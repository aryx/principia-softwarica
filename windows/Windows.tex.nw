\documentclass[twocolumn]{report}

%******************************************************************************
% Prelude
%******************************************************************************
\newif\iffinal
\newif\ifverbose
\finaltrue\verbosefalse
% see also other newif in Macros.tex

%------------------------------------------------------------------------------
%history: 
%------------------------------------------------------------------------------

%thx to LP, changed for the better a few things:
% - removed deadcode (Qnew, threadrforkflag)

%thx to codemap/codegraph/scheck:
% - use cg to reduce backward deps, introduce globals.c, utils.c,
%   (harder to understand non layered code)
% - use scheck to remove deadcode, dead prototypes, useless export
%   or mv as forward decl
%   (harder to understand big interface files)
% - TODO use cg to reduce number of globals by moving them closer to the
%   relevant file (or even function), better cluster the code
%   (harder to understand non functional code using lots of globals)

%thx to this manual, better understand X11?:

%history LP-ization:
% - skeleton, mostly copy paste of Template.tex.nw skeleton
% - put all content of files in the Extra section, via 'pfff -lpize'
%   which also now split in chunks!
%    * function, global, struct, enum, constant, macro(actually function)
%    * TODO ctor/dtor, dumper
%    * TODO [[xxx]] other fields, [[xxx]] extra fields
% - read Extra section, identify concepts, first TOC
% - SEMI distribute parts of the Extra section in the main file
% - understand main(), LP split main, improve TOC
% - understand main functions, LP split, cluster, improve TOC
% - SEMI LP split the structures, use datalog for flow to field info
% - SEMI nullify, boolify, errorify, enumify,  typeify,    scheckify, plan9ify
% - SEMI aspecify advanced features! remove useless features
% - TODO add figures
% - TODO add explanations

%------------------------------------------------------------------------------
% Packages
%------------------------------------------------------------------------------

\usepackage{../docs/latex/noweb}
 \noweboptions{footnotesizecode,nomargintag}
 %note: allow chunk on different pages, less white space at bottom of pages
 \def\nwendcode{\endtrivlist \endgroup}
 \let\nwdocspar=\par
\usepackage{xspace}
\usepackage{verbatim}
%note: required by noweblatexpad for the \t \l \n in this file
\usepackage{fancyvrb}
\usepackage{url}
\iffinal
\usepackage{hyperref}
 \hypersetup{colorlinks=true}
\fi
\usepackage[pageref]{backref}
 \def\backref{{\footnotesize cited page(s)}~}
%\usepackage{cleveref} %\cref
%\usepackage{multirow}
\usepackage{booktabs} 
 \newcommand{\otoprule}{\midrule[\heavyrulewidth]}
\usepackage{graphicx}
 %\usepackage[margin=0.5in]{geometry}
 %  but eat the bottom when very low
 %\usepackage{fullpage} is deprecated 
 % => do the more manual below:
 \addtolength{\oddsidemargin}{-.850in}
 \addtolength{\evensidemargin}{-.850in}
 \addtolength{\textwidth}{1.70in}
 \addtolength{\topmargin}{-.850in}
 \addtolength{\textheight}{1.70in}
%\usepackage{minitoc}

%------------------------------------------------------------------------------
% Macros
%------------------------------------------------------------------------------
\input{../docs/latex/Macros}

%------------------------------------------------------------------------------
% Config
%------------------------------------------------------------------------------
\allcodefalse
% used for forward decl, pragmas, func decl, extern decl, stats, #ifdef,
% debugging macros

%\setcounter{tocdepth}{1}

%******************************************************************************
% Title
%******************************************************************************

\begin{document}

\title{
{\Huge 
Principia Softwarica: Plan9 Windowing System [[rio]]
}\\
{version 0.1}
}

\author{
Yoann Padioleau\\
\texttt{yoann.padioleau@gmail.com}
}

\maketitle 
\onecolumn
\hrule
\begin{quote}
    Copyright \copyright{} 2014 Yoann Padioleau \\
    Permission is granted to copy, distribute and/or modify this document,
    except all the source code it contains, under the terms of the GNU Free
    Documentation License, Version 1.3.
\end{quote}
\hrule

%CONFIG: \dominitoc

\iffinal
\begingroup
\hypersetup{linkcolor=blue}
% need to s/onecolumn/twocolumn in report.cls :) for \tableofcontents
\twocolumn
\tableofcontents
\endgroup
\else
\tableofcontents
\fi

%******************************************************************************
% Body
%******************************************************************************

\chapter{Introduction}

\section{Motivations}

The goal of this book is to present in full details the source code of
a real windowing system.
Why? Because I think it makes you a better programmer if
you fully understand how things work under the hood.

Here are other candidates that were considered but ultimately discarded:
\begin{itemize}
\item X11
% the obvious choice
\item Mini X
\item Nano X (MicroWindows)
\item Wayland
\end{itemize}
% nuttx has some graphic and windowing stack apparently too!

%nice set of screenshots of past famous GUIs:
%http://toastytech.com/guis/
%http://toastytech.com/guis/guitimeline.html

% history me: 
%  - tos, sega yeno, atari GEM, dos, windows 3.11
%  - one Linux terminal
%  - job control shell! (otherwise multi tasking OS but just one term so ...)
%  - multi terminal Alt-Fx on Linux
%  - screen or tux programs
%  - X11 and xterm with as many windows you want!
%  - FVWM fast key to many terminals
%  - Emacs eshell fast key to many terminals
%  - virtual desktops
%  - MacOS expose! bird's eye view

\section{Getting started}

\section{Requirements}

% rio.ps
% rio(1) and rio(5), also draw(2?)

\section{About this document}
#include "../docs/latex/About.tex.nw"

\section{Copyright}

Most of this document is actually source code from Plan9, so
those parts are copyright by Lucent Technologies Inc.
The prose is mine and is licensed under the GNU Free Documentation
License.

\section{Acknowledgments}

%Rob pike obviously, rio's author (and its precursors 81/2, ...)

\chapter{Overview}

\section{Windowing system principles}

% a screen demultiplexer essentially! toy app run outside rio
% but with rio can have "virtual" screen.
% can also have virtual keyboard/mouse
% also a window manager! mv/resize/close/hide/etc menus, a visual shell!

\section{[[rio]] services}
% the interface!  again the /dev/xxx ?

<<function usage>>=
void
usage(void)
{
    fprint(2, "usage: rio [-f font] [-i initcmd] [-k kbdcmd] [-s]\n");
    exits("usage");
}
@

% once run have full screen, with right menu to start things.

% also have fileserver to offer a virtual view for the apps running
% inside the windows

%$wsys
%$wctl

%/mnt/wsys (unioned also in /dev)
%cons, consctl
%mouse %kbdin
%screen window
%text
%cursor
%label, winid, winname  wdir
%snarf
%wctl 
%wsys/1/

%/srv
%rio.user.pid
%riowctl.user.pid

% mount #s/rio.user.pid /mnt/wsys 1
% mount -b #s/rio.user.pid /dev


% $rio
% manual creation of window (not via menu)
% (see rio(5)
% mount $wsys /tmp 'new -r 0 0 128 64 -pid' $pid
% echo hi > /tmp/cons
% :)


% can run rio inside rio!


%\section{YYY file format}
%rio(5)?

%\section{ZZZ Toy example}
%??

\section{Code organization}

% for the graphic system part see Graphics.tex.nw

%dat.h: data structure and global declarations
%fns.h: prototypes

%globals.c
%data.c: cursors, images, resources

%util.c: helpers

%wind.c: windows manip
%wctl.c: windows control
%fsys.c: /dev/ server
%xfid.c: /dev/ services
%time.c: timer thread
%scrl.c: scrolling
%rio.c: main


\section{Architecture overview}

% kernel driver vs graphic libs vs rio vs graphical apps

% /dev/draw (core one) vs /dev/draw (fake one to clients)
% /dev/mouse, /dev/cons
% /dev/cursor

% see 81/2.ps and rio.ps
% see also panel.pdf

% part1: windows (rio)
% part2: toolkit (libpanel)


% there are DS server side and client side.
% Window is server side info about client window. On the client
% side this window is actually stored in a handle called screen
% (and also have different services in /dev/ like /dev/winname)

% show the different threads! threadmain, mouse, keyboard, and windows threads!
% (as well as close, delete, and xfids)

% actually also have different processes! winshell, timer, and the main rio one

% each window is a thread! when keydown the keyboard thread is triggered
% (it was waiting in the event loop in a recv() on /dev/cons probably in raw
% mode), and send the character
% to the input window channel, and the thread corresponding to this window
% who should wait for many channels should be awaken by the thread scheduler
% to process the keyboard input and act on it.

% switch(alt(alts)) { event loop in many threads (mouse, winctl, etc)

% menu3 -> xxx() -> wsendctlmesg(w, xxxd) -> send(w->cctl, xxxd) -> winctl thread awake -> wxxx()
% or sometimes xxx() -> wxxx() directly like for whide() because reuse
% an existing Wctlmsg (e.g. Reshaped)


% filsysxxx -> xfidxxx -> wxxx


%http://tech.slashdot.org/story/14/06/19/1317227/x-window-system-turns-30-years-old?utm_source=slashdot&utm_medium=facebook
%"A server lets clients access a shared resource. On a file server, it's
%storage. On a web server, it's documents. On a compute server, it's
%processing. On an X server, the shared resource is the display, and
%clients are given access to it."


\section{Trace of a mouse click}
% event! find right window, dispatch

%###############################################################################

\chapter{Core Data Structures}

% core DS of rio, the server side view!
% core DS of client apps? similar actually but demultiplex from original one!

\section{Device handlers, [[display]], [[screen]], etc}

%draw.h
%Display	*display; // set by initdraw()
%Image          *screen; // should be renamed window! really TODO?
% = point to the portion of the display for this window
% but for rio it's really the whole screen (unless run recursively)

% so windows are represented as Image pointer. Really a subclass
% of Image with additional methods like originwindow().

%Font		*font;

%display = draw
%screen = current image memory in current display
%window = ? 

% this is DS wrapper on top of /dev/draw

%\section{[[view]], [[mousectl]], [[keyboardctl]], etc}

<<global view>>=
Image	*view;
@
% = screen global, initialized in main()

<<global viewr>>=
Rectangle	viewr;
@
%view->r




% keyboard.h
<<global keyboardctl>>=
Keyboardctl	*keyboardctl;
@
% wrapper over /dev/cons in raw mode probably

% mouse.h
<<global mousectl>>=
Mousectl	*mousectl;
@
% wrapper over /dev/mouse

<<global mouse>>=
Mouse	*mouse;
@
% = mousectl._anon_Mouse






<<global background>>=
Image	*background;
@

<<global wscreen>>=
Screen	*wscreen;
@
% = allocscreen(screen, background)
% will get code like
%    switch(i = menuhit(3, mousectl, &menu3, wscreen)){
% so make sense? what is wscreen?




<<global red>>=
Image	*red;
@
% when moving around windows, the frame become red!
%//Image	*lightgrey;




\section{[[Window]], [[window]], and [[input]]}

<<struct Window>>=
struct Window
{
    int		id;
    char	*label;
    Frame;

    Image	*i;
    /*
     * Rio once used originwindow, so screenr could be different from i->r.
     * Now they're always the same but the code doesn't assume so.
    */
    Rectangle	screenr; /* screen coordinates of window */

    Mousectl	mc; // mc->c is the mouse event listening channel
    Channel	*ck;		/* chan(Rune[10]) */
    Channel	*cctl;		/* chan(Wctlmesg)[20] */

    bool_byte	deleted;

    <<[[Window]] other fields>>

    <<[[Window]] extra fields>>
};
@
% screenr is ZR when hidden


<<[[Window]] extra fields>>=
Ref;
@
% when middle click on a window we want to keep it alive!
% don't want someone else via /dev/... to delete it yet, otherwise
% will get segfault if try to access some fields of this window!

<<[[Window]] extra fields>>=
QLock;
@
% need? threads are cooperatif so can have race??
% have different process though

%XXXXX
<<[[Window]] other fields>>=
Mouseinfo	mouse;
Channel		*conswrite;	/* chan(Conswritemesg) */
Channel		*consread;	/* chan(Consreadmesg) */
Channel		*mouseread;	/* chan(Mousereadmesg) */
Channel		*wctlread;	/* chan(Consreadmesg) */
uint		nr;	/* number of runes in window */
uint		maxr;	/* number of runes allocated in r */
Rune		*r;
uint		nraw;
Rune		*raw;
uint		org;
uint		q0;
uint		q1;
uint		qh;
char		name[32];
uint		namecount;
Rectangle	scrollr;
int	 	resized;
int	 	wctlready;
Rectangle	lastsr;
int	 	topped;
int	 	notefd;
uchar		scrolling;
Cursor		cursor;
Cursor		*cursorp;
uchar		holding;
uchar		rawing;
uchar		ctlopen;
uchar		wctlopen;
uchar		mouseopen;
int		pid;
char		*dir;
@

% grown in wmk()
<<global window>>=
//array<option<ref_own<Window>>>
Window	**window;
@

% next free window
<<global nwindow>>=
int		nwindow;
@

% counter
<<global id>>=
static	int		id;
@


% the current window? the one with the focus getting the keyboard events?
<<global input>>=
//option<ref<Window>>, the window with the focus! the window to send input to
Window	*input;
@

<<global hidden>>=
Window	*hidden[100];
@
% hidden windows

<<global nhidden>>=
int		nhidden;
@



%ctor!
% cmd is usually /bin/rc
%        new(sweep(), false, scrolling, 0, nil, "/bin/rc", nil); => pid is 0
% when from the menu!
<<function new>>=
Window*
new(Image *i, bool hideit, bool scrollit, int pid, char *dir, char *cmd, char **argv)
{
    Window *w;
    Mousectl *mc;
    Channel *cm, *ck, *cctl, *cpid;
    void **arg;

    if(i == nil)
        return nil;

    cm = chancreate(sizeof(Mouse), 0);
    ck = chancreate(sizeof(Rune*), 0);
    cctl = chancreate(sizeof(Wctlmesg), 4);
    cpid = chancreate(sizeof(int), 0);
    if(cm==nil || ck==nil || cctl==nil)
        error("new: channel alloc failed");

    mc = emalloc(sizeof(Mousectl));
    *mc = *mousectl;
    mc->image = i;
    mc->c = cm;
    w = wmk(i, mc, ck, cctl, scrollit);
    free(mc);	/* wmk copies *mc */

    // growing array
    window = erealloc(window, ++nwindow*sizeof(Window*));
    window[nwindow-1] = w;
    if(hideit){
        hidden[nhidden++] = w;
        w->screenr = ZR;
    }

    // a new thread! for this new window!
    threadcreate(winctl, w, 8192);
    if(!hideit)
        wcurrent(w);

    flushimage(display, true);

    <<[[new()]] if pid == 0>>

    wsetpid(w, pid, true);
    wsetname(w);
    if(dir)
        w->dir = estrdup(dir);
    chanfree(cpid);
    return w;
}
@

<<global rcargv>>=
char *rcargv[] = { "rc", "-i", nil };
@

%when new from the system menu
<<[[new()]] if pid == 0>>=
if(pid == 0){
    arg = emalloc(5*sizeof(void*));
    arg[0] = w;
    arg[1] = cpid;
    arg[2] = cmd;
    if(argv == nil)
        arg[3] = rcargv;
    else
        arg[3] = argv;
    arg[4] = dir;
    proccreate(winshell, arg, 8192);
    pid = recvul(cpid);
    free(arg);
}
if(pid == 0){
    /* window creation failed */
    wsendctlmesg(w, Deleted, ZR, nil);
    chanfree(cpid);
    return nil;
}
@


<<enum _anon_ (windows/rio/dat.h)3>>=
enum
{
    Selborder		= 4,	/* border of selected window */
    Unselborder		= 1,	/* border of unselected window */
    Scrollwid 		= 12,	/* width of scroll bar */
    Scrollgap 		= 4,	/* gap right of scroll bar */
    BIG			= 3,	/* factor by which window dimension can exceed screen */
};
@


<<function wmk>>=
Window*
wmk(Image *i, Mousectl *mc, Channel *ck, Channel *cctl, bool scrolling)
{
    Window *w;
    Rectangle r;

    <<[[wmk()]] cols initialisation>>

    w = emalloc(sizeof(Window));

    w->screenr = i->r;
    r = insetrect(i->r, Selborder+1);
    w->i = i;
    w->mc = *mc;
    w->ck = ck;
    w->cctl = cctl;
    w->cursorp = nil;

    w->conswrite = chancreate(sizeof(Conswritemesg), 0);
    w->consread =  chancreate(sizeof(Consreadmesg), 0);
    w->mouseread =  chancreate(sizeof(Mousereadmesg), 0);
    w->wctlread =  chancreate(sizeof(Consreadmesg), 0);

    w->scrollr = r;
    w->scrollr.max.x = r.min.x+Scrollwid;
    w->lastsr = ZR;
    r.min.x += Scrollwid+Scrollgap;

    frinit(w, r, font, i, cols);

    w->maxtab = maxtab*stringwidth(font, "0");
    w->topped = ++topped;
    w->id = ++id;
    w->notefd = -1;
    w->scrolling = scrolling;
    w->dir = estrdup(startdir);
    w->label = estrdup("<unnamed>");
    r = insetrect(w->i->r, Selborder);

    draw(w->i, r, cols[BACK], nil, w->entire.min);
    wborder(w, Selborder);
    wscrdraw(w);
    incref(w);	/* ref will be removed after mounting; avoids delete before ready to be deleted */
    return w;
}
@

% dtor?
<<function wclose>>=
int
wclose(Window *w)
{
    int i;

    i = decref(w);
    if(i > 0)
        return 0;

    if(i < 0)
        error("negative ref count");
    if(!w->deleted)
        wclosewin(w);
    wsendctlmesg(w, Exited, ZR, nil);
    return 1;
}
@

<<function wclosewin>>=
void
wclosewin(Window *w)
{
    Rectangle r;
    int i;

    w->deleted = true;

    if(w == input){
        input = nil;
        wsetcursor(w, 0);
    }
    if(w == wkeyboard)
        wkeyboard = nil;

    for(i=0; i<nhidden; i++)
        if(hidden[i] == w){
            --nhidden;
            memmove(hidden+i, hidden+i+1, (nhidden-i)*sizeof(hidden[0]));
            hidden[nhidden] = nil;
            break;
        }
    for(i=0; i<nwindow; i++)
        if(window[i] == w){
            --nwindow;
            memmove(window+i, window+i+1, (nwindow-i)*sizeof(Window*));
            w->deleted = true; // again??
            r = w->i->r;
            /* move it off-screen to hide it, in case client is slow in letting it go */
            //if(0) originwindow(w->i, r.min, view->r.max);
            freeimage(w->i);
            w->i = nil;
            return;
        }
    error("unknown window in closewin");
}
@


\section{[[Frame]]}

% layers!
<<enum _anon_ (include/frame.h)>>=
enum{
    BACK,
    HIGH,
    BORD,
    TEXT,
    HTEXT,

    NCOL
};
@

<<struct Frame>>=
struct Frame
{
    Font	*font;		/* of chars in the frame */
    Display	*display;	/* on which frame appears */
    Image	*b;		/* on which frame appears */
    Image	*cols[NCOL];	/* text and background colors */

    Rectangle	r;		/* in which text appears */
    Rectangle	entire;		/* of full frame */

    void			(*scroll)(Frame*, int);	/* scroll function provided by application */

    Frbox	*box;

    ulong	p0, p1;		/* selection */
    ushort	nbox, nalloc;
    ushort	maxtab;		/* max size of tab, in pixels */
    ushort	nchars;		/* # runes in frame */
    ushort	nlines;		/* # lines with text */
    ushort	maxlines;	/* total # lines in frame */
    ushort	lastlinefull;	/* last line fills frame */
    ushort	modified;	/* changed since frselect() */
    Image	*tick;	/* typing tick */
    Image	*tickback;	/* saved image under tick */
    int		ticked;	/* flag: is tick onscreen? */
};
@


%images of the frame
<<global cols>>=
static	Image	*cols[NCOL];
@


<<global grey>>=
static	Image	*grey;
@

<<global darkgrey>>=
static	Image	*darkgrey;
@

<<global titlecol>>=
static	Image	*titlecol;
@

<<global lighttitlecol>>=
static	Image	*lighttitlecol;
@

<<global holdcol>>=
static	Image	*holdcol;
@

<<global lightholdcol>>=
static	Image	*lightholdcol;
@

<<global paleholdcol>>=
static	Image	*paleholdcol;
@


<<[[wmk()]] cols initialisation>>=
if(cols[0] == nil){
    /* greys are multiples of 0x11111100+0xFF, 14* being palest */
    grey = allocimage(display, Rect(0,0,1,1), CMAP8, 1, 0xEEEEEEFF);
    darkgrey = allocimage(display, Rect(0,0,1,1), CMAP8, 1, 0x666666FF);
    cols[BACK] = display->white;
    cols[HIGH] = allocimage(display, Rect(0,0,1,1), CMAP8, 1, 0xCCCCCCFF);
    cols[BORD] = allocimage(display, Rect(0,0,1,1), CMAP8, 1, 0x999999FF);
    cols[TEXT] = display->black;
    cols[HTEXT] = display->black;
    titlecol = allocimage(display, Rect(0,0,1,1), CMAP8, 1, DGreygreen);
    lighttitlecol = allocimage(display, Rect(0,0,1,1), CMAP8, 1, DPalegreygreen);
    holdcol = allocimage(display, Rect(0,0,1,1), CMAP8, 1, DMedblue);
    lightholdcol = allocimage(display, Rect(0,0,1,1), CMAP8, 1, DGreyblue);
    paleholdcol = allocimage(display, Rect(0,0,1,1), CMAP8, 1, DPalegreyblue);
}
@

% libframe/
% ... -> new -> wmk() -> <>
<<function frinit>>=
void
frinit(Frame *f, Rectangle r, Font *ft, Image *b, Image *cols[NCOL])
{
    f->font = ft;
    f->display = b->display;
    f->maxtab = 8*stringwidth(ft, "0");
    f->nbox = 0;
    f->nalloc = 0;
    f->nchars = 0;
    f->nlines = 0;
    f->p0 = 0;
    f->p1 = 0;
    f->box = 0;
    f->lastlinefull = 0;
    if(cols != 0)
        memmove(f->cols, cols, sizeof f->cols);
    frsetrects(f, r, b);
    if(f->tick==nil && f->cols[BACK]!=0)
        frinittick(f);
}
@




%XXX ?
<<struct Frbox>>=
struct Frbox
{
    long		wid;		/* in pixels */
    long		nrune;		/* <0 ==> negate and treat as break char */
    union{
        uchar	*ptr;
        struct{
            short	bc;	/* break char */
            short	minwid;
        };
    };
};
@

\section{[[FilSys]], [[Fid]], [[Xfid]] and [[filsys]]}

<<constant Nhash>>=
#define Nhash 16
@

<<struct Filsys>>=
struct Filsys
{
    int		cfd;
    int		sfd;

    int		pid;

    char	*user;

    Channel	*cxfidalloc;	/* chan(Xfid*) */
    Fid		*fids[Nhash];
};
@

<<global filsys>>=
Filsys	*filsys;
@


<<struct Fid>>=
struct Fid
{
    int		fid;

    int		busy;
    int		open;
    int		mode;

    Qid		qid;

    Window	*w;
    Dirtab	*dir;
    Fid		*next;
    int		nrpart;
    uchar	rpart[UTFmax];
};
@


% ctor
<<function newfid>>=
static
Fid*
newfid(Filsys *fs, int fid)
{
    Fid *f, *ff, **fh;

    ff = nil;
    fh = &fs->fids[fid&(Nhash-1)];
    for(f=*fh; f; f=f->next)
        if(f->fid == fid)
            return f;
        else if(ff==nil && f->busy==false)
            ff = f;
    if(ff){
        ff->fid = fid;
        return ff;
    }
    f = emalloc(sizeof *f);
    f->fid = fid;
    f->next = *fh;
    *fh = f;
    return f;
}
@



%\section{[[Xfid]]}

<<struct Xfid>>=
struct Xfid
{
        Ref;
        Xfid	*next;
        Xfid	*free;
        Fcall;
        Channel	*c;	/* chan(void(*)(Xfid*)) */

        Fid	*f;

        uchar	*buf;

        Filsys	*fs;

        QLock	active;
        int	flushing;	/* another Xfid is trying to flush us */
        int	flushtag;	/* our tag, so flush can find us */
        Channel	*flushc;/* channel(int) to notify us we're being flushed */
};
@





\chapter{[[main()]]}
% actually it's threadmain()

\ifallcode
<<[[main()]] locals>>=
char *s;
char buf[256];
@
\fi
%dead? static void *arg[1];

%    //PAD: let's keep the Exit option!
%    //PAD: if(strstr(argv[0], ".out") == nil){
%    //PAD: 	menu3str[Exit] = nil;
%    //PAD: 	Hidden--;
%    //PAD: }

<<function threadmain>>=
//@Scheck: not dead, called by lib_thread probably
void threadmain(int argc, char *argv[])
{
    <<[[main()]] locals>>

    ARGBEGIN{
    <<[[main()]] command line processing>>
    }ARGEND

    <<[[main()]] set some globals>>
    <<[[main()]] set snarffd>>

    if(geninitdraw(nil, derror, nil, "rio", nil, Refnone) < 0){
        fprint(2, "rio: can't open display: %r\n");
        exits("display open");
    }

    view = screen;
    viewr = view->r;

    iconinit(); // allocate background and red images

    <<[[main()]] mouse initialisation>>
    <<[[main()]] keyboard initialisation>>

    wscreen = allocscreen(screen, background, 0);
    if(wscreen == nil)
        error("can't allocate screen");
    
    draw(view, viewr, background, nil, ZP);
    flushimage(display, true);

    <<[[main()]] communication channels creation>>
    <<[[main()]] threads creation>>

    filsys = filsysinit(xfidinit());

    if(filsys == nil)
        fprint(2, "rio: can't create file system server: %r\n");
    else{
        errorshouldabort = true;/* suicide if there's trouble after this */
        <<[[main()]] if initstr or kdbin>>
        threadnotify(shutdown, 1);
        recv(exitchan, nil);
    }
    killprocs();
    threadexitsall(nil);
}
@

% diff geninitdraw vs initdraw? defaults different for ref? Refnone?

\section{Graphics initialisation}

<<function iconinit>>=
void
iconinit(void)
{
    background = allocimage(display, Rect(0,0,1,1), RGB24, 1, 0x777777FF);
    red        = allocimage(display, Rect(0,0,1,1), RGB24, 1, 0xDD0000FF);
}
@
% is it really a red?
% why iconinit? icon??

\section{Mouse initialisation}

<<[[main()]] mouse initialisation>>=
mousectl = initmouse(nil, screen);
if(mousectl == nil)
    error("can't find mouse");
mouse = mousectl;
@

\section{Keyboard initialisation}

<<[[main()]] keyboard initialisation>>=
keyboardctl = initkeyboard(nil);
if(keyboardctl == nil)
    error("can't find keyboard");
@

%<<[[main()]] wscreen initialisation>>=
%@


\section{Channels creation}

<<global exitchan>>=
Channel	*exitchan;	/* chan(int) */
@

% rio = waiting for many different kind of "events"
<<[[main()]] communication channels creation>>=
exitchan = chancreate(sizeof(int), 0);
winclosechan = chancreate(sizeof(Window*), 0);
deletechan = chancreate(sizeof(char*), 0);
@

\section{Threads creation}

<<constant STACK>>=
#define	STACK	8192
@

<<[[main()]] threads creation>>=
timerinit();
threadcreate(keyboardthread, nil, STACK);
threadcreate(mousethread, nil, STACK);

threadcreate(winclosethread, nil, STACK);
threadcreate(deletethread, nil, STACK);
@


<<global cxfidalloc>>=
static	Channel	*cxfidalloc;	/* chan(Xfid*) */
@

<<global cxfidfree>>=
static	Channel	*cxfidfree;	/* chan(Xfid*) */
@

<<function xfidinit>>=
Channel*
xfidinit(void)
{
    cxfidalloc = chancreate(sizeof(Xfid*), 0);
    cxfidfree = chancreate(sizeof(Xfid*), 0);
    threadcreate(xfidallocthread, nil, STACK);
    return cxfidalloc;
}
@



\section{Misc}

% dead? written but never read
<<global mainpid>>=
int		mainpid;
@

<<[[main()]] set some globals>>=
mainpid = getpid();
@





<<global startdir>>=
char		*startdir;
@

<<[[main()]] set some globals>>=
if(getwd(buf, sizeof buf) == nil)
    startdir = estrdup(".");
else
    startdir = estrdup(buf);
@





<<global maxtab>>=
int		maxtab = 0;
@

<<[[main()]] set some globals>>=
s = getenv("tabstop");
if(s != nil)
    maxtab = strtol(s, nil, 0);
if(maxtab == 0)
    maxtab = 4;
free(s);
@



\chapter{Threads}
% see rio presentation with architecture

\section{Keyboard thread}

% the channel is keyboardctl->c, see keyboard.h
% it's initialized in main()

<<function keyboardthread>>=
void
keyboardthread(void*)
{
    Rune buf[2][20], *rp;
    int n, i;

    threadsetname("keyboardthread");
    n = 0;
    for(;;){
        rp = buf[n];
        n = 1-n;
        recv(keyboardctl->c, rp);
        for(i=1; i<nelem(buf[0])-1; i++)
            if(nbrecv(keyboardctl->c, rp+i) <= 0)
                break;
        rp[i] = L'\0';

        if(input != nil)
            sendp(input->ck, rp);
    }
}
@

\section{Mouse thread}

<<enum Mxxx>>=
enum {
    MReshape,
    MMouse,

    NALT
};
@

<<global sweeping>>=
bool	sweeping;
@

<<function mousethread>>=
void
mousethread(void*)
{
    bool sending, inside, scrolling, moving, band;
    Window *oin, *w, *winput;
    Image *i;
    Rectangle r;
    Point xy;
    Mouse tmp;
    static Alt alts[NALT+1];

    threadsetname("mousethread");
    sending = false;
    scrolling = false;
    moving = false;

    alts[MReshape].c = mousectl->resizec;
    alts[MReshape].v = nil;
    alts[MReshape].op = CHANRCV;
    alts[MMouse].c = mousectl->c;
    alts[MMouse].v = &mousectl->Mouse;
    alts[MMouse].op = CHANRCV;
    alts[NALT].op = CHANEND;

    for(;;)
        // event loop
        switch(alt(alts)){
        case MReshape:
            resized();
            break;
        case MMouse:
            if(wkeyboard!=nil && (mouse->buttons & (1<<5))){
                keyboardhide();
                break;
            }
        Again:
            winput = input;
            /* override everything for the keyboard window */
            if(wkeyboard!=nil && ptinrect(mouse->xy, wkeyboard->screenr)){
                /* make sure it's on top; this call is free if it is */
                wtopme(wkeyboard);
                winput = wkeyboard;
            }
            if(winput!=nil && winput->i!=nil){
                /* convert to logical coordinates */
                xy.x = mouse->xy.x + (winput->i->r.min.x-winput->screenr.min.x);
                xy.y = mouse->xy.y + (winput->i->r.min.y-winput->screenr.min.y);

                /* the up and down scroll buttons are not subject to the usual rules */
                if((mouse->buttons&(8|16)) && !winput->mouseopen)
                    goto Sending;

                inside = ptinrect(mouse->xy, insetrect(winput->screenr, Selborder));
                if(winput->mouseopen)
                    scrolling = false;
                else if(scrolling)
                    scrolling = mouse->buttons;
                else
                    scrolling = mouse->buttons && ptinrect(xy, winput->scrollr);
                /* topped will be zero or less if window has been bottomed */
                if(sending == false && !scrolling && winborder(winput, mouse->xy) && winput->topped>0){
                    moving = true;
                }else if(inside && (scrolling || winput->mouseopen || (mouse->buttons&1)))
                    sending = true;
            }else
                sending = false;
            if(sending){
            Sending:
                if(mouse->buttons == 0){
                    cornercursor(winput, mouse->xy, 0);
                    sending = false;
                }else
                    wsetcursor(winput, 0);
                tmp = mousectl->Mouse;
                tmp.xy = xy;
                send(winput->mc.c, &tmp);
                continue;
            }
            w = wpointto(mouse->xy);
            /* change cursor if over anyone's border */
            if(w != nil)
                cornercursor(w, mouse->xy, 0);
            else
                riosetcursor(nil, 0);
            if(moving && (mouse->buttons&7)){
                oin = winput;
                band = mouse->buttons & 3;
                sweeping = true;
                if(band)
                    i = bandsize(winput);
                else
                    i = drag(winput, &r);
                sweeping = false;
                if(i != nil){
                    if(winput == oin){
                        if(band)
                            wsendctlmesg(winput, Reshaped, i->r, i);
                        else
                            wsendctlmesg(winput, Moved, r, i);
                        cornercursor(winput, mouse->xy, 1);
                    }else
                        freeimage(i);
                }
            }
            if(w != nil)
                cornercursor(w, mouse->xy, 0);
            /* we're not sending the event, but if button is down maybe we should */
            if(mouse->buttons){
                /* w->topped will be zero or less if window has been bottomed */
                if(w==nil || (w==winput && w->topped>0)){
                    if(mouse->buttons & 1){
                        ;
                    }else if(mouse->buttons & 2){
                        if(winput && !winput->mouseopen)
                            button2menu(winput);
                    }else if(mouse->buttons & 4)
                        button3menu();
                }else{
                    /* if button 1 event in the window, top the window and wait for button up. */
                    /* otherwise, top the window and pass the event on */
                    if(wtop(mouse->xy) && (mouse->buttons!=1 || winborder(w, mouse->xy)))
                        goto Again;
                    goto Drain;
                }
            }
            moving = false;
            break;

        Drain:
            do
                readmouse(mousectl);
            while(mousectl->buttons);
            moving = false;
            goto Again;	/* recalculate mouse position, cursor */
        }
}
@



\section{Windows threads}

<<enum Wxxx>>=
enum { 
    WKey, 
    WMouse, 
    WMouseread, 

    WCtl, //!!!

    WCwrite, 
    WCread, 
    WWread, 

    NWALT 
};
@

% right click -> button3menu() -> new() -> threadcreate(<>)
<<function winctl>>=
void
winctl(void *arg)
{
    Rune *rp, *bp, *tp, *up, *kbdr;
    uint qh;
    int nr, nb, c, wid, i, npart, initial, lastb;
    char *s, *t, part[3];
    Window *w;
    Mousestate *mp, m;
    Alt alts[NWALT+1];
    Mousereadmesg mrm;
    Conswritemesg cwm;
    Consreadmesg crm;
    Consreadmesg cwrm;
    Stringpair pair;
    Wctlmesg wcm;
    char buf[4*12+1];

    w = arg;
    snprint(buf, sizeof buf, "winctl-id%d", w->id);
    threadsetname(buf);

    mrm.cm = chancreate(sizeof(Mouse), 0);
    cwm.cw = chancreate(sizeof(Stringpair), 0);
    crm.c1 = chancreate(sizeof(Stringpair), 0);
    crm.c2 = chancreate(sizeof(Stringpair), 0);
    cwrm.c1 = chancreate(sizeof(Stringpair), 0);
    cwrm.c2 = chancreate(sizeof(Stringpair), 0);
    

    alts[WKey].c = w->ck;
    alts[WKey].v = &kbdr;
    alts[WKey].op = CHANRCV;
    alts[WMouse].c = w->mc.c;
    alts[WMouse].v = &w->mc.Mouse;
    alts[WMouse].op = CHANRCV;
    alts[WMouseread].c = w->mouseread;
    alts[WMouseread].v = &mrm;
    alts[WMouseread].op = CHANSND;
    alts[WCtl].c = w->cctl;
    alts[WCtl].v = &wcm;
    alts[WCtl].op = CHANRCV;
    alts[WCwrite].c = w->conswrite;
    alts[WCwrite].v = &cwm;
    alts[WCwrite].op = CHANSND;
    alts[WCread].c = w->consread;
    alts[WCread].v = &crm;
    alts[WCread].op = CHANSND;
    alts[WWread].c = w->wctlread;
    alts[WWread].v = &cwrm;
    alts[WWread].op = CHANSND;
    alts[NWALT].op = CHANEND;

    npart = 0;
    lastb = -1;
    for(;;){
        if(w->mouseopen && w->mouse.counter != w->mouse.lastcounter)
            alts[WMouseread].op = CHANSND;
        else
            alts[WMouseread].op = CHANNOP;
        if(!w->scrolling && !w->mouseopen && w->qh>w->org+w->nchars)
            alts[WCwrite].op = CHANNOP;
        else
            alts[WCwrite].op = CHANSND;
        if(w->deleted || !w->wctlready)
            alts[WWread].op = CHANNOP;
        else
            alts[WWread].op = CHANSND;
        /* this code depends on NL and EOT fitting in a single byte */
        /* kind of expensive for each loop; worth precomputing? */
        if(w->holding)
            alts[WCread].op = CHANNOP;
        else if(npart || (w->rawing && w->nraw>0))
            alts[WCread].op = CHANSND;
        else{
            alts[WCread].op = CHANNOP;
            for(i=w->qh; i<w->nr; i++){
                c = w->r[i];
                if(c=='\n' || c=='\004'){
                    alts[WCread].op = CHANSND;
                    break;
                }
            }
        }

        // event loop
        switch(alt(alts)){
        case WKey:
            for(i=0; kbdr[i]!=L'\0'; i++)
                wkeyctl(w, kbdr[i]);
//			wkeyctl(w, r);
///			while(nbrecv(w->ck, &r))
//				wkeyctl(w, r);
            break;
        case WMouse:
            if(w->mouseopen) {
                w->mouse.counter++;

                /* queue click events */
                if(!w->mouse.qfull && lastb != w->mc.buttons) {	/* add to ring */
                    mp = &w->mouse.queue[w->mouse.wi];
                    if(++w->mouse.wi == nelem(w->mouse.queue))
                        w->mouse.wi = 0;
                    if(w->mouse.wi == w->mouse.ri)
                        w->mouse.qfull = true;
                    mp->Mouse = w->mc;
                    mp->counter = w->mouse.counter;
                    lastb = w->mc.buttons;
                }
            } else
                wmousectl(w);
            break;
        case WMouseread:
            /* send a queued event or, if the queue is empty, the current state */
            /* if the queue has filled, we discard all the events it contained. */
            /* the intent is to discard frantic clicking by the user during long latencies. */
            w->mouse.qfull = false;
            if(w->mouse.wi != w->mouse.ri) {
                m = w->mouse.queue[w->mouse.ri];
                if(++w->mouse.ri == nelem(w->mouse.queue))
                    w->mouse.ri = 0;
            } else
                m = (Mousestate){w->mc.Mouse, w->mouse.counter};

            w->mouse.lastcounter = m.counter;
            send(mrm.cm, &m.Mouse);
            continue;
        case WCtl:
            if(wctlmesg(w, wcm.type, wcm.r, wcm.image) == Exited){
                chanfree(crm.c1);
                chanfree(crm.c2);
                chanfree(mrm.cm);
                chanfree(cwm.cw);
                chanfree(cwrm.c1);
                chanfree(cwrm.c2);
                threadexits(nil);
            }
            continue;
        case WCwrite:
            recv(cwm.cw, &pair);
            rp = pair.s;
            nr = pair.ns;
            bp = rp;
            for(i=0; i<nr; i++)
                if(*bp++ == '\b'){
                    --bp;
                    initial = 0;
                    tp = runemalloc(nr);
                    runemove(tp, rp, i);
                    up = tp+i;
                    for(; i<nr; i++){
                        *up = *bp++;
                        if(*up == '\b')
                            if(up == tp)
                                initial++;
                            else
                                --up;
                        else
                            up++;
                    }
                    if(initial){
                        if(initial > w->qh)
                            initial = w->qh;
                        qh = w->qh-initial;
                        wdelete(w, qh, qh+initial);
                        w->qh = qh;
                    }
                    free(rp);
                    rp = tp;
                    nr = up-tp;
                    rp[nr] = 0;
                    break;
                }
            w->qh = winsert(w, rp, nr, w->qh)+nr;
            if(w->scrolling || w->mouseopen)
                wshow(w, w->qh);
            wsetselect(w, w->q0, w->q1);
            wscrdraw(w);
            free(rp);
            break;
        case WCread:
            recv(crm.c1, &pair);
            t = pair.s;
            nb = pair.ns;
            i = npart;
            npart = 0;
            if(i)
                memmove(t, part, i);
            while(i<nb && (w->qh<w->nr || w->nraw>0)){
                if(w->qh == w->nr){
                    wid = runetochar(t+i, &w->raw[0]);
                    w->nraw--;
                    runemove(w->raw, w->raw+1, w->nraw);
                }else
                    wid = runetochar(t+i, &w->r[w->qh++]);
                c = t[i];	/* knows break characters fit in a byte */
                i += wid;
                if(!w->rawing && (c == '\n' || c=='\004')){
                    if(c == '\004')
                        i--;
                    break;
                }
            }
            if(i==nb && w->qh<w->nr && w->r[w->qh]=='\004')
                w->qh++;
            if(i > nb){
                npart = i-nb;
                memmove(part, t+nb, npart);
                i = nb;
            }
            pair.s = t;
            pair.ns = i;
            send(crm.c2, &pair);
            continue;
        case WWread:
            w->wctlready = 0;
            recv(cwrm.c1, &pair);
            if(w->deleted || w->i==nil)
                pair.ns = sprint(pair.s, "");
            else{
                s = "visible";
                for(i=0; i<nhidden; i++)
                    if(hidden[i] == w){
                        s = "hidden";
                        break;
                    }
                t = "notcurrent";
                if(w == input)
                    t = "current";
                pair.ns = snprint(pair.s, pair.ns, "%11d %11d %11d %11d %s %s ",
                    w->i->r.min.x, w->i->r.min.y, w->i->r.max.x, w->i->r.max.y, t, s);
            }
            send(cwrm.c2, &pair);
            continue;
        }
        if(!w->deleted)
            flushimage(display, 1);
    }
}
@


\section{Xfid threads}

%TODO rename XFAlloc, XFFree, XNALT like for the other threads
<<enum Xxxx>>=
enum { 
    Alloc, 
    Free, 
    N 
};
@

<<global xfidfree>>=
static	Xfid	*xfidfree;
@

<<global xfid>>=
static	Xfid	*xfid;
@

<<function xfidallocthread>>=
void
xfidallocthread(void*)
{
    Xfid *x;
    static Alt alts[N+1];

    alts[Alloc].c = cxfidalloc;
    alts[Alloc].v = nil;
    alts[Alloc].op = CHANRCV;
    alts[Free].c = cxfidfree;
    alts[Free].v = &x;
    alts[Free].op = CHANRCV;
    alts[N].op = CHANEND;

    for(;;){
        // event loop
        switch(alt(alts)){
        case Alloc:
            x = xfidfree;
            if(x)
                xfidfree = x->free;
            else{
                x = emalloc(sizeof(Xfid));
                x->c = chancreate(sizeof(void(*)(Xfid*)), 0);
                x->flushc = chancreate(sizeof(int), 0);	/* notification only; no data */
                x->flushtag = -1;
                x->next = xfid;
                xfid = x;
                threadcreate(xfidctl, x, 16384);
            }
            if(x->ref != 0){
                fprint(2, "%p incref %ld\n", x, x->ref);
                error("incref");
            }
            if(x->flushtag != -1)
                error("flushtag in allocate");
            incref(x);
            sendp(cxfidalloc, x);
            break;
        case Free:
            if(x->ref != 0){
                fprint(2, "%p decref %ld\n", x, x->ref);
                error("decref");
            }
            if(x->flushtag != -1)
                error("flushtag in free");
            x->free = xfidfree;
            xfidfree = x;
            break;
        }
    }
}
@



<<function xfidctl>>=
void
xfidctl(void *arg)
{
    Xfid *x;
    void (*f)(Xfid*);
    char buf[64];

    x = arg;
    snprint(buf, sizeof buf, "xfid.%p", x);
    threadsetname(buf);
    for(;;){
        f = recvp(x->c);
        (*f)(x);
        if(decref(x) == 0)
            sendp(cxfidfree, x);
    }
}
@

\section{Closing and delete threads}

<<global winclosechan>>=
Channel	*winclosechan; /* chan(Window*); */
@

<<function winclosethread>>=
/* thread to allow fsysproc to synchronize window closing with main proc */
void
winclosethread(void*)
{
    Window *w;

    threadsetname("winclosethread");
    for(;;){
        w = recvp(winclosechan);
        wclose(w);
    }
}
@


<<global deletechan>>=
Channel*	deletechan;
@

<<function deletethread>>=
/* thread to make Deleted windows that the client still holds disappear offscreen after an interval */
void
deletethread(void*)
{
    char *s;
    Image *i;

    threadsetname("deletethread");
    for(;;){
        s = recvp(deletechan);
        i = namedimage(display, s);
        if(i != nil){
            /* move it off-screen to hide it, since client is slow in letting it go */
            originwindow(i, i->r.min, view->r.max);
        }
        freeimage(i);
        free(s);
    }
}
@


\chapter{System Menus}

\section{Right click menu}

<<enum _anon_ (windows/rio/rio.c)>>=
enum
{
    New,
    Reshape,
    Move,
    Delete,
    Hide,
    Exit,

    Hidden,
};
@

%//PAD used to be a global
%<<global Hidden>>=
%int	Hidden = Exit+1;
%@
% ? when hide it's accessible in the right menu! hence the 100 below

<<global menu3str>>=
char		*menu3str[100] = {
 [New]		"New",
 [Reshape]	"Resize",
 [Move]		"Move",
 [Delete]	"Delete",
 [Hide]		"Hide",
 [Exit]		"Exit",
 nil
};
@

<<global menu3>>=
Menu menu3 =
{
    menu3str
};
@

% displaying a menu is drawing something! on top of what you
% are currently! it's part of the drawing library!
% mousethread -> event loop -> <>
<<function button3menu>>=
void
button3menu(void)
{
    int i;

    for(i=0; i<nhidden; i++)
        menu3str[i+Hidden] = hidden[i]->label;
    menu3str[i+Hidden] = nil;

    sweeping = true;
    switch(i = menuhit(3, mousectl, &menu3, wscreen)){
    case -1:
        break;
    case New:
        new(sweep(), false, scrolling, 0, nil, "/bin/rc", nil);
        break;
    case Reshape:
        resize();
        break;
    case Move:
        move();
        break;
    case Delete:
        delete();
        break;
    case Hide:
        hide();
        break;
    case Exit:
        send(exitchan, nil);
        break;
    default:
        unhide(i);
        break;
    }
    sweeping = false;
}
@
%old:
%        if(Hidden > Exit){
%        }
%        /* else fall through */
% tricks when Exit was an optional menu item disabled sometimes

\section{Middle click menu}

<<enum _anon_ (windows/rio/rio.c)2>>=
enum
{
    Cut,
    Paste,
    Snarf,
    Plumb,
    Send,
    Scroll,
};
@

<<global menu2str>>=
char		*menu2str[] = {
 [Cut]		"cut",
 [Paste]	"paste",
 [Snarf]	"snarf",
 [Plumb]	"plumb",
 [Send]		"send",
 [Scroll]	"scroll",
 nil
};
@

<<global menu2>>=
Menu menu2 =
{
    menu2str
};
@

% active only on actual window, not like right menu
% mousethread -> event loop -> <>
<<function button2menu>>=
void
button2menu(Window *w)
{
    if(w->deleted)
        return;
    incref(w);

    if(w->scrolling)
        menu2str[Scroll] = "noscroll";
    else
        menu2str[Scroll] = "scroll";

    switch(menuhit(2, mousectl, &menu2, wscreen)){
    case Cut:
        wsnarf(w);
        wcut(w);
        wscrdraw(w);
        break;

    case Snarf:
        wsnarf(w);
        break;

    case Paste:
        getsnarf();
        wpaste(w);
        wscrdraw(w);
        break;

    case Plumb:
        wplumb(w);
        break;

    case Send:
        getsnarf();
        wsnarf(w);
        if(nsnarf == 0)
            break;
        if(w->rawing){
            waddraw(w, snarf, nsnarf);
            if(snarf[nsnarf-1]!='\n' && snarf[nsnarf-1]!='\004')
                          waddraw(w, L"\n", 1);
        }else{
            winsert(w, snarf, nsnarf, w->nr);
            if(snarf[nsnarf-1]!='\n' && snarf[nsnarf-1]!='\004')
                winsert(w, L"\n", 1, w->nr);
        }
        wsetselect(w, w->nr, w->nr);
        wshow(w, w->nr);
        break;

    case Scroll:
        if(w->scrolling ^= 1)
            wshow(w, w->nr);
        break;
    }
    wclose(w); // decref
    wsendctlmesg(w, Wakeup, ZR, nil);
    flushimage(display, true);
}
@




\chapter{Windows}

\section{Overview}

\section{[[Wctlmesg]]}

<<enum wctlmesgkind>>=
enum	/* control messages */
{
    Wakeup,
    Reshaped, // Resized, Hide/Unhind
    Moved,
    Refresh,
    Movemouse,

    Rawon,
    Rawoff,

    Holdon,
    Holdoff,

    Deleted,
    Exited,
};
@


<<struct Wctlmesg>>=
struct Wctlmesg
{
    int		type;
    Rectangle	r;
    Image	*image;
};
@


<<function wsendctlmesg>>=
void
wsendctlmesg(Window *w, int type, Rectangle r, Image *image)
{
    Wctlmesg wcm;

    wcm.type = type;
    wcm.r = r;
    wcm.image = image;
    send(w->cctl, &wcm);
}
@


<<[[wctlmesg()]] cases>>=
case Wakeup:
    break;
@

<<[[wctlmesg()]] cases>>=
case Refresh:
    if(w->deleted || Dx(w->screenr)<=0 || !rectclip(&r, w->i->r))
        break;
    if(!w->mouseopen)
        wrefresh(w, r);
    flushimage(display, 1);
    break;
@

<<[[wctlmesg()]] cases>>=
case Movemouse:
    if(sweeping || !ptinrect(r.min, w->i->r))
        break;
    wmovemouse(w, r.min);
    break;
@

<<[[wctlmesg()]] cases>>=
case Rawon:
    break;
case Rawoff:
    if(w->deleted)
        break;
    while(w->nraw > 0){
        wkeyctl(w, w->raw[0]);
        --w->nraw;
        runemove(w->raw, w->raw+1, w->nraw);
    }
    break;
@

<<[[wctlmesg()]] cases>>=
case Holdon:
case Holdoff:
    if(w->deleted)
        break;
    wrepaint(w);
    flushimage(display, 1);
    break;
@

<<[[wctlmesg()]] cases>>=
case Deleted:
    if(w->deleted)
        break;
    write(w->notefd, "hangup", 6);
    proccreate(deletetimeoutproc, estrdup(w->name), 4096);
    wclosewin(w);
    break;
@



% from winctl event loop!
<<function wctlmesg>>=
int
wctlmesg(Window *w, int m, Rectangle r, Image *i)
{
    char buf[64];

    switch(m){
    <<[[wctlmesg()]] cases>>
    default:
        error("unknown control message");
        break;
    }

    return m;
}
@

\section{Window creation}

% button3menu -> new() -> wmk ()

%        new(sweep(), false, scrolling, 0, nil, "/bin/rc", nil);

<<global menuing>>=
bool menuing;/* menu action is pending; waiting for window to be indicated */
@

<<function sweep>>=
Image*
sweep(void)
{
    Image *i, *oi;
    Rectangle r;
    Point p0, p;

    i = nil;
    menuing = true;
    riosetcursor(&crosscursor, 1);
    while(mouse->buttons == 0)
        readmouse(mousectl);
    p0 = onscreen(mouse->xy);
    p = p0;
    r.min = p;
    r.max = p;
    oi = nil;
    while(mouse->buttons == 4){
        readmouse(mousectl);
        if(mouse->buttons != 4 && mouse->buttons != 0)
            break;
        if(!eqpt(mouse->xy, p)){
            p = onscreen(mouse->xy);
            r = canonrect(Rpt(p0, p));
            if(Dx(r)>5 && Dy(r)>5){
                i = allocwindow(wscreen, r, Refnone, 0xEEEEEEFF); /* grey */
                freeimage(oi);
                if(i == nil)
                    goto Rescue;
                oi = i;
                border(i, r, Selborder, red, ZP);
                flushimage(display, 1);
            }
        }
    }
    if(mouse->buttons != 0)
        goto Rescue;
    if(i==nil || Dx(i->r)<100 || Dy(i->r)<3*font->height)
        goto Rescue;
    oi = i;
    i = allocwindow(wscreen, oi->r, Refbackup, DWhite);
    freeimage(oi);
    if(i == nil)
        goto Rescue;
    border(i, r, Selborder, red, ZP);
    cornercursor(input, mouse->xy, 1);
    goto Return;

 Rescue:
    freeimage(i);
    i = nil;
    cornercursor(input, mouse->xy, 1);
    while(mouse->buttons)
        readmouse(mousectl);

 Return:
    moveto(mousectl, mouse->xy);	/* force cursor update; ugly */
    menuing = false;
    return i;
}
@


\section{Window deletion}

% Exited vs Deleted?

% button3menu -> wclose() -> wclosewin() ; wsendctlmsg(Exited)

<<[[wctlmesg()]] cases>>=
case Exited:
    frclear(w, true);
    close(w->notefd);
    chanfree(w->mc.c);
    chanfree(w->ck);
    chanfree(w->cctl);
    chanfree(w->conswrite);
    chanfree(w->consread);
    chanfree(w->mouseread);
    chanfree(w->wctlread);
    free(w->raw);
    free(w->r);
    free(w->dir);
    free(w->label);
    free(w);
    break;
@

\section{Window resize}

<<function resize>>=
void
resize(void)
{
    Window *w;
    Image *i;

    w = pointto(true);
    if(w == nil)
        return;
    i = sweep();
    if(i)
        wsendctlmesg(w, Reshaped, i->r, i);
}
@

<<[[wctlmesg()]] cases>>=
case Moved:
case Reshaped:
    if(w->deleted){
        freeimage(i);
        break;
    }
    w->screenr = r;
    strcpy(buf, w->name);
    wresize(w, i, m==Moved);
    w->wctlready = 1;
    proccreate(deletetimeoutproc, estrdup(buf), 4096);
    if(Dx(r) > 0){
        if(w != input)
            wcurrent(w);
    }else if(w == input)
        wcurrent(nil);
    flushimage(display, 1);
    break;
@


<<function wresize>>=
void
wresize(Window *w, Image *i, bool move)
{
    Rectangle r, or;

    or = w->i->r;
    if(move || (Dx(or)==Dx(i->r) && Dy(or)==Dy(i->r)))
        draw(i, i->r, w->i, nil, w->i->r.min);
    freeimage(w->i);
    w->i = i;
    wsetname(w);
    w->mc.image = i;
    r = insetrect(i->r, Selborder+1);
    w->scrollr = r;
    w->scrollr.max.x = r.min.x+Scrollwid;
    w->lastsr = ZR;
    r.min.x += Scrollwid+Scrollgap;
    if(move)
        frsetrects(w, r, w->i);
    else{
        frclear(w, false);
        frinit(w, r, w->font, w->i, cols);
        wsetcols(w);
        w->maxtab = maxtab*stringwidth(w->font, "0");
        r = insetrect(w->i->r, Selborder);
        draw(w->i, r, cols[BACK], nil, w->entire.min);
        wfill(w);
        wsetselect(w, w->q0, w->q1);
        wscrdraw(w);
    }
    wborder(w, Selborder);
    w->topped = ++topped;
    w->resized = true;
    w->mouse.counter++;
}
@

\section{Window move}

<<function move>>=
void
move(void)
{
    Window *w;
    Image *i;
    Rectangle r;

    w = pointto(false);
    if(w == nil)
        return;
    i = drag(w, &r);
    if(i)
        wsendctlmesg(w, Moved, r, i);
    cornercursor(input, mouse->xy, 1);
}
@

\section{Window hiding}

<<function hide>>=
void
hide(void)
{
    Window *w;

    w = pointto(true);
    if(w == nil)
        return;
    whide(w);
}
@


<<function whide>>=
int
whide(Window *w)
{
    Image *i;
    int j;

    for(j=0; j<nhidden; j++)
        if(hidden[j] == w)	/* already hidden */
            return -1;
    i = allocimage(display, w->screenr, w->i->chan, 0, DWhite);
    if(i){
        hidden[nhidden++] = w;
        wsendctlmesg(w, Reshaped, ZR, i);
        return 1;
    }
    return 0;
}
@

%\section{Window unhiding}

<<function unhide>>=
void
unhide(int h)
{
    Window *w;

    h -= Hidden;
    w = hidden[h];
    if(w == nil)
        return;
    wunhide(h);
}
@

<<function wunhide>>=
int
wunhide(int h)
{
    Image *i;
    Window *w;

    w = hidden[h];
    i = allocwindow(wscreen, w->i->r, Refbackup, DWhite);
    if(i){
        --nhidden;
        memmove(hidden+h, hidden+h+1, (nhidden-h)*sizeof(Window*));
        wsendctlmesg(w, Reshaped, w->i->r, i);
        return 1;
    }
    return 0;
}
@


\chapter{Cursor}
% put pictures instead of code :)
% what is the code that takes the hexa data and draw?


<<global crosscursor (windows/rio/data.c)>>=
Cursor crosscursor = {
    {-7, -7},
    {0x03, 0xC0, 0x03, 0xC0, 0x03, 0xC0, 0x03, 0xC0,
     0x03, 0xC0, 0x03, 0xC0, 0xFF, 0xFF, 0xFF, 0xFF,
     0xFF, 0xFF, 0xFF, 0xFF, 0x03, 0xC0, 0x03, 0xC0,
     0x03, 0xC0, 0x03, 0xC0, 0x03, 0xC0, 0x03, 0xC0, },
    {0x00, 0x00, 0x01, 0x80, 0x01, 0x80, 0x01, 0x80,
     0x01, 0x80, 0x01, 0x80, 0x01, 0x80, 0x7F, 0xFE,
     0x7F, 0xFE, 0x01, 0x80, 0x01, 0x80, 0x01, 0x80,
     0x01, 0x80, 0x01, 0x80, 0x01, 0x80, 0x00, 0x00, }
};
@

<<global boxcursor (windows/rio/data.c)>>=
Cursor boxcursor = {
    {-7, -7},
    {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
     0xFF, 0xFF, 0xF8, 0x1F, 0xF8, 0x1F, 0xF8, 0x1F,
     0xF8, 0x1F, 0xF8, 0x1F, 0xF8, 0x1F, 0xFF, 0xFF,
     0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, },
    {0x00, 0x00, 0x7F, 0xFE, 0x7F, 0xFE, 0x7F, 0xFE,
     0x70, 0x0E, 0x70, 0x0E, 0x70, 0x0E, 0x70, 0x0E,
     0x70, 0x0E, 0x70, 0x0E, 0x70, 0x0E, 0x70, 0x0E,
     0x7F, 0xFE, 0x7F, 0xFE, 0x7F, 0xFE, 0x00, 0x00, }
};
@

<<global sightcursor (windows/rio/data.c)>>=
Cursor sightcursor = {
    {-7, -7},
    {0x1F, 0xF8, 0x3F, 0xFC, 0x7F, 0xFE, 0xFB, 0xDF,
     0xF3, 0xCF, 0xE3, 0xC7, 0xFF, 0xFF, 0xFF, 0xFF,
     0xFF, 0xFF, 0xFF, 0xFF, 0xE3, 0xC7, 0xF3, 0xCF,
     0x7B, 0xDF, 0x7F, 0xFE, 0x3F, 0xFC, 0x1F, 0xF8, },
    {0x00, 0x00, 0x0F, 0xF0, 0x31, 0x8C, 0x21, 0x84,
     0x41, 0x82, 0x41, 0x82, 0x41, 0x82, 0x7F, 0xFE,
     0x7F, 0xFE, 0x41, 0x82, 0x41, 0x82, 0x41, 0x82,
     0x21, 0x84, 0x31, 0x8C, 0x0F, 0xF0, 0x00, 0x00, }
};
@

<<global whitearrow (windows/rio/data.c)>>=
Cursor whitearrow = {
    {0, 0},
    {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFF, 0xFC, 
     0xFF, 0xF0, 0xFF, 0xF0, 0xFF, 0xF8, 0xFF, 0xFC, 
     0xFF, 0xFE, 0xFF, 0xFF, 0xFF, 0xFE, 0xFF, 0xFC, 
     0xF3, 0xF8, 0xF1, 0xF0, 0xE0, 0xE0, 0xC0, 0x40, },
    {0xFF, 0xFF, 0xFF, 0xFF, 0xC0, 0x06, 0xC0, 0x1C, 
     0xC0, 0x30, 0xC0, 0x30, 0xC0, 0x38, 0xC0, 0x1C, 
     0xC0, 0x0E, 0xC0, 0x07, 0xCE, 0x0E, 0xDF, 0x1C, 
     0xD3, 0xB8, 0xF1, 0xF0, 0xE0, 0xE0, 0xC0, 0x40, }
};
@

<<global query (windows/rio/data.c)>>=
Cursor query = {
    {-7,-7},
    {0x0f, 0xf0, 0x1f, 0xf8, 0x3f, 0xfc, 0x7f, 0xfe, 
     0x7c, 0x7e, 0x78, 0x7e, 0x00, 0xfc, 0x01, 0xf8, 
     0x03, 0xf0, 0x07, 0xe0, 0x07, 0xc0, 0x07, 0xc0, 
     0x07, 0xc0, 0x07, 0xc0, 0x07, 0xc0, 0x07, 0xc0, },
    {0x00, 0x00, 0x0f, 0xf0, 0x1f, 0xf8, 0x3c, 0x3c, 
     0x38, 0x1c, 0x00, 0x3c, 0x00, 0x78, 0x00, 0xf0, 
     0x01, 0xe0, 0x03, 0xc0, 0x03, 0x80, 0x03, 0x80, 
     0x00, 0x00, 0x03, 0x80, 0x03, 0x80, 0x00, 0x00, }
};
@

<<global tl>>=
Cursor tl = {
    {-4, -4},
    {0xfe, 0x00, 0x82, 0x00, 0x8c, 0x00, 0x87, 0xff, 
     0xa0, 0x01, 0xb0, 0x01, 0xd0, 0x01, 0x11, 0xff, 
     0x11, 0x00, 0x11, 0x00, 0x11, 0x00, 0x11, 0x00, 
     0x11, 0x00, 0x11, 0x00, 0x11, 0x00, 0x1f, 0x00, },
    {0x00, 0x00, 0x7c, 0x00, 0x70, 0x00, 0x78, 0x00, 
     0x5f, 0xfe, 0x4f, 0xfe, 0x0f, 0xfe, 0x0e, 0x00, 
     0x0e, 0x00, 0x0e, 0x00, 0x0e, 0x00, 0x0e, 0x00, 
     0x0e, 0x00, 0x0e, 0x00, 0x0e, 0x00, 0x00, 0x00, }
};
@

<<global t>>=
static Cursor t = {
    {-7, -8},
    {0x00, 0x00, 0x00, 0x00, 0x03, 0x80, 0x06, 0xc0, 
     0x1c, 0x70, 0x10, 0x10, 0x0c, 0x60, 0xfc, 0x7f, 
     0x80, 0x01, 0x80, 0x01, 0x80, 0x01, 0xff, 0xff, 
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, },
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 
     0x03, 0x80, 0x0f, 0xe0, 0x03, 0x80, 0x03, 0x80, 
     0x7f, 0xfe, 0x7f, 0xfe, 0x7f, 0xfe, 0x00, 0x00, 
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, }
};
@

<<global tr>>=
Cursor tr = {
    {-11, -4},
    {0x00, 0x7f, 0x00, 0x41, 0x00, 0x31, 0xff, 0xe1, 
     0x80, 0x05, 0x80, 0x0d, 0x80, 0x0b, 0xff, 0x88, 
     0x00, 0x88, 0x0, 0x88, 0x00, 0x88, 0x00, 0x88, 
     0x00, 0x88, 0x00, 0x88, 0x00, 0x88, 0x00, 0xf8, },
    {0x00, 0x00, 0x00, 0x3e, 0x00, 0x0e, 0x00, 0x1e, 
     0x7f, 0xfa, 0x7f, 0xf2, 0x7f, 0xf0, 0x00, 0x70, 
     0x00, 0x70, 0x00, 0x70, 0x00, 0x70, 0x00, 0x70, 
     0x00, 0x70, 0x00, 0x70, 0x00, 0x70, 0x00, 0x00, }
};
@

<<global r>>=
Cursor r = {
    {-8, -7},
    {0x07, 0xc0, 0x04, 0x40, 0x04, 0x40, 0x04, 0x58, 
     0x04, 0x68, 0x04, 0x6c, 0x04, 0x06, 0x04, 0x02, 
     0x04, 0x06, 0x04, 0x6c, 0x04, 0x68, 0x04, 0x58, 
     0x04, 0x40, 0x04, 0x40, 0x04, 0x40, 0x07, 0xc0, },
    {0x00, 0x00, 0x03, 0x80, 0x03, 0x80, 0x03, 0x80, 
     0x03, 0x90, 0x03, 0x90, 0x03, 0xf8, 0x03, 0xfc, 
     0x03, 0xf8, 0x03, 0x90, 0x03, 0x90, 0x03, 0x80, 
     0x03, 0x80, 0x03, 0x80, 0x03, 0x80, 0x00, 0x00, }
};
@

<<global br>>=
Cursor br = {
    {-11, -11},
    {0x00, 0xf8, 0x00, 0x88, 0x00, 0x88, 0x00, 0x88, 
     0x00, 0x88, 0x00, 0x88, 0x00, 0x88, 0x00, 0x88, 
     0xff, 0x88, 0x80, 0x0b, 0x80, 0x0d, 0x80, 0x05, 
     0xff, 0xe1, 0x00, 0x31, 0x00, 0x41, 0x00, 0x7f, },
    {0x00, 0x00, 0x00, 0x70, 0x00, 0x70, 0x00, 0x70, 
     0x0, 0x70, 0x00, 0x70, 0x00, 0x70, 0x00, 0x70, 
     0x00, 0x70, 0x7f, 0xf0, 0x7f, 0xf2, 0x7f, 0xfa, 
     0x00, 0x1e, 0x00, 0x0e, 0x00, 0x3e, 0x00, 0x00, }
};
@

<<global b>>=
Cursor b = {
    {-7, -7},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
     0xff, 0xff, 0x80, 0x01, 0x80, 0x01, 0x80, 0x01, 
     0xfc, 0x7f, 0x0c, 0x60, 0x10, 0x10, 0x1c, 0x70, 
     0x06, 0xc0, 0x03, 0x80, 0x00, 0x00, 0x00, 0x00, },
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
     0x00, 0x00, 0x7f, 0xfe, 0x7f, 0xfe, 0x7f, 0xfe, 
     0x03, 0x80, 0x03, 0x80, 0x0f, 0xe0, 0x03, 0x80, 
     0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, }
};
@

<<global bl>>=
Cursor bl = {
    {-4, -11},
    {0x1f, 0x00, 0x11, 0x00, 0x11, 0x00, 0x11, 0x00, 
     0x11, 0x00, 0x11, 0x00, 0x11, 0x00, 0x11, 0x00, 
     0x11, 0xff, 0xd0, 0x01, 0xb0, 0x01, 0xa0, 0x01, 
     0x87, 0xff, 0x8c, 0x00, 0x82, 0x00, 0xfe, 0x00, },
    {0x00, 0x00, 0x0e, 0x00, 0x0e, 0x00, 0x0e, 0x00, 
     0x0e, 0x00, 0x0e, 0x00, 0x0e, 0x00, 0x0e, 0x00, 
     0x0e, 0x00, 0x0f, 0xfe, 0x4f, 0xfe, 0x5f, 0xfe, 
     0x78, 0x00, 0x70, 0x00, 0x7c, 0x00, 0x00, 0x0, }
};
@

<<global l>>=
Cursor l = {
    {-7, -7},
    {0x03, 0xe0, 0x02, 0x20, 0x02, 0x20, 0x1a, 0x20, 
     0x16, 0x20, 0x36, 0x20, 0x60, 0x20, 0x40, 0x20, 
     0x60, 0x20, 0x36, 0x20, 0x16, 0x20, 0x1a, 0x20, 
     0x02, 0x20, 0x02, 0x20, 0x02, 0x20, 0x03, 0xe0, },
    {0x00, 0x00, 0x01, 0xc0, 0x01, 0xc0, 0x01, 0xc0, 
     0x09, 0xc0, 0x09, 0xc0, 0x1f, 0xc0, 0x3f, 0xc0, 
     0x1f, 0xc0, 0x09, 0xc0, 0x09, 0xc0, 0x01, 0xc0, 
     0x01, 0xc0, 0x01, 0xc0, 0x01, 0xc0, 0x00, 0x00, }
};
@

<<global corners (windows/rio/data.c)>>=
Cursor *corners[9] = {
    &tl,	&t,	&tr,
    &l,	nil,	&r,
    &bl,	&b,	&br,
};
@


\chapter{The Server}

<<global fcall>>=
Xfid* 	(*fcall[Tmax])(Filsys*, Xfid*, Fid*) =
{
    [Tattach]	= filsysattach,
    [Twalk]	= filsyswalk,
    [Topen]	= filsysopen,
    [Tcreate]	= filsyscreate,
    [Tread]	= filsysread,
    [Twrite]	= filsyswrite,
    [Tclunk]	= filsysclunk,
    [Tremove]   = filsysremove,
    [Tstat]	= filsysstat,
    [Twstat]	= filsyswstat,
    [Tflush]	= filsysflush,
    [Tversion]	= filsysversion,
    [Tauth]	= filsysauth,
};
@


\section{[[filsysinit()]]}

<<global wctlfd>>=
int	wctlfd;
@

<<global srvpipe (windows/rio/fsys.c)>>=
char	srvpipe[64];
@

<<global srvwctl (windows/rio/fsys.c)>>=
char	srvwctl[64];
@


<<function filsysinit>>=
Filsys*
filsysinit(Channel *cxfidalloc)
{
    int n, fd, pid, p0;
    Filsys *fs;
    Channel *c;
    char buf[128];

    fs = emalloc(sizeof(Filsys));
    if(cexecpipe(&fs->cfd, &fs->sfd) < 0)
        goto Rescue;

    fmtinstall('F', fcallfmt);

    clockfd = open("/dev/time", OREAD|OCEXEC);

    fd = open("/dev/user", OREAD);
    strcpy(buf, "Jean-Paul_Belmondo"); // lol
    if(fd >= 0){
        n = read(fd, buf, sizeof buf-1);
        if(n > 0)
            buf[n] = 0;
        close(fd);
    }
    fs->user = estrdup(buf);

    fs->cxfidalloc = cxfidalloc;
    pid = getpid();

    /*
     * Create and post wctl pipe
     */
    if(cexecpipe(&p0, &wctlfd) < 0)
        goto Rescue;
    sprint(srvwctl, "/srv/riowctl.%s.%d", fs->user, pid);
    post(srvwctl, "wctl", p0);
    close(p0);

    /*
     * Start server processes
     */
    c = chancreate(sizeof(char*), 0);
    if(c == nil)
        error("wctl channel");
    proccreate(wctlproc, c, 4096);
    threadcreate(wctlthread, c, 4096);
    proccreate(filsysproc, fs, 10000);

    /*
     * Post srv pipe
     */
    sprint(srvpipe, "/srv/rio.%s.%d", fs->user, pid);
    post(srvpipe, "wsys", fs->cfd);

    return fs;

Rescue:
    free(fs);
    return nil;
}
@


<<function post>>=
void
post(char *name, char *envname, int srvfd)
{
    int fd;
    char buf[32];

    fd = create(name, OWRITE|ORCLOSE|OCEXEC, 0600);
    if(fd < 0)
        error(name);
    sprint(buf, "%d",srvfd);
    if(write(fd, buf, strlen(buf)) != strlen(buf))
        error("srv write");
    putenv(envname, name);
}
@



<<function cexecpipe>>=
/*
 * Build pipe with OCEXEC set on second fd.
 * Can't put it on both because we want to post one in /srv.
 */
int
cexecpipe(int *p0, int *p1)
{
    /* pipe the hard way to get close on exec */
    if(bind("#|", "/mnt/temp", MREPL) < 0)
        return -1;
    *p0 = open("/mnt/temp/data", ORDWR);
    *p1 = open("/mnt/temp/data1", ORDWR|OCEXEC);
    unmount(nil, "/mnt/temp");
    if(*p0<0 || *p1<0)
        return -1;
    return 0;
}
@




<<global messagesize>>=
int	messagesize = 8192+IOHDRSZ;	/* good start */
@


<<function wctlproc>>=
void
wctlproc(void *v)
{
    char *buf;
    int n, eofs;
    Channel *c;

    threadsetname("WCTLPROC");
    c = v;

    eofs = 0;
    for(;;){
        buf = emalloc(messagesize);
        n = read(wctlfd, buf, messagesize-1);	/* room for \0 */
        if(n < 0)
            break;
        if(n == 0){
            if(++eofs > 20)
                break;
            continue;
        }
        eofs = 0;

        buf[n] = '\0';
        sendp(c, buf);
    }
}
@




<<function wctlthread>>=
void
wctlthread(void *v)
{
    char *buf, *arg, *dir;
    int cmd, id, pid, hideit, scrollit;
    Rectangle rect;
    char err[ERRMAX];
    Channel *c;

    c = v;

    threadsetname("WCTLTHREAD");

    for(;;){
        buf = recvp(c);
        cmd = parsewctl(&arg, ZR, &rect, &pid, &id, &hideit, &scrollit, &dir, buf, err);

        switch(cmd){
        case New:
            wctlnew(rect, arg, pid, hideit, scrollit, dir, err);
        }
        free(buf);
    }
}
@





<<function filsysproc>>=
static
void
filsysproc(void *arg)
{
    int n;
    Xfid *x;
    Fid *f;
    Fcall t;
    uchar *buf;
    Filsys *fs;

    threadsetname("FILSYSPROC");
    fs = arg;
    fs->pid = getpid();
    x = nil;
    for(;;){
        buf = emalloc(messagesize+UTFmax);	/* UTFmax for appending partial rune in xfidwrite */
        n = read9pmsg(fs->sfd, buf, messagesize);
        if(n <= 0){
            yield();	/* if threadexitsall'ing, will not return */
            fprint(2, "rio: %d: read9pmsg: %d %r\n", getpid(), n);
            errorshouldabort = false;
            error("eof or i/o error on server channel");
        }
        if(x == nil){
            send(fs->cxfidalloc, nil);
            recv(fs->cxfidalloc, &x);
            x->fs = fs;
        }
        x->buf = buf;
        if(convM2S(buf, n, x) != n)
            error("convert error in convM2S");
        if(DEBUG)
            fprint(2, "rio:<-%F\n", &x->Fcall);
        if(fcall[x->type] == nil)
            x = filsysrespond(fs, x, &t, Ebadfcall);
        else{
            if(x->type==Tversion || x->type==Tauth)
                f = nil;
            else
                f = newfid(fs, x->fid);
            x->f = f;
            x  = (*fcall[x->type])(fs, x, f);
        }
        firstmessage = false;
    }
}
@



\section{[[filsysxxx()]]}

\subsection{Attach}

<<function filsysattach>>=
static
Xfid*
filsysattach(Filsys *, Xfid *x, Fid *f)
{
    Fcall t;

    if(strcmp(x->uname, x->fs->user) != 0)
        return filsysrespond(x->fs, x, &t, Eperm);
    f->busy = true;
    f->open = false;
    f->qid.path = Qdir;
    f->qid.type = QTDIR;
    f->qid.vers = 0;
    f->dir = dirtab;
    f->nrpart = 0;
    sendp(x->c, xfidattach);
    return nil;
}
@


\subsection{Walk}

<<global all>>=
QLock	all;			/* BUG */
@


<<function filsyswalk>>=
static
Xfid*
filsyswalk(Filsys *fs, Xfid *x, Fid *f)
{
    Fcall t;
    Fid *nf;
    int i, id;
    uchar type;
    ulong path;
    Dirtab *d, *dir;
    Window *w;
    char *err;
    Qid qid;

    if(f->open)
        return filsysrespond(fs, x, &t, "walk of open file");
    nf = nil;
    if(x->fid  != x->newfid){
        /* BUG: check exists */
        nf = newfid(fs, x->newfid);
        if(nf->busy)
            return filsysrespond(fs, x, &t, "clone to busy fid");
        nf->busy = true;
        nf->open = false;
        nf->dir = f->dir;
        nf->qid = f->qid;
        nf->w = f->w;
        incref(f->w);
        nf->nrpart = 0;	/* not open, so must be zero */
        f = nf;	/* walk f */
    }

    t.nwqid = 0;
    err = nil;

    /* update f->qid, f->dir only if walk completes */
    qid = f->qid;
    dir = f->dir;

    if(x->nwname > 0){
        for(i=0; i<x->nwname; i++){
            if((qid.type & QTDIR) == 0){
                err = Enotdir;
                break;
            }
            if(strcmp(x->wname[i], "..") == 0){
                type = QTDIR;
                path = Qdir;
                dir = dirtab;
                if(FILE(qid) == Qwsysdir)
                    path = Qwsys;
                id = 0;
    Accept:
                if(i == MAXWELEM){
                    err = "name too long";
                    break;
                }
                qid.type = type;
                qid.vers = 0;
                qid.path = QID(id, path);
                t.wqid[t.nwqid++] = qid;
                continue;
            }

            if(qid.path == Qwsys){
                /* is it a numeric name? */
                if(!numeric(x->wname[i]))
                    break;
                /* yes: it's a directory */
                id = atoi(x->wname[i]);
                qlock(&all);
                w = wlookid(id);
                if(w == nil){
                    qunlock(&all);
                    break;
                }
                path = Qwsysdir;
                type = QTDIR;
                qunlock(&all);
                incref(w);
                sendp(winclosechan, f->w);
                f->w = w;
                dir = dirtab;
                goto Accept;
            }
        
            if(snarffd>=0 && strcmp(x->wname[i], "snarf")==0)
                break;	/* don't serve /dev/snarf if it's provided in the environment */
            id = WIN(f->qid);
            d = dirtab;
            d++;	/* skip '.' */
            for(; d->name; d++)
                if(strcmp(x->wname[i], d->name) == 0){
                    path = d->qid;
                    type = d->type;
                    dir = d;
                    goto Accept;
                }

            break;	/* file not found */
        }

        if(i==0 && err==nil)
            err = Eexist;
    }

    if(err!=nil || t.nwqid<x->nwname){
        if(nf){
            if(nf->w)
                sendp(winclosechan, nf->w);
            nf->open = false;
            nf->busy = false;
        }
    }else if(t.nwqid == x->nwname){
        f->dir = dir;
        f->qid = qid;
    }

    return filsysrespond(fs, x, &t, err);
}
@

<<function numeric>>=
static
int
numeric(char *s)
{
    for(; *s!='\0'; s++)
        if(*s<'0' || '9'<*s)
            return 0;
    return 1;
}
@


\subsection{Open}

<<function filsysopen>>=
static
Xfid*
filsysopen(Filsys *fs, Xfid *x, Fid *f)
{
    Fcall t;
    int m;

    /* can't truncate anything, so just disregard */
    x->mode &= ~(OTRUNC|OCEXEC);
    /* can't execute or remove anything */
    if(x->mode==OEXEC || (x->mode&ORCLOSE))
        goto Deny;
    switch(x->mode){
    default:
        goto Deny;
    case OREAD:
        m = 0400;
        break;
    case OWRITE:
        m = 0200;
        break;
    case ORDWR:
        m = 0600;
        break;
    }
    if(((f->dir->perm&~(DMDIR|DMAPPEND))&m) != m)
        goto Deny;
        
    sendp(x->c, xfidopen);
    return nil;

    Deny:
    return filsysrespond(fs, x, &t, Eperm);
}
@

\subsection{Create}


<<function filsyscreate>>=
static
Xfid*
filsyscreate(Filsys *fs, Xfid *x, Fid*)
{
    Fcall t;

    return filsysrespond(fs, x, &t, Eperm);
}
@

\subsection{Read}


<<function filsysread>>=
static
Xfid*
filsysread(Filsys *fs, Xfid *x, Fid *f)
{
    Fcall t;
    uchar *b;
    int i, n, o, e, len, j, k, *ids;
    Dirtab *d, dt;
    uint clock;
    char buf[16];

    if((f->qid.type & QTDIR) == 0){
        sendp(x->c, xfidread);
        return nil;
    }
    o = x->offset;
    e = x->offset+x->count;
    clock = getclock();
    b = malloc(messagesize-IOHDRSZ);	/* avoid memset of emalloc */
    if(b == nil)
        return filsysrespond(fs, x, &t, "out of memory");
    n = 0;
    switch(FILE(f->qid)){
    <<[[filsysread()]] cases>>
    }
    t.data = (char*)b;
    t.count = n;
    filsysrespond(fs, x, &t, nil);
    free(b);
    return x;
}
@

\subsection{Write}

<<function filsyswrite>>=
static
Xfid*
filsyswrite(Filsys*, Xfid *x, Fid*)
{
    sendp(x->c, xfidwrite);
    return nil;
}
@

\subsection{Clunk}


<<function filsysclunk>>=
static
Xfid*
filsysclunk(Filsys *fs, Xfid *x, Fid *f)
{
    Fcall t;

    if(f->open){
        f->busy = false;
        f->open = false;
        sendp(x->c, xfidclose);
        return nil;
    }
    if(f->w)
        sendp(winclosechan, f->w);
    f->busy = false;
    f->open = false;
    return filsysrespond(fs, x, &t, nil);
}
@

\subsection{Remove}

<<function filsysremove>>=
static
Xfid*
filsysremove(Filsys *fs, Xfid *x, Fid*)
{
    Fcall t;

    return filsysrespond(fs, x, &t, Eperm);
}
@

\subsection{Stats}

<<function filsysstat>>=
static
Xfid*
filsysstat(Filsys *fs, Xfid *x, Fid *f)
{
    Fcall t;

    t.stat = emalloc(messagesize-IOHDRSZ);
    t.nstat = dostat(fs, WIN(x->f->qid), f->dir, t.stat, messagesize-IOHDRSZ, getclock());
    x = filsysrespond(fs, x, &t, nil);
    free(t.stat);
    return x;
}
@

<<function dostat>>=
static
int
dostat(Filsys *fs, int id, Dirtab *dir, uchar *buf, int nbuf, uint clock)
{
    Dir d;

    d.qid.path = QID(id, dir->qid);
    if(dir->qid == Qsnarf)
        d.qid.vers = snarfversion;
    else
        d.qid.vers = 0;
    d.qid.type = dir->type;
    d.mode = dir->perm;
    d.length = 0;	/* would be nice to do better */
    d.name = dir->name;
    d.uid = fs->user;
    d.gid = fs->user;
    d.muid = fs->user;
    d.atime = clock;
    d.mtime = clock;
    return convD2M(&d, buf, nbuf);
}
@




<<function filsyswstat>>=
static
Xfid*
filsyswstat(Filsys *fs, Xfid *x, Fid*)
{
    Fcall t;

    return filsysrespond(fs, x, &t, Eperm);
}
@

\subsection{Flush}

<<function filsysflush>>=
static
Xfid*
filsysflush(Filsys*, Xfid *x, Fid*)
{
    sendp(x->c, xfidflush);
    return nil;
}
@


\subsection{Misc}

<<global firstmessage>>=
bool	firstmessage = true;
@

<<function filsysversion>>=
static
Xfid*
filsysversion(Filsys *fs, Xfid *x, Fid*)
{
    Fcall t;

    if(!firstmessage)
        return filsysrespond(x->fs, x, &t, "version request not first message");
    if(x->msize < 256)
        return filsysrespond(x->fs, x, &t, "version: message size too small");
    messagesize = x->msize;
    t.msize = messagesize;
    if(strncmp(x->version, "9P2000", 6) != 0)
        return filsysrespond(x->fs, x, &t, "unrecognized 9P version");
    t.version = "9P2000";
    return filsysrespond(fs, x, &t, nil);
}
@


<<function filsysauth>>=
static
Xfid*
filsysauth(Filsys *fs, Xfid *x, Fid*)
{
    Fcall t;

        return filsysrespond(fs, x, &t, "rio: authentication not required");
}
@


\subsection{Helpers}

<<function filsysrespond>>=
Xfid*
filsysrespond(Filsys *fs, Xfid *x, Fcall *t, char *err)
{
    int n;

    if(err){
        t->type = Rerror;
        t->ename = err;
    }else
        t->type = x->type+1;
    t->fid = x->fid;
    t->tag = x->tag;
    if(x->buf == nil)
        x->buf = malloc(messagesize);
    n = convS2M(t, x->buf, messagesize);
    if(n <= 0)
        error("convert error in convS2M");
    if(write(fs->sfd, x->buf, n) != n)
        error("write error in respond");
    if(DEBUG)
        fprint(2, "rio:->%F\n", t);
    free(x->buf);
    x->buf = nil;
    return x;
}
@


<<function filsyscancel>>=
void
filsyscancel(Xfid *x)
{
    if(x->buf){
        free(x->buf);
        x->buf = nil;
    }
}
@


\section{[[xfidxxx()]]}

\subsection{Attach}

<<function xfidattach>>=
void
xfidattach(Xfid *x)
{
    Fcall t;
    int id, hideit, scrollit;
    Window *w;
    char *err, *n, *dir, errbuf[ERRMAX];
    int pid, newlymade;
    Rectangle r;
    Image *i;

    t.qid = x->f->qid;
    qlock(&all);
    w = nil;
    err = Eunkid;
    newlymade = false;
    hideit = 0;

    //TODO delete
    if(x->aname[0] == 'N'){	/* N 100,100, 200, 200 - old syntax */
        n = x->aname+1;
        pid = strtoul(n, &n, 0);
        if(*n == ',')
            n++;
        r.min.x = strtoul(n, &n, 0);
        if(*n == ',')
            n++;
        r.min.y = strtoul(n, &n, 0);
        if(*n == ',')
            n++;
        r.max.x = strtoul(n, &n, 0);
        if(*n == ',')
            n++;
        r.max.y = strtoul(n, &n, 0);
  Allocate:
        if(!goodrect(r))
            err = Ebadrect;
        else{
            if(hideit)
                i = allocimage(display, r, screen->chan, 0, DWhite);
            else
                i = allocwindow(wscreen, r, Refbackup, DWhite);
            if(i){
                border(i, r, Selborder, display->black, ZP);
                if(pid == 0)
                    pid = -1;	/* make sure we don't pop a shell! - UGH */
                w = new(i, hideit, scrolling, pid, nil, nil, nil);
                flushimage(display, 1);
                newlymade = true;
            }else
                err = Ewindow;
        }
    }else if(strncmp(x->aname, "new", 3) == 0){	/* new -dx -dy - new syntax, as in wctl */
        pid = 0;
        if(parsewctl(nil, ZR, &r, &pid, nil, &hideit, &scrollit, &dir, x->aname, errbuf) < 0)
            err = errbuf;
        else
            goto Allocate;
    }else{
        id = atoi(x->aname);
        w = wlookid(id);
    }
    x->f->w = w;
    if(w == nil){
        qunlock(&all);
        x->f->busy = false;
        filsysrespond(x->fs, x, &t, err);
        return;
    }
    if(!newlymade)	/* counteract dec() in winshell() */
        incref(w);
    qunlock(&all);
    filsysrespond(x->fs, x, &t, nil);
}
@

\subsection{Open}


<<function xfidopen>>=
void
xfidopen(Xfid *x)
{
    Fcall t;
    Window *w;

    w = x->f->w;
    if(w->deleted){
        filsysrespond(x->fs, x, &t, Edeleted);
        return;
    }
    switch(FILE(x->f->qid)){
    <<[[xfidopen()]] cases>>
    }
    t.qid = x->f->qid;
    t.iounit = messagesize-IOHDRSZ;
    x->f->open = true;
    x->f->mode = x->mode;
    filsysrespond(x->fs, x, &t, nil);
}
@

\subsection{Close}


<<function xfidclose>>=
void
xfidclose(Xfid *x)
{
    Fcall t;
    Window *w;
    int nb, nulls;

    w = x->f->w;
    switch(FILE(x->f->qid)){
    <<[[xfidclose()]] cases>>
    }
    wclose(w);
    filsysrespond(x->fs, x, &t, nil);
}
@

\subsection{Read}


<<[[xfidread()]] locals>>=
char buf[128];
Fcall fc;
int n, off, cnt, c;
uint qid;
char *t;
char cbuf[30];
Window *w;
Mouse ms;
Rectangle r;
Image *i;
Channel *c1, *c2;	/* chan (tuple(char*, int)) */
Consreadmesg crm;
Mousereadmesg mrm;
Consreadmesg cwrm;
Stringpair pair;
Alt alts[NCR+1];
@


<<function xfidread>>=
void
xfidread(Xfid *x)
{
    <<[[xfidread()]] locals>>
    
    w = x->f->w;
    if(w->deleted){
        filsysrespond(x->fs, x, &fc, Edeleted);
        return;
    }
    qid = FILE(x->f->qid);
    off = x->offset;
    cnt = x->count;

    switch(qid){
    <<[[xfidread()]] cases>>
    default:
        fprint(STDERR, "unknown qid %d in read\n", qid);
        sprint(buf, "unknown qid in read");
        filsysrespond(x->fs, x, &fc, buf);
        break;
        }
}
@

\subsection{Write}

<<[[xfidwrite()]] locals>>=
Fcall fc;
int c, cnt, qid, nb, off, nr;
char buf[256], *p;
Point pt;
Window *w;
Rune *r;
Conswritemesg cwm;
Stringpair pair;
Alt alts[NCW+1];
@


<<function xfidwrite>>=
void
xfidwrite(Xfid *x)
{
    <<[[xfidwrite()]] locals>>
    
    w = x->f->w;
    if(w->deleted){
        filsysrespond(x->fs, x, &fc, Edeleted);
        return;
    }
    qid = FILE(x->f->qid);
    cnt = x->count;
    off = x->offset;
    x->data[cnt] = 0;

    switch(qid){
    <<[[xfidwrite()]] cases>>
    default:
        fprint(2, buf, "unknown qid %d in write\n", qid);
        sprint(buf, "unknown qid in write");
        filsysrespond(x->fs, x, &fc, buf);
        return;
    }

    fc.count = cnt;
    filsysrespond(x->fs, x, &fc, nil);
}
@

\subsection{Flush}

<<function xfidflush>>=
void
xfidflush(Xfid *x)
{
    Fcall t;
    Xfid *xf;

    for(xf=xfid; xf; xf=xf->next)
        if(xf->flushtag == x->oldtag){
            xf->flushtag = -1;
            xf->flushing = true;
            incref(xf);	/* to hold data structures up at tail of synchronization */
            if(xf->ref == 1)
                error("ref 1 in flush");
            if(canqlock(&xf->active)){
                qunlock(&xf->active);
                sendul(xf->flushc, 0);
            }else{
                qlock(&xf->active);	/* wait for him to finish */
                qunlock(&xf->active);
            }
            xf->flushing = false;
            if(decref(xf) == 0)
                sendp(cxfidfree, xf);
            break;
        }
    filsysrespond(x->fs, x, &t, nil);
}
@


\chapter{[[/dev/...]] Demultiplexer}

\section{Overview}

<<enum qid>>=
enum qid
{
    Qdir,			/* /dev for this window */
    <<enum qid cases>>
    QMAX,
};
@

% window+dev -> qid
<<function QID>>=
#define	QID(w,q)	((w<<8)|(q))
@
% what about overflow? hop will not have too many windows then

% qid -> window
<<function WIN>>=
#define	WIN(q)	((((ulong)(q).path)>>8) & 0xFFFFFF)
@

% qid -> dev
<<function FILE>>=
#define	FILE(q)	(((ulong)(q).path) & 0xFF)
@


<<struct Dirtab>>=
struct Dirtab
{
    char	*name;
    uchar	type;
    uint	qid;
    uint	perm;
};
@

<<global dirtab>>=
Dirtab dirtab[]=
{
    { ".",		QTDIR,	Qdir,		0500|DMDIR },
    <<dirtab array elements>>
    { nil, }
};
@



\section{[[/dev/cons]]}

<<enum qid cases>>=
Qcons,
@

<<dirtab array elements>>=
{ "cons",		QTFILE,	Qcons,		0600 },
@

<<enum _anon_ (windows/rio/xfid.c)3>>=
enum { CRdata, CRflush, NCR };
@

<<[[xfidread()]] cases>>=
case Qcons:
    x->flushtag = x->tag;

    alts[CRdata].c = w->consread;
    alts[CRdata].v = &crm;
    alts[CRdata].op = CHANRCV;
    alts[CRflush].c = x->flushc;
    alts[CRflush].v = nil;
    alts[CRflush].op = CHANRCV;
    alts[NMR].op = CHANEND;

    switch(alt(alts)){
    case CRdata:
        break;
    case CRflush:
        filsyscancel(x);
        return;
    }

    /* received data */
    x->flushtag = -1;
    c1 = crm.c1;
    c2 = crm.c2;
    t = malloc(cnt+UTFmax+1);	/* room to unpack partial rune plus */
    pair.s = t;
    pair.ns = cnt;
    send(c1, &pair);
    if(x->flushing){
        recv(x->flushc, nil);	/* wake up flushing xfid */
        recv(c2, nil);			/* wake up window and toss data */
        free(t);
        filsyscancel(x);
        return;
    }
    qlock(&x->active);
    recv(c2, &pair);
    fc.data = pair.s;
    fc.count = pair.ns;
    filsysrespond(x->fs, x, &fc, nil);
    free(t);
    qunlock(&x->active);
    break;
@





<<enum _anon_ (windows/rio/xfid.c)2>>=
enum { CWdata, CWflush, NCW };
@


<<[[xfidwrite()]] cases>>=
case Qcons:
    nr = x->f->nrpart;
    if(nr > 0){
        memmove(x->data+nr, x->data, cnt);	/* there's room: see malloc in filsysproc */
        memmove(x->data, x->f->rpart, nr);
        cnt += nr;
        x->f->nrpart = 0;
    }
    r = runemalloc(cnt);
    cvttorunes(x->data, cnt-UTFmax, r, &nb, &nr, nil);
    /* approach end of buffer */
    while(fullrune(x->data+nb, cnt-nb)){
        c = nb;
        nb += chartorune(&r[nr], x->data+c);
        if(r[nr])
            nr++;
    }
    if(nb < cnt){
        memmove(x->f->rpart, x->data+nb, cnt-nb);
        x->f->nrpart = cnt-nb;
    }
    x->flushtag = x->tag;

    alts[CWdata].c = w->conswrite;
    alts[CWdata].v = &cwm;
    alts[CWdata].op = CHANRCV;
    alts[CWflush].c = x->flushc;
    alts[CWflush].v = nil;
    alts[CWflush].op = CHANRCV;
    alts[NCW].op = CHANEND;

    switch(alt(alts)){
    case CWdata:
        break;
    case CWflush:
        filsyscancel(x);
        return;
    }

    /* received data */
    x->flushtag = -1;
    if(x->flushing){
        recv(x->flushc, nil);	/* wake up flushing xfid */
        pair.s = runemalloc(1);
        pair.ns = 0;
        send(cwm.cw, &pair);		/* wake up window with empty data */
        filsyscancel(x);
        return;
    }
    qlock(&x->active);
    pair.s = r;
    pair.ns = nr;
    send(cwm.cw, &pair);
    fc.count = x->count;
    filsysrespond(x->fs, x, &fc, nil);
    qunlock(&x->active);
    return;
@


\section{[[/dev/consctl]]}

<<enum qid cases>>=
Qconsctl,
@
<<dirtab array elements>>=
{ "consctl",	QTFILE,	Qconsctl,	0200 },
@

<<[[xfidopen()]] cases>>=
case Qconsctl:
    if(w->ctlopen){
        filsysrespond(x->fs, x, &t, Einuse);
        return;
    }
    w->ctlopen = true;
    break;
@

<<[[xfidclose()]] cases>>=
case Qconsctl:
    if(w->rawing){
        w->rawing = false;
        wsendctlmesg(w, Rawoff, ZR, nil);
    }
    if(w->holding){
        w->holding = false;
        wsendctlmesg(w, Holdoff, ZR, nil);
    }
    w->ctlopen = false;
    break;
@

<<[[xfidwrite()]] cases>>=
case Qconsctl:
    if(strncmp(x->data, "holdon", 6)==0){
        if(w->holding++ == 0)
            wsendctlmesg(w, Holdon, ZR, nil);
        break;
    }
    if(strncmp(x->data, "holdoff", 7)==0 && w->holding){
        if(--w->holding == false)
            wsendctlmesg(w, Holdoff, ZR, nil);
        break;
    }
    if(strncmp(x->data, "rawon", 5)==0){
        if(w->holding){
            w->holding = false;
            wsendctlmesg(w, Holdoff, ZR, nil);
        }
        if(w->rawing++ == 0)
            wsendctlmesg(w, Rawon, ZR, nil);
        break;
    }
    if(strncmp(x->data, "rawoff", 6)==0 && w->rawing){
        if(--w->rawing == 0)
            wsendctlmesg(w, Rawoff, ZR, nil);
        break;
    }
    filsysrespond(x->fs, x, &fc, "unknown control message");
    return;
@

\section{[[/dev/mouse]]}

<<enum qid cases>>=
Qmouse,
@
<<dirtab array elements>>=
{ "mouse",		QTFILE,	Qmouse,		0600 },
@

<<[[xfidopen()]] cases>>=
case Qmouse:
    if(w->mouseopen){
        filsysrespond(x->fs, x, &t, Einuse);
        return;
    }
    /*
     * Reshaped: there's a race if the appl. opens the
     * window, is resized, and then opens the mouse,
     * but that's rare.  The alternative is to generate
     * a resized event every time a new program starts
     * up in a window that has been resized since the
     * dawn of time.  We choose the lesser evil.
     */
    w->resized = false;
    w->mouseopen = true;
    break;
@


<<[[xfidclose()]] cases>>=
case Qmouse:
    w->resized = false;
    w->mouseopen = false;
    if(w->i != nil)
        wsendctlmesg(w, Refresh, w->i->r, nil);
    break;
@


<<enum _anon_ (windows/rio/xfid.c)4>>=
enum { MRdata, MRflush, NMR };
@

<<[[xfidread()]] cases>>=
case Qmouse:
    x->flushtag = x->tag;

    alts[MRdata].c = w->mouseread;
    alts[MRdata].v = &mrm;
    alts[MRdata].op = CHANRCV;
    alts[MRflush].c = x->flushc;
    alts[MRflush].v = nil;
    alts[MRflush].op = CHANRCV;
    alts[NMR].op = CHANEND;

    switch(alt(alts)){
    case MRdata:
        break;
    case MRflush:
        filsyscancel(x);
        return;
    }

    /* received data */
    x->flushtag = -1;
    if(x->flushing){
        recv(x->flushc, nil);		/* wake up flushing xfid */
        recv(mrm.cm, nil);			/* wake up window and toss data */
        filsyscancel(x);
        return;
    }
    qlock(&x->active);
    recv(mrm.cm, &ms);
    c = 'm';
    if(w->resized)
        c = 'r';
    n = sprint(buf, "%c%11d %11d %11d %11ld ", c, ms.xy.x, ms.xy.y, ms.buttons, ms.msec);
    w->resized = 0;
    fc.data = buf;
    fc.count = min(n, cnt);
    filsysrespond(x->fs, x, &fc, nil);
    qunlock(&x->active);
    break;
@


<<[[xfidwrite()]] cases>>=
case Qmouse:
    if(w!=input || Dx(w->screenr)<=0)
        break;
    if(x->data[0] != 'm'){
        filsysrespond(x->fs, x, &fc, Ebadmouse);
        return;
    }
    p = nil;
    pt.x = strtoul(x->data+1, &p, 0);
    if(p == nil){
        filsysrespond(x->fs, x, &fc, Eshort);
        return;
    }
    pt.y = strtoul(p, nil, 0);
    if(w==input && wpointto(mouse->xy)==w)
        wsendctlmesg(w, Movemouse, Rpt(pt, pt), nil);
    break;
@

\section{[[/dev/cursor]]}

<<enum qid cases>>=
Qcursor,
@
<<dirtab array elements>>=
{ "cursor",		QTFILE,	Qcursor,	0600 },
@

<<[[xfidclose()]] cases>>=
case Qcursor:
    w->cursorp = nil;
    wsetcursor(w, false);
    break;
@

<<[[xfidread()]] cases>>=
case Qcursor:
    filsysrespond(x->fs, x, &fc, "cursor read not implemented");
    break;
@

<<[[xfidwrite()]] cases>>=
case Qcursor:
    if(cnt < 2*4+2*2*16)
        w->cursorp = nil;
    else{
        w->cursor.offset.x = BGLONG(x->data+0*4);
        w->cursor.offset.y = BGLONG(x->data+1*4);
        memmove(w->cursor.clr, x->data+2*4, 2*2*16);
        w->cursorp = &w->cursor;
    }
    wsetcursor(w, !sweeping);
    break;
@

\chapter{[[/dev/...]] Windows Files}

\section{[[/dev/winid]]}

<<enum qid cases>>=
Qwinid,
@
<<dirtab array elements>>=
{ "winid",		QTFILE,	Qwinid,		0400 },
@

<<[[xfidread()]] cases>>=
case Qwinid:
    n = sprint(buf, "%11d ", w->id);
    t = estrdup(buf);
    goto Text;
@

\section{[[/dev/winname]]}

<<enum qid cases>>=
Qwinname,
@
<<dirtab array elements>>=
{ "winname",	QTFILE,	Qwinname,	0400 },
@

<<[[xfidread()]] cases>>=
case Qwinname:
    n = strlen(w->name);
    if(n == 0){
        filsysrespond(x->fs, x, &fc, "window has no name");
        break;
    }
    t = estrdup(w->name);
    goto Text;
@

\section{[[/dev/label]]}

<<enum qid cases>>=
Qlabel,
@
<<dirtab array elements>>=
{ "label",		QTFILE,	Qlabel,		0600 },
@

<<[[xfidread()]] cases>>=
case Qlabel:
    n = strlen(w->label);
    if(off > n)
        off = n;
    if(off+cnt > n)
        cnt = n-off;
    fc.data = w->label+off;
    fc.count = cnt;
    filsysrespond(x->fs, x, &fc, nil);
    break;
@

<<[[xfidwrite()]] cases>>=
case Qlabel:
    if(off != 0){
        filsysrespond(x->fs, x, &fc, "non-zero offset writing label");
        return;
    }
    free(w->label);
    w->label = emalloc(cnt+1);
    memmove(w->label, x->data, cnt);
    w->label[cnt] = 0;
    break;
@

\section{[[/dev/screen]]}

% but not /dev/draw!
% this is not demultiplex, but instead
% writing to /dev/screen write to /dev/draw at the right place

<<enum qid cases>>=
Qscreen,
@
<<dirtab array elements>>=
{ "screen",		QTFILE,	Qscreen,	0400 },
@

<<[[xfidread()]] cases>>=
case Qscreen:
    i = display->image;
    if(i == nil){
        filsysrespond(x->fs, x, &fc, "no top-level screen");
        break;
    }
    r = i->r;
    /* fall through */

caseImage:
    if(off < 5*12){
        n = sprint(buf, "%11s %11d %11d %11d %11d ",
            chantostr(cbuf, screen->chan),
            i->r.min.x, i->r.min.y, i->r.max.x, i->r.max.y);
        t = estrdup(buf);
        goto Text;
    }
    t = malloc(cnt);
    fc.data = t;
    n = readwindow(i, t, r, off, cnt);	/* careful; fc.count is unsigned */
    if(n < 0){
        buf[0] = 0;
        errstr(buf, sizeof buf);
        filsysrespond(x->fs, x, &fc, buf);
    }else{
        fc.count = n;
        filsysrespond(x->fs, x, &fc, nil);
    }
    free(t);
    return;
@

<<function readwindow>>=
int
readwindow(Image *i, char *t, Rectangle r, int offset, int n)
{
    int ww, y;

    offset -= 5*12;
    ww = bytesperline(r, screen->depth);
    r.min.y += offset/ww;
    if(r.min.y >= r.max.y)
        return 0;
    y = r.min.y + n/ww;
    if(y < r.max.y)
        r.max.y = y;
    if(r.max.y <= r.min.y)
        return 0;
    return unloadimage(i, r, (uchar*)t, n);
}
@


\section{[[/dev/window]]}

<<enum qid cases>>=
Qwindow,
@
<<dirtab array elements>>=
{ "window",		QTFILE,	Qwindow,	0400 },
@

<<[[xfidread()]] cases>>=
case Qwindow:
    i = w->i;
    if(i == nil || Dx(w->screenr)<=0){
        filsysrespond(x->fs, x, &fc, Enowindow);
        return;
    }
    r = w->screenr;
    goto caseImage;
@

\section{[[/dev/text]]}

<<enum qid cases>>=
Qtext,
@
<<dirtab array elements>>=
{ "text",		QTFILE,	Qtext,		0400 },
@

<<[[xfidread()]] cases>>=
case Qtext:
    t = wcontents(w, &n);
    goto Text;

Text:
    if(off > n){
        off = n;
        cnt = 0;
    }
    if(off+cnt > n)
        cnt = n-off;
    fc.data = t+off;
    fc.count = cnt;
    filsysrespond(x->fs, x, &fc, nil);
    free(t);
    break;
@

\section{[[/dev/kdbin]]}

<<enum qid cases>>=
Qkbdin,
@
<<dirtab array elements>>=
{ "kbdin",		QTFILE,	Qkbdin,		0200 },
@

<<[[xfidopen()]] cases>>=
case Qkbdin:
    if(w !=  wkeyboard){
        filsysrespond(x->fs, x, &t, Eperm);
        return;
    }
    break;
@

<<[[xfidwrite()]] cases>>=
case Qkbdin:
    keyboardsend(x->data, cnt);
    break;
@

<<function keyboardsend>>=
/*
 * Used by /dev/kbdin
 */
void
keyboardsend(char *s, int cnt)
{
    Rune *r;
    int i, nb, nr;

    r = runemalloc(cnt);
    /* BUGlet: partial runes will be converted to error runes */
    cvttorunes(s, cnt, r, &nb, &nr, nil);
    for(i=0; i<nr; i++)
        send(keyboardctl->c, &r[i]);
    free(r);
}
@

\section{[[/dev/wdir]]}

<<enum qid cases>>=
Qwdir,
@
<<dirtab array elements>>=
{ "wdir",		QTFILE,	Qwdir,		0600 },
@

<<[[xfidread()]] cases>>=
case Qwdir:
    t = estrdup(w->dir);
    n = strlen(t);
    goto Text;
@

<<[[xfidwrite()]] cases>>=
case Qwdir:
    if(cnt == 0)
        break;
    if(x->data[cnt-1] == '\n'){
        if(cnt == 1)
            break;
        x->data[cnt-1] = '\0';
    }
    /* assume data comes in a single write */
    /*
      * Problem: programs like dossrv, ftp produce illegal UTF;
      * we must cope by converting it first.
      */
    snprint(buf, sizeof buf, "%.*s", cnt, x->data);
    if(buf[0] == '/'){
        free(w->dir);
        w->dir = estrdup(buf);
    }else{
        p = emalloc(strlen(w->dir) + 1 + strlen(buf) + 1);
        sprint(p, "%s/%s", w->dir, buf);
        free(w->dir);
        w->dir = cleanname(p);
    }
    break;
@

\section{[[/dev/wctl]]}

<<enum qid cases>>=
Qwctl,
@
<<dirtab array elements>>=
{ "wctl",		QTFILE,	Qwctl,		0600 },
@

<<[[xfidopen()]] cases>>=
case Qwctl:
    if(x->mode==OREAD || x->mode==ORDWR){
        /*
         * It would be much nicer to implement fan-out for wctl reads,
         * so multiple people can see the resizings, but rio just isn't
         * structured for that.  It's structured for /dev/cons, which gives
         * alternate data to alternate readers.  So to keep things sane for
         * wctl, we compromise and give an error if two people try to
         * open it.  Apologies.
         */
        if(w->wctlopen){
            filsysrespond(x->fs, x, &t, Einuse);
            return;
        }
        w->wctlopen = true;
        w->wctlready = 1;
        wsendctlmesg(w, Wakeup, ZR, nil);
    }
    break;
@

<<[[xfidclose()]] cases>>=
case Qwctl:
    if(x->f->mode==OREAD || x->f->mode==ORDWR)
        w->wctlopen = false;
break;
@


<<enum _anon_ (windows/rio/xfid.c)5>>=
enum { WCRdata, WCRflush, NWCR };
@

<<[[xfidread()]] cases>>=
case Qwctl:	/* read returns rectangle, hangs if not resized */
    if(cnt < 4*12){
        filsysrespond(x->fs, x, &fc, Etooshort);
        break;
    }
    x->flushtag = x->tag;

    alts[WCRdata].c = w->wctlread;
    alts[WCRdata].v = &cwrm;
    alts[WCRdata].op = CHANRCV;
    alts[WCRflush].c = x->flushc;
    alts[WCRflush].v = nil;
    alts[WCRflush].op = CHANRCV;
    alts[NMR].op = CHANEND;

    switch(alt(alts)){
    case WCRdata:
        break;
    case WCRflush:
        filsyscancel(x);
        return;
    }

    /* received data */
    x->flushtag = -1;
    c1 = cwrm.c1;
    c2 = cwrm.c2;
    t = malloc(cnt+1);	/* be sure to have room for NUL */
    pair.s = t;
    pair.ns = cnt+1;
    send(c1, &pair);
    if(x->flushing){
        recv(x->flushc, nil);	/* wake up flushing xfid */
        recv(c2, nil);			/* wake up window and toss data */
        free(t);
        filsyscancel(x);
        return;
    }
    qlock(&x->active);
    recv(c2, &pair);
    fc.data = pair.s;
    if(pair.ns > cnt)
        pair.ns = cnt;
    fc.count = pair.ns;
    filsysrespond(x->fs, x, &fc, nil);
    free(t);
    qunlock(&x->active);
    break;
@

<<[[xfidwrite()]] cases>>=
case Qwctl:
    if(writewctl(x, buf) < 0){
        filsysrespond(x->fs, x, &fc, buf);
        return;
    }
    flushimage(display, 1);
    break;
@



\section{[[/dev/wsys]]}

<<enum qid cases>>=
Qwsys,		/* directory of window directories */
@
<<dirtab array elements>>=
{ "wsys",		QTDIR,	Qwsys,		0500|DMDIR },
@



<<function idcmp>>=
static
int
idcmp(void *a, void *b)
{
    return *(int*)a - *(int*)b;
}
@

<<[[filsysread()]] cases>>=
case Qwsys:
    qlock(&all);
    ids = emalloc(nwindow*sizeof(int));
    for(j=0; j<nwindow; j++)
        ids[j] = window[j]->id;
    qunlock(&all);
    qsort(ids, nwindow, sizeof ids[0], idcmp);
    dt.name = buf;
    for(i=0, j=0; j<nwindow && i<e; i+=len){
        k = ids[j];
        sprint(dt.name, "%d", k);
        dt.qid = QID(k, Qdir);
        dt.type = QTDIR;
        dt.perm = DMDIR|0700;
        len = dostat(fs, k, &dt, b+n, x->count-n, clock);
        if(len == 0)
            break;
        if(i >= o)
            n += len;
        j++;
    }
    free(ids);
    break;
@




<<enum qid cases>>=
Qwsysdir,		/* window directory, child of wsys */
@


<<[[filsysread()]] cases>>=
case Qdir:
case Qwsysdir:
    d = dirtab;
    d++;	/* first entry is '.' */
    for(i=0; d->name!=nil && i<e; i+=len){
        len = dostat(fs, WIN(x->f->qid), d, b+n, x->count-n, clock);
        if(len <= BIT16SZ)
            break;
        if(i >= o)
            n += len;
        d++;
    }
    break;
@


\chapter{[[/dev/wctl]]}


<<enum _anon_ (windows/rio/wctl.c)>>=
/* >= Top are disallowed if mouse button is pressed */
enum
{
    New,
    Resize,
    Move,
    Scroll,
    Noscroll,
    Set,
    Top,
    Bottom,
    Current,
    Hide,
    Unhide,
    Delete,
};
@

<<global cmds>>=
static char *cmds[] = {
    [New]	= "new",
    [Resize]	= "resize",
    [Move]	= "move",
    [Scroll]	= "scroll",
    [Noscroll]	= "noscroll",
    [Set]	= "set",
    [Top]	= "top",
    [Bottom]	= "bottom",
    [Current]	= "current",
    [Hide]	= "hide",
    [Unhide]	= "unhide",
    [Delete]	= "delete",
    nil
};
@

<<enum _anon_ (windows/rio/wctl.c)2>>=
enum
{
    Cd,
    Deltax,
    Deltay,
    Hidden,
    Id,
    Maxx,
    Maxy,
    Minx,
    Miny,
    PID,
    R,
    Scrolling,
    Noscrolling,
};
@

<<global params>>=
static char *params[] = {
    [Cd] 			= "-cd",
    [Deltax]			= "-dx",
    [Deltay]			= "-dy",
    [Hidden]			= "-hide",
    [Id]			= "-id",
    [Maxx]			= "-maxx",
    [Maxy]			= "-maxy",
    [Minx]			= "-minx",
    [Miny]			= "-miny",
    [PID]			= "-pid",
    [R]				= "-r",
    [Scrolling]			= "-scroll",
    [Noscrolling]		= "-noscroll",
    nil
};
@

<<function goodrect>>=
/*
 * Check that newly created window will be of manageable size
 */
int
goodrect(Rectangle r)
{
    if(!eqrect(canonrect(r), r))
        return 0;
    if(Dx(r)<100 || Dy(r)<3*font->height)
        return 0;
    /* must have some screen and border visible so we can move it out of the way */
    if(Dx(r) >= Dx(screen->r) && Dy(r) >= Dy(screen->r))
        return 0;
    /* reasonable sizes only please */
    if(Dx(r) > BIG*Dx(screen->r))
        return 0;
    if(Dy(r) > BIG*Dx(screen->r))
        return 0;
    return 1;
}
@

<<function word>>=
static
int
word(char **sp, char *tab[])
{
    char *s, *t;
    int i;

    s = *sp;
    while(isspace(*s))
        s++;
    t = s;
    while(*s!='\0' && !isspace(*s))
        s++;
    for(i=0; tab[i]!=nil; i++)
        if(strncmp(tab[i], t, strlen(tab[i])) == 0){
            *sp = s;
            return i;
    }
    return -1;
}
@

<<function set>>=
int
set(int sign, int neg, int abs, int pos)
{
    if(sign < 0)
        return neg;
    if(sign > 0)
        return pos;
    return abs;
}
@

<<function newrect>>=
Rectangle
newrect(void)
{
    static int i = 0;
    int minx, miny, dx, dy;

    dx = min(600, Dx(screen->r) - 2*Borderwidth);
    dy = min(400, Dy(screen->r) - 2*Borderwidth);
    minx = 32 + 16*i;
    miny = 32 + 16*i;
    i++;
    i %= 10;

    return Rect(minx, miny, minx+dx, miny+dy);
}
@

<<function shift>>=
void
shift(int *minp, int *maxp, int min, int max)
{
    if(*minp < min){
        *maxp += min-*minp;
        *minp = min;
    }
    if(*maxp > max){
        *minp += max-*maxp;
        *maxp = max;
    }
}
@

<<function rectonscreen>>=
Rectangle
rectonscreen(Rectangle r)
{
    shift(&r.min.x, &r.max.x, screen->r.min.x, screen->r.max.x);
    shift(&r.min.y, &r.max.y, screen->r.min.y, screen->r.max.y);
    return r;
}
@

<<function riostrtol>>=
/* permit square brackets, in the manner of %R */
int
riostrtol(char *s, char **t)
{
    int n;

    while(*s!='\0' && (*s==' ' || *s=='\t' || *s=='['))
        s++;
    if(*s == '[')
        s++;
    n = strtol(s, t, 10);
    if(*t != s)
        while((*t)[0] == ']')
            (*t)++;
    return n;
}
@

<<function parsewctl>>=
int
parsewctl(char **argp, Rectangle r, Rectangle *rp, int *pidp, int *idp, int *hiddenp, int *scrollingp, char **cdp, char *s, char *err)
{
    int cmd, param, xy, sign;
    char *t;

    *pidp = 0;
    *hiddenp = 0;
    *scrollingp = scrolling;
    *cdp = nil;
    cmd = word(&s, cmds);
    if(cmd < 0){
        strcpy(err, "unrecognized wctl command");
        return -1;
    }
    if(cmd == New)
        r = newrect();

    strcpy(err, "missing or bad wctl parameter");
    while((param = word(&s, params)) >= 0){
        switch(param){	/* special cases */
        case Hidden:
            *hiddenp = 1;
            continue;
        case Scrolling:
            *scrollingp = 1;
            continue;
        case Noscrolling:
            *scrollingp = 0;
            continue;
        case R:
            r.min.x = riostrtol(s, &t);
            if(t == s)
                return -1;
            s = t;
            r.min.y = riostrtol(s, &t);
            if(t == s)
                return -1;
            s = t;
            r.max.x = riostrtol(s, &t);
            if(t == s)
                return -1;
            s = t;
            r.max.y = riostrtol(s, &t);
            if(t == s)
                return -1;
            s = t;
            continue;
        }
        while(isspace(*s))
            s++;
        if(param == Cd){
            *cdp = s;
            while(*s && !isspace(*s))
                s++;
            if(*s != '\0')
                *s++ = '\0';
            continue;
        }
        sign = 0;
        if(*s == '-'){
            sign = -1;
            s++;
        }else if(*s == '+'){
            sign = +1;
            s++;
        }
        if(!isdigit(*s))
            return -1;
        xy = riostrtol(s, &s);
        switch(param){
        case -1:
            strcpy(err, "unrecognized wctl parameter");
            return -1;
        case Minx:
            r.min.x = set(sign, r.min.x-xy, xy, r.min.x+xy);
            break;
        case Miny:
            r.min.y = set(sign, r.min.y-xy, xy, r.min.y+xy);
            break;
        case Maxx:
            r.max.x = set(sign, r.max.x-xy, xy, r.max.x+xy);
            break;
        case Maxy:
            r.max.y = set(sign, r.max.y-xy, xy, r.max.y+xy);
            break;
        case Deltax:
            r.max.x = set(sign, r.max.x-xy, r.min.x+xy, r.max.x+xy);
            break;
        case Deltay:
            r.max.y = set(sign, r.max.y-xy, r.min.y+xy, r.max.y+xy);
            break;
        case Id:
            if(idp != nil)
                *idp = xy;
            break;
        case PID:
            if(pidp != nil)
                *pidp = xy;
            break;
        }
    }

    *rp = rectonscreen(rectaddpt(r, screen->r.min));

    while(isspace(*s))
        s++;
    if(cmd!=New && *s!='\0'){
        strcpy(err, "extraneous text in wctl message");
        return -1;
    }

    if(argp)
        *argp = s;

    return cmd;
}
@

<<function wctlnew>>=
int
wctlnew(Rectangle rect, char *arg, int pid, int hideit, int scrollit, char *dir, char *err)
{
    char **argv;
    Image *i;

    if(!goodrect(rect)){
        strcpy(err, Ebadwr);
        return -1;
    }
    argv = emalloc(4*sizeof(char*));
    argv[0] = "rc";
    argv[1] = "-c";
    while(isspace(*arg))
        arg++;
    if(*arg == '\0'){
        argv[1] = "-i";
        argv[2] = nil;
    }else{
        argv[2] = arg;
        argv[3] = nil;
    }
    if(hideit)
        i = allocimage(display, rect, screen->chan, 0, DWhite);
    else
        i = allocwindow(wscreen, rect, Refbackup, DWhite);
    if(i == nil){
        strcpy(err, Ewalloc);
        return -1;
    }
    border(i, rect, Selborder, red, ZP);

    new(i, hideit, scrollit, pid, dir, "/bin/rc", argv);

    free(argv);	/* when new() returns, argv and args have been copied */
    return 1;
}
@

<<function writewctl>>=
int
writewctl(Xfid *x, char *err)
{
    int cnt, cmd, j, id, hideit, scrollit, pid;
    Image *i;
    char *arg, *dir;
    Rectangle rect;
    Window *w;

    w = x->f->w;
    cnt = x->count;
    x->data[cnt] = '\0';
    id = 0;

    rect = rectsubpt(w->screenr, screen->r.min);
    cmd = parsewctl(&arg, rect, &rect, &pid, &id, &hideit, &scrollit, &dir, x->data, err);
    if(cmd < 0)
        return -1;

    if(mouse->buttons!=0 && cmd>=Top){
        strcpy(err, "action disallowed when mouse active");
        return -1;
    }

    if(id != 0){
        for(j=0; j<nwindow; j++)
            if(window[j]->id == id)
                break;
        if(j == nwindow){
            strcpy(err, "no such window id");
            return -1;
        }
        w = window[j];
        if(w->deleted || w->i==nil){
            strcpy(err, "window deleted");
            return -1;
        }
    }

    switch(cmd){
    case New:
        return wctlnew(rect, arg, pid, hideit, scrollit, dir, err);
    case Set:
        if(pid > 0)
            wsetpid(w, pid, 0);
        return 1;
    case Move:
        rect = Rect(rect.min.x, rect.min.y, rect.min.x+Dx(w->screenr), rect.min.y+Dy(w->screenr));
        rect = rectonscreen(rect);
        /* fall through */
    case Resize:
        if(!goodrect(rect)){
            strcpy(err, Ebadwr);
            return -1;
        }
        if(eqrect(rect, w->screenr))
            return 1;
        i = allocwindow(wscreen, rect, Refbackup, DWhite);
        if(i == nil){
            strcpy(err, Ewalloc);
            return -1;
        }
        border(i, rect, Selborder, red, ZP);
        wsendctlmesg(w, Reshaped, i->r, i);
        return 1;
    case Scroll:
        w->scrolling = 1;
        wshow(w, w->nr);
        wsendctlmesg(w, Wakeup, ZR, nil);
        return 1;
    case Noscroll:
        w->scrolling = 0;
        wsendctlmesg(w, Wakeup, ZR, nil);
        return 1;
    case Top:
        wtopme(w);
        return 1;
    case Bottom:
        wbottomme(w);
        return 1;
    case Current:
        wcurrent(w);
        return 1;
    case Hide:
        switch(whide(w)){
        case -1:
            strcpy(err, "window already hidden");
            return -1;
        case 0:
            strcpy(err, "hide failed");
            return -1;
        default:
            break;
        }
        return 1;
    case Unhide:
        for(j=0; j<nhidden; j++)
            if(hidden[j] == w)
                break;
        if(j == nhidden){
            strcpy(err, "window not hidden");
            return -1;
        }
        if(wunhide(j) == 0){
            strcpy(err, "hide failed");
            return -1;
        }
        return 1;
    case Delete:
        wsendctlmesg(w, Deleted, ZR, nil);
        return 1;
    }
    strcpy(err, "invalid wctl message");
    return -1;
}
@


\chapter{Window Terminal}
% fake /dev/cons

% it's relatively easy thx to the fake /dev/cons and frame lib



<<function winshell>>=
void
winshell(void *args)
{
    Window *w;
    Channel *pidc;
    void **arg;
    char *cmd, *dir;
    char **argv;

    arg = args;
    w = arg[0];
    pidc = arg[1];
    cmd = arg[2];
    argv = arg[3];
    dir = arg[4];

    rfork(RFNAMEG|RFFDG|RFENVG);

    if(filsysmount(filsys, w->id) < 0){
        fprint(2, "mount failed: %r\n");
        sendul(pidc, 0);
        threadexits("mount failed");
    }
    close(0);
    if(open("/dev/cons", OREAD) < 0){
        fprint(2, "can't open /dev/cons: %r\n");
        sendul(pidc, 0);
        threadexits("/dev/cons");
    }
    close(1);
    if(open("/dev/cons", OWRITE) < 0){
        fprint(2, "can't open /dev/cons: %r\n");
        sendul(pidc, 0);
        threadexits("open");	/* BUG? was terminate() */
    }
    if(wclose(w) == 0){	/* remove extra ref hanging from creation */
        notify(nil);
        dup(1, 2);
        if(dir)
            chdir(dir);
        procexec(pidc, cmd, argv);
        _exits("exec failed");
    }
}
@


<<function filsysmount>>=
/*
 * Called only from a different FD group
 */
int
filsysmount(Filsys *fs, int id)
{
    char buf[32];

    close(fs->sfd);	/* close server end so mount won't hang if exiting */
    sprint(buf, "%d", id);
    if(mount(fs->cfd, -1, "/mnt/wsys", MREPL, buf) < 0){
        fprint(2, "mount failed: %r\n");
        return -1;
    }
    if(bind("/mnt/wsys", "/dev", MBEFORE) < 0){
        fprint(2, "bind failed: %r\n");
        return -1;
    }
    return 0;
}
@

\chapter{Timer}


<<global clockfd>>=
int	clockfd;
@

<<function getclock>>=
static
uint
getclock(void)
{
    char buf[32];

    seek(clockfd, 0, 0);
    read(clockfd, buf, sizeof buf);
    return atoi(buf);
}
@











<<struct Timer>>=
struct Timer
{
    int		dt;
    int		cancel;
    Channel	*c;	/* chan(int) */
    Timer	*next;
};
@

<<function timerinit>>=
void
timerinit(void)
{
    ctimer = chancreate(sizeof(Timer*), 100);
    proccreate(timerproc, nil, STACK);
}
@

<<function timerproc>>=
static
void
timerproc(void*)
{
    int i, nt, na, dt, del;
    Timer **t, *x;
    uint old, new;

    rfork(RFFDG);
    threadsetname("TIMERPROC");
    t = nil;
    na = 0;
    nt = 0;
    old = msec();
    for(;;){
        sleep(1);	/* will sleep minimum incr */
        new = msec();
        dt = new-old;
        old = new;
        if(dt < 0)	/* timer wrapped; go around, losing a tick */
            continue;
        for(i=0; i<nt; i++){
            x = t[i];
            x->dt -= dt;
            del = 0;
            if(x->cancel){
                timerstop(x);
                del = 1;
            }else if(x->dt <= 0){
                /*
                 * avoid possible deadlock if client is
                 * now sending on ctimer
                 */
                if(nbsendul(x->c, 0) > 0)
                    del = 1;
            }
            if(del){
                memmove(&t[i], &t[i+1], (nt-i-1)*sizeof t[0]);
                --nt;
                --i;
            }
        }
        if(nt == 0){
            x = recvp(ctimer);
    gotit:
            if(nt == na){
                na += 10;
                t = realloc(t, na*sizeof(Timer*));
                if(t == nil)
                    abort();
            }
            t[nt++] = x;
            old = msec();
        }
        if(nbrecv(ctimer, &x) > 0)
            goto gotit;
    }
}
@






<<global ctimer>>=
static Channel*	ctimer;	/* chan(Timer*)[100] */
@

<<global timer>>=
static Timer *timer;
@

<<function msec>>=
static
uint
msec(void)
{
    return nsec()/1000000;
}
@

<<function timerstop>>=
void
timerstop(Timer *t)
{
    t->next = timer;
    timer = t;
}
@

<<function timercancel>>=
void
timercancel(Timer *t)
{
    t->cancel = true;
}
@



<<function timerstart>>=
/*
 * timeralloc() and timerfree() don't lock, so can only be
 * called from the main proc.
 */
Timer*
timerstart(int dt)
{
    Timer *t;

    t = timer;
    if(t)
        timer = timer->next;
    else{
        t = emalloc(sizeof(Timer));
        t->c = chancreate(sizeof(int), 0);
    }
    t->next = nil;
    t->dt = dt;
    t->cancel = false;
    sendp(ctimer, t);
    return t;
}
@

\chapter{Signals, notes}

<<global oknotes>>=
char *oknotes[] =
{
    "delete",
    "hangup",
    "kill",
    "exit",
    nil
};
@


% threadmain -> threadnotify(<>, 1);
<<function shutdown>>=
int
shutdown(void *, char *msg)
{
    int i;
    static Lock shutdownlk;
    
    killprocs();
    for(i=0; oknotes[i]; i++)
        if(strncmp(oknotes[i], msg, strlen(oknotes[i])) == 0){
            lock(&shutdownlk);	/* only one can threadexitsall */
            threadexitsall(msg);
        }
    fprint(2, "rio %d: abort: %s\n", getpid(), msg);
    abort();
    exits(msg);
    return 0;
}
@

<<function killprocs>>=
void
killprocs(void)
{
    int i;

    for(i=0; i<nwindow; i++)
        postnote(PNGROUP, window[i]->pid, "hangup");
}
@


\chapter{Widgets}

\section{Frame}
% have libframe/ but also a frame widge in libpanel

\section{Scrolling}
% have also a menu in libpanel, scrollbar

\section{Menu}
% have also a menu in libpanel, popup, pulldown

\section{Libpanel}
% different alloc, different event loop, 
% and the Panel main data structure

\section{Button}

\section{Label}

\section{Text entry}

\section{Completion}

\section{Slider}

\section{List}

\section{Pack}

\section{Canvas}

\section{Text view}

\section{Rich text}


\chapter{Advanced Topics}

\section{Snarf}
%\subsection{[[/dev/snarf]]}


<<enum qid cases>>=
Qsnarf,
@

<<dirtab array elements>>=
{ "snarf",		QTFILE,	Qsnarf,		0600 },
@

<<[[xfidopen()]] cases>>=
case Qsnarf:
    if(x->mode==ORDWR || x->mode==OWRITE){
        if(tsnarf)
            free(tsnarf);	/* collision, but OK */
        ntsnarf = 0;
        tsnarf = malloc(1);
    }
    break;
@

<<[[xfidclose()]] cases>>=
/* odd behavior but really ok: replace snarf buffer when /dev/snarf is closed */
case Qsnarf:
    if(x->f->mode==ORDWR || x->f->mode==OWRITE){
        snarf = runerealloc(snarf, ntsnarf+1);
        cvttorunes(tsnarf, ntsnarf, snarf, &nb, &nsnarf, &nulls);
        free(tsnarf);
        tsnarf = nil;
        ntsnarf = 0;
    }
    break;
@

<<[[xfidread()]] cases>>=
/* The algorithm for snarf and text is expensive but easy and rarely used */
case Qsnarf:
    getsnarf();
    if(nsnarf)
        t = runetobyte(snarf, nsnarf, &n);
    else {
        t = nil;
        n = 0;
    }
    goto Text;
@

<<constant MAXSNARF>>=
#define	MAXSNARF	100*1024
@

<<[[xfidwrite()]] cases>>=
case Qsnarf:
    /* always append only */
    if(ntsnarf > MAXSNARF){	/* avoid thrashing when people cut huge text */
        filsysrespond(x->fs, x, &fc, Elong);
        return;
    }
    tsnarf = erealloc(tsnarf, ntsnarf+cnt+1);	/* room for NUL */
    memmove(tsnarf+ntsnarf, x->data, cnt);
    ntsnarf += cnt;
    snarfversion++;
    break;
@


<<global tsnarf>>=
static	char	*tsnarf;
@

<<global ntsnarf>>=
static	int	ntsnarf;
@






<<global snarffd>>=
fdt		snarffd;
@

<<[[main()]] set snarffd>>=
snarffd = open("/dev/snarf", OREAD|OCEXEC);
@

<<global nsnarf>>=
int		nsnarf;
@

<<global snarf>>=
Rune*	snarf;
@

<<global snarfversion>>=
int		snarfversion;	/* updated each time it is written */
@


<<function putsnarf>>=
/*
 * /dev/snarf updates when the file is closed, so we must open our own
 * fd here rather than use snarffd
 */
void
putsnarf(void)
{
    int fd, i, n;

    if(snarffd<0 || nsnarf==0)
        return;
    fd = open("/dev/snarf", OWRITE);
    if(fd < 0)
        return;
    /* snarf buffer could be huge, so fprint will truncate; do it in blocks */
    for(i=0; i<nsnarf; i+=n){
        n = nsnarf-i;
        if(n >= 256)
            n = 256;
        if(fprint(fd, "%.*S", n, snarf+i) < 0)
            break;
    }
    close(fd);
}
@

<<function getsnarf>>=
void
getsnarf(void)
{
    int i, n, nb, nulls;
    char *sn, buf[1024];

    if(snarffd < 0)
        return;
    sn = nil;
    i = 0;
    seek(snarffd, 0, 0);
    while((n = read(snarffd, buf, sizeof buf)) > 0){
        sn = erealloc(sn, i+n+1);
        memmove(sn+i, buf, n);
        i += n;
        sn[i] = 0;
    }
    if(i > 0){
        snarf = runerealloc(snarf, i+1);
        cvttorunes(sn, i, snarf, &nb, &nsnarf, &nulls);
        free(sn);
    }
}
@



\section{Plumb}

%/*
% * Message format:
% *	source application\n
% *	destination port\n
% *	working directory\n
% *	type\n
% *	attributes\n
% *	nbytes\n
% *	n bytes of data
% */

<<struct Plumbmsg>>=
struct Plumbmsg
{
    char		*src;
    char		*dst;
    char		*wdir;
    char		*type;
    Plumbattr		*attr;
    int			ndata;
    char		*data;
};
@

<<struct Plumbattr>>=
struct Plumbattr
{
    char		*name;
    char		*value;
    Plumbattr		*next;
};
@


\section{Auto complete}

<<struct Completion>>=
struct Completion{
    uchar advance;	/* whether forward progress has been made */
    uchar complete;	/* whether the completion now represents a file or directory */
    char *string; /* the string to advance, suffixed " " or "/" for file or directory */
    int nmatch;		/* number of files that matched */
    int nfile;		/* number of files returned */
    char **filename;	/* their names */
};
@


\section{Scrolling, [[rio -s]]}

<<global scrolling>>=
bool		scrolling;
@

<<[[main()]] command line processing>>=
case 's':
    scrolling = true;
    break;
@

<<enum _anon_ (windows/rio/dat.h)2>>=
enum
{
    Kscrolloneup = KF|0x20,
    Kscrollonedown = KF|0x21,
};
@


<<global scrtmp>>=
static Image *scrtmp;
@

<<function scrtemps>>=
static
void
scrtemps(void)
{
    int h;

    if(scrtmp)
        return;
    h = BIG*Dy(screen->r);
    scrtmp = allocimage(display, Rect(0, 0, 32, h), screen->chan, 0, DWhite);
    if(scrtmp == nil)
        error("scrtemps");
}
@

<<function freescrtemps>>=
void
freescrtemps(void)
{
    freeimage(scrtmp);
    scrtmp = nil;
}
@

<<function scrpos>>=
static
Rectangle
scrpos(Rectangle r, uint p0, uint p1, uint tot)
{
    Rectangle q;
    int h;

    q = r;
    h = q.max.y-q.min.y;
    if(tot == 0)
        return q;
    if(tot > 1024*1024){
        tot>>=10;
        p0>>=10;
        p1>>=10;
    }
    if(p0 > 0)
        q.min.y += h*p0/tot;
    if(p1 < tot)
        q.max.y -= h*(tot-p1)/tot;
    if(q.max.y < q.min.y+2){
        if(q.min.y+2 <= r.max.y)
            q.max.y = q.min.y+2;
        else
            q.min.y = q.max.y-2;
    }
    return q;
}
@

<<function wscrdraw>>=
void
wscrdraw(Window *w)
{
    Rectangle r, r1, r2;
    Image *b;

    scrtemps();
    if(w->i == nil)
        error("scrdraw");
    r = w->scrollr;
    b = scrtmp;
    r1 = r;
    r1.min.x = 0;
    r1.max.x = Dx(r);
    r2 = scrpos(r1, w->org, w->org+w->nchars, w->nr);
    if(!eqrect(r2, w->lastsr)){
        w->lastsr = r2;
        /* move r1, r2 to (0,0) to avoid clipping */
        r2 = rectsubpt(r2, r1.min);
        r1 = rectsubpt(r1, r1.min);
        draw(b, r1, w->cols[BORD], nil, ZP);
        draw(b, r2, w->cols[BACK], nil, ZP);
        r2.min.x = r2.max.x-1;
        draw(b, r2, w->cols[BORD], nil, ZP);
        draw(w->i, r, b, nil, Pt(0, r1.min.y));
    }
}
@

<<function wscrsleep>>=
void
wscrsleep(Window *w, uint dt)
{
    Timer	*timer;
    int y, b;
    static Alt alts[3];

    timer = timerstart(dt);
    y = w->mc.xy.y;
    b = w->mc.buttons;
    alts[0].c = timer->c;
    alts[0].v = nil;
    alts[0].op = CHANRCV;
    alts[1].c = w->mc.c;
    alts[1].v = &w->mc.Mouse;
    alts[1].op = CHANRCV;
    alts[2].op = CHANEND;
    for(;;)
        switch(alt(alts)){
        case 0:
            timerstop(timer);
            return;
        case 1:
            if(abs(w->mc.xy.y-y)>2 || w->mc.buttons!=b){
                timercancel(timer);
                return;
            }
            break;
        }
}
@

<<function wscroll>>=
void
wscroll(Window *w, int but)
{
    uint p0, oldp0;
    Rectangle s;
    int x, y, my, h, first;

    s = insetrect(w->scrollr, 1);
    h = s.max.y-s.min.y;
    x = (s.min.x+s.max.x)/2;
    oldp0 = ~0;
    first = true;
    do{
        flushimage(display, 1);
        if(w->mc.xy.x<s.min.x || s.max.x<=w->mc.xy.x){
            readmouse(&w->mc);
        }else{
            my = w->mc.xy.y;
            if(my < s.min.y)
                my = s.min.y;
            if(my >= s.max.y)
                my = s.max.y;
            if(!eqpt(w->mc.xy, Pt(x, my))){
                wmovemouse(w, Pt(x, my));
                readmouse(&w->mc);		/* absorb event generated by moveto() */
            }
            if(but == 2){
                y = my;
                if(y > s.max.y-2)
                    y = s.max.y-2;
                if(w->nr > 1024*1024)
                    p0 = ((w->nr>>10)*(y-s.min.y)/h)<<10;
                else
                    p0 = w->nr*(y-s.min.y)/h;
                if(oldp0 != p0)
                    wsetorigin(w, p0, false);
                oldp0 = p0;
                readmouse(&w->mc);
                continue;
            }
            if(but == 1)
                p0 = wbacknl(w, w->org, (my-s.min.y)/w->font->height);
            else
                p0 = w->org+frcharofpt(w, Pt(s.max.x, my));
            if(oldp0 != p0)
                wsetorigin(w, p0, true);
            oldp0 = p0;
            /* debounce */
            if(first){
                flushimage(display, 1);
                sleep(200);
                nbrecv(w->mc.c, &w->mc.Mouse);
                first = false;
            }
            wscrsleep(w, 100);
        }
    }while(w->mc.buttons & (1<<(but-1)));
    while(w->mc.buttons)
        readmouse(&w->mc);
}
@


\section{Initial command, [[rio -i]]}

<<[[main()]] locals>>=
char *initstr = nil;
@

<<[[main()]] command line processing>>=
case 'i':
    initstr = ARGF();
    if(initstr == nil)
        usage();
    break;
@

<<[[main()]] if initstr or kdbin>>=
if(initstr)
    proccreate(initcmd, initstr, STACK);
@

<<function initcmd>>=
void
initcmd(void *arg)
{
    char *cmd;

    cmd = arg;
    rfork(RFENVG|RFFDG|RFNOTEG|RFNAMEG);
    procexecl(nil, "/bin/rc", "rc", "-c", cmd, nil);
    fprint(2, "rio: exec failed: %r\n");
    exits("exec");
}
@

\section{Fake keyboard input, [[rio -k]]}

<<global wkeyboard>>=
Window	*wkeyboard;	/* window of simulated keyboard */
@

<<[[main()]] locals>>=
char *kbdin = nil;
@

<<[[main()]] command line processing>>=
case 'k':
    if(kbdin != nil)
        usage();
    kbdin = ARGF();
    if(kbdin == nil)
        usage();
    break;
@

<<[[main()]] locals>>=
Image *i;
Rectangle r;
@

<<global kbdargv>>=
char *kbdargv[] = { "rc", "-c", nil, nil };
@

<<[[main()]] if initstr or kdbin>>=
if(kbdin){
    kbdargv[2] = kbdin;
    r = screen->r;
    r.max.x = r.min.x+300;
    r.max.y = r.min.y+80;
    i = allocwindow(wscreen, r, Refbackup, DWhite);
    wkeyboard = new(i, false, scrolling, 0, nil, "/bin/rc", kbdargv);
    if(wkeyboard == nil)
        error("can't create keyboard window");
}
@

\section{Font selection, [[rio -f]]}

<<global fontname>>=
char		*fontname;
@

<<[[main()]] command line processing>>=
case 'f':
    fontname = ARGF();
    if(fontname == nil)
        usage();
    break;
@

<<[[main()]] set some globals>>=
if(fontname == nil)
    fontname = getenv("font");
if(fontname == nil)
    fontname = "/lib/font/bit/lucm/unicode.9.font";

/* check font before barging ahead */
if(access(fontname, 0) < 0){
    fprint(2, "rio: can't access %s: %r\n", fontname);
    exits("font open");
}
putenv("font", fontname);
@

\chapter{Conclusion}

\appendix

\chapter{Debugging}

% _drawdebug?

% errorshouldabort could be here

<<constant DEBUG>>=
#define DEBUG false
@

\chapter{Profiling}

\chapter{Error Managment}

\section{Error codes}

% fsys.c
<<global Eperm>>=
char Eperm[] = "permission denied";
@

<<global Eexist>>=
char Eexist[] = "file does not exist";
@

<<global Enotdir>>=
char Enotdir[] = "not a directory";
@

<<global Ebadfcall>>=
char	Ebadfcall[] = "bad fcall type";
@

<<global Eoffset>>=
char	Eoffset[] = "illegal offset";
@


% wctl.c
<<global Ebadwr>>=
char	Ebadwr[]		= "bad rectangle in wctl request";
@

<<global Ewalloc>>=
char	Ewalloc[]		= "window allocation failed in wctl request";
@


% xfid.c

<<global Einuse>>=
char Einuse[] =		"file in use";
@

<<global Edeleted>>=
char Edeleted[] =	"window deleted";
@

<<global Ebadreq>>=
char Ebadreq[] =	"bad graphics request";
@

<<global Etooshort>>=
char Etooshort[] =	"buffer too small";
@

<<global Ebadtile>>=
char Ebadtile[] =	"unknown tile";
@

<<global Eshort>>=
char Eshort[] =		"short i/o request";
@

<<global Elong>>=
char Elong[] = 		"snarf buffer too long";
@

<<global Eunkid>>=
char Eunkid[] = 	"unknown id in attach";
@

<<global Ebadrect>>=
char Ebadrect[] = 	"bad rectangle in attach";
@

<<global Ewindow>>=
char Ewindow[] = 	"cannot make window";
@

<<global Enowindow>>=
char Enowindow[] = 	"window has no image";
@

<<global Ebadmouse>>=
char Ebadmouse[] = 	"bad format on /dev/mouse";
@

<<global Ebadwrect>>=
char Ebadwrect[] = 	"rectangle outside screen";
@

<<global Ebadoffset>>=
char Ebadoffset[] = 	"window read not on scan line boundary";
@

\section{[[error()]], [[derror()]]}


<<global errorshouldabort>>=
bool errorshouldabort = false;
@

<<function error>>=
void
error(char *s)
{
    fprint(STDERR, "rio: %s: %r\n", s);
    if(errorshouldabort)
        abort();
    threadexitsall("error");
}
@
% abort? diff with exit? generate a fault so go in broken state so
% can be debugged!


% argument to geninitdraw()
<<function derror>>=
void
derror(Display*, char *errorstr)
{
    error(errorstr);
}
@



\chapter{Libc}

<<function min>>=
int
min(int a, int b)
{
    if(a < b)
        return a;
    return b;
}
@

<<function max (windows/rio/util.c)>>=
int
max(int a, int b)
{
    if(a > b)
        return a;
    return b;
}
@



<<function erealloc>>=
void*
erealloc(void *p, uint n)
{
    p = realloc(p, n);
    if(p == nil)
        error("realloc failed");
    return p;
}
@

<<function emalloc>>=
void*
emalloc(uint n)
{
    void *p;

    p = malloc(n);
    if(p == nil)
        error("malloc failed");
    memset(p, 0, n);
    return p;
}
@

<<function estrdup>>=
char*
estrdup(char *s)
{
    char *p;

    p = malloc(strlen(s)+1);
    if(p == nil)
        error("strdup failed");
    strcpy(p, s);
    return p;
}
@




<<function isalnum>>=
//@Scheck: not dead, but conflict with the one in ctype.h
int isalnum(Rune c)
{
    /*
     * Hard to get absolutely right.  Use what we know about ASCII
     * and assume anything above the Latin control characters is
     * potentially an alphanumeric.
     */
    if(c <= ' ')
        return false;
    if(0x7F<=c && c<=0xA0)
        return false;
    if(utfrune("!\"#$%&'()*+,-./:;<=>?@[\\]^`{|}~", c))
        return false;
    return true;
}
@
%$



<<function runemalloc>>=
#define	runemalloc(n)		malloc((n)*sizeof(Rune))
@

<<function runerealloc>>=
#define	runerealloc(a, n)	realloc(a, (n)*sizeof(Rune))
@

<<function runemove>>=
#define	runemove(a, b, n)	memmove(a, b, (n)*sizeof(Rune))
@


<<function cvttorunes>>=
void
cvttorunes(char *p, int n, Rune *r, int *nb, int *nr, int *nulls)
{
    uchar *q;
    Rune *s;
    int j, w;

    /*
     * Always guaranteed that n bytes may be interpreted
     * without worrying about partial runes.  This may mean
     * reading up to UTFmax-1 more bytes than n; the caller
     * knows this.  If n is a firm limit, the caller should
     * set p[n] = 0.
     */
    q = (uchar*)p;
    s = r;
    for(j=0; j<n; j+=w){
        if(*q < Runeself){
            w = 1;
            *s = *q++;
        }else{
            w = chartorune(s, (char*)q);
            q += w;
        }
        if(*s)
            s++;
        else if(nulls)
                *nulls = true;
    }
    *nb = (char*)q-p;
    *nr = s-r;
}
@




<<function strrune>>=
Rune*
strrune(Rune *s, Rune c)
{
    Rune c1;

    if(c == 0) {
        while(*s++)
            ;
        return s-1;
    }

    while(c1 = *s++)
        if(c1 == c)
            return s-1;
    return nil;
}
@

<<function runetobyte>>=
char*
runetobyte(Rune *r, int n, int *ip)
{
    char *s;
    int m;

    s = emalloc(n*UTFmax+1);
    m = snprint(s, n*UTFmax+1, "%.*S", n, r);
    *ip = m;
    return s;
}
@








\chapter{Extra Code}

\ifallcode
#include "Windows_extra.tex.nw"
\fi

\chapter{Changelog}
\label{sec:changelog}

\chapter{Glossary}
\label{sec:glossary}

\begin{verbatim}
\end{verbatim}

\chapter*{Indexes}
\addcontentsline{toc}{section}{Index}

%\chapter{References} 
\addcontentsline{toc}{section}{References}

\begin{thebibliography}{99}

\bibitem[1]{wp-literate-programming} Donald Knuth,,
{\em Literate Programming}, 
\url{http://en.wikipedia.org/wiki/Literate\_Program}

\bibitem[2]{noweb} Norman Ramsey,
{\em Noweb}, 
\url{http://www.cs.tufts.edu/~nr/noweb/}

\bibitem[3]{syncweb} Yoann Padioleau,
{\em Syncweb, literate programming meets unison}, 
\url{http://padator.org/software/project-syncweb/readme.txt}

\end{thebibliography}

%******************************************************************************
% Postlude
%******************************************************************************

\end{document}

