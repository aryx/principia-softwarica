\documentclass[twocolumn]{report}

%******************************************************************************
% Prelude
%******************************************************************************
\newif\iffinal
\newif\ifverbose
\finaltrue\verbosefalse
% see also other newif in Macros.tex

%------------------------------------------------------------------------------
%history: 
%------------------------------------------------------------------------------

%thx to LP, changed for the better a few things:
% - removed deadcode (Qnew)

%thx to codemap/codegraph/scheck:
% - TODO use cg to reduce backward deps, introduce globals.c, utils.c,
%   (harder to understand non layered code)
% - TODO use scheck to remove deadcode, dead prototypes, useless export
%   or mv as forward decl
%   (harder to understand big interface files)
% - TODO use cg to reduce number of globals by moving them closer to the
%   relevant file (or even function), better cluster the code
%   (harder to understand non functional code using lots of globals)

%thx to this manual, better understand X11?:

%history LP-ization:
% - skeleton, mostly copy paste of Template.tex.nw skeleton
% - put all content of files in the Extra section, via 'pfff -lpize'
%   which also now split in chunks!
%    * function, global, struct, enum, constant, macro(actually function)
%    * TODO ctor/dtor, dumper
%    * TODO [[xxx]] other fields, [[xxx]] extra fields
% - TODO read Extra section, identify concepts, first TOC
% - TODO distribute parts of the Extra section in the main file
% - TODO understand main(), LP split main, improve TOC
% - TODO understand main functions, LP split, cluster, improve TOC
% - TODO LP split the structures, use datalog for flow to field info
% - TODO nullify, boolify, errorify, enumify,  typeify,    scheckify, plan9ify
% - TODO aspecify advanced features! remove useless features
% - TODO add figures
% - TODO add explanations

%------------------------------------------------------------------------------
% Packages
%------------------------------------------------------------------------------

\usepackage{../docs/latex/noweb}
 \noweboptions{footnotesizecode,nomargintag}
 %note: allow chunk on different pages, less white space at bottom of pages
 \def\nwendcode{\endtrivlist \endgroup}
 \let\nwdocspar=\par
\usepackage{xspace}
\usepackage{verbatim}
%note: required by noweblatexpad for the \t \l \n in this file
\usepackage{fancyvrb}
\usepackage{url}
\iffinal
\usepackage{hyperref}
 \hypersetup{colorlinks=true}
\fi
\usepackage[pageref]{backref}
 \def\backref{{\footnotesize cited page(s)}~}
%\usepackage{cleveref} %\cref
%\usepackage{multirow}
\usepackage{booktabs} 
 \newcommand{\otoprule}{\midrule[\heavyrulewidth]}
\usepackage{graphicx}
 %\usepackage[margin=0.5in]{geometry}
 %  but eat the bottom when very low
 %\usepackage{fullpage} is deprecated 
 % => do the more manual below:
 \addtolength{\oddsidemargin}{-.850in}
 \addtolength{\evensidemargin}{-.850in}
 \addtolength{\textwidth}{1.70in}
 \addtolength{\topmargin}{-.850in}
 \addtolength{\textheight}{1.70in}
%\usepackage{minitoc}

%------------------------------------------------------------------------------
% Macros
%------------------------------------------------------------------------------
\input{../docs/latex/Macros}

%------------------------------------------------------------------------------
% Config
%------------------------------------------------------------------------------
\allcodefalse
% used for forward decl, pragmas, func decl, extern decl, stats, #ifdef,
% debugging macros

%\setcounter{tocdepth}{1}

%******************************************************************************
% Title
%******************************************************************************

\begin{document}

\title{
{\Huge 
Principia Softwarica: Plan9 Windowing System [[rio]]
}\\
{version 0.1}
}

\author{
Yoann Padioleau\\
\texttt{yoann.padioleau@gmail.com}
}

\maketitle 
\onecolumn
\hrule
\begin{quote}
    Copyright \copyright{} 2014 Yoann Padioleau \\
    Permission is granted to copy, distribute and/or modify this document,
    except all the source code it contains, under the terms of the GNU Free
    Documentation License, Version 1.3.
\end{quote}
\hrule

%CONFIG: \dominitoc

\iffinal
\begingroup
\hypersetup{linkcolor=blue}
% need to s/onecolumn/twocolumn in report.cls :) for \tableofcontents
\twocolumn
\tableofcontents
\endgroup
\else
\tableofcontents
\fi

%******************************************************************************
% Body
%******************************************************************************

\chapter{Introduction}

\section{Motivations}

The goal of this book is to present in full details the source code of
a real windowing system.
Why? Because I think it makes you a better programmer if
you fully understand how things work under the hood.

Here are other candidates that were considered but ultimately discarded:
\begin{itemize}
\item Mini X
\item Nano X (MicroWindows)
\item X11
\item Wayland
\end{itemize}
% nuttx has some graphic and windowing stack apparently too!

%nice set of screenshots of past famous GUIs:
%http://toastytech.com/guis/
%http://toastytech.com/guis/guitimeline.html

% history me: 
%  - one terminal
%  - job control shell! (otherwise multi tasking OS but just one term so ...)
%  - multi terminal Alt-Fx on Linux
%  - screen or tux programs
%  - X11 and xterm with as many windows you want!
%  - FVWM fast key to many terminals
%  - Emacs eshell fast key to many terminals
%  - virtual desktops
%  - MacOS expose! bird's eye view

\section{Getting started}

\section{Requirements}

% rio.ps
% rio(1) and rio(5)

\section{About this document}
#include "../docs/latex/About.tex.nw"

\section{Copyright}

Most of this document is actually source code from Plan9, so
those parts are copyright by Lucent Technologies Inc.
The prose is mine and is licensed under the GNU Free Documentation
License.

\section{Acknowledgments}


\chapter{Overview}

\section{Windowing system principles}

% a demultiplexer essentially! toy app run outside rio
% but with rio can have "virtual" screen, virtual keyboard/mouse
% also a window manager! mv/resize/close/hide/etc

\section{[[rio]] services}
% the interface!  again the /dev/xxx ?

<<function usage>>=
void
usage(void)
{
    fprint(2, "usage: rio [-f font] [-i initcmd] [-k kbdcmd] [-s]\n");
    exits("usage");
}
@

%see rio(1) and rio(5)!

%$wsys
%$wctl

%/mnt/wsys (unioned also in /dev)
%cons, consctl
%mouse %kbdin
%screen window
%text
%cursor
%label, winid, winname  wdir
%snarf
%wctl 
%wsys/1/

%/srv
%rio.user.pid
%riowctl.user.pid

% mount #s/rio.user.pid /mnt/wsys 1
% mount -b #s/rio.user.pid /dev


% $rio

% manual creation of window (not via menu)
% (see rio(5)
% mount $wsys /tmp 'new -r 0 0 128 64 -pid' $pid
% echo hi > /tmp/cons
% :)


% can run rio inside rio!


%\section{YYY file format}
%rio(5)?

%\section{ZZZ Toy example}
%??

\section{Code organization}

% for the graphic system part see Graphics.tex.nw

%dat.h: data structure and global declarations
%fns.h: prototypes

%globals.c
%data.c: cursors, images, resources

%util.c

%time.c: timer thread
%scrl.c: scrolling
%wind.c: windows manip
%wctl.c: windows control
%fsys.c: /dev/ server
%xfid.c: /dev/ services
%rio.c: main


\section{Architecture overview}

% kernel driver vs libs vs apps vs rio

% see 81/2.ps and rio.ps
% see panel.pdf

% part1: windows (rio)
% part2: toolkit (libpanel)


% there are DS server side and client side.
% Window is server side info about client window. On the client
% side this window is actually stored in a handle called screen.


% show the different threads! mouse, keyboard, close, delete, and xfids

% each window is a thread! when keydown the keyboard thread is triggered
% (it was waiting in the event loop in a recv()), and send the character
% to the input window channel, and the thread corresponding to this window
% who should wait for many channels should be awaken by the thread scheduler
% to process the keyboard input!

% filsysxxx -> xfidxxx -> wxxx


% switch(alt(alts)) { event loop in many threads (mouse, winctl, etc)

%http://tech.slashdot.org/story/14/06/19/1317227/x-window-system-turns-30-years-old?utm_source=slashdot&utm_medium=facebook
%"A server lets clients access a shared resource. On a file server, it's
%storage. On a web server, it's documents. On a compute server, it's
%processing. On an X server, the shared resource is the display, and
%clients are given access to it."



\section{Trace of a mouse click}
% event! find right window, dispatch

%###############################################################################

\chapter{Core Data Structures}

\section{[[display]], [[screen]], etc}

%draw.h, set by initdraw
%Display	*display;
%Image          *screen; // should be renamed window! really TODO?
% = point to the portion of the display for this window
% but for rio it's really the whole screen (unless run recursively)

% so windows are represented as Image pointer. Really a subclass
% of Image with additional methods like originwindow().

%Font		*font;


%display = draw
%screen = current image memory in current display
%window = ? 



\section{[[view]], [[mousectl]], [[keyboardctl]], etc}

<<global view>>=
Image	*view;
@
% = screen global, initialized in main()

<<global viewr>>=
Rectangle	viewr;
@
%view->r




% keyboard.h
<<global keyboardctl>>=
Keyboardctl	*keyboardctl;
@

% mouse.h
<<global mousectl>>=
Mousectl	*mousectl;
@

<<global mouse>>=
Mouse	*mouse;
@
% = mousectl._anon_Mouse






<<global background>>=
Image	*background;
@

<<global wscreen>>=
Screen	*wscreen;
@
% = allocscreen(screen, background)




<<global red>>=
Image	*red;
@
% when moving around windows, the frame become red!
%//Image	*lightgrey;




\section{[[Window]], [[window]], and [[input]]}

<<struct Window>>=
struct Window
{
    int		id;
    Frame;

    /*
     * Rio once used originwindow, so screenr could be different from i->r.
     * Now they're always the same but the code doesn't assume so.
    */
    Rectangle	screenr; /* screen coordinates of window */

    Mousectl	mc; // mc->c is the mouse event listening channel

    <<[[Window]] other fields>>

    <<[[Window]] extra fields>>
};
@
% screenr is ZR when hidden


<<[[Window]] extra fields>>=
Ref;
QLock;
@


%XXXXX
<<[[Window]] other fields>>=
Image		*i;

Mouseinfo	mouse;

Channel		*ck;		/* chan(Rune[10]) */
Channel		*cctl;		/* chan(Wctlmesg)[20] */
Channel		*conswrite;	/* chan(Conswritemesg) */
Channel		*consread;	/* chan(Consreadmesg) */
Channel		*mouseread;	/* chan(Mousereadmesg) */
Channel		*wctlread;	/* chan(Consreadmesg) */

uint		nr;	/* number of runes in window */
uint		maxr;	/* number of runes allocated in r */
Rune		*r;
uint		nraw;
Rune		*raw;
uint		org;
uint		q0;
uint		q1;
uint		qh;
char		name[32];
uint		namecount;
Rectangle	scrollr;
int	 	resized;
int	 	wctlready;
Rectangle	lastsr;
int	 	topped;
int	 	notefd;
uchar		scrolling;
Cursor		cursor;
Cursor		*cursorp;
uchar		holding;
uchar		rawing;
uchar		ctlopen;
uchar		wctlopen;
uchar		deleted;
uchar		mouseopen;
char		*label;
int		pid;
char		*dir;
@

<<global window>>=
//array<option<ref_own<Window>>>
Window	**window;
@

% next free window
<<global nwindow>>=
int		nwindow;
@

% counter
<<global id>>=
static	int		id;
@


% the current window? the one with the focus getting the keyboard events?
<<global input>>=
//option<ref<Window>>, the window with the focus! the window to send input to
Window	*input;
@

<<global hidden>>=
Window	*hidden[100];
@

<<global nhidden>>=
int		nhidden;
@



%ctor!
<<function new>>=
Window*
new(Image *i, bool hideit, bool scrollit, int pid, char *dir, char *cmd, char **argv)
{
    Window *w;
    Mousectl *mc;
    Channel *cm, *ck, *cctl, *cpid;
    void **arg;

    if(i == nil)
        return nil;

    cm = chancreate(sizeof(Mouse), 0);
    ck = chancreate(sizeof(Rune*), 0);
    cctl = chancreate(sizeof(Wctlmesg), 4);
    cpid = chancreate(sizeof(int), 0);
    if(cm==nil || ck==nil || cctl==nil)
        error("new: channel alloc failed");

    mc = emalloc(sizeof(Mousectl));
    *mc = *mousectl;
    mc->image = i;
    mc->c = cm;
    w = wmk(i, mc, ck, cctl, scrollit);
    free(mc);	/* wmk copies *mc */

    // growing array
    window = erealloc(window, ++nwindow*sizeof(Window*));
    window[nwindow-1] = w;
    if(hideit){
        hidden[nhidden++] = w;
        w->screenr = ZR;
    }

    // a new thread! for this new window!
    threadcreate(winctl, w, 8192);
    if(!hideit)
        wcurrent(w);

    flushimage(display, true);

    <<[[new()]] if pid == 0>>

    wsetpid(w, pid, true);
    wsetname(w);
    if(dir)
        w->dir = estrdup(dir);
    chanfree(cpid);
    return w;
}
@

%XXX ?
<<[[new()]] if pid == 0>>=
if(pid == 0){
    arg = emalloc(5*sizeof(void*));
    arg[0] = w;
    arg[1] = cpid;
    arg[2] = cmd;
    if(argv == nil)
        arg[3] = rcargv;
    else
        arg[3] = argv;
    arg[4] = dir;
    proccreate(winshell, arg, 8192);
    pid = recvul(cpid);
    free(arg);
}
if(pid == 0){
    /* window creation failed */
    wsendctlmesg(w, Deleted, ZR, nil);
    chanfree(cpid);
    return nil;
}
@


<<enum _anon_ (windows/rio/dat.h)3>>=
enum
{
    Selborder		= 4,	/* border of selected window */
    Unselborder		= 1,	/* border of unselected window */
    Scrollwid 		= 12,	/* width of scroll bar */
    Scrollgap 		= 4,	/* gap right of scroll bar */
    BIG			= 3,	/* factor by which window dimension can exceed screen */
};
@


<<function wmk>>=
Window*
wmk(Image *i, Mousectl *mc, Channel *ck, Channel *cctl, bool scrolling)
{
    Window *w;
    Rectangle r;

    <<[[wmk()]] cols initialisation>>

    w = emalloc(sizeof(Window));

    w->screenr = i->r;
    r = insetrect(i->r, Selborder+1);
    w->i = i;
    w->mc = *mc;
    w->ck = ck;
    w->cctl = cctl;
    w->cursorp = nil;

    w->conswrite = chancreate(sizeof(Conswritemesg), 0);
    w->consread =  chancreate(sizeof(Consreadmesg), 0);
    w->mouseread =  chancreate(sizeof(Mousereadmesg), 0);
    w->wctlread =  chancreate(sizeof(Consreadmesg), 0);

    w->scrollr = r;
    w->scrollr.max.x = r.min.x+Scrollwid;
    w->lastsr = ZR;
    r.min.x += Scrollwid+Scrollgap;

    frinit(w, r, font, i, cols);

    w->maxtab = maxtab*stringwidth(font, "0");
    w->topped = ++topped;
    w->id = ++id;
    w->notefd = -1;
    w->scrolling = scrolling;
    w->dir = estrdup(startdir);
    w->label = estrdup("<unnamed>");
    r = insetrect(w->i->r, Selborder);

    draw(w->i, r, cols[BACK], nil, w->entire.min);
    wborder(w, Selborder);
    wscrdraw(w);
    incref(w);	/* ref will be removed after mounting; avoids delete before ready to be deleted */
    return w;
}
@

\section{[[FilSys]], [[Fid]], [[Xfid] and [[filsys]]}

<<struct Fid>>=
struct Fid
{
    int		fid;

    int		busy;
    int		open;
    int		mode;

    Qid		qid;

    Window	*w;
    Dirtab	*dir;
    Fid		*next;
    int		nrpart;
    uchar	rpart[UTFmax];
};
@

<<constant Nhash>>=
#define Nhash 16
@

<<struct Filsys>>=
struct Filsys
{
    int		cfd;
    int		sfd;

    int		pid;

    char	*user;

    Channel	*cxfidalloc;	/* chan(Xfid*) */
    Fid		*fids[Nhash];
};
@

<<global filsys>>=
Filsys	*filsys;
@

%\section{[[Xfid]]}

<<struct Xfid>>=
struct Xfid
{
        Ref;
        Xfid	*next;
        Xfid	*free;
        Fcall;
        Channel	*c;	/* chan(void(*)(Xfid*)) */

        Fid	*f;

        uchar	*buf;

        Filsys	*fs;

        QLock	active;
        int	flushing;	/* another Xfid is trying to flush us */
        int	flushtag;	/* our tag, so flush can find us */
        Channel	*flushc;	/* channel(int) to notify us we're being flushed */
};
@

\section{[[Frame]]}

% layers!
<<enum _anon_ (include/frame.h)>>=
enum{
    BACK,
    HIGH,
    BORD,
    TEXT,
    HTEXT,

    NCOL
};
@

<<constant FRTICKW>>=
#define	FRTICKW	3
@

<<struct Frbox>>=
struct Frbox
{
    long		wid;		/* in pixels */
    long		nrune;		/* <0 ==> negate and treat as break char */
    union{
        uchar	*ptr;
        struct{
            short	bc;	/* break char */
            short	minwid;
        };
    };
};
@

<<struct Frame>>=
struct Frame
{
    Font	*font;		/* of chars in the frame */
    Display	*display;	/* on which frame appears */
    Image	*b;		/* on which frame appears */
    Image	*cols[NCOL];	/* text and background colors */
    Rectangle	r;		/* in which text appears */
    Rectangle	entire;		/* of full frame */
    void			(*scroll)(Frame*, int);	/* scroll function provided by application */
    Frbox	*box;
    ulong	p0, p1;		/* selection */
    ushort	nbox, nalloc;
    ushort	maxtab;		/* max size of tab, in pixels */
    ushort	nchars;		/* # runes in frame */
    ushort	nlines;		/* # lines with text */
    ushort	maxlines;	/* total # lines in frame */
    ushort	lastlinefull;	/* last line fills frame */
    ushort	modified;	/* changed since frselect() */
    Image	*tick;	/* typing tick */
    Image	*tickback;	/* saved image under tick */
    int		ticked;	/* flag: is tick onscreen? */
};
@


%images of the frame
<<global cols>>=
static	Image	*cols[NCOL];
@


<<global grey>>=
static	Image	*grey;
@

<<global darkgrey>>=
static	Image	*darkgrey;
@

<<global titlecol>>=
static	Image	*titlecol;
@

<<global lighttitlecol>>=
static	Image	*lighttitlecol;
@

<<global holdcol>>=
static	Image	*holdcol;
@

<<global lightholdcol>>=
static	Image	*lightholdcol;
@

<<global paleholdcol>>=
static	Image	*paleholdcol;
@


<<[[wmk()]] cols initialisation>>=
if(cols[0] == nil){
    /* greys are multiples of 0x11111100+0xFF, 14* being palest */
    grey = allocimage(display, Rect(0,0,1,1), CMAP8, 1, 0xEEEEEEFF);
    darkgrey = allocimage(display, Rect(0,0,1,1), CMAP8, 1, 0x666666FF);
    cols[BACK] = display->white;
    cols[HIGH] = allocimage(display, Rect(0,0,1,1), CMAP8, 1, 0xCCCCCCFF);
    cols[BORD] = allocimage(display, Rect(0,0,1,1), CMAP8, 1, 0x999999FF);
    cols[TEXT] = display->black;
    cols[HTEXT] = display->black;
    titlecol = allocimage(display, Rect(0,0,1,1), CMAP8, 1, DGreygreen);
    lighttitlecol = allocimage(display, Rect(0,0,1,1), CMAP8, 1, DPalegreygreen);
    holdcol = allocimage(display, Rect(0,0,1,1), CMAP8, 1, DMedblue);
    lightholdcol = allocimage(display, Rect(0,0,1,1), CMAP8, 1, DGreyblue);
    paleholdcol = allocimage(display, Rect(0,0,1,1), CMAP8, 1, DPalegreyblue);
}
@

% libframe/
% ... -> new -> wmk() -> <>
<<function frinit>>=
void
frinit(Frame *f, Rectangle r, Font *ft, Image *b, Image *cols[NCOL])
{
    f->font = ft;
    f->display = b->display;
    f->maxtab = 8*stringwidth(ft, "0");
    f->nbox = 0;
    f->nalloc = 0;
    f->nchars = 0;
    f->nlines = 0;
    f->p0 = 0;
    f->p1 = 0;
    f->box = 0;
    f->lastlinefull = 0;
    if(cols != 0)
        memmove(f->cols, cols, sizeof f->cols);
    frsetrects(f, r, b);
    if(f->tick==nil && f->cols[BACK]!=0)
        frinittick(f);
}
@

\section{XXX}

<<global all>>=
QLock	all;			/* BUG */
@


<<global sweeping>>=
int	sweeping;
@

<<global wctlfd>>=
int	wctlfd;
@

<<global menuing>>=
bool menuing;/* menu action is pending; waiting for window to be indicated */
@


\chapter{[[main()]]}
% actually it's threadmain()

\ifallcode
<<[[main()]] locals>>=
char *s;
char buf[256];
@
\fi
%dead? static void *arg[1];

%    //PAD: let's keep the Exit option!
%    //PAD: if(strstr(argv[0], ".out") == nil){
%    //PAD: 	menu3str[Exit] = nil;
%    //PAD: 	Hidden--;
%    //PAD: }

<<function threadmain>>=
//@Scheck: not dead, called by lib_thread probably
void threadmain(int argc, char *argv[])
{
    <<[[main()]] locals>>

    ARGBEGIN{
    <<[[main()]] command line processing>>
    }ARGEND

    <<[[main()]] set some globals>>
    <<[[main()]] set snarffd>>

    if(geninitdraw(nil, derror, nil, "rio", nil, Refnone) < 0){
        fprint(2, "rio: can't open display: %r\n");
        exits("display open");
    }

    view = screen;
    viewr = view->r;

    iconinit(); // allocate background and red images

    <<[[main()]] mouse initialisation>>
    <<[[main()]] keyboard initialisation>>

    wscreen = allocscreen(screen, background, 0);
    if(wscreen == nil)
        error("can't allocate screen");
    
    draw(view, viewr, background, nil, ZP);
    flushimage(display, true);

    <<[[main()]] communication channels creation>>
    <<[[main()]] threads creation>>

    filsys = filsysinit(xfidinit());

    if(filsys == nil)
        fprint(2, "rio: can't create file system server: %r\n");
    else{
        errorshouldabort = true;/* suicide if there's trouble after this */
        <<[[main()]] if initstr or kdbin>>
        threadnotify(shutdown, 1);
        recv(exitchan, nil);
    }
    killprocs();
    threadexitsall(nil);
}
@

% diff geninitdraw vs initdraw? defaults different for ref? Refnone?


<<function iconinit>>=
void
iconinit(void)
{
    background = allocimage(display, Rect(0,0,1,1), RGB24, 1, 0x777777FF);
    red        = allocimage(display, Rect(0,0,1,1), RGB24, 1, 0xDD0000FF);
}
@
% is it really a red?
% why iconinit? icon??


<<[[main()]] mouse initialisation>>=
mousectl = initmouse(nil, screen);
if(mousectl == nil)
    error("can't find mouse");
mouse = mousectl;
@

<<[[main()]] keyboard initialisation>>=
keyboardctl = initkeyboard(nil);
if(keyboardctl == nil)
    error("can't find keyboard");
@

%<<[[main()]] wscreen initialisation>>=
%@

<<global exitchan>>=
Channel	*exitchan;	/* chan(int) */
@

% rio = waiting for many different kind of "events"
<<[[main()]] communication channels creation>>=
exitchan = chancreate(sizeof(int), 0);
winclosechan = chancreate(sizeof(Window*), 0);
deletechan = chancreate(sizeof(char*), 0);
@

<<[[main()]] threads creation>>=
timerinit();
threadcreate(keyboardthread, nil, STACK);
threadcreate(mousethread, nil, STACK);

threadcreate(winclosethread, nil, STACK);
threadcreate(deletethread, nil, STACK);
@


<<global cxfidalloc>>=
static	Channel	*cxfidalloc;	/* chan(Xfid*) */
@

<<global cxfidfree>>=
static	Channel	*cxfidfree;	/* chan(Xfid*) */
@

<<function xfidinit>>=
Channel*
xfidinit(void)
{
    cxfidalloc = chancreate(sizeof(Xfid*), 0);
    cxfidfree = chancreate(sizeof(Xfid*), 0);
    threadcreate(xfidallocthread, nil, STACK);
    return cxfidalloc;
}
@





% dead? written but never read
<<global mainpid>>=
int		mainpid;
@

<<[[main()]] set some globals>>=
mainpid = getpid();
@





<<global startdir>>=
char		*startdir;
@

<<[[main()]] set some globals>>=
if(getwd(buf, sizeof buf) == nil)
    startdir = estrdup(".");
else
    startdir = estrdup(buf);
@





<<global maxtab>>=
int		maxtab = 0;
@

<<[[main()]] set some globals>>=
s = getenv("tabstop");
if(s != nil)
    maxtab = strtol(s, nil, 0);
if(maxtab == 0)
    maxtab = 4;
free(s);
@



\chapter{Threads}
% see rio presentation with architecture

\section{Mouse thread}

<<function mousethread>>=
void
mousethread(void*)
{
    bool sending, inside, scrolling, moving, band;
    Window *oin, *w, *winput;
    Image *i;
    Rectangle r;
    Point xy;
    Mouse tmp;
    static Alt alts[NALT+1];

    threadsetname("mousethread");
    sending = false;
    scrolling = false;
    moving = false;

    alts[MReshape].c = mousectl->resizec;
    alts[MReshape].v = nil;
    alts[MReshape].op = CHANRCV;
    alts[MMouse].c = mousectl->c;
    alts[MMouse].v = &mousectl->Mouse;
    alts[MMouse].op = CHANRCV;
    alts[NALT].op = CHANEND;

    for(;;)
        // event loop
        switch(alt(alts)){
        case MReshape:
            resized();
            break;
        case MMouse:
            if(wkeyboard!=nil && (mouse->buttons & (1<<5))){
                keyboardhide();
                break;
            }
        Again:
            winput = input;
            /* override everything for the keyboard window */
            if(wkeyboard!=nil && ptinrect(mouse->xy, wkeyboard->screenr)){
                /* make sure it's on top; this call is free if it is */
                wtopme(wkeyboard);
                winput = wkeyboard;
            }
            if(winput!=nil && winput->i!=nil){
                /* convert to logical coordinates */
                xy.x = mouse->xy.x + (winput->i->r.min.x-winput->screenr.min.x);
                xy.y = mouse->xy.y + (winput->i->r.min.y-winput->screenr.min.y);

                /* the up and down scroll buttons are not subject to the usual rules */
                if((mouse->buttons&(8|16)) && !winput->mouseopen)
                    goto Sending;

                inside = ptinrect(mouse->xy, insetrect(winput->screenr, Selborder));
                if(winput->mouseopen)
                    scrolling = false;
                else if(scrolling)
                    scrolling = mouse->buttons;
                else
                    scrolling = mouse->buttons && ptinrect(xy, winput->scrollr);
                /* topped will be zero or less if window has been bottomed */
                if(sending == false && !scrolling && winborder(winput, mouse->xy) && winput->topped>0){
                    moving = true;
                }else if(inside && (scrolling || winput->mouseopen || (mouse->buttons&1)))
                    sending = true;
            }else
                sending = false;
            if(sending){
            Sending:
                if(mouse->buttons == 0){
                    cornercursor(winput, mouse->xy, 0);
                    sending = false;
                }else
                    wsetcursor(winput, 0);
                tmp = mousectl->Mouse;
                tmp.xy = xy;
                send(winput->mc.c, &tmp);
                continue;
            }
            w = wpointto(mouse->xy);
            /* change cursor if over anyone's border */
            if(w != nil)
                cornercursor(w, mouse->xy, 0);
            else
                riosetcursor(nil, 0);
            if(moving && (mouse->buttons&7)){
                oin = winput;
                band = mouse->buttons & 3;
                sweeping = 1;
                if(band)
                    i = bandsize(winput);
                else
                    i = drag(winput, &r);
                sweeping = 0;
                if(i != nil){
                    if(winput == oin){
                        if(band)
                            wsendctlmesg(winput, Reshaped, i->r, i);
                        else
                            wsendctlmesg(winput, Moved, r, i);
                        cornercursor(winput, mouse->xy, 1);
                    }else
                        freeimage(i);
                }
            }
            if(w != nil)
                cornercursor(w, mouse->xy, 0);
            /* we're not sending the event, but if button is down maybe we should */
            if(mouse->buttons){
                /* w->topped will be zero or less if window has been bottomed */
                if(w==nil || (w==winput && w->topped>0)){
                    if(mouse->buttons & 1){
                        ;
                    }else if(mouse->buttons & 2){
                        if(winput && !winput->mouseopen)
                            button2menu(winput);
                    }else if(mouse->buttons & 4)
                        button3menu();
                }else{
                    /* if button 1 event in the window, top the window and wait for button up. */
                    /* otherwise, top the window and pass the event on */
                    if(wtop(mouse->xy) && (mouse->buttons!=1 || winborder(w, mouse->xy)))
                        goto Again;
                    goto Drain;
                }
            }
            moving = false;
            break;

        Drain:
            do
                readmouse(mousectl);
            while(mousectl->buttons);
            moving = false;
            goto Again;	/* recalculate mouse position, cursor */
        }
}
@



\section{Keyboard thread}

% the channel is keyboardctl->c, see keyboard.h
% it's initialized in main()

<<function keyboardthread>>=
void
keyboardthread(void*)
{
    Rune buf[2][20], *rp;
    int n, i;

    threadsetname("keyboardthread");
    n = 0;
    for(;;){
        rp = buf[n];
        n = 1-n;
        recv(keyboardctl->c, rp);
        for(i=1; i<nelem(buf[0])-1; i++)
            if(nbrecv(keyboardctl->c, rp+i) <= 0)
                break;
        rp[i] = L'\0';

        if(input != nil)
            sendp(input->ck, rp);
    }
}
@

\section{Windows threads}

% right click -> button3menu() -> new() -> threadcreate(<>)
<<function winctl>>=
void
winctl(void *arg)
{
    Rune *rp, *bp, *tp, *up, *kbdr;
    uint qh;
    int nr, nb, c, wid, i, npart, initial, lastb;
    char *s, *t, part[3];
    Window *w;
    Mousestate *mp, m;
    enum { WKey, WMouse, WMouseread, WCtl, WCwrite, WCread, WWread, NWALT };
    Alt alts[NWALT+1];
    Mousereadmesg mrm;
    Conswritemesg cwm;
    Consreadmesg crm;
    Consreadmesg cwrm;
    Stringpair pair;
    Wctlmesg wcm;
    char buf[4*12+1];

    w = arg;
    snprint(buf, sizeof buf, "winctl-id%d", w->id);
    threadsetname(buf);

    mrm.cm = chancreate(sizeof(Mouse), 0);
    cwm.cw = chancreate(sizeof(Stringpair), 0);
    crm.c1 = chancreate(sizeof(Stringpair), 0);
    crm.c2 = chancreate(sizeof(Stringpair), 0);
    cwrm.c1 = chancreate(sizeof(Stringpair), 0);
    cwrm.c2 = chancreate(sizeof(Stringpair), 0);
    

    alts[WKey].c = w->ck;
    alts[WKey].v = &kbdr;
    alts[WKey].op = CHANRCV;
    alts[WMouse].c = w->mc.c;
    alts[WMouse].v = &w->mc.Mouse;
    alts[WMouse].op = CHANRCV;
    alts[WMouseread].c = w->mouseread;
    alts[WMouseread].v = &mrm;
    alts[WMouseread].op = CHANSND;
    alts[WCtl].c = w->cctl;
    alts[WCtl].v = &wcm;
    alts[WCtl].op = CHANRCV;
    alts[WCwrite].c = w->conswrite;
    alts[WCwrite].v = &cwm;
    alts[WCwrite].op = CHANSND;
    alts[WCread].c = w->consread;
    alts[WCread].v = &crm;
    alts[WCread].op = CHANSND;
    alts[WWread].c = w->wctlread;
    alts[WWread].v = &cwrm;
    alts[WWread].op = CHANSND;
    alts[NWALT].op = CHANEND;

    npart = 0;
    lastb = -1;
    for(;;){
        if(w->mouseopen && w->mouse.counter != w->mouse.lastcounter)
            alts[WMouseread].op = CHANSND;
        else
            alts[WMouseread].op = CHANNOP;
        if(!w->scrolling && !w->mouseopen && w->qh>w->org+w->nchars)
            alts[WCwrite].op = CHANNOP;
        else
            alts[WCwrite].op = CHANSND;
        if(w->deleted || !w->wctlready)
            alts[WWread].op = CHANNOP;
        else
            alts[WWread].op = CHANSND;
        /* this code depends on NL and EOT fitting in a single byte */
        /* kind of expensive for each loop; worth precomputing? */
        if(w->holding)
            alts[WCread].op = CHANNOP;
        else if(npart || (w->rawing && w->nraw>0))
            alts[WCread].op = CHANSND;
        else{
            alts[WCread].op = CHANNOP;
            for(i=w->qh; i<w->nr; i++){
                c = w->r[i];
                if(c=='\n' || c=='\004'){
                    alts[WCread].op = CHANSND;
                    break;
                }
            }
        }
        // event loop
        switch(alt(alts)){
        case WKey:
            for(i=0; kbdr[i]!=L'\0'; i++)
                wkeyctl(w, kbdr[i]);
//			wkeyctl(w, r);
///			while(nbrecv(w->ck, &r))
//				wkeyctl(w, r);
            break;
        case WMouse:
            if(w->mouseopen) {
                w->mouse.counter++;

                /* queue click events */
                if(!w->mouse.qfull && lastb != w->mc.buttons) {	/* add to ring */
                    mp = &w->mouse.queue[w->mouse.wi];
                    if(++w->mouse.wi == nelem(w->mouse.queue))
                        w->mouse.wi = 0;
                    if(w->mouse.wi == w->mouse.ri)
                        w->mouse.qfull = true;
                    mp->Mouse = w->mc;
                    mp->counter = w->mouse.counter;
                    lastb = w->mc.buttons;
                }
            } else
                wmousectl(w);
            break;
        case WMouseread:
            /* send a queued event or, if the queue is empty, the current state */
            /* if the queue has filled, we discard all the events it contained. */
            /* the intent is to discard frantic clicking by the user during long latencies. */
            w->mouse.qfull = false;
            if(w->mouse.wi != w->mouse.ri) {
                m = w->mouse.queue[w->mouse.ri];
                if(++w->mouse.ri == nelem(w->mouse.queue))
                    w->mouse.ri = 0;
            } else
                m = (Mousestate){w->mc.Mouse, w->mouse.counter};

            w->mouse.lastcounter = m.counter;
            send(mrm.cm, &m.Mouse);
            continue;
        case WCtl:
            if(wctlmesg(w, wcm.type, wcm.r, wcm.image) == Exited){
                chanfree(crm.c1);
                chanfree(crm.c2);
                chanfree(mrm.cm);
                chanfree(cwm.cw);
                chanfree(cwrm.c1);
                chanfree(cwrm.c2);
                threadexits(nil);
            }
            continue;
        case WCwrite:
            recv(cwm.cw, &pair);
            rp = pair.s;
            nr = pair.ns;
            bp = rp;
            for(i=0; i<nr; i++)
                if(*bp++ == '\b'){
                    --bp;
                    initial = 0;
                    tp = runemalloc(nr);
                    runemove(tp, rp, i);
                    up = tp+i;
                    for(; i<nr; i++){
                        *up = *bp++;
                        if(*up == '\b')
                            if(up == tp)
                                initial++;
                            else
                                --up;
                        else
                            up++;
                    }
                    if(initial){
                        if(initial > w->qh)
                            initial = w->qh;
                        qh = w->qh-initial;
                        wdelete(w, qh, qh+initial);
                        w->qh = qh;
                    }
                    free(rp);
                    rp = tp;
                    nr = up-tp;
                    rp[nr] = 0;
                    break;
                }
            w->qh = winsert(w, rp, nr, w->qh)+nr;
            if(w->scrolling || w->mouseopen)
                wshow(w, w->qh);
            wsetselect(w, w->q0, w->q1);
            wscrdraw(w);
            free(rp);
            break;
        case WCread:
            recv(crm.c1, &pair);
            t = pair.s;
            nb = pair.ns;
            i = npart;
            npart = 0;
            if(i)
                memmove(t, part, i);
            while(i<nb && (w->qh<w->nr || w->nraw>0)){
                if(w->qh == w->nr){
                    wid = runetochar(t+i, &w->raw[0]);
                    w->nraw--;
                    runemove(w->raw, w->raw+1, w->nraw);
                }else
                    wid = runetochar(t+i, &w->r[w->qh++]);
                c = t[i];	/* knows break characters fit in a byte */
                i += wid;
                if(!w->rawing && (c == '\n' || c=='\004')){
                    if(c == '\004')
                        i--;
                    break;
                }
            }
            if(i==nb && w->qh<w->nr && w->r[w->qh]=='\004')
                w->qh++;
            if(i > nb){
                npart = i-nb;
                memmove(part, t+nb, npart);
                i = nb;
            }
            pair.s = t;
            pair.ns = i;
            send(crm.c2, &pair);
            continue;
        case WWread:
            w->wctlready = 0;
            recv(cwrm.c1, &pair);
            if(w->deleted || w->i==nil)
                pair.ns = sprint(pair.s, "");
            else{
                s = "visible";
                for(i=0; i<nhidden; i++)
                    if(hidden[i] == w){
                        s = "hidden";
                        break;
                    }
                t = "notcurrent";
                if(w == input)
                    t = "current";
                pair.ns = snprint(pair.s, pair.ns, "%11d %11d %11d %11d %s %s ",
                    w->i->r.min.x, w->i->r.min.y, w->i->r.max.x, w->i->r.max.y, t, s);
            }
            send(cwrm.c2, &pair);
            continue;
        }
        if(!w->deleted)
            flushimage(display, 1);
    }
}
@


\section{Closing and delete threads}

<<global winclosechan>>=
Channel	*winclosechan; /* chan(Window*); */
@

<<function winclosethread>>=
/* thread to allow fsysproc to synchronize window closing with main proc */
void
winclosethread(void*)
{
    Window *w;

    threadsetname("winclosethread");
    for(;;){
        w = recvp(winclosechan);
        wclose(w);
    }
}
@


<<global deletechan>>=
Channel*	deletechan;
@

<<function deletethread>>=
/* thread to make Deleted windows that the client still holds disappear offscreen after an interval */
void
deletethread(void*)
{
    char *s;
    Image *i;

    threadsetname("deletethread");
    for(;;){
        s = recvp(deletechan);
        i = namedimage(display, s);
        if(i != nil){
            /* move it off-screen to hide it, since client is slow in letting it go */
            originwindow(i, i->r.min, view->r.max);
        }
        freeimage(i);
        free(s);
    }
}
@


\section{Xfid threads}


<<function xfidallocthread>>=
void
xfidallocthread(void*)
{
    Xfid *x;
    static Alt alts[N+1];

    alts[Alloc].c = cxfidalloc;
    alts[Alloc].v = nil;
    alts[Alloc].op = CHANRCV;
    alts[Free].c = cxfidfree;
    alts[Free].v = &x;
    alts[Free].op = CHANRCV;
    alts[N].op = CHANEND;
    for(;;){
        // event loop
        switch(alt(alts)){
        case Alloc:
            x = xfidfree;
            if(x)
                xfidfree = x->free;
            else{
                x = emalloc(sizeof(Xfid));
                x->c = chancreate(sizeof(void(*)(Xfid*)), 0);
                x->flushc = chancreate(sizeof(int), 0);	/* notification only; no data */
                x->flushtag = -1;
                x->next = xfid;
                xfid = x;
                threadcreate(xfidctl, x, 16384);
            }
            if(x->ref != 0){
                fprint(2, "%p incref %ld\n", x, x->ref);
                error("incref");
            }
            if(x->flushtag != -1)
                error("flushtag in allocate");
            incref(x);
            sendp(cxfidalloc, x);
            break;
        case Free:
            if(x->ref != 0){
                fprint(2, "%p decref %ld\n", x, x->ref);
                error("decref");
            }
            if(x->flushtag != -1)
                error("flushtag in free");
            x->free = xfidfree;
            xfidfree = x;
            break;
        }
    }
}
@


\chapter{System Menus}

\section{Right click menu}
<<enum _anon_ (windows/rio/rio.c)>>=
enum
{
    New,
    Reshape,
    Move,
    Delete,
    Hide,
    Exit,
};
@


<<global Hidden>>=
int	Hidden = Exit+1;
@

<<global menu3str>>=
char		*menu3str[100] = {
 [New]		"New",
 [Reshape]	"Resize",
 [Move]		"Move",
 [Delete]	"Delete",
 [Hide]		"Hide",
 [Exit]		"Exit",
 nil
};
@

<<global menu3>>=
Menu menu3 =
{
    menu3str
};
@


<<function button3menu>>=
void
button3menu(void)
{
    int i;

    for(i=0; i<nhidden; i++)
        menu3str[i+Hidden] = hidden[i]->label;
    menu3str[i+Hidden] = nil;

    sweeping = 1;
    switch(i = menuhit(3, mousectl, &menu3, wscreen)){
    case -1:
        break;
    case New:
        new(sweep(), false, scrolling, 0, nil, "/bin/rc", nil);
        break;
    case Reshape:
        resize();
        break;
    case Move:
        move();
        break;
    case Delete:
        delete();
        break;
    case Hide:
        hide();
        break;
    case Exit:
        if(Hidden > Exit){
            send(exitchan, nil);
            break;
        }
        /* else fall through */
    default:
        unhide(i);
        break;
    }
    sweeping = 0;
}
@

\section{Middle click menu}

<<enum _anon_ (windows/rio/rio.c)2>>=
enum
{
    Cut,
    Paste,
    Snarf,
    Plumb,
    Send,
    Scroll,
};
@

<<global menu2str>>=
char		*menu2str[] = {
 [Cut]		"cut",
 [Paste]	"paste",
 [Snarf]	"snarf",
 [Plumb]	"plumb",
 [Send]		"send",
 [Scroll]	"scroll",
 nil
};
@

<<global menu2>>=
Menu menu2 =
{
    menu2str
};
@


<<function button2menu>>=
void
button2menu(Window *w)
{
    if(w->deleted)
        return;
    incref(w);
    if(w->scrolling)
        menu2str[Scroll] = "noscroll";
    else
        menu2str[Scroll] = "scroll";
    switch(menuhit(2, mousectl, &menu2, wscreen)){
    case Cut:
        wsnarf(w);
        wcut(w);
        wscrdraw(w);
        break;

    case Snarf:
        wsnarf(w);
        break;

    case Paste:
        getsnarf();
        wpaste(w);
        wscrdraw(w);
        break;

    case Plumb:
        wplumb(w);
        break;

    case Send:
        getsnarf();
        wsnarf(w);
        if(nsnarf == 0)
            break;
        if(w->rawing){
            waddraw(w, snarf, nsnarf);
            if(snarf[nsnarf-1]!='\n' && snarf[nsnarf-1]!='\004')
                          waddraw(w, L"\n", 1);
        }else{
            winsert(w, snarf, nsnarf, w->nr);
            if(snarf[nsnarf-1]!='\n' && snarf[nsnarf-1]!='\004')
                winsert(w, L"\n", 1, w->nr);
        }
        wsetselect(w, w->nr, w->nr);
        wshow(w, w->nr);
        break;

    case Scroll:
        if(w->scrolling ^= 1)
            wshow(w, w->nr);
        break;
    }
    wclose(w);
    wsendctlmesg(w, Wakeup, ZR, nil);
    flushimage(display, 1);
}
@



\chapter{Windows}

\chapter{Cursor}
% put pictures instead of code :)
% what is the code that takes the hexa data and draw?


<<global crosscursor (windows/rio/data.c)>>=
Cursor crosscursor = {
    {-7, -7},
    {0x03, 0xC0, 0x03, 0xC0, 0x03, 0xC0, 0x03, 0xC0,
     0x03, 0xC0, 0x03, 0xC0, 0xFF, 0xFF, 0xFF, 0xFF,
     0xFF, 0xFF, 0xFF, 0xFF, 0x03, 0xC0, 0x03, 0xC0,
     0x03, 0xC0, 0x03, 0xC0, 0x03, 0xC0, 0x03, 0xC0, },
    {0x00, 0x00, 0x01, 0x80, 0x01, 0x80, 0x01, 0x80,
     0x01, 0x80, 0x01, 0x80, 0x01, 0x80, 0x7F, 0xFE,
     0x7F, 0xFE, 0x01, 0x80, 0x01, 0x80, 0x01, 0x80,
     0x01, 0x80, 0x01, 0x80, 0x01, 0x80, 0x00, 0x00, }
};
@

<<global boxcursor (windows/rio/data.c)>>=
Cursor boxcursor = {
    {-7, -7},
    {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
     0xFF, 0xFF, 0xF8, 0x1F, 0xF8, 0x1F, 0xF8, 0x1F,
     0xF8, 0x1F, 0xF8, 0x1F, 0xF8, 0x1F, 0xFF, 0xFF,
     0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, },
    {0x00, 0x00, 0x7F, 0xFE, 0x7F, 0xFE, 0x7F, 0xFE,
     0x70, 0x0E, 0x70, 0x0E, 0x70, 0x0E, 0x70, 0x0E,
     0x70, 0x0E, 0x70, 0x0E, 0x70, 0x0E, 0x70, 0x0E,
     0x7F, 0xFE, 0x7F, 0xFE, 0x7F, 0xFE, 0x00, 0x00, }
};
@

<<global sightcursor (windows/rio/data.c)>>=
Cursor sightcursor = {
    {-7, -7},
    {0x1F, 0xF8, 0x3F, 0xFC, 0x7F, 0xFE, 0xFB, 0xDF,
     0xF3, 0xCF, 0xE3, 0xC7, 0xFF, 0xFF, 0xFF, 0xFF,
     0xFF, 0xFF, 0xFF, 0xFF, 0xE3, 0xC7, 0xF3, 0xCF,
     0x7B, 0xDF, 0x7F, 0xFE, 0x3F, 0xFC, 0x1F, 0xF8, },
    {0x00, 0x00, 0x0F, 0xF0, 0x31, 0x8C, 0x21, 0x84,
     0x41, 0x82, 0x41, 0x82, 0x41, 0x82, 0x7F, 0xFE,
     0x7F, 0xFE, 0x41, 0x82, 0x41, 0x82, 0x41, 0x82,
     0x21, 0x84, 0x31, 0x8C, 0x0F, 0xF0, 0x00, 0x00, }
};
@

<<global whitearrow (windows/rio/data.c)>>=
Cursor whitearrow = {
    {0, 0},
    {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFF, 0xFC, 
     0xFF, 0xF0, 0xFF, 0xF0, 0xFF, 0xF8, 0xFF, 0xFC, 
     0xFF, 0xFE, 0xFF, 0xFF, 0xFF, 0xFE, 0xFF, 0xFC, 
     0xF3, 0xF8, 0xF1, 0xF0, 0xE0, 0xE0, 0xC0, 0x40, },
    {0xFF, 0xFF, 0xFF, 0xFF, 0xC0, 0x06, 0xC0, 0x1C, 
     0xC0, 0x30, 0xC0, 0x30, 0xC0, 0x38, 0xC0, 0x1C, 
     0xC0, 0x0E, 0xC0, 0x07, 0xCE, 0x0E, 0xDF, 0x1C, 
     0xD3, 0xB8, 0xF1, 0xF0, 0xE0, 0xE0, 0xC0, 0x40, }
};
@

<<global query (windows/rio/data.c)>>=
Cursor query = {
    {-7,-7},
    {0x0f, 0xf0, 0x1f, 0xf8, 0x3f, 0xfc, 0x7f, 0xfe, 
     0x7c, 0x7e, 0x78, 0x7e, 0x00, 0xfc, 0x01, 0xf8, 
     0x03, 0xf0, 0x07, 0xe0, 0x07, 0xc0, 0x07, 0xc0, 
     0x07, 0xc0, 0x07, 0xc0, 0x07, 0xc0, 0x07, 0xc0, },
    {0x00, 0x00, 0x0f, 0xf0, 0x1f, 0xf8, 0x3c, 0x3c, 
     0x38, 0x1c, 0x00, 0x3c, 0x00, 0x78, 0x00, 0xf0, 
     0x01, 0xe0, 0x03, 0xc0, 0x03, 0x80, 0x03, 0x80, 
     0x00, 0x00, 0x03, 0x80, 0x03, 0x80, 0x00, 0x00, }
};
@

<<global tl>>=
Cursor tl = {
    {-4, -4},
    {0xfe, 0x00, 0x82, 0x00, 0x8c, 0x00, 0x87, 0xff, 
     0xa0, 0x01, 0xb0, 0x01, 0xd0, 0x01, 0x11, 0xff, 
     0x11, 0x00, 0x11, 0x00, 0x11, 0x00, 0x11, 0x00, 
     0x11, 0x00, 0x11, 0x00, 0x11, 0x00, 0x1f, 0x00, },
    {0x00, 0x00, 0x7c, 0x00, 0x70, 0x00, 0x78, 0x00, 
     0x5f, 0xfe, 0x4f, 0xfe, 0x0f, 0xfe, 0x0e, 0x00, 
     0x0e, 0x00, 0x0e, 0x00, 0x0e, 0x00, 0x0e, 0x00, 
     0x0e, 0x00, 0x0e, 0x00, 0x0e, 0x00, 0x00, 0x00, }
};
@

<<global t>>=
static Cursor t = {
    {-7, -8},
    {0x00, 0x00, 0x00, 0x00, 0x03, 0x80, 0x06, 0xc0, 
     0x1c, 0x70, 0x10, 0x10, 0x0c, 0x60, 0xfc, 0x7f, 
     0x80, 0x01, 0x80, 0x01, 0x80, 0x01, 0xff, 0xff, 
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, },
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 
     0x03, 0x80, 0x0f, 0xe0, 0x03, 0x80, 0x03, 0x80, 
     0x7f, 0xfe, 0x7f, 0xfe, 0x7f, 0xfe, 0x00, 0x00, 
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, }
};
@

<<global tr>>=
Cursor tr = {
    {-11, -4},
    {0x00, 0x7f, 0x00, 0x41, 0x00, 0x31, 0xff, 0xe1, 
     0x80, 0x05, 0x80, 0x0d, 0x80, 0x0b, 0xff, 0x88, 
     0x00, 0x88, 0x0, 0x88, 0x00, 0x88, 0x00, 0x88, 
     0x00, 0x88, 0x00, 0x88, 0x00, 0x88, 0x00, 0xf8, },
    {0x00, 0x00, 0x00, 0x3e, 0x00, 0x0e, 0x00, 0x1e, 
     0x7f, 0xfa, 0x7f, 0xf2, 0x7f, 0xf0, 0x00, 0x70, 
     0x00, 0x70, 0x00, 0x70, 0x00, 0x70, 0x00, 0x70, 
     0x00, 0x70, 0x00, 0x70, 0x00, 0x70, 0x00, 0x00, }
};
@

<<global r>>=
Cursor r = {
    {-8, -7},
    {0x07, 0xc0, 0x04, 0x40, 0x04, 0x40, 0x04, 0x58, 
     0x04, 0x68, 0x04, 0x6c, 0x04, 0x06, 0x04, 0x02, 
     0x04, 0x06, 0x04, 0x6c, 0x04, 0x68, 0x04, 0x58, 
     0x04, 0x40, 0x04, 0x40, 0x04, 0x40, 0x07, 0xc0, },
    {0x00, 0x00, 0x03, 0x80, 0x03, 0x80, 0x03, 0x80, 
     0x03, 0x90, 0x03, 0x90, 0x03, 0xf8, 0x03, 0xfc, 
     0x03, 0xf8, 0x03, 0x90, 0x03, 0x90, 0x03, 0x80, 
     0x03, 0x80, 0x03, 0x80, 0x03, 0x80, 0x00, 0x00, }
};
@

<<global br>>=
Cursor br = {
    {-11, -11},
    {0x00, 0xf8, 0x00, 0x88, 0x00, 0x88, 0x00, 0x88, 
     0x00, 0x88, 0x00, 0x88, 0x00, 0x88, 0x00, 0x88, 
     0xff, 0x88, 0x80, 0x0b, 0x80, 0x0d, 0x80, 0x05, 
     0xff, 0xe1, 0x00, 0x31, 0x00, 0x41, 0x00, 0x7f, },
    {0x00, 0x00, 0x00, 0x70, 0x00, 0x70, 0x00, 0x70, 
     0x0, 0x70, 0x00, 0x70, 0x00, 0x70, 0x00, 0x70, 
     0x00, 0x70, 0x7f, 0xf0, 0x7f, 0xf2, 0x7f, 0xfa, 
     0x00, 0x1e, 0x00, 0x0e, 0x00, 0x3e, 0x00, 0x00, }
};
@

<<global b>>=
Cursor b = {
    {-7, -7},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
     0xff, 0xff, 0x80, 0x01, 0x80, 0x01, 0x80, 0x01, 
     0xfc, 0x7f, 0x0c, 0x60, 0x10, 0x10, 0x1c, 0x70, 
     0x06, 0xc0, 0x03, 0x80, 0x00, 0x00, 0x00, 0x00, },
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
     0x00, 0x00, 0x7f, 0xfe, 0x7f, 0xfe, 0x7f, 0xfe, 
     0x03, 0x80, 0x03, 0x80, 0x0f, 0xe0, 0x03, 0x80, 
     0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, }
};
@

<<global bl>>=
Cursor bl = {
    {-4, -11},
    {0x1f, 0x00, 0x11, 0x00, 0x11, 0x00, 0x11, 0x00, 
     0x11, 0x00, 0x11, 0x00, 0x11, 0x00, 0x11, 0x00, 
     0x11, 0xff, 0xd0, 0x01, 0xb0, 0x01, 0xa0, 0x01, 
     0x87, 0xff, 0x8c, 0x00, 0x82, 0x00, 0xfe, 0x00, },
    {0x00, 0x00, 0x0e, 0x00, 0x0e, 0x00, 0x0e, 0x00, 
     0x0e, 0x00, 0x0e, 0x00, 0x0e, 0x00, 0x0e, 0x00, 
     0x0e, 0x00, 0x0f, 0xfe, 0x4f, 0xfe, 0x5f, 0xfe, 
     0x78, 0x00, 0x70, 0x00, 0x7c, 0x00, 0x00, 0x0, }
};
@

<<global l>>=
Cursor l = {
    {-7, -7},
    {0x03, 0xe0, 0x02, 0x20, 0x02, 0x20, 0x1a, 0x20, 
     0x16, 0x20, 0x36, 0x20, 0x60, 0x20, 0x40, 0x20, 
     0x60, 0x20, 0x36, 0x20, 0x16, 0x20, 0x1a, 0x20, 
     0x02, 0x20, 0x02, 0x20, 0x02, 0x20, 0x03, 0xe0, },
    {0x00, 0x00, 0x01, 0xc0, 0x01, 0xc0, 0x01, 0xc0, 
     0x09, 0xc0, 0x09, 0xc0, 0x1f, 0xc0, 0x3f, 0xc0, 
     0x1f, 0xc0, 0x09, 0xc0, 0x09, 0xc0, 0x01, 0xc0, 
     0x01, 0xc0, 0x01, 0xc0, 0x01, 0xc0, 0x00, 0x00, }
};
@

<<global corners (windows/rio/data.c)>>=
Cursor *corners[9] = {
    &tl,	&t,	&tr,
    &l,	nil,	&r,
    &bl,	&b,	&br,
};
@


\chapter{[[filsysinit()]]}

<<function filsysinit>>=
Filsys*
filsysinit(Channel *cxfidalloc)
{
    int n, fd, pid, p0;
    Filsys *fs;
    Channel *c;
    char buf[128];

    fs = emalloc(sizeof(Filsys));
    if(cexecpipe(&fs->cfd, &fs->sfd) < 0)
        goto Rescue;

    fmtinstall('F', fcallfmt);

    clockfd = open("/dev/time", OREAD|OCEXEC);

    fd = open("/dev/user", OREAD);
    strcpy(buf, "Jean-Paul_Belmondo"); // lol
    if(fd >= 0){
        n = read(fd, buf, sizeof buf-1);
        if(n > 0)
            buf[n] = 0;
        close(fd);
    }
    fs->user = estrdup(buf);

    fs->cxfidalloc = cxfidalloc;
    pid = getpid();

    /*
     * Create and post wctl pipe
     */
    if(cexecpipe(&p0, &wctlfd) < 0)
        goto Rescue;
    sprint(srvwctl, "/srv/riowctl.%s.%d", fs->user, pid);
    post(srvwctl, "wctl", p0);
    close(p0);

    /*
     * Start server processes
     */
    c = chancreate(sizeof(char*), 0);
    if(c == nil)
        error("wctl channel");
    proccreate(wctlproc, c, 4096);
    threadcreate(wctlthread, c, 4096);
    proccreate(filsysproc, fs, 10000);

    /*
     * Post srv pipe
     */
    sprint(srvpipe, "/srv/rio.%s.%d", fs->user, pid);
    post(srvpipe, "wsys", fs->cfd);

    return fs;

Rescue:
    free(fs);
    return nil;
}
@




<<function wctlproc>>=
void
wctlproc(void *v)
{
    char *buf;
    int n, eofs;
    Channel *c;

    threadsetname("WCTLPROC");
    c = v;

    eofs = 0;
    for(;;){
        buf = emalloc(messagesize);
        n = read(wctlfd, buf, messagesize-1);	/* room for \0 */
        if(n < 0)
            break;
        if(n == 0){
            if(++eofs > 20)
                break;
            continue;
        }
        eofs = 0;

        buf[n] = '\0';
        sendp(c, buf);
    }
}
@




<<function wctlthread>>=
void
wctlthread(void *v)
{
    char *buf, *arg, *dir;
    int cmd, id, pid, hideit, scrollit;
    Rectangle rect;
    char err[ERRMAX];
    Channel *c;

    c = v;

    threadsetname("WCTLTHREAD");

    for(;;){
        buf = recvp(c);
        cmd = parsewctl(&arg, ZR, &rect, &pid, &id, &hideit, &scrollit, &dir, buf, err);

        switch(cmd){
        case New:
            wctlnew(rect, arg, pid, hideit, scrollit, dir, err);
        }
        free(buf);
    }
}
@





<<function filsysproc>>=
static
void
filsysproc(void *arg)
{
    int n;
    Xfid *x;
    Fid *f;
    Fcall t;
    uchar *buf;
    Filsys *fs;

    threadsetname("FILSYSPROC");
    fs = arg;
    fs->pid = getpid();
    x = nil;
    for(;;){
        buf = emalloc(messagesize+UTFmax);	/* UTFmax for appending partial rune in xfidwrite */
        n = read9pmsg(fs->sfd, buf, messagesize);
        if(n <= 0){
            yield();	/* if threadexitsall'ing, will not return */
            fprint(2, "rio: %d: read9pmsg: %d %r\n", getpid(), n);
            errorshouldabort = false;
            error("eof or i/o error on server channel");
        }
        if(x == nil){
            send(fs->cxfidalloc, nil);
            recv(fs->cxfidalloc, &x);
            x->fs = fs;
        }
        x->buf = buf;
        if(convM2S(buf, n, x) != n)
            error("convert error in convM2S");
        if(DEBUG)
            fprint(2, "rio:<-%F\n", &x->Fcall);
        if(fcall[x->type] == nil)
            x = filsysrespond(fs, x, &t, Ebadfcall);
        else{
            if(x->type==Tversion || x->type==Tauth)
                f = nil;
            else
                f = newfid(fs, x->fid);
            x->f = f;
            x  = (*fcall[x->type])(fs, x, f);
        }
        firstmessage = 0;
    }
}
@

\chapter{[[/dev/...]] Demultiplexer}

\section{Overview}

<<enum qid>>=
enum qid
{
    Qdir,			/* /dev for this window */
    <<enum qid cases>>
    QMAX,
};
@

% window+dev -> qid
<<function QID>>=
#define	QID(w,q)	((w<<8)|(q))
@
% what about overflow? hop will not have too many windows then

% qid -> window
<<function WIN>>=
#define	WIN(q)	((((ulong)(q).path)>>8) & 0xFFFFFF)
@

% qid -> dev
<<function FILE>>=
#define	FILE(q)	(((ulong)(q).path) & 0xFF)
@


<<struct Dirtab>>=
struct Dirtab
{
    char	*name;
    uchar	type;
    uint	qid;
    uint	perm;
};
@

<<global dirtab>>=
Dirtab dirtab[]=
{
    { ".",		QTDIR,	Qdir,		0500|DMDIR },
    <<dirtab array elements>>
    { nil, }
};
@


<<global fcall>>=
Xfid* 	(*fcall[Tmax])(Filsys*, Xfid*, Fid*) =
{
    [Tattach]	= filsysattach,
    [Twalk]	= filsyswalk,
    [Topen]	= filsysopen,
    [Tcreate]	= filsyscreate,
    [Tread]	= filsysread,
    [Twrite]	= filsyswrite,
    [Tclunk]	= filsysclunk,
    [Tremove]   = filsysremove,
    [Tstat]	= filsysstat,
    [Twstat]	= filsyswstat,
    [Tflush]	= filsysflush,
    [Tversion]	= filsysversion,
    [Tauth]	= filsysauth,
};
@




\section{[[/dev/cons]]}

<<enum qid cases>>=
Qcons,
@

<<dirtab array elements>>=
{ "cons",		QTFILE,	Qcons,		0600 },
@

<<[[xfidread()]] cases>>=
case Qcons:
    x->flushtag = x->tag;

    alts[CRdata].c = w->consread;
    alts[CRdata].v = &crm;
    alts[CRdata].op = CHANRCV;
    alts[CRflush].c = x->flushc;
    alts[CRflush].v = nil;
    alts[CRflush].op = CHANRCV;
    alts[NMR].op = CHANEND;

    switch(alt(alts)){
    case CRdata:
        break;
    case CRflush:
        filsyscancel(x);
        return;
    }

    /* received data */
    x->flushtag = -1;
    c1 = crm.c1;
    c2 = crm.c2;
    t = malloc(cnt+UTFmax+1);	/* room to unpack partial rune plus */
    pair.s = t;
    pair.ns = cnt;
    send(c1, &pair);
    if(x->flushing){
        recv(x->flushc, nil);	/* wake up flushing xfid */
        recv(c2, nil);			/* wake up window and toss data */
        free(t);
        filsyscancel(x);
        return;
    }
    qlock(&x->active);
    recv(c2, &pair);
    fc.data = pair.s;
    fc.count = pair.ns;
    filsysrespond(x->fs, x, &fc, nil);
    free(t);
    qunlock(&x->active);
    break;
@

<<[[xfidwrite()]] cases>>=
case Qcons:
    nr = x->f->nrpart;
    if(nr > 0){
        memmove(x->data+nr, x->data, cnt);	/* there's room: see malloc in filsysproc */
        memmove(x->data, x->f->rpart, nr);
        cnt += nr;
        x->f->nrpart = 0;
    }
    r = runemalloc(cnt);
    cvttorunes(x->data, cnt-UTFmax, r, &nb, &nr, nil);
    /* approach end of buffer */
    while(fullrune(x->data+nb, cnt-nb)){
        c = nb;
        nb += chartorune(&r[nr], x->data+c);
        if(r[nr])
            nr++;
    }
    if(nb < cnt){
        memmove(x->f->rpart, x->data+nb, cnt-nb);
        x->f->nrpart = cnt-nb;
    }
    x->flushtag = x->tag;

    alts[CWdata].c = w->conswrite;
    alts[CWdata].v = &cwm;
    alts[CWdata].op = CHANRCV;
    alts[CWflush].c = x->flushc;
    alts[CWflush].v = nil;
    alts[CWflush].op = CHANRCV;
    alts[NCW].op = CHANEND;

    switch(alt(alts)){
    case CWdata:
        break;
    case CWflush:
        filsyscancel(x);
        return;
    }

    /* received data */
    x->flushtag = -1;
    if(x->flushing){
        recv(x->flushc, nil);	/* wake up flushing xfid */
        pair.s = runemalloc(1);
        pair.ns = 0;
        send(cwm.cw, &pair);		/* wake up window with empty data */
        filsyscancel(x);
        return;
    }
    qlock(&x->active);
    pair.s = r;
    pair.ns = nr;
    send(cwm.cw, &pair);
    fc.count = x->count;
    filsysrespond(x->fs, x, &fc, nil);
    qunlock(&x->active);
    return;
@


\section{[[/dev/consctl]]}

<<enum qid cases>>=
Qconsctl,
@
<<dirtab array elements>>=
{ "consctl",	QTFILE,	Qconsctl,	0200 },
@

<<[[xfidopen()]] cases>>=
case Qconsctl:
    if(w->ctlopen){
        filsysrespond(x->fs, x, &t, Einuse);
        return;
    }
    w->ctlopen = true;
    break;
@

<<[[xfidclose()]] cases>>=
case Qconsctl:
    if(w->rawing){
        w->rawing = false;
        wsendctlmesg(w, Rawoff, ZR, nil);
    }
    if(w->holding){
        w->holding = false;
        wsendctlmesg(w, Holdoff, ZR, nil);
    }
    w->ctlopen = false;
    break;
@

<<[[xfidwrite()]] cases>>=
case Qconsctl:
    if(strncmp(x->data, "holdon", 6)==0){
        if(w->holding++ == 0)
            wsendctlmesg(w, Holdon, ZR, nil);
        break;
    }
    if(strncmp(x->data, "holdoff", 7)==0 && w->holding){
        if(--w->holding == false)
            wsendctlmesg(w, Holdoff, ZR, nil);
        break;
    }
    if(strncmp(x->data, "rawon", 5)==0){
        if(w->holding){
            w->holding = false;
            wsendctlmesg(w, Holdoff, ZR, nil);
        }
        if(w->rawing++ == 0)
            wsendctlmesg(w, Rawon, ZR, nil);
        break;
    }
    if(strncmp(x->data, "rawoff", 6)==0 && w->rawing){
        if(--w->rawing == 0)
            wsendctlmesg(w, Rawoff, ZR, nil);
        break;
    }
    filsysrespond(x->fs, x, &fc, "unknown control message");
    return;
@

\section{[[/dev/mouse]]}

<<enum qid cases>>=
Qmouse,
@
<<dirtab array elements>>=
{ "mouse",		QTFILE,	Qmouse,		0600 },
@

<<[[xfidopen()]] cases>>=
case Qmouse:
    if(w->mouseopen){
        filsysrespond(x->fs, x, &t, Einuse);
        return;
    }
    /*
     * Reshaped: there's a race if the appl. opens the
     * window, is resized, and then opens the mouse,
     * but that's rare.  The alternative is to generate
     * a resized event every time a new program starts
     * up in a window that has been resized since the
     * dawn of time.  We choose the lesser evil.
     */
    w->resized = false;
    w->mouseopen = true;
    break;
@


<<[[xfidclose()]] cases>>=
case Qmouse:
    w->resized = false;
    w->mouseopen = false;
    if(w->i != nil)
        wsendctlmesg(w, Refresh, w->i->r, nil);
    break;
@


<<[[xfidread()]] cases>>=
case Qmouse:
    x->flushtag = x->tag;

    alts[MRdata].c = w->mouseread;
    alts[MRdata].v = &mrm;
    alts[MRdata].op = CHANRCV;
    alts[MRflush].c = x->flushc;
    alts[MRflush].v = nil;
    alts[MRflush].op = CHANRCV;
    alts[NMR].op = CHANEND;

    switch(alt(alts)){
    case MRdata:
        break;
    case MRflush:
        filsyscancel(x);
        return;
    }

    /* received data */
    x->flushtag = -1;
    if(x->flushing){
        recv(x->flushc, nil);		/* wake up flushing xfid */
        recv(mrm.cm, nil);			/* wake up window and toss data */
        filsyscancel(x);
        return;
    }
    qlock(&x->active);
    recv(mrm.cm, &ms);
    c = 'm';
    if(w->resized)
        c = 'r';
    n = sprint(buf, "%c%11d %11d %11d %11ld ", c, ms.xy.x, ms.xy.y, ms.buttons, ms.msec);
    w->resized = 0;
    fc.data = buf;
    fc.count = min(n, cnt);
    filsysrespond(x->fs, x, &fc, nil);
    qunlock(&x->active);
    break;
@


<<[[xfidwrite()]] cases>>=
case Qmouse:
    if(w!=input || Dx(w->screenr)<=0)
        break;
    if(x->data[0] != 'm'){
        filsysrespond(x->fs, x, &fc, Ebadmouse);
        return;
    }
    p = nil;
    pt.x = strtoul(x->data+1, &p, 0);
    if(p == nil){
        filsysrespond(x->fs, x, &fc, Eshort);
        return;
    }
    pt.y = strtoul(p, nil, 0);
    if(w==input && wpointto(mouse->xy)==w)
        wsendctlmesg(w, Movemouse, Rpt(pt, pt), nil);
    break;
@

\section{[[/dev/cursor]]}

<<enum qid cases>>=
Qcursor,
@
<<dirtab array elements>>=
{ "cursor",		QTFILE,	Qcursor,	0600 },
@

<<[[xfidclose()]] cases>>=
case Qcursor:
    w->cursorp = nil;
    wsetcursor(w, false);
    break;
@

<<[[xfidread()]] cases>>=
case Qcursor:
    filsysrespond(x->fs, x, &fc, "cursor read not implemented");
    break;
@

<<[[xfidwrite()]] cases>>=
case Qcursor:
    if(cnt < 2*4+2*2*16)
        w->cursorp = nil;
    else{
        w->cursor.offset.x = BGLONG(x->data+0*4);
        w->cursor.offset.y = BGLONG(x->data+1*4);
        memmove(w->cursor.clr, x->data+2*4, 2*2*16);
        w->cursorp = &w->cursor;
    }
    wsetcursor(w, !sweeping);
    break;
@

\chapter{[[/dev/...]] Windows Files}

\section{[[/dev/winid]]}

<<enum qid cases>>=
Qwinid,
@
<<dirtab array elements>>=
{ "winid",		QTFILE,	Qwinid,		0400 },
@

<<[[xfidread()]] cases>>=
case Qwinid:
    n = sprint(buf, "%11d ", w->id);
    t = estrdup(buf);
    goto Text;
@

\section{[[/dev/winname]]}

<<enum qid cases>>=
Qwinname,
@
<<dirtab array elements>>=
{ "winname",	QTFILE,	Qwinname,	0400 },
@

<<[[xfidread()]] cases>>=
case Qwinname:
    n = strlen(w->name);
    if(n == 0){
        filsysrespond(x->fs, x, &fc, "window has no name");
        break;
    }
    t = estrdup(w->name);
    goto Text;
@

\section{[[/dev/label]]}

<<enum qid cases>>=
Qlabel,
@
<<dirtab array elements>>=
{ "label",		QTFILE,	Qlabel,		0600 },
@

<<[[xfidread()]] cases>>=
case Qlabel:
    n = strlen(w->label);
    if(off > n)
        off = n;
    if(off+cnt > n)
        cnt = n-off;
    fc.data = w->label+off;
    fc.count = cnt;
    filsysrespond(x->fs, x, &fc, nil);
    break;
@

<<[[xfidwrite()]] cases>>=
case Qlabel:
    if(off != 0){
        filsysrespond(x->fs, x, &fc, "non-zero offset writing label");
        return;
    }
    free(w->label);
    w->label = emalloc(cnt+1);
    memmove(w->label, x->data, cnt);
    w->label[cnt] = 0;
    break;
@

\section{[[/dev/screen]]}

% but not /dev/draw!
% this is not demultiplex, but instead
% writing to /dev/screen write to /dev/draw at the right place

<<enum qid cases>>=
Qscreen,
@
<<dirtab array elements>>=
{ "screen",		QTFILE,	Qscreen,	0400 },
@

<<[[xfidread()]] cases>>=
case Qscreen:
    i = display->image;
    if(i == nil){
        filsysrespond(x->fs, x, &fc, "no top-level screen");
        break;
    }
    r = i->r;
    /* fall through */

caseImage:
    if(off < 5*12){
        n = sprint(buf, "%11s %11d %11d %11d %11d ",
            chantostr(cbuf, screen->chan),
            i->r.min.x, i->r.min.y, i->r.max.x, i->r.max.y);
        t = estrdup(buf);
        goto Text;
    }
    t = malloc(cnt);
    fc.data = t;
    n = readwindow(i, t, r, off, cnt);	/* careful; fc.count is unsigned */
    if(n < 0){
        buf[0] = 0;
        errstr(buf, sizeof buf);
        filsysrespond(x->fs, x, &fc, buf);
    }else{
        fc.count = n;
        filsysrespond(x->fs, x, &fc, nil);
    }
    free(t);
    return;
@

\section{[[/dev/window]]}

<<enum qid cases>>=
Qwindow,
@
<<dirtab array elements>>=
{ "window",		QTFILE,	Qwindow,	0400 },
@

<<[[xfidread()]] cases>>=
case Qwindow:
    i = w->i;
    if(i == nil || Dx(w->screenr)<=0){
        filsysrespond(x->fs, x, &fc, Enowindow);
        return;
    }
    r = w->screenr;
    goto caseImage;
@

\section{[[/dev/text]]}

<<enum qid cases>>=
Qtext,
@
<<dirtab array elements>>=
{ "text",		QTFILE,	Qtext,		0400 },
@

<<[[xfidread()]] cases>>=
case Qtext:
    t = wcontents(w, &n);
    goto Text;

Text:
    if(off > n){
        off = n;
        cnt = 0;
    }
    if(off+cnt > n)
        cnt = n-off;
    fc.data = t+off;
    fc.count = cnt;
    filsysrespond(x->fs, x, &fc, nil);
    free(t);
    break;
@

\section{[[/dev/kdbin]]}

<<enum qid cases>>=
Qkbdin,
@
<<dirtab array elements>>=
{ "kbdin",		QTFILE,	Qkbdin,		0200 },
@

<<[[xfidopen()]] cases>>=
case Qkbdin:
    if(w !=  wkeyboard){
        filsysrespond(x->fs, x, &t, Eperm);
        return;
    }
    break;
@

<<[[xfidwrite()]] cases>>=
case Qkbdin:
    keyboardsend(x->data, cnt);
    break;
@

\section{[[/dev/wdir]]}

<<enum qid cases>>=
Qwdir,
@
<<dirtab array elements>>=
{ "wdir",		QTFILE,	Qwdir,		0600 },
@

<<[[xfidread()]] cases>>=
case Qwdir:
    t = estrdup(w->dir);
    n = strlen(t);
    goto Text;
@

<<[[xfidwrite()]] cases>>=
case Qwdir:
    if(cnt == 0)
        break;
    if(x->data[cnt-1] == '\n'){
        if(cnt == 1)
            break;
        x->data[cnt-1] = '\0';
    }
    /* assume data comes in a single write */
    /*
      * Problem: programs like dossrv, ftp produce illegal UTF;
      * we must cope by converting it first.
      */
    snprint(buf, sizeof buf, "%.*s", cnt, x->data);
    if(buf[0] == '/'){
        free(w->dir);
        w->dir = estrdup(buf);
    }else{
        p = emalloc(strlen(w->dir) + 1 + strlen(buf) + 1);
        sprint(p, "%s/%s", w->dir, buf);
        free(w->dir);
        w->dir = cleanname(p);
    }
    break;
@

\section{[[/dev/wctl]]}

<<enum qid cases>>=
Qwctl,
@
<<dirtab array elements>>=
{ "wctl",		QTFILE,	Qwctl,		0600 },
@

<<[[xfidopen()]] cases>>=
case Qwctl:
    if(x->mode==OREAD || x->mode==ORDWR){
        /*
         * It would be much nicer to implement fan-out for wctl reads,
         * so multiple people can see the resizings, but rio just isn't
         * structured for that.  It's structured for /dev/cons, which gives
         * alternate data to alternate readers.  So to keep things sane for
         * wctl, we compromise and give an error if two people try to
         * open it.  Apologies.
         */
        if(w->wctlopen){
            filsysrespond(x->fs, x, &t, Einuse);
            return;
        }
        w->wctlopen = true;
        w->wctlready = 1;
        wsendctlmesg(w, Wakeup, ZR, nil);
    }
    break;
@

<<[[xfidclose()]] cases>>=
case Qwctl:
    if(x->f->mode==OREAD || x->f->mode==ORDWR)
        w->wctlopen = false;
break;
@

<<[[xfidread()]] cases>>=
case Qwctl:	/* read returns rectangle, hangs if not resized */
    if(cnt < 4*12){
        filsysrespond(x->fs, x, &fc, Etooshort);
        break;
    }
    x->flushtag = x->tag;

    alts[WCRdata].c = w->wctlread;
    alts[WCRdata].v = &cwrm;
    alts[WCRdata].op = CHANRCV;
    alts[WCRflush].c = x->flushc;
    alts[WCRflush].v = nil;
    alts[WCRflush].op = CHANRCV;
    alts[NMR].op = CHANEND;

    switch(alt(alts)){
    case WCRdata:
        break;
    case WCRflush:
        filsyscancel(x);
        return;
    }

    /* received data */
    x->flushtag = -1;
    c1 = cwrm.c1;
    c2 = cwrm.c2;
    t = malloc(cnt+1);	/* be sure to have room for NUL */
    pair.s = t;
    pair.ns = cnt+1;
    send(c1, &pair);
    if(x->flushing){
        recv(x->flushc, nil);	/* wake up flushing xfid */
        recv(c2, nil);			/* wake up window and toss data */
        free(t);
        filsyscancel(x);
        return;
    }
    qlock(&x->active);
    recv(c2, &pair);
    fc.data = pair.s;
    if(pair.ns > cnt)
        pair.ns = cnt;
    fc.count = pair.ns;
    filsysrespond(x->fs, x, &fc, nil);
    free(t);
    qunlock(&x->active);
    break;
@

<<[[xfidwrite()]] cases>>=
case Qwctl:
    if(writewctl(x, buf) < 0){
        filsysrespond(x->fs, x, &fc, buf);
        return;
    }
    flushimage(display, 1);
    break;
@


<<enum _anon_ (windows/rio/dat.h)5>>=
enum	/* control messages */
{
    Wakeup,
    Reshaped,
    Moved,
    Refresh,
    Movemouse,
    Rawon,
    Rawoff,
    Holdon,
    Holdoff,
    Deleted,
    Exited,
};
@


<<struct Wctlmesg>>=
struct Wctlmesg
{
    int		type;
    Rectangle	r;
    Image	*image;
};
@


\section{[[/dev/wsys]]}

<<enum qid cases>>=
Qwsys,		/* directory of window directories */
@
<<dirtab array elements>>=
{ "wsys",		QTDIR,	Qwsys,		0500|DMDIR },
@


<<enum qid cases>>=
Qwsysdir,		/* window directory, child of wsys */
@


\chapter{Window Terminal}
% fake /dev/cons

% it's really easy thx to the fake /dev/cons and frame lib

\chapter{Widgets}

\section{Frame}
% have libframe/ but also a frame widge in libpanel

\section{Scrolling}
% have also a menu in libpanel, scrollbar

\section{Menu}
% have also a menu in libpanel, popup, pulldown

\section{Libpanel}
% different alloc, different event loop, 
% and the Panel main data structure

\section{Button}

\section{Label}

\section{Text entry}

\section{Completion}

\section{Slider}

\section{List}

\section{Pack}

\section{Canvas}

\section{Text view}

\section{Rich text}


\chapter{Advanced Topics}

\section{Snarf}
%\subsection{[[/dev/snarf]]}


<<enum qid cases>>=
Qsnarf,
@

<<dirtab array elements>>=
{ "snarf",		QTFILE,	Qsnarf,		0600 },
@

<<[[xfidopen()]] cases>>=
case Qsnarf:
    if(x->mode==ORDWR || x->mode==OWRITE){
        if(tsnarf)
            free(tsnarf);	/* collision, but OK */
        ntsnarf = 0;
        tsnarf = malloc(1);
    }
    break;
@

<<[[xfidclose()]] cases>>=
/* odd behavior but really ok: replace snarf buffer when /dev/snarf is closed */
case Qsnarf:
    if(x->f->mode==ORDWR || x->f->mode==OWRITE){
        snarf = runerealloc(snarf, ntsnarf+1);
        cvttorunes(tsnarf, ntsnarf, snarf, &nb, &nsnarf, &nulls);
        free(tsnarf);
        tsnarf = nil;
        ntsnarf = 0;
    }
    break;
@

<<[[xfidread()]] cases>>=
/* The algorithm for snarf and text is expensive but easy and rarely used */
case Qsnarf:
    getsnarf();
    if(nsnarf)
        t = runetobyte(snarf, nsnarf, &n);
    else {
        t = nil;
        n = 0;
    }
    goto Text;
@

<<[[xfidwrite()]] cases>>=
case Qsnarf:
    /* always append only */
    if(ntsnarf > MAXSNARF){	/* avoid thrashing when people cut huge text */
        filsysrespond(x->fs, x, &fc, Elong);
        return;
    }
    tsnarf = erealloc(tsnarf, ntsnarf+cnt+1);	/* room for NUL */
    memmove(tsnarf+ntsnarf, x->data, cnt);
    ntsnarf += cnt;
    snarfversion++;
    break;
@


<<global tsnarf>>=
static	char	*tsnarf;
@

<<global ntsnarf>>=
static	int	ntsnarf;
@






<<global snarffd>>=
fdt		snarffd;
@

<<[[main()]] set snarffd>>=
snarffd = open("/dev/snarf", OREAD|OCEXEC);
@

<<global nsnarf>>=
int		nsnarf;
@

<<global snarf>>=
Rune*	snarf;
@

<<global snarfversion>>=
int		snarfversion;	/* updated each time it is written */
@


<<function putsnarf>>=
/*
 * /dev/snarf updates when the file is closed, so we must open our own
 * fd here rather than use snarffd
 */
void
putsnarf(void)
{
    int fd, i, n;

    if(snarffd<0 || nsnarf==0)
        return;
    fd = open("/dev/snarf", OWRITE);
    if(fd < 0)
        return;
    /* snarf buffer could be huge, so fprint will truncate; do it in blocks */
    for(i=0; i<nsnarf; i+=n){
        n = nsnarf-i;
        if(n >= 256)
            n = 256;
        if(fprint(fd, "%.*S", n, snarf+i) < 0)
            break;
    }
    close(fd);
}
@

<<function getsnarf>>=
void
getsnarf(void)
{
    int i, n, nb, nulls;
    char *sn, buf[1024];

    if(snarffd < 0)
        return;
    sn = nil;
    i = 0;
    seek(snarffd, 0, 0);
    while((n = read(snarffd, buf, sizeof buf)) > 0){
        sn = erealloc(sn, i+n+1);
        memmove(sn+i, buf, n);
        i += n;
        sn[i] = 0;
    }
    if(i > 0){
        snarf = runerealloc(snarf, i+1);
        cvttorunes(sn, i, snarf, &nb, &nsnarf, &nulls);
        free(sn);
    }
}
@



\section{Plumb}

\section{Auto complete}

\section{Scrolling, [[rio -s]]}

<<global scrolling>>=
bool		scrolling;
@

<<[[main()]] command line processing>>=
case 's':
    scrolling = true;
    break;
@

<<enum _anon_ (windows/rio/dat.h)2>>=
enum
{
    Kscrolloneup = KF|0x20,
    Kscrollonedown = KF|0x21,
};
@

\section{Initial command, [[rio -i]]}

<<[[main()]] locals>>=
char *initstr = nil;
@

<<[[main()]] command line processing>>=
case 'i':
    initstr = ARGF();
    if(initstr == nil)
        usage();
    break;
@

<<[[main()]] if initstr or kdbin>>=
if(initstr)
    proccreate(initcmd, initstr, STACK);
@

<<function initcmd>>=
void
initcmd(void *arg)
{
    char *cmd;

    cmd = arg;
    rfork(RFENVG|RFFDG|RFNOTEG|RFNAMEG);
    procexecl(nil, "/bin/rc", "rc", "-c", cmd, nil);
    fprint(2, "rio: exec failed: %r\n");
    exits("exec");
}
@

\section{Fake keyboard input, [[rio -k]]}

<<global wkeyboard>>=
Window	*wkeyboard;	/* window of simulated keyboard */
@

<<[[main()]] locals>>=
char *kbdin = nil;
@

<<[[main()]] command line processing>>=
case 'k':
    if(kbdin != nil)
        usage();
    kbdin = ARGF();
    if(kbdin == nil)
        usage();
    break;
@

<<[[main()]] locals>>=
Image *i;
Rectangle r;
@

<<global kbdargv>>=
char *kbdargv[] = { "rc", "-c", nil, nil };
@

<<[[main()]] if initstr or kdbin>>=
if(kbdin){
    kbdargv[2] = kbdin;
    r = screen->r;
    r.max.x = r.min.x+300;
    r.max.y = r.min.y+80;
    i = allocwindow(wscreen, r, Refbackup, DWhite);
    wkeyboard = new(i, false, scrolling, 0, nil, "/bin/rc", kbdargv);
    if(wkeyboard == nil)
        error("can't create keyboard window");
}
@

\section{Font, [[rio -f]]}

<<global fontname>>=
char		*fontname;
@

<<[[main()]] command line processing>>=
case 'f':
    fontname = ARGF();
    if(fontname == nil)
        usage();
    break;
@

<<[[main()]] set some globals>>=
if(fontname == nil)
    fontname = getenv("font");
if(fontname == nil)
    fontname = "/lib/font/bit/lucm/unicode.9.font";

/* check font before barging ahead */
if(access(fontname, 0) < 0){
    fprint(2, "rio: can't access %s: %r\n", fontname);
    exits("font open");
}
putenv("font", fontname);
@

\chapter{Conclusion}

\appendix

\chapter{Debugging}

% _drawdebug?

% errorshouldabort could be here

\chapter{Profiling}

\chapter{Error Managment}

\section{Error codes}

% fsys.c
<<global Eperm>>=
char Eperm[] = "permission denied";
@

<<global Eexist>>=
char Eexist[] = "file does not exist";
@

<<global Enotdir>>=
char Enotdir[] = "not a directory";
@

<<global Ebadfcall>>=
char	Ebadfcall[] = "bad fcall type";
@

<<global Eoffset>>=
char	Eoffset[] = "illegal offset";
@


% wctl.c
<<global Ebadwr>>=
char	Ebadwr[]		= "bad rectangle in wctl request";
@

<<global Ewalloc>>=
char	Ewalloc[]		= "window allocation failed in wctl request";
@


% xfid.c

<<global Einuse>>=
char Einuse[] =		"file in use";
@

<<global Edeleted>>=
char Edeleted[] =	"window deleted";
@

<<global Ebadreq>>=
char Ebadreq[] =	"bad graphics request";
@

<<global Etooshort>>=
char Etooshort[] =	"buffer too small";
@

<<global Ebadtile>>=
char Ebadtile[] =	"unknown tile";
@

<<global Eshort>>=
char Eshort[] =		"short i/o request";
@

<<global Elong>>=
char Elong[] = 		"snarf buffer too long";
@

<<global Eunkid>>=
char Eunkid[] = 	"unknown id in attach";
@

<<global Ebadrect>>=
char Ebadrect[] = 	"bad rectangle in attach";
@

<<global Ewindow>>=
char Ewindow[] = 	"cannot make window";
@

<<global Enowindow>>=
char Enowindow[] = 	"window has no image";
@

<<global Ebadmouse>>=
char Ebadmouse[] = 	"bad format on /dev/mouse";
@

<<global Ebadwrect>>=
char Ebadwrect[] = 	"rectangle outside screen";
@

<<global Ebadoffset>>=
char Ebadoffset[] = 	"window read not on scan line boundary";
@

\section{[[error()]], [[derror()]]}


<<global errorshouldabort>>=
bool errorshouldabort = false;
@

<<function error>>=
void
error(char *s)
{
    fprint(STDERR, "rio: %s: %r\n", s);
    if(errorshouldabort)
        abort();
    threadexitsall("error");
}
@
% abort? diff with exit? generate a fault so go in broken state so
% can be debugged!


% argument to geninitdraw()
<<function derror>>=
void
derror(Display*, char *errorstr)
{
    error(errorstr);
}
@



\chapter{Libc}

<<function min>>=
int
min(int a, int b)
{
    if(a < b)
        return a;
    return b;
}
@

<<function max (windows/rio/util.c)>>=
int
max(int a, int b)
{
    if(a > b)
        return a;
    return b;
}
@



<<function erealloc>>=
void*
erealloc(void *p, uint n)
{
    p = realloc(p, n);
    if(p == nil)
        error("realloc failed");
    return p;
}
@

<<function emalloc>>=
void*
emalloc(uint n)
{
    void *p;

    p = malloc(n);
    if(p == nil)
        error("malloc failed");
    memset(p, 0, n);
    return p;
}
@

<<function estrdup>>=
char*
estrdup(char *s)
{
    char *p;

    p = malloc(strlen(s)+1);
    if(p == nil)
        error("strdup failed");
    strcpy(p, s);
    return p;
}
@




<<function isalnum>>=
//@Scheck: not dead, but conflict with the one in ctype.h
int isalnum(Rune c)
{
    /*
     * Hard to get absolutely right.  Use what we know about ASCII
     * and assume anything above the Latin control characters is
     * potentially an alphanumeric.
     */
    if(c <= ' ')
        return false;
    if(0x7F<=c && c<=0xA0)
        return false;
    if(utfrune("!\"#$%&'()*+,-./:;<=>?@[\\]^`{|}~", c))
        return false;
    return true;
}
@
%$




<<function cvttorunes>>=
void
cvttorunes(char *p, int n, Rune *r, int *nb, int *nr, int *nulls)
{
    uchar *q;
    Rune *s;
    int j, w;

    /*
     * Always guaranteed that n bytes may be interpreted
     * without worrying about partial runes.  This may mean
     * reading up to UTFmax-1 more bytes than n; the caller
     * knows this.  If n is a firm limit, the caller should
     * set p[n] = 0.
     */
    q = (uchar*)p;
    s = r;
    for(j=0; j<n; j+=w){
        if(*q < Runeself){
            w = 1;
            *s = *q++;
        }else{
            w = chartorune(s, (char*)q);
            q += w;
        }
        if(*s)
            s++;
        else if(nulls)
                *nulls = true;
    }
    *nb = (char*)q-p;
    *nr = s-r;
}
@




<<function strrune>>=
Rune*
strrune(Rune *s, Rune c)
{
    Rune c1;

    if(c == 0) {
        while(*s++)
            ;
        return s-1;
    }

    while(c1 = *s++)
        if(c1 == c)
            return s-1;
    return nil;
}
@

<<function runetobyte>>=
char*
runetobyte(Rune *r, int n, int *ip)
{
    char *s;
    int m;

    s = emalloc(n*UTFmax+1);
    m = snprint(s, n*UTFmax+1, "%.*S", n, r);
    *ip = m;
    return s;
}
@








\chapter{Extra Code}

\ifallcode
#include "Windows_extra.tex.nw"
\fi

\chapter{Changelog}
\label{sec:changelog}

\chapter{Glossary}
\label{sec:glossary}

\begin{verbatim}
\end{verbatim}

\chapter*{Indexes}
\addcontentsline{toc}{section}{Index}

%\chapter{References} 
\addcontentsline{toc}{section}{References}

\begin{thebibliography}{99}

\bibitem[1]{wp-literate-programming} Donald Knuth,,
{\em Literate Programming}, 
\url{http://en.wikipedia.org/wiki/Literate\_Program}

\bibitem[2]{noweb} Norman Ramsey,
{\em Noweb}, 
\url{http://www.cs.tufts.edu/~nr/noweb/}

\bibitem[3]{syncweb} Yoann Padioleau,
{\em Syncweb, literate programming meets unison}, 
\url{http://padator.org/software/project-syncweb/readme.txt}

\end{thebibliography}

%******************************************************************************
% Postlude
%******************************************************************************

\end{document}

