\documentclass[twocolumn]{report}

%******************************************************************************
% Prelude
%******************************************************************************
\newif\iffinal
\newif\ifverbose
\finaltrue\verbosefalse
% see also other newif in Macros.tex

%------------------------------------------------------------------------------
%history: 
%------------------------------------------------------------------------------

%thx to LP, changed for the better a few things:

%thx to codemap/codegraph/scheck:
% - TODO use cg to reduce backward deps, introduce globals.c, utils.c,
%   (harder to understand non layered code)
% - TODO use scheck to remove deadcode, dead prototypes, useless export
%   or mv as forward decl
%   (harder to understand big interface files)
% - TODO use cg to reduce number of globals by moving them closer to the
%   relevant file (or even function), better cluster the code
%   (harder to understand non functional code using lots of globals)

%thx to this manual, better understand X11?:

%history LP-ization:
% - skeleton, mostly copy paste of Template.tex.nw skeleton
% - put all content of files in the Extra section, via 'pfff -lpize'
%   which also now split in chunks!
%    * function, global, struct, enum, constant, macro(actually function)
%    * TODO ctor/dtor, dumper
%    * TODO [[xxx]] other fields, [[xxx]] extra fields
% - TODO read Extra section, identify concepts, first TOC
% - TODO distribute parts of the Extra section in the main file
% - TODO understand main(), LP split main, improve TOC
% - TODO understand main functions, LP split, cluster, improve TOC
% - TODO LP split the structures, use datalog for flow to field info
% - TODO nullify, boolify, errorify, enumify,  typeify,    scheckify, plan9ify
% - TODO aspecify advanced features! remove useless features
% - TODO add figures
% - TODO add explanations

%------------------------------------------------------------------------------
% Packages
%------------------------------------------------------------------------------

\usepackage{../docs/latex/noweb}
 \noweboptions{footnotesizecode,nomargintag}
 %note: allow chunk on different pages, less white space at bottom of pages
 \def\nwendcode{\endtrivlist \endgroup}
 \let\nwdocspar=\par
\usepackage{xspace}
\usepackage{verbatim}
%note: required by noweblatexpad for the \t \l \n in this file
\usepackage{fancyvrb}
\usepackage{url}
\iffinal
\usepackage{hyperref}
 \hypersetup{colorlinks=true}
\fi
\usepackage[pageref]{backref}
 \def\backref{{\footnotesize cited page(s)}~}
%\usepackage{cleveref} %\cref
%\usepackage{multirow}
\usepackage{booktabs} 
 \newcommand{\otoprule}{\midrule[\heavyrulewidth]}
\usepackage{graphicx}
 %\usepackage[margin=0.5in]{geometry}
 %  but eat the bottom when very low
 %\usepackage{fullpage} is deprecated 
 % => do the more manual below:
 \addtolength{\oddsidemargin}{-.850in}
 \addtolength{\evensidemargin}{-.850in}
 \addtolength{\textwidth}{1.70in}
 \addtolength{\topmargin}{-.850in}
 \addtolength{\textheight}{1.70in}
%\usepackage{minitoc}

%------------------------------------------------------------------------------
% Macros
%------------------------------------------------------------------------------
\input{../docs/latex/Macros}

%------------------------------------------------------------------------------
% Config
%------------------------------------------------------------------------------
\allcodefalse
% used for forward decl, pragmas, func decl, extern decl, stats, #ifdef,
% debugging macros

%\setcounter{tocdepth}{1}

%******************************************************************************
% Title
%******************************************************************************

\begin{document}

\title{
{\Huge 
Principia Softwarica: Plan9 Windowing System [[rio]]
}\\
{version 0.1}
}

\author{
Yoann Padioleau\\
\texttt{yoann.padioleau@gmail.com}
}

\maketitle 
\onecolumn
\hrule
\begin{quote}
    Copyright \copyright{} 2014 Yoann Padioleau \\
    Permission is granted to copy, distribute and/or modify this document,
    except all the source code it contains, under the terms of the GNU Free
    Documentation License, Version 1.3.
\end{quote}
\hrule

%CONFIG: \dominitoc

\iffinal
\begingroup
\hypersetup{linkcolor=blue}
% need to s/onecolumn/twocolumn in report.cls :) for \tableofcontents
\twocolumn
\tableofcontents
\endgroup
\else
\tableofcontents
\fi

%******************************************************************************
% Body
%******************************************************************************

\chapter{Introduction}

\section{Motivations}

The goal of this book is to present in full details the source code of
a real windowing system.
Why? Because I think it makes you a better programmer if
you fully understand how things work under the hood.

Here are other candidates that were considered but ultimately discarded:
\begin{itemize}
\item Mini X
\item Nano X (MicroWindows)
\item X11
\item Wayland
\end{itemize}
% nuttx has some graphic and windowing stack apparently too!

%nice set of screenshots of past famous GUIs:
%http://toastytech.com/guis/
%http://toastytech.com/guis/guitimeline.html

% history me: 
%  - one terminal
%  - job control shell! (otherwise multi tasking OS but just one term so ...)
%  - multi terminal Alt-Fx on Linux
%  - screen or tux programs
%  - X11 and xterm with as many windows you want!
%  - FVWM fast key to many terminals
%  - Emacs eshell fast key to many terminals
%  - virtual desktops
%  - MacOS expose! bird's eye view

\section{Getting started}

\section{Requirements}

\section{About this document}
#include "../docs/latex/About.tex.nw"

\section{Copyright}

Most of this document is actually source code from Plan9, so
those parts are copyright by Lucent Technologies Inc.
The prose is mine and is licensed under the GNU Free Documentation
License.

\section{Acknowledgments}


\chapter{Overview}

\section{Windowing system principles}

% a demultiplexer essentially! toyapp run outside rio
% but with rio can have "virtual" screen, virtual keyboard/mouse

\section{[[rio]] services}
% the interface!  again the /dev/xxx ?
% can run rio inside rio!


<<function usage>>=
void
usage(void)
{
    fprint(2, "usage: rio [-f font] [-i initcmd] [-k kbdcmd] [-s]\n");
    exits("usage");
}
@


%\section{YYY file format}
%rio(5)?

%\section{ZZZ Toy example}
%??

\section{Code organization}

% graphic system part! see Graphics.tex.nw

% rio, frame?

\section{Architecture overview}

% kernel driver vs libs vs apps vs rio

% see 81/2.ps and rio.ps
% see panel.pdf

% part2: windows (rio)
% part3: toolkit (libpanel)

%http://tech.slashdot.org/story/14/06/19/1317227/x-window-system-turns-30-years-old?utm_source=slashdot&utm_medium=facebook
%"A server lets clients access a shared resource. On a file server, it's
%storage. On a web server, it's documents. On a compute server, it's
%processing. On an X server, the shared resource is the display, and
%clients are given access to it."

\section{Trace of a mouse click}
% event! find right window, dispatch

%###############################################################################

\chapter{Core Data Structures}

\section{[[display]], [[view]], [[mouse]], etc}

<<global display>>=
Display	*display;
@

<<global view>>=
Image	*view;
@

<<global wscreen>>=
Screen	*wscreen;
@


<<global font>>=
Font		*font;
@



<<global mousectl>>=
Mousectl	*mousectl;
@

<<global mouse>>=
Mouse	*mouse;
@

<<global keyboardctl>>=
Keyboardctl	*keyboardctl;
@



<<global background>>=
Image	*background;
@

<<global lightgrey>>=
//Image	*lightgrey;
@

<<global red>>=
Image	*red;
@





\section{[[Window]] and [[window]]}

<<struct Window>>=
struct Window
{
    Ref;
    QLock;
    Frame;

    Image		*i;
    Mousectl		mc;
    Mouseinfo	mouse;
    Channel		*ck;		/* chan(Rune[10]) */
    Channel		*cctl;		/* chan(Wctlmesg)[20] */
    Channel		*conswrite;	/* chan(Conswritemesg) */
    Channel		*consread;	/* chan(Consreadmesg) */
    Channel		*mouseread;	/* chan(Mousereadmesg) */
    Channel		*wctlread;	/* chan(Consreadmesg) */
    uint			nr;	/* number of runes in window */
    uint			maxr;	/* number of runes allocated in r */
    Rune			*r;
    uint			nraw;
    Rune			*raw;
    uint			org;
    uint			q0;
    uint			q1;
    uint			qh;
    int			id;
    char			name[32];
    uint			namecount;
    Rectangle		scrollr;
    /*
     * Rio once used originwindow, so screenr could be different from i->r.
     * Now they're always the same but the code doesn't assume so.
    */
    Rectangle		screenr;	/* screen coordinates of window */
    int			resized;
    int			wctlready;
    Rectangle		lastsr;
    int			topped;
    int			notefd;
    uchar		scrolling;
    Cursor		cursor;
    Cursor		*cursorp;
    uchar		holding;
    uchar		rawing;
    uchar		ctlopen;
    uchar		wctlopen;
    uchar		deleted;
    uchar		mouseopen;
    char		*label;
    int			pid;
    char		*dir;
};
@

<<global window>>=
Window	**window;
@

<<global nwindow>>=
int		nwindow;
@

<<global wkeyboard>>=
Window	*wkeyboard;	/* window of simulated keyboard */
@

<<global input>>=
Window	*input;
@

<<global hidden>>=
Window	*hidden[100];
@

<<global nhidden>>=
int		nhidden;
@





<<function new>>=
Window*
new(Image *i, int hideit, int scrollit, int pid, char *dir, char *cmd, char **argv)
{
    Window *w;
    Mousectl *mc;
    Channel *cm, *ck, *cctl, *cpid;
    void **arg;

    if(i == nil)
        return nil;
    cm = chancreate(sizeof(Mouse), 0);
    ck = chancreate(sizeof(Rune*), 0);
    cctl = chancreate(sizeof(Wctlmesg), 4);
    cpid = chancreate(sizeof(int), 0);
    if(cm==nil || ck==nil || cctl==nil)
        error("new: channel alloc failed");
    mc = emalloc(sizeof(Mousectl));
    *mc = *mousectl;
    mc->image = i;
    mc->c = cm;
    w = wmk(i, mc, ck, cctl, scrollit);
    free(mc);	/* wmk copies *mc */
    window = erealloc(window, ++nwindow*sizeof(Window*));
    window[nwindow-1] = w;
    if(hideit){
        hidden[nhidden++] = w;
        w->screenr = ZR;
    }
    threadcreate(winctl, w, 8192);
    if(!hideit)
        wcurrent(w);
    flushimage(display, 1);
    if(pid == 0){
        arg = emalloc(5*sizeof(void*));
        arg[0] = w;
        arg[1] = cpid;
        arg[2] = cmd;
        if(argv == nil)
            arg[3] = rcargv;
        else
            arg[3] = argv;
        arg[4] = dir;
        proccreate(winshell, arg, 8192);
        pid = recvul(cpid);
        free(arg);
    }
    if(pid == 0){
        /* window creation failed */
        wsendctlmesg(w, Deleted, ZR, nil);
        chanfree(cpid);
        return nil;
    }
    wsetpid(w, pid, 1);
    wsetname(w);
    if(dir)
        w->dir = estrdup(dir);
    chanfree(cpid);
    return w;
}
@

\section{[[FidRio]]}

<<struct FidRio>>=
struct FidRio
{
    int		fid;
    int		busy;
    int		open;
    int		mode;
    Qid		qid;
    Window	*w;
    Dirtab	*dir;
    Fid		*next;
    int		nrpart;
    uchar	rpart[UTFmax];
};
@

\section{[[FilSys]] and [[filsys]]}

<<constant Nhash>>=
#define Nhash 16
@

<<struct Filsys>>=
struct Filsys
{
    int		cfd;
    int		sfd;
    int		pid;
    char	*user;
    Channel	*cxfidalloc;	/* chan(Xfid*) */
    Fid		*fids[Nhash];
};
@

<<global filsys>>=
Filsys	*filsys;
@

\section{[[Xfid]]}

<<struct Xfid>>=
struct Xfid
{
        Ref;
        Xfid		*next;
        Xfid		*free;
        Fcall;
        Channel	*c;	/* chan(void(*)(Xfid*)) */
        Fid		*f;
        uchar	*buf;
        Filsys	*fs;
        QLock	active;
        int		flushing;	/* another Xfid is trying to flush us */
        int		flushtag;	/* our tag, so flush can find us */
        Channel	*flushc;	/* channel(int) to notify us we're being flushed */
};
@

\section{[[Frame]]}


<<enum _anon_ (include/frame.h)>>=
enum{
    BACK,
    HIGH,
    BORD,
    TEXT,
    HTEXT,
    NCOL
};
@

<<constant FRTICKW>>=
#define	FRTICKW	3
@

<<struct Frbox>>=
struct Frbox
{
    long		wid;		/* in pixels */
    long		nrune;		/* <0 ==> negate and treat as break char */
    union{
        uchar	*ptr;
        struct{
            short	bc;	/* break char */
            short	minwid;
        };
    };
};
@

<<struct Frame>>=
struct Frame
{
    Font		*font;		/* of chars in the frame */
    Display		*display;	/* on which frame appears */
    Image		*b;		/* on which frame appears */
    Image		*cols[NCOL];	/* text and background colors */
    Rectangle	r;		/* in which text appears */
    Rectangle	entire;		/* of full frame */
    void			(*scroll)(Frame*, int);	/* scroll function provided by application */
    Frbox		*box;
    ulong		p0, p1;		/* selection */
    ushort		nbox, nalloc;
    ushort		maxtab;		/* max size of tab, in pixels */
    ushort		nchars;		/* # runes in frame */
    ushort		nlines;		/* # lines with text */
    ushort		maxlines;	/* total # lines in frame */
    ushort		lastlinefull;	/* last line fills frame */
    ushort		modified;	/* changed since frselect() */
    Image		*tick;	/* typing tick */
    Image		*tickback;	/* saved image under tick */
    int			ticked;	/* flag: is tick onscreen? */
};
@


\section{XXX}

<<global all>>=
QLock	all;			/* BUG */
@


<<global scrolling>>=
int		scrolling;
@

<<global maxtab>>=
int		maxtab;
@

<<global deletechan>>=
Channel*	deletechan;
@

<<global startdir>>=
char		*startdir;
@

<<global sweeping>>=
int		sweeping;
@

<<global wctlfd>>=
int		wctlfd;
@

<<global menuing>>=
int		menuing;		/* menu action is pending; waiting for window to be indicated */
@


\chapter{[[main()]]}

<<function threadmain>>=
//@Scheck: not dead, called by lib_thread?
void threadmain(int argc, char *argv[])
{
    char *initstr, *kbdin, *s;
    static void *arg[1];
    char buf[256];
    Image *i;
    Rectangle r;

    //PAD: let's keep the Exit option!
    //PAD: if(strstr(argv[0], ".out") == nil){
    //PAD: 	menu3str[Exit] = nil;
    //PAD: 	Hidden--;
    //PAD: }
    initstr = nil;
    kbdin = nil;
    maxtab = 0;
    ARGBEGIN{
    case 'f':
        fontname = ARGF();
        if(fontname == nil)
            usage();
        break;
    case 'i':
        initstr = ARGF();
        if(initstr == nil)
            usage();
        break;
    case 'k':
        if(kbdin != nil)
            usage();
        kbdin = ARGF();
        if(kbdin == nil)
            usage();
        break;
    case 's':
        scrolling = TRUE;
        break;
    }ARGEND

    mainpid = getpid();
    if(getwd(buf, sizeof buf) == nil)
        startdir = estrdup(".");
    else
        startdir = estrdup(buf);
    if(fontname == nil)
        fontname = getenv("font");
    if(fontname == nil)
        fontname = "/lib/font/bit/lucm/unicode.9.font";
    s = getenv("tabstop");
    if(s != nil)
        maxtab = strtol(s, nil, 0);
    if(maxtab == 0)
        maxtab = 4;
    free(s);
    /* check font before barging ahead */
    if(access(fontname, 0) < 0){
        fprint(2, "rio: can't access %s: %r\n", fontname);
        exits("font open");
    }
    putenv("font", fontname);

    snarffd = open("/dev/snarf", OREAD|OCEXEC);

    if(geninitdraw(nil, derror, nil, "rio", nil, Refnone) < 0){
        fprint(2, "rio: can't open display: %r\n");
        exits("display open");
    }
    iconinit();
    view = screen;
    viewr = view->r;
    mousectl = initmouse(nil, screen);
    if(mousectl == nil)
        error("can't find mouse");
    mouse = mousectl;
    keyboardctl = initkeyboard(nil);
    if(keyboardctl == nil)
        error("can't find keyboard");
    wscreen = allocscreen(screen, background, 0);
    if(wscreen == nil)
        error("can't allocate screen");
    draw(view, viewr, background, nil, ZP);
    flushimage(display, 1);

    exitchan = chancreate(sizeof(int), 0);
    winclosechan = chancreate(sizeof(Window*), 0);
    deletechan = chancreate(sizeof(char*), 0);

    timerinit();
    threadcreate(keyboardthread, nil, STACK);
    threadcreate(mousethread, nil, STACK);
    threadcreate(winclosethread, nil, STACK);
    threadcreate(deletethread, nil, STACK);
    filsys = filsysinit(xfidinit());

    if(filsys == nil)
        fprint(2, "rio: can't create file system server: %r\n");
    else{
        errorshouldabort = 1;	/* suicide if there's trouble after this */
        if(initstr)
            proccreate(initcmd, initstr, STACK);
        if(kbdin){
            kbdargv[2] = kbdin;
            r = screen->r;
            r.max.x = r.min.x+300;
            r.max.y = r.min.y+80;
            i = allocwindow(wscreen, r, Refbackup, DWhite);
            wkeyboard = new(i, FALSE, scrolling, 0, nil, "/bin/rc", kbdargv);
            if(wkeyboard == nil)
                error("can't create keyboard window");
        }
        threadnotify(shutdown, 1);
        recv(exitchan, nil);
    }
    killprocs();
    threadexitsall(nil);
}
@

\chapter{Window, Screen, Display}

\chapter{[[/dev/...]] Demultiplexer}

\chapter{[[/dev/wctl]] Server}

\chapter{[[fsys]] Server}

\chapter{Threads}
% see rio presentation with architecture

\section{Keyboard thread}

\section{Mouse thread}

\section{Window threads}

\chapter{Changing Cursor}
% put pictures instead of code :)
% what is the code that takes the hexa data and draw?

\chapter{System Menus}

\chapter{Window Terminal}
% fake /dev/cons

\chapter{Widgets}

\section{Frame}
% have libframe/ but also a frame widge in libpanel

\section{Scrolling}
% have also a menu in libpanel, scrollbar

\section{Menu}
% have also a menu in libpanel, popup, pulldown

\section{Libpanel}
% different alloc, different event loop, 
% and the Panel main data structure

\section{Button}

\section{Label}

\section{Text entry}

\section{Completion}

\section{Slider}

\section{List}

\section{Pack}

\section{Canvas}

\section{Text view}

\section{Rich text}


\chapter{Advanced Topics}

\section{Snarf}

<<global snarffd>>=
int		snarffd;
@


<<global nsnarf>>=
int		nsnarf;
@

<<global snarf>>=
Rune*	snarf;
@

<<global snarfversion>>=
int		snarfversion;	/* updated each time it is written */
@


<<function putsnarf>>=
/*
 * /dev/snarf updates when the file is closed, so we must open our own
 * fd here rather than use snarffd
 */
void
putsnarf(void)
{
    int fd, i, n;

    if(snarffd<0 || nsnarf==0)
        return;
    fd = open("/dev/snarf", OWRITE);
    if(fd < 0)
        return;
    /* snarf buffer could be huge, so fprint will truncate; do it in blocks */
    for(i=0; i<nsnarf; i+=n){
        n = nsnarf-i;
        if(n >= 256)
            n = 256;
        if(fprint(fd, "%.*S", n, snarf+i) < 0)
            break;
    }
    close(fd);
}
@

<<function getsnarf>>=
void
getsnarf(void)
{
    int i, n, nb, nulls;
    char *sn, buf[1024];

    if(snarffd < 0)
        return;
    sn = nil;
    i = 0;
    seek(snarffd, 0, 0);
    while((n = read(snarffd, buf, sizeof buf)) > 0){
        sn = erealloc(sn, i+n+1);
        memmove(sn+i, buf, n);
        i += n;
        sn[i] = 0;
    }
    if(i > 0){
        snarf = runerealloc(snarf, i+1);
        cvttorunes(sn, i, snarf, &nb, &nsnarf, &nulls);
        free(sn);
    }
}
@



\section{Plumb}


\chapter{Conclusion}

\appendix

\chapter{Debugging}

\chapter{Profiling}

\chapter{Error Managment}

<<global errorshouldabort>>=
int errorshouldabort = 0;
@

<<function derror>>=
void
derror(Display*, char *errorstr)
{
    error(errorstr);
}
@

\chapter{Libc}

\chapter{Extra Code}

\ifallcode
#include "Windows_extra.tex.nw"
\fi

\chapter{Changelog}
\label{sec:changelog}

\chapter{Glossary}
\label{sec:glossary}

\begin{verbatim}
\end{verbatim}

\chapter*{Indexes}
\addcontentsline{toc}{section}{Index}

%\chapter{References} 
\addcontentsline{toc}{section}{References}

\begin{thebibliography}{99}

\bibitem[1]{wp-literate-programming} Donald Knuth,,
{\em Literate Programming}, 
\url{http://en.wikipedia.org/wiki/Literate\_Program}

\bibitem[2]{noweb} Norman Ramsey,
{\em Noweb}, 
\url{http://www.cs.tufts.edu/~nr/noweb/}

\bibitem[3]{syncweb} Yoann Padioleau,
{\em Syncweb, literate programming meets unison}, 
\url{http://padator.org/software/project-syncweb/readme.txt}

\end{thebibliography}

%******************************************************************************
% Postlude
%******************************************************************************

\end{document}

