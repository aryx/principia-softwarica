\documentclass[twocolumn, landscape]{report}

%******************************************************************************
% Prelude
%******************************************************************************
\newif\iffinal
\newif\ifverbose
\finaltrue\verbosefalse % see also other newif in Macros.tex

%------------------------------------------------------------------------------
%history: 
%------------------------------------------------------------------------------

%thx to LP, I changed for the better a few things:
% - removed deadcode (Qnew, threadrforkflag, mainpid, Filsys.pid, ...)
% - reoganized the files to better match the chapters by introducing more files:
%    thread_xxx.c and process_xxx.c, wm.c, cursor.c, terminal.c, etc.

%thx to codemap/codegraph/scheck:
% - use cg to reduce backward deps (only 6: 0.33%), introduce globals.c, utils.c
%   (harder to understand non layered code)
% - use scheck to remove deadcode, dead prototypes, useless export
%   or mv as forward decl
%   (harder to understand big interface files)
% - use cg to reduce number of globals by moving them closer to the
%   relevant file (or even function), better cluster the code
%   (harder to understand non functional code using lots of globals)

%thx to this manual, I better understand X11, concurrent apps, and fileservers:
% - I had no idea how a windowing system worked so for sure now I understand
%   more. For instance, each window is represented by a DS and a thread! (like
%   an active object). A windowing system is first a display server so
%   it needs a server/clients archi and so thread archi is natural.
% - how to use threads and channels, a bit like Erlang; rio's architecture
%   is very nice
% - master/worker architecture with threads, passing around function 
%   pointers in channels
% - a filesystem server a la Fuse, multithreaded to handle multiple requests
%   (so need request identifiers)
% - better understand need for raw mode for keyboard input in addition to
%   "edit" mode (with backspace handling and newline only for send)

%history LP-ization:
% - skeleton, mostly copy paste of Template.nw skeleton
% - put all content of files in the Extra section, via 'pfff -lpize'
%   which also now split in chunks!
%    * function, global, struct, enum, constant, macro(actually function)
%    * TODO ctor/dtor, dumper
%    * [[xxx]] other fields, [[xxx]] extra fields
%    * TODO thread function, process function, mouse action function
% - read Extra section, identify concepts, first TOC
% - distribute parts of the Extra section in the main file
% - understand main(), LP split main, improve TOC
% - understand main functions, LP split, cluster, improve TOC
% - LP split the structures, use datalog for flow to field info
% - nullify, boolify, errorify, enumify,  typeify,    scheckify, plan9ify
% - aspecify advanced features! remove useless features
% - SEMI add figures
% - SEMI add explanations

%------------------------------------------------------------------------------
% Packages
%------------------------------------------------------------------------------

\usepackage{../docs/latex/noweb}
 \noweboptions{footnotesizecode,nomargintag}
 %note: allow chunk on different pages, less white space at bottom of pages
 \def\nwendcode{\endtrivlist \endgroup}
 \let\nwdocspar=\par
\usepackage{xspace}
\usepackage{verbatim}
%note: required by noweblatexpad for the \t \l \n in this file
\usepackage{fancyvrb}
\usepackage{url}
\usepackage{hyperref}
 \hypersetup{colorlinks=true}
\usepackage[pageref]{backref}
 \def\backref{{\footnotesize cited page(s)}~}
\usepackage{booktabs} 
 \newcommand{\otoprule}{\midrule[\heavyrulewidth]}
\usepackage{graphicx}

%------------------------------------------------------------------------------
% Macros
%------------------------------------------------------------------------------
\input{../docs/latex/Macros}

%------------------------------------------------------------------------------
% Config
%------------------------------------------------------------------------------
\allcodefalse
% ifallcode is used for:
%  - forward decl, func decl, extern decl, #ifdef, pragmas (stuff in Extra.nw)
%  - obvious locals (s, buf)
%  - ??

\addtolength{\topmargin}{-.850in}
\addtolength{\textheight}{1.70in}

\begin{document}
%******************************************************************************
% Title
%******************************************************************************
\title{
{\Huge 
Principia Softwarica: The Plan~9 Windowing System [[rio]]
}\\
{version 0.1}
}

\author{
Yoann Padioleau\\
\texttt{yoann.padioleau@gmail.com}
\\
with code from\\
Rob Pike
}

\maketitle 

\onecolumn
\hrule
\input{../docs/latex/Copyright}
\input{../docs/latex/CopyrightPlan9}
\hrule
\twocolumn


\begingroup
\hypersetup{linkcolor=blue}
% need to s/onecolumn/twocolumn in report.cls :) for \tableofcontents
\tableofcontents
\endgroup

%******************************************************************************
% Body
%******************************************************************************

\chapter{Introduction}

The goal of this book is to present with full details the source code of
a {windowing system}.
\n wikipedia uses this term

\section{Motivations}

Why a windowing system? 
Because I think you are a better programmer if
you fully understand how things work under the hood,
and one of the first thing you should see on your screen is
a set of {windows}.
The {windowing system} is the program (or the set of programs)
allowing the user to create and manipulate those {windows}.
\l which I will define later. but most people knows intuitively what it is.
\l many components: display server, window manager, compositor, xterm, etc.

%dup: Graphics.nw
Windowing systems are usually coupled with a {graphics system}
to form a {graphical user interface} (GUI).
%history: %dup: Graphics.nw
GUIs, introduced in the 1970's with the Xerox Alto~\cite{alto},
were a vast improvement over {text-based} user interfaces, to
the point where every mainstream operating systems now come with a GUI
(e.g., Microsoft Windows, MacOS and iOS, Linux with X Window, or Android).
\l hmm iOS and Android have windows? just IMP interface actually. Not WIMP.
\l even command line become more powerful with multiple windows

\l we will focus on universal windowing system!

A windowing system relies on a graphics system to {render}
the graphics of a window on a specific rectangular {surface} of the screen.
However, a window is not just a surface; it is also a process.
\l well not in mini X, draw, etc. rio is universal! like kernel!
Thus, a windowing system manages not only a set of
surfaces, but also a set of processes.
This is similar to what a kernel does.
%
Moreover, just like the kernel manages the {CPU} and {memory}
and virtualizes those shared resources among multiple processes, 
a windowing system manages the {screen} and {input devices} 
(e.g., the mouse, the keyboard)
and virtualizes those shared resources among multiple windows.
\l multiplex, virtualization, virtual X, abstraction
\n could be in Principles, but motiv is "rio is as important as the kernel!"
%%A windowing system takes as input
%%{events} from 
%%the keyboard (e.g, a key press) or 
%%the mouse (e.g., a mouse click)
%%and {dispatches} those events to the right process (the right window). 
%%Moreover, it takes graphic commands or simple text output from 
%%multiple processes and renders those commands or text at the right 
%%place on the screen.
\l each process, in addition to think it has all the cpu and memory
\l  thx to preempty scheduling and virtual memory, thinks it is alone
\l  and has full access to the screen and all input devices, thx
\l  to compartimentized screen (window), and policy.
\t event model for app, and also for windowing system itself
%
The windowing system is a natural extension of the kernel.
In fact, the need for multiple processes and 
a multi-tasking kernel is less obvious without a windowing system.
Linux offers virtual consoles where the user can launch independent
commands, but those consoles are a poor's man windowing system.
\l Emacs also has a windowing system, so screen command line tool, etc


Surprisingly, there is almost no book explaining how a windowing system
works or how to implement one,
even though there is a myriad of books on kernels.
I can cite only {\em The NeWS book: An Introduction to the
Network/Extensible Window System}~\cite{news-book},
and one chapter of 
{\em Computer Graphics, Principles and Practice}~\cite{cgpp-foley}
dedicated to user interface software.
Books on operating systems usually do not even include a
chapter on windowing systems.
\l Oberon? 
\l X Window series of OReilly is more on the protocol and API
\l http://keithp.com/~keithp/talks/Xarchitecture/Talk.htm
This is a pity because the windowing system is as important
as the kernel for the user.
\n Per Brinch Hansen was right, windowing systems is major OS innovation

\t other motivation is that great concurrent application! learn a lot.
\t  learn many concurrency patterns

Here are a few questions I hope this book will answer:
\begin{itemize}

\item What are the differences among
a windowing system,
a window manager,
a window compositor,
a display server, and
a desktop system?
\l a window server, a graphical shell, display manager, session manager
\n windowing system is all of that mostly.


\item How does the windowing system manage multiple processes? How
does it communicate with those processes?
\n kernel: syscall interface and time interrupt handler
\n rio: virtual-devices/fs for input and draw for graphics (clients/server)
\n X11: sockets and client/server archi with loop in server

\item How does the windowing system control access to a shared resource,
the screen, by multiple processes at the same time?
How does it cooperate with the graphics system?
\n leverage draw and delegate to draw

\item How drawing operations by graphical applications are intercepted
by the windowing system to make sure they can not
draw in other windows? How is the screen virtualized?
\n well they can draw in other windows, but have originWindow/clipping/named-image



\item How does the windowing system handle the mouse device? When
are mouse events dispatched to the graphical application? How does
the windowing system decide which window should receive the mouse
event? 
%What is the difference between a system mouse event and an application mouse event? 
\n location of coordinate and kind of click

\item How does the introduction of the mouse and graphics change
the programming model of an application?
What are the differences between a command-line application and
a graphical application? 
How does a graphical application {react} to a mouse event?
How does the windowing system itself react to a mouse event?
\n reactive model. notification oriented. events.
\t  not sequential style with input/output. event loop (in fact windowing system
\t  itself is a graphical program and so use similiar programming model)
\t differences between command line app and graphical app? same model?
\t in fact what is soft archi of a windowing system, which 
\t  is a graphic application itself.

\item How does the windowing system handle the keyboard device? How does it
decide which application should receive a keyboard event? How does
it deliver a keyboard event to this application?
\n focused window policy (or follow-mouse focus)
\n and virtual fs for /dev/cons

% how demultiplex the screen mouse and keyboard, how virtualize
\n per-process namespaces and filserver for /mnt/wsys/mouse /mnt/wsys/cons
% need create process, delete process, associate window, 
% send resize/refresh, ...
% kinda a scheduler
% actually you will learn a lot about concurrent programming! nice side effect.

\item How overlapping windows are managed? Where are stored
the pixels of a window overlapped by another window?
How are those pixels restored on the screen
when an overlapped window is exposed back?
\n actually mostly handled by Graphics.nw
%alt: expose event, but ugly


\item How does a terminal emulator (e.g. [[xterm]]) work?
What are the standard input and output of traditional command-line
applications when run under an emulator? How does the emulator offer
a backward-compatible environment for those applications?
%alt: xterm is huge
\n virtual devices! elegant

\item What happens when the user type [[ls]] in a terminal emulator?
What are the set of programs involved in such a command? What
is the trace of such a command through the different layers
of the software stack, from the keyboard interrupt to
the display of text glyphs on the screen in the appropriate window?

\end{itemize}
\l How terminal scrolling, text selection, copy/paste, etc
\l how menus? actually a set of windows?

\t put in conclusion non-trivial adv algo and data structures seen? see comment
%data-structures:
% - circular buffers (Window.mouse.queue)
% - growing arrays (windows (by 1), Window.r, Window.nraw, ...)

%algorithms:

%concurrency patterns:
% - master/workers
% - producer/consumer queue (Window.mouse.queue)
% - send and receive alts =~ select
% - passing channels as parameters
% - proc vs threads
% - cooperative threads and no need for lock

\section{[[rio]]}

I will explain in this book the code of the \plan windowing system 
[[rio]]\footnote{\url{http://plan9.bell-labs.com/magic/man2html/4/rio}},
which is about 10~000 lines of code (LOC).
\n when include libframe/ and libplumb/ and libcomplete/! include full emulator!
[[rio]] is written entirely in C.
\t rely on draw, all in userspace, so portable! x86 and ARM!


%dup: (and adapted) from Assembler.nw
Like for most books in \principia, I chose a \plan program because
those programs are simple, small, elegant, open source, and they form together
a coherent set.
%history: %dup: (and extended) Graphics.nw
[[rio]] comes from a series of windowing systems designed by Rob Pike:
[[8-1/2]], the direct ancestor of [[rio]] running also under \plan;
the Concurrent Window System, programmed in the 
Newsqueak language; and 
[[mpx]],
the windowing system of the Blit~\cite{blit} machine.
\t cite all of that
[[mpx]] was the first windowing system for Unix, and one of the first
windowing system back in 
1982\footnote{See \url{https://www.youtube.com/watch?v=emh22gT5e9k}
for an historical demo of the Blit and [[mpx]].}.
\n actually GUI of mpx is very similar to rio; not much changed, except color.
It was created even before the Macintosh, X Window, and Microsoft Windows.
\n comment shows the lineage and dates
%  in 1982
% Alto -> Pilot? -> Star (commercial system, mouse & windows, desktop metaphor)
%     the electronic office
%      |> Blit, mux ->  ... -> rio
%      |> Smalltalk (or just application on top of Alto?) -> ...
%      |> Macintosh -> Window -> ...
%      |> Lisp Machine? -> W Window -> X Window
\n so not a bad idea to explain rio; it has street credit like X.

%dup: (and adapted) Graphics.nw
[[rio]] services, like many other services in \plan,
are accessible through files. Indeed, [[rio]] is a user-space program
{\em and} a filesystem (see the \book{Kernel} if this sounds confusing).

To understand why [[rio]] is implemented as a filesystem, you need
(1) to have a general idea on how to implement a windowing system,
and (2) be familiar with some of the advanced features of the
\plan kernel.

Regarding the first point, at a high level,
a windowing system is a program that uses
the mouse (via [[/dev/mouse]] under \plan), the keyboard (via [[/dev/cons]]),
and the screen (via [[/dev/draw]]). However, a regular graphical application
is not different; such an application also wants to
use the mouse, the keyboard, and the screen.
Thus, a windowing system can be implemented simply
as a {\em multiplexer}; the windowing system can use
the {\em physical devices} and serve {\em virtual devices}
to the multiple graphical applications running under it.

Regarding the second point, the \plan kernel has a few
original features that makes it easy to implement 
virtual devices served by programs in user-space. Those features are
the {per-process namespaces}, the {union-mount directories}, and
the {file-server protocol 9P}.
See the \book{Kernel} for more information on those features.
\t or intro to plan9 article? or the use of namespace in plan9?
%
With [[rio]], the virtual devices are accessible under [[/mnt/wsys/]]
(e.g. [[/mnt/wsys/mouse]], [[/mnt/wsys/cons]]), 
%
but also under [[/dev/]] (e.g., [[/dev/mouse]], [[/dev/cons]]), 
thanks to the union-mount directories. 
%
Thanks to the per-process namespaces, each
graphical application sees a different [[/dev/mouse]], [[/dev/cons]],
and could see a different [[/dev/draw]]\footnote{For [[/dev/draw]],
the [[draw]] device already multiplexes the screen among 
multiple clients with [[/dev/draw/1/]], [[/dev/draw/2]], etc;
There is no need for a virtual [[/dev/draw]].
However, the ancestor of [[draw]], [[8-1/2]], was serving a virtual
[[/dev/draw]] device file, which was more elegant
but also more inefficient.
}.
%
Finally, thanks to 9P, all those virtual device files can be served 
by a single user-space program: [[rio]].
%
%from rio slides:
% "Each window mounts a different root of a distinc file system implemented
%  by Rio, containing an identical-looking simulation of the standard 
%  device file set for display, mouse, and keyboard."
\t if not clear, do not worry, explain more later, but can see namespace.ps
\t  article too.


A nice side effect of the multiplexer approach used by [[rio]] is that
[[rio]] can run under itself. This is useful for development
and debugging purposes.
%
Moreover, because you can export filesystems through
the network in \plan, [[rio]] is also a 
{networked windowing system}, similar to X Window
(even though the code of [[rio]] does not include a single line of
code related to networking).
%
Thus, in \plan, programs running on one machine
can have their windows displayed on another machine.


\section{Other windowing systems}

Here are a few windowing systems that I considered for this book,
but which I ultimately discarded:
\begin{itemize}

\item Xorg~\furl{http://xorg.freedesktop.org}, which I mentioned already
in the \book{Graphics}, 
%dup: Graphics.nw
is the most popular open-source implementation of the X Window System,
a windowing system (and a graphics system) designed in the 1980's at MIT.
%
However, its codebase is enormous. In fact, the whole system is divided
in hundreds of repositories\furl{https://cgit.freedesktop.org/xorg}
to better handle its complexity. One of this repository,
[[xserver]]\furl{https://cgit.freedesktop.org/xorg/xserver/},
which contains the code of the display server,
\l and window {compositor}, but then need define compositor here?
has already more than 500~000 LOC. 
\n KDrive (Xkdrive and Xfbdev) are small actually; but still need libX11/...
This does not even include the code for the
window manager (e.g., [[twm]] with 17~000 LOC),
\n can have many window managers under X11; policy-free server.
the terminal emulator (e.g., [[xterm]] with 80~000 LOC),
\n rxvt is 37 000 LOC so similar
or the many libraries that are required by clients (e.g., [[Xlib]]
with 150~000 LOC).
\l more than whole code of rio which includes a terminal emulator.

Part of the reason for the enormous size of Xorg is that
Xorg supports many graphic cards (with hardware acceleration),
many monitors, many input devices, and many extensions (e.g., 3D operations).
\n XRender, XRandR, Shape, etc
%
Another reason is that X Window is an old program;
programmers extended X Window for more than 30 years now.
Programmers added many extensions while still remaining
backward compatible with graphical applications designed in the 1980's. 

%dup: Graphics.nw
X Window defines a special protocol, X11, for a 
networked client/server architecture.
Client applications must use {\em sockets} to connect to the display server.
%
Unfortunately, the set of mechanisms used by clients to interact
with the display server is quite different from
the one offered by the kernel, for instance, the simple opening of 
files in [[/dev/]] such as  [[/dev/mouse]]. 
In some sense, X Window hides the features of the underlying kernel.
%
On the opposite, [[rio]]
is more {\em transparent}\cite{window-system-should-be-transparent}
by {extending} the services offered by the kernel, for instance
with the virtual device file [[/dev/mouse]].
%
The use of sockets in X Window allows client applications
to display their result on another machine on the network.
However, this is also possible with [[rio]], for free, thanks to the generic
9P protocol.
\l still a /dev/cons, /dev/draw, /dev/mouse

\t x86 specific? X on Raspberry Pi?


\item Wayland~\furl{https://wayland.freedesktop.org/} is a protocol, 
similar to X11,
specifying the communication between a display server, called
a Wayland {\em compositor}, and a set of {local} clients.
Weston~\furl{https://cgit.freedesktop.org/wayland/weston/}
is a reference implementation of a Wayland compositor.
%
Wayland and Weston grew out of the frustation of some
developers of Xorg with the complexity of X Window, as well as
the inability of X Window to support the modern needs of a windowing
system: 
transluscent windows, 
drop shadows on the window's border as in Mac OS Aqua,
fancy window-switcher such as Mac OS Expose, etc.

Fortunately, during the last ten years, lots of the code of
Xorg got gradually moved out of the display server and
put either in the Linux kernel (e.g., the resolution setting
of the screen, called KMS for kernel mode setting, or the ability
to interact directly with the graphics hardware, called DRM
for direct rendering manager),
or in external libraries (e.g., Cairo for an advanced drawing
API and imaging model, or [[libinput]] for a generic interface
to the input devices).
%
What remains in Xorg is an old drawing API, the ability
to have remote applications, and a display server that is backward
compatible with old graphical applications.
\l Useless intermediate. 
%
The developers of Wayland used this opportunity to redesign
from scratch a modern windowing system, while reusing lots of the
code that was now outside Xorg.

There are many differences between Wayland and X11.
For instance, Wayland does not specify any drawing API. Instead,
it assumes the clients do their own graphics rendering by using
libraries such as Cairo on locally-shared image buffers.
Weston then just uses those shared buffers
and composes them together (hence the use of the word {\em compositor}),
while possibly applying effects during the image composition
such as transluscence.
%
The use of locally-shared buffers means that 
Wayland does not support remote applications; Fortunately, most users now
run and display their applications on the same machine.
\l well except for the Web, so maybe remote app is important
\l not network transparent. No remote cos no drawing API.
\l   (or need transfer all the pixels a la VNC)
\n need rewrite X11 apps? not if they're using GTK/QT. Already compatible!
\n still need xterm? actually has one, 

The code of Wayland and Weston is far smaller than Xorg, 
but is still fairly large: 120~000 LOC (excluding the tests).
Moreover, Weston relies on many libraries (e.g., Cairo, [[libinput]]),
as well as lots of code and subsystems of the Linux graphics stack
(e.g., KMS, DRM, GEM, fbdev, evdev);
this would add up to lots of code to explain.
\l  a pile of layers with the kernel, soft archi diagrams looks complicated


\item Nano-X\furl{http://www.microwindows.org/}
(previously known as MicroWindows), is a windowing system and graphics system
\n is -> was? no news since 2011 though in the repository. But run at least.
\n was mentioned by tinyGL
designed for small devices such as PDAs.
%
It started as a fork of Mini-X, a graphics system for MINIX.
\n Mini-X, Minix :)
Both mini-X and Nano-X are modeled after X Window, and offer
an API similar to Xlib.
Nano-X added a client/server architecture to Mini-X as well
as a window manager to have a full windowing system.
%
Nano-X is highly portable, with support for many machines (x86, MIPS
machines, ARM embedded devices, etc).
Nano-X does not use any library; it just requires access to
a framebuffer from the Linux kernel.
It is far smaller than Xorg: 80~000 LOC (excluding the tests,
application demos, the Win32 API, and the fonts).
However, this is still bigger than the code of [[draw]] and [[rio]].

\end{itemize}

\l lots of other windowing systems, see the comment in the .nw
%industry:
% - Windows DWM?
% - MacOS Quartz compositor (innovative: Expose, window closing effects, etc)
%history:
% - Alto, started in 1973, had overlapping windows, mouse, fonts, etc
% - Blit (mux -> rio/draw), 1982
% - Smalltalk?
% - NeWS, Network/Extensible Window system =~ X + Display Postscript, 1989
%   https://books.google.com/books?id=DdbvBwAAQBAJ
%other:
% - MIR, very similar to wayland, used only by Canonical.
% - nuttx has some graphic and windowing stack apparently too!
%   http://nuttx.org/doku.php?id=documentation:nxgraphics
% - Qnx photons, 1.44MB demo disk! even with web browser!
% - Kolibri/MenuetOS, also floppy disk with full GUI, but all in assembly
% - berlin?
% - http://ignorethecode.net/blog/2009/04/22/oberon/
% - redox in rust has a windowing system apparently, Orbital?
%semi windowing systems (single client with multiple windows; no clients/server)
% - mini X
% - TWIN
%text-based windowing systems or libraries:
% - newt?
% - stuff used by Turbo Pascal? had dialog boxes!
% - twin (another one)
%mini:
% - TWIN (see above)
% - mgr http://www.hack.org/mc/mgr/
% - Xynth and Xfast
%window managers: (still rely on X11)
% - xmonad
% - efuns/gwml
% - tinyWM, 50 LOC http://incise.org/tinywm.html
% - another claimed to be minimal WM http://www.cc.rim.or.jp/~hok/heliwm/
%research:
% - 10/gui http://ignorethecode.net/blog/2009/10/13/10_gui/
% - xmonad in Coq, hmmm
%   http://www.staff.science.uu.nl/~swier004/Publications/XmonadInCoq.pdf
% - 3D windowing systems? Looking glasses of Sun?

% nice list of X wannabe killers:
% http://linuxfinances.info/info/xbloat.html

%nice set of screenshots of past famous GUIs:
% http://toastytech.com/guis/
% http://toastytech.com/guis/guitimeline.html

% history me: 
%  - tos, sega yeno, atari GEM, dos, windows 3.11
%  - one Linux terminal
%  - job control shell! (otherwise multi tasking OS but just one term so ...)
%  - multi terminal Alt-Fx on Linux
%  - screen or tux programs (actually I never used but many people do)
%  - X11 and xterm with as many windows as you want!
%  - FVWM fast key to many terminals
%  - Emacs eshell fast key to many terminals
%  - virtual desktops
%  - MacOS expose! bird's eye view

\section{Getting started}
\label{sec:getting-started}

To play with [[rio]], you will first need to install
the \plan fork used in \principia. See \urlinstall.
Once installed, you can test [[rio]] under \plan
by executing the following commands:

\begin{verbatim}
1   $ bind -a '#v' /dev
2   $ vga -l 640x480x8 
# screen should change layout
3   $ bind -a '#i' /dev
4   $ rio
\end{verbatim}
% x86 for vga part
\t need also /temp! and other stuff.

Then, if you right-click with the mouse, you should then see on your screen
graphics similar to the one in Figure~\ref{fig:rio}.

\begin{figure}\begin{center}
%\includegraphics[width=8cm]{rio}
\end{center}
\caption{[[rio]] screenshot when it just started.}
\label{fig:rio}
\end{figure}
\n terminal window? not yet, minimal spirit for now


Line~1 through 3, above, installs the graphics system of \plan
called [[draw]], and configure it to run at the
[[640x480x8]] resolution 
(See the \book{Graphics} for more information on [[draw]]).
%
Line~4 then executes [[rio]], which should take over
the screen to create the graphics shown in Figure~\ref{fig:rio}.


\section{Requirements}

% Window system is complex.
% many requirements ... rio is a complicated program using a lot
% of features of plan9 (namespace, 9p, /dev/draw, threads, ...)
% Builds on many other books. Use lots of stuff.

\begin{itemize}
\item The \book{Graphics}:
% display server, overlapping windows, some support (/dev/winname).

\item The \book{Libcore}:
% for channels, thread/process model, alts()

\item The \book{Kernel}:
% filesystem

\item The \book{Network}:
% for plan9 RPC, userspace filesystem. 9P. /srv. 

\end{itemize}

% methodology of Window Management (a workshop with a few papers) 1985
%http://www.chilton-computing.org.uk/inf/literature/books/wm/overview.htm
% seems like everything about WM was done in 1985 and after they stopped.

% NeWS book. 
% Chapter X of CGPP. 
% Introduction to window management, steinhart, 320 page
%   siggraph 1990 course notes (but cant find it)
% Useful, but not mandatory.

% rio.ps, 8.1/2.ps, concurrent-windowing-system.ps, lec5.pdf
% rio(1) and rio(4)

% graphics(2), draw(2)

% thread(2?) library! heavy use of channels and threads here
% proc and threads share address space! so proccreate create
% process but it's really similar to a thread, except 
% scheduled by OS.

% window(2)
% mouse(3)
% man/5/intro and man/5/* for 9p

% historical documents:
% Blit.pdf

\section{About this document}
#include "../docs/latex/About.nw"

\section{Copyright}
\input{../docs/latex/CopyrightPlan9Text}

\section{Acknowledgments}

I would like to acknowledge of course the author of
[[rio]], Rob Pike, 
who wrote in some sense most of this book.






\chapter{Overview}

%trans: %dup: Assembler.nw
Before showing the source code of [[rio]] in the following chapters, 
%toc:
I first give in this chapter an overview 
of the general principles of a windowing system.
%I also describe quickly the interface of the
%files in [[/dev/draw/]], and show the code
%of a toy program using functions from [[draw.h]].
%dup: from Assembler.nw
I also define terms, explain how the code is organized, 
and more generally give the background necessary
to understand the code I will show later.

\section{Windowing system principles}

% As said in intro,
% a {windowing system} is a program or set of programs
% allowing to create and manipulate windows!
% What is window then ...
% and many components.
% Display server, window manager, compositor,
% terminal emulator, etc.

% imagine how would you code a windowing system? not that easy.
% graphical app = use mouse, keyboard, and screen.
% windowing system also use screen, mouse and keyboard, but
%  demultiplex it! so windowing system is demultiplexer.
%  in fact rio can run under itself!

% windowing system is a type of GUI which implements WIMP paradigm.
% Each app is assigned a usually rectangular window.
% can overlap. Have decoration.

%\item What are the differences among
%a windowing system,
%a window manager,
%a window compositor,
%a display server, and
%a desktop system?
\t maybe diagram showing relation with all of that
% desktop system is big, windowing system inside, then
% window manager, compositor, and display server works together.

\subsection{Window}

% actually a misnommer according to first people.

% "A surface to have an activity ..."
% So window is first part of screen. An image.
% But it's also an associated process. A living image!
% It's also something that can be manipulated (window manager), like OS/shell,
% a Graphical shell: new, moved, resized, closed. Dynamic surface! 
% usually via decoration/border. Also have often title.

% Overlapping.
% Compositing.

% from SunDew:
%"a window should be just that. it is a surface on which he
%can write, and that it persists. All overlap issues should be
%completely hidden from the client"
% => no refresh/repaint brain damage.


\subsection{Display server}
% related to Graphics.nw, but context of multiple applications.
\l display server vs window server vs compositor

% windowing system need first display server. They will be
% many applications displaying stuff, need coord, need display server.

% more than graphics system, display server!
% because if want universal, then need multiple clients in
% independent processes. mini X is not universal. draw is!

% note that principle is not to provide graphics! it is often put
% together, e.g., X11 is windowing system and graphics system, but
% does not have to be. In fact in plan9 can have graphical app
% outside windowing system!
% (Alto was mixing? Smalltalk was? Blit was?)


% clients/server archi. (=> threads?)


%http://tech.slashdot.org/story/14/06/19/1317227/x-window-system-turns-30-years-old?utm_source=slashdot&utm_medium=facebook
%"A server lets clients access a shared resource. On a file server, it's
%storage. On a web server, it's documents. On a compute server, it's
%processing. On an X server, the shared resource is the display, and
%clients are given access to it."

%\subsection{communication protocol}

\subsection{Window compositor}

% tiling, stacking, or compositing

% each window as off-screen buffer, so then windowing system can
% compose those images in different ways: drop shadow, 3d effects, scaling
% (expose). Transluscence.


% in plan9, no compositor, just delegate to display server.
% but could.

\subsection{Window manager}

% The other role of windowing system is a windows manager!
% mv/resize/close/hide/etc menus. mouse right click and options.

% some graphics system allow to create windows, e.g. draw,
% but if does not have window manager, app must implement
% one. also not universal.

% related is window borders.

%alt: under X11 this is actually delegated to another program
%alt: wayland is display-server/compositor/window-manager all in one
% (but poor display server, just handle bitmaps transfer, drawing
% is done by library like cairo by the client)
%https://wayland.freedesktop.org/faq.html#heading_toc_j_11
% "The Wayland architecture integrates the display server, window manager
%  and compositor into one process"

%\subsection{Process manager}

% it's a kinda of scheduler, a bit like kernel. Need manage
% set of processes/activities. Need to keep track of them.

%\subsection{Graphical shell}
% can launch new processes

% could be separate program than wm, e.g. the Dock under MacOS.

%\subsection{Desktop shell}
% can have WM without icons, without file, garbage can, etc.
% In fact rio is not a WIMP, just a WMP.

%\subsection{Desktop environment}
% e.g. KDE, GNome.

\subsection{Virtual screen}

% then for each clients, what are the needs? a virtual screen!

% {windows}, obviously first principle :)
% "virtual screens" that applications can draw into.

% similar to virtual memory! abstraction!

% overlapping windows! can hide each other, and when resume
% get back its state (like suspended process) (so need
% save window content somewhere)

% The main role is to be a screen demultiplexer essentially! 
% A toy app can run outside rio
% but with rio can have "virtual" screen.

%alt:?

% not that draw is used by rio to manage screen, have windows,
% window borders. But regular apps can also use draw! to have their
% own internal overlapping windows! A menu, dialog box, widgets, all of that
% can be done with overlapping windows!

\subsection{Virtual mouse and keyboard}
% virtual output, then also virtual input!
% dont want program to read mouse concurrently and check
% if mouse is on top of his window, translate coord, etc.
% Job of windowing system.

% demultiplexer!

% many processes, but one keyboard/mouse.
% so need to virtualize/demultiplex keyboard/mouse.

%alt: how kernel does that? it does not really, only one process
% read the key at the same time (and mouse not really handled)

%alt: evdev in linux? yet another mechanism

\subsection{Events}
% and the events loop

% input events
% user-generated events (action with window manager)
%  expose event! resize event!

\subsection{Terminal emulator}

% backward compatible

% for keyboard, can even lead to need of terminal emulator.

%alt:


\section{[[rio]] interfaces}

\subsection{command-line interface}

<<function usage>>=
void
usage(void)
{
    fprint(STDERR, "usage: rio [-f font] [-i initcmd] [-k kbdcmd] [-s]\n");
    exits("usage");
}
@

% will see most options later. For debugging mostly.

\subsection{graphical interface}

% Well rio interface is first its graphical use interface :)
% once run, rio has full screen, with right menu to start things 
% (e.g., button3menu)

% FIGURE and annotate subtle things, like blue frame,
% or light grey text when unfocused xterm, and menus
% winborder, scrollr, screenr

\subsection{filesystem interface}

% rio is actually a special kind of program. It's a \plan filesystem
% or more accurately a fileserver because in userspace.

% when create new window/process under rio,
% also create new namespace, internal mount, so
% child process see different files in /dev/. In fact
% first in /mnt/wsys and then bind so also in /dev/





% show command in new()?

%/mnt/wsys/cons, /mnt/wsys/consctl, %kbdin
%/mnt/wsys/mouse, /mnt/wsys/cursor

%alt: could also /mnt/wsys/draw! but would be slower,
% more efficient access directly /dev/draw/ but that means
% then needed to have really a display server accepting multiple
% connections (less elegant).

% graphical vs textual windows?
% mouseopen or not? this has influence on many things.
% need to explain that early?

%/mnt/wsys/winid, /mnt/wsys/winname, /mnt/wsys/label,
%/mnt/wsys/screen /mnt/wsys/window (actually those are read-only)
%/mnt/wsys/text
%/mnt/wsys/snarf
%/mnt/wsys/wdir
%/mnt/wsys/wctl 
%/mnt/wsys/wsys/1/


% then to create new window, mount $wsys /mnt/wys/ 1
% and there you will have new device files. 
% Can then do the same and bind it in -b /dev and boom, 
% you have setup the right environment.

% also has special files in /srv/
% for external process to create new window and still have
% the mount.
% wsys and wctl are maybe advanced stuff we can delay?
% wctl for sure, allow to control rio from command line but
%  less important
%/srv
% rio.user.pid
% riowctl.user.pid
%env var:
%$wsys (e.g., /srv/rio.pad.21)
%$wctl (e.g., /srv/riowctl.pad.21)
%
% can also ctl rio by writing in $wctl
% also have fileserver that can take command (e.g., wctlnew())
% the fileserver offer also virtual views for the apps running
% inside the windows
% mount #s/rio.user.pid /mnt/wsys 1
% mount -b #s/rio.user.pid /dev

% $rio
% manual creation of window (not via menu)
% see rio(5)
% mount $wsys /tmp 'new -r 0 0 128 64 -pid' $pid
% echo hi > /tmp/cons
% :)



% note that can even run rio inside rio!



\section{[[hellorio.c]]}

% has nothing to do! abstraction power!
% hellodraw.c but using view instead of display->image this time!

% new programming model! not just display as in hellodraw.
% and not just input/output as command line app.
% Event based! interactive! reactive!

%alt:
% no need Expose event, just draw!
%hmm but need resize event. See section X of Graphics book,
% or here Section X because demultiplex the mouse (but should
% have a /dev/resize instead)

<<tests/draw/hellorio.c>>=
1   #include <u.h>
2   #include <libc.h>
3   #include <draw.h>
4   
5   void main(void) {
6     int result;
7     Image *color;
8   
9     result = initdraw(nil, nil, "Hello Rio");
10    if (result < 0) {
11      exits("Error in initdraw\n");
12    }
13  
14    color = allocimage(display, Rect(0,0,1,1), RGBA32, true, DMagenta);
15    draw(view, view->r, color, nil, ZP);
16  
17    line(view, 
18         Pt(10, 10), 
19         Pt(100, 100), Endsquare, Endsquare, 10, display->black, ZP);
20    string(view, 
21           Pt(200, 200), display->black, ZP, font, 
22           "Hello Graphical World");
23    flushimage(display, true);
24  
25    sleep(5000); // msec
26  }
@

%todo: use originWindow! by default! so even less change compared
% to hellodraw.c
%old:
% a bit annoying that have to transform your xy into the final
% xy ourself by adding view->r.min. Not really "abstraction"
% power. I'd rather have my 0x0 to be the top left on _my_ window.
%update: actually you can, but you have to make your image a window
% which means you also have to create a Screen first.

% delay for later rio and /dev/winname? I think so. already quite complicated.
% but maybe can show that can under rio! magic! (and link to other book)
% /dev/winname! from noborder.xxx to window.xxx and then
% thanks to naming image, can find back image you need to write to!
% (instead of writing directly to the screen)


% far cleaner than hello world for X11. No need for expose ugly stuff!
% (but still need to handle resize :( )

\section{Code organization}

% different dirs. libframe/, libcomplete/, libframe/, rio/
% but will focus on rio/
% depends also on libdraw/, libc/

%dup: (and adapted) from Assembler.nw
Table~\ref{tab:code-orga} presents short descriptions
of the source files used by [[rio]], together with
the main entities (e.g., structures, functions, globals) the file defines,
and the corresponding chapter in this document in which the code
contained in the file is primarily discussed.


\begin{table*}[tbh!]
\begin{center}
\begin{tabular}{lcllr}
\toprule
{\bf Function}  & {\bf Chapter} & {\bf File} & {\bf Entities} & {\bf LOC} \\
\otoprule
data structures and constants & \ref{chap:core-ds}           & [[dat.h]]                & [[Window]] [[FilSys]] [[Fid]] [[Xfid]]                                    & 0 \\ % Qxxx Wctlmesg
globals                       & \ref{chap:core-ds}           & [[globals.c]]            & [[windows]] [[input]] [[filsys]] [[mousectl]] [[keyboardctl]]             & 0 \\
prototypes                    & \ref{chap:main}              & [[fns.h]]                &                                                                           & 0 \\ 
entry point                   & \ref{chap:main}              & [[rio.c]]                & [[threadmain()]]                                                          & 0 \\         
% filsysinit called by main, from fsys.c, xfidinit() in xfid.c

\midrule

keyboard thread               & \ref{chap:processes-threads} &  [[thread_keyboard.c]]   &  [[keyboardthread()]]                                                     & 0 \\ % was rio.c before
mouse thread                  & \ref{chap:processes-threads} &  [[thread_mouse.c]]      &  [[mousethread()]]                                                        & 0 \\ % was rio.c
window threads                & \ref{chap:processes-threads} &  [[threads_window.c]]    &  [[winctl()]]                                                             & 0 \\ % was wind.c
closing threads               & \ref{chap:processes-threads} &  [[threads_misc.c]]      &  [[deletethread()]] [[winclosethread()]]                                  & 0 \\ % was rio.c
master and worker threads     & \ref{chap:processes-threads} &  [[threads_worker.c]]    & [[xfidinit()]] [[xfidctl()]]                                              & 0 \\ % was in xfid.c before
%thread_workerallocator.c
fileserver process            & \ref{chap:processes-threads} & [[process_fileserver.c]] & [[filsysinit()]] [[filsysmount()]] [[filsysproc()]]                       & 0 \\ % was in fsys.c before

\midrule

cursor graphics               & \ref{chap:cursor}            & [[data.c]]               & [[crosscursor]] [[corner]]                                                & 0 \\ 
cursor operations             & \ref{chap:cursor}            & [[cursor.c]]             & [[riosetcursor()]]                                                        & 0 \\ %pad: was in wind.c before %related: cornercursor() wsetcursor()
window manager                & \ref{chap:wm}                & [[wm.c]]                 & [[button3menu()]] [[drag()]] [[new()]]                                    & 0 \\ %pad: was in rio.c before
window methods                & \ref{chap:wm}                & [[wind.c]]               & [[wpointto()]] [[wclose()]] [[wtop()]]                                    & 0 \\ 
window process creation       & \ref{chap:wm}                & [[process_winshell]]     & [[winshell()]]                                                            & 0 \\ %pad: was in wind.c befrore
fileserver methods            & \ref{chap:filesystem-server} & [[fsys.c]]               & [[filsysattach()]] [[filsysopen()]]                                       & 0 \\ % dirtab fcall 
fileserver utilities          & \ref{chap:filesystem-server} & [[9p.c]]                 & [[filsysrespond()]] [[filsyscancel()]]                                    & 0 \\ % was in fsys.c before
virtual devices methods       & \ref{chap:virtual-devices}   & [[xfid.c]]               & [[xfidinit()]] [[xfidopen()]] [[xfidread()]] [[xfidwrite()]]              & 0 \\                 

\midrule
 
graphical window operations   & \ref{chap:graphical-windows} & [[graphical_window.c]]   & [[waddraw()]]                                                             & 0 \\ %pad: was in wind.c before
terminal emulator             & \ref{chap:textual-windows}   & [[terminal.c]]           & [[button2menu()]] [[winsert()]] [[wshow()]] [[wkeyctl()]] [[wmousectl()]] & 0 \\ %pad: was wind.c before
% frame.h, frame.c  Frame frinit() 
% editor.c? wselect.c?
terminal scrolling            & \ref{chap:textual-windows}   & [[scrl.c]]               & [[wscroll()]] [[wscrdraw()]]                                              & 0 \\

% chap 12: \ref{chap:window-files}, xfid.c again

\midrule

external window control       & \ref{chap:advanced}          & [[wctl.c]]               &  [[parsewctl()]] [[wctlthread()]] [[wctlproc()]]                          & 0 \\
copy/paste clipboard          & \ref{chap:advanced}          & [[snarf.c]]              & [[putsnarf()]] [[getsnarf()]]                                             & 0 \\
%  TODO put globals there
timer                         & \ref{chap:advanced}          & [[timer.c]]              & [[timerstart()]]                                                          & 0 \\
% timer for what? scrolling?

% srv.c?
% completion.c? 
% debugging.c? with wkeyboard stuff? keyboardhide()?
% hold.c?

\midrule

error management              & \ref{chap:error}             & [[error.c]]              & [[error()]] [[derror()]]                                                  & 0 \\ %pad: was in rio.c before
utilities                     & \ref{chap:utilities}         & [[util.c]]               & [[min()]] [[emalloc()]] [[strrune()]]                                     & 0 \\

\otoprule
Total                         &                              &                          &                                                                           & 8142 \\
\bottomrule
\end{tabular}
\end{center}
\caption{Chapters and source files of [[rio]].}
\label{tab:code-orga}
\end{table*}
\n see SRC_VIEWS in the Makefile, and make loc



\section{Software architecture}
\l maybe put code orga after soft archi?

% use many kernel devices:
% /dev/mouse, /dev/cons (the core one)
% /dev/cursor

% /dev/draw!

% depends on libdraw
% (depends also on libmemdraw? libmemlayer? no, just libdraw)
% For the graphics system part see Graphics.nw

% kernel driver vs graphic libs vs rio vs graphical apps
% different levels! kernel, rio, window, client app

% lots of window managment stuff in draw.h actually! like topwindow()!
% that will change what is drawn on top!

% kernel manages the images, so Image* is really an handle ID
% that can be passed in draw commands to /dev/draw and can be
% retrieved by the kernel


% (actually rio will virtualize some of those, so those could be
%  actually not the kernel devices but rio virtual files)

% see 81/2.ps and rio.ps
% see also panel.pdf


% there are DS server side and client side.
% Window is server side info about client window. On the client
% side this window is actually stored in a handle called screen
% (and also have different services in /dev/ like /dev/winname)

\subsection{Processes and threads relationships}

\begin{figure}[!]\centering
\begin{verbatim}
+-----------------------------------------------------------------------+
|               +----------------------------------------------+        |
|               |+--------------------------------------------+|        |
|               ||                               +----------+ || +----+ |
|  +----------+ ||                               |  Worker  | || |+--+| |
|  |+--------+| || +--------+                    |allocator <-++->|  || |
|  ||        || || |Keyboard|                    +----------+ || ||  || |
|  ||IO proc |+-++-> thread |  +----------+  +--------------+ || ||f || |
|  ||keyboard|| || |        +-->          <-->   Worker 1   | || ||i || |
|  ||        || || +---+----+  | Window 1 |  |(r wsys/cons) <-++->|l || |
|  |+--------+| ||     |       |(terminal)|  +--------------+ || ||e || |
|  +----+-----+ ||     |  +---->          <-->   Worker 2   | || ||s || |
| +-----+       ||     |  |    +----------+  |(w wsys/cons) <-++->|e || |
| |             ||     |  |                  +--------------+ || ||r || |
| | +---------+ ||     |  |    +----------+  +--------------+ || ||v || |
| | |+-------+| ||     +--+---->          <-->   Worker 3   <-++->|e || |                   -
| | ||       || || +------+-+  | Window 2 |  |(r wsys/mouse)| || ||r || |
| | ||IO proc|| || | Mouse  |  |(hellorio)|  +--------------+ || ||  || |
| | || mouse |+-++-> thread +-->          <-->   Worker 4   <-++->|  || |
| | ||       || || |        |  +----------+  |(r wsys/cons) | || |+--+| |
| | |+--+----+| || +--------+                +--------------+ || +-^--+ |
| | +---+-----+ |+--------------------------------------------+|   |    |
| |     |       +----------------------------------------------+   |    |
+-+-----+----------------------------------------------------------+----+
  |     |                  |        +-------------+  +-----------+ |
  |     +-------+          |        |+-----------+|  |+---------+| |
  v             v          v        || hellorio  ||  ||  shell  || |
 /dev/cons  /dev/mouse /dev/draw/1  ||  process  ||  || process || |
     |          |          |        |+-----------+|  |+---------+| |
     |          |          |        +-------------+  +-----------+ |
     |          |          |        /mnt/wsys/mouse  /mnt/wsys/cons|
     |          |          |        /mnt/wsys/cons|         |      |
     |          |          |        /dev/draw/2 | |         |      |
     |          |          |             |      | |         |      |
  +--v----------v----------v-------------v------v-v---------v------v-+
  |  |          |          |     Kernel  |      ------------------>  |
  +--+----------+----------+-------------+---------------------------+
     v          v          v             |
 +--------+ +-------+    +-------+       |
 |Keyboard| | Mouse |    |Display|       |
 | device | |device |    |device |<------+
 +--------+ +-------+    +-------+
\end{verbatim}
\caption{Processes and threads in [[rio]].}
\label{fig:soft-archi-directories}
\end{figure}

% no need for locks!


% show the different threads! threadmain, mouse, keyboard, and windows threads!
% (as well as close, delete, and xfids)

% actually also have different processes! winshell, timer, and the main rio one
% Also have process for mouse and keyboard (connected to mouse and keyboard
% thread), filsysproc!

% so process  = system threads
% and threads = cooperative lightweight threads (no need lock between light
%  cos always cooperative so clear limit)

% and show which DS are associated with each big process.
% for instance filsysproc does not have access to windows, only
% to filsys

% each window is a thread! when keydown the keyboard thread is triggered
% (it was waiting in the msg/event loop in a recv() on /dev/cons probably in raw
% mode), and send the character
% to the input window channel, and the thread corresponding to this window
% who should wait for many channels should be awaken by the thread scheduler
% to process the keyboard input and act on it.

% each file accessed by process is a thread too!

% switch(alt(alts)) { event loop in many threads (mouse, winctl, etc)

% menu3 -> xxx() -> wsendctlmesg(w, xxxd) -> send(w->cctl, xxxd) -> winctl thread awake -> wxxx()
% or sometimes xxx() -> wxxx() directly like for whide() because reuse
% an existing Wctlmsg (e.g., Reshaped)


% filsysxxx -> xfidxxx -> wxxx


% for a new window, have a new process created, and in this
% process fork, we adjust (classic), and mount
% the right namespace.
% See http://epresence.kmdi.utoronto.ca/1/watch/630.aspx
%  mount("/srv/ws", "/dev", M_REPL);
%  W = open("/dev/graphics", O_WRITE);
%  K = open("/dev/cons", O_READ);
%  M = open("/dev/mouse", O_READ);
% then this process read/write of those devices will trigger
% the rio fileserver, which will then dispatch the request
% to the right window thread associated with this process/window,
% and do the right action.

% single threaded is a big deal? not really, cos it does not block
% heavy computation process from running. It only matters when there
% are events, but those events are mostly human events (mouse move, key press)
% and humans are very slow.

\subsection{Data structures relationships}

\subsection{Trace of a mouse click}

%like me: https://wayland.freedesktop.org/architecture.html
%"A good way to understand the wayland architecture and how it is
%different from X is to follow an event from the input device to the
%point where the change it affects appears on screen."

% message! find right window, dispatch

% click => hardware interrupt => kernel => ioproc(initmouse, read /dev/mouse) =>
%  mousethread => winctl => ??? ... (read /mnt/wsys/mouse)

% why ioproc? otherwise mousethread would block the whole process
% why mousethread? because need dispatch to appropriate window
% why winctl? because depending on state of window, might
%  dispatch to some xfid, or not.

% write to /dev/mouse
% rio process with many threads Await.
% mouse thread listening on mousectl channel, probably a wrapper over
% /dev/mouse listening.
% get data, get current window (shared memory 'input' global),
% write to window mouse channel.
% window thread listening on many channels (alts()), get awake
% and call wmousectl(), pass around address of mouse structure
% containing the info (shared memory).

\subsection{Trace of a key press}

% key => hardware interrupt => kernel => ioproc(initkeyboard, read /dev/cons) =>
%  keyboardthread => winctl => ??? (read /mnt/wsys/cons)

% why ioproc? otherwise keyboardthread would block the whole process
% why keyboardthread? because need dispatch to appropriate window
% why winctl? 

% lots similar but wkeyctl()

%related: but for typing google.com in a browser
%https://github.com/alex/what-happens-when

\subsection{Trace of a drawing operation}
% more important in Graphics.nw

% toy app does a draw operation, what happens?
% it writes on /dev/draw/n/data? 

% there are no write on /dev/screen or /dev/window.
% those are read-only device.
% /dev/draw does its own demultiplexing. A client
% open /dev/draw/new, get a handler, and then getwindow
% give name of image for this client to use, stored then
% in view.

% a bit annoying that have to transform your xy into the final
% xy ourself by adding view->r.min. Not really "abstraction"
% power. I'd rather have my 0x0 to be the top left on _my_ window.
%update: can use originwindow! then cleaner!

\section{Book structure}





%###############################################################################

\chapter{Core Data Structures}
\label{chap:core-ds}

% lots of DS ... complicated program.

\section{Device handlers}

\subsection{Output device: [[display]] and [[view]]}

% rio is first a graphical app, like other graphical app. 
% So use display, view, etc. See Graphics.nw and draw.h and initdraw called
% early in main().

%Display	*display; // set by initdraw()
%display =~ /dev/draw handler

%Image          *view; 
%old: was called screen but was confusing because screen was of type Image*, 
% whereas there was a Screen type too (which really should be called Desktop)
%dead:
%  <<global view>>=
%  Image	*view;
%  @
% was initialized in main() to screen, but now that I renamed in Graphics
% screen to view, no need anymore this global
% (this made me change screen to view in Graphics.nw)

% view = full screen in rio context (unless run recursively).
% but normally portion of the display for this window.

<<global viewr>>=
Rectangle	viewr;
@
%view->r
% can remove? no cos when resize, view->r changes but
% want old value (but should be needed only when run rio under rio no?)


% rio will provide actually to its client a view Image too!
% but for subpart of screen (subpart of rio's view).

\subsection{Input devices: [[mousectl]] and [[keyboardctl]]}

% rio is a graphical app which uses the keyboard and mouse.

% mouse.h
<<global mousectl>>=
Mousectl	*mousectl;
@
% wrapper over /dev/mouse, channel wrapper
% actually partially output? with cursor?


<<global mouse>>=
// alias for &mousectl->Mouse
Mouse	*mouse;
@
% explain inline struct


% keyboard.h
<<global keyboardctl>>=
Keyboardctl	*keyboardctl;
@
% wrapper over /dev/cons (set in raw mode), channel wrapper


% and again, rio will provide to its client a "view" of the
% mouse and keyboard device.


\section{Desktop, [[wscreen]]}

% rio rely on big support in Graphics.nw to manage overlapping
% images, which is big building block for windowing systems (but still
% a lot remains)

<<global wscreen>>=
Screen	*wscreen;
@
% wscreen = allocscreen(screen, background)
%TODO: rename to screen? or better desktop! or merge with the one in window.h?
% but initdraw allocates by default a screen no? why not reuse
%  this one? because screen by default has also border on it
%  and window is actually subpart inside the border.
%  so when run rio under rio, you want a new desktop, inside the border too???
% created new one on top of existing one because change background?
%  Can not have API that change background setting for the desktop global?

<<global background>>=
Image	*background;
@
% used for desktop. It's actually a Color. in plan9 everything
% are images, See Graphics.nw, colors, masks, windows, fonts, etc.
% allocimage in main()


% will see also another color:
<<global red>>=
Image	*red;
@
% when moving around windows, the frame become red!
%//Image	*lightgrey;


% rio can also provide a screen to its client, but less useful,
% just acme uses that.

\section{Windows}

\subsection{[[Window]]}

% Windowing systems is all about managing windows ... so here it is.
% Big structure (a bit like Proc in Kernel.nw).

% Note that also have window type in Graphics.nw, which is really
% Image with additional methods. Those window/images will be used
% for graphical part, but need more fields, not just graphic part
% to handle windows. 

<<struct Window>>=
struct Window
{
    //--------------------------------------------------------------------
    // ID
    //--------------------------------------------------------------------
    <<[[Window]] id fields>>
    
    //--------------------------------------------------------------------
    // Graphics
    //--------------------------------------------------------------------
    <<[[Window]] graphics fields>>
    
    //--------------------------------------------------------------------
    // Mouse
    //--------------------------------------------------------------------
    <<[[Window]] mouse fields>>
   
    //--------------------------------------------------------------------
    // Keyboard
    //--------------------------------------------------------------------
    <<[[Window]] keyboard fields>>
    
    //--------------------------------------------------------------------
    // Control
    //--------------------------------------------------------------------
    <<[[Window]] control fields>>

    //--------------------------------------------------------------------
    // Process
    //--------------------------------------------------------------------
    <<[[Window]] process fields>>
    
    //--------------------------------------------------------------------
    // Config
    //--------------------------------------------------------------------
    <<[[Window]] config fields>>

    //--------------------------------------------------------------------
    // Textual Window
    //--------------------------------------------------------------------
    <<[[Window]] textual window fields>>

    //--------------------------------------------------------------------
    // Graphical Window
    //--------------------------------------------------------------------
    <<[[Window]] graphical window fields>>

    //--------------------------------------------------------------------
    // Misc
    //--------------------------------------------------------------------
    <<[[Window]] other fields>>

    //--------------------------------------------------------------------
    // Extra
    //--------------------------------------------------------------------
    <<[[Window]] extra fields>>
};
@

% all categories are important above. Window is connected
% to mouse, keyboard, can be controlled, has some id and graphics,
% is connected to external process, and can be textual or graphical.



<<[[Window]] id fields>>=
int	    id;       // visible through /mnt/wsys/winid
char    name[32]; // visible through /mnt/wsys/winname
char    *label;   // writable through /mnt/wsys/label
@
% name vs label? name is here for client to find back its window/image via
%  namedimage, so rio sends info back to window. name is just readable.
%  label is actually set by client, and displayed back by rio.
%  label can be arbitrary size and /dev/label is writable

% counter
<<global id>>=
static	int	id;
@

% id is passed to filsysmount! so will be in /mnt/wsys/<id>/devs



<<[[Window]] graphics fields>>=
// ref_own<Image>, public image for the window (name in /dev/winname)
Image	*i;
@
% will be used by Graphics, e.g., topwindow(w->i) in wtop()
% this is whole image, including its border, see sweep() and wmk()

<<[[Window]] graphics fields>>=
/*
 * Rio once used originwindow, so screenr could be different from i->r.
 * Now they're always the same but the code doesn't assume so.
*/
Rectangle	screenr; /* screen coordinates of window */
@
\t put back originwindow! cleaner to have origin really at Pt(0,0),
% window is more like an abstraction of the screen then.
% but should do that in gengetwindow anyway, since here we have
% a border, and gengetwindow will create another window inside
% the border.
\t why need that here? already info in draw no?

% image->r is physical coord. screenr is logical coord.

% screenr is ZR when hidden

% screenr is whole window, including border, see wmk.
% hmm but then if do originWindow, should not include the border ...







<<[[Window]] extra fields>>=
Ref;
@
% when middle click on a window we want to keep it alive!
% don't want someone else via /dev/... to delete it yet, otherwise
% will get segfault if try to access some fields of this window!

<<[[Window]] extra fields>>=
QLock;
@
% need? threads are cooperatif so can have race??
% have different process though




\subsection{[[windows]]}

% grown in wmk()
<<global window>>=
// growing_array<option<ref_own<Window>>> (size = nwindow+1)
Window	**windows;
@
%old: was window but better to be windows!!!
% essence of windowing system right here!! manage many windows!!
\l option above? seems like when delete there is a memmove
%alt: called scenegraph in wayland

% next free window
<<global nwindow>>=
int	nwindow;
@
% seems to be actually the size of windows



% each time a window get the focus, it becomes the topmost window
% and topped is incremented
<<global topped>>=
static	int		topped;
@

<<[[Window]] other fields>>=
int	 	topped;
@
% overlapping windows! see wpointto() to understand how determine focus.
% can know when click which window it concerns by iterating over
% all window and see if window screenr is there and if topmost one there.
% (similar info is in kernel)
\l need that since can compare w == input? maybe because sometimes
\l  nothing has the focus but there is still a top window?

\subsection{[[input]]}

% the current window, the one with the focus, the one
%  getting for instance the keyboard messages
<<global input>>=
//option<ref<Window>>, the window with the focus! the window to send input to
Window	*input;
@
% should rename winput I think. or wcurrent (but there is wcurrent())
% or just current. of focuswin.


% also
% - menuing, when in the middle of a menu action like 
%    pointto(), sweep(), drag(), bandsize(), in which case even if the cursor
%    is on a window, you dont want wsetcursor to change it
% - sweeping, when get system menu out, but this seems used
%    very little
% - moving (local to mousethread)

\subsection{Graphical windows}





% important difference we will see later between graphical
% and textual windows. Many things change accordingly.

<<[[Window]] graphical window fields>>=
bool	mouseopen;
@
%old: was bool_byte
% graphical window & mouse field.


\subsection{Textual windows}

% of course it has text!

<<[[Window]] textual window fields>>=
<<[[Window]] textual window fields, text data>>
<<[[Window]] textual window fields, text cursors>>
<<[[Window]] textual window fields, visible text>>
<<[[Window]] textual window fields, graphics>>
@

<<[[Window]] textual window fields, text data>>=
// growing_array<Rune> (size = Window.maxr)
Rune		*r;
uint		nr;	/* number of runes in window */
uint		maxr;	/* number of runes allocated in r */
@
% see wcontents!


% see "Windows should be transparent" intro, talk about
% insert point, cursor, etc.

\t typedef cursor? like in Efuns?

<<[[Window]] textual window fields, text cursors>>=
// index in Window.r
uint		q0; // cursor, where entered text go (and selection start)
// index in Window.r
uint		q1; // selection end or same value than q0 when no selection
@
\l give name ``cursor''?

% user modify q0, by navigating.

% output point? "division between characters the host has seen
% and characters not yet transmitted ... the positino in the
% text that separates output from input".

<<[[Window]] textual window fields, text cursors>>=
// index in Window.r
uint		qh; // output point
@
% why qh??

% process modify qh, by output stuff

% "when characters are sent from the host, they are inserted at
% the output point and the output point is advanced.

% "When newline, chars between output point and newline are sent."

% FIGURE! or delay to later?




% Frame actually means image with text inside, with lines,
%  which can be scrolled.

<<[[Window]] textual window fields, visible text>>=
Frame;
@
% Image is inside frame or cover frame too?
% graphics & textual window field 

% will see Frame later.

<<[[Window]] textual window fields, graphics>>=
Rectangle	scrollr;
@

% FIGURE, Scrollbar | gap | Frame (TextWidget really)


% automatic scroll mode! this is actually quite important
%  because when automatic scrolling, if process write on /dev/cons
%  then need output it, otherwise have to block process on
%  its write
<<[[Window]] config fields>>=
bool	scrolling;
@
%old: was bool_byte
% config & textual window field
\t rename autoscroll?



%\subsection{[[Wctlmesg]]}
%later

\section{Filesystem server}

\subsection{[[FilSys]] and [[filsys]]}

% rio is also a filesystem server! not just graphical app.
% rio uses plan9 ability to have regular process act as filesystem (server).
% userspace filesystem.

% how 9p works? how mount works?
% interface is essentialy a pipe! a server waiting for clients.
% (named pipe? no, no need yet, pipe here is between rio and filsys?
%  or kinda named pipe, but managed by mount and srv??)

<<struct Filsys>>=
struct Filsys
{
    // client
    fdt		cfd;
    // server
    fdt		sfd;

    // ref_own<string>
    char	*user;

    // map<fid, Fid> (next in bucket = Fid.next)
    Fid		*fids[Nhash];

    // chan<ref<Xfid>> (listener = filsysproc, sender = xfidallocthread)
    Channel	*cxfidalloc;	/* chan(Xfid*) */
};
@
%dead: int		pid;  was pid of proccreate(filsysproc), but not needed

% cfd will be published in /srv/rio.user.pid? but not that important

% [[user]] is needed for security purpose, make sure people making request
%  to pipe are the same user

<<global filsys>>=
Filsys	*filsys;
@
% this is used only by winshell when calling filsysmount,
%  which needs to know where the pipe is to communicate like
%  everybody else with the rio fileserver


<<constant Nhash>>=
#define Nhash 16
@

<<[[Fid]] extra fields>>=
Fid		*next;
@


\subsection{File state, [[Fid]]}

% server need to maintain state of requested files,
% just like kernel does with file descriptor state.

% when userspace filesystem, have notion of fid, Fcall message.

<<struct Fid>>=
struct Fid
{
    // the key
    int		fid;

    // the state
    bool	open;
    int		mode;

    <<[[Fid]] other fields>>

    // Extra
    <<[[Fid]] extra fields>>
};
@

%see docs/man/5/intro
%a 32-bit unsigned integer that the client uses to identify
%a ``current file'' on the server.


% fid is client's (filsys) idea of a file on the server.
% qid is server's (kernel) idea of a file on the server.

<<[[Fid]] other fields>>=
Qid		qid;
@
% See libc.h, qid.path, vers, etc.
% qid.path will be made of window id and kind of device file
%  with qid enum we will see later


<<[[Fid]] extra fields>>=
bool	busy;
@

% looks more like lookupfid than always newfid
% ctor
<<function newfid>>=
Fid*
newfid(Filsys *fs, int fid)
{
    Fid *f, *ff, **fh;

    ff = nil;
    fh = &fs->fids[fid&(Nhash-1)];

    // lookup_hash(fid, fs->fids)
    for(f=*fh; f; f=f->next) {
        if(f->fid == fid)
            return f;
        else if(ff==nil && f->busy==false)
            ff = f;
    }
    if(ff){
        ff->fid = fid;
        return ff;
    }
    // else

    f = emalloc(sizeof(Fid));
    f->fid = fid;

    // insert_hash(f, fs->fids)
    f->next = *fh;
    *fh = f;

    return f;
}
@
\t why not use fid=Qid?



<<[[Fid]] other fields>>=
Window	*w;
@
% at some point requested file will be associated with corresponding
% because fid is given a qid (in attach/walk) which will encode
% the windows id.
% So full circle here! get back a Window!







\subsection{Workers and jobs, [[Xfid]]}

% saw server will receive 9p request on pipe while reading filsys.sfd.
% But potentially multiple windows, multiple processes
% each using /dev/xxx served by rio and so need threads to handle
% those requests.
% Server filsysproc can be seen as a master.
% Now see slaves workers.


% Fcall see fcall.h, unmarshalled p9 message received
% from pipe
%  Fcall.buf, Fcall.type
%  Fcall.fid! =~ qid?

% it's a DS which reprenset a filesystem request, Fcall,
% but when it's allocated it's also associated with a worker
% via a channel where can send some code to run! very nice!
% and so Xfid contains also all params for this call

\l rename Xfid to WorkerRequest?
<<struct Xfid>>=
struct Xfid
{
        // incoming parsed request
        Fcall;
        // answer buffer
        byte	*buf;
 
        // handler to worker thread
        // chan<void(*)(Xfid*)> (listener = xfidctl, senders = filsysxxx)
        Channel	*c;	/* chan(void(*)(Xfid*)) */

        Fid	*f;
        Filsys	*fs;

        <<[[Xfid]] flushing fields>>
        <<[[Xfid]] other fields>>

        // Extra
        Ref;
        <<[[Xfid]] extra fields>>
};
@
\t Xfid.fs ? anyway can use the global filsys instead
% The ref seems to be either 0 or 1, so used just to sanity check things
% Ref because possibly concurrently access by xallocthread and xfidctl?

% buf? for filsysrespond? to write back? use same buffer
% after have parsed?




\subsection{Filesystem callbacks, [[fcall]]}

% See Network.nw and plan9 RPC via 9p messages.
% Any process can be a filesystem server for another process.
% so can do mount /srv/rio.user.pid /mnt/wsys 43 
% and now the namespace /mnt/wsys/ will be served by the process
%  on the other side of the pipe in /src/rio.user.pid

% see docs/man/5/* 

% if mount cfd /mnt/wsys, then access from process (or child/execed process
%  which will inherit namespace) to files under /mnt/wsys/ will send
%  messages on cfd which will be processed by other side of pipe
%  and dispatched to right method.

\t could just pass Xfid no? anyway Fid and Filsys are inside Xfid.

% so filsysproc server listening on pipe will interpret 9p 
% incoming request and then dispatch to right function.
% will pass fs, worker handler, and file and then
% the method may or not call worker. It may return nil
% when the worker was used because need async processing.
% That was server know if can reuse or not the worker handler.

<<global fcall>>=
Xfid* 	(*fcall[Tmax])(Filsys*, Xfid*, Fid*) =
{
    [Tattach]  = filsysattach,

    [Twalk]    = filsyswalk,

    [Topen]    = filsysopen,
    [Tclunk]   = filsysclunk,
    [Tread]    = filsysread,
    [Twrite]   = filsyswrite,
    [Tstat]    = filsysstat,

    <<[[fcall]] other methods>>
};
@
% create/remove forbidden, other stuff could be aspectized too

% remember that Xfid is a Fcall, so signature make senses.
% Get incoming request and handler to worker, and
% return nil if need new worker or worker handler if can reuse.

% T for client Transmit request, R for server reply.
% will see R later in filsysrespond

% close? it is clunk, but it's not called close because
%  not all fid correspond to opened files. Clunk is there to
%  say the client does not care anymore about this fid.

% flush seems advanced feature of 9P not super needed.

%docs/man/5/intro
%Most programs do not see the 9P protocol directly; instead calls to library
%routines that access files are
%translated by the mount driver,
%.IR mnt (3),
%into 9P messages.








\chapter{[[main()]]}
\label{chap:main}

\n actually it's threadmain()

% see Libcore.nw, quick refresh on threads in plan9 and
% fact that main is then threadmain.

% main? -> <>
<<function threadmain>>=
void threadmain(int argc, char *argv[])
{
    <<[[main()]] locals>>

    ARGBEGIN{
    <<[[main()]] command line processing>>
    }ARGEND

    <<[[main()]] set some globals>>

    // Rio, a graphical application

    <<[[main()]] graphics initializations>>

    // Rio, a concurrent application

    <<[[main()]] communication channels creation>>
    <<[[main()]] threads creation>>

    // Rio, a filesystem server

    filsys = filsysinit(xfidinit());
    <<[[main()]] if filsys is nil>>
    else{
        <<[[main()]] error management after everything setup>>

        // blocks until get exit message on exitchan
        recv(exitchan, nil);
    }
    killprocs();
    threadexitsall(nil);
}
@
%dead: written but never read
%  <<global mainpid>>=
%  int		mainpid;
%  @
%  <<[[main()]] set some globals>>=
%  mainpid = getpid();
%  @


% exitchan later, but a channel! when Exit menu in rio via mouse,
% this will send on exitchan a message and unblock threadmain.


<<[[main()]] if filsys is nil>>=
if(filsys == nil)
    fprint(STDERR, "rio: can't create file system server: %r\n");
@


\section{Graphics initialization}

% see Graphics.nw

<<[[main()]] graphics initializations>>=
if(geninitdraw(nil, derror, nil, "rio", nil, Refnone) < 0){
    fprint(STDERR, "rio: can't open display: %r\n");
    exits("display open");
}
viewr = view->r;

iconinit(); // allocate background and red images

<<[[main()]] mouse initialisation>>
<<[[main()]] keyboard initialisation>>

wscreen = allocscreen(view, background, false);
<<[[main()]] sanity check wscreen>>

draw(view, viewr, background, nil, ZP);
flushimage(display, true);
@
\l could call initdraw instead of geninitdraw


<<[[main()]] sanity check wscreen>>=
if(wscreen == nil)
    error("can't allocate screen");
@
% ref to Error managment appendix?
% also talk about derror argument to geninitdraw?



% threadmain -> <>
<<function iconinit>>=
void
iconinit(void)
{
    background = allocimage(display, Rect(0,0,1,1), RGB24, true, 0x777777FF);
    red        = allocimage(display, Rect(0,0,1,1), RGB24, true, 0xDD0000FF);
}
@
% why iconinit? icon??

\section{Mouse initialization}

% The windowing system is a graphical application like other graph app!
% It needs to call initmouse, initkeyboard. 

% threadmain -> <>
<<[[main()]] mouse initialisation>>=
mousectl = initmouse(nil, view);
if(mousectl == nil)
    error("can't find mouse");
mouse = mousectl;
@
% cast here, access actually anonymous subfield of mousectl.
% could pass /dev/mouse

% Note that this creates a process! ioproc.

\section{Keyboard initialization}

<<[[main()]] keyboard initialisation>>=
keyboardctl = initkeyboard(nil);
if(keyboardctl == nil)
    error("can't find keyboard");
@
% could pass /dev/mouse

% Note that this creates a process too! ioproc.


\section{Channels creation}

% threads communicate and synchronized between each other through
% messages on channels
%alt: locks or mutex or semaphores or monitor

<<global exitchan>>=
// chan<unit> (listener = threadmain, sender = mousethread(Exit) | ?)
Channel	*exitchan;	/* chan(int) */
@
% It's more chan(void) no?

% rio = waiting for many different kind of messages/"events"
<<[[main()]] communication channels creation>>=
exitchan     = chancreate(sizeof(int), 0);
@

% see also winclosechan and deletechan later
% see also cxfidalloc and cxfidfree later
% there are also lots of channel creation when create windows

\section{Threads creation}

<<constant STACK>>=
#define	STACK	8192
@

<<[[main()]] threads creation>>=
timerinit();

threadcreate(keyboardthread, nil, STACK);
threadcreate(mousethread, nil, STACK);
@
% could pass keyboardctl, mousectl, etc instead of nil
% but convenient to have them in globals.

% timerinit? later. need be before the other thread?

% see also right menu and new create a new window and so a new thread!
%  also each open of a /dev/ file creates a thread?
% see also filsysinit also creates many threads and also some processes
% see also thread for deletechan and winclose, but later.

% will see Threads in next chapter.

\section{Filesystem server initialization}

%    filsys = filsysinit(xfidinit());

\subsection{[[filsysinit()]]}

% ctor filsys
% main -> <>
<<function filsysinit>>=
Filsys*
filsysinit(Channel *cxfidalloc)
{
    int pid;
    Filsys *fs;
    <<[[filsysinit()]] other locals>>

    <<[[filsysinit()]] install dumper>>

    fs = emalloc(sizeof(Filsys));

    if(cexecpipe(&fs->cfd, &fs->sfd) < 0)
        goto Rescue;

    <<[[filsysinit()]] set clockfd>>
    <<[[filsysinit()]] set fs user>>
    pid = getpid();

    fs->cxfidalloc = cxfidalloc;

    <<[[filsysinit()]] wctl pipe, process, and thread creation>>

    proccreate(filsysproc, fs, 10000);

    <<[[filsysinit()]] srv pipe>>

    return fs;

Rescue:
    free(fs);
    return nil;
}
@

% filsysproc later

% user and pid are for
%    // to create "/srv/rio.{user}.{pid}"
% but maybe also more


% comm channel is a pipe this time, because it's between processes.

<<function cexecpipe>>=
/*
 * Build pipe with OCEXEC set on second fd.
 * Can't put it on both because we want to post one in /srv.
 */
errorneg1
cexecpipe(fdt *p0, fdt *p1)
{
    /* pipe the hard way to get close on exec */
    if(bind("#|", "/mnt/temp", MREPL) < 0)
        return ERROR_NEG1;
    *p0 = open("/mnt/temp/data", ORDWR);
    *p1 = open("/mnt/temp/data1", ORDWR|OCEXEC);
    unmount(nil, "/mnt/temp");
    if(*p0<0 || *p1<0)
        return ERROR_NEG1;
    return OK_0;
}
@
% comment about /srv??

% close on exec for server? so keep only client fd?

% See Kernel.nw for pipe and #| device.





<<[[filsysinit()]] other locals>>=
fdt fd;
char buf[128];
int n;
@

<<[[filsysinit()]] set fs user>>=
fd = open("/dev/user", OREAD);
strcpy(buf, "Jean-Paul_Belmondo"); // lol
if(fd >= 0){
    n = read(fd, buf, sizeof buf-1);
    if(n > 0)
        buf[n] = 0;
    close(fd);
}
fs->user = estrdup(buf);
@
% useful beyond the /srv/rio.user.pid? Yes for security
% the worker and filesystem make sure request match the owner of rio


\subsection{Worker allocator, [[xfidinit()]]}

%    filsys = filsysinit(xfidinit());

% workers factory

<<global cxfidalloc>>=
// chan<ref<Xfid>> (listener = filsysproc, sender = xfidallocthread)
static	Channel	*cxfidalloc;	/* chan(Xfid*) */
@
% could avoid using globals if pass it to xfidallocthread
% as anyway it's stored in filsys

<<global cxfidfree>>=
// chan<ref<Xfid>> (listner = ??, sender = ??)
static	Channel	*cxfidfree;	/* chan(Xfid*) */
@

% who owns the Xfid? xfidallocthread! and this allocator
% has two channels for new/free.


% threadmain -> <>
<<function xfidinit>>=
Channel*
xfidinit(void)
{
    cxfidalloc = chancreate(sizeof(Xfid*), 0);
    cxfidfree = chancreate(sizeof(Xfid*), 0);
    threadcreate(xfidallocthread, nil, STACK);
    return cxfidalloc;
}
@

% xfidallocthread later


% regular threads, so no race between xfidxxx and winctl!








\chapter{Processes and Threads}
\label{chap:processes-threads}

% FIGURE? put diagram where see many threads in rio slides
% and also ioproc for mouse and keyboard launched by initmouse
% and initkeyboard.

% In the end rio will manage many independent windows/process/activities.
% Independent activities, answer to keyboard/mouse, events,
% so need manage those activities. Threads seems natural.

% GUI is reactive, not batch, so have external events (kinda interrupts),
% such as mouse move, keyboard, and cant have rio polling that.
% Need separate concerns and be efficient. So threads and channels
% and have thread scheduler do its best to yield to the
% thread who needs it. When mouse, then mouse thread. When keyboard,
% keyboard threads, and those threads then dispatch to the appropriate
% window thread that will handle its own window.

% in the end it's similar to what the kernel does. Process are waiting
% reading on fd connected to some devices, and when interrupt, the
% kernel await some process to go on. So can have independent
% activities working.

%alt: quite similar to a kernel? interrupt handlers?

% Efficiently Scheduling X Clients:
%http://keithp.com/~keithp/talks/usenix2000/smart.html

\section{Keyboard thread}

% The listening channel is keyboardctl->c, see keyboard.h.
% The sending channel is Window.ck, which we will see soon.
% Each window will have a thread.

% // chan<Rune, 20> (listener = keyboardthread, sender = ioproc(initkeyboard))
% Channel* Keyboardctl.c; // Graphics.nw

% listen/dispatch architecture.

% main -> threadcreate -> <>  (as ?? in threadcreate(<>) <- main)
<<function keyboardthread>>=
void
keyboardthread(void*)
{
    Rune buf[2][20];
    // points to buf[0] or buf[1]
    Rune *rp;
    int n, i;

    threadsetname("keyboardthread");

    n = 0;
    for(;;){
        rp = buf[n];
        n = 1-n;

        // Listen
        recv(keyboardctl->c, rp);

        for(i=1; i<nelem(buf[0])-1; i++)
            if(nbrecv(keyboardctl->c, rp+i) <= 0)
                break;
        rp[i] = L'\0';

        if(input != nil)
            // Dispatch, to current window thread!
            sendp(input->ck, rp);
    }
}
@
% no alts(), just a single message, so just recv()

% Rune! so super simple, no need to have Ctl, Alt, ... all of
% those composed keys are Rune? Hmm but then cant intercept
% when guy just type on Ctlr and release?

% pretty simple, send key to the window (window ck channel and thread) 
% with the focus

% null char put as end marker (could pass size instead?)

% why use alternate buffer? so can send with one and recv on the other?
\t sendp ? vs send?


%alt: alternative to keyboard thread? select in rio? callback/interrupts?
% why want to use thread for that?
% Have main rio process do scanf? cant cos buffered.
% So need raw mode, but then blocked ... need to listen but not
% be blocked. Want to listen to many external events, do many concurrent
% things.
% This is what threads (and ioproc) provides.

% why need separate thread just for keyboard? because cant have
% all window thread listen at the same time. Need one thread
% and then dispatch (demultiplex).

\section{Mouse thread}

<<enum Mxxx>>=
enum {
    MMouse,
    <<[[Mxxx]] cases>>
    NALT
};
@
% index for different Alt. Thread will look for multiple messages
% on different channels.


<<[[mousethread()]] locals>>=
// map<enum<Mxxx>, Alt>
static Alt alts[NALT+1];
@
% why static? mousethread not called anyway no?

% small rappel here on libthread maybe? alt =~ select.


<<function mousethread>>=
void
mousethread(void*)
{
    <<[[mousethread()]] locals>>

    threadsetname("mousethread");

    <<[[mousethread()]] alts setup>>
    alts[NALT].op = CHANEND;

    for(;;)
        // message loop
        switch(alt(alts)){
        <<[[mousethread()]] event loop cases>>
        }
}
@

<<[[mousethread()]] alts setup>>=
// listen
alts[MMouse].c = mousectl->c;
alts[MMouse].v = &mousectl->Mouse;
alts[MMouse].op = CHANRCV;
@
% what would be the other Alt??

%// chan<Mouse> (listener = mousethread, sender = ioproc(initkeyboard))
%Channel* Mousectl.c;

% global mousectl here.

% but for now equivalent mostly to a recv(mousectl->c, &mousectl->Mouse)


<<[[mousethread()]] locals>>=
Window *winput;
Point xy; // logical coord
@
\l why local winput? cant use input directly? need to save it?


% different from keyboard, here does not always dispatch to the
% (possibly graphical) window.
% The mouse action must be interpreted by rio itself as it may relate
% to windows managment! mv, resize, etc.
% Local below differentiates those 2 situations, whether need to 
% relay/send mouse event to window.

<<[[mousethread()]] locals>>=
bool sending = false;
@
% application(client) vs system (rio) mouse event!


<<[[mousethread()]] event loop cases>>=
case MMouse:
    <<[[mousethread()]] if wkeyboard and button 6>>
Again:
    winput = input;
    <<[[mousethread()]] if wkeyboard and ptinrect>>

    if(winput != nil && winput->i != nil){
        /* convert to logical coordinates */
        xy.x = mouse->xy.x + (winput->i->r.min.x - winput->screenr.min.x);
        xy.y = mouse->xy.y + (winput->i->r.min.y - winput->screenr.min.y);

        <<[[mousethread()]] goto Sending if scroll buttons>>

        inside = ptinrect(mouse->xy, insetrect(winput->screenr, Selborder));

        <<[[mousethread()]] set scrolling>>
        <<[[mousethread()]] set moving to true for some conditions>>
        else 
           <<[[mousethread()]] set sending to true for some conditions>>
    }else
        sending = false;

    <<[[mousethread()]] if sending>>
    <<[[mousethread()]] if not sending>>

<<[[mousethread()]] Drain label>>
@

% explain logical coordinates, even though rio does not do anymore
% originwindow, so w->i->r and w->screenr ar the same so cancelled out)

% FIGURE: with winput->screenr, i->r, screen->r, etc and how they relate.


<<constant Selborder>>=
Selborder		= 4,	/* border of selected window */
@
%coupling with Borderwidth in draw.h? why not use same constant?


\subsection{Application mouse events}

% when set sending to true? what are the conditions to relay mouse events?
% when inside and scroll, left click, or opened mouse
% if not opened then middle and right click are intercepted.

<<[[mousethread()]] set sending to true for some conditions>>=
if(inside && 
   ((mouse->buttons&1) || winput->mouseopen || scrolling))
     sending = true;
@
% if mouseopen then need relay all mouse messages

% scrolling? when started click to scroll? or when automatic
%  scrolling selected?

<<[[mousethread()]] locals>>=
Mouse tmp;
@

<<[[mousethread()]] if sending>>=
if(sending){
Sending:
    <<[[mousethread()]] when sending mouse message to window, set the cursor>>

    tmp = mousectl->Mouse;
    tmp.xy = xy; // logical coordinates

    // Dispatch, to current window thread!
    send(winput->mc.c, &tmp);
    continue;
}
@


\l could mv later
<<[[mousethread()]] when sending mouse message to window, set the cursor>>=
if(mouse->buttons == 0){
    // cornercursor will call wsetcursor if cursor not on the border
    cornercursor(winput, mouse->xy, false);
    sending = false;
}else
    wsetcursor(winput, false);
@
% so when click button there is never a system cursor?

% send until release button?



\subsection{Windowing system mouse events}

<<[[mousethread()]] locals>>=
Window *w;
@

% window manager related stuff
<<[[mousethread()]] if not sending>>=
w = wpointto(mouse->xy);

/* change cursor if over anyone's border */
if(w != nil)
    cornercursor(w, mouse->xy, false);
else
    riosetcursor(nil, false);

<<[[mousethread()]] if moving and buttons>>

if(w != nil)
    cornercursor(w, mouse->xy, false);

<<[[mousethread()]] if buttons and was not sending>>
moving = false;
break;
@
% why 2 times cornercursor?

% moving??

% important function
<<function wpointto>>=
Window*
wpointto(Point pt)
{
    int i;
    Window *v, *w;

    w = nil;
    for(i=0; i<nwindow; i++){
        v = windows[i];
        if(ptinrect(pt, v->screenr))
         if(!v->deleted)
          if(w==nil || v->topped > w->topped)
            w = v;
    }
    return w;
}
@
% thx to topped can find the topmost one under the cursor


% hmmm, complicated dispatch function.
% LP split more? and make more readable the action
<<[[mousethread()]] if buttons and was not sending>>=
/* we're not sending the event, but if button is down maybe we should */
if(mouse->buttons){
    /* w->topped will be zero or less if window has been bottomed */
    if(w==nil || (w==winput && w->topped > 0)){
        if(mouse->buttons & 1){
            ;
        }else if(mouse->buttons & 2){
            if(winput && !winput->mouseopen)
                <<[[mousethread()]] middle click under certain conditions>>
        }else if(mouse->buttons & 4)
                <<[[mousethread()]] right click under certain conditions>>
    }else{
        /* if button 1 event in the window, top the window and wait for button up. */
        /* otherwise, top the window and pass the event on */
        <<[[mousethread()]] click on unfocused window, set w>>
        if(w && (mouse->buttons!=1 || winborder(w, mouse->xy)))
            // input changed
            goto Again;

        goto Drain;
    }
}
@
% Drain?





\t ??? 
<<[[mousethread()]] Drain label>>=
Drain:
    do {
        readmouse(mousectl);
    } while(mousectl->buttons);
    moving = false;
    goto Again;	/* recalculate mouse position, cursor */
@



\section{Window threads}

% listen to many channels! (and relaying to many channels)

% keyboard listening (and relaying)
% mouse listening (and relaying)
% ctl listening from rio window manager

% special device file listening (/dev/cons) but will see that later

<<enum Wxxx>>=
enum { 
    WKey, 
    WMouse, 
    WCtl,
    <<[[Wxxx]] cases>>

    NWALT 
};
@







% rename winctlthread? more consistent?
% ... -> new() -> threadcreate(<>, w)
<<function winctl>>=
void
winctl(void *arg)
{
    Window *w = arg;
    // map<enum<Wxxx>, Alt>
    Alt alts[NWALT+1];
    char buf[128]; // /dev/mouse interface
    <<[[winctl()]] other locals>>
    
    snprint(buf, sizeof buf, "winctl-id%d", w->id);
    threadsetname(buf);

    <<[[winctl()]] channels creation>>

    <<[[winctl()]] alts setup>>
    alts[NWALT].op = CHANEND;

    for(;;){
        <<[[winctl()]] alts adjustments>>

        // event loop
        switch(alt(alts)){
        <<[[winctl()]] event loop cases>>
        }

        if(!w->deleted)
            flushimage(display, true);
    }
}
@
%old: was char buf[4*12+1]; but just used for threadsetname
% so even though it looks like size for interface to /dev/mouse, it was not

%<<[[winctl()]] local initialisation>>=
%@
%old: 
% npart = 0; was there, but better put with local decl.
% lastb = -1; same

% m = mouse, c = cons
% r = read, w = write
% m = message


\subsection{Keyboard events listening}

<<[[Window]] keyboard fields>>=
// chan<Rune, 20> (listener = winctl, sender = keyboardthread)
Channel	*ck;		/* chan(Rune[10]) */
@
% it's Rune[20] actually no?

% saw send(input->ck) before in keyboard thread.
% so trace of key: 
% kernel (interrupt) -> ioproc(read /dev/cons) !-> keyboardthread !-> winctl
% and not finished ...

<<[[winctl()]] other locals>>=
Rune *kbdr;
@
% allocated by who? because chan 20?

<<[[winctl()]] alts setup>>=
alts[WKey].c = w->ck;
alts[WKey].v = &kbdr;
alts[WKey].op = CHANRCV;
@


<<[[winctl()]] event loop cases>>=
case WKey:
    for(i=0; kbdr[i]!=L'\0'; i++)
        wkeyctl(w, kbdr[i]);
    break;
@
%old, probably debug code commented?:
%//		wkeyctl(w, r);
%//		while(nbrecv(w->ck, &r))
%//			wkeyctl(w, r);

% use of end marker L'\0' here, same than in keyboardthread


% winctl -> <> (when key on ck channel)
<<function wkeyctl>>=
void
wkeyctl(Window *w, Rune r)
{
    <<[[wkeyctl()]] locals>>

    if(r == 0)
        return;
    <<[[wkeyctl()]] return if window was deleted>>

    /* navigation keys work only when mouse is not open */
    <<[[wkeyctl()]] when mouse not opened and navigation keys>>

    <<[[wkeyctl()]] if rawing>>
    <<[[wkeyctl()]] if holding>>

    <<[[wkeyctl()]] when not rawing>>
}
@
\l actually it's not exactly when not rawing, because the if rawing
\l  path is taken if w->rawing && other condition

% when have rune 0?

% will see those cases later when talk about graphical and textual windows.
% will see actually relay to other channel.


<<[[wkeyctl()]] return if window was deleted>>=
if(w->deleted)
    return;
@

\subsection{Mouse events listening}

<<[[Window]] mouse fields>>=
// mc.c = chan<Mouse> (listener = winctl, sender = mousethread)
Mousectl	mc;
@
% note that not all mouse events arrive here, only the one
% mousethread think they are destined for this window

% same DS than in mousethread

\l why need whole Mousectl? why not just channel?


% kernel (interrupt) -> ioproc(read /dev/mouse) !-> mousethread !-> winctl
% and not finished ...


<<[[winctl()]] alts setup>>=
alts[WMouse].c = w->mc.c;
alts[WMouse].v = &w->mc.Mouse;
alts[WMouse].op = CHANRCV;
@

% see in mousethread for the application mouse event dispatch:
%    send(winput->mc.c, &tmp);


<<[[winctl()]] event loop cases>>=
case WMouse:
    <<[[winctl()]] WMouse case if mouseopen>>
    else
    <<[[winctl()]] WMouse case if not mouseopen>>
    break;
@

% no wmousectl()

\subsection{Control events listening}
% e.g., resize, delete, hide, etc.

<<[[Window]] control fields>>=
// chan<Wctlmesg, 20> (listener = winctl, sender = mousethread | ...)
Channel	*cctl;		/* chan(Wctlmesg)[20] */
@

<<[[winctl()]] other locals>>=
Wctlmesg wcm;
@
% will see Wctlmesg later.

<<[[winctl()]] alts setup>>=
alts[WCtl].c = w->cctl;
alts[WCtl].v = &wcm;
alts[WCtl].op = CHANRCV;
@

% many calls to wctlsendmesg() that write in w->cctl


<<[[winctl()]] event loop cases>>=
case WCtl:
    if(wctlmesg(w, wcm.type, wcm.r, wcm.image) == Exited){
        <<[[winctl()]] Wctl case, free channels if wctlmesg is Excited>>
        threadexits(nil);
    }
    continue;
@

% will see wctlmesg later


%\subsection{[[/mnt/wsys/mouse]]  emitting}
%\subsection{[[/mnt/wsys/cons]] emitting}
%\subsection{[[/mnt/wsys/wctl]] emitting}

%\section{Client processes}
% winshell created from mouse threads when New from winctl


\section{Filesystem server process}
\n actually it's a process but it creates many threads indirectly


% why a process? because block on fs->sfd! would block everything
% else.

<<global messagesize>>=
int	messagesize = 8192+IOHDRSZ;	/* good start */
@
% negociated with kernel in filsysversion in first message

%main -> filsysinit -> proccreate -> <>
<<function filsysproc>>=
static
void
filsysproc(void *arg)
{
    Filsys *fs = arg;
    int n;
    byte *buf;
    Xfid *x = nil;
    Fid *f;
    <<[[filsysproc()]] other locals>>

    threadsetname("FILSYSPROC");

    for(;;){
        buf = emalloc(messagesize+UTFmax);	/* UTFmax for appending partial rune in xfidwrite */

        n = read9pmsg(fs->sfd, buf, messagesize);
        <<[[filsysproc()]] sanity check n>>
        if(x == nil){
            send(fs->cxfidalloc, nil);
            recv(fs->cxfidalloc, &x);
            x->fs = fs;
        }
        x->buf = buf;

        if(convM2S(buf, n, x) != n)
            error("convert error in convM2S");
        <<[[filsysproc()]] dump Fcall if debug>>

        <<[[filsysproc()]] sanity check x type>>
        else{
            <<[[filsysproc()]] if x type is Tversion or Tauth>>
            else
                f = newfid(fs, x->fid);

            x->f = f;

            // Dispatch
            x  = (*fcall[x->type])(fs, x, f);
        }
        firstmessage = false;
    }
}
@
%dead:    fs->pid = getpid();  was after threadsetname

% for the comment about UTFMAX, it's because there is a memmove
% far later in xfidwrite when put back a partial rune
% wrote last time

% this reset x after the call? if result could be
% processed immediately, then can reuse, otherwise need
% get a new thread.

% read9pmsg, convM2S, see fcall.h

<<global firstmessage>>=
bool	firstmessage = true;
@
% needed to ensure filsysversion is first request sent


% Note that filsysproc is a proccreate! need because blocking
% on pipe. Note also that in plan9 proccreate create process
% but share address space (RFMEM)! means filsys and Fids can be modified in
% filsysrespond and access in xfidthreads!

<<[[filsysproc()]] sanity check n>>=
if(n <= 0){
    yield();	/* if threadexitsall'ing, will not return */
    fprint(STDERR, "rio: %d: read9pmsg: %d %r\n", getpid(), n);
    errorshouldabort = false;
    error("eof or i/o error on server channel");
}
@
% yield??



<<[[filsysproc()]] if x type is Tversion or Tauth>>=
if(x->type==Tversion || x->type==Tauth)
    f = nil;
@




<<[[filsysproc()]] other locals>>=
Fcall fc;
@
%old: was called t, but sometimes called fc in some functions
% and confusing that it's actually a Fcall Reply, not Transmit.
% maybe should call it r?

<<[[filsysproc()]] sanity check x type>>=
if(fcall[x->type] == nil)
    x = filsysrespond(fs, x, &fc, Ebadfcall);
@



\section{[[Xfid]] allocator thread}

<<enum Xxxx>>=
enum { 
    Alloc, 
    Free, 

    N 
};
@
\t rename XFAlloc, XFFree, XNALT like for the other threads

<<global xfid>>=
// list<ref_own<Xfid>> (next = Xfid.next)
static	Xfid	*xfid;
@

<<global xfidfree>>=
// list<ref_own<Xfid>> (next = Xfid.free)
static	Xfid	*xfidfree;
@


<<[[Xfid]] extra fields>>=
Xfid	*next;
Xfid	*free;
@

% main -> xfidinit -> threadcreate -> <> (as ?? <- threadcreate(<>) <- xfidinit)
<<function xfidallocthread>>=
void
xfidallocthread(void*)
{
    Xfid *x;
    static Alt alts[N+1];

    alts[Alloc].c = cxfidalloc;
    alts[Alloc].v = nil;
    alts[Alloc].op = CHANRCV;
    alts[Free].c = cxfidfree;
    alts[Free].v = &x;
    alts[Free].op = CHANRCV;
    alts[N].op = CHANEND;

    for(;;){
        // event loop
        switch(alt(alts)){
        case Alloc:
            x = xfidfree;
            if(x)
                xfidfree = x->free;
            else{
                x = emalloc(sizeof(Xfid));
                x->c = chancreate(sizeof(void(*)(Xfid*)), 0);
                <<[[xfidallocthread()]] create flushc channel>>

                // insert_list(x, xfid)
                x->next = xfid;
                xfid = x;

                // new Xfid threads!
                threadcreate(xfidctl, x, 16384);
            }
            <<[[xfidallocthread()]] sanity check x when Alloc>>
            incref(x);

            sendp(cxfidalloc, x);
            break;

        case Free:
            <<[[xfidallocthread()]] sanity check x when Free>>
            // insert_list(x, xfidfree)
            x->free = xfidfree;
            xfidfree = x;
            break;
        }
    }
}
@



<<[[xfidallocthread()]] sanity check x when Alloc>>=
if(x->ref != 0){
    fprint(STDERR, "%p incref %ld\n", x, x->ref);
    error("incref");
}
if(x->flushtag != -1)
    error("flushtag in allocate");
@


<<[[xfidallocthread()]] sanity check x when Free>>=
if(x->ref != 0){
    fprint(STDERR, "%p decref %ld\n", x, x->ref);
    error("decref");
}
if(x->flushtag != -1)
    error("flushtag in free");
@

\section{[[Xfid]] threads}
% =~ workers which will handle a file request

% thread ...
<<function xfidctl>>=
void
xfidctl(void *arg)
{
    Xfid *x = arg;
    void (*f)(Xfid*);
    char buf[64];

    snprint(buf, sizeof buf, "xfid.%p", x);

    threadsetname(buf);

    for(;;){
        f = recvp(x->c);

        // Executing a xfidxxx()
        (*f)(x);

        if(decref(x) == 0)
            sendp(cxfidfree, x);
    }
}
@

% very nice, get code on channel (function pointer),
% and start execute it!

% how decref cannot be 0?






\chapter{Cursors}
\label{chap:cursor}

%trans: before heart of rio and windows managment,
% easier part, cursors.

\section{Cursor graphics}

% put pictures instead of code :)
% what is the code that takes the hexa data and draw?

\subsection{Classic cursors}

% arrow? default in ?

<<global crosscursor (windows/rio/data.c)>>=
Cursor crosscursor = {
    {-7, -7},
    {0x03, 0xC0, 0x03, 0xC0, 0x03, 0xC0, 0x03, 0xC0,
     0x03, 0xC0, 0x03, 0xC0, 0xFF, 0xFF, 0xFF, 0xFF,
     0xFF, 0xFF, 0xFF, 0xFF, 0x03, 0xC0, 0x03, 0xC0,
     0x03, 0xC0, 0x03, 0xC0, 0x03, 0xC0, 0x03, 0xC0, },
    {0x00, 0x00, 0x01, 0x80, 0x01, 0x80, 0x01, 0x80,
     0x01, 0x80, 0x01, 0x80, 0x01, 0x80, 0x7F, 0xFE,
     0x7F, 0xFE, 0x01, 0x80, 0x01, 0x80, 0x01, 0x80,
     0x01, 0x80, 0x01, 0x80, 0x01, 0x80, 0x00, 0x00, }
};
@
% when create new window (sweep())

<<global boxcursor (windows/rio/data.c)>>=
Cursor boxcursor = {
    {-7, -7},
    {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
     0xFF, 0xFF, 0xF8, 0x1F, 0xF8, 0x1F, 0xF8, 0x1F,
     0xF8, 0x1F, 0xF8, 0x1F, 0xF8, 0x1F, 0xFF, 0xFF,
     0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, },
    {0x00, 0x00, 0x7F, 0xFE, 0x7F, 0xFE, 0x7F, 0xFE,
     0x70, 0x0E, 0x70, 0x0E, 0x70, 0x0E, 0x70, 0x0E,
     0x70, 0x0E, 0x70, 0x0E, 0x70, 0x0E, 0x70, 0x0E,
     0x7F, 0xFE, 0x7F, 0xFE, 0x7F, 0xFE, 0x00, 0x00, }
};
@
% when move (drag())

<<global sightcursor (windows/rio/data.c)>>=
Cursor sightcursor = {
    {-7, -7},
    {0x1F, 0xF8, 0x3F, 0xFC, 0x7F, 0xFE, 0xFB, 0xDF,
     0xF3, 0xCF, 0xE3, 0xC7, 0xFF, 0xFF, 0xFF, 0xFF,
     0xFF, 0xFF, 0xFF, 0xFF, 0xE3, 0xC7, 0xF3, 0xCF,
     0x7B, 0xDF, 0x7F, 0xFE, 0x3F, 0xFC, 0x1F, 0xF8, },
    {0x00, 0x00, 0x0F, 0xF0, 0x31, 0x8C, 0x21, 0x84,
     0x41, 0x82, 0x41, 0x82, 0x41, 0x82, 0x7F, 0xFE,
     0x7F, 0xFE, 0x41, 0x82, 0x41, 0x82, 0x41, 0x82,
     0x21, 0x84, 0x31, 0x8C, 0x0F, 0xF0, 0x00, 0x00, }
};
@
% when select delete in system menu

<<global whitearrow (windows/rio/data.c)>>=
Cursor whitearrow = {
    {0, 0},
    {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFF, 0xFC, 
     0xFF, 0xF0, 0xFF, 0xF0, 0xFF, 0xF8, 0xFF, 0xFC, 
     0xFF, 0xFE, 0xFF, 0xFF, 0xFF, 0xFE, 0xFF, 0xFC, 
     0xF3, 0xF8, 0xF1, 0xF0, 0xE0, 0xE0, 0xC0, 0x40, },
    {0xFF, 0xFF, 0xFF, 0xFF, 0xC0, 0x06, 0xC0, 0x1C, 
     0xC0, 0x30, 0xC0, 0x30, 0xC0, 0x38, 0xC0, 0x1C, 
     0xC0, 0x0E, 0xC0, 0x07, 0xCE, 0x0E, 0xDF, 0x1C, 
     0xD3, 0xB8, 0xF1, 0xF0, 0xE0, 0xE0, 0xC0, 0x40, }
};
@
% for holding mode

<<global query (windows/rio/data.c)>>=
Cursor query = {
    {-7,-7},
    {0x0f, 0xf0, 0x1f, 0xf8, 0x3f, 0xfc, 0x7f, 0xfe, 
     0x7c, 0x7e, 0x78, 0x7e, 0x00, 0xfc, 0x01, 0xf8, 
     0x03, 0xf0, 0x07, 0xe0, 0x07, 0xc0, 0x07, 0xc0, 
     0x07, 0xc0, 0x07, 0xc0, 0x07, 0xc0, 0x07, 0xc0, },
    {0x00, 0x00, 0x0f, 0xf0, 0x1f, 0xf8, 0x3c, 0x3c, 
     0x38, 0x1c, 0x00, 0x3c, 0x00, 0x78, 0x00, 0xf0, 
     0x01, 0xe0, 0x03, 0xc0, 0x03, 0x80, 0x03, 0x80, 
     0x00, 0x00, 0x03, 0x80, 0x03, 0x80, 0x00, 0x00, }
};
@
% ???

\subsection{Border and corner cursors}

<<global corners (windows/rio/data.c)>>=
Cursor *corners[9] = {
    &tl,    &t,   &tr,
    &l,    nil,   &r,
    &bl,    &b,   &br,
};
@
% top/below, left/right

<<global tl>>=
Cursor tl = {
    {-4, -4},
    {0xfe, 0x00, 0x82, 0x00, 0x8c, 0x00, 0x87, 0xff, 
     0xa0, 0x01, 0xb0, 0x01, 0xd0, 0x01, 0x11, 0xff, 
     0x11, 0x00, 0x11, 0x00, 0x11, 0x00, 0x11, 0x00, 
     0x11, 0x00, 0x11, 0x00, 0x11, 0x00, 0x1f, 0x00, },
    {0x00, 0x00, 0x7c, 0x00, 0x70, 0x00, 0x78, 0x00, 
     0x5f, 0xfe, 0x4f, 0xfe, 0x0f, 0xfe, 0x0e, 0x00, 
     0x0e, 0x00, 0x0e, 0x00, 0x0e, 0x00, 0x0e, 0x00, 
     0x0e, 0x00, 0x0e, 0x00, 0x0e, 0x00, 0x00, 0x00, }
};
@

<<global t>>=
static Cursor t = {
    {-7, -8},
    {0x00, 0x00, 0x00, 0x00, 0x03, 0x80, 0x06, 0xc0, 
     0x1c, 0x70, 0x10, 0x10, 0x0c, 0x60, 0xfc, 0x7f, 
     0x80, 0x01, 0x80, 0x01, 0x80, 0x01, 0xff, 0xff, 
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, },
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 
     0x03, 0x80, 0x0f, 0xe0, 0x03, 0x80, 0x03, 0x80, 
     0x7f, 0xfe, 0x7f, 0xfe, 0x7f, 0xfe, 0x00, 0x00, 
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, }
};
@

<<global tr>>=
Cursor tr = {
    {-11, -4},
    {0x00, 0x7f, 0x00, 0x41, 0x00, 0x31, 0xff, 0xe1, 
     0x80, 0x05, 0x80, 0x0d, 0x80, 0x0b, 0xff, 0x88, 
     0x00, 0x88, 0x0, 0x88, 0x00, 0x88, 0x00, 0x88, 
     0x00, 0x88, 0x00, 0x88, 0x00, 0x88, 0x00, 0xf8, },
    {0x00, 0x00, 0x00, 0x3e, 0x00, 0x0e, 0x00, 0x1e, 
     0x7f, 0xfa, 0x7f, 0xf2, 0x7f, 0xf0, 0x00, 0x70, 
     0x00, 0x70, 0x00, 0x70, 0x00, 0x70, 0x00, 0x70, 
     0x00, 0x70, 0x00, 0x70, 0x00, 0x70, 0x00, 0x00, }
};
@

<<global r>>=
Cursor r = {
    {-8, -7},
    {0x07, 0xc0, 0x04, 0x40, 0x04, 0x40, 0x04, 0x58, 
     0x04, 0x68, 0x04, 0x6c, 0x04, 0x06, 0x04, 0x02, 
     0x04, 0x06, 0x04, 0x6c, 0x04, 0x68, 0x04, 0x58, 
     0x04, 0x40, 0x04, 0x40, 0x04, 0x40, 0x07, 0xc0, },
    {0x00, 0x00, 0x03, 0x80, 0x03, 0x80, 0x03, 0x80, 
     0x03, 0x90, 0x03, 0x90, 0x03, 0xf8, 0x03, 0xfc, 
     0x03, 0xf8, 0x03, 0x90, 0x03, 0x90, 0x03, 0x80, 
     0x03, 0x80, 0x03, 0x80, 0x03, 0x80, 0x00, 0x00, }
};
@

<<global br>>=
Cursor br = {
    {-11, -11},
    {0x00, 0xf8, 0x00, 0x88, 0x00, 0x88, 0x00, 0x88, 
     0x00, 0x88, 0x00, 0x88, 0x00, 0x88, 0x00, 0x88, 
     0xff, 0x88, 0x80, 0x0b, 0x80, 0x0d, 0x80, 0x05, 
     0xff, 0xe1, 0x00, 0x31, 0x00, 0x41, 0x00, 0x7f, },
    {0x00, 0x00, 0x00, 0x70, 0x00, 0x70, 0x00, 0x70, 
     0x0, 0x70, 0x00, 0x70, 0x00, 0x70, 0x00, 0x70, 
     0x00, 0x70, 0x7f, 0xf0, 0x7f, 0xf2, 0x7f, 0xfa, 
     0x00, 0x1e, 0x00, 0x0e, 0x00, 0x3e, 0x00, 0x00, }
};
@

<<global b>>=
Cursor b = {
    {-7, -7},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
     0xff, 0xff, 0x80, 0x01, 0x80, 0x01, 0x80, 0x01, 
     0xfc, 0x7f, 0x0c, 0x60, 0x10, 0x10, 0x1c, 0x70, 
     0x06, 0xc0, 0x03, 0x80, 0x00, 0x00, 0x00, 0x00, },
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
     0x00, 0x00, 0x7f, 0xfe, 0x7f, 0xfe, 0x7f, 0xfe, 
     0x03, 0x80, 0x03, 0x80, 0x0f, 0xe0, 0x03, 0x80, 
     0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, }
};
@

<<global bl>>=
Cursor bl = {
    {-4, -11},
    {0x1f, 0x00, 0x11, 0x00, 0x11, 0x00, 0x11, 0x00, 
     0x11, 0x00, 0x11, 0x00, 0x11, 0x00, 0x11, 0x00, 
     0x11, 0xff, 0xd0, 0x01, 0xb0, 0x01, 0xa0, 0x01, 
     0x87, 0xff, 0x8c, 0x00, 0x82, 0x00, 0xfe, 0x00, },
    {0x00, 0x00, 0x0e, 0x00, 0x0e, 0x00, 0x0e, 0x00, 
     0x0e, 0x00, 0x0e, 0x00, 0x0e, 0x00, 0x0e, 0x00, 
     0x0e, 0x00, 0x0f, 0xfe, 0x4f, 0xfe, 0x5f, 0xfe, 
     0x78, 0x00, 0x70, 0x00, 0x7c, 0x00, 0x00, 0x0, }
};
@

<<global l>>=
Cursor l = {
    {-7, -7},
    {0x03, 0xe0, 0x02, 0x20, 0x02, 0x20, 0x1a, 0x20, 
     0x16, 0x20, 0x36, 0x20, 0x60, 0x20, 0x40, 0x20, 
     0x60, 0x20, 0x36, 0x20, 0x16, 0x20, 0x1a, 0x20, 
     0x02, 0x20, 0x02, 0x20, 0x02, 0x20, 0x03, 0xe0, },
    {0x00, 0x00, 0x01, 0xc0, 0x01, 0xc0, 0x01, 0xc0, 
     0x09, 0xc0, 0x09, 0xc0, 0x1f, 0xc0, 0x3f, 0xc0, 
     0x1f, 0xc0, 0x09, 0xc0, 0x09, 0xc0, 0x01, 0xc0, 
     0x01, 0xc0, 0x01, 0xc0, 0x01, 0xc0, 0x00, 0x00, }
};
@


\section{Setting the cursor}

% rio cursor, window managment, vs app cursor!

\subsection{[[riosetcursor()]]}

<<global lastcursor>>=
Cursor	*lastcursor;
@

<<function riosetcursor>>=
void
riosetcursor(Cursor *p, bool force)
{
    if(!force && p==lastcursor)
        return;
    setcursor(mousectl, p);
    lastcursor = p;
}
@

% setcursor() from mouse.h, will write in /dev/cursor

% what this force is all about? why sometimes need and sometimes not?

\subsection{[[cornercursor()]]}

% mousethread -> <>
<<function cornercursor>>=
void
cornercursor(Window *w, Point p, bool force)
{
    if(w != nil && winborder(w, p))
        riosetcursor(corners[whichcorner(w, p)], force);
    else
        wsetcursor(w, force);
}
@
% actually put cornercursor only if on the corner


<<function winborder>>=
bool
winborder(Window *w, Point xy)
{
    return ptinrect(xy, w->screenr) && 
           !ptinrect(xy, insetrect(w->screenr, Selborder));
}
@


% cornercursor -> <>
<<function whichcorner>>=
int
whichcorner(Window *w, Point p)
{
    int i, j;
    
    i = portion(p.x, w->screenr.min.x, w->screenr.max.x);
    j = portion(p.y, w->screenr.min.y, w->screenr.max.y);
    return 3*j + i;
}
@
% j = 0 means top, j = 1 means middle, j = 2 means below

% whichcorner -> <>
<<function portion>>=
int
portion(int x, int lo, int hi)
{
    x -= lo;
    hi -= lo;

    if(x < 20)
        return 0; // top
    if(x > hi-20)
        return 2; // below
    return 1; // middle
}
@


\subsection{[[wsetcursor()]]}

<<[[Window]] mouse fields>>=
Cursor		cursor;
Cursor		*cursorp;
@

% each window can write on his own /dev/cursor
% so when mouse over different windows, need to
% load the appropriate cursor

% will see later how a window can change its cursor (via
%  virtual /dev/cursor handler)

<<function wsetcursor>>=
void
wsetcursor(Window *w, bool force)
{
    Cursor *p;

    if(w==nil || w->i==nil || Dx(w->screenr)<=0)
        p = nil;
    else if(wpointto(mouse->xy) == w){
        p = w->cursorp;
        <<[[wsetcursor()]] if holding>>
    }else
        p = nil;

    if(!menuing)
        riosetcursor(p, force);
}
@
%old: /*w!=input || */ 
%old:
%    if(!menuing)
%        riosetcursor(p, force && !menuing);
%  but !menuing obviously redundant and true


% menuing means that are in the middle of a system action 
% (sweep, move, reshape) in which case do not honor window cursor.







\chapter{Window Manager}
\label{chap:wm}


\section{Overview}

% in plan9, same program than window server.
%alt: separate program as in X11

% Window management operations can be trigged in different ways:
% - right click menu (rio/system menu), can create new window
% - mouse operations on border of window
% - dev/wctl
% - filsys, listening pipe, mount can create new window
% - /srv/riowctl.user.pid

% They all trigger then messages send to the appropriate window thread 
% via wsendctlmsg(w->cctl).

\section{Right click system menu}

% so most of this chapter is from mousethread() context!
% but will at some point send some Wctlmesg to the window thread
% which will do the modifications.

<<[[mousethread()]] right click under certain conditions>>=
button3menu();
@


% mousethread -> event loop -> <>
<<function button3menu>>=
void
button3menu(void)
{
    int i;

    <<[[button3menu()]] menu3str adjustments with hidden windows>>

    sweeping = true;
    switch(i = menuhit(3, mousectl, &menu3, wscreen)){
    <<[[button3menu()]] cases>>
    case -1:
        break;
    }
    sweeping = false;
}
@
%old:
%        if(Hidden > Exit){
%        }
%        /* else fall through */
% tricks when Exit was an optional menu item disabled sometimes
% but I made it always apparent now.

% displaying a menu with menuhit is drawing something! on top of what you
% are currently! it's part of the drawing library! See Graphics.nw.
% The menu is probably simply an overlapping window.

% mousectl->Mouse.xy will contain location to put the menu

<<global sweeping>>=
bool	sweeping;
@
% seems used when menu is out, but used very little
% or when in middle of big action started in mousethread



<<global menu3>>=
Menu menu3 = { menu3str };
@

<<global menu3str>>=
char*		menu3str[100] = {
 [New]		"New",
 [Reshape]	"Resize",
 [Move]		"Move",
 [Delete]	"Delete",
 [Hide]		"Hide",
 [Exit]		"Exit",
 nil
};
@
%old: was in main()
%  // pad:let's keep the Exit option!
%  if(strstr(argv[0], ".out") == nil){
%  	menu3str[Exit] = nil;
%  	Hidden--;
%  }


<<enum _anon_ (windows/rio/rio.c)>>=
enum
{
    New,

    Reshape,
    Move,
    Delete,
    Hide,

    Exit,

    Hidden,
};
@
%pad: I introduced Hidden
%old: used to be a global
% <<global Hidden>>=
% int	Hidden = Exit+1;
% @

% Hidden is for the start of the hidden windows.
% When a window is hidden it's accessible in the right menu! 
% hence the 100 below
% see Section X later.




<<[[button3menu()]] cases>>=
case Exit:
    send(exitchan, nil);
    break;
@
% threadmain is listening on exitchan

%toc:
% we will see handlers for other actions later.


\section{Window borders click}

<<[[mousethread()]] locals>>=
bool moving = false;
@
% ???
\t how?

% when set moving to true?? when on window border!
<<[[mousethread()]] set moving to true for some conditions>>=
/* topped will be zero or less if window has been bottomed */
if(sending == false && !scrolling 
   && winborder(winput, mouse->xy) && winput->topped > 0){
    moving = true;
}
@



<<[[mousethread()]] locals>>=
bool inside, band;
Window *oin;
Image *i;
Rectangle r;
@

<<[[mousethread()]] if moving and buttons>>=
if(moving && (mouse->buttons&7)){
    oin = winput;
    band = mouse->buttons & 3; // left or middle click

    sweeping = true;
    if(band)
        i = bandsize(winput);
    else
        i = drag(winput, &r);
    sweeping = false;

    if(i != nil){
        if(winput == oin){
            if(band)
                wsendctlmesg(winput, Reshaped, i->r, i);
            else
                wsendctlmesg(winput, Moved, r, i);
            cornercursor(winput, mouse->xy, true);
        }else
            freeimage(i);
    }
}
@
% when winput can change in middle of operation?
%  thread arrives which changed focused window?

% bandsize and drag later




\section{[[Wctlmesg]]}

<<enum wctlmesgkind>>=
enum	/* control messages */
{
    Reshaped, // Resized, Hide/Expose
    Moved,
    <<[[Wctlmesgkind]] cases>>
};
@
% different than previous enum for the menu, here it's a message!
% there is a 'd' at the end, Move -> Moved

% wrefresh vs wrepaint?





<<struct Wctlmesg>>=
struct Wctlmesg
{
    // enum<Wctlmesgkind>
    int		type;

    Rectangle	r;
    Image	*image;
};
@
% r? image? because some action involve a rectangle and image 
% like when sweep which defines an area
% (actually why need rectangle, image not enough?)

<<function wsendctlmesg>>=
void
wsendctlmesg(Window *w, int type, Rectangle r, Image *image)
{
    Wctlmesg wcm;

    wcm.type = type;
    wcm.r = r;
    wcm.image = image;

    send(w->cctl, &wcm);
}
@

% from winctl event loop! to process on the window thread side a  Wctlmesg
% winctl -> <>
<<function wctlmesg>>=
int
wctlmesg(Window *w, int m, Rectangle r, Image *i)
{
    char buf[64];

    switch(m){
    <<[[wctlmesg()]] cases>>
    default:
        error("unknown control message");
        break;
    }
    return m;
}
@







\t distribute
<<[[Wctlmesgkind]] cases>>=
Wakeup,
@

% wcurrent | button2menu | xfidopen(Qwctl) --> <>
<<[[wctlmesg()]] cases>>=
case Wakeup:
    break;
@

\t distribute
<<[[Wctlmesgkind]] cases>>=
Refresh,
@
% seens called when close the mouse, maybe to restore frame
% maybe can put in Textual windows chapter

% xfidclose (Qmouse) -> <>
<<[[wctlmesg()]] cases>>=
case Refresh:
    if(w->deleted || Dx(w->screenr)<=0 || !rectclip(&r, w->i->r))
        break;
    if(!w->mouseopen)
        wrefresh(w, r);
    flushimage(display, true);
    break;
@

<<function wrefresh>>=
void
wrefresh(Window *w, Rectangle)
{
    /* BUG: rectangle is ignored */
    if(w == input)
        wborder(w, Selborder);
    else
        wborder(w, Unselborder);
    if(w->mouseopen)
        return;
    // else

    draw(w->i, insetrect(w->i->r, Borderwidth), w->cols[BACK], nil, w->i->r.min);
    w->ticked = 0;
    if(w->p0 > 0)
        frdrawsel(w, frptofchar(w, 0), 0, w->p0, 0);
    if(w->p1 < w->nchars)
        frdrawsel(w, frptofchar(w, w->p1), w->p1, w->nchars, 0);
    frdrawsel(w, frptofchar(w, w->p0), w->p0, w->p1, 1);
    w->lastsr = ZR;
    wscrdraw(w);
}
@







\section{Window creation}
% via menu

% most important operation. Link with draw.
% link with external process.

<<[[button3menu()]] cases>>=
case New:
    new(sweep(), false, scrolling, 0, nil, "/bin/rc", nil);
    break;
@

% sweep will let user specify a window geometry
% and  allocate a (named) window!

% There are other way to create new window, but will see later.
% this one is simplest.

\subsection{Window thread creation, [[new()]]}

% if pid == 0 then means create a new terminal process
% otherwise, process already there, just need create window.
% who call new with pid != 0? when externa process such as a shell
% want to access rio (via mount /srv/rio.user.pid ...) see chapter X

%ctor!
% ((right click -> button3menu()) | wctlnew()) -> <>
<<function new>>=
Window*
new(Image *i, bool hideit, bool scrollit, int pid, char *dir, char *cmd, char **argv)
{
    Channel *cm, *ck, *cctl;
    Channel *cpid;
    Mousectl *mc;
    Window *w;
    <<[[new()]] other locals>>

    <<[[new()]] sanity check i>>

    <<[[new()]] channels creation>>
    cpid = chancreate(sizeof(int), 0);
    <<[[new()]] sanity check channels>>

    <<[[new()]] mc allocation>>

    w = wmk(i, mc, ck, cctl, scrollit);
    free(mc);	/* wmk copies *mc */

    // growing array
    windows = erealloc(windows, ++nwindow * sizeof(Window*));
    windows[nwindow-1] = w;
    <<[[new()]] if hideit>>

    // a new thread! for this new window!
    threadcreate(winctl, w, 8192);

    if(!hideit)
        wcurrent(w);

    flushimage(display, true);

    <<[[new()]] if pid == 0, create winshell process and set pid>>
    <<[[new()]] sanity check pid>>

    wsetpid(w, pid, true);
    wsetname(w);

    if(dir)
        w->dir = estrdup(dir);

    chanfree(cpid);
    return w;
}
@
% always growing windows? never reuse when a window is closed?

% cpid allow communicate pid of child process back to parent
% and so winctl thread.
%alt: need use channel? cant just get fork return integer value
% simply? because use proccreate(winshell, and dont want to
% block on fork? but proccreate could return pid no?
% because anyway winshell is just a procexec


% seen those channels properties before
<<[[new()]] channels creation>>=
cm = chancreate(sizeof(Mouse), 0);
ck = chancreate(sizeof(Rune*), 0);
cctl = chancreate(sizeof(Wctlmesg), 4);
@
% passed to wmk and set in Window fields.

<<[[new()]] mc allocation>>=
mc = emalloc(sizeof(Mousectl));
*mc = *mousectl;
mc->image = i;
mc->c = cm;
@
% local image, local channel
% why copy mousectl?




<<[[new()]] sanity check i>>=
if(i == nil)
    return nil;
@
<<[[new()]] sanity check channels>>=
if(cm==nil || ck==nil || cctl==nil)
    error("new: channel alloc failed");
@

\subsection{Window allocation, [[wmk()]]}


%ctor 
<<function wmk>>=
Window*
wmk(Image *i, Mousectl *mc, Channel *ck, Channel *cctl, bool scrolling)
{
    Window *w;
    Rectangle r;

    <<[[wmk()]] cols initialisation>>

    w = emalloc(sizeof(Window));

    w->i = i;
    w->screenr = i->r;
    w->cursorp = nil;

    w->id = ++id;
    w->topped = ++topped;

    <<[[wmk()]] channels creation>>

    <<[[wmk()]] textual window settings>>

    w->notefd = -1;
    w->dir = estrdup(startdir);
    w->label = estrdup("<unnamed>");

    wborder(w, Selborder);
    wscrdraw(w);

    incref(w);	/* ref will be removed after mounting; avoids delete before ready to be deleted */
    return w;
}
@
%old: I changed the order of some initialisations, to group textual window
% stuff together

\t wscrdraw??

% about incref comment, see call to wclose in winshell after filsysmount

<<[[wmk()]] channels creation>>=
w->mc = *mc;
w->ck = ck;
w->cctl = cctl;
@



%\subsection{Window border}

<<function wborder>>=
void
wborder(Window *w, int type)
{
    Image *col;

    <<[[wborder()]] sanity check w>>
    <<[[wborder()]] if holding>>
    else{
        if(type == Selborder)
            col = titlecol;
        else
            col = lighttitlecol;
    }

    border(w->i, w->i->r, Selborder, col, ZP);
}
@
% will see col later

<<[[wborder()]] sanity check w>>=
if(w->i == nil)
    return;
@



<<[[Window]] other fields>>=
char		*dir; // /dev/wdir
@
% window working dir


<<global startdir>>=
char		*startdir;
@
<<[[main()]] locals>>=
char buf[256];
@
%old dead? static void *arg[1];
<<[[main()]] set some globals>>=
if(getwd(buf, sizeof buf) == nil)
    startdir = estrdup(".");
else
    startdir = estrdup(buf);
@



\subsection{Window process creation, [[winshell()]]}

<<global rcargv>>=
char *rcargv[] = { "rc", "-i", nil };
@

<<[[new()]] other locals>>=
void **arg;
@

%when new from the system menu
<<[[new()]] if pid == 0, create winshell process and set pid>>=
if(pid == 0){
    arg = emalloc(5 * sizeof(void*));
    arg[0] = w;
    arg[1] = cpid;
    arg[2] = cmd;
    if(argv == nil)
        arg[3] = rcargv;
    else
        arg[3] = argv;
    arg[4] = dir;

    proccreate(winshell, arg, 8192);

    pid = recvul(cpid);
    free(arg);
}
@
% pass w so can communicate back with its winctl thread handler

% wait for pid. pid will be passed to wsetpid, so know
% which process we are connected to, and which one to kill if delete
% window

% independent process, this is where gonna exec stuff! but before
% set right namespace.



<<[[new()]] sanity check pid>>=
if(pid == 0){
    /* window creation failed */
    wsendctlmesg(w, Deleted, ZR, nil);
    chanfree(cpid);
    return nil;
}
@



% have already half of it, new, wmk, winctl thread creation,
% and a few channels. Now need a fake /dev/cons, /dev/mouse, etc

% new(..., pid = 0, ...) -> proccreate(<>)
% by default new windows are in "textual mode"
% the cmd is often "rc -i" (rc -i explicit interactive mode because
%   rc expect #c/cons or /mnt/term/dev/cons)
<<function winshell>>=
void
winshell(void *args)
{
    Window *w;
    Channel *pidc;
    void **arg;
    char *cmd, *dir;
    char **argv;
    errorneg1 err;

    arg = args;

    w    = arg[0];
    pidc = arg[1];
    cmd  = arg[2];
    argv = arg[3];
    dir  = arg[4];

    rfork(RFNAMEG|RFFDG|RFENVG);

    <<[[winshell()]] adjust namespace>>
    <<[[winshell()]] reassign STDIN/STDOUT>>

    if(wclose(w) == false){	/* remove extra ref hanging from creation */
        notify(nil);
        dup(STDOUT, STDERR); // STDERR = STDOUT
        if(dir)
            chdir(dir);

        // Exec!!
        procexec(pidc, cmd, argv);
        _exits("exec failed"); // should never be reached
    }
}
@
% remove extra ref, see comment in wmk

% procexec? take a channel? to write pid there?


<<[[Window]] process fields>>=
int		pid;
// /proc/<pid>/notepg
fdt	 	notefd;
@
% can communicate with process though signals!

% new -> <>
<<function wsetpid>>=
void
wsetpid(Window *w, int pid, bool dolabel)
{
    char buf[128];
    fdt fd;

    w->pid = pid;

    if(dolabel){
        sprint(buf, "rc %d", pid);
        free(w->label);
        w->label = estrdup(buf);
    }

    sprint(buf, "/proc/%d/notepg", pid);
    fd = open(buf, OWRITE|OCEXEC);
    if(w->notefd > 0)
        close(w->notefd);
    w->notefd = fd;
}
@


\subsection{Namespace adjustments, [[filsysmount()]]}

<<[[winshell()]] adjust namespace>>=
err = filsysmount(filsys, w->id);
<<[[winshell()]] sanity check err filsysmount>>
@
%pad: I added err to aspectize sanity checking

% use of filsys here! which is why we need it to be a global!

<<function filsysmount>>=
/*
 * Called only from a different FD group
 */
errorneg1
filsysmount(Filsys *fs, int id)
{
    char buf[32];
    errorneg1 err;

    close(fs->sfd);	/* close server end so mount won't hang if exiting */
    sprint(buf, "%d", id);
    err = mount(fs->cfd, -1, "/mnt/wsys", MREPL, buf);
    <<[[filsysmount()]] sanity check err mount>>
    err = bind("/mnt/wsys", "/dev", MBEFORE);
    <<[[filsysmount()]] sanity check err bind>>
    return OK_0;
}
@
% pass window id to mount, for /mnt/wsys/x/ and to know
%  later which window to send request to probably.
%pad: I added err


<<[[winshell()]] reassign STDIN/STDOUT>>=
// reassign stdin/stdout to virtualized /dev/cons from filsysmount
close(STDIN);
err = open("/dev/cons", OREAD);
<<[[winshell()]] sanity check err open cons stdin>>
close(STDOUT);
err = open("/dev/cons", OWRITE);
<<[[winshell()]] sanity check err open cons stdout>>
@





<<[[winshell()]] sanity check err open cons stdin>>=
if(err < 0){
    fprint(STDERR, "can't open /dev/cons: %r\n");
    sendul(pidc, 0);
    threadexits("/dev/cons");
}
@

<<[[winshell()]] sanity check err open cons stdout>>=
if(err < 0){
    fprint(STDERR, "can't open /dev/cons: %r\n");
    sendul(pidc, 0);
    threadexits("open");	/* BUG? was terminate() */
}
@

<<[[winshell()]] sanity check err filsysmount>>=
if(err < 0){
    fprint(STDERR, "mount failed: %r\n");
    sendul(pidc, 0);
    threadexits("mount failed");
}
@



<<[[filsysmount()]] sanity check err mount>>=
if(err < 0){
    fprint(STDERR, "mount failed: %r\n");
    return ERROR_NEG1;
}
@
<<[[filsysmount()]] sanity check err bind>>=
if(err < 0){
    fprint(STDERR, "bind failed: %r\n");
    return ERROR_NEG1;
}
@

\subsection{Public named image, [[wsetname()]]}

%trans: adjusted namespace for client process to see
% virtualized /dev/cons, /dev/mouse.
% Miss /dev/draw. But actually use different mechanism.
% Not virtualized. Would be too slow to have intermediate.

%trans:
% so /dev/winname will be good because adjusted namespace
% but need to make image public! % so client can find it.
%alt: could pass info via putenv? but anyway have already
% a mechanism /dev/xxx so why not use it.

<<[[Window]] id fields>>=
uint		namecount;
@
% counter

% new -> <>
<<function wsetname>>=
void
wsetname(Window *w)
{
    int i, n;
    char err[ERRMAX];
    
    n = sprint(w->name, "window.%d.%d", w->id, w->namecount++);

    if(nameimage(w->i, w->name, true) > 0)
        return;
    // else
    <<[[wsetname()]] if image name already in use, try another name>>
}
@
%pad: I copy pasted and duplicated the code which call nameimage,
% but then can aspectize better the special error case

% thx to that, geninitdraw will work!


<<[[wsetname()]] if image name already in use, try another name>>=
for(i='A'; i<='Z'; i++){
    if(nameimage(w->i, w->name, true) > 0)
        return;

    errstr(err, sizeof err);
    if(strcmp(err, "image name in use") != 0)
        break;
    w->name[n] = i;
    w->name[n+1] = '\0';
}
w->name[0] = 0;
fprint(STDERR, "rio: setname failed: %s\n", err);
@


\subsection{Mouse action [[sweep()]]}

<<global menuing>>=
bool menuing;/* menu action is pending; waiting for window to be indicated */
@
% should be called sweeping no?

% button3menu() | wctlnew() -> new() -> wmk () -> <>
% ex:  new(sweep(), false, scrolling, 0, nil, "/bin/rc", nil);
<<function sweep>>=
Image*
sweep(void)
{
    Image *i, *oi;
    Rectangle r;
    Point p0, p;

    i = nil;

    menuing = true;
    riosetcursor(&crosscursor, true);
    while(mouse->buttons == 0)
        readmouse(mousectl);

    p0 = onscreen(mouse->xy);
    p = p0;
    r = Rpt(p0, p0);
    oi = nil;

    while(mouse->buttons == 4){ // right click
        readmouse(mousectl);

        if(mouse->buttons != 4 && mouse->buttons != 0)
            break;
        if(!eqpt(mouse->xy, p)){
            p = onscreen(mouse->xy);
            r = canonrect(Rpt(p0, p));

            if(Dx(r)>5 && Dy(r)>5){
                i = allocwindow(wscreen, r, Refnone, 0xEEEEEEFF); /* grey */
                freeimage(oi);
                <<[[sweep()]] sanity check i>>
                oi = i;
                border(i, r, Selborder, red, ZP);
                flushimage(display, true);
            }
        }
    }
    <<[[sweep()]] sanity check mouse buttons, i, and rectangle size>>
    oi = i;
    i = allocwindow(wscreen, oi->r, Refbackup, DWhite);
    freeimage(oi);
    <<[[sweep()]] sanity check i>>
    border(i, r, Selborder, red, ZP);
    cornercursor(input, mouse->xy, true);
    goto Return;
<<[[sweep()]] Rescue handler>>

 Return:
    moveto(mousectl, mouse->xy);	/* force cursor update; ugly */
    menuing = false;
    return i;
}
@
%old: use Rpt
%    r.min = p0;
%    r.max = p0;

% Refnone first, so transparent!
% Then Refbackup

% readmouse(mousectl), but does not conflict with mousethread??
% or thread/channel lib gives priority to last one waiting on channel?
% but then as soon as received, how ensure mousethread will not recv?
% because scheduler does not preempt threads? (or timerinit does?)


<<function onscreen>>=
Point
onscreen(Point p)
{
    p.x = max(view->clipr.min.x, p.x);
    p.x = min(view->clipr.max.x, p.x);
    p.y = max(view->clipr.min.y, p.y);
    p.y = min(view->clipr.max.y, p.y);
    return p;
}
@



<<[[sweep()]] sanity check i>>=
if(i == nil)
    goto Rescue;
@

<<[[sweep()]] sanity check mouse buttons, i, and rectangle size>>=
if(mouse->buttons != 0)
    goto Rescue;
if(i==nil || Dx(i->r)<100 || Dy(i->r)<3*font->height)
    goto Rescue;
@


<<[[sweep()]] Rescue handler>>=
 Rescue:
    freeimage(i);
    i = nil;
    cornercursor(input, mouse->xy, 1);
    while(mouse->buttons)
        readmouse(mousectl);
@








\section{Window focus}
% via mouse

% put code of mousethread related to window focus here!!

<<[[mousethread()]] click on unfocused window, set w>>=
w = wtop(mouse->xy);
@
% w is used for what then?


% mousethread -> <>
<<function wtop>>=
Window*
wtop(Point pt)
{
    Window *w;

    w = wpointto(pt);
    if(w){
        if(w->topped == topped)
            return nil;
        topwindow(w->i); // draw.h
        wcurrent(w);
        flushimage(display, true);
        w->topped = ++topped;
    }
    return w;
}
@
% saw wpointto before, for mousethread to identify windows under cursor

% topwindow not enough? no because border is actually drawn
% by window manager


% new | wtop | ... -> <>
<<function wcurrent>>=
void
wcurrent(Window *w)
{
    Window *oi;

    <<[[wcurrent()]] if wkeyboard>>
    oi = input;
    // updated input!
    input = w;

    if(oi && oi != w)
        wrepaint(oi);
    if(w){
        wrepaint(w);
        wsetcursor(w, false);
    }
    <<[[wcurrent()]] wakeup w and oi>>
}
@


\l rename wrepaintborders?

% wcurrent | ... -> <>
<<function wrepaint>>=
void
wrepaint(Window *w)
{

    <<[[wrepaint()]] update cols>>
    <<[[wrepaint()]] if mouse not opened>>

    if(w == input){
        wborder(w, Selborder);
        wsetcursor(w, false);
    }else
        wborder(w, Unselborder);
}
@
% if ! mouseopen then have a frame with scrollbar, so redraw it

<<constant Unselborder>>=
Unselborder		= 1,	/* border of unselected window */
@

% this is where see difference of color between selected and unselected



\section{Window deletion}
% via menu

% 2 steps, Deleted, and then Exited

<<[[button3menu()]] cases>>=
case Delete:
    delete();
    break;
@

\subsection{[[delete()]]}

<<function delete>>=
void
delete(void)
{
    Window *w;

    w = pointto(true);
    if(w)
        wsendctlmesg(w, Deleted, ZR, nil);
}
@
% pointto != wpointto, = menu action we will see soon


<<[[Wctlmesgkind]] cases>>=
Deleted,
@


<<[[Window]] config fields>>=
bool	deleted;
@
%old: bool_byte


<<[[wctlmesg()]] cases>>=
case Deleted:
    <<[[wctlmesg()]] break if window was deleted>>
    write(w->notefd, "hangup", 6);
    proccreate(deletetimeoutproc, estrdup(w->name), 4096);
    wclosewin(w);
    break;
@
% want to block for action as little as possible, a bit like in kernel
%  where want to do the minimum in an interrupt, hence
%  the use of an auxilary process to take care of waiting for the
%  hangup process and clean resources


<<[[wctlmesg()]] break if window was deleted>>=
if(w->deleted)
    break;
@

% wctlmesg | wclose -> <>
<<function wclosewin>>=
void
wclosewin(Window *w)
{
    int i;

    w->deleted = true;

    if(w == input){
        input = nil;
        wsetcursor(w, false);
    }
    <<[[wclosewin()]] if wkeyboard>>
    <<[[wclosewin()]] remove w from hidden>>

    for(i=0; i<nwindow; i++)
        if(windows[i] == w){
            --nwindow;
            memmove(windows+i, windows+i+1, (nwindow-i)*sizeof(Window*));

            freeimage(w->i);
            w->i = nil;
            return;
        }
    error("unknown window in closewin");
}
@
%dead:
%    Rectangle r;
%             w->deleted = true; // again??
%             r = w->i->r;
%             /* move it off-screen to hide it, in case client is slow in letting it go */
%             //if(0) originwindow(w->i, r.min, view->r.max);



\subsection{[[deletetimeoutproc()]] and [[deletethread()]]}

\t not sure we need that, does already freeimage in wclosewin

% process
<<function deletetimeoutproc>>=
void
deletetimeoutproc(void *v)
{
    char *s = v;

    sleep(750);	/* remove window from screen after 3/4 of a second */
    sendp(deletechan, s);
}
@
% separate process cos sleep is blocking


<<global deletechan>>=
// chan<string> (listener = deletethread, sender = deletetimeoutproc)
Channel* deletechan;
@
% deletetimeoutproc (as ? in proccreate(<>) <- wctlmesg(Delete | Moved) <- 
%  mousethread

<<[[main()]] communication channels creation>>=
deletechan   = chancreate(sizeof(char*), 0);
@

<<[[main()]] threads creation>>=
threadcreate(deletethread, nil, STACK);
@

% why not do that in deletetimeoutproc directly? why pass
%  through extra thread?


<<function deletethread>>=
/* thread to make Deleted windows that the client still holds disappear offscreen after an interval */
void
deletethread(void*)
{
    char *s;
    Image *i;

    threadsetname("deletethread");

    for(;;){
        s = recvp(deletechan);

        i = namedimage(display, s);
        if(i != nil){
            /* move it off-screen to hide it, since client is slow in letting it go */
            originwindow(i, i->r.min, view->r.max);
        }
        freeimage(i);
        free(s);
    }
}
@
% why freeimage here too? not enough in closewin?




\subsection{[[Deleted]] and [[Exited]]}


\t who send to that?
<<global winclosechan>>=
// chan<ref<Window>> (listener = winclosethread, sender = filsyswalk | filsysclunk )
Channel	*winclosechan; /* chan(Window*); */
@


<<[[main()]] communication channels creation>>=
winclosechan = chancreate(sizeof(Window*), 0);
@
<<[[main()]] threads creation>>=
threadcreate(winclosethread, nil, STACK);
@


<<function winclosethread>>=
/* thread to allow fsysproc to synchronize window closing with main proc */
void
winclosethread(void*)
{
    Window *w;

    threadsetname("winclosethread");

    for(;;){
        w = recvp(winclosechan);
        wclose(w);
    }
}
@




% winclosethread -> <>
<<function wclose>>=
bool
wclose(Window *w)
{
    int i;

    i = decref(w);
    if(i > 0)
        return false;

    if(i < 0)
        error("negative ref count");
    if(!w->deleted)
        wclosewin(w);
    wsendctlmesg(w, Exited, ZR, nil);
    return true;
}
@
% decref? but does one incref in new(), decref in winshell,
%  via wclose, then incref in?? xfidattach??


<<[[Wctlmesgkind]] cases>>=
Exited,
@

% Exited vs Deleted?
% First user send Deleted, to give a chance for window to do stuff
% then call wclosewin which send Exited


%?? button3menu -> wclose???() -> wclosewin() ; wsendctlmsg(Exited)

<<[[wctlmesg()]] cases>>=
case Exited:
    frclear(w, true);
    close(w->notefd);
    chanfree(w->mc.c);
    chanfree(w->ck);
    chanfree(w->cctl);
    chanfree(w->conswrite);
    chanfree(w->consread);
    chanfree(w->mouseread);
    chanfree(w->wctlread);
    free(w->raw);
    free(w->r);
    free(w->dir);
    free(w->label);
    free(w);
    break;
@







\subsection{Mouse action [[pointto()]]}

% wait = wait for release. In case of delete we wait,
%  but for move pointto() is only the first step so we don't
%  want a release here.

% delete(true) | move -> <>
<<function pointto>>=
Window*
pointto(bool wait)
{
    Window *w;

    menuing = true;
    riosetcursor(&sightcursor, true);

    while(mouse->buttons == 0)
        readmouse(mousectl);

    if(mouse->buttons == 4)
        w = wpointto(mouse->xy);
    else
        w = nil;

    if(wait){
        while(mouse->buttons){
            if(mouse->buttons!=4 && w != nil){	/* cancel */
                cornercursor(input, mouse->xy, false);
                w = nil;
            }
            readmouse(mousectl);
        }
        if(w != nil && wpointto(mouse->xy) != w)
            w = nil;
    }

    cornercursor(input, mouse->xy, false);
    moveto(mousectl, mouse->xy);	/* force cursor update; ugly */
    menuing = false;
    return w;
}
@
% dont understand this force cursor thing, nor the cancel

% 



\section{Window move}
% via menu, see also via border click

<<[[button3menu()]] cases>>=
case Move:
    move();
    break;
@

\subsection{[[move()]]}

<<function move>>=
void
move(void)
{
    Window *w;
    Image *i;
    Rectangle r;

    w = pointto(false);
    if(w == nil)
        return;
    i = drag(w, &r);
    if(i)
        wsendctlmesg(w, Moved, r, i);
    cornercursor(input, mouse->xy, true);
}
@
%pointto() changes the cursor
% pass false here, so does not wait for end of click

% see wctlmesg Moved|Reshaped case
% because Moved is a special case of Reshaped where same size.


\subsection{Mouse action [[drag()]]}

% assumes already has done a pointto
% move | mousethread -> <>
<<function drag>>=
Image*
drag(Window *w, Rectangle *rp)
{
    Image *i;
    Image *ni = nil;
    Point p, op, d, dm, om;
    Rectangle r;

    i = w->i;

    menuing = true;
    om = mouse->xy;
    riosetcursor(&boxcursor, true);

    dm = subpt(mouse->xy, w->screenr.min);
    d = subpt(i->r.max, i->r.min);
    op = subpt(mouse->xy, dm);

    drawborder(Rect(op.x, op.y, op.x+d.x, op.y+d.y), true);
    flushimage(display, true);

    while(mouse->buttons == 4){
        p = subpt(mouse->xy, dm);
        if(!eqpt(p, op)){
            // will move previously drawn rectangle thx to originwindow
            drawborder(Rect(p.x, p.y, p.x+d.x, p.y+d.y), true);
            flushimage(display, true);
            op = p;
        }
        readmouse(mousectl);
    }

    r = Rect(op.x, op.y, op.x+d.x, op.y+d.y);
    drawborder(r, false);

    cornercursor(w, mouse->xy, true);
    moveto(mousectl, mouse->xy);	/* force cursor update; ugly */
    menuing = false;

    flushimage(display, true);
    if(mouse->buttons == 0)
        ni=allocwindow(wscreen, r, Refbackup, DWhite);
    <<[[drag()]] sanity check mouse buttons and ni>>
    draw(ni, ni->r, i, nil, i->r.min);
    *rp = r;
    return ni;
}
@
%old: I rewrote a bit and move ni= outside the if

<<[[drag()]] sanity check mouse buttons and ni>>=
if(mouse->buttons!=0 || ni==nil){
    moveto(mousectl, om);
    while(mouse->buttons)
        readmouse(mousectl);
    *rp = Rect(0, 0, 0, 0);
    return nil;
}
@

% drawborder does delete previous image if there was one

% drag | bandsize -> <>
<<function drawborder>>=
void
drawborder(Rectangle r, bool show)
{
    static Image *b[4];
    int i;
    if(!show){
        for(i = 0; i < 4; i++){
            freeimage(b[i]);
            b[i] = nil;
        }
    }else{
        r = canonrect(r);
        drawedge(&b[0], Rect(r.min.x, r.min.y, r.min.x+Borderwidth, r.max.y));
        drawedge(&b[1], Rect(r.min.x+Borderwidth, r.min.y, r.max.x-Borderwidth, r.min.y+Borderwidth));
        drawedge(&b[2], Rect(r.max.x-Borderwidth, r.min.y, r.max.x, r.max.y));
        drawedge(&b[3], Rect(r.min.x+Borderwidth, r.max.y-Borderwidth, r.max.x-Borderwidth, r.max.y));
    }
}
@


% drawborder -> <>
<<function drawedge>>=
void
drawedge(Image **bp, Rectangle r)
{
    Image *b = *bp;
    if(b != nil && Dx(b->r) == Dx(r) && Dy(b->r) == Dy(r))
        originwindow(b, r.min, r.min);
    else{
        freeimage(b);
        *bp = allocwindow(wscreen, r, Refbackup, DRed);
    }
}
@
% can not use single rectangle, because then inside will not be
% transparent
% (hmm but do that a bit in sweep() no?)
\t originwindow works here now that I changed stuff in draw?

\section{Window resize}
% via menu, or via mouse on border directly

<<[[button3menu()]] cases>>=
case Reshape:
    resize();
    break;
@

\subsection{[[resize()]]}

<<function resize>>=
void
resize(void)
{
    Window *w;
    Image *i;

    w = pointto(true);
    if(w == nil)
        return;
    i = sweep();
    if(i)
        wsendctlmesg(w, Reshaped, i->r, i);
}
@
% very similar to move()

% use sweep() to define area.


% seen Moved Reshaped in section X.
% A Moved is actually a special case of Reshaped

<<[[wctlmesg()]] cases>>=
case Moved:
case Reshaped:
    if(w->deleted){
        freeimage(i);
        break;
    }
    w->screenr = r;
    strcpy(buf, w->name);
    wresize(w, i, m==Moved);
    w->wctlready = true;

    proccreate(deletetimeoutproc, estrdup(buf), 4096);

    if(Dx(r) > 0){
        if(w != input)
            wcurrent(w);
    }else if(w == input)
        wcurrent(nil);
    flushimage(display, true);
    break;
@






<<[[Window]] other fields>>=
bool	 	resized;
@
% why important to remember? for creating a resize
% even to client listening to /mnt/wsys/mouse
% a bit uglt
\t put in Resize event section?

<<function wresize>>=
void
wresize(Window *w, Image *i, bool move)
{
    Rectangle r, or;

    or = w->i->r;
    if(move || (Dx(or)==Dx(i->r) && Dy(or)==Dy(i->r)))
        draw(i, i->r, w->i, nil, w->i->r.min);
    freeimage(w->i);
    w->i = i;
    wsetname(w); // publish new window name by incrementing namecount
    w->mc.image = i;

    <<[[wresize()]] textual window updates>>

    wborder(w, Selborder);
    w->topped = ++topped;

    w->resized = true;
    w->mouse.counter++;
}
@
% mouse counter ??? comes with resize thing?
% yes, both case there is a new event in the queue to send
% if process listen to /dev/mouse, he will get the event
%  which will prompt it to redo a getwindow to read back
%  new /dev/winname
\t how this will handle graphical applications which are resized??
\t  ok set w->resized = true, but how force sending resize
\t  message to app? because incr counter?

\subsection{Mouse action [[bandsize()]]}

% with left or middle click, other way to resize.

% mousethread -> <>
<<function bandsize>>=
Image*
bandsize(Window *w)
{
    Image *i;
    Rectangle r, or;
    Point p, startp;
    int which, but;

    p = mouse->xy;
    but = mouse->buttons;
    which = whichcorner(w, p);
    p = cornerpt(w->screenr, p, which);
    wmovemouse(w, p);

    readmouse(mousectl);
    r = whichrect(w->screenr, p, which);
    drawborder(r, true);

    or = r;
    startp = p;
    
    while(mouse->buttons == but){
        p = onscreen(mouse->xy);
        r = whichrect(w->screenr, p, which);
        if(!eqrect(r, or) && goodrect(r)){
            drawborder(r, true);
            flushimage(display, true);
            or = r;
        }
        readmouse(mousectl);
    }

    p = mouse->xy;
    drawborder(or, false);
    flushimage(display, true);

    wsetcursor(w, true);
    <<[[bandsize()]] sanity check mouse buttons, rectanglr [[or]], point [[p]]>>
    i = allocwindow(wscreen, or, Refbackup, DWhite);
    <<[[bandsize()]] sanity check i>>
    border(i, r, Selborder, red, ZP);
    return i;
}
@


<<[[bandsize()]] sanity check mouse buttons, rectanglr [[or]], point [[p]]>>=
if(mouse->buttons!=0 || Dx(or)<100 || Dy(or)<3*font->height){
    while(mouse->buttons)
        readmouse(mousectl);
    return nil;
}
if(abs(p.x - startp.x) + abs(p.y - startp.y) <= 1)
    return nil;
@

<<[[bandsize()]] sanity check i>>=
if(i == nil)
    return nil;
@





<<function wmovemouse>>=
/*
 * Convert back to physical coordinates
 */
void
wmovemouse(Window *w, Point p)
{
    p.x += w->screenr.min.x - w->i->r.min.x;
    p.y += w->screenr.min.y - w->i->r.min.y;
    moveto(mousectl, p);
}
@

% bandsize -> <>
<<function whichrect>>=
Rectangle
whichrect(Rectangle r, Point p, int which)
{
    switch(which){
    case 0:	/* top left */
        r = Rect(p.x, p.y, r.max.x, r.max.y);
        break;
    case 2:	/* top right */
        r = Rect(r.min.x, p.y, p.x, r.max.y);
        break;
    case 6:	/* bottom left */
        r = Rect(p.x, r.min.y, r.max.x, p.y);
        break;
    case 8:	/* bottom right */
        r = Rect(r.min.x, r.min.y, p.x, p.y);
        break;
    case 1:	/* top edge */
        r = Rect(r.min.x, p.y, r.max.x, r.max.y);
        break;
    case 5:	/* right edge */
        r = Rect(r.min.x, r.min.y, p.x, r.max.y);
        break;
    case 7:	/* bottom edge */
        r = Rect(r.min.x, r.min.y, r.max.x, p.y);
        break;
    case 3:		/* left edge */
        r = Rect(p.x, r.min.y, r.max.x, r.max.y);
        break;
    }
    return canonrect(r);
}
@


% bandsize -> <>
<<function cornerpt>>=
Point
cornerpt(Rectangle r, Point p, int which)
{
    switch(which){
    case 0:	/* top left */
        p = Pt(r.min.x, r.min.y);
        break;
    case 2:	/* top right */
        p = Pt(r.max.x,r.min.y);
        break;
    case 6:	/* bottom left */
        p = Pt(r.min.x, r.max.y);
        break;
    case 8:	/* bottom right */
        p = Pt(r.max.x, r.max.y);
        break;
    case 1:	/* top edge */
        p = Pt(p.x,r.min.y);
        break;
    case 5:	/* right edge */
        p = Pt(r.max.x, p.y);
        break;
    case 7:	/* bottom edge */
        p = Pt(p.x, r.max.y);
        break;
    case 3:		/* left edge */
        p = Pt(r.min.x, p.y);
        break;
    }
    return p;
}
@



\section{Window hiding/exposing}
% via menu


<<[[button3menu()]] cases>>=
case Hide:
    hide();
    break;
@


\subsection{[[hide()]]}

<<function hide>>=
void
hide(void)
{
    Window *w;

    w = pointto(true);
    if(w == nil)
        return;
    whide(w);
}
@

\subsection{[[hiddden]]}


<<global hidden>>=
Window	*hidden[100];
@
% hidden windows

<<global nhidden>>=
int		nhidden;
@



% return -1, 0, 1, used in switch somewhere
<<function whide>>=
int
whide(Window *w)
{
    Image *i;
    int j;

    for(j=0; j<nhidden; j++)
        if(hidden[j] == w)	/* already hidden */
            return -1;

    i = allocimage(display, w->screenr, w->i->chan, false, DWhite);
    if(i){
        hidden[nhidden++] = w;
        wsendctlmesg(w, Reshaped, ZR, i);
        return 1;
    }
    return 0;
}
@
% allocimage is not allocwindow, and so it's in-memory image


% related = command line hidden

<<[[new()]] if hideit>>=
if(hideit){
    hidden[nhidden++] = w;
    w->screenr = ZR;
}
@

<<[[wclosewin()]] remove w from hidden>>=
// delete_list(w, hidden)
for(i=0; i<nhidden; i++)
    if(hidden[i] == w){
        --nhidden;
        memmove(hidden+i, hidden+i+1, (nhidden-i)*sizeof(hidden[0]));
        hidden[nhidden] = nil;
        break;
    }
@

\subsection{[[unhide()]]}


<<[[button3menu()]] menu3str adjustments with hidden windows>>=
for(i=0; i<nhidden; i++)
    menu3str[i+Hidden] = hidden[i]->label;
menu3str[i+Hidden] = nil;
@

<<[[button3menu()]] cases>>=
default:
    unhide(i);
    break;
@

<<function unhide>>=
void
unhide(int h)
{
    Window *w;

    h -= Hidden;
    w = hidden[h];
    if(w == nil)
        return;
    wunhide(h);
}
@

<<function wunhide>>=
int
wunhide(int h)
{
    Image *i;
    Window *w;

    w = hidden[h];
    i = allocwindow(wscreen, w->i->r, Refbackup, DWhite);
    if(i){
        --nhidden;
        memmove(hidden+h, hidden+h+1, (nhidden-h)*sizeof(Window*));
        wsendctlmesg(w, Reshaped, w->i->r, i);
        return 1;
    }
    return 0;
}
@
% back to allocwindow! Reshaped will make this image public again
% via wsetname






\chapter{Filesystem Server}
\label{chap:filesystem-server}

%trans:
% new -> ... -> winshell -> filsysmount
%    if(mount(fs->cfd, -1, "/mnt/wsys", MREPL, buf) < 0){
% big missing piece.

% mount is in kernel and does the right thing when the argument
% is a filedescriptor.

% Require Kernel.nw and Network.nw for this chapter. 
% I assume a lot.

% so then what happens?
% filsysproc is reading on fs->sfd, server side of the pipe

% readp9msg, then create or get a worker (Xfid), 
% set its field with the current p9 message, and then fcall
% for right type of message. Then each fcall may proceed,
% or call the worker to do more job.
% if job requires some processing, then return nil meaning someone needs
% to allocate a new worker because this file is currently
% being processed and its state is open (state of fid
% is in f parameter below).

% Saw fcall in core DS and filsysproc dispatcher.
% Saw also worker handler Xfid and Fid file state.


\section{Additional data structures}

\subsection{[[Qxxx]]}

% Saw before
%<<[[Fid]] other fields>>=
%Qid		qid;
%@

% Qid is defined in libc.h. See also Kernel.pdf
 

<<enum qid>>=
enum Qxxx
{
    Qdir,			/* /dev for this window */
    <<[[qid]] cases>>

    QMAX,
};
@


% window id + device enum id  -> final Qid
<<function QID>>=
#define	QID(winid,qxxx)	((winid<<8)|(qxxx))
@
% what about overflow? hope will not have too many windows then
%old: was w,q, but then confusing with q below

% Qid -> window id
<<function WIN>>=
#define	WIN(q)	((((ulong)(q).path)>>8) & 0xFFFFFF)
@

% qid -> dev
<<function FILE>>=
#define	FILE(q)	(((ulong)(q).path) & 0xFF)
@



\subsection{[[dirtab]]}

<<struct Dirtab>>=
struct Dirtab
{
    char	*name;
    // bitset<enum<QTxxx>>
    byte	type;
    // enum<Qxxx>
    uint	qid;
    uint	perm;
};
@
% rename DirEntry (or DirEntryShort) like I want to do in kernel

<<global dirtab>>=
Dirtab dirtab[]=
{
    { ".",		QTDIR,	Qdir,		0500|DMDIR },
    <<dirtab array elements>>
    { nil, }
};
@


<<[[Fid]] other fields>>=
Dirtab	*dir;
@
\t it's a DirEntry!
\t  rename field too? direntry

% so for instance attach will set qid to Qdir
% and dir to dirtable of root! 



\section{[[filsysrespond()]]}

%trans: before seeing attach/... client transmited request
% (Txxx), see utility function to answer to client (Rxxx).
% see docs/man/5/intro, +1 trick, Rerror, etc.

% ... -> <>  called from many Xfid threads, and some filsysxxx too
<<function filsysrespond>>=
Xfid*
filsysrespond(Filsys *fs, Xfid *x, Fcall *fc, char *err)
{
    int n;

    if(err){
        fc->type = Rerror;
        fc->ename = err;
    }else
        fc->type = x->type+1; // Reply type just after Transmit type

    fc->fid = x->fid;
    fc->tag = x->tag;

    if(x->buf == nil)
        x->buf = malloc(messagesize);
    n = convS2M(fc, x->buf, messagesize);
    <<[[filsysrespond()]] sanity check n>>

    if(write(fs->sfd, x->buf, n) != n)
        error("write error in respond");
    <<[[filsysrespond()]] dump Fcall t if debug>>
    free(x->buf);
    x->buf = nil;
    return x;
}
@
% but write on sfd goes where?
% and what if multiple things write on it at the same time?
%  filsysproc and any xfidctl thread can potentially call filsysrespond
\l could rename fc to r? for reply? but then confusing with rectangle

<<[[filsysrespond()]] sanity check n>>=
if(n <= 0)
    error("convert error in convS2M");
@


\section{Attach}

\subsection{[[filsysattach()]]}

\t does not use first argument, so remove it from fcall sig no?
\t  anyway it's in the Xfid
<<function filsysattach>>=
static
Xfid*
filsysattach(Filsys *, Xfid *x, Fid *f)
{
    <<[[filsysattach()]] locals>>

    <<[[filsysattach()]] sanity check same user>>

    f->busy = true;
    f->open = false;

    f->qid.path = Qdir;
    f->qid.type = QTDIR;
    f->qid.vers = 0;
    f->dir = dirtab; // entry for "."

    f->nrpart = 0;

    sendp(x->c, xfidattach);
    return nil;
}
@


% return nil, because worker has a job to do asynchronously so filsysproc
% need allocate a new worker for next request.
% once finished this worker will go back in xfidfree.


<<[[filsysattach()]] locals>>=
Fcall fc;
@
%old: was called t, we will see such a local often

<<[[filsysattach()]] sanity check same user>>=
if(strcmp(x->uname, x->fs->user) != 0)
    return filsysrespond(x->fs, x, &fc, Eperm);
@

% see filsysrespond later, but write back on pipe an answer
% to client using x->buf space.

\subsection{[[xfidattach()]]}

% filsysattach !-> <>
<<function xfidattach>>=
void
xfidattach(Xfid *x)
{
    Fcall fc;
    int id;
    Window *w = nil;
    bool newlymade = false;
    <<[[xfidattach()]] other locals>>

    fc.qid = x->f->qid;
    qlock(&all);

    <<[[xfidattach()]] if mount "new ...">>
    else{
        // mount(fs->cfd, ..., "/mnt/wsys", ..., "2"), winid
        id = atoi(x->aname);
        w = wlookid(id);
    }

    x->f->w = w;
    <<[[xfidattach()]] sanity check w>>
    if(!newlymade)	/* counteract dec() in winshell() */
        incref(w);
    qunlock(&all);

    filsysrespond(x->fs, x, &fc, nil);
}
@

%dead: old syntax
%    if(x->aname[0] == 'N'){	/* N 100,100, 200, 200 - old syntax */
%        n = x->aname+1;
%        pid = strtoul(n, &n, 0);
%        if(*n == ',')
%            n++;
%        r.min.x = strtoul(n, &n, 0);
%        if(*n == ',')
%            n++;
%        r.min.y = strtoul(n, &n, 0);
%        if(*n == ',')
%            n++;
%        r.max.x = strtoul(n, &n, 0);
%        if(*n == ',')
%            n++;
%        r.max.y = strtoul(n, &n, 0);

<<function wlookid>>=
Window*
wlookid(int id)
{
    int i;

    for(i=0; i<nwindow; i++)
        if(windows[i]->id == id)
            return windows[i];
    return nil;
}
@
% need to do that only for attach. Further fid creation
% will come from walk and can copy Fid.w field

% so get back here from mount()!
% pass window id, and now this attach thing is connected
% to the right window


<<[[xfidattach()]] sanity check w>>=
if(w == nil){
    qunlock(&all);
    x->f->busy = false;
    filsysrespond(x->fs, x, &fc, err);
    return;
}
@

\section{Open}

\subsection{[[filsysopen()]]}

<<function filsysopen>>=
static
Xfid*
filsysopen(Filsys *fs, Xfid *x, Fid *f)
{
    Fcall fc;
    int m;

    <<[[filsysopen()]] sanity check mode>>
        
    sendp(x->c, xfidopen);
    return nil;

    Deny:
    return filsysrespond(fs, x, &fc, Eperm);
}
@

% remember that x->mode is really x->Fcall.mode of union

<<[[filsysopen()]] sanity check mode>>=
/* can't truncate anything, so just disregard */
x->mode &= ~(OTRUNC|OCEXEC);
/* can't execute or remove anything */
if(x->mode==OEXEC || (x->mode&ORCLOSE))
    goto Deny;

switch(x->mode){
case OREAD:
    m = 0400;
    break;
case OWRITE:
    m = 0200;
    break;
case ORDWR:
    m = 0600;
    break;
default:
    goto Deny;
}
if(((f->dir->perm & ~(DMDIR|DMAPPEND)) & m) != m)
    goto Deny;
@
% look for 

\subsection{[[xfidopen()]]}

% how sure that have a x->f->w?  because cant open if not attach?
<<function xfidopen>>=
void
xfidopen(Xfid *x)
{
    Fcall fc;
    Window *w;

    w = x->f->w;
    <<[[xfidxxx()]] respond error if window was deleted>>
    switch(FILE(x->f->qid)){
    <<[[xfidopen()]] cases>>
    }

    x->f->open = true;
    x->f->mode = x->mode;

    fc.qid = x->f->qid;
    fc.iounit = messagesize-IOHDRSZ;
    filsysrespond(x->fs, x, &fc, nil);
}
@

<<[[xfidxxx()]] respond error if window was deleted>>=
if(w->deleted){
    filsysrespond(x->fs, x, &fc, Edeleted);
    return;
}
@

\section{Clunk/Close}

\subsection{[[filsysclunk()]]}

<<function filsysclunk>>=
static
Xfid*
filsysclunk(Filsys *fs, Xfid *x, Fid *f)
{
    Fcall fc;

    if(f->open){
        f->busy = false;
        f->open = false;
        sendp(x->c, xfidclose);
        return nil;
    }
    // else
    if(f->w)
        sendp(winclosechan, f->w);
    f->busy = false;
    f->open = false;
    return filsysrespond(fs, x, &fc, nil);
}
@

% winclosechan ultimately call wclose which removes a reference
% to the window, so looks similar to xfidclose ...
% why not call wclose directly? to not block?

\subsection{[[xfidclose()]]}


<<function xfidclose>>=
void
xfidclose(Xfid *x)
{
    Fcall fc;
    Window *w;
    <<[[xfidclose()]] other locals>>

    w = x->f->w;
    switch(FILE(x->f->qid)){
    <<[[xfidclose()]] cases>>
    }
    wclose(w);
    filsysrespond(x->fs, x, &fc, nil);
}
@
% wclose(w)! remove one reference



\section{Read}

\subsection{[[filsysread()]]}


<<function filsysread>>=
static
Xfid*
filsysread(Filsys *fs, Xfid *x, Fid *f)
{
    int o, e;
    uint clock;
    byte *b;
    int n;
    Fcall fc;
    <<[[filsysread()]] other locals>>

    if(!(f->qid.type & QTDIR)){
        sendp(x->c, xfidread);
        return nil;
    }

    // else, a directory

    o = x->offset;
    e = x->offset + x->count;
    clock = getclock();
    b = malloc(messagesize-IOHDRSZ);	/* avoid memset of emalloc */
    <<[[filsysread()]] sanity check b>>

    n = 0;
    switch(FILE(f->qid)){
    <<[[filsysread()]] cases>>
    }

    fc.data = (char*)b;
    fc.count = n;
    filsysrespond(fs, x, &fc, nil);
    free(b);
    return x;
}
@
% can reuse x, request processed


<<[[filsysread()]] sanity check b>>=
if(b == nil)
    return filsysrespond(fs, x, &fc, "out of memory");
@

\subsection{[[xfidread()]]}

<<function xfidread>>=
void
xfidread(Xfid *x)
{
    Window *w;
    uint qid;
    int off, cnt;
    Fcall fc;
    <<[[xfidread()]] other locals>>
    
    w = x->f->w;
    <<[[xfidxxx()]] respond error if window was deleted>>
    qid = FILE(x->f->qid);
    off = x->offset;
    cnt = x->count;

    switch(qid){
    <<[[xfidread()]] cases>>
    default:
        fprint(STDERR, "unknown qid %d in read\n", qid);
        sprint(buf, "unknown qid in read");
        filsysrespond(x->fs, x, &fc, buf);
        break;
        }
}
@

% off, cnt, very important.
% see read(2) API?

\section{Write}

\subsection{[[filsyswrite()]]}

<<function filsyswrite>>=
static
Xfid*
filsyswrite(Filsys*, Xfid *x, Fid*)
{
    sendp(x->c, xfidwrite);
    return nil;
}
@

\subsection{[[xfidwrite()]]}


<<function xfidwrite>>=
void
xfidwrite(Xfid *x)
{
    Fcall fc;
    Window *w;
    uint qid;
    int off, cnt;
    char buf[256];
    <<[[xfidwrite()]] other locals>>
    
    w = x->f->w;
    <<[[xfidxxx()]] respond error if window was deleted>>
    qid = FILE(x->f->qid);
    cnt = x->count;
    off = x->offset;
    x->data[cnt] = 0;

    switch(qid){
    <<[[xfidwrite()]] cases>>
    default:
        fprint(STDERR, buf, "unknown qid %d in write\n", qid);
        sprint(buf, "unknown qid in write");
        filsysrespond(x->fs, x, &fc, buf);
        return;
    }

    fc.count = cnt;
    filsysrespond(x->fs, x, &fc, nil);
}
@




\section{Stats}

\subsection{[[filsysstat()]]}

<<function filsysstat>>=
static
Xfid*
filsysstat(Filsys *fs, Xfid *x, Fid *f)
{
    Fcall fc;

    fc.stat = emalloc(messagesize-IOHDRSZ);
    fc.nstat = dostat(fs, WIN(x->f->qid), f->dir, fc.stat, messagesize-IOHDRSZ, getclock());
    x = filsysrespond(fs, x, &fc, nil);
    free(fc.stat);
    return x;
}
@

<<function dostat>>=
static
int
dostat(Filsys *fs, int id, Dirtab *dir, uchar *buf, int nbuf, uint clock)
{
    Dir d;

    d.qid.path = QID(id, dir->qid);
    if(dir->qid == Qsnarf)
        d.qid.vers = snarfversion;
    else
        d.qid.vers = 0;
    d.qid.type = dir->type;
    d.mode = dir->perm;
    d.length = 0;	/* would be nice to do better */
    d.name = dir->name;
    d.uid = fs->user;
    d.gid = fs->user;
    d.muid = fs->user;
    d.atime = clock;
    d.mtime = clock;

    return convD2M(&d, buf, nbuf);
}
@




\section{Walk TODO}

\subsection{[[filsyswalk()]]}

% docs/man/5/walk

% One message for full path. So efficient network wise,
% no need back and forth for each path elements.
% But that means filsyswalk need to redo part of the job
% of the kernel in namei().

% complicated ...

<<global all>>=
QLock	all;			/* BUG */
@
% I think it's mainly for wsys/ shared access
% it protects access to windows and nwindow


\t todo, hard to understand
<<function filsyswalk>>=
static
Xfid*
filsyswalk(Filsys *fs, Xfid *x, Fid *f)
{
    Fcall fc;
    Fid *nf;
    int i, id;
    uchar type;
    ulong path;
    Dirtab *d, *dir;
    Window *w;
    char *err;
    Qid qid;

    if(f->open)
        return filsysrespond(fs, x, &fc, "walk of open file");
    nf = nil;
    if(x->fid  != x->newfid){
        /* BUG: check exists */
        nf = newfid(fs, x->newfid);
        if(nf->busy)
            return filsysrespond(fs, x, &fc, "clone to busy fid");
        nf->busy = true;
        nf->open = false;
        nf->dir = f->dir;
        nf->qid = f->qid;
        nf->w = f->w;
        incref(f->w);
        nf->nrpart = 0;	/* not open, so must be zero */
        f = nf;	/* walk f */
    }

    fc.nwqid = 0;
    err = nil;

    /* update f->qid, f->dir only if walk completes */
    qid = f->qid;
    dir = f->dir;

    if(x->nwname > 0){
        for(i=0; i<x->nwname; i++){
            if((qid.type & QTDIR) == 0){
                err = Enotdir;
                break;
            }
            if(strcmp(x->wname[i], "..") == 0){
                type = QTDIR;
                path = Qdir;
                dir = dirtab;
                if(FILE(qid) == Qwsysdir)
                    path = Qwsys;
                id = 0;
    Accept:
                if(i == MAXWELEM){
                    err = "name too long";
                    break;
                }
                qid.type = type;
                qid.vers = 0;
                qid.path = QID(id, path);
                fc.wqid[fc.nwqid++] = qid;
                continue;
            }

            if(qid.path == Qwsys){
                /* is it a numeric name? */
                if(!numeric(x->wname[i]))
                    break;
                /* yes: it's a directory */
                id = atoi(x->wname[i]);
                qlock(&all);
                w = wlookid(id);
                if(w == nil){
                    qunlock(&all);
                    break;
                }
                path = Qwsysdir;
                type = QTDIR;
                qunlock(&all);
                incref(w);
                sendp(winclosechan, f->w);
                f->w = w;
                dir = dirtab;
                goto Accept;
            }
        
            if(snarffd>=0 && strcmp(x->wname[i], "snarf")==0)
                break;	/* don't serve /dev/snarf if it's provided in the environment */
            id = WIN(f->qid);
            d = dirtab;
            d++;	/* skip '.' */
            for(; d->name; d++)
                if(strcmp(x->wname[i], d->name) == 0){
                    path = d->qid;
                    type = d->type;
                    dir = d;
                    goto Accept;
                }

            break;	/* file not found */
        }

        if(i==0 && err==nil)
            err = Eexist;
    }

    if(err!=nil || fc.nwqid<x->nwname){
        if(nf){
            if(nf->w)
                sendp(winclosechan, nf->w);
            nf->open = false;
            nf->busy = false;
        }
    }else if(fc.nwqid == x->nwname){
        f->dir = dir;
        f->qid = qid;
    }

    return filsysrespond(fs, x, &fc, err);
}
@

<<function numeric>>=
static
int
numeric(char *s)
{
    for(; *s!='\0'; s++)
        if(*s<'0' || '9'<*s)
            return 0;
    return 1;
}
@

%\section{Flush}
% adv topics now

\section{Forbidden operations}

<<[[fcall]] other methods>>=
[Tcreate]  = filsyscreate,
[Tremove]  = filsysremove,
[Twstat]   = filsyswstat,
@


%\subsection{Create, remove}

<<function filsyscreate>>=
static
Xfid*
filsyscreate(Filsys *fs, Xfid *x, Fid*)
{
    Fcall fc;

    return filsysrespond(fs, x, &fc, Eperm);
}
@

<<function filsysremove>>=
static
Xfid*
filsysremove(Filsys *fs, Xfid *x, Fid*)
{
    Fcall fc;

    return filsysrespond(fs, x, &fc, Eperm);
}
@

<<function filsyswstat>>=
static
Xfid*
filsyswstat(Filsys *fs, Xfid *x, Fid*)
{
    Fcall fc;

    return filsysrespond(fs, x, &fc, Eperm);
}
@




\section{Misc}
% adv topics

<<[[fcall]] other methods>>=
[Tversion] = filsysversion,
[Tauth]    = filsysauth,
@

<<function filsysversion>>=
static
Xfid*
filsysversion(Filsys *fs, Xfid *x, Fid*)
{
    Fcall fc;

    if(!firstmessage)
        return filsysrespond(x->fs, x, &fc, "version request not first message");
    if(x->msize < 256)
        return filsysrespond(x->fs, x, &fc, "version: message size too small");

    messagesize = x->msize;

    fc.msize = messagesize;
    if(strncmp(x->version, "9P2000", 6) != 0)
        return filsysrespond(x->fs, x, &fc, "unrecognized 9P version");
    // else
    fc.version = "9P2000";
    return filsysrespond(fs, x, &fc, nil);
}
@
% why 256? 

<<function filsysauth>>=
static
Xfid*
filsysauth(Filsys *fs, Xfid *x, Fid*)
{
    Fcall fc;

    return filsysrespond(fs, x, &fc, "rio: authentication not required");
}
@







\chapter{[[/mnt/wsys/...]] Virtual Devices}
\label{chap:virtual-devices}

% remember that /mnt/wsys is unioned in /dev/ so access to /dev/cons
% in client is really /mnt/wsys/cons handled by rio.

\section{[[/mnt/wsys/mouse]]}
\n simpler than cons

% more a graphical window device.

<<[[qid]] cases>>=
Qmouse,
@
<<dirtab array elements>>=
{ "mouse",		QTFILE,	Qmouse,		0600 },
@

% xfidopen for Qmouse is now discussed in Graphical windows chapter.


\subsection{Reading part1}
% and window.mouseread

% So if client reads /dev/mouse (after it has been opened of course),
% then we wait for mouse events to come to us by listening to mouseread!
% The winctl itself listen for mouse events on w->mc.c from mousethread


<<[[Window]] other fields>>=
// chan<Mousereadmesg> (listener = xfidread(Qmouse), sender = winctl)
Channel		*mouseread;	/* chan(Mousereadmesg) */
@
<<[[wmk()]] channels creation>>=
w->mouseread =  chancreate(sizeof(Mousereadmesg), 0);
@

% why does not send Mouse directly? maybe because mouse state
% at sending time is not good anymore at receiving time?
% No, because sender send only when he has something he is ready
% to send and it's queue anyway. Maybe because of the flushing?
% because then on the other channel there is no alt with a flush
% message? but could ...

<<struct Mousereadmesg>>=
struct Mousereadmesg
{
    // chan<Mouse> (listener = xfidread(Qmouse), sender = winctl)
    Channel	*cm;		/* chan(Mouse) */
};
@
% passing a channel in a Channel!
% could be a Window field too no? first know if someone wants
% a mouseread, then write on other channel the mouse

<<enum _anon_ (windows/rio/xfid.c)4>>=
enum { MRdata, MRflush, NMR };
@
% MRflush and flush stuff in adv topics

<<[[xfidread()]] other locals>>=
Alt alts[NCR+1];
Mousereadmesg mrm;
Mouse ms;
int n, c;
@
% c local?
% NCR+1 should be enough for all alts (which looks like have always 2 elems,
% 1 regular and one XXflush)

<<[[xfidread()]] cases>>=
case Qmouse:
    <<[[xfidxxx()]] set flushtag>>

    alts[MRdata].c = w->mouseread;
    alts[MRdata].v = &mrm;
    alts[MRdata].op = CHANRCV;
    <<[[xfidread()]] when Qmouse, set alts for flush>>
    alts[NMR].op = CHANEND;

    switch(alt(alts)){
    case MRdata:
        break;
    <<[[xfidread()]] when Qmouse, switch alt flush case>>
    }
    /* received data */
    <<[[xfidxxx()]] unset flushtag>>
    <<[[xfidread()]] when Qmouse, if flushing>>

    qlock(&x->active);
    recv(mrm.cm, &ms);
    c = 'm';
    <<[[xfidread()]] when Qmouse, adjust c for resize message if resized>>
    n = sprint(buf, "%c%11d %11d %11d %11ld ", c, ms.xy.x, ms.xy.y, ms.buttons, ms.msec);
    w->resized = false;

    fc.data = buf;
    fc.count = min(n, cnt);
    filsysrespond(x->fs, x, &fc, nil);
    qunlock(&x->active);
    break;
@
\l hide even more switch and code after? put alt(alts) how of it?

\subsection{Writing}

% can move the mouse programatically :)
% but it needs to have the focus apparently and be visible

<<[[xfidwrite()]] other locals>>=
char *p;
Point pt;
@

<<[[xfidwrite()]] cases>>=
case Qmouse:
    if(w!=input || Dx(w->screenr)<=0)
        break;
    if(x->data[0] != 'm'){
        filsysrespond(x->fs, x, &fc, Ebadmouse);
        return;
    }
    p = nil;
    pt.x = strtoul(x->data+1, &p, 0);
    if(p == nil){
        filsysrespond(x->fs, x, &fc, Eshort);
        return;
    }
    pt.y = strtoul(p, nil, 0);
    if(w==input && wpointto(mouse->xy)==w)
        wsendctlmesg(w, Movemouse, Rpt(pt, pt), nil);
    break;
@



<<[[Wctlmesgkind]] cases>>=
Movemouse,
@
<<[[wctlmesg()]] cases>>=
case Movemouse:
    if(sweeping || !ptinrect(r.min, w->i->r))
        break;
    wmovemouse(w, r.min);
    break;
@

\section{[[/mnt/wsys/cons]]}

% quite complicated

<<[[qid]] cases>>=
Qcons,
@
<<dirtab array elements>>=
{ "cons",		QTFILE,	Qcons,		0600 },
@


\subsection{Reading part1}

% So if client reads /dev/cons,
% then we wait for key event to come to us by listening to consread!
% The winctl itself listen for key events on w->ck from keyboardthread

<<[[Window]] other fields>>=
// chan<Consreadmesg> (listener = xfidread(Qcons), sender = winctl)
Channel		*consread;	/* chan(Consreadmesg) */
@
<<[[wmk()]] channels creation>>=
w->consread =  chancreate(sizeof(Consreadmesg), 0);
@

<<struct Consreadmesg>>=
struct Consreadmesg
{
    // chan<ref<array<Rune>> (listener = winctl, sender = xfidread(Qcons))
    Channel	*c1;		/* chan(tuple(char*, int) == Stringpair) */
    // chan<ref<array<Rune>> (listener = xdidread(Qcons), sender = winctl)
    Channel	*c2;		/* chan(tuple(char*, int) == Stringpair) */
};
@
% pass channels inside channel ... subtle
% why not just one? because need first pass a buffer allocated
%  by xfidread who knows how much he wants.
% file interface is byte, but runes are multi bytes, so need
%  adjust, maybe send partial rune, etc.
% Cant just use one channel in both direction? channel = unidirectional pipe?

% note that channels are in Runes, but OS interface is in bytes
% so we will see adjustments because of that.

<<struct Stringpair>>=
struct Stringpair	/* rune and nrune or byte and nbyte */
{
    void	*s;
    int		ns;
};
@
\t where this is used to send bytes on a channel?


<<enum _anon_ (windows/rio/xfid.c)3>>=
enum { CRdata, CRflush, NCR };
@

<<[[xfidread()]] other locals>>=
Consreadmesg crm;
Channel *c1, *c2;	/* chan (tuple(char*, int)) */
char *t;
Stringpair pair;
@

<<[[xfidread()]] cases>>=
case Qcons:
    <<[[xfidxxx()]] set flushtag>>

    alts[CRdata].c = w->consread;
    alts[CRdata].v = &crm;
    alts[CRdata].op = CHANRCV;
    <<[[xfidread()]] when Qcons, set alts for flush>>
    alts[NCR].op = CHANEND;

    switch(alt(alts)){
    case CRdata:
        break;
    <<[[xfidread()]] when Qcons, switch alt flush case>>
    }
    /* received data */
    <<[[xfidxxx()]] unset flushtag>>

    c1 = crm.c1;
    c2 = crm.c2;
    t = malloc(cnt+UTFmax+1);	/* room to unpack partial rune plus */
    pair.s = t;
    pair.ns = cnt;
    send(c1, &pair);

    <<[[xfidread()]] when Qcons, if flushing>>

    qlock(&x->active);
    recv(c2, &pair);
    fc.data = pair.s;
    fc.count = pair.ns;
    filsysrespond(x->fs, x, &fc, nil);
    free(t);
    qunlock(&x->active);
    break;
@
%bug: was alts.[NMR] = ... above, but it should be NCR

% here s and ns are byte and nbyte

\subsection{Writing part1}

% So if client writes to /dev/cons, he wants to output strings
% on the terminal,
% then we wait for conswrite to get the go from winctl.

<<[[Window]] other fields>>=
// chan<Conswritemesg> (listener = xfidwrite(Qcons), sender = winctl)
Channel		*conswrite;	/* chan(Conswritemesg) */
@
<<[[wmk()]] channels creation>>=
w->conswrite = chancreate(sizeof(Conswritemesg), 0);
@

<<struct Conswritemesg>>=
struct Conswritemesg
{
    // chan<ref<array<Rune>> (listener = winctl, sender = xfidwrite(Qcons))
    Channel	*cw;		/* chan(Stringpair) */
};
@


<<enum _anon_ (windows/rio/xfid.c)2>>=
enum { CWdata, CWflush, NCW };
@


<<[[xfidwrite()]] other locals>>=
Rune *r;
int nr; // nb runes
int nb; // nb bytes
@

<<[[xfidwrite()]] other locals>>=
Alt alts[NCW+1];
Conswritemesg cwm;
Stringpair pair;
@
%NCW+1 enough for all xfidwrite cases

% see cvttorunes function in appendix

<<[[xfidwrite()]] cases>>=
case Qcons:

    <<[[xfidwrite()]] when Qcons, look for previous partial rune bytes>>
    r = runemalloc(cnt);
    cvttorunes(x->data, cnt-UTFmax, r, &nb, &nr, nil);
    <<[[xfidwrite()]] when Qcons, look if more full runes>>
    <<[[xfidwrite()]] when Qcons, store remaining partial rune bytes>>

    <<[[xfidxxx()]] set flushtag>>

    alts[CWdata].c = w->conswrite;
    alts[CWdata].v = &cwm;
    alts[CWdata].op = CHANRCV;
    <<[[xfidwrite()]] when Qcons, set alts for flush>>
    alts[NCW].op = CHANEND;

    switch(alt(alts)){
    case CWdata:
        break;
    <<[[xfidwrite()]] when Qcons, switch alt flush case>>
    }

    /* received data */
    <<[[xfidxxx()]] unset flushtag>>
    <<[[xfidwrite()]] when Qcons, if flushing>>

    qlock(&x->active);
    pair.s = r;
    pair.ns = nr;
    send(cwm.cw, &pair);
    fc.count = x->count;
    filsysrespond(x->fs, x, &fc, nil);
    qunlock(&x->active);
    return;
@

% this time pass full rune, not byte


% we have stuff to write! stuff to write in the console,
% but this time it must be Rune! cant pass half rune to winctl
% as it will not be able to display it. So need
% to remember in Fid partial runes.

<<[[Fid]] other fields>>=
uchar	rpart[UTFmax];
int		nrpart;
@
% rune partial


<<[[xfidwrite()]] when Qcons, store remaining partial rune bytes>>=
// assert(cnt-nb < UTFMAX);
if(nb < cnt){
    memmove(x->f->rpart, x->data + nb, cnt-nb);
    x->f->nrpart = cnt-nb;
}
@
% didn't send complete rune, need store those bytes for next run
% of xfidwrite to have complete rune to relay

<<[[xfidwrite()]] when Qcons, look for previous partial rune bytes>>=
nr = x->f->nrpart;
if(nr > 0){
    memmove(x->data+nr, x->data, cnt);	/* there's room: see malloc in filsysproc */
    memmove(x->data, x->f->rpart, nr);
    cnt += nr;
    x->f->nrpart = 0;
}
@


<<[[xfidwrite()]] other locals>>=
int c;
@

% did cnt-UTFMAX, but maybe still full rune in UTFMAX, can have
% 4 simple runes
<<[[xfidwrite()]] when Qcons, look if more full runes>>=
/* approach end of buffer */
while(fullrune(x->data+nb, cnt-nb)){
    c = nb;
    nb += chartorune(&r[nr], x->data+c);
    if(r[nr])
        nr++;
}
@
% see also cvttorunes



\section{[[/mnt/wsys/consctl]]}

<<[[qid]] cases>>=
Qconsctl,
@
<<dirtab array elements>>=
{ "consctl",	QTFILE,	Qconsctl,	0200 },
@


<<[[Window]] other fields>>=
bool	ctlopen;
@
% exclusive access to /dev/consctl (why?)
%old: bool_byte

<<[[xfidopen()]] cases>>=
case Qconsctl:
    if(w->ctlopen){
        filsysrespond(x->fs, x, &fc, Einuse);
        return;
    }
    w->ctlopen = true;
    break;
@


<<[[xfidclose()]] cases>>=
case Qconsctl:
    <<[[xfidclose()]] Qconsctl case, if rawing>>
    <<[[xfidclose()]] Qconsctl case, if holding>>
    w->ctlopen = false;
    break;
@

<<[[xfidwrite()]] cases>>=
case Qconsctl:
    <<[[xfidwrite()]] Qconsctl case>>
    // else
    filsysrespond(x->fs, x, &fc, "unknown control message");
    return;
@
% will see later writing on consctl, why we need it

\section{[[/mnt/wsys/cursor]]}

<<[[qid]] cases>>=
Qcursor,
@
<<dirtab array elements>>=
{ "cursor",		QTFILE,	Qcursor,	0600 },
@

% seen Window.cursorp before

<<[[xfidclose()]] cases>>=
case Qcursor:
    w->cursorp = nil;
    wsetcursor(w, false);
    break;
@
% will put back default cursor?

<<[[xfidread()]] cases>>=
case Qcursor:
    filsysrespond(x->fs, x, &fc, "cursor read not implemented");
    break;
@

<<[[xfidwrite()]] cases>>=
case Qcursor:
    if(cnt < 2*4+2*2*16)
        w->cursorp = nil;
    else{
        w->cursor.offset.x = BGLONG(x->data+0*4);
        w->cursor.offset.y = BGLONG(x->data+1*4);
        memmove(w->cursor.clr, x->data+2*4, 2*2*16);
        w->cursorp = &w->cursor;
    }
    wsetcursor(w, !sweeping);
    break;
@
% does not adjust cnt? off?

\section{[[/dev/draw/]] and [[/mnt/wsys/winname]]}

% actually this one in rio is not demultiplexed!
% It's not a virtual device.
% so more efficient.
% Done by the namedimage thing and /dev/winname

% security issue? can pass wrong screen id to draw operation?
% anyway, anybody can access the full screen in display->image, hmm

<<[[qid]] cases>>=
Qwinname,
@
<<dirtab array elements>>=
{ "winname",	QTFILE,	Qwinname,	0400 },
@

<<[[xfidread()]] cases>>=
case Qwinname:
    n = strlen(w->name);
    if(n == 0){
        filsysrespond(x->fs, x, &fc, "window has no name");
        break;
    }
    t = estrdup(w->name);
    goto Text;
@

% very useful! basis for initdraw and gengetwindow!!

% see goto Text later


%alt: could pass by environment variable? hmm but then
% external process not children of rio who wants to connect?
% will use mount anyway, and env var is anyway a fileserver in plan9
% so simpler to use /mnt/wsys for that too







\chapter{Graphical Windows}
\label{chap:graphical-windows}

% Graphical windows use /dev/draw (and /mnt/wsys/winname), /mnt/wsys/mouse.
% They do not write in /mnt/wsys/cons (instead they use 
%  stringxxx API from draw.h)
% they care optionally about /mnt/wsys/consctl and /mnt/wys/cons
%  for reading from the keyboard in "raw" mode.

\section{Graphical window setup}

% We say setup cos not really creation, since most of the time create first
% textual window and then setup things to become a graphical window
% (we will see later a way to create directly graphical window
%  with  /srv/rio.user.pid)

\subsection{[[initdraw()]]}

% regular graphical apps calls initdraw() in Graphics.nw.
% connect to /dev/draw and /mnt/wys/winname to get window to draw into.
% See Graphics.nw

\subsection{[[initmouse()]], mouse open mode}

% graphical apps calls usually also initmouse() which open /mnt/wys/mouse.

% direct access to mouse events, no interpretation like cut/copy/paste
% menu as we will see in Section X.

% seen mouseopen attribute in core DS, quite important bool,
%  used by mousethread a lot to do different things
%bool mouseopen;

<<[[xfidopen()]] cases>>=
case Qmouse:
    if(w->mouseopen){
        filsysrespond(x->fs, x, &fc, Einuse);
        return;
    }
    w->mouseopen = true;

    /*
     * Reshaped: there's a race if the appl. opens the
     * window, is resized, and then opens the mouse,
     * but that's rare.  The alternative is to generate
     * a resized event every time a new program starts
     * up in a window that has been resized since the
     * dawn of time.  We choose the lesser evil.
     */
    w->resized = false;
    break;
@

% remember than xfidxxx are executed by xfid threads,
% and because of thread model of plan9, no race between
% winctl and xfid threads so safe to update the w fields!


<<[[xfidclose()]] cases>>=
case Qmouse:
    w->mouseopen = false;

    w->resized = false;
    if(w->i != nil)
        wsendctlmesg(w, Refresh, w->i->r, nil);
    break;
@
% why Refresh ? when close the mouse?
% put Refresh here?




\subsection{[[initkeyboard()]], keyboard raw mode}

% not necessarily tied to graphical app, but strongly correlated.
% again, initkeyboard() in Graphics.nw.

% direct access to keyboard event, no interpretation of special navigation 
% key, buffered input, etc (actually have navigation key if mouse not opened
% even if raw mode)

% actually first thing initkeyboard does is to write
% rawon on /dev/consctl, see Graphics.ns

<<[[Window]] config fields>>=
bool	rawing;
@
%old: bool_byte
% actually abused as an int in if(w->rawing++ == 0) as one can write
% multiple rawon message on the consctl


<<[[xfidwrite()]] Qconsctl case>>=
if(strncmp(x->data, "rawon", 5)==0){
    <<[[xfidwrite()]] Qconsctl case, if rawon message and holding mode>>
    if(w->rawing++ == 0)
        wsendctlmesg(w, Rawon, ZR, nil);
    break;
}
if(strncmp(x->data, "rawoff", 6)==0 && w->rawing){
    if(--w->rawing == 0)
        wsendctlmesg(w, Rawoff, ZR, nil);
    break;
}
@


<<[[xfidclose()]] Qconsctl case, if rawing>>=
if(w->rawing){
    w->rawing = false;
    wsendctlmesg(w, Rawoff, ZR, nil);
}
@

<<[[Wctlmesgkind]] cases>>=
Rawon,
Rawoff,
@

<<[[wctlmesg()]] cases>>=
case Rawon:
    // already setup w->rawing in xfidwrite, nothing else todo
    break;
case Rawoff:
    <<[[wctlmesg()]] break if window was deleted>>
    <<[[wctlmesg()]] When Rawoff, process raw keys in non rawing mode>>
    break;
@



\section{Mouse events}

%alt: special APIs for graphical client to access mouse? that
% request directly to window manager?
% but then ugly? here transparent whether app run under rio or not!
% always use simply /dev/mouse!


\subsection{Mouse state queue}

<<[[Window]] mouse fields>>=
Mouseinfo	mouse;
@

<<struct Mouseinfo>>=
struct Mouseinfo
{
    Mousestate	queue[16];

    // consumer
    int	ri;	/* read index into queue */
    // producer
    int	wi;	/* write index */

    bool	qfull;/* filled the queue; no more recording until client comes back */	

    ulong	counter;	/* serial no. of last mouse event we received */
    ulong	lastcounter;/* serial no. of last mouse event sent to client */

    int	lastb;	/* last button state we received */

};	
@
%old: was uchar for qfull

\l need counter thing? not enough the ri != wi?
\l  or is it because of resize where increment counter without
\l  producing a thing in the queue?

% producer/consumer, classic.

<<struct Mousestate>>=
struct Mousestate
{
    Mouse;
    ulong	counter;	/* serial no. of mouse event */
};
@


\subsection{[[/mnt/wsys/mouse]]  reading part2}

% chain of event, read /mnt/wsys/mouse => ??
% start from actual click -> mousethread listening on
% channel conntected to ioproc reading /dev/mouse.
% -> winctl

\subsubsection{Producer}


% seen WMouse before

<<[[winctl()]] other locals>>=
Mousestate *mp;
int lastb = -1;
@
% mp = m producer, and m = m consumer (but cant use mc cos conflict
% with mouse control)

% received a mouse even from mousethread
<<[[winctl()]] WMouse case if mouseopen>>=
if(w->mouseopen) {
    w->mouse.counter++;

    /* queue click events */
    if(!w->mouse.qfull && lastb != w->mc.buttons) {	/* add to ring */

        //insert_queue(w->mc, w->mouse.queue)
        mp = &w->mouse.queue[w->mouse.wi];
        if(++w->mouse.wi == nelem(w->mouse.queue))
            w->mouse.wi = 0;
        if(w->mouse.wi == w->mouse.ri)
            w->mouse.qfull = true;
        mp->Mouse = w->mc;
        mp->counter = w->mouse.counter;

        lastb = w->mc.buttons;
    }
}
@
% if same buttons, then no new event?

\subsubsection{Consumer}
% Consumer and producer, like in a pipe

<<[[Wxxx]] cases>>=
WMouseread,
@


<<[[winctl()]] other locals>>=
Mousereadmesg mrm;
@
<<[[winctl()]] channels creation>>=
mrm.cm = chancreate(sizeof(Mouse), 0);
@
<<[[winctl()]] Wctl case, free channels if wctlmesg is Excited>>=
chanfree(mrm.cm);
@

% if child process listening on mouseread, we can feed him
% stuff in our queue


<<[[winctl()]] alts setup>>=
alts[WMouseread].c = w->mouseread;
alts[WMouseread].v = &mrm;
alts[WMouseread].op = CHANSND;
@
%CHANSND here!! first time! 

<<[[winctl()]] alts adjustments>>=
if(w->mouseopen && w->mouse.counter != w->mouse.lastcounter)
    alts[WMouseread].op = CHANSND;
else
    alts[WMouseread].op = CHANNOP;
@
% prepare to send something if the mouse was opened and if there is
% something to send.
% Remember that adjustments are made inside the for loop, so
%  after each message has been processed, revisit the alts setting

\t why need to go through 2 stages with the channel?
\t  anyway we queue mouse events and we look for counters,
\t  so we could send directly 


<<[[winctl()]] other locals>>=
Mousestate m;
@

<<[[winctl()]] event loop cases>>=
case WMouseread:
    /* send a queued event or, if the queue is empty, the current state */
    /* if the queue has filled, we discard all the events it contained. */
    /* the intent is to discard frantic clicking by the user during long latencies. */
    w->mouse.qfull = false;
    // if produced more than read
    if(w->mouse.wi != w->mouse.ri) {
        m = w->mouse.queue[w->mouse.ri];
        if(++w->mouse.ri == nelem(w->mouse.queue))
            w->mouse.ri = 0;
    } else
        m = (Mousestate){w->mc.Mouse, w->mouse.counter};

    w->mouse.lastcounter = m.counter;
    // consumed and relay
    send(mrm.cm, &m.Mouse);
    continue;
@



\section{Keyboard events}

\subsection{Raw keys queue}

<<[[Window]] graphical window fields>>=
// array<Rune> (size = Window.nraw)
Rune		*raw;
uint		nraw;
@
% graphical window & keyboard field


% in addition have runes from the text copied potentially by user
% with the mouse after the output point.


\subsection{[[/mnt/wsys/cons]] reading part2}

\subsubsection{Producer}

% seen keyboard listening code already in section X.

% winctl -> <>
<<[[wkeyctl()]] if rawing>>=
if(w->rawing && (w->mouseopen || w->q0 == w->nr)){
    waddraw(w, &r, 1);
    return;
}
@
%old: I transposed the || arguments, clearer for now


% if rawing and graphical mode, then dont care about output pointer.

% faux ami, not a draw operation :) but w_add_raw

% nr? q0? will see later
% but because can have raw mode also for textual window,
% in which case add rune (and no echo),
% otherwise the "when not rawing" section will happen


<<function waddraw>>=
void
waddraw(Window *w, Rune *r, int nr)
{
    w->raw = runerealloc(w->raw, w->nraw+nr);
    runemove(w->raw + w->nraw, r, nr);
    w->nraw += nr;
}
@
% realloc at each key press??


<<[[wctlmesg()]] When Rawoff, process raw keys in non rawing mode>>=
while(w->nraw > 0){
    wkeyctl(w, w->raw[0]);
    --w->nraw;
    runemove(w->raw, w->raw+1, w->nraw);
}
@
% wkeyctl will not loop back to same code now that rawing has been
%  set off in xfidclose. It just feeds back the rune to 
%  regular textual window mode.



\subsubsection{Consumer}
% Consumer and producer, like in a pipe

<<[[Wxxx]] cases>>=
WCread, 
@

<<[[winctl()]] other locals>>=
Consreadmesg crm;
@

<<[[winctl()]] channels creation>>=
crm.c1 = chancreate(sizeof(Stringpair), 0);
crm.c2 = chancreate(sizeof(Stringpair), 0);
@
<<[[winctl()]] Wctl case, free channels if wctlmesg is Excited>>=
chanfree(crm.c1);
chanfree(crm.c2);
@


% when have key, it's send to app that listen on /dev/cons,
% so we actually reemit here (what we have listened before on w->ck)
% hence the CHNSND! we write in their STDIN, we act as a relay between
% two entities, hence the two channels which is really kind of a pipe?


<<[[winctl()]] alts setup>>=
alts[WCread].c = w->consread;
alts[WCread].v = &crm;
alts[WCread].op = CHANSND;
@
% CHANSND!!


<<[[winctl()]] alts adjustments>>=
<<[[winctl()]] alts adjustments, if holding>>
else if((w->rawing && w->nraw>0) || npart)
    alts[WCread].op = CHANSND;
else{
    alts[WCread].op = CHANNOP;
    <<[[winctl()]] alts adjustments, revert to CHANSND if newline in queue>>
}
@
%old: I transposed again the || arguments, clearer to see raw first

% ready to send only if have stuff indeed to send!

% similar to Fid.rpart and Fid.nrpart, but this time
% on the side of the winctl, since it is the one who 


<<[[winctl()]] other locals>>=
Stringpair pair;
char *t;
int nb;
int i, c, wid;
@
% app is reading /dev/cons for bytes, not Rune.



<<[[winctl()]] event loop cases>>=
case WCread:
    recv(crm.c1, &pair);
    t = pair.s;
    nb = pair.ns;

    i = 0;
    <<[[winctl()]] when WCRead, copy in t previous partial rune bytes>>

    while(i<nb && (w->nraw > 0 || w->qh < w->nr)){

        if(w->qh == w->nr){
            wid = runetochar(t+i, &w->raw[0]);
            w->nraw--;
            runemove(w->raw, w->raw+1, w->nraw);
        }else
            wid = runetochar(t+i, &w->r[w->qh++]);

        i += wid;
        <<[[winctl()]] when WCRead, break if newline and handle EOF character>>
        }
    }
    <<[[winctl()]] when WCRead, handle EOF character after while loop>>
    <<[[winctl()]] when WCRead, store overflow bytes of partial rune>>

    pair.s = t;
    pair.ns = i;
    send(crm.c2, &pair);
    continue;
@
%old: again I reverted some ||



% similar issue than in xfid where need store partial rune bytes

<<[[winctl()]] other locals>>=
char part[3]; // UTFMAX-1
int npart = 0;
@
% end of w->raw[] unprocessed last time

<<[[winctl()]] when WCRead, store overflow bytes of partial rune>>=
if(i > nb){
    npart = i-nb;
    memmove(part, t+nb, npart);
    i = nb;
}
@


<<[[winctl()]] when WCRead, copy in t previous partial rune bytes>>=
i = npart;
npart = 0;
if(i)
    memmove(t, part, i);
@





\section{Resize events}

% actually abuse the mouse device for that, a big ugly.

<<[[xfidread()]] when Qmouse, adjust c for resize message if resized>>=
if(w->resized)
    c = 'r';
@

% also mounter.counter++ in wresize()


\section{[[/mnt/wsys/window]]}

<<[[qid]] cases>>=
Qwindow,
@
<<dirtab array elements>>=
{ "window",		QTFILE,	Qwindow,	0400 },
@


<<[[xfidread()]] other locals>>=
Image *i;
Rectangle r;
char buf[128];
char cbuf[30];
@
% 128 enough to read /dev/mouse, or header of image

<<[[xfidread()]] cases>>=
case Qwindow:
    i = w->i;
    if(i == nil || Dx(w->screenr)<=0){
        filsysrespond(x->fs, x, &fc, Enowindow);
        return;
    }
    r = w->screenr;
    /* fall through */

caseImage:
    if(off < 5*12){
        n = sprint(buf, "%11s %11d %11d %11d %11d ",
            chantostr(cbuf, view->chan),
            i->r.min.x, i->r.min.y, i->r.max.x, i->r.max.y);
        t = estrdup(buf);
        goto Text;
    }
    t = malloc(cnt);
    fc.data = t;
    n = readwindow(i, t, r, off, cnt);	/* careful; fc.count is unsigned */
    if(n < 0){
        buf[0] = 0;
        errstr(buf, sizeof buf);
        filsysrespond(x->fs, x, &fc, buf);
    }else{
        fc.count = n;
        filsysrespond(x->fs, x, &fc, nil);
    }
    free(t);
    return;
@
\l could make a function case_image instead of using labels and goto.

<<function readwindow>>=
int
readwindow(Image *i, char *t, Rectangle r, int offset, int n)
{
    int ww, y;

    offset -= 5*12;
    ww = bytesperline(r, view->depth);
    r.min.y += offset/ww;
    if(r.min.y >= r.max.y)
        return 0;
    y = r.min.y + n/ww;
    if(y < r.max.y)
        r.max.y = y;
    if(r.max.y <= r.min.y)
        return 0;
    return unloadimage(i, r, (uchar*)t, n);
}
@







\chapter{Textual Windows}
\label{chap:textual-windows}

% challenge is we don't want to change all our command line apps
% to do some drawtext() ... we want backward compatibility, some
% kind of emulation! (and with more services thx to the mouse!)

% it's relatively easy to have an xterm under plan9
% thx to the fake /dev/cons

%https://www.destroyallsoftware.com/talks/a-whole-new-world

% terminal emulator has a lot in common with an editor.
% Code of efuns is similar for many things.

\l put most stuff of libframe in appendix

\section{Textual window creation}

% Saw window creation section before. Some additional setup
% for textual windows we skipped.


<<constants Scrollxxx>>=
Scrollwid 		= 12,	/* width of scroll bar */
Scrollgap 		= 4,	/* gap right of scroll bar */
@
\n could also put that in Scrolling section later, but then
\n force to split wmk too much I think

% FIGURE again?

<<[[wmk()]] textual window settings>>=
r = insetrect(i->r, Selborder+1);
w->scrollr = r;
w->scrollr.max.x = r.min.x+Scrollwid;

r.min.x += Scrollwid+Scrollgap;
frinit(w, r, font, i, cols);

w->lastsr = ZR;
w->maxtab = maxtab * stringwidth(font, "0");
w->scrolling = scrolling;

r = insetrect(w->i->r, Selborder);
draw(w->i, r, cols[BACK], nil, w->entire.min);
@
% entire is a frame property, set by frinit()

% will see cols soon

% not mentionned is Window.r, nr, maxr, which are initialized
% to 0 by emalloc(sizeof(Window)) in wmk.
% might be nice to initialize them explicitly to nil or 0
% and say winsert will do first alloc.

% similar code
<<[[wresize()]] textual window updates>>=
r = insetrect(i->r, Selborder+1);
w->scrollr = r;
w->scrollr.max.x = r.min.x+Scrollwid;

w->lastsr = ZR;

r.min.x += Scrollwid+Scrollgap;

if(move)
    frsetrects(w, r, w->i);
else{
    frclear(w, false);
    frinit(w, r, w->font, w->i, cols);
    wsetcols(w);

    w->maxtab = maxtab * stringwidth(w->font, "0");

    r = insetrect(w->i->r, Selborder);
    draw(w->i, r, cols[BACK], nil, w->entire.min);

    wfill(w);
    wsetselect(w, w->q0, w->q1);
    wscrdraw(w);
}
@
% useful opti to differentiate move and resize?
% maybe could factorize more code with wmk creation.
% Have a paint function! (see codemap)

\section{Text widget, [[Frame]]}

% frame(2)
% used by rio and sam, factorize code for Editable Text (widget)

% mv in Widgets.nw?

% It is actually not what is around the window. Bad name.
% Rename maybe TextWidget?
% 

<<struct Frame>>=
struct Frame
{
    Display	*display;	/* on which frame appears */
    Image	*b;		/* on which frame appears */

    Image	*cols[NCOL];	/* text and background colors */

    Font	*font;		/* of chars in the frame */

    Rectangle	r;		/* in which text appears */
    Rectangle	entire;		/* of full frame */

    void (*scroll)(Frame*, int); /* scroll function provided by application */

    Frbox	*box;

    ulong	p0, p1;		/* selection */

    ushort	nbox, nalloc;
    ushort	maxtab;		/* max size of tab, in pixels */

    ushort	nchars;		/* # runes in frame */
    ushort	nlines;		/* # lines with text */

    ushort	maxlines;	/* total # lines in frame */
    ushort	lastlinefull;	/* last line fills frame */

    ushort	modified;	/* changed since frselect() */

    Image	*tick;	/* typing tick */
    Image	*tickback;	/* saved image under tick */
    int		ticked;	/* flag: is tick onscreen? */
};
@
% the actual content is in the englobing data structure (e.g., Window.r)

% properties
<<enum _anon_ (include/frame.h)>>=
enum{
    BACK, // Background
    HIGH, // Background highlighted text
    BORD, // Border
    TEXT, // Text
    HTEXT, // Highlited text

    NCOL
};
@
\l rename enums? use full word?
\t Bord is not the same that window border?

% images/colors for the frame
<<global cols>>=
// map<Property, Color>
static	Image	*cols[NCOL];
@


<<global grey>>=
static	Image	*grey;
@

<<global darkgrey>>=
static	Image	*darkgrey;
@

<<global titlecol>>=
static	Image	*titlecol;
@

<<global lighttitlecol>>=
static	Image	*lighttitlecol;
@



<<[[wmk()]] cols initialisation>>=
if(cols[0] == nil){
    /* greys are multiples of 0x11111100+0xFF, 14* being palest */
    grey     = allocimage(display, Rect(0,0,1,1), CMAP8, true, 0xEEEEEEFF);
    darkgrey = allocimage(display, Rect(0,0,1,1), CMAP8, true, 0x666666FF);
    cols[BACK] = display->white;
    cols[HIGH] = allocimage(display, Rect(0,0,1,1), CMAP8, true, 0xCCCCCCFF);
    cols[BORD] = allocimage(display, Rect(0,0,1,1), CMAP8, true, 0x999999FF);
    cols[TEXT] = display->black;
    cols[HTEXT] = display->black;

    titlecol     = allocimage(display, Rect(0,0,1,1), CMAP8, true, DGreygreen);
    lighttitlecol= allocimage(display, Rect(0,0,1,1), CMAP8, true, DPalegreygreen);
    holdcol      = allocimage(display, Rect(0,0,1,1), CMAP8, true, DMedblue);
    lightholdcol = allocimage(display, Rect(0,0,1,1), CMAP8, true, DGreyblue);
    paleholdcol  = allocimage(display, Rect(0,0,1,1), CMAP8, true, DPalegreyblue);
}
@
% the cols will be inverted at some point.

% libframe/
% ... -> new -> wmk() -> <>
<<function frinit>>=
void
frinit(Frame *f, Rectangle r, Font *ft, Image *b, Image *cols[NCOL])
{
    f->font = ft;
    f->display = b->display;
    f->maxtab = 8 * stringwidth(ft, "0");

    f->nbox = 0;
    f->nalloc = 0;
    f->nchars = 0;
    f->nlines = 0;

    f->p0 = 0;
    f->p1 = 0;
    f->box = 0;
    f->lastlinefull = 0;
    if(cols != nil)
        memmove(f->cols, cols, sizeof f->cols);
    frsetrects(f, r, b);
    if(f->tick == nil && f->cols[BACK] != nil)
        frinittick(f);
}
@


\t in appendix?
<<struct Frbox>>=
struct Frbox
{
    long		wid;		/* in pixels */
    long		nrune;		/* <0 ==> negate and treat as break char */
    union{
        uchar	*ptr;
        struct{
            short	bc;	/* break char */
            short	minwid;
        };
    };
};
@





<<global maxtab>>=
int		maxtab = 0;
@
<<[[main()]] locals>>=
char *s;
@
<<[[main()]] set some globals>>=
s = getenv("tabstop");
if(s != nil)
    maxtab = strtol(s, nil, 0);
if(maxtab == 0)
    maxtab = 4;
free(s);
@

\section{Content modification}

% Saw Window.r, Window.nr, maxr in core DS chapter.
% Also Window.q0, Window.org, Window.qh

% FIGURE again

% all are "text cursors", so when insert a char
% in the ext, have to update those pointers, shift then by 1 too.
% (See Efuns.nw)

% A bit like in Efuns.nw, except even simpler than gap buffer ...
% when insert, runemove everytime. Fortunatnely terminal
% usually updated at the very end, not in the middle, so it's ok.

% return q0 but might have been modified since winsert
%  can get rid of some lines when too much memory space is used
<<function winsert>>=
uint
winsert(Window *w, Rune *r, int n, uint q0)
{
    uint m;

    if(n == 0)
        return q0;
    <<[[winsert()]] if size of rune array is getting really big>>
    <<[[winsert()]] grow rune array if reach maxr>>

    // move to the right the runes after the cursor q0 to make some space
    runemove(w->r + q0 + n, w->r + q0, w->nr - q0);
    // fill the space
    runemove(w->r + q0, r, n);
    w->nr += n;

    /* if output touches, advance selection, not qh; works best for keyboard and output */
    if(q0 <= w->q0)
        w->q0 += n; // move the q0 cursor
    if(q0 <= w->q1)
        w->q1 += n;
    if(q0 < w->qh)
        w->qh += n;

    <<[[winsert()]] update visible text>>
    return q0;
}
@
% adjust cursors


% See also Efuns.nw?

<<enum _anon_ (windows/rio/wind.c)>>=
enum
{
    HiWater	= 640000,	/* max size of history */
    LoWater	= 400000,	/* min size of history after max'ed */
    MinWater	= 20000,	/* room to leave available when reallocating */
};
@


<<[[winsert()]] if size of rune array is getting really big>>=
if(w->nr + n > HiWater && q0 >= w->org && q0 >= w->qh){
    m = min(HiWater-LoWater, min(w->org, w->qh));
    w->org -= m;
    w->qh -= m;
    if(w->q0 > m)
        w->q0 -= m;
    else
        w->q0 = 0;
    if(w->q1 > m)
        w->q1 -= m;
    else
        w->q1 = 0;
    w->nr -= m;
    runemove(w->r, w->r+m, w->nr);
    q0 -= m;
}
@
% getting rid of some lines

<<[[winsert()]] grow rune array if reach maxr>>=
if(w->nr+n > w->maxr){
    /*
     * Minimize realloc breakage:
     *	Allocate at least MinWater
     * 	Double allocation size each time
     *	But don't go much above HiWater
     */
    m = max(min(2*(w->nr+n), HiWater), w->nr+n)+MinWater;
    if(m > HiWater)
        m = max(HiWater+MinWater, w->nr+n);
    if(m > w->maxr){
        w->r = runerealloc(w->r, m);
        w->maxr = m;
    }
}
@
% realloc

\section{Content rendering}

\subsection{Text color}

% ?? -> wrepaint
<<[[wrepaint()]] update cols>>=
wsetcols(w);
@

% wrepaint | ... -> <>
<<function wsetcols>>=
void
wsetcols(Window *w)
{
    <<[[wsetcols()]] if holding>>
    else
        if(w == input)
            w->cols[TEXT] = w->cols[HTEXT] = display->black;
        else
            w->cols[TEXT] = w->cols[HTEXT] = darkgrey;
}
@
% invert color, but who then redraw the content?

\subsection{Text widget draw}

<<[[wrepaint()]] if mouse not opened>>=
if(!w->mouseopen)
    frredraw(w);
@

\subsection{[[wshow()]]}

<<[[Window]] textual window fields>>=
uint		org;
@
% what is visible on the frame!
\l could move in core DS, but used only now so maybe ok.

% Window.nchars is in Frame!




% mv cursor, show text where can see cursor q0
<<function wshow>>=
void
wshow(Window *w, uint q0)
{
    int qe;
    int nl;
    uint q;

    qe = w->org + w->nchars;
    if(w->org <= q0 && (q0 < qe || (q0 == qe && qe == w->nr)))
        wscrdraw(w);
    <<[[wshow()]] else, when q0 is out of scope>>
}
@


<<[[winsert()]] update visible text>>=
if(q0 < w->org)
    w->org += n;
else if(q0 <= w->org + w->nchars)
    frinsert(w, r, r+n, q0 - w->org); // echo back
@


\subsection{[[wscrdraw()]]}

<<[[Window]] other fields>>=
Rectangle	lastsr;
@
% opti

<<function wscrdraw>>=
void
wscrdraw(Window *w)
{
    Rectangle r, r1, r2;
    Image *b;

    scrtemps();
    <<[[wscrdraw()]] sanity check the window image>>
    r = w->scrollr;
    b = scrtmp;
    r1 = r;
    r1.min.x = 0;
    r1.max.x = Dx(r);
    r2 = scrpos(r1, w->org, w->org+w->nchars, w->nr);
    if(!eqrect(r2, w->lastsr)){
        w->lastsr = r2;
        /* move r1, r2 to (0,0) to avoid clipping */
        r2 = rectsubpt(r2, r1.min);
        r1 = rectsubpt(r1, r1.min);
        draw(b, r1, w->cols[BORD], nil, ZP);
        draw(b, r2, w->cols[BACK], nil, ZP);
        r2.min.x = r2.max.x-1;
        draw(b, r2, w->cols[BORD], nil, ZP);

        draw(w->i, r, b, nil, Pt(0, r1.min.y));
    }
}
@


<<[[wscrdraw()]] sanity check the window image>>=
if(w->i == nil)
    error("scrdraw");
@




<<global scrtmp>>=
static Image *scrtmp;
@

<<constant BIG>>=
BIG			= 3,	/* factor by which window dimension can exceed screen */
@

<<function scrtemps>>=
static
void
scrtemps(void)
{
    int h;

    if(scrtmp)
        return;
    h = BIG * Dy(view->r);
    scrtmp = allocimage(display, Rect(0, 0, 32, h), view->chan, false, DWhite);
    if(scrtmp == nil)
        error("scrtemps");
}
@
% 32?

\subsection{Moving the frame origin}

<<[[wshow()]] else, when q0 is out of scope>>=
else{
    nl = 4 * w->maxlines / 5;
    q = wbacknl(w, q0, nl);
    /* avoid going backwards if trying to go forwards - long lines! */
    if(!(q0 > w->org && q < w->org))
        wsetorigin(w, q, true);
    while(q0 > w->org + w->nchars)
        wsetorigin(w, w->org+1, false);
}
@

<<function wsetorigin>>=
void
wsetorigin(Window *w, uint org, int exact)
{
    int i, a, fixup;
    Rune *r;
    uint n;

    if(org>0 && !exact){
        /* org is an estimate of the char posn; find a newline */
        /* don't try harder than 256 chars */
        for(i=0; i<256 && org<w->nr; i++){
            if(w->r[org] == '\n'){
                org++;
                break;
            }
            org++;
        }
    }
    a = org - w->org;
    fixup = 0;
    if(a>=0 && a<w->nchars){
        frdelete(w, 0, a);
        fixup = 1;	/* frdelete can leave end of last line in wrong selection mode; it doesn't know what follows */
    }else if(a<0 && -a<w->nchars){
        n = w->org - org;
        r = runemalloc(n);
        runemove(r, w->r+org, n);
        frinsert(w, r, r+n, 0);
        free(r);
    }else
        frdelete(w, 0, w->nchars);
    w->org = org;
    wfill(w);
    wscrdraw(w);
    wsetselect(w, w->q0, w->q1);
    if(fixup && w->p1 > w->p0)
        frdrawsel(w, frptofchar(w, w->p1-1), w->p1-1, w->p1, 1);
}
@

<<function wfill>>=
void
wfill(Window *w)
{
    Rune *rp;
    int i, n, m, nl;

    if(w->lastlinefull)
        return;
    rp = malloc(messagesize);
    do{
        n = w->nr-(w->org+w->nchars);
        if(n == 0)
            break;
        if(n > 2000)	/* educated guess at reasonable amount */
            n = 2000;
        runemove(rp, w->r+(w->org+w->nchars), n);
        /*
         * it's expensive to frinsert more than we need, so
         * count newlines.
         */
        nl = w->maxlines-w->nlines;
        m = 0;
        for(i=0; i<n; ){
            if(rp[i++] == '\n'){
                m++;
                if(m >= nl)
                    break;
            }
        }
        frinsert(w, rp, rp+i, w->nchars);
    } while(w->lastlinefull == false);
    free(rp);
}
@





\section{Mouse events}

% no producer/consumer here, just click generating action,
% textual windows do not read /mnt/wsys/mouse

\subsection{Middle click menu}

% certain condition = when !mouseopen
<<[[mousethread()]] middle click under certain conditions>>=
button2menu(winput);
@

% active only on actual window, not like right menu
% mousethread -> event loop -> <>(winput)
<<function button2menu>>=
void
button2menu(Window *w)
{
    <<[[button2menu()]] return if window was deleted>>

    incref(w);
    <<[[button2menu()]] menu2str adjustments for scrolling>>
    switch(menuhit(2, mousectl, &menu2, wscreen)){
    <<[[button2menu()]] cases>>
    }
    wclose(w); // decref

    wsendctlmesg(w, Wakeup, ZR, nil);
    flushimage(display, true);
}
@

<<[[button2menu()]] return if window was deleted>>=
if(w->deleted)
    return;
@

<<global menu2>>=
Menu menu2 =
{
    menu2str
};
@

<<global menu2str>>=
char*		menu2str[] = {
 [Cut]		"cut",
 [Paste]	"paste",
 [Snarf]	"snarf",
 [Plumb]	"plumb",
 [Send]		"send",
 [Scroll]	"scroll",
 nil
};
@

<<enum _anon_ (windows/rio/rio.c)2>>=
enum
{
    Cut,
    Paste,
    Snarf,
    Plumb,
    Send,
    Scroll,
};
@



\subsection{Other clicks}

<<[[winctl()]] WMouse case if not mouseopen>>=
wmousectl(w);
@

% hmm can get middle click here? and right click?? but it should
% have been intercepted before no?
<<function wmousectl>>=
void
wmousectl(Window *w)
{
    int but;

    if(w->mc.buttons == 1)
        but = 1;
    else if(w->mc.buttons == 2)
        but = 2;
    else if(w->mc.buttons == 4)
        but = 3;
    else{
        if(w->mc.buttons == 8)
            wkeyctl(w, Kscrolloneup);
        if(w->mc.buttons == 16)
            wkeyctl(w, Kscrollonedown);
        return;
    }

    incref(w);		/* hold up window while we track */
    <<[[wmousectl()]] goto Return if window was deleted>>

    <<[[wmousectl()]] if pt in scrollbar>>
    if(but == 1)
        wselect(w);

    /* else all is handled by main process */
   Return:
    wclose(w);
}
@
% transform mouse even in key event :) for scrolling

% see scrolling later, using but value


<<[[wmousectl()]] goto Return if window was deleted>>=
if(w->deleted)
    goto Return;
@

\section{Keyboard events}

\subsection{Text input queue}

% it's between w->qh and w->nr!
% see core DS chapter
% (not necessarily keyboard event actually, can have put text after
% output point because of copy paste)

% output point!


\subsection{[[/mnt/wsys/cons]] reading part3}

\subsubsection{Producer}

<<[[wkeyctl()]] when not rawing>>=
// here when no navigation key, no rawing, no 0x1B holding

<<[[wkeyctl()]] snarf and cut if not interrupt key>>
switch(r){
<<[[wkeyctl()]] special key cases and no special mode>>
}
// else

/* otherwise ordinary character; just insert */
<<[[wkeyctl()]] ordinary character>>
@

% will see soon special keys

<<[[wkeyctl()]] locals>>=
uint q0;
@

<<[[wkeyctl()]] ordinary character>>=
q0 = w->q0;
q0 = winsert(w, &r, 1, q0);
wshow(w, q0+1);
@
% insert, and move cursor after (and redisplay)





\subsubsection{Consumer}

% similar to graphical window, except condition
% not just have raw char, now check for newline

<<[[winctl()]] alts adjustments, revert to CHANSND if newline in queue>>=
/* this code depends on NL and EOT fitting in a single byte */
/* kind of expensive for each loop; worth precomputing? */
for(i = w->qh; i < w->nr; i++){
     c = w->r[i];
     // buffering, until get a newline in which case we are ready to send
     if(c=='\n' || c=='\004'){
         alts[WCread].op = CHANSND;
         break;
     }
 }
@



<<[[winctl()]] when WCRead, break if newline and handle EOF character>>=
c = t[i-wid];	/* knows break characters fit in a byte */
if(!w->rawing && (c == '\n' || c=='\004')){
    if(c == '\004')
        i--;
    break;
@
%old: was c = t[i] but I put i+=wid earlier to aspectize this part
% break so will not fill more t, will stop even if guy asked for more.

<<[[winctl()]] when WCRead, handle EOF character after while loop>>=
if(i==nb && w->qh < w->nr && w->r[w->qh]=='\004')
    w->qh++;
@
% ???





\subsection{Navigation keys}
% can help to understand q0, qh, etc

<<[[wkeyctl()]] when mouse not opened and navigation keys>>=
if(!w->mouseopen)
switch(r){
<<[[wkeyctl()]] when mouse not opened, switch key cases>>
default:
    ; // no return! fallthrough
}
@

<<[[wkeyctl()]] locals>>=
uint q1;
int n, nb;
@
% seen q0 before too

\subsubsection{Text boundaries (Home, end)}

<<[[wkeyctl()]] when mouse not opened, switch key cases>>=
case Khome:
    wshow(w, 0);
    return;
@

<<[[wkeyctl()]] when mouse not opened, switch key cases>>=
case Kend:
    wshow(w, w->nr);
    return;
@

\subsubsection{Down}

% maxlines is very bad name.
% use nblines instead?

<<[[wkeyctl()]] when mouse not opened, switch key cases>>=
case Kdown:
    n = w->maxlines / 3;
    goto case_Down;
@
% go down 1/3 of height

<<[[wkeyctl()]] when mouse not opened, switch key cases>>=
case Kscrollonedown:
    n = mousescrollsize(w->maxlines);
    if(n <= 0)
        n = 1;
    goto case_Down;
@
<<[[wkeyctl()]] when mouse not opened, switch key cases>>=
case Kpgdown:
    n = 2 * w->maxlines / 3;
    // Fallthrough
case_Down:
    q0 = w->org +
        frcharofpt(w, Pt(w->Frame.r.min.x, 
                         w->Frame.r.min.y + n * w->font->height));
    wsetorigin(w, q0, true);
    return;
@
% go down 2/3 of height

\subsubsection{Up}

<<[[wkeyctl()]] when mouse not opened, switch key cases>>=
case Kup:
    n = w->maxlines/3;
    goto case_Up;
@
<<[[wkeyctl()]] when mouse not opened, switch key cases>>=
case Kscrolloneup:
    n = mousescrollsize(w->maxlines);
    if(n <= 0)
        n = 1;
    goto case_Up;
@
<<[[wkeyctl()]] when mouse not opened, switch key cases>>=
case Kpgup:
    n = 2*w->maxlines/3;
    // Fallthrough
case_Up:
    q0 = wbacknl(w, w->org, n);
    wsetorigin(w, q0, true);
    return;
@



<<function wbacknl>>=
uint
wbacknl(Window *w, uint p, uint n)
{
    int i, j;

    /* look for start of this line if n==0 */
    if(n==0 && p>0 && w->r[p-1]!='\n')
        n = 1;
    i = n;
    while(i-->0 && p>0){
        --p;	/* it's at a newline now; back over it */
        if(p == 0)
            break;
        /* at 128 chars, call it a line anyway */
        for(j=128; --j>0 && p>0; p--)
            if(w->r[p-1]=='\n')
                break;
    }
    return p;
}
@


\subsubsection{Left}

<<[[wkeyctl()]] when mouse not opened, switch key cases>>=
case Kleft:
    if(w->q0 > 0){
        q0 = w->q0 - 1;
        wsetselect(w, q0, q0);
        wshow(w, q0);
    }
    return;
@



\subsubsection{Right}

<<[[wkeyctl()]] when mouse not opened, switch key cases>>=
case Kright:
    if(w->q1 < w->nr){
        q1 = w->q1+1;
        wsetselect(w, q1, q1);
        wshow(w, q1);
    }
    return;
@

\subsubsection{Line boundaries}

% easy
<<[[wkeyctl()]] when mouse not opened, switch key cases>>=
case 0x05:	/* ^E: end of line */
    q0 = w->q0;
    while(q0 < w->nr && w->r[q0] != '\n')
        q0++;
    wsetselect(w, q0, q0);
    wshow(w, w->q0);
    return;
@



<<[[wkeyctl()]] when mouse not opened, switch key cases>>=
case 0x01:	/* ^A: beginning of line */
    if(w->q0==0 || w->q0 == w->qh || w->r[w->q0 - 1]=='\n')
        return;
    nb = wbswidth(w, 0x15 /* ^U */);
    wsetselect(w, w->q0 - nb, w->q0 - nb);
    wshow(w, w->q0);
    return;
@

<<function wbswidth>>=
int
wbswidth(Window *w, Rune c)
{
    uint q, eq, stop;
    Rune r;
    int skipping;

    /* there is known to be at least one character to erase */
    if(c == 0x08)	/* ^H: erase character */
        return 1;
    q = w->q0;
    stop = 0;
    if(q > w->qh)
        stop = w->qh;
    skipping = true;
    while(q > stop){
        r = w->r[q-1];
        if(r == '\n'){		/* eat at most one more character */
            if(q == w->q0)	/* eat the newline */
                --q;
            break; 
        }
        if(c == 0x17){
            eq = isalnum(r);
            if(eq && skipping)	/* found one; stop skipping */
                skipping = false;
            else if(!eq && !skipping)
                break;
        }
        --q;
    }
    return w->q0-q;
}
@




\subsection{Special keys}

\subsubsection{Delete}

<<[[wkeyctl()]] special key cases and no special mode>>=
case 0x08:	/* ^H: erase character */
case 0x15:	/* ^U: erase line */
case 0x17:	/* ^W: erase word */
    if(w->q0==0 || w->q0==w->qh)
        return;
    nb = wbswidth(w, r);
    q1 = w->q0;
    q0 = q1-nb;
    if(q0 < w->org){
        q0 = w->org;
        nb = q1-q0;
    }
    if(nb > 0){
        wdelete(w, q0, q0+nb);
        wsetselect(w, q0, q0);
    }
    return;
@


<<function wdelete>>=
void
wdelete(Window *w, uint q0, uint q1)
{
    uint n, p0, p1;

    n = q1-q0;
    if(n == 0)
        return;
    runemove(w->r+q0, w->r+q1, w->nr-q1);
    w->nr -= n;
    if(q0 < w->q0)
        w->q0 -= min(n, w->q0-q0);
    if(q0 < w->q1)
        w->q1 -= min(n, w->q1-q0);
    if(q1 < w->qh)
        w->qh -= n;
    else if(q0 < w->qh)
        w->qh = q0;
    if(q1 <= w->org)
        w->org -= n;
    else if(q0 < w->org+w->nchars){
        p1 = q1 - w->org;
        if(p1 > w->nchars)
            p1 = w->nchars;
        if(q0 < w->org){
            w->org = q0;
            p0 = 0;
        }else
            p0 = q0 - w->org;
        frdelete(w, p0, p1);
        wfill(w);
    }
}
@





\subsubsection{Interrupt}

% 0x7F = Del? (see Kernel.nw )

<<[[wkeyctl()]] locals>>=
int nr;
Rune *rp;
int *notefd;
@

<<[[wkeyctl()]] special key cases and no special mode>>=
case 0x7F:		/* send interrupt */
    w->qh = w->nr;
    wshow(w, w->qh);
    notefd = emalloc(sizeof(int));
    *notefd = w->notefd;
    proccreate(interruptproc, notefd, 4096);
    return;
@

% wkeyctl -> proccreate(<>)
<<function interruptproc>>=
/*
 * Need to do this in a separate proc because if process we're interrupting
 * is dying and trying to print tombstone, kernel is blocked holding p->debug lock.
 */
void
interruptproc(void *v)
{
    int *notefd;

    notefd = v;
    write(*notefd, "interrupt", 9);
    free(notefd);
}
@





\section{Application output events}


\subsection{[[/mnt/wsys/cons]] writing part2}

% when write on /dev/cons, then need update text.

% process output string by writing on /dev/cons!
% newline too, runes

\subsubsection{Producer}

% is user process writing on /mnt/wsys/cons

\subsubsection{Consumer}

<<[[Wxxx]] cases>>=
WCwrite,
@

<<[[winctl()]] other locals>>=
Conswritemesg cwm;
@
<<[[winctl()]] channels creation>>=
cwm.cw = chancreate(sizeof(Stringpair), 0);
@
<<[[winctl()]] Wctl case, free channels if wctlmesg is Excited>>=
chanfree(cwm.cw);
@

<<[[winctl()]] alts setup>>=
alts[WCwrite].c = w->conswrite;
alts[WCwrite].v = &cwm;
alts[WCwrite].op = CHANSND;
@

<<[[winctl()]] alts adjustments>>=
if(!w->scrolling && !w->mouseopen && w->qh >  w->org + w->nchars)
    alts[WCwrite].op = CHANNOP;
else
    alts[WCwrite].op = CHANSND;
@
% ! mouseopen??




<<[[winctl()]] other locals>>=
Rune *rp, *bp, *tp, *up;
int nr;
int initial;
uint qh;
@

<<[[winctl()]] event loop cases>>=
case WCwrite:
    recv(cwm.cw, &pair);
    rp = pair.s;
    nr = pair.ns;

    bp = rp;
    for(i=0; i<nr; i++) {
        if(*bp++ == '\b'){
            --bp;
            initial = 0;
            tp = runemalloc(nr);
            runemove(tp, rp, i);
            up = tp+i;
            for(; i<nr; i++){
                *up = *bp++;
                if(*up == '\b')
                    if(up == tp)
                        initial++;
                    else
                        --up;
                else
                    up++;
            }
            if(initial){
                if(initial > w->qh)
                    initial = w->qh;
                qh = w->qh-initial;
                wdelete(w, qh, qh+initial);
                w->qh = qh;
            }
            free(rp);
            rp = tp;
            nr = up-tp;
            rp[nr] = 0;
            break;
        }
    }

    w->qh = winsert(w, rp, nr, w->qh) + nr;
    if(w->scrolling || w->mouseopen)
        wshow(w, w->qh);
    wsetselect(w, w->q0, w->q1);
    wscrdraw(w);
    free(rp);
    break;
@



\section{Word selection}
% adv topics?

<<global clickwin>>=
static Window	*clickwin;
@

<<global clickmsec>>=
static uint	clickmsec;
@

<<global selectwin>>=
static Window	*selectwin;
@

<<global selectq>>=
static uint	selectq;
@



<<function wselect>>=
void
wselect(Window *w)
{
    uint q0, q1;
    int b, x, y, first;

    first = 1;
    selectwin = w;
    /*
     * Double-click immediately if it might make sense.
     */
    b = w->mc.buttons;
    q0 = w->q0;
    q1 = w->q1;
    selectq = w->org+frcharofpt(w, w->mc.xy);
    if(clickwin==w && w->mc.msec-clickmsec<500)
    if(q0==q1 && selectq==w->q0){
        wdoubleclick(w, &q0, &q1);
        wsetselect(w, q0, q1);
        flushimage(display, 1);
        x = w->mc.xy.x;
        y = w->mc.xy.y;
        /* stay here until something interesting happens */
        do
            readmouse(&w->mc);
        while(w->mc.buttons==b && abs(w->mc.xy.x-x)<3 && abs(w->mc.xy.y-y)<3);
        w->mc.xy.x = x;	/* in case we're calling frselect */
        w->mc.xy.y = y;
        q0 = w->q0;	/* may have changed */
        q1 = w->q1;
        selectq = q0;
    }
    if(w->mc.buttons == b){
        w->scroll = framescroll;
        frselect(w, &w->mc);
        /* horrible botch: while asleep, may have lost selection altogether */
        if(selectq > w->nr)
            selectq = w->org + w->p0;
        w->Frame.scroll = nil;
        if(selectq < w->org)
            q0 = selectq;
        else
            q0 = w->org + w->p0;
        if(selectq > w->org+w->nchars)
            q1 = selectq;
        else
            q1 = w->org+w->p1;
    }
    if(q0 == q1){
        if(q0==w->q0 && clickwin==w && w->mc.msec-clickmsec<500){
            wdoubleclick(w, &q0, &q1);
            clickwin = nil;
        }else{
            clickwin = w;
            clickmsec = w->mc.msec;
        }
    }else
        clickwin = nil;
    wsetselect(w, q0, q1);
    flushimage(display, 1);
    while(w->mc.buttons){
        w->mc.msec = 0;
        b = w->mc.buttons;
        if(b & 6){
            if(b & 2){
                wsnarf(w);
                wcut(w);
            }else{
                if(first){
                    first = 0;
                    getsnarf();
                }
                wpaste(w);
            }
        }
        wscrdraw(w);
        flushimage(display, 1);
        while(w->mc.buttons == b)
            readmouse(&w->mc);
        clickwin = nil;
    }
}
@




<<global left1>>=
static Rune left1[] =  { L'{', L'[', L'(', L'<', L'', 0 };
@

<<global right1>>=
static Rune right1[] = { L'}', L']', L')', L'>', L'', 0 };
@

<<global left2>>=
static Rune left2[] =  { L'\n', 0 };
@

<<global left3>>=
static Rune left3[] =  { L'\'', L'"', L'`', 0 };
@

<<global left>>=
Rune *left[] = {
    left1,
    left2,
    left3,
    nil
};
@

<<global right>>=
Rune *right[] = {
    right1,
    left2,
    left3,
    nil
};
@



<<function wdoubleclick>>=
void
wdoubleclick(Window *w, uint *q0, uint *q1)
{
    int c, i;
    Rune *r, *l, *p;
    uint q;

    for(i=0; left[i]!=nil; i++){
        q = *q0;
        l = left[i];
        r = right[i];
        /* try matching character to left, looking right */
        if(q == 0)
            c = '\n';
        else
            c = w->r[q-1];
        p = strrune(l, c);
        if(p != nil){
            if(wclickmatch(w, c, r[p-l], 1, &q))
                *q1 = q-(c!='\n');
            return;
        }
        /* try matching character to right, looking left */
        if(q == w->nr)
            c = '\n';
        else
            c = w->r[q];
        p = strrune(r, c);
        if(p != nil){
            if(wclickmatch(w, c, l[p-r], -1, &q)){
                *q1 = *q0+(*q0<w->nr && c=='\n');
                *q0 = q;
                if(c!='\n' || q!=0 || w->r[0]=='\n')
                    (*q0)++;
            }
            return;
        }
    }
    /* try filling out word to right */
    while(*q1<w->nr && isalnum(w->r[*q1]))
        (*q1)++;
    /* try filling out word to left */
    while(*q0>0 && isalnum(w->r[*q0-1]))
        (*q0)--;
}
@


<<function wclickmatch>>=
int
wclickmatch(Window *w, int cl, int cr, int dir, uint *q)
{
    Rune c;
    int nest;

    nest = 1;
    for(;;){
        if(dir > 0){
            if(*q == w->nr)
                break;
            c = w->r[*q];
            (*q)++;
        }else{
            if(*q == 0)
                break;
            (*q)--;
            c = w->r[*q];
        }
        if(c == cr){
            if(--nest==0)
                return 1;
        }else if(c == cl)
            nest++;
    }
    return cl=='\n' && nest==1;
}
@


<<function wsetselect>>=
void
wsetselect(Window *w, uint q0, uint q1)
{
    int p0, p1;

    /* w->p0 and w->p1 are always right; w->q0 and w->q1 may be off */
    w->q0 = q0;
    w->q1 = q1;
    /* compute desired p0,p1 from q0,q1 */
    p0 = q0-w->org;
    p1 = q1-w->org;
    if(p0 < 0)
        p0 = 0;
    if(p1 < 0)
        p1 = 0;
    if(p0 > w->nchars)
        p0 = w->nchars;
    if(p1 > w->nchars)
        p1 = w->nchars;
    if(p0==w->p0 && p1==w->p1)
        return;

    /* screen disagrees with desired selection */
    if(w->p1<=p0 || p1<=w->p0 || p0==p1 || w->p1==w->p0){
        /* no overlap or too easy to bother trying */
        frdrawsel(w, frptofchar(w, w->p0), w->p0, w->p1, 0);
        frdrawsel(w, frptofchar(w, p0), p0, p1, 1);
        goto Return;
    }
    /* overlap; avoid unnecessary painting */
    if(p0 < w->p0){
        /* extend selection backwards */
        frdrawsel(w, frptofchar(w, p0), p0, w->p0, 1);
    }else if(p0 > w->p0){
        /* trim first part of selection */
        frdrawsel(w, frptofchar(w, w->p0), w->p0, p0, 0);
    }
    if(p1 > w->p1){
        /* extend selection forwards */
        frdrawsel(w, frptofchar(w, w->p1), w->p1, p1, 1);
    }else if(p1 < w->p1){
        /* trim last part of selection */
        frdrawsel(w, frptofchar(w, p1), p1, w->p1, 0);
    }

    Return:
    w->p0 = p0;
    w->p1 = p1;
}
@



\section{Cut, Copy, Paste}
% adv topics?
% put snarf stuff here


\section{Automatic scrolling mode}
% hard to put in adv topics, this global is pretty important

<<[[button2menu()]] menu2str adjustments for scrolling>>=
if(w->scrolling)
    menu2str[Scroll] = "noscroll";
else
    menu2str[Scroll] = "scroll";
@

<<[[button2menu()]] cases>>=
case Scroll:
    if(w->scrolling ^= 1)
        wshow(w, w->nr);
    break;
@


\section{Scroll bars}

% seen Window.scrollr before

<<[[mousethread()]] locals>>=
bool scrolling = false;
@
% != Window.scrolling !! this is when inside scrollbar

% window terminal have scrollbars
<<[[mousethread()]] set scrolling>>=
if(winput->mouseopen)
    scrolling = false;
else 
  if(scrolling)
    scrolling = mouse->buttons;
  else
    scrolling = mouse->buttons && ptinrect(xy, winput->scrollr);
@


<<[[mousethread()]] goto Sending if scroll buttons>>=
/* the up and down scroll buttons are not subject to the usual rules */
if((mouse->buttons&(8|16)) && !winput->mouseopen)
    goto Sending;
@



<<[[wmousectl()]] if pt in scrollbar>>=
if(ptinrect(w->mc.xy, w->scrollr)){
    if(but)
        wscroll(w, but);
    goto Return;
}
@

% if ptinrect scrollr

<<function wscroll>>=
void
wscroll(Window *w, int but)
{
    uint p0, oldp0;
    Rectangle s;
    int x, y, my, h, first;

    s = insetrect(w->scrollr, 1);
    h = s.max.y-s.min.y;
    x = (s.min.x+s.max.x)/2;
    oldp0 = ~0;
    first = true;
    do{
        flushimage(display, 1);
        if(w->mc.xy.x<s.min.x || s.max.x<=w->mc.xy.x){
            readmouse(&w->mc);
        }else{
            my = w->mc.xy.y;
            if(my < s.min.y)
                my = s.min.y;
            if(my >= s.max.y)
                my = s.max.y;
            if(!eqpt(w->mc.xy, Pt(x, my))){
                wmovemouse(w, Pt(x, my));
                readmouse(&w->mc);		/* absorb event generated by moveto() */
            }
            if(but == 2){
                y = my;
                if(y > s.max.y-2)
                    y = s.max.y-2;
                if(w->nr > 1024*1024)
                    p0 = ((w->nr>>10)*(y-s.min.y)/h)<<10; // >>
                else
                    p0 = w->nr*(y-s.min.y)/h;
                if(oldp0 != p0)
                    wsetorigin(w, p0, false);
                oldp0 = p0;
                readmouse(&w->mc);
                continue;
            }
            if(but == 1)
                p0 = wbacknl(w, w->org, (my-s.min.y)/w->font->height);
            else
                p0 = w->org+frcharofpt(w, Pt(s.max.x, my));
            if(oldp0 != p0)
                wsetorigin(w, p0, true);
            oldp0 = p0;
            /* debounce */
            if(first){
                flushimage(display, 1);
                sleep(200);
                nbrecv(w->mc.c, &w->mc.Mouse);
                first = false;
            }
            wscrsleep(w, 100);
        }
    }while(w->mc.buttons & (1<<(but-1))); // >>
    while(w->mc.buttons)
        readmouse(&w->mc);
}
@






<<enum _anon_ (windows/rio/dat.h)2>>=
enum
{
    Kscrolloneup = KF|0x20,
    Kscrollonedown = KF|0x21,
};
@





<<function freescrtemps>>=
void
freescrtemps(void)
{
    freeimage(scrtmp);
    scrtmp = nil;
}
@

<<function scrpos>>=
static
Rectangle
scrpos(Rectangle r, uint p0, uint p1, uint tot)
{
    Rectangle q;
    int h;

    q = r;
    h = q.max.y-q.min.y;
    if(tot == 0)
        return q;
    if(tot > 1024*1024){
        tot>>=10;
        p0>>=10;
        p1>>=10;
    }
    if(p0 > 0)
        q.min.y += h*p0/tot;
    if(p1 < tot)
        q.max.y -= h*(tot-p1)/tot;
    if(q.max.y < q.min.y+2){
        if(q.min.y+2 <= r.max.y)
            q.max.y = q.min.y+2;
        else
            q.min.y = q.max.y-2;
    }
    return q;
}
@



<<function wscrsleep>>=
void
wscrsleep(Window *w, uint dt)
{
    Timer	*timer;
    int y, b;
    static Alt alts[3];

    timer = timerstart(dt);
    y = w->mc.xy.y;
    b = w->mc.buttons;
    alts[0].c = timer->c;
    alts[0].v = nil;
    alts[0].op = CHANRCV;
    alts[1].c = w->mc.c;
    alts[1].v = &w->mc.Mouse;
    alts[1].op = CHANRCV;
    alts[2].op = CHANEND;
    for(;;)
        switch(alt(alts)){
        case 0:
            timerstop(timer);
            return;
        case 1:
            if(abs(w->mc.xy.y-y)>2 || w->mc.buttons!=b){
                timercancel(timer);
                return;
            }
            break;
        }
}
@














<<function framescroll>>=
/*
 * called from frame library
 */
void
framescroll(Frame *f, int dl)
{
    if(f != &selectwin->Frame)
        error("frameselect not right frame");
    wframescroll(selectwin, dl);
}
@

<<function wframescroll>>=
void
wframescroll(Window *w, int dl)
{
    uint q0;

    if(dl == 0){
        wscrsleep(w, 100);
        return;
    }
    if(dl < 0){
        q0 = wbacknl(w, w->org, -dl);
        if(selectq > w->org+w->p0)
            wsetselect(w, w->org+w->p0, selectq);
        else
            wsetselect(w, selectq, w->org+w->p0);
    }else{
        if(w->org+w->nchars == w->nr)
            return;
        q0 = w->org+frcharofpt(w, Pt(w->Frame.r.min.x, w->Frame.r.min.y+dl*w->font->height));
        if(selectq >= w->org+w->p1)
            wsetselect(w, w->org+w->p1, selectq);
        else
            wsetselect(w, selectq, w->org+w->p1);
    }
    wsetorigin(w, q0, true);
}
@




\section{[[/mnt/wsys/text]]}
% interesting to understand structure!

<<[[qid]] cases>>=
Qtext,
@
<<dirtab array elements>>=
{ "text",		QTFILE,	Qtext,		0400 },
@

<<[[xfidread()]] cases>>=
case Qtext:
    t = wcontents(w, &n);
    goto Text;

Text:
    if(off > n){
        off = n;
        cnt = 0;
    }
    if(off+cnt > n)
        cnt = n-off;

    fc.data = t + off;
    fc.count = cnt;
    filsysrespond(x->fs, x, &fc, nil);
    free(t);
    break;
@

<<function wcontents>>=
char*
wcontents(Window *w, int *ip)
{
    return runetobyte(w->r, w->nr, ip);
}
@
% runetobyte libc


\chapter{[[/mnt/wsys/...]] Window Files}
\label{chap:window-files}

% more the reflective part of rio, a bit like /proc for the kernel.
% (well winname is more important than that though)

\section{[[/mnt/wsys/winid]]}

<<[[qid]] cases>>=
Qwinid,
@
<<dirtab array elements>>=
{ "winid",		QTFILE,	Qwinid,		0400 },
@

<<[[xfidread()]] cases>>=
case Qwinid:
    n = sprint(buf, "%11d ", w->id);
    t = estrdup(buf);
    goto Text;
@
% sanity check n?

\section{[[/mnt/wsys/winname]]}
% before


\section{[[/mnt/wsys/label]]}

<<[[qid]] cases>>=
Qlabel,
@
<<dirtab array elements>>=
{ "label",		QTFILE,	Qlabel,		0600 },
@

<<[[xfidread()]] cases>>=
case Qlabel:
    n = strlen(w->label);
    if(off > n)
        off = n;
    if(off+cnt > n)
        cnt = n - off;

    fc.data = w->label + off;
    fc.count = cnt;
    filsysrespond(x->fs, x, &fc, nil);
    break;
@
% could use goto Text? we avoid some allocations here


% used in hidden!
% not used in title bar, see rational in "Windows should be transparent",
% pike does not like title bar, useless according to him, encouraging
% to put state info in it which anyway should not exist!

<<[[xfidwrite()]] cases>>=
case Qlabel:
    if(off != 0){
        filsysrespond(x->fs, x, &fc, "non-zero offset writing label");
        return;
    }
    free(w->label);
    w->label = emalloc(cnt+1);
    memmove(w->label, x->data, cnt);
    w->label[cnt] = '\0';
    break;
@


\section{[[/mnt/wsys/wdir]]}

<<[[qid]] cases>>=
Qwdir,
@
<<dirtab array elements>>=
{ "wdir",		QTFILE,	Qwdir,		0600 },
@

<<[[xfidread()]] cases>>=
case Qwdir:
    t = estrdup(w->dir);
    n = strlen(t);
    goto Text;
@


% so can write on /dev/wdir, but effect?
% a bit like chdir()?

<<[[xfidwrite()]] cases>>=
case Qwdir:
    if(cnt == 0)
        break;
    if(x->data[cnt-1] == '\n'){
        if(cnt == 1)
            break;
        x->data[cnt-1] = '\0';
    }
    /* assume data comes in a single write */
    /*
      * Problem: programs like dossrv, ftp produce illegal UTF;
      * we must cope by converting it first.
      */
    snprint(buf, sizeof buf, "%.*s", cnt, x->data);
    if(buf[0] == '/'){
        free(w->dir);
        w->dir = estrdup(buf);
    }else{
        p = emalloc(strlen(w->dir) + 1 + strlen(buf) + 1);
        sprint(p, "%s/%s", w->dir, buf);
        free(w->dir);
        w->dir = cleanname(p);
    }
    break;
@

\section{[[/mnt/wsys/screen]]}

% read only

<<[[qid]] cases>>=
Qscreen,
@
<<dirtab array elements>>=
{ "screen",		QTFILE,	Qscreen,	0400 },
@

<<[[xfidread()]] cases>>=
case Qscreen:
    i = display->image;
    if(i == nil){
        filsysrespond(x->fs, x, &fc, "no top-level screen");
        break;
    }
    r = i->r;
    goto caseImage;
@
%old: the caseImage used to be here, but I prefer to put
% it with the Qwindow case

\section{[[/mnt/wsys/wsys/]]}

% https://github.com/sdhand/x11fs

<<[[qid]] cases>>=
Qwsys,		/* directory of window directories */
@
<<dirtab array elements>>=
{ "wsys",		QTDIR,	Qwsys,		0500|DMDIR },
@
% QTDIR!


<<function idcmp>>=
static
int
idcmp(void *a, void *b)
{
    return *(int*)a - *(int*)b;
}
@


<<[[filsysread()]] other locals>>=
int i, j, k;
int len;
int *ids;
Dirtab dt;
char buf[16];
@

<<[[filsysread()]] cases>>=
case Qwsys:

    qlock(&all);
    ids = emalloc(nwindow * sizeof(int));
    for(j=0; j<nwindow; j++)
        ids[j] = windows[j]->id;
    qunlock(&all);

    qsort(ids, nwindow, sizeof ids[0], idcmp);
    dt.name = buf;
    for(i=0, j=0; j<nwindow && i<e; i+=len){
        k = ids[j];
        sprint(dt.name, "%d", k);
        dt.qid = QID(k, Qdir);
        dt.type = QTDIR;
        dt.perm = DMDIR|0700;
        len = dostat(fs, k, &dt, b+n, x->count-n, clock);
        if(len == 0)
            break;
        if(i >= o)
            n += len;
        j++;
    }
    free(ids);
    break;
@



% see filsyswalk
<<[[qid]] cases>>=
Qwsysdir,		/* window directory, child of wsys */
@


<<[[filsysread()]] other locals>>=
Dirtab *d;
@

<<[[filsysread()]] cases>>=
case Qdir:
case Qwsysdir:
    d = dirtab;
    d++;	/* first entry is '.' */
    for(i=0; d->name != nil && i<e; i+=len){
        len = dostat(fs, WIN(x->f->qid), d, b+n, x->count-n, clock);
        if(len <= BIT16SZ)
            break;
        if(i >= o)
            n += len;
        d++;
    }
    break;
@


\section{[[/mnt/wsys/wctl]]}
% Adv topics? Debugging support chapter?
% allow to command an app? a la watir/selenium/... ?


<<[[Window]] other fields>>=
bool	wctlopen;
bool 	wctlready;
@
%old: was bool_byte for wctlopen, and int for wctlready
% exclusive access to wctlopen



<<[[qid]] cases>>=
Qwctl,
@
<<dirtab array elements>>=
{ "wctl",		QTFILE,	Qwctl,		0600 },
@

<<[[xfidopen()]] cases>>=
case Qwctl:
    if(x->mode==OREAD || x->mode==ORDWR){
        /*
         * It would be much nicer to implement fan-out for wctl reads,
         * so multiple people can see the resizings, but rio just isn't
         * structured for that.  It's structured for /dev/cons, which gives
         * alternate data to alternate readers.  So to keep things sane for
         * wctl, we compromise and give an error if two people try to
         * open it.  Apologies.
         */
        if(w->wctlopen){
            filsysrespond(x->fs, x, &fc, Einuse);
            return;
        }
        w->wctlopen = true;
        w->wctlready = true;
        wsendctlmesg(w, Wakeup, ZR, nil);
    }
    break;
@

<<[[xfidclose()]] cases>>=
case Qwctl:
    if(x->f->mode==OREAD || x->f->mode==ORDWR)
        w->wctlopen = false;
break;
@



<<[[wcurrent()]] wakeup w and oi>>=
if(w != oi){
    if(oi){
        oi->wctlready = true;
        wsendctlmesg(oi, Wakeup, ZR, nil);
    }
    if(w){
        w->wctlready = true;
        wsendctlmesg(w, Wakeup, ZR, nil);
    }
}
@
% But Wakeup does nothing actually

\subsection{Reading}

\subsubsection{Producer}

\subsubsection{Consumer}



<<enum _anon_ (windows/rio/xfid.c)5>>=
enum { WCRdata, WCRflush, NWCR };
@

<<[[xfidread()]] other locals>>=
Consreadmesg cwrm;
@

<<[[xfidread()]] cases>>=
case Qwctl:	/* read returns rectangle, hangs if not resized */
    if(cnt < 4*12){
        filsysrespond(x->fs, x, &fc, Etooshort);
        break;
    }
    <<[[xfidxxx()]] set flushtag>>

    alts[WCRdata].c = w->wctlread;
    alts[WCRdata].v = &cwrm;
    alts[WCRdata].op = CHANRCV;
    <<[[xfidread()]] when Qwctl, set alts for flush>>
    alts[NMR].op = CHANEND;

    switch(alt(alts)){
    case WCRdata:
        break;
    <<[[xfidread()]] when Qwctl, switch alt flush case>>
    }

    /* received data */
    <<[[xfidxxx()]] unset flushtag>>
    c1 = cwrm.c1;
    c2 = cwrm.c2;
    t = malloc(cnt+1);	/* be sure to have room for NUL */
    pair.s = t;
    pair.ns = cnt+1;
    send(c1, &pair);
    <<[[xfidread()]] when Qwctl, if flushing>>

    qlock(&x->active);
    recv(c2, &pair);
    fc.data = pair.s;
    if(pair.ns > cnt)
        pair.ns = cnt;
    fc.count = pair.ns;
    filsysrespond(x->fs, x, &fc, nil);
    free(t);
    qunlock(&x->active);
    break;
@




% when read by app it's the current status of the window

<<[[Window]] other fields>>=
// chan<Consreadmesg> (listener = , sender = )
Channel		*wctlread;	/* chan(Consreadmesg) */
@
% abuse Consreadmesg
<<[[wmk()]] channels creation>>=
w->wctlread =  chancreate(sizeof(Consreadmesg), 0);
@


<<[[winctl()]] other locals>>=
Consreadmesg cwrm;
@

<<[[winctl()]] channels creation>>=
cwrm.c1 = chancreate(sizeof(Stringpair), 0);
cwrm.c2 = chancreate(sizeof(Stringpair), 0);
@
<<[[winctl()]] Wctl case, free channels if wctlmesg is Excited>>=
chanfree(cwrm.c1);
chanfree(cwrm.c2);
@


<<[[Wxxx]] cases>>=
WWread,
@


<<[[winctl()]] alts setup>>=
alts[WWread].c = w->wctlread;
alts[WWread].v = &cwrm;
alts[WWread].op = CHANSND;
@

<<[[winctl()]] alts adjustments>>=
if(w->deleted || !w->wctlready)
    alts[WWread].op = CHANNOP;
else
    alts[WWread].op = CHANSND;
@


<<[[winctl()]] other locals>>=
char *s;
@

<<[[winctl()]] event loop cases>>=
case WWread:
    w->wctlready = false;
    recv(cwrm.c1, &pair);
    if(w->deleted || w->i==nil)
        pair.ns = sprint(pair.s, "");
    else{
        s = "visible";
        for(i=0; i<nhidden; i++)
            if(hidden[i] == w){
                s = "hidden";
                break;
            }
        t = "notcurrent";
        if(w == input)
            t = "current";
        pair.ns = snprint(pair.s, pair.ns, "%11d %11d %11d %11d %s %s ",
            w->i->r.min.x, w->i->r.min.y, w->i->r.max.x, w->i->r.max.y, t, s);
    }
    send(cwrm.c2, &pair);
    continue;
@





\subsection{Writing (controlling windows)}

<<[[xfidwrite()]] cases>>=
case Qwctl:
    if(writewctl(x, buf) < 0){
        filsysrespond(x->fs, x, &fc, buf);
        return;
    }
    flushimage(display, true);
    break;
@



<<function writewctl>>=
int
writewctl(Xfid *x, char *err)
{
    int cnt, cmd, j, id, hideit, scrollit, pid;
    Image *i;
    char *arg, *dir;
    Rectangle rect;
    Window *w;

    w = x->f->w;
    cnt = x->count;
    x->data[cnt] = '\0';
    id = 0;

    rect = rectsubpt(w->screenr, view->r.min);
    cmd = parsewctl(&arg, rect, &rect, &pid, &id, &hideit, &scrollit, &dir, x->data, err);
    if(cmd < 0)
        return -1;

    if(mouse->buttons!=0 && cmd>=Top){
        strcpy(err, "action disallowed when mouse active");
        return -1;
    }

    if(id != 0){
        for(j=0; j<nwindow; j++)
            if(windows[j]->id == id)
                break;
        if(j == nwindow){
            strcpy(err, "no such window id");
            return -1;
        }
        w = windows[j];
        if(w->deleted || w->i==nil){
            strcpy(err, "window deleted");
            return -1;
        }
    }

    switch(cmd){
    case New:
        return wctlnew(rect, arg, pid, hideit, scrollit, dir, err);
    case Set:
        if(pid > 0)
            wsetpid(w, pid, 0);
        return 1;
    case Move:
        rect = Rect(rect.min.x, rect.min.y, rect.min.x+Dx(w->screenr), rect.min.y+Dy(w->screenr));
        rect = rectonscreen(rect);
        /* fall through */
    case Resize:
        if(!goodrect(rect)){
            strcpy(err, Ebadwr);
            return -1;
        }
        if(eqrect(rect, w->screenr))
            return 1;
        i = allocwindow(wscreen, rect, Refbackup, DWhite);
        if(i == nil){
            strcpy(err, Ewalloc);
            return -1;
        }
        border(i, rect, Selborder, red, ZP);
        wsendctlmesg(w, Reshaped, i->r, i);
        return 1;
    case Scroll:
        w->scrolling = 1;
        wshow(w, w->nr);
        wsendctlmesg(w, Wakeup, ZR, nil);
        return 1;
    case Noscroll:
        w->scrolling = 0;
        wsendctlmesg(w, Wakeup, ZR, nil);
        return 1;
    case Top:
        wtopme(w);
        return 1;
    case Bottom:
        wbottomme(w);
        return 1;
    case Current:
        wcurrent(w);
        return 1;
    case Hide:
        switch(whide(w)){
        case -1:
            strcpy(err, "window already hidden");
            return -1;
        case 0:
            strcpy(err, "hide failed");
            return -1;
        default:
            break;
        }
        return 1;
    case Unhide:
        for(j=0; j<nhidden; j++)
            if(hidden[j] == w)
                break;
        if(j == nhidden){
            strcpy(err, "window not hidden");
            return -1;
        }
        if(wunhide(j) == 0){
            strcpy(err, "hide failed");
            return -1;
        }
        return 1;
    case Delete:
        wsendctlmesg(w, Deleted, ZR, nil);
        return 1;
    }
    strcpy(err, "invalid wctl message");
    return -1;
}
@

% nice summary of all Wctlmesgkind






%\chapter{Debugging Support}
% ? with rio -k? with /mnt/wsys/wctl?

\chapter{Advanced Topics TODO}
\label{chap:advanced}

\section{Command-line mount, [[/srv/rio.user.pid]]}

% this make fileserver accessible more easily to external
% processes. 

% like a named pipe?

% also allow newwindow() we saw in Graphics.nw!

% Until now done filsysmount() from rio itself
% in child process where mount(filesys->cfd, ...) and
% so have access to file descriptor. But for external?
% enter the /srv mechanism of plan9 to publish those things.

% mount $sys ... 

% /srv/rio.user.pid  pipe open for clients to communicate with rio server
<<global srvpipe (windows/rio/fsys.c)>>=
char	srvpipe[64];
@


<<[[filsysinit()]] srv pipe>>=
/*
 * Post srv pipe
 */
sprint(srvpipe, "/srv/rio.%s.%d", fs->user, pid);
post(srvpipe, "wsys", fs->cfd);
@


<<function post>>=
void
post(char *name, char *envname, fdt srvfd)
{
    fdt fd;
    char buf[32];

    fd = create(name, OWRITE|ORCLOSE|OCEXEC, 0600);
    if(fd < 0)
        error(name);
    sprint(buf, "%d", srvfd);
    if(write(fd, buf, strlen(buf)) != strlen(buf))
        error("srv write");

    putenv(envname, name);
}
@
% why need write srvfd which is fs->cfd? 
% so the file in /srv/.../ just contains a filedescriptor number? enough?
% or is it working with #s special code?



<<[[xfidattach()]] other locals>>=
Rectangle r;
int pid;
bool hideit = false;
bool scrollit;
char *err = Eunkid;
char *dir, errbuf[ERRMAX];
Image *i;
@

<<[[xfidattach()]] if mount "new ...">>=
if(strncmp(x->aname, "new", 3) == 0){	/* new -dx -dy - new syntax, as in wctl */
    pid = 0;
    if(parsewctl(nil, ZR, &r, &pid, nil, &hideit, &scrollit, &dir, x->aname, errbuf) < 0)
        err = errbuf;
    else {
        if(!goodrect(r))
            err = Ebadrect;
        else{
            if(hideit)
                i = allocimage(display, r, view->chan, false, DWhite);
            else
                i = allocwindow(wscreen, r, Refbackup, DWhite);
            if(i){
                border(i, r, Selborder, display->black, ZP);
                if(pid == 0)
                    pid = -1;	/* make sure we don't pop a shell! - UGH */
                w = new(i, hideit, scrolling, pid, nil, nil, nil);
                flushimage(display, 1);
                newlymade = true;
            }else
                err = Ewindow;
        }
   }
}
@

\section{Command-line control, [[/srv/riowctl.user.pid]]}

% allow to run graphical command from the command line

<<global wctlfd>>=
int	wctlfd;
@

<<global srvwctl (windows/rio/fsys.c)>>=
char	srvwctl[64];
@
% why need global?


<<[[filsysinit()]] wctl pipe, process, and thread creation>>=
/*
 * Create and post wctl pipe
 */
<<[[filsysinit()]] create wctl pipe>>

/*
 * Start server processes
 */
<<[[filsysinit()]] create wctl process and thread>>
@



<<[[filsysinit()]] other locals>>=
fdt p0;
// chan<??> (listener = ??, sender = ??)
Channel *c;
@


<<[[filsysinit()]] create wctl pipe>>=
if(cexecpipe(&p0, &wctlfd) < 0)
    goto Rescue;
sprint(srvwctl, "/srv/riowctl.%s.%d", fs->user, pid);
post(srvwctl, "wctl", p0);
close(p0);
@
% vs /dev/wctl? why need pipe mechanism for that? because
% /dev/wctl is for stuff who mounted rio, but external process
% dont have it! so need bootstrap!

<<[[filsysinit()]] create wctl process and thread>>=
c = chancreate(sizeof(char*), 0);
if(c == nil)
    error("wctl channel");

proccreate(wctlproc, c, 4096);
threadcreate(wctlthread, c, 4096);
@
% channel so process and thread can communicate


<<function wctlproc>>=
void
wctlproc(void *v)
{
    Channel *c = v;
    char *buf;
    int n, eofs;

    threadsetname("WCTLPROC");

    eofs = 0;
    for(;;){
        buf = emalloc(messagesize);
        // blocking call
        n = read(wctlfd, buf, messagesize-1);	/* room for \0 */
        if(n < 0)
            break;
        if(n == 0){
            if(++eofs > 20)
                break;
            continue;
        }
        eofs = 0;

        buf[n] = '\0';
        sendp(c, buf);
    }
}
@




<<function wctlthread>>=
void
wctlthread(void *v)
{
    Channel *c = v;
    char *buf, *arg, *dir;
    int cmd, id, pid, hideit, scrollit;
    Rectangle rect;
    char err[ERRMAX];

    threadsetname("WCTLTHREAD");

    for(;;){
        buf = recvp(c);

        cmd = parsewctl(&arg, ZR, &rect, &pid, &id, &hideit, &scrollit, &dir, buf, err);

        switch(cmd){
        case New:
            wctlnew(rect, arg, pid, hideit, scrollit, dir, err);
        }
        free(buf);
    }
}
@





\t mv before in other /mnt/wsys/ctl?

<<enum _anon_ (windows/rio/wctl.c)>>=
/* >= Top are disallowed if mouse button is pressed */
enum
{
    New,
    Resize,
    Move,
    Scroll,
    Noscroll,
    Set,
    Top,
    Bottom,
    Current,
    Hide,
    Unhide,
    Delete,
};
@

<<global cmds>>=
static char *cmds[] = {
    [New]	= "new",
    [Resize]	= "resize",
    [Move]	= "move",
    [Scroll]	= "scroll",
    [Noscroll]	= "noscroll",
    [Set]	= "set",
    [Top]	= "top",
    [Bottom]	= "bottom",
    [Current]	= "current",
    [Hide]	= "hide",
    [Unhide]	= "unhide",
    [Delete]	= "delete",
    nil
};
@

<<enum _anon_ (windows/rio/wctl.c)2>>=
enum
{
    Cd,
    Deltax,
    Deltay,
    Hidden,
    Id,

    Maxx,
    Maxy,
    Minx,
    Miny,

    PID,
    R,

    Scrolling,
    Noscrolling,
};
@

<<global params>>=
static char *params[] = {
    [Cd] 			= "-cd",
    [Deltax]			= "-dx",
    [Deltay]			= "-dy",
    [Hidden]			= "-hide",
    [Id]			= "-id",
    [Maxx]			= "-maxx",
    [Maxy]			= "-maxy",
    [Minx]			= "-minx",
    [Miny]			= "-miny",
    [PID]			= "-pid",
    [R]				= "-r",
    [Scrolling]			= "-scroll",
    [Noscrolling]		= "-noscroll",
    nil
};
@

<<function goodrect>>=
/*
 * Check that newly created window will be of manageable size
 */
int
goodrect(Rectangle r)
{
    if(!eqrect(canonrect(r), r))
        return 0;
    if(Dx(r)<100 || Dy(r)<3*font->height)
        return 0;
    /* must have some screen and border visible so we can move it out of the way */
    if(Dx(r) >= Dx(view->r) && Dy(r) >= Dy(view->r))
        return 0;
    /* reasonable sizes only please */
    if(Dx(r) > BIG*Dx(view->r))
        return 0;
    if(Dy(r) > BIG*Dx(view->r))
        return 0;
    return 1;
}
@

<<function word>>=
static
int
word(char **sp, char *tab[])
{
    char *s, *t;
    int i;

    s = *sp;
    while(isspace(*s))
        s++;
    t = s;
    while(*s!='\0' && !isspace(*s))
        s++;
    for(i=0; tab[i]!=nil; i++)
        if(strncmp(tab[i], t, strlen(tab[i])) == 0){
            *sp = s;
            return i;
    }
    return -1;
}
@

<<function set>>=
int
set(int sign, int neg, int abs, int pos)
{
    if(sign < 0)
        return neg;
    if(sign > 0)
        return pos;
    return abs;
}
@

<<function newrect>>=
Rectangle
newrect(void)
{
    static int i = 0;
    int minx, miny, dx, dy;

    dx = min(600, Dx(view->r) - 2*Borderwidth);
    dy = min(400, Dy(view->r) - 2*Borderwidth);
    minx = 32 + 16*i;
    miny = 32 + 16*i;
    i++;
    i %= 10;

    return Rect(minx, miny, minx+dx, miny+dy);
}
@

<<function shift>>=
void
shift(int *minp, int *maxp, int min, int max)
{
    if(*minp < min){
        *maxp += min-*minp;
        *minp = min;
    }
    if(*maxp > max){
        *minp += max-*maxp;
        *maxp = max;
    }
}
@

<<function rectonscreen>>=
Rectangle
rectonscreen(Rectangle r)
{
    shift(&r.min.x, &r.max.x, view->r.min.x, view->r.max.x);
    shift(&r.min.y, &r.max.y, view->r.min.y, view->r.max.y);
    return r;
}
@

<<function riostrtol>>=
/* permit square brackets, in the manner of %R */
int
riostrtol(char *s, char **t)
{
    int n;

    while(*s!='\0' && (*s==' ' || *s=='\t' || *s=='['))
        s++;
    if(*s == '[')
        s++;
    n = strtol(s, t, 10);
    if(*t != s)
        while((*t)[0] == ']')
            (*t)++;
    return n;
}
@

<<function parsewctl>>=
int
parsewctl(char **argp, Rectangle r, Rectangle *rp, int *pidp, int *idp, int *hiddenp, int *scrollingp, char **cdp, char *s, char *err)
{
    int cmd, param, xy, sign;
    char *t;

    *pidp = 0;
    *hiddenp = 0;
    *scrollingp = scrolling;
    *cdp = nil;
    cmd = word(&s, cmds);
    if(cmd < 0){
        strcpy(err, "unrecognized wctl command");
        return -1;
    }
    if(cmd == New)
        r = newrect();

    strcpy(err, "missing or bad wctl parameter");

    while((param = word(&s, params)) >= 0){
        switch(param){	/* special cases */
        case Hidden:
            *hiddenp = 1;
            continue;
        case Scrolling:
            *scrollingp = 1;
            continue;
        case Noscrolling:
            *scrollingp = 0;
            continue;
        case R:
            r.min.x = riostrtol(s, &t);
            if(t == s)
                return -1;
            s = t;
            r.min.y = riostrtol(s, &t);
            if(t == s)
                return -1;
            s = t;
            r.max.x = riostrtol(s, &t);
            if(t == s)
                return -1;
            s = t;
            r.max.y = riostrtol(s, &t);
            if(t == s)
                return -1;
            s = t;
            continue;
        }
        while(isspace(*s))
            s++;
        if(param == Cd){
            *cdp = s;
            while(*s && !isspace(*s))
                s++;
            if(*s != '\0')
                *s++ = '\0';
            continue;
        }
        sign = 0;
        if(*s == '-'){
            sign = -1;
            s++;
        }else if(*s == '+'){
            sign = +1;
            s++;
        }
        if(!isdigit(*s))
            return -1;
        xy = riostrtol(s, &s);

        switch(param){
        case Minx:
            r.min.x = set(sign, r.min.x-xy, xy, r.min.x+xy);
            break;
        case Miny:
            r.min.y = set(sign, r.min.y-xy, xy, r.min.y+xy);
            break;
        case Maxx:
            r.max.x = set(sign, r.max.x-xy, xy, r.max.x+xy);
            break;
        case Maxy:
            r.max.y = set(sign, r.max.y-xy, xy, r.max.y+xy);
            break;
        case Deltax:
            r.max.x = set(sign, r.max.x-xy, r.min.x+xy, r.max.x+xy);
            break;
        case Deltay:
            r.max.y = set(sign, r.max.y-xy, r.min.y+xy, r.max.y+xy);
            break;
        case Id:
            if(idp != nil)
                *idp = xy;
            break;
        case PID:
            if(pidp != nil)
                *pidp = xy;
            break;
        case -1:
            strcpy(err, "unrecognized wctl parameter");
            return -1;
        }
    }

    *rp = rectonscreen(rectaddpt(r, view->r.min));

    while(isspace(*s))
        s++;
    if(cmd!=New && *s!='\0'){
        strcpy(err, "extraneous text in wctl message");
        return -1;
    }

    if(argp)
        *argp = s;

    return cmd;
}
@

<<function wctlnew>>=
int
wctlnew(Rectangle rect, char *arg, int pid, int hideit, int scrollit, char *dir, char *err)
{
    char **argv;
    Image *i;

    if(!goodrect(rect)){
        strcpy(err, Ebadwr);
        return -1;
    }
    argv = emalloc(4*sizeof(char*));
    argv[0] = "rc";
    argv[1] = "-c";
    while(isspace(*arg))
        arg++;
    if(*arg == '\0'){
        argv[1] = "-i";
        argv[2] = nil;
    }else{
        argv[2] = arg;
        argv[3] = nil;
    }
    if(hideit)
        i = allocimage(display, rect, view->chan, false, DWhite);
    else
        i = allocwindow(wscreen, rect, Refbackup, DWhite);
    if(i == nil){
        strcpy(err, Ewalloc);
        return -1;
    }
    border(i, rect, Selborder, red, ZP);

    new(i, hideit, scrollit, pid, dir, "/bin/rc", argv);

    free(argv);	/* when new() returns, argv and args have been copied */
    return 1;
}
@




<<function wtopme>>=
void
wtopme(Window *w)
{
    if(w!=nil && w->i!=nil && !w->deleted && w->topped!=topped){
        topwindow(w->i);
        flushimage(display, 1);
        w->topped = ++topped;
    }
}
@

<<function wbottomme>>=
void
wbottomme(Window *w)
{
    if(w!=nil && w->i!=nil && !w->deleted){
        bottomwindow(w->i);
        flushimage(display, 1);
        w->topped = - ++topped;
    }
}
@


\section{Recursive [[rio]]}
% could be in Debugging section, after all it's mostly
%  to make easy to develop rio

% actually it works without doing much thing!
% because use /dev/xxx too!

<<[[Mxxx]] cases>>=
MReshape,
@
% a Mxxx because in plan9 resize events are communicated through
%  /dev/mouse (ugly)

%mouse(3)
%The mouse and cursor files are multiplexed by rio(1) to give the
%illusion of a private mouse to each of its clients. The semantics are
%otherwise the same except that notification of a window resize is
%passed to the application using a mouse message beginning with r
%rather than m; see rio(4) for details.

% so normally MReshape does not happen! only when rio is run under rio!

<<[[mousethread()]] alts setup>>=
alts[MReshape].c = mousectl->resizec;
alts[MReshape].v = nil;
alts[MReshape].op = CHANRCV;
@

<<[[mousethread()]] event loop cases>>=
case MReshape:
    resized();
    break;
@

% resized is what regular applications are supposed to do.

% from MReshape, how can get this event? from resize of rio window itself?
% so get that when run vgactl? or when run rio inside rio and resize
% sub rio window?
<<function resized>>=
void
resized(void)
{
    Image *im;
    int i, j;
    bool ishidden;
    Rectangle r;
    Point o, n;
    Window *w;

    // updates view (and screen)
    if(getwindow(display, Refnone) < 0)
        error("failed to re-attach window");

    freescrtemps();
    freescreen(wscreen);

    wscreen = allocscreen(view, background, false);
    <<[[resized()]] sanity check wscreen>>
    draw(view, view->r, background, nil, ZP);

    // old view rectangle
    o = subpt(viewr.max, viewr.min);
    n = subpt(view->clipr.max, view->clipr.min);

    for(i=0; i<nwindow; i++){
        w = windows[i];
        <<[[resized()]] continue if window was deleted>>
        r = rectsubpt(w->i->r, viewr.min);
        r.min.x = (r.min.x*n.x)/o.x;
        r.min.y = (r.min.y*n.y)/o.y;
        r.max.x = (r.max.x*n.x)/o.x;
        r.max.y = (r.max.y*n.y)/o.y;
        r = rectaddpt(r, view->clipr.min);

        ishidden = false;
        for(j=0; j<nhidden; j++)
            if(w == hidden[j]){
                ishidden = true;
                break;
            }
        if(ishidden){
            im = allocimage(display, r, view->chan, false, DWhite);
            r = ZR;
        }else
            im = allocwindow(wscreen, r, Refbackup, DWhite);

        if(im)
            wsendctlmesg(w, Reshaped, r, im);
    }
    viewr = view->r;
    flushimage(display, true);
}
@
% force redisplay by Reshaped!

% Nice code where see the full state of rio and how to iterate
%  over it


<<[[resized()]] sanity check wscreen>>=
if(wscreen == nil)
    error("can't re-allocate screen");
@

<<[[resized()]] continue if window was deleted>>=
if(w->deleted)
    continue;
@

\section{Snarf}
%\subsection{[[/dev/snarf]]}

<<[[wkeyctl()]] snarf and cut if not interrupt key>>=
if(r != 0x7F){ // 0x7F = Interrupt key
    wsnarf(w);
    wcut(w);
}
@

\subsection{Snarf menu}

<<[[button2menu()]] cases>>=
case Cut:
    wsnarf(w);
    wcut(w);
    wscrdraw(w);
    break;

case Snarf:
    wsnarf(w);
    break;

case Paste:
    getsnarf();
    wpaste(w);
    wscrdraw(w);
    break;

case Send:
    getsnarf();
    wsnarf(w);
    if(nsnarf == 0)
        break;
    if(w->rawing){
        waddraw(w, snarf, nsnarf);
        if(snarf[nsnarf-1]!='\n' && snarf[nsnarf-1]!='\004')
                      waddraw(w, L"\n", 1);
    }else{
        winsert(w, snarf, nsnarf, w->nr);
        if(snarf[nsnarf-1]!='\n' && snarf[nsnarf-1]!='\004')
            winsert(w, L"\n", 1, w->nr);
    }
    wsetselect(w, w->nr, w->nr);
    wshow(w, w->nr);
    break;
@



<<function wsnarf>>=
void
wsnarf(Window *w)
{
    if(w->q1 == w->q0)
        return;
    nsnarf = w->q1 - w->q0;
    snarf = runerealloc(snarf, nsnarf);
    snarfversion++;	/* maybe modified by parent */
    runemove(snarf, w->r+w->q0, nsnarf);
    putsnarf();
}
@


<<function wcut>>=
void
wcut(Window *w)
{
    if(w->q1 == w->q0)
        return;
    wdelete(w, w->q0, w->q1);
    wsetselect(w, w->q0, w->q0);
}
@





<<function wpaste>>=
void
wpaste(Window *w)
{
    uint q0;

    if(nsnarf == 0)
        return;
    wcut(w);
    q0 = w->q0;
    if(w->rawing && q0==w->nr){
        waddraw(w, snarf, nsnarf);
        wsetselect(w, q0, q0);
    }else{
        q0 = winsert(w, snarf, nsnarf, w->q0);
        wsetselect(w, q0, q0+nsnarf);
    }
}
@




\subsection{[[/mnt/wsys/snarf]]}

<<[[qid]] cases>>=
Qsnarf,
@

<<dirtab array elements>>=
{ "snarf",		QTFILE,	Qsnarf,		0600 },
@

<<[[xfidopen()]] cases>>=
case Qsnarf:
    if(x->mode==ORDWR || x->mode==OWRITE){
        if(tsnarf)
            free(tsnarf);	/* collision, but OK */
        ntsnarf = 0;
        tsnarf = malloc(1);
    }
    break;
@

<<[[xfidclose()]] other locals>>=
int nb, nulls;
@

<<[[xfidclose()]] cases>>=
/* odd behavior but really ok: replace snarf buffer when /dev/snarf is closed */
case Qsnarf:
    if(x->f->mode==ORDWR || x->f->mode==OWRITE){
        snarf = runerealloc(snarf, ntsnarf+1);
        cvttorunes(tsnarf, ntsnarf, snarf, &nb, &nsnarf, &nulls);
        free(tsnarf);
        tsnarf = nil;
        ntsnarf = 0;
    }
    break;
@

<<[[xfidread()]] cases>>=
/* The algorithm for snarf and text is expensive but easy and rarely used */
case Qsnarf:
    getsnarf();
    if(nsnarf)
        t = runetobyte(snarf, nsnarf, &n);
    else {
        t = nil;
        n = 0;
    }
    goto Text;
@

<<constant MAXSNARF>>=
#define	MAXSNARF	100*1024
@

<<[[xfidwrite()]] cases>>=
case Qsnarf:
    /* always append only */
    if(ntsnarf > MAXSNARF){	/* avoid thrashing when people cut huge text */
        filsysrespond(x->fs, x, &fc, Elong);
        return;
    }
    tsnarf = erealloc(tsnarf, ntsnarf+cnt+1);	/* room for NUL */
    memmove(tsnarf+ntsnarf, x->data, cnt);
    ntsnarf += cnt;
    snarfversion++;
    break;
@


<<global tsnarf>>=
static	char	*tsnarf;
@

<<global ntsnarf>>=
static	int	ntsnarf;
@






<<global snarffd>>=
fdt		snarffd;
@

<<[[main()]] set some globals>>=
snarffd = open("/dev/snarf", OREAD|OCEXEC);
@
% used to be in his own chunk but I think does not matter

<<global nsnarf>>=
int		nsnarf;
@

<<global snarf>>=
Rune*	snarf;
@

<<global snarfversion>>=
int		snarfversion;	/* updated each time it is written */
@


<<function putsnarf>>=
/*
 * /dev/snarf updates when the file is closed, so we must open our own
 * fd here rather than use snarffd
 */
void
putsnarf(void)
{
    int fd, i, n;

    if(snarffd<0 || nsnarf==0)
        return;
    fd = open("/dev/snarf", OWRITE);
    if(fd < 0)
        return;
    /* snarf buffer could be huge, so fprint will truncate; do it in blocks */
    for(i=0; i<nsnarf; i+=n){
        n = nsnarf-i;
        if(n >= 256)
            n = 256;
        if(fprint(fd, "%.*S", n, snarf+i) < 0)
            break;
    }
    close(fd);
}
@

<<function getsnarf>>=
void
getsnarf(void)
{
    int i, n, nb, nulls;
    char *sn, buf[1024];

    if(snarffd < 0)
        return;
    sn = nil;
    i = 0;
    seek(snarffd, 0, 0);
    while((n = read(snarffd, buf, sizeof buf)) > 0){
        sn = erealloc(sn, i+n+1);
        memmove(sn+i, buf, n);
        i += n;
        sn[i] = 0;
    }
    if(i > 0){
        snarf = runerealloc(snarf, i+1);
        cvttorunes(sn, i, snarf, &nb, &nsnarf, &nulls);
        free(sn);
    }
}
@



\section{Plumb}

<<[[button2menu()]] cases>>=
case Plumb:
    wplumb(w);
    break;
@

<<function wplumb>>=
void
wplumb(Window *w)
{
    Plumbmsg *m;
    static int fd = -2;
    char buf[32];
    uint p0, p1;
    Cursor *c;

    if(fd == -2)
        fd = plumbopen("send", OWRITE|OCEXEC);
    if(fd < 0)
        return;
    m = emalloc(sizeof(Plumbmsg));
    m->src = estrdup("rio");
    m->dst = nil;
    m->wdir = estrdup(w->dir);
    m->type = estrdup("text");
    p0 = w->q0;
    p1 = w->q1;
    if(w->q1 > w->q0)
        m->attr = nil;
    else{
        while(p0>0 && w->r[p0-1]!=' ' && w->r[p0-1]!='\t' && w->r[p0-1]!='\n')
            p0--;
        while(p1<w->nr && w->r[p1]!=' ' && w->r[p1]!='\t' && w->r[p1]!='\n')
            p1++;
        sprint(buf, "click=%d", w->q0-p0);
        m->attr = plumbunpackattr(buf);
    }
    if(p1-p0 > messagesize-1024){
        plumbfree(m);
        return;	/* too large for 9P */
    }
    m->data = runetobyte(w->r+p0, p1-p0, &m->ndata);
    if(plumbsend(fd, m) < 0){
        c = lastcursor;
        riosetcursor(&query, 1);
        sleep(300);
        riosetcursor(c, 1);
    }
    plumbfree(m);
}
@



%/*
% * Message format:
% *	source application\n
% *	destination port\n
% *	working directory\n
% *	type\n
% *	attributes\n
% *	nbytes\n
% *	n bytes of data
% */

<<struct Plumbmsg>>=
struct Plumbmsg
{
    char		*src;
    char		*dst;
    char		*wdir;
    char		*type;
    Plumbattr		*attr;
    int			ndata;
    char		*data;
};
@

<<struct Plumbattr>>=
struct Plumbattr
{
    char		*name;
    char		*value;
    Plumbattr		*next;
};
@


\section{Auto complete}

<<[[wkeyctl()]] special key cases and no special mode>>=
case 0x06:	/* ^F: file name completion */
case Kins:		/* Insert: file name completion */
    rp = namecomplete(w);
    if(rp == nil)
        return;
    nr = runestrlen(rp);
    q0 = w->q0;
    q0 = winsert(w, rp, nr, q0);
    wshow(w, q0+nr);
    free(rp);
    return;
@


<<struct Completion>>=
struct Completion{
    uchar advance;	/* whether forward progress has been made */
    uchar complete;	/* whether the completion now represents a file or directory */
    char *string; /* the string to advance, suffixed " " or "/" for file or directory */
    int nmatch;		/* number of files that matched */
    int nfile;		/* number of files returned */
    char **filename;	/* their names */
};
@

% wkeyctl -> <>
<<function namecomplete>>=
Rune*
namecomplete(Window *w)
{
    int nstr, npath;
    Rune *rp, *path, *str;
    Completion *c;
    char *s, *dir, *root;

    /* control-f: filename completion; works back to white space or / */
    if(w->q0<w->nr && w->r[w->q0]>' ')	/* must be at end of word */
        return nil;
    nstr = windfilewidth(w, w->q0, true);
    str = runemalloc(nstr);
    runemove(str, w->r+(w->q0-nstr), nstr);
    npath = windfilewidth(w, w->q0-nstr, false);
    path = runemalloc(npath);
    runemove(path, w->r+(w->q0-nstr-npath), npath);
    rp = nil;

    /* is path rooted? if not, we need to make it relative to window path */
    if(npath>0 && path[0]=='/'){
        dir = malloc(UTFmax*npath+1);
        sprint(dir, "%.*S", npath, path);
    }else{
        if(strcmp(w->dir, "") == 0)
            root = ".";
        else
            root = w->dir;
        dir = malloc(strlen(root)+1+UTFmax*npath+1);
        sprint(dir, "%s/%.*S", root, npath, path);
    }
    dir = cleanname(dir);

    s = smprint("%.*S", nstr, str);
    c = complete(dir, s);
    free(s);
    if(c == nil)
        goto Return;

    if(!c->advance)
        showcandidates(w, c);

    if(c->advance)
        rp = runesmprint("%s", c->string);

  Return:
    freecompletion(c);
    free(dir);
    free(path);
    free(str);
    return rp;
}
@


<<function showcandidates>>=
void
showcandidates(Window *w, Completion *c)
{
    int i;
    Fmt f;
    Rune *rp;
    uint nr, qline, q0;
    char *s;

    runefmtstrinit(&f);
    if (c->nmatch == 0)
        s = "[no matches in ";
    else
        s = "[";
    if(c->nfile > 32)
        fmtprint(&f, "%s%d files]\n", s, c->nfile);
    else{
        fmtprint(&f, "%s", s);
        for(i=0; i<c->nfile; i++){
            if(i > 0)
                fmtprint(&f, " ");
            fmtprint(&f, "%s", c->filename[i]);
        }
        fmtprint(&f, "]\n");
    }
    /* place text at beginning of line before host point */
    qline = w->qh;
    while(qline>0 && w->r[qline-1] != '\n')
        qline--;

    rp = runefmtstrflush(&f);
    nr = runestrlen(rp);

    q0 = w->q0;
    q0 += winsert(w, rp, runestrlen(rp), qline) - qline;
    free(rp);
    wsetselect(w, q0+nr, q0+nr);
}
@


% showcandidates -> <>
<<function windfilewidth>>=
int
windfilewidth(Window *w, uint q0, int oneelement)
{
    uint q;
    Rune r;

    q = q0;
    while(q > 0){
        r = w->r[q-1];
        if(r<=' ')
            break;
        if(oneelement && r=='/')
            break;
        --q;
    }
    return q0-q;
}
@


\section{Automatic scrolling, [[rio -s]]}


<<global scrolling>>=
bool		scrolling;
@
\t rename autoscroll too

<<[[main()]] command line processing>>=
case 's':
    scrolling = true;
    break;
@
% who uses that then? default mode in new()?

% and then who set w->scrolling to true?



\section{Initial command, [[rio -i]]}

<<[[main()]] locals>>=
char *initstr = nil;
@

<<[[main()]] command line processing>>=
case 'i':
    initstr = ARGF();
    if(initstr == nil)
        usage();
    break;
@

<<[[main()]] if initstr or kdbin>>=
if(initstr)
    proccreate(initcmd, initstr, STACK);
@

% process initcmd -> rename procinitcmd? or initcmdproc?
<<function initcmd>>=
void
initcmd(void *arg)
{
    char *cmd;

    cmd = arg;
    rfork(RFENVG|RFFDG|RFNOTEG|RFNAMEG);
    procexecl(nil, "/bin/rc", "rc", "-c", cmd, nil);
    fprint(STDERR, "rio: exec failed: %r\n");
    exits("exec");
}
@

\section{Fake keyboard input, [[rio -k]]}
% what for? to help debug app? to automate testing?
% put in Debugging support chapter? or Debugging chapter
% if it helps debug only rio itself

\subsection{[[rio -k]]}

<<[[main()]] locals>>=
char *kbdin = nil;
@

<<[[main()]] command line processing>>=
case 'k':
    if(kbdin != nil)
        usage();
    kbdin = ARGF();
    if(kbdin == nil)
        usage();
    break;
@



<<global wkeyboard>>=
Window	*wkeyboard;	/* window of simulated keyboard */
@




<<global kbdargv>>=
char *kbdargv[] = { "rc", "-c", nil, nil };
@

<<[[main()]] locals>>=
Image *i;
Rectangle r;
@

<<[[main()]] if initstr or kdbin>>=
if(kbdin){
    kbdargv[2] = kbdin;
    r = view->r;
    r.max.x = r.min.x+300;
    r.max.y = r.min.y+80;
    i = allocwindow(wscreen, r, Refbackup, DWhite);
    wkeyboard = new(i, false, scrolling, 0, nil, "/bin/rc", kbdargv);
    if(wkeyboard == nil)
        error("can't create keyboard window");
}
@



\subsection{[[wkeyboard]]}

<<[[mousethread()]] if wkeyboard and button 6>>=
if(wkeyboard!=nil && (mouse->buttons & (1<<5))){
    keyboardhide();
    break;
}
@

<<[[mousethread()]] if wkeyboard and ptinrect>>=
/* override everything for the keyboard window */
if(wkeyboard!=nil && ptinrect(mouse->xy, wkeyboard->screenr)){
    /* make sure it's on top; this call is free if it is */
    wtopme(wkeyboard);
    winput = wkeyboard;
}
@

<<[[wcurrent()]] if wkeyboard>>=
if(wkeyboard!=nil && w==wkeyboard)
    return;
@

<<[[wclosewin()]] if wkeyboard>>=
if(w == wkeyboard)
    wkeyboard = nil;
@

\subsection{[[/mnt/wsys/kdbin]]}

<<[[qid]] cases>>=
Qkbdin,
@
<<dirtab array elements>>=
{ "kbdin",		QTFILE,	Qkbdin,		0200 },
@

<<[[xfidopen()]] cases>>=
case Qkbdin:
    if(w !=  wkeyboard){
        filsysrespond(x->fs, x, &fc, Eperm);
        return;
    }
    break;
@

<<[[xfidwrite()]] cases>>=
case Qkbdin:
    keyboardsend(x->data, cnt);
    break;
@

<<function keyboardsend>>=
/*
 * Used by /dev/kbdin
 */
void
keyboardsend(char *s, int cnt)
{
    Rune *r;
    int i, nb, nr;

    r = runemalloc(cnt);
    /* BUGlet: partial runes will be converted to error runes */
    cvttorunes(s, cnt, r, &nb, &nr, nil);
    for(i=0; i<nr; i++)
        send(keyboardctl->c, &r[i]);
    free(r);
}
@

\subsection{Keyboard hide}

% button 6 ???

<<function keyboardhide>>=
/*
 * Button 6 - keyboard toggle - has been pressed.
 * Send event to keyboard, wait for button up, send that.
 * Note: there is no coordinate translation done here; this
 * is just about getting button 6 to the keyboard simulator.
 */
void
keyboardhide(void)
{
    send(wkeyboard->mc.c, mouse);
    do
        readmouse(mousectl);
    while(mouse->buttons & (1<<5));
    send(wkeyboard->mc.c, mouse);
}
@


\section{Font selection, [[rio -f]]}

<<global fontname>>=
char		*fontname;
@

<<[[main()]] command line processing>>=
case 'f':
    fontname = ARGF();
    if(fontname == nil)
        usage();
    break;
@

<<[[main()]] set some globals>>=
if(fontname == nil)
    fontname = getenv("font");
if(fontname == nil)
    fontname = "/lib/font/bit/lucm/unicode.9.font";

/* check font before barging ahead */
if(access(fontname, 0) < 0){
    fprint(STDERR, "rio: can't access %s: %r\n", fontname);
    exits("font open");
}

putenv("font", fontname);
@


\section{Holding mode}

% ??? why someone wants to write holdon? to stop key event to
% go to app?

% also a textual window field?
<<[[Window]] config fields>>=
bool	holding;
@
%old: bool_byte

% main effect! no sending on /dev/cons

<<[[winctl()]] alts adjustments, if holding>>=
if(w->holding)
    alts[WCread].op = CHANNOP;
@



% visual effect

<<[[wsetcursor()]] if holding>>=
if(p==nil && w->holding)
    p = &whitearrow;
@

<<[[wborder()]] if holding>>=
if(w->holding){
    if(type == Selborder)
        col = holdcol;
    else
        col = paleholdcol;
}
@


<<[[wsetcols()]] if holding>>=
if(w->holding)
    if(w == input)
        w->cols[TEXT] = w->cols[HTEXT] = holdcol;
    else
        w->cols[TEXT] = w->cols[HTEXT] = lightholdcol;
@



% for holding mode
<<global holdcol>>=
static	Image	*holdcol;
@

<<global paleholdcol>>=
static	Image	*paleholdcol;
@

<<global lightholdcol>>=
static	Image	*lightholdcol;
@


% how set it up (dev/consctl or special key)

<<[[Wctlmesgkind]] cases>>=
Holdon,
Holdoff,
@

<<[[xfidwrite()]] Qconsctl case>>=
if(strncmp(x->data, "holdon", 6)==0){
    if(w->holding++ == 0)
        wsendctlmesg(w, Holdon, ZR, nil);
    break;
}
if(strncmp(x->data, "holdoff", 7)==0 && w->holding){
    if(--w->holding == false)
        wsendctlmesg(w, Holdoff, ZR, nil);
    break;
}
@

<<[[xfidclose()]] Qconsctl case, if holding>>=
if(w->holding){
    w->holding = false;
    wsendctlmesg(w, Holdoff, ZR, nil);
}
@

<<[[xfidwrite()]] Qconsctl case, if rawon message and holding mode>>=
if(w->holding){
    w->holding = false;
    wsendctlmesg(w, Holdoff, ZR, nil);
}
@




<<[[wkeyctl()]] if holding>>=
if(r==0x1B || (w->holding && r==0x7F)){	/* toggle hold */
    if(w->holding)
        --w->holding;
    else
        w->holding++;
    wrepaint(w);
    if(r == 0x1B)
        return;
}
@
% use = false and = true instead?

% wrepaint because wsetborder will change certain colors now!
<<[[wctlmesg()]] cases>>=
case Holdon:
case Holdoff:
    <<[[wctlmesg()]] break if window was deleted>>
    wrepaint(w);
    flushimage(display, true);
    break;
@


\section{Signals, notes}

% saw some hangup before note when delete a window
% and want to kill associated process

<<global oknotes>>=
char *oknotes[] =
{
    "delete",
    "hangup",
    "kill",
    "exit",
    nil
};
@


% threadmain -> threadnotify(<>, 1);
<<function shutdown>>=
int
shutdown(void *, char *msg)
{
    int i;
    static Lock shutdownlk;
    
    killprocs();
    for(i=0; oknotes[i]; i++)
        if(strncmp(oknotes[i], msg, strlen(oknotes[i])) == 0){
            lock(&shutdownlk);	/* only one can threadexitsall */
            threadexitsall(msg);
        }
    fprint(STDERR, "rio %d: abort: %s\n", getpid(), msg);
    abort();
    exits(msg);
    return 0;
}
@

<<function killprocs>>=
void
killprocs(void)
{
    int i;

    for(i=0; i<nwindow; i++)
        postnote(PNGROUP, windows[i]->pid, "hangup");
}
@


\section{Timer}

% seems only used by wscrsleep so maybe should be put in adv topics,
%  but maybe it's an interesting thing to show

<<global clockfd>>=
fdt	clockfd;
@

<<[[filsysinit()]] set clockfd>>=
clockfd = open("/dev/time", OREAD|OCEXEC);
@

%  -> <>
% used to give current date for files /dev/xxx
<<function getclock>>=
static
uint
getclock(void)
{
    char buf[32];

    seek(clockfd, 0, 0);
    read(clockfd, buf, sizeof buf);
    return atoi(buf);
}
@







% who uses the timer and timerproc?
% wscrsleep


<<struct Timer>>=
struct Timer
{
    int		dt;
    int		cancel;
    Channel	*c;	/* chan(int) */
    Timer	*next;
};
@

<<function timerinit>>=
void
timerinit(void)
{
    ctimer = chancreate(sizeof(Timer*), 100);
    proccreate(timerproc, nil, STACK);
}
@

<<function timerproc>>=
static
void
timerproc(void*)
{
    int i, nt, na, dt, del;
    Timer **t, *x;
    uint old, new;

    rfork(RFFDG);
    threadsetname("TIMERPROC");

    t = nil;
    na = 0;
    nt = 0;
    old = msec();
    for(;;){
        sleep(1);	/* will sleep minimum incr */
        new = msec();
        dt = new-old;
        old = new;
        if(dt < 0)	/* timer wrapped; go around, losing a tick */
            continue;
        for(i=0; i<nt; i++){
            x = t[i];
            x->dt -= dt;
            del = 0;
            if(x->cancel){
                timerstop(x);
                del = 1;
            }else if(x->dt <= 0){
                /*
                 * avoid possible deadlock if client is
                 * now sending on ctimer
                 */
                if(nbsendul(x->c, 0) > 0)
                    del = 1;
            }
            if(del){
                memmove(&t[i], &t[i+1], (nt-i-1)*sizeof t[0]);
                --nt;
                --i;
            }
        }
        if(nt == 0){
            x = recvp(ctimer);
    gotit:
            if(nt == na){
                na += 10;
                t = realloc(t, na*sizeof(Timer*));
                if(t == nil)
                    abort();
            }
            t[nt++] = x;
            old = msec();
        }
        if(nbrecv(ctimer, &x) > 0)
            goto gotit;
    }
}
@






<<global ctimer>>=
// chan<?> (listener = ?, sender = ?)
static Channel*	ctimer;	/* chan(Timer*)[100] */
@

<<global timer>>=
static Timer *timer;
@

<<function msec>>=
static
uint
msec(void)
{
    return nsec()/1000000;
}
@

<<function timerstop>>=
void
timerstop(Timer *t)
{
    t->next = timer;
    timer = t;
}
@

<<function timercancel>>=
void
timercancel(Timer *t)
{
    t->cancel = true;
}
@



<<function timerstart>>=
/*
 * timeralloc() and timerfree() don't lock, so can only be
 * called from the main proc.
 */
Timer*
timerstart(int dt)
{
    Timer *t;

    t = timer;
    if(t)
        timer = timer->next;
    else{
        t = emalloc(sizeof(Timer));
        t->c = chancreate(sizeof(int), 0);
    }
    t->next = nil;
    t->dt = dt;
    t->cancel = false;
    sendp(ctimer, t);
    return t;
}
@





\section{Flushing}

%from docs/man/5/flush
%"When the response to a request is no longer needed, such as when
%a user interrupts a process doing a read (2), a Tflush
%request is sent to the server to purge the pending response."

% so looks like an advanced fileserver feature which is not super needed.


<<[[Xfid]] flushing fields>>=
int	flushtag;	/* our tag, so flush can find us */
// chan<int> (listener = ?, sender = ?)
Channel	*flushc;/* channel(int) to notify us we're being flushed */
bool	flushing;	/* another Xfid is trying to flush us */
@

<<[[xfidallocthread()]] create flushc channel>>=
x->flushc = chancreate(sizeof(int), 0);	/* notification only; nodata */
x->flushtag = -1;
@

<<[[Xfid]] other fields>>=
QLock	active;
@
% seems used for concurrent access by xfidflush

<<[[fcall]] other methods>>=
[Tflush]   = filsysflush,
@

<<function filsysflush>>=
static
Xfid*
filsysflush(Filsys*, Xfid *x, Fid*)
{
    sendp(x->c, xfidflush);
    return nil;
}
@


<<function xfidflush>>=
void
xfidflush(Xfid *x)
{
    Fcall fc;
    Xfid *xf;

    for(xf=xfid; xf; xf=xf->next)
        if(xf->flushtag == x->oldtag){
            xf->flushtag = -1;
            xf->flushing = true;
            incref(xf);	/* to hold data structures up at tail of synchronization */
            if(xf->ref == 1)
                error("ref 1 in flush");
            if(canqlock(&xf->active)){
                qunlock(&xf->active);
                sendul(xf->flushc, 0);
            }else{
                qlock(&xf->active);	/* wait for him to finish */
                qunlock(&xf->active);
            }
            xf->flushing = false;

            if(decref(xf) == 0)
                sendp(cxfidfree, xf);
            break;
        }
    filsysrespond(x->fs, x, &fc, nil);
}
@


% -> <>
<<function filsyscancel>>=
void
filsyscancel(Xfid *x)
{
    if(x->buf){
        free(x->buf);
        x->buf = nil;
    }
}
@

<<[[xfidxxx()]] set flushtag>>=
x->flushtag = x->tag;
@
<<[[xfidxxx()]] unset flushtag>>=
x->flushtag = -1;
@



<<[[xfidread()]] when Qmouse, set alts for flush>>=
alts[MRflush].c = x->flushc;
alts[MRflush].v = nil;
alts[MRflush].op = CHANRCV;
@
<<[[xfidread()]] when Qmouse, switch alt flush case>>=
case MRflush:
    filsyscancel(x);
    return;
@
<<[[xfidread()]] when Qmouse, if flushing>>=
if(x->flushing){
    recv(x->flushc, nil);		/* wake up flushing xfid */
    recv(mrm.cm, nil);			/* wake up window and toss data */
    filsyscancel(x);
    return;
}
@

<<[[xfidread()]] when Qcons, set alts for flush>>=
alts[CRflush].c = x->flushc;
alts[CRflush].v = nil;
alts[CRflush].op = CHANRCV;
@
<<[[xfidread()]] when Qcons, switch alt flush case>>=
case CRflush:
    filsyscancel(x);
    return;
@
<<[[xfidread()]] when Qcons, if flushing>>=
if(x->flushing){
    recv(x->flushc, nil);	/* wake up flushing xfid */
    recv(c2, nil);			/* wake up window and toss data */
    free(t);
    filsyscancel(x);
    return;
}
@

<<[[xfidwrite()]] when Qcons, set alts for flush>>=
alts[CWflush].c = x->flushc;
alts[CWflush].v = nil;
alts[CWflush].op = CHANRCV;
@
<<[[xfidwrite()]] when Qcons, switch alt flush case>>=
case CWflush:
    filsyscancel(x);
    return;
@
<<[[xfidwrite()]] when Qcons, if flushing>>=
if(x->flushing){
    recv(x->flushc, nil);	/* wake up flushing xfid */
    pair.s = runemalloc(1);
    pair.ns = 0;
    send(cwm.cw, &pair);		/* wake up window with empty data */
    filsyscancel(x);
    return;
}
@


<<[[xfidread()]] when Qwctl, set alts for flush>>=
alts[WCRflush].c = x->flushc;
alts[WCRflush].v = nil;
alts[WCRflush].op = CHANRCV;
@
<<[[xfidread()]] when Qwctl, switch alt flush case>>=
case WCRflush:
    filsyscancel(x);
    return;
@
<<[[xfidread()]] when Qwctl, if flushing>>=
if(x->flushing){
    recv(x->flushc, nil);	/* wake up flushing xfid */
    recv(c2, nil);			/* wake up window and toss data */
    free(t);
    filsyscancel(x);
    return;
}
@

\section{Security}

% none :( like X11? worse?
% can draw everywhere ... so can fish applications.
% BUT in the end security in MacOS is just based on trusted
% reviewed apps so they didn't really improved things.

\chapter{Conclusion}











\appendix

\chapter{Debugging}

%\section{9P messages}

% in fsys.c
<<constant DEBUG>>=
#define DEBUG false
@

<<[[filsysinit()]] install dumper>>=
fmtinstall('F', fcallfmt);
@
% fcallfmt defined in fcall.h?

<<[[filsysproc()]] dump Fcall if debug>>=
if(DEBUG)
    fprint(STDERR, "rio:<-%F\n", &x->Fcall);
@

<<[[filsysrespond()]] dump Fcall t if debug>>=
if(DEBUG)
    fprint(STDERR, "rio:->%F\n", fc);
@

%\chapter{Profiling}

\chapter{Error Management}
\label{chap:error}

\section{Error codes}

% fsys.c
<<global Eperm>>=
char Eperm[] = "permission denied";
@

<<global Eexist>>=
char Eexist[] = "file does not exist";
@

<<global Enotdir>>=
char Enotdir[] = "not a directory";
@

<<global Ebadfcall>>=
char	Ebadfcall[] = "bad fcall type";
@

<<global Eoffset>>=
char	Eoffset[] = "illegal offset";
@


% wctl.c
<<global Ebadwr>>=
char	Ebadwr[]		= "bad rectangle in wctl request";
@

<<global Ewalloc>>=
char	Ewalloc[]		= "window allocation failed in wctl request";
@


% xfid.c

<<global Einuse>>=
char Einuse[] =		"file in use";
@

<<global Edeleted>>=
char Edeleted[] =	"window deleted";
@

<<global Ebadreq>>=
char Ebadreq[] =	"bad graphics request";
@

<<global Etooshort>>=
char Etooshort[] =	"buffer too small";
@

<<global Ebadtile>>=
char Ebadtile[] =	"unknown tile";
@

<<global Eshort>>=
char Eshort[] =		"short i/o request";
@

<<global Elong>>=
char Elong[] = 		"snarf buffer too long";
@

<<global Eunkid>>=
char Eunkid[] = 	"unknown id in attach";
@

<<global Ebadrect>>=
char Ebadrect[] = 	"bad rectangle in attach";
@

<<global Ewindow>>=
char Ewindow[] = 	"cannot make window";
@

<<global Enowindow>>=
char Enowindow[] = 	"window has no image";
@

<<global Ebadmouse>>=
char Ebadmouse[] = 	"bad format on /dev/mouse";
@

<<global Ebadwrect>>=
char Ebadwrect[] = 	"rectangle outside screen";
@

<<global Ebadoffset>>=
char Ebadoffset[] = 	"window read not on scan line boundary";
@

\section{[[error()]], [[derror()]]}


<<global errorshouldabort>>=
bool errorshouldabort = false;
@
% who its back to false?


<<[[main()]] error management after everything setup>>=
errorshouldabort = true;/* suicide if there's trouble after this */
<<[[main()]] if initstr or kdbin>>
threadnotify(shutdown, true);
@


<<function error>>=
void
error(char *s)
{
    fprint(STDERR, "rio: %s: %r\n", s);
    if(errorshouldabort)
        abort();
    threadexitsall("error");
}
@
% abort? diff with exit? generate a fault so go in broken state so
% can be debugged!


% main -> ... <- (as ? <- geninitdraw(<>) <- main)
<<function derror>>=
void
derror(Display*, char *errorstr)
{
    error(errorstr);
}
@



\chapter{Utilities}
\label{chap:utilities}

<<function min>>=
int
min(int a, int b)
{
    if(a < b)
        return a;
    return b;
}
@

<<function max (windows/rio/util.c)>>=
int
max(int a, int b)
{
    if(a > b)
        return a;
    return b;
}
@



<<function erealloc>>=
void*
erealloc(void *p, uint n)
{
    p = realloc(p, n);
    if(p == nil)
        error("realloc failed");
    return p;
}
@

<<function emalloc>>=
void*
emalloc(uint n)
{
    void *p;

    p = malloc(n);
    if(p == nil)
        error("malloc failed");
    memset(p, 0, n);
    return p;
}
@

<<function estrdup>>=
char*
estrdup(char *s)
{
    char *p;

    p = malloc(strlen(s)+1);
    if(p == nil)
        error("strdup failed");
    strcpy(p, s);
    return p;
}
@



% not sure why redefine it
<<function isalnum>>=
//@Scheck: not dead, but conflict with the one in ctype.h
int isalnum(Rune c)
{
    /*
     * Hard to get absolutely right.  Use what we know about ASCII
     * and assume anything above the Latin control characters is
     * potentially an alphanumeric.
     */
    if(c <= ' ')
        return false;
    if(0x7F<=c && c<=0xA0)
        return false;
    if(utfrune("!\"#$%&'()*+,-./:;<=>?@[\\]^`{|}~", c))
        return false;
    return true;
}
@
%$



<<function runemalloc>>=
#define	runemalloc(n)		malloc((n)*sizeof(Rune))
@

<<function runerealloc>>=
#define	runerealloc(a, n)	realloc(a, (n)*sizeof(Rune))
@

<<function runemove>>=
#define	runemove(a, b, n)	memmove(a, b, (n)*sizeof(Rune))
@


% cvt ?? 
<<function cvttorunes>>=
void
cvttorunes(char *p, int n, Rune *r, int *nb, int *nr, int *nulls)
{
    uchar *q;
    Rune *s;
    int j, w;

    /*
     * Always guaranteed that n bytes may be interpreted
     * without worrying about partial runes.  This may mean
     * reading up to UTFmax-1 more bytes than n; the caller
     * knows this.  If n is a firm limit, the caller should
     * set p[n] = 0.
     */
    q = (uchar*)p;
    s = r;
    for(j=0; j<n; j+=w){
        if(*q < Runeself){
            w = 1;
            *s = *q++;
        }else{
            w = chartorune(s, (char*)q);
            q += w;
        }
        if(*s)
            s++;
        else if(nulls)
                *nulls = true;
    }
    *nb = (char*)q-p;
    *nr = s-r;
}
@




<<function strrune>>=
Rune*
strrune(Rune *s, Rune c)
{
    Rune c1;

    if(c == 0) {
        while(*s++)
            ;
        return s-1;
    }

    while(c1 = *s++)
        if(c1 == c)
            return s-1;
    return nil;
}
@

<<function runetobyte>>=
char*
runetobyte(Rune *r, int n, int *ip)
{
    char *s;
    int m;

    s = emalloc(n*UTFmax+1);
    m = snprint(s, n*UTFmax+1, "%.*S", n, r);
    *ip = m;
    return s;
}
@





%\chapter{Frame Library}
% really Text Widget

\chapter{Examples of Windowing System Applications TODO}

% statusbar
% winwatch

\chapter{Extra Code}

\ifallcode
#include "Windows_extra.nw"
\fi

%\chapter{Changelog}
%\label{sec:changelog}
% code via make loc = 9500 LOC
% orig nw = 9000, just lpized and few comments, ??? pages pdf
% now: ? LOC ? pages, so added ?? LOE (Lines of explanations)

\chapter*{Glossary}
\label{sec:glossary}
\addcontentsline{toc}{chapter}{Glossary}

\begin{verbatim}
GUI = Graphical User Interface
\end{verbatim}

\chapter*{Indexes}
\addcontentsline{toc}{chapter}{Index}

%\chapter{References} 
\addcontentsline{toc}{chapter}{References}

\bibliography{../docs/latex/Principia}
\bibliographystyle{alpha}

%******************************************************************************
% Postlude
%******************************************************************************

\end{document}
