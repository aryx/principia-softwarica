\documentclass[12pt]{report}
%12pt, twocolumn, landscape

%******************************************************************************
% Prelude
%******************************************************************************
\newif\iffinal
\newif\ifverbose
\finaltrue\verbosefalse % see also other newif in Macros.tex

%------------------------------------------------------------------------------
%history: 
%------------------------------------------------------------------------------

%thx to LP, I changed for the better a few things:
% - removed deadcode (Qnew, threadrforkflag, mainpid, Filsys.pid, ...)
% - reoganized the files to better match the chapters by introducing more files:
%    thread_xxx.c and proc_xxx.c, wm.c, cursor.c, terminal.c, etc.

%thx to codemap/codegraph/scheck:
% - use cg to reduce backward deps (only 6: 0.33%), introduce globals.c/utils.c
%   (harder to understand non layered code)
% - use scheck to remove deadcode, dead prototypes, useless export
%   or mv as forward decl
%   (harder to understand big interface files)
% - use cg to reduce number of globals by moving them closer to the
%   relevant file (or even function), better cluster the code
%   (harder to understand non functional code using lots of globals)

%thx to this manual, I better understand X11, concurrent apps, and fileservers:
% - I had no idea how a windowing system worked so for sure now I understand
%   more. For instance, each window is represented by a DS and a thread! (like
%   an active object). A windowing system is first a display server so
%   it needs a server/clients archi and so thread archi is natural.
% - how to use threads and channels, a bit like Erlang; rio's architecture
%   is very nice
% - master/workers architecture with threads, passing around function 
%   pointers in channels
% - a filesystem server a la Fuse, multithreaded to handle multiple requests
%   (so need request identifiers, and file state Fid in server too)
% - better understand need for raw mode for keyboard input in addition to
%   "edit" mode (with backspace handling and newline only for send)

%thx to rio in ocaml: many things! 
% - difference between mouse counter and mouseclicks queue
% - why pass a channel in mouseread and not a mouse state
% - 

%history LP-ization:
% - skeleton, mostly copy paste of Template.nw skeleton
% - put all content of files in the Extra section, via 'pfff -lpize'
%   which also now split in chunks!
%    * function, global, struct, enum, constant, macro(actually function)
%    * TODO ctor/dtor, dumper
%    * [[xxx]] other fields, [[xxx]] extra fields
%    * TODO thread function, process function, mouse action function
% - read Extra section, identify concepts, first TOC
% - distribute parts of the Extra section in the main file
% - understand main(), LP split main, improve TOC
% - understand main functions, LP split, cluster, improve TOC
% - LP split the structures, use datalog for flow to field info
% - nullify, boolify, errorify, enumify,  typeify,    scheckify, plan9ify
% - aspecify advanced features! remove useless features
% - SEMI add figures
% - SEMI add explanations

%------------------------------------------------------------------------------
% Packages
%------------------------------------------------------------------------------

\usepackage{xspace}
\usepackage{verbatim}
%note: required by 'syncweb -to_tex' for the \t \l \n in this file
\usepackage{fancyvrb}
\usepackage{url}
\usepackage{hyperref}
 \hypersetup{colorlinks=true}
\usepackage[pageref]{backref}
 \def\backref{{\footnotesize cited page(s)}~}
\usepackage{booktabs} 
 \newcommand{\otoprule}{\midrule[\heavyrulewidth]}
\usepackage{graphicx}

\input{../docs/latex/Config}
\usepackage{../docs/latex/noweb}
 \noweboptions{footnotesizecode,nomargintag}
 %note: allow chunk on different pages, less white space at bottom of pages
 \def\nwendcode{\endtrivlist \endgroup}
 \let\nwdocspar=\par
\usepackage{../docs/latex/syncweb}

\hyphenation{name-space name-spaces}
% (not names-pace)

%------------------------------------------------------------------------------
% Macros
%------------------------------------------------------------------------------
\input{../docs/latex/Macros}

%------------------------------------------------------------------------------
% Config
%------------------------------------------------------------------------------
\allcodefalse
% ifallcode is used for:
%  - forward decl, func decl, extern decl, #ifdef, pragmas (stuff in Extra.nw)
%  - obvious locals (s, buf)
%  - ??

\begin{document}
%******************************************************************************
% Title
%******************************************************************************
\title{
{\Huge 
Principia Softwarica: The Plan~9 Windowing System [[rio]]
}\\
{version 0.1}
}

\author{
Yoann Padioleau\\
\texttt{yoann.padioleau@gmail.com}\\
\\
with code from\\
Rob Pike
}

\maketitle 

%\onecolumn
\hrule
\input{../docs/latex/Copyright}
\input{../docs/latex/CopyrightPlan9}
\hrule
%\twocolumn


\begingroup
\hypersetup{linkcolor=blue}
% need to s/onecolumn/twocolumn in report.cls :) for \tableofcontents
\tableofcontents
\endgroup

%******************************************************************************
% Body
%******************************************************************************

\chapter{Introduction}

The goal of this book is to explain with full details the source code of
a {windowing system}.
\n wikipedia uses this term rather than Window System

\section{Motivations}
\label{sec:motivations}

Why a windowing system? 
Because I think you are a better programmer if
you fully understand how things work under the hood,
and one of the first thing you should see on your screen is
a set of {windows}.
The {windowing system} is the program
allowing you to create and manipulate those {windows}.
\n or set of programs (said later)
\n def window (defined later, but most people knows intuitively what it is)

%dup: Graphics.nw
Windowing systems are usually coupled with a {graphics system}
to form a {graphical user interface} (GUI).
\n can have a GUI without a windowing system (said later)
\n windowing system is a kind of GUI, a meta-GUI implementing WIMP (said later)
%history: %dup: Graphics.nw
GUIs, introduced in the 1970's with the Xerox Alto~\cite{alto},
were a vast improvement over {text-based} user interfaces, to
the point where every mainstream operating systems now come with a GUI
(e.g., Microsoft Windows, macOS, or Linux with X~Window).
\n iOS/Android dont have windows. just IM actually, but still GUI (said later)
\n even command line become more powerful with multiple windows (said later)

A windowing system relies on a graphics system to {render}
the graphics of a window on a specific rectangular {surface} of the screen.
However, a window is not just a surface; it is also a process.
\l well not in mini-X, draw, etc. rio is universal! like Unix kernel!
\l we will focus on universal windowing system! more than window.h and draw!
Thus, a windowing system manages not only a set of
surfaces, but also a set of processes.
This is similar to what a kernel does.
\n define graphical app vs window vs client vs process (said later)
%
Moreover, just like the kernel manages the {CPU} and {memory}
and virtualizes those resources shared among multiple processes, 
a windowing system manages the {screen} and {input devices} 
(e.g., the mouse, the keyboard)
and virtualizes those resources shared among multiple windows.
\n could be in Principles, but motiv is "rio is as important as the kernel!"
\n multiplex, virtualization, virtual X, abstraction (said later better)
%
The windowing system is a natural extension of the kernel.
In fact, the need for multiple processes and 
a multi-tasking kernel is less obvious without a windowing system.
Linux offers {virtual consoles} where the user can launch independent
commands, but those consoles are a poor's man windowing system.
\l Emacs also has a windowing system, so screen command line tool, etc


Surprisingly, there is almost no book explaining how a windowing system works,
even though there is a myriad of books on kernels.
I can cite {\em The NeWS book: An Introduction to the
Network/Extensible Window System}~\cite{news-book},
or one chapter of 
{\em Computer Graphics, Principles and Practice}~\cite{cgpp-foley}
dedicated to user interface software.
%
Books on operating systems usually do not even include a
chapter on windowing systems.
%
This is a pity because the windowing system is as important
as the kernel for the user.
\n Per Brinch Hansen was right, windowing systems is a major OS innovation!
\l less complex than kernel, but still not trivial!
\l how to implement a windowing system? coordinate processes, clients/server,
\l  async input from multiple sources, concurrency, graphics, efficient, etc.
\l other motivation is that great concurrent program! learn a lot.
\l  learn many concurrency patterns. Also different programming model! reactif!

Here are a few questions I hope this book will answer:
\begin{itemize}

\item What is the software architecture of a windowing system? 
Is the windowing system a regular program?
How does it have access to the mouse and the screen?
Does it need special privileges from the kernel?
How does it cooperate with the kernel?
\l What kind of program it is? server? kernel? setuid program?
\n Xorg originally was a setuid program doing directly assembly ins/out

\item How does the windowing system manage multiple windows/processes? How
does it communicate with those processes?
\n kernel: syscall interface and time interrupt handler
\n rio: through files! /dev/{cons,mouse} for input and /dev/draw for graphics
\n  (and /dev/winname). syscall (for draw), shared image IPC, pipe IPC (for fs)
\n X11: sockets and client/server archi with loop in server

\item How does the windowing system control access to the screen,
a resource used by multiple windows at the same time?
How does it cooperate with the graphics system?
\n leverage draw and delegate to draw

\item How does the windowing system intercept the
drawing operations done by windows
to make sure they can not draw in other windows? 
How is the screen virtualized?
\n well they can draw in other windows, but have originWindow/clipping/named-image
\n I use window instead of graphical application. More specific.
\l intercept pb maybe too specific to draw/rio; no pb in X~Window.

\item How does the windowing system handle the mouse device? When
are mouse events dispatched to the windows? How does
the windowing system decide which window should receive the mouse
event? 
\l difference between a system mouse event and an application mouse event? 
\n location of coordinate and kind of click

\item How does the introduction of the mouse, graphics, and windows changes
the programming model of an application?
%What are the differences between a command-line application and
%a graphical application beyond the obvious? 
\n more a Graphics.nw question in the end, but because rio/draw is special.
\l diff between graphical application and window application
How can an application {react} to a mouse event?
How can the windowing system itself react to a mouse event?
\l windowing system itself is a graphical program and so use same model

\item How does the windowing system handle the keyboard device? How does it
decide which window should receive a keyboard event? How does
it deliver a keyboard event to this window?
\n focused window policy (or follow-mouse focus)
\n and virtual fs for /dev/cons
\l also raw mode need

\l How demultiplex the screen mouse and keyboard? How virtualize?
\n per-process namespace and fileserver for /mnt/wsys/mouse /mnt/wsys/cons
% need create process, delete process, associate window, 
% send resize/refresh, ... kinda a scheduler
% actually you will learn a lot about concurrent programming! nice side effect.

\item How are overlapping windows managed? Where are stored
the pixels of a window overlapped by another window?
How are those pixels restored on the screen
when an overlapped window is exposed back?
\n actually mostly handled by Graphics.nw
\n X11: expose event, but ugly

\item What are the differences among
a windowing system,
a window manager,
a window compositor,
a window server, and
a desktop system?
\l a display server, graphical shell, display manager, session manager, GUI, ...
\n windowing system is all of that mostly.



\item How does a terminal emulator (e.g., [[xterm]]) work?
What are the standard input and output of traditional 
command-line applications when running under an emulator? 
How does the emulator offer
a backward-compatible environment for those applications?
\l how collaborate with kernel?
\n X11: xterm is huge
\n rio: virtual devices far more elegant than pseudo-devices (pty of xterm)

\item What happens when you type [[ls]] in a terminal emulator?
What are the set of programs involved in such a command? What
is the trace of such a command through the different layers
of the software stack, from the keyboard interrupt to
the display of text glyphs on the screen in the appropriate window?

\end{itemize}
\l How terminal scrolling, text selection, copy/paste, etc (libframe/)
\l How menus? actually a layer. How dialog boxes? widgets?

%tags used in this file for different recurring themes:
 %real-world: mostly talk about X~Window
 %in-plan9: when in general section (e.g., principles), instantiate with plan9
 %rio-reflection: exposing features provided by rio but also used by rio
 %toc: %trans: %dup: etc

\t put in conclusion non-trivial adv algo and data structures seen? see comment
%data-structures (beyond list/hashtbl):
% - circular buffers (Window.mouse.queue) producer/consumer indexes
% - growing arrays (windows (by 1), Window.r, Window.nraw, ...)

%algorithms:

%concurrency patterns:
% - master/workers
% - producer/consumer queue (Window.mouse.queue)
% - send and receive alts =~ select
% - passing channels as parameters
% - procs vs threads
% - cooperative threads and no need for lock! 

\section{The \plan{} windowing system: [[rio]]}
\label{sec:rio}

I will explain in this book the code of the \plan windowing system 
[[rio]]\footnote{\url{http://plan9.bell-labs.com/magic/man2html/4/rio}},
which contains about 10~000 lines of code (LOC).
\n when include libframe/ and libplumb/ and libcomplete/! include full emulator!
[[rio]] is written entirely in C.
\l why called rio? r IO?

%dup: (and adapted) Graphics.nw, intro/motivations
In most operating systems (e.g., macOS, Microsoft Windows),
the windowing system is {\em strongly} coupled with the {graphics system}.
\l and even with the kernel? old Xorg was special. in windows?
%
In \plan, the windowing system [[rio]], and the graphics system,
called [[draw]], are clearly separated; [[rio]] is a user-space
program that relies on [[draw]], which is implemented
as a device in the kernel
(for more information on [[draw]], read the \book{Graphics}).
In \plan, you can run graphical applications with or without [[rio]].
%rio-reflection:
In fact, [[rio]] itself is just a graphical application.
\l call initdraw(), see chapter X.
\n pictures of clock with/without rio (said later)
\l in fact can have recursive!
\l all in userspace, so portable! x86 and ARM!
\l this simplify things but also complicate other I think.


%dup: (and adapted) from Assembler.nw
Like for most books in \principia, I chose a \plan program because
those programs are simple, small, elegant, open source, and they form together
a coherent set.
%history: %dup: (and extended) Graphics.nw
[[rio]] comes from a series of windowing systems designed by Rob Pike:
[[8-1/2]]~\cite{eight-and-a-half}, 
the direct ancestor of [[rio]], running also under \plan;
the ``Concurrent Window System''~\cite{concurrent-window-system}, 
programmed in the Newsqueak language; and 
[[mpx]], the windowing system of the Blit~\cite{blit} machine.
%history:
[[mpx]] was the first windowing system for Unix, and one of the first
windowing system back in 
1982\footnote{See \url{https://www.youtube.com/watch?v=emh22gT5e9k}
for an historical demo of the Blit and [[mpx]], which has
a user interface almost identical to [[rio]].
}.
\n actually GUI of mpx is very similar to rio; not much changed, except color.
\n mpx for multiplex
It was created even before the Macintosh, X~Window, and Microsoft Windows.
\n comment shows the lineage and dates
% Alto -> Pilot? -> Star (commercial system, mouse & windows, desktop metaphor)
%     the electronic office
%      |> Blit, mux ->  ... -> rio
%      |> Smalltalk (or just application on top of Alto?) -> ...
%      |> Macintosh -> Window -> ...
%      |> Lisp Machine? -> W Window -> X~Window
\n so not a bad idea to explain rio; it has street credit like X.


%dup: (and adapted) Graphics.nw
Like many other services in \plan, some of the [[rio]] services
are accessible through files. Indeed, [[rio]] is a graphical application
{\em and} a filesystem.
%
To understand why a part of [[rio]] is implemented as a filesystem, you need
(1) to have a general idea on how to implement a windowing system,
and (2) be familiar with some of the advanced features of the
\plan kernel.

Regarding the first point, at a high level,
a windowing system is a program 
that uses
the mouse (via [[/dev/mouse]] under \plan), 
the keyboard (via [[/dev/cons]]), and 
the screen (via [[/dev/draw]]).
%
However, an application
running in a window
is not different; such an application also wants to
use the mouse, the keyboard, and the screen.
%
Thus, a windowing system can be implemented simply
as a {\em multiplexer}; the windowing system can use
the {\em physical devices} (managed by the kernel)
and serve {\em virtual devices}
to the multiple windows running under it\footnote{For more information, 
see Section~\ref{sec:windowing-system-api} and especially
Figure~\ref{fig:rio-multiplexer}.
}.


Regarding the second point, the \plan kernel has a few
original features that makes it easy to implement 
virtual devices served by programs in user space. Those features are
the {\em per-process namespace}, the {\em union-mount}, and
the {\em file-server protocol 9P}
(see the \book{Kernel} for more information on those features,
or the two \plan articles~\cite{plan9, namespaces-plan9},
which contain both good introductions to those features).
%
With [[rio]], the virtual devices are accessible under [[/mnt/wsys/]]
(e.g., [[/mnt/wsys/mouse]], [[/mnt/wsys/cons]]), 
%
but also under [[/dev/]] 
(e.g., [[/dev/mouse]], [[/dev/cons]]), 
thanks to the union-mount. 
%
Thanks to the per-process namespace, the applications
running under [[rio]] {see} a different [[/dev/mouse]], [[/dev/cons]],
and could see a different [[/dev/draw]]\footnote{For [[/dev/draw]],
the [[draw]] device can already multiplex the screen among 
multiple clients (in [[/dev/draw/1/]], [[/dev/draw/2]], etc).
There is no need for a virtual [[/dev/draw]].
However, the ancestor of [[rio]], [[8-1/2]]~\cite{eight-and-a-half}, 
was serving a virtual [[/dev/draw]] device file, which was more elegant
but also more inefficient.
For more information, see Section~\ref{sec:winname}.
}.
%
Finally, thanks to 9P, all those virtual device files can be served 
by a single user-space program: [[rio]].
%from rio slides:
% "Each window mounts a different root of a distinct file system implemented
%  by Rio, containing an identical-looking simulation of the standard 
%  device file set for display, mouse, and keyboard."
\l again, if not clear, do not worry, explain more later, and can namespace.ps


A nice side effect of the multiplexer approach used by [[rio]] is that
[[rio]] can run under itself (see Section~\ref{sec:recursive-rio}).
%
This is useful for development and debugging purposes.
\n another nice side effect is that same app can run with or without rio (later)
%
Moreover, because you can export filesystems through
the network in \plan, [[rio]] is also a 
{networked windowing system}, similar to X~Window
(even though the code of [[rio]] does not include a single line of
code related to networking).
%
Thus, in \plan, programs running on one machine
can have their window displayed on another machine.

%pro: not as used as X Window. Still production quality.
% In fact first windowing system for Unix! 
% and very interesting program. You will learn about concurrency
% a lot, many concurrency patterns. Inspiration for Go by Google!

\section{Other windowing systems}
\label{sec:other-windowing-systems}

Here are a few windowing systems that I considered for this book,
but which I ultimately discarded:
\begin{itemize}

%history:
\item Xorg\furl{http://xorg.freedesktop.org}, which I mentioned already
in the \book{Graphics}, 
%dup: Graphics.nw
is the most popular open-source implementation of 
the X~Window System~\cite{x-window},
a windowing system (and a graphics system) designed in the 1980's at MIT.
%
However, its codebase is enormous. In fact, the whole system is divided
in hundreds of repositories\furl{https://cgit.freedesktop.org/xorg}
to better handle its complexity. One of this repository,
[[xserver]]\furl{https://cgit.freedesktop.org/xorg/xserver/},
which contains the code of the {display server},
\l and window {compositor}, but then need define compositor here?
has already more than 500~000 LOC. 
\n KDrive (Xkdrive and Xfbdev) are small actually; but still need libX11/...
This does not even include the code of the
{window manager} (e.g., [[twm]] with 17~000 LOC),
\n can have many window managers under X11; policy-free server.
the {terminal emulator} (e.g., [[xterm]] with 80~000 LOC),
\n rxvt is 37 000 LOC so similar (said later)
or the libraries required by clients
to communicate with the display server (e.g., [[Xlib]] with 150~000 LOC).
Xorg, in total, contains more than two orders of magnitude more code 
than [[rio]].


Part of the reason for the enormous size of Xorg is that
Xorg supports many graphic cards,
\l (with hardware acceleration),
many monitors, many input devices, and many extensions (e.g., 3D operations).
\n XRender, XRandR, Shape, etc also many optimisations.
%
Another reason is that X~Window is an old program;
programmers extended X~Window for more than 30 years now.
Programmers added many extensions while still being forced to remain
backward compatible with applications designed in the 1980's. 

%dup: Graphics.nw
X~Window defines a {communication protocol}, X11, for a 
networked client/server architecture.
Client applications must use {\em sockets} to connect to the display server.
%
Unfortunately, the set of mechanisms used by clients to interact
with the screen, mouse, or keyboard is quite different from
the one offered by the kernel, for instance, the simple opening of 
files in [[/dev/]] such as  [[/dev/mouse]]. 
In some sense, X~Window {\em masks} the features of the underlying kernel.
%
On the opposite, [[rio]]
is {\em transparent}\cite{window-system-should-be-transparent}
and instead {generalizes} the services offered by the kernel, for instance,
with the virtual device file [[/dev/mouse]].
\n not super clear for now (but better explained later)
%
Of course, the use of sockets in X~Window allows client applications
to display their result on another machine on the network.
However, this is also possible with [[rio]], for free, thanks to the generic
9P protocol.
\t cite 9P?
\l still a /dev/cons, /dev/draw, /dev/mouse
\l x86 specific? X on Raspberry Pi? 
\n Raspberry Pi seems to finance wayland  and also bare metal Squeak.

%dup: Graphics.nw, intro/motiv intro/rio
Finally, the graphics and windowing system parts of Xorg are strongly coupled;
%
this coupling makes the whole system harder to understand than [[rio]]
and [[draw]], which we can study separately.


\item Wayland\furl{https://wayland.freedesktop.org/} is a protocol, 
similar to X11,
specifying the communication between a display server, called
a Wayland {\em compositor}, and a set of {local} clients.
Weston\furl{https://cgit.freedesktop.org/wayland/weston/}
is a reference implementation of a Wayland compositor.
%
Wayland and Weston grew out of the frustation of some
developers of Xorg with the complexity of X~Window, as well as
the difficulty for X~Window to support the modern needs of a windowing
system: 
transluscent windows, 
drop shadows on the window's border as in macOS Aqua,
fancy window-switcher such as macOS Expose, etc.

Fortunately, during the last ten years, lots of the code of
Xorg got gradually moved out of the display server and
put either in the Linux kernel (e.g., the resolution setting
of the screen, called KMS for kernel mode setting, or the ability
to interact directly with the graphics hardware, called DRM
for direct rendering manager),
or in external libraries (e.g., 
Cairo for an advanced drawing API, 
or [[libinput]] for a generic interface to the input devices).
%
What remains in Xorg is an old drawing API, the ability
to have remote applications, and a display server that is backward
compatible with old applications.
\l Useless intermediate. 
%
The developers of Wayland used this opportunity to redesign
from scratch a modern windowing system, while reusing lots of the
code that was now outside Xorg.

There are many differences between Wayland and X11.
For instance, Wayland does not specify any drawing API. Instead,
it assumes the clients do their own graphics rendering by using
libraries such as Cairo on locally-shared image buffers.
Weston then just uses those shared buffers
and composes them together (hence the use of the word {``compositor''}),
while possibly applying effects during the image composition
such as transluscence.
%
The use of locally-shared buffers means that 
Wayland does not support remote applications. Fortunately, most users now
run and display their applications on the same machine.
\l footnote? well except for the Web, so maybe remote app is important
\l  and done with lots of complexity, so maybe better to go back to rio model!
\l not network transparent. No remote cos no drawing API (but can do VNC-like)
\n need rewrite X11 apps? not if they're using GTK/QT. Already compatible!
\n still need xterm? actually has one (LOC?)

The code of Wayland and Weston is far smaller than Xorg:
120~000 LOC (excluding the tests).
However, this is still one order of magnitude more code than [[rio]].
%
Moreover, Weston relies on many libraries (e.g., Cairo, [[libinput]]),
as well as lots of code and subsystems of the Linux graphics stack
(e.g., KMS, DRM, GEM, fbdev, evdev);
this would add up to lots of code to explain.
\l  a pile of layers with the kernel, soft archi diagrams looks complicated
%https://drewdevault.com/2017/06/10/Introduction-to-Wayland.html

\item Nano-X\furl{http://www.microwindows.org/}
(previously known as MicroWindows) is a windowing system and graphics system
designed originally for small devices such as PDAs.
\n started in 1999. No news since 2011 though in the repository. Still run?
\n was mentioned by tinyGL, and also by picoGUI.
%
It started as a fork of Mini-X, a graphics system for MINIX.
Both Mini-X and Nano-X are modeled after X~Window, and offer
an API similar to Xlib.
\n Nano-X has also an API similar to the one in Microsoft Windows
Nano-X added a client/server architecture to Mini-X, as well
as a window manager, to become a full windowing system.

Nano-X is highly portable, with support for many machines 
(e.g., x86 desktops, MIPS machines, ARM embedded devices).
Moreover, Nano-X does not require any external graphics library; 
it just requires an access to the framebuffer from the Linux kernel.
It is far smaller than Xorg: 80~000 LOC (excluding the tests,
application demos, the Win32 API, and the fonts).
%
However, this is still bigger than the code of [[draw]] and [[rio]]
combined.
\n which moreover can be studied separately (but said elsewhere)

\end{itemize}

\l lots of other windowing systems, see the comment in the .nw
%industry:
% - Windows DWM
% - macOS Quartz compositor (innovative: Expose, window closing effects, etc)
% - Android SurfaceFlinger (but no real windows on the screen)
% - Qnx photons, 1.44MB demo disk! even with web browser!
%history:
% - Alto, started in 1973, had overlapping windows, mouse, fonts, etc
% - Smalltalk?
% - Blit (mux -> rio/draw), 1982
% - NeWS, Network/Extensible Window system =~ X + Display Postscript, 1989
%   https://books.google.com/books?id=DdbvBwAAQBAJ
%other:
% - MIR, very similar to Wayland; used only by Canonical.
%   but seems now abandonned
% - nuttx has some graphic and windowing stack apparently too!
%   http://nuttx.org/doku.php?id=documentation:nxgraphics
% - HelenOS Gui? https://www.youtube.com/watch?v=ZjqYRv2xOSw&feature=youtu.be
%   code?
% - pico GUI? \furl{http://picogui.org/} seems similar to Nano-X.
%   no news since 2003 on website and repository
%   mentions microwindows on history document, saying he should have use it
% - Kolibri/MenuetOS, also floppy disk with full GUI, but all in assembly
% - berlin? dead?
% - http://ignorethecode.net/blog/2009/04/22/oberon/
% - redox in rust has a windowing system apparently, Orbital?
% - arcan/durden https://arcan-fe.com/ mix of game engine, display server
%   and streaming multimedia engine, inspired by plan9 too:
%   https://arcan-fe.com/2017/04/17/one-night-in-rio-vacation-photos-from-plan9/
%semi windowing systems (single client with multiple windows; no clients/server)
% - Mini-X (see Graphics.nw)
% - TWIN   (see Graphics.nw)
%text-based windowing systems or libraries:
% - newt?
% - stuff used by Turbo Pascal? had dialog boxes!
% - twin (another one)
%mini:
% - mgr http://www.hack.org/mc/mgr/, but very old, and restrictive license
% - Xynth and Xfast
% - Xorg contains also a few mini server to prototype thinhs (written by 
%   Keith packard again)
%window managers: (still rely on X11)
% - xmonad
% - efuns/gwml
% - tinyWM, 50 LOC http://incise.org/tinywm.html
% - another claimed to be minimal WM http://www.cc.rim.or.jp/~hok/heliwm/
%research:
% - 10/gui http://ignorethecode.net/blog/2009/10/13/10_gui/
% - xmonad in Coq, hmmm
%   http://www.staff.science.uu.nl/~swier004/Publications/XmonadInCoq.pdf
% - 3D windowing systems? Looking glasses of Sun?

% nice list of X wannabe killers:
% http://linuxfinances.info/info/xbloat.html

%nice set of screenshots of past famous GUIs:
% http://toastytech.com/guis/
% http://toastytech.com/guis/guitimeline.html

% history me: 
%  - tos, sega yeno, atari GEM, dos, windows 3.11
%  - one Linux terminal
%  - job control shell! (otherwise multi tasking OS but just one term so ...)
%  - multi terminal Alt-Fx on Linux
%  - screen or tux programs (actually I never used but many people do)
%  - X11 and xterm with as many windows as you want!
%  - FVWM fast key to many terminals
%  - Emacs eshell fast key to many terminals
%  - virtual desktops
%  - macOS expose! bird's eye view (great feature)

%maybe not great, but rare example of blogs on how to make a windowing system:
% http://www.trackze.ro/windowing-systems-learning-by-example-introduction/
% http://www.trackze.ro/wsbe-9-coup-de-grace/

% concurrent programming in ML contain the description of a windowing system

\section{Getting started}
\label{sec:getting-started}

%dup: (and adapted) Assembler.mw
To play with [[rio]], you will first need to install
the \plan fork used in \principia (see \urlinstall).
Once installed, you can test [[rio]] under \plan
by executing the following commands:

\begin{verbatim}
1   $ bind -a '#v' /dev
2   $ vga -l 640x480x8 
# screen should change layout
3   $ bind -a '#i' /dev

4   $ rio
\end{verbatim}
% x86 for vga part
\t need also /mnt/temp for pipes, and other stuff (use ramfs for now, ugly)

Then, if you right-click with the mouse somewhere on the screen,
you should see graphics similar to the one in Figure~\ref{fig:rio-start}.
\n need mouse with 3 buttons (said later)

\begin{figure}\begin{center}
\includegraphics[width=8cm]{rio-start}
\end{center}
\caption{The screen, just after [[rio]] started and the user right-clicked.}
\label{fig:rio-start}
\end{figure}
\n terminal window? not yet! minimal spirit for now!
\t explain QEMU? or even simpler, remove it! via gimp scriptfu?


Line~1 through 3, above, install the graphics system of \plan ([[draw]])
and configure it to run at the [[640x480x8]] resolution 
(See the \book{Graphics} for more information on [[draw]]).
%
Line~4 then executes [[rio]], which should take over
the screen to create the graphics shown in Figure~\ref{fig:rio-start}.


\section{Requirements}

%dup: from Assembler.nw
Because most of this book is made of C source code, 
you will need a good knowledge of 
the C programming language~\cite{k-r} to understand it.
%
Moreover, because [[rio]] relies on many advanced features
of the \plan kernel, and builds upon the \plan graphics system [[draw]],
I strongly suggest you to read the \book{Kernel} and \book{Graphics}
before reading this book.
%
Note that [[rio]] is implemented as a filesystem in user space, 
and uses the protocol 9P to communicate with the kernel. 
Thus, it can also be useful to read the \book{Network}, which describes 9P.
\t actually now in Libcore
In the same way, I also suggest you to read the \book{Libcore},
which explains the thread library, which is heavily used by [[rio]].

\begin{table*}[tbh!]
\begin{center}
\begin{tabular}{lp{7cm}p{4cm}lp{33mm}}
\toprule
{\bf Book} & {\bf Concepts} & {\bf Device Files} & {\bf Codes} & {\bf Headers} \\
\otoprule
\nobook{Graphics} & 
display server, drawing API, shared image, overlapping layers & 
[[/dev/draw]] [[/dev/winname]] [[/dev/vgactl]] & [[#i]] [[#v]] &
[[draw.h]] [[window.h]] [[mouse.h]] [[keyboard.h]] \\

\nobook{Kernel} &
filesystem, device, pipe, console, per-process namespace, union-mount, shared memory &
% system call
[[/dev/cons]] [[/dev/consctl]] [[/dev/mouse]] [[/dev/pipes/]] & [[#c]] [[#m]] [[#|]] &
[[syscall.h]] \\

\nobook{Libcore} &
channel, proc, thread, message, message queue &
% system call
& &
[[libc.h]] [[thread.h]] \\

\nobook{Network} &
remote procedure call (RPC), filesystem in user space, 9P protocol &
[[/srv]] & [[#s]] &
[[fcall.h]] \\


\bottomrule
\end{tabular}
\end{center}
\caption{\principia books related to the \nobook{Graphics}.}
\label{tab:principia-books}
\end{table*}
\l also API (mount, bind, alt, read9pmsg, fcallfmt, sendp, threadcreate, proc)? 
\l data structures?

Table~\ref{tab:principia-books} presents
the list of related \principia books,
as well as the concepts, devices, and header files used by [[rio]]
and introduced by those books.
%
The most important book in Table~\ref{tab:principia-books} 
is the \nobook{Graphics}.
%
Regarding the three other books, you can probably understand most of the code
in the following chapters without reading those books if you read at least
{\em Plan 9 from Bell Labs}~\cite{plan9},
as well as {\em The Use of Name Spaces in Plan 9}~\cite{namespaces-plan9};
those two articles introduce many of the concepts listed 
in Table~\ref{tab:principia-books}.


As I said in Section~\ref{sec:motivations},
there are very few books explaining
the concepts, theories, and algorithms used in windowing systems.
%dup: (and extended) intro/motivations
I can cite {\em The NeWS book}~\cite{news-book},
{\em Methodology of Window Management}~\cite{methodology-window-management},
and one chapter of 
{\em Computer Graphics, Principles and Practice}~\cite{cgpp-foley}.
\l Introduction to window management, Steinhart, 320p SIGGRAPH 1990 course note
\l  (but cant find it)
\l Oberon? 
\l X~Window series of OReilly is more on the protocol and API
\l http://keithp.com/~keithp/talks/Xarchitecture/Talk.htm
\l nothing since 1990?
Those books are useful, but they are not mandatory to understand this book.

%dup: (and changed a lot) from Graphics.nw
If, while reading this book,
you have specific questions on the interfaces of [[rio]],
or on the API used by [[rio]], you can find answers in certain manual pages.
%
Those pages are located under [[docs/man/]] in my \plan repository.
Here is a list of pages relevant to [[rio]] and a short description
of their content:

\begin{itemize}

\item [[1/rio]]: the command-line and graphical user interface of [[rio]]

\item [[4/rio]]: the filesystem interface of [[rio]]

\item [[2/draw]]: the [[draw.h]] API
\t a few changes though, like screen -> view.
%\item [[2/graphics]]: the big picture (no pun intented)

\item [[2/window]]: the [[window.h]] API
\n so I was right to create this file! there was a different man page!

\item [[2/keyboard]]: the [[keyboard.h]] API
%\item [[3/cons]]: the [[/dev/cons]] interface

\item [[2/mouse]]: the [[mouse.h]] API
%\item [[3/mouse]]: the [[/dev/mouse]] interface

\item [[2/thread]]: the thread and channel library 
%\item [[2/event]]: event API, an alternative to threads and channels

\item [[5/0intro]]: the 9P protocol
\l and man/5/* 

\end{itemize}

Finally, the [[windows/docs/]] directory in my \plan repository
contains documents describing either [[rio]]~\cite{rio-slides}
or ancestors of [[rio]]~\cite{eight-and-a-half, concurrent-window-system,
window-system-should-be-transparent, blit}.
%dup: Graphics.nw
All those documents are useful to understand some of the 
design decisions presented in this book.
\l also to learn about GUI, namespaces, some implementation details.

\section{About this document}
#include "../docs/latex/About.nw"

\section{Copyright}
\input{../docs/latex/CopyrightPlan9Text}

\section{Acknowledgments}

I would like to acknowledge of course the author of
[[rio]], Rob Pike, 
who wrote in some sense most of this book.






\chapter{Overview}

%trans: %dup: Assembler.nw
Before showing the source code of [[rio]] in the following chapters,
%toc: Assembler.nw
I first give in this chapter an overview 
of the general principles of a windowing system.
%
I also describe quickly the graphical user interface of [[rio]],
as well as its filesystem interface in [[/mnt/wsys/]].
%
I also show the code of a toy application running under [[rio]].
% and using functions from [[draw.h]] and [[mouse.h]].
\n graphical application vs window application (said later)
\l Different model! Interactive! Reactive!
\l using threads, so good first step for code of rio
%dup: Assembler.nw
Finally, I define terms, explain how the code is organized, 
and more generally give the background necessary
to understand the code I will show later.

\section{Windowing system principles}
\label{sec:principles}

A {\em windowing system} is a program (or a set of programs)
with a {graphical user interface} (GUI) allowing the user to
create and manipulate {windows}.
\l def of GUI? program with graphics and interactive with mouse?
A {\em window} is a usually rectangular and resizeable
{surface} of the screen containing the GUI of another program.
%
Just like the kernel is a {\em meta-program}, that is 
a program allowing the user to run other programs, 
the windowing system is a {\em meta-GUI}, that is
a graphical user interface allowing the user to run other
graphical user interfaces.
%without: ??? mess, need coordinator intermediate, like for kernel
% to virtualize and have independent stuff

In addition to windows, a windowing system traditionally uses 
{\em icons}, 
{\em menus}, and a
{\em pointer}, or {\em WIMP} for short.
\n actually rio just WMP (said below)
Note that windowing systems are not the only kind of meta-GUIs.
For example, the user interface of phones running under iOS or
Android do not have any windows. Moreover, the user can use
multiple pointers at the same time through his multiple fingers.
\n has unresizable tabs instead of windows.
%
Those interfaces are called {\em post-WIMP} interfaces.

%\subsection{Desktop system}
%\subsection{Desktop shell}
A {\em desktop system} is a kind of windowing system
promoting the following metaphor: 
{a windowing system is like a physical desk in an office}.
%
A desktop system usually includes applications
and icons mimicking the real-life objects of an office:
a garbage can, 
folders, 
a clock,
a rolodex,
an alarm,
a calendar,
etc.
%
The window is then like a paper on a desk; it can be moved
around, or stacked on top of other papers. Each window represents
a separate activity.

The Xerox Star~\cite{xerox-star} was the first desktop system.
%real-world:
Desktop systems are the most popular windowing systems
(e.g., Microsoft Windows, macOS),
because they offer a familiar interface to the user.
%
On Linux, the desktop systems 
KDE\furl{https://www.kde.org/} and 
GNOME\furl{https://www.gnome.org/}
are implemented as a set of applications
\l and a special window manager
on top of X~Window.
%in-plan9:
\plan does not have a desktop system; [[rio]] does not
use any icon and does not promote an office metaphor. [[rio]] is
not a WIMP, just a WMP.
\l why? simpler, minimalst, non-essential anyway.



\begin{figure}[!]\centering
\begin{verbatim}
+-------------+ +-------------+ +-----------+
|   Window    | |   Window    | |  Textual  |
|application 1| |application 2| |application|
+------+--^---+ +-+---^-------+ +----^------+
       |  |       |   |              |
+------+--+-------+---+--------------+------+
|      |  |       |   |          +---v----+ |
|      |  +-------+---+----+----->Terminal| |
|   +--v----------v+       |     |emulator| |
|   |    Window    <-------+-----+        | |
|   |  compositor  |       |     +--------+ |
|   +--------------+     +-+------------+   |
|   |   Display    |     |    Window    |   |
|   |    server    <-----+   manager    |   |
|   +----+---------+     +----^-----^---+   |
|        |    Windowing system|     |       |
+--------+--------------------+-----+-------+
+--------v--------------------+-----+-------+
|        |         Kernel     |     |       |
+--------+--------------------^-----^-------+
+--------v---+          +-----+-+ +-+-------+
|  Display   |          | Mouse | |Keyboard |
|   device   |          |device | | device  |
+------------+          +-------+ +---------+
\end{verbatim}
\caption{Components of a windowing system.}
\label{fig:window-system-components}
\end{figure}
\l could also put libs, at the top, like Xlib, provides nice connection API
\n could have input manager
\l desktop system then is bigger; just windowing systems with special programs


A windowing system has many {components}, which sometimes
can even be separate programs. 
\n hence  'set of programs' above
I mentioned them already in Section~\ref{sec:other-windowing-systems}:
the {display server}, the {window compositor}, the {window manager}, and
the {terminal emulator}.
%
Figure~\ref{fig:window-system-components} 
presents the relationships between those components.
%trans:
Figure~\ref{fig:window-system-components} shows also four important
{layers}: the hardware at the very bottom, the kernel and windowing system 
in the middle, and the applications at the top.
\l layer confusing with draw layer?
%
Moreover, in this book, I divide applications in three different categories:

\begin{itemize}

\item {\em Textual applications}: those are command-line
programs, which just read and output text (e.g., [[grep]]).

\item {\em Graphical applications}: those are programs
drawing on the whole screen and using the mouse (e.g., the Doom video game)

\item {\em Window applications}: those are programs
drawing and using the mouse inside a window
(e.g., the Microsoft minesweeper video game)
\l and possibly use multiple windows

\end{itemize}
\n also Web application

A windowing system is mostly concerned with the last category,
but it usually offers a way to run in a special environment
the other kinds of applications. For instance, the terminal emulator
in Figure~\ref{fig:window-system-components} allows to run
textual applications.

%toc:
The following sections will explain the relations between
the different components in Figure~\ref{fig:window-system-components}
as well as the role of each of those components. I will also
quickly describe how those components are implemented in X~Window and [[rio]].
\l different soft archi possible.
But before, I need to better characterize what is a window.


\l imagine how would you code a windowing system? not that easy.
\l multiplexer!

\subsection{The window}

A window is multiple things at the same time.
First, it is a {delimited surface} of the screen
containing the visual {\em output} of a running program\footnote{
The term ``window'' is actually a misnomer~\cite{pike-layers}. 
In graphics terminology, such an output is called instead the
{\em viewport}.}.
\l but in {pike-window-transparent} he says that "apt word because in
\l  a transparent windowing system, it is through windows that you see
\l  the operating systems and its programs"
\n he cites NewMan-Sproull-79; a window is actually the whole virtual world.
\l it is a {dynamic picture} representing a separate activity.
\n Magic Ink! Bret Victor.
%
It is also an {interactive region} of the screen responding to {\em input}
from the mouse; when the mouse hovers {inside} a window, 
the underlying program can {react}.
\l ``rectangular area which maintains input/output  context for a 
\l  particular program or graphics application.''
%
Finally, it is a {container} that can be manipulated
from the {outside}; a window can be moved, resized, closed, etc.
\n by window manager, via decoration/border (said later)
\l Like OS/shell; a Graphical shell!


A window surface is made of multiple elements,
as shown in Figure~\ref{fig:window-elements}.
Here is the list of those elements as well as their functions:


\begin{itemize}

\item {\em Window content}: contains the GUI of the underlying running program


\item {\em Window border}: allows the user to move or resize the window
\n generated by window manager (said later)
\l also clear boundary with other windows/programs (drop shadows at least)

\item {\em Title bar}: contains usually the name of the program
\l can be changed by program itself, /dev/label

\item {\em Windowing system icons}: allows the user to close, expand, or hide
the window

\end{itemize}

\begin{figure}[!]\centering
\begin{verbatim}
+------------------------------------+
|+--------------------+----icons----+|
||                    |     +--+ \ /||
||       Title Bar    |     |  |  X ||
||                    | --- +--+ / \||
|+--------------------+-------------+|
||                                  ||
||                                  ||
||                                  ||
||          Window Content          ||
||                                  ||
||                                  ||
||                                  ||
||                                  ||
|+----------------------------------+|
+-----------Window border------------+
\end{verbatim}
\caption{Window elements.}
\label{fig:window-elements}
\end{figure}


Only the first element is mandatory; the other elements,
forming the {\em window decoration}, are all optionals.
\n done by window manager (said later)
%in-plan9: %dup: overview/principle (for icon part)
For instance, in [[rio]], windows have a border but they have
neither a title bar nor icons 
(see Figure~\ref{fig:rio-gui}). % in Section~\ref{sec:rio-gui}
\n sometimes even no border; everything done via keyboard


%in-plan9:
In [[rio]], as well as in many other windowing systems,
windows can {overlap} each other. Thus, 
windows can be {\em stacked} {on top of each other}, 
hiding the pixels of the windows below.
\n how to restore those pixels (explained later)
%
In other windowing systems, windows instead are {\em tiled} automatically
{next to each other} (or hidden completely).
%real-world:
Finally, in recent windowing systems, windows can be
{\em composited} {with each other}; 
%dup: intro/other-systems
the windowing system composes the images representing the different windows
together and can apply special effects, for instance,
transluscence or drop shadows as in macOS\footnote{Another 
nice effect is to zoom out and tile automatically
all the images of the windows, as in macOS Expose,
to get a bird's eye view of all the windows.}.
\n even dynamic!
\l thus combining some advantages of tiling and stacking
\l in the end tiling, overlapped, composited


\subsection{Display server}
\label{sec:display-server}
\l and communication protocol

%trans: now that window clearer, I switch back to Figure X and its components.

%trans:
The first component of a windowing system is the display server.
%dup: (a bit changed) Graphics.nw
A {\em display server} is a {graphics system} that accepts {drawing commands}
from multiple {\em clients} via a {\em communication protocol},
and then translates those commands into instructions to the graphics card.
%http://tech.slashdot.org/story/14/06/19/1317227/x-window-system-turns-30-years-old?utm_source=slashdot&utm_medium=facebook
%"A server lets clients access a shared resource. On a file server, it's
%storage. On a web server, it's documents. On a compute server, it's
%processing. On an X server, the shared resource is the display, and
%clients are given access to it."
%
The display server is responsible for all the visual {output}
of all the applications, as well as the
visual output of the windowing system itself (e.g., the window decorations, 
the background image).
\n the system menu, the cursor
%
This is why in Figure~\ref{fig:window-system-components}, 
the applications, window manager, and terminal
emulator are all connected to the display server 
(through the window compositor, which I will explain in
Section~\ref{sec:compositor}).
%dup: Graphics.nw (overview/principles/display-server)
A display server uses a client/server architecture because
it needs to serve many clients: 
the multiple processes corresponding to the multiple windows on the screen.
\n and rio itself when display server is outside windowing system

\t Can have graphics system without client/server archi, direct, but
\l if want universal windowing system, then need multiple clients in
\l independent processes, and so need server. mini-X is not universal. draw is!

\t Some graphics system allow to create windows, e.g., draw,
\l but if does not have window manager, app must implement one. 


%real-world: %dup: (changed, not-coupled) intro/motiv intro/rio intro/other
In X~Window (as well as in most windowing systems),
the display server is an integral part of the windowing system.
%
Moreover, the communication protocol of X~Window, X11, 
is used not only to carry drawing
commands from the clients, but also to relay input {events} from the devices
to the clients.
%
In that case, the display server acts also as a {\em window server}
as it manages all the communications with the windows.
\l input and output
\n display server vs window server vs compositor

%in-plan9:
In \plan, the display server [[draw]] is outside [[rio]], in the kernel,
and serves only the drawing commands from the clients.
The communication protocol of [[draw]] is described in the
\book{Graphics} (and involves the [[/dev/draw/x/data]] files).
\l in rio just output; for input use traditional (virtual) devices.
%dup: (and adapted) Graphics.nw   intro/motiv intro/rio intro/...
%In \plan, you can run graphical applications with or without
%the windowing system; the graphics system and windowing system
%are clearly separated.
\l (Alto was mixing? Smalltalk was? Blit was?)
\l rio itself use comm protocol with draw to display things!

\l clients/server archi. (=> threads?)


\subsection{Window compositor}
\label{sec:compositor}

A {\em window compositor} is an optional component of a windowing system 
%real-world: 
(found in modern windowing systems)
allowing windows to be {\em composited} with each other.
%dup: (and adapted) intro/other-systems overview/principle/window
Each window application draws first in an {\em off-screen image}.
Then, the compositor composes all those images together while
applying possibly advanced effects such as transluscence or drop shadows. 
\n 3d effects, scaling (Expose)
\l Policy on how to compose?
Finally, the composition is sent to the display server,
which outputs the result on the screen.
%
This is why in Figure~\ref{fig:window-system-components}, 
the window applications are all connected first to the compositor.
%
The compositor and display server are usually tightly coupled,
hence the direct contact between the two respective boxes in 
Figure~\ref{fig:window-system-components}.

%real-world: X window? not really, this is why Wayland?
% macOS first one? and then with Expose got tiling, stacking, compositing!
\n tiling, stacking, or compositing (said before)

%in-plan9:
In [[rio]], which favors a minimalist approach, there is no compositor;
each window application is connected directly to the 
display server ([[draw]]).
That means [[rio]] does not offer special effects such as transluscence, but
it would not be difficult to extend [[rio]] to include a compositor
to support those effects.
\l just change /dev/winname to off-screen image


\subsection{Window manager}
\label{sec:window-manager}

The {\em window manager} is the component
responsible for all the user {inputs} to the windowing system:
inputs from the mouse, the keyboard, or other devices.
\l also window decoration, placement
%
Those inputs can lead to the 
moving, 
resizing, 
opening, 
closing, or 
hiding
of windows, hence the term ``window manager''.
%
Indeed, the action of the mouse over the window decorations can trigger
the changes to the windows listed above.
%
In fact, the window manager is also responsible for
the display of those window decorations.
%
This is why in Figure~\ref{fig:window-system-components}, 
the window manager is connected to the display server,


When the mouse is over the {window content}, the role of the
window manager is then to {relay} the input events to the
application.
%
This is why in Figure~\ref{fig:window-system-components}, 
the mouse and keyboard devices are connected to
the window manager, which is connected itself to
all the window applications (and the terminal emulator)
in order to {\em dispatch} the input to the appropriate window.


%real-world:
In X~Window, the window manager is a separate program.
There are more than 50 different window managers available for X~Window,
each with different window decorations, different {input policies},
different {menus}, etc.
The window manager communicates also with the display server, like other
clients. However, the window manager is assigned a special role 
by the display server.
\l under X11 this is actually delegated to another program
%alt: rebind parent window and root window concept. Hints for positions.

%alt: 
In Weston and Wayland, the display server, compositor, and window manager
are all parts of the same program.
\l but poor display server; just bitmaps transfer; drawing is done by cairo
%  https://wayland.freedesktop.org/faq.html#heading_toc_j_11
% "The Wayland architecture integrates the display server, window manager
%  and compositor into one process"

%in-plan9:
With [[rio]], there is only one window manager, which is an
integral part of the windowing system.
There is only one style of window decoration, kept to a minimum:
%dup: overview/principle overview/principle/window
no title bar, no icon, just a thin blue window border
(see Figure~\ref{fig:rio-gui}). % in Section~\ref{sec:rio-gui}.
\n in rio no icon, so way to start new process is tricky (said later)

%\subsection{Process manager}

% it's a kinda of scheduler, a bit like kernel. Need manage
% set of processes/activities. Need to keep track of them.

%\subsection{Graphical shell}

% can launch new processes
% could be separate program than wm, e.g., the Dock under macOS.


\subsection{Terminal emulator}
\label{sec:terminal-emulator}

%trans: 
The last component of a windowing system is the terminal emulator.
%
A {\em terminal emulator} provides a backward-compatible
environment for command-line applications to run inside
a window, without having to rewrite and recompile those applications.
%
The emulator has also usually some basic line-editing capabilities
such as handling the backspace key or copy-pasting.
\l factorize stuff 
\l actually old terminal have special capacity in kernel too, echoing


The terminal emulator is an optional component of the windowing system
that most users never use, but that most programmers can not live without.
%
Indeed, thanks to the emulator, the programmer can run
all his classic tools (e.g., shells, compilers, linkers, [[grep]])
under the windowing system, and even run multiple tools
at the same time in different windows.
%
An alternative is to use an integrated development environment (IDE),
but IDEs rarely integrate all the tools used by a programmer.

% GUI introduce a new model, new devices, new way to interact, new APIs.
% but what about old command line application? How run?
% could recompile, but why put complexity in it? instead emulator.


%in-unix: %dup? Kernel.nw? Shell.nw?
The environment needed by a command-line application under \unix
or \plan is minimal:
three opened files, in the first three {file descriptors} of the process,
corresponding to the 
{\em standard input},
{\em standard output}, and 
{\em standard error}.
%real-world: %in-plan9:
Those file descriptors correspond usually to the
{teletype device} ([[/dev/tty]]) under \unix, or one
of the {virtual console} under Linux ([[/dev/tty1]], [[/dev/tty2]], etc.),
or finally the {console device} under \plan ([[/dev/cons]]).
%
Those file descriptors can also correspond to regular files when 
the user uses {redirections} in the shell (e.g., [[ls > list.txt]]).
\l   via fork, adjust, exec trick


Under a windowing system, those input/output descriptors must be connected
to the emulator.
\l no teletype device
\l also fork/adjust/exec input/output connected to emulator
%
This is why in Figure~\ref{fig:window-system-components},
the terminal emulator is connected in both directions
to the textual application;
%
the terminal emulator
relays from the window manager the keyboard input to the application, and 
relays from the application the output text to the display server 
(by drawing this text with a special font in the window).



%real-world: 
In X~Window, terminal emulators (e.g., [[xterm]], [[rxvt]]) 
are separate programs.
\n iterm, iterm2, gnome-terminal, Konsole, etc
The standard input and output of command-line applications
running under those terminals are connected to a
{\em pseudo-tty} (PTY), which is a pair of {\em pseudo-devices}
(the master and the slave) managed by the kernel.
Those pseudo-devices and connected themselves to the terminal program 
in user space, as well as to the command-line application.
% http://rachid.koucha.free.fr/tech_corner/pty_pdip.html
%
I must admit I do not fully understand how it works. % lol :)
\l See X? In Wayland simpler?
%
The code of [[xterm]] is very complex with more than 80~000 LOC
%dup: Principia.nw
(eight times more code than the code of [[rio]], which is the whole
windowing system).
[[rxvt]] is smaller, but still has 37~000 LOC.


%in-plan9: beautiful! transparent!
With [[rio]], the terminal emulator is an integral part of the windowing
system and accounts for only 2600 LOC (including the
code to support scrollbars, filename completion, copy-pasting, etc).
\n terminal.c, libframe, libcomplete, libplumb
This is mainly because the pseudo-tty is replaced by a more
general approach: {\em virtual devices} and {\em filesystems in user space}.
%
Indeed, under  [[rio]], a command-line application still
opens the {console device} by opening in read and write {modes}
[[/dev/cons]]. However, this file, thanks to the per-process namespace
feature of \plan, is not the device file managed by the kernel but
a virtual device managed by [[rio]]; 
every file request on [[/dev/cons]] is redirected to a 9P request to [[rio]]
(which itself uses the ``real'' [[/dev/cons]] managed by the kernel).
\l See X for more information?



\subsection{Windowing system API}
\label{sec:windowing-system-api}

%trans: 
I just described the {\em internal} structure of a windowing system,
as well as the environment needed by command-line applications
when running under a terminal emulator.
%
But, what about the {\em external} interface of a windowing system,
as well as the needs of a window application?
% running under this windowing system?
%
What API should a windowing system offer to its clients?
\l the top edges in Figure~\ref{fig:window-system-components}


Obviously, a window application
% running under a windowing system
wants to access the screen, the mouse, and optionaly the keyboard.
%in-plan9: %dup: (but clearer) intro/rio
Note that there is already an API to access those devices under \plan.
Indeed, 
%to access 
%the screen, 
%the mouse, and 
%the keyboard 
a \plan graphical application (e.g., Doom) can simply read or write in 
%respectively 
the 
[[/dev/draw]], 
[[/dev/mouse]], and
[[/dev/cons]]
{devices files}, which are managed by the \plan kernel 
(see the \book{Graphics} and \book{Kernel}).
%
The top of Figure~\ref{fig:rio-multiplexer} illustrates one such
graphical application called [[App 1]].
%
This program can also use functions from the 
[[draw.h]], 
[[mouse.h]], and 
[[keyboard.h]] 
header files instead of using directly the device files, 
but those functions are just thin wrappers that ultimately read and write
in the corresponding device files.


\begin{figure}[!]\centering
\begin{verbatim}
                                       +---+
                  +------+ /dev/draw   |   |
                  |      +------------->   |
                  |      | /dev/mouse  |   | +--------+
                  |App 1 <-------------+   | |Display |
                  |      | /dev/cons   |   | | device |
                  |      <-------------+   | +--------+
                  +------+             |   |
+------+ /dev/draw   +---+             | K |
|      +-------------> w |             | e | +--------+
|      | /dev/mouse  | i |             | r | | Mouse  |
|App 2 <-------------+ n |             | n | | device |
|      | /dev/cons   | d |             | e | +--------+
|      <-------------+ o | /dev/draw   | l |
+------+             | w +------------->   |
                     |   | /dev/mouse  |   |
+------+ /dev/draw   | s <-------------+   | +--------+
|      +-------------> y | /dev/cons   |   | |Keyboard|
|      | /dev/mouse  | s <-------------+   | | device |
|App 3 <-------------+ t |             |   | +--------+
|      | /dev/cons   | e |             |   |
|      <-------------+ m |             |   |
+------+             +---+             +---+
\end{verbatim}
\caption{Windowing system as a multiplexer.}
\label{fig:rio-multiplexer}
\end{figure}
\n actually a bit different for /dev/draw, but simpler to cheat for now

%in-plan9:
Thus, under \plan,
one way to define the external interface of a windowing system
is to just mimic the interface defined by the kernel,
as shown at the bottom of Figure~\ref{fig:rio-multiplexer}.
%in-plan9: %dup: (but clearer) intro/rio
As mentioned in Section~\ref{sec:rio}, [[rio]] is
implemented as a {\em multiplexer}; 
it accesses the {physical devices} (managed by the kernel) 
at the bottom right of Figure~\ref{fig:rio-multiplexer},
and provides {virtual devices} to its clients ([[App 2]] and [[App 3]])
with similar interfaces at the bottom left of 
Figure~\ref{fig:rio-multiplexer}.
\l like for terminal emulator, virtual device files.

%dup: (but clearer) intro/other-systems
This multiplexer approach makes [[rio]] a 
{\em transparent}~\cite{window-system-should-be-transparent} windowing system.
%
Indeed, [[rio]] does not need to introduce a new API.
\n in fact it will a bit, for resize, and for /srv for creating windows
%for a graphical application running under [[rio]], 
%it is exactly as if [[rio]] was not there.
%
In fact, this transparence enables the same
graphical application to run with or without [[rio]], as shown
respectively in Figure~\ref{fig:clock-rio} and Figure~\ref{fig:clock-no-rio}
for the [[clock]] application.
%
Under \plan, there is almost no difference between a graphical application
and a window application.
\l almost cos few differences still, need to use view, resize, etc.
%dup: intro/rio %rio-reflection:
This transparence enables also [[rio]] to run recursively under itself
(see Section~\ref{sec:recursive-rio}).
%rio-reflection: so everything rio used from kernel must be emulated!
% can be confusing sometimes.

\begin{figure}\begin{center}
\includegraphics[width=8cm]{clock-rio}
\end{center}
\caption{[[clock]] running inside [[rio]].}
\label{fig:clock-rio}
\end{figure}

\begin{figure}\begin{center}
\includegraphics[width=8cm]{clock-no-rio}
\end{center}
\caption{[[clock]] running without [[rio]].}
\label{fig:clock-no-rio}
\end{figure}


%real-world:
X~Window, on the opposite, is not a transparent windowing system. It
introduces a special protocol and special APIs to access
the screen, the mouse, and the keyboard. You can not run a window
application without X~Window, and you can not run a graphical
application (e.g., Doom) inside a window in X~Window
(unless you rewrite Doom to use the X~Window API).
\n can in Windows though no? or can if Doom programmed in a special way?
\n  but then it can run only in X~Window.
\n or need an X~Window extension?
% 2 different worlds
\l cant run X inside X? apparently you can, but maybe need lots of code.
\l partly because run on OS without features necessary for virtual device files
\l  but also cos badly designed

\subsection{Window application versus graphical application}
\l very specific to plan9? maybe not.

Window applications and graphical applications have a lot in common:
they both draw on the screen, use the mouse, and possibly use the keyboard.
\l in raw mode.
%in-plan9:
As I said above,
in \plan, the difference between a graphical application and a window
application is fuzzy since you can also run graphical applications
inside a window.
%
However, this is possible only because
of some careful design decisions in [[rio]] and [[draw]].
\l and also few changes in the code
%explained in the following sections.
\l or additional code in application, or special library.
%real-world: X~Window?
%toc:
There are a few differences between running inside or outside a windowing
system, as explained in the following sections.

\subsubsection{A virtual screen}

One of the role of a windowing system is to 
offer {abstractions} hiding complexity, just like the kernel does.
%
Indeed, thanks to {\em virtual memory}, 
a process thinks it is alone and has access
to the whole memory, starting at address 0.
This simplifies greatly programming; the programmer does not have to care
about the physical memory layout and which memory is used by other processes.
%
In the same way, thanks to {preemptive scheduling},
a process thinks it is alone and has exclusive access to the CPU.
Again, the programmer does not have to care about the other processes
and how they use the processor (or processors). 
Each process uses a {\em virtual CPU}.


%in-plan9: but could be made more general
When running without [[rio]], a graphical application has access to the
whole screen. The origin point ([[Pt(0,0)]]) corresponds
to the top left corner of the screen (see the \book{Graphics}).
%
This should be similar when the graphical application is running under [[rio]].
This is why [[rio]] offers a {\em virtual screen} to each window, where
the origin point corresponds to the top left corner of the {window content}.
\t with originWindow. even if window in right corner. but bug right now

Thanks to the virtual screen, a graphical application running in a window 
%thinks it is alone; it 
does not even know it is running inside a windowing system.
%
Moreover, the programmer does not have to care about the other windows, or
where is located the window on the screen;
whatever the location, drawing a line from [[Pt(0,0)]] will always
start from the top left corner of the window, even though the window
itself is located at the very right of the screen.
\l just like virtual /dev/cons for emulator,
\n in the end natural to use virtual devices to represent virtual things
%
The programmer can use {\em virtual coordinates} 
(a.k.a. {\em logical coordinates}); those coordinates
are then translated in {\em physical coordinates} on the screen
by the windowing system.

%in-plan9: how implemented? actually complicated, see later

%real-world: same, logical coords in X~Window?
 
\subsubsection{A virtual mouse}

%trans:
What is true for the screen should also be true for the mouse.
%in-plan9:
This is why [[rio]] offers also a {\em virtual mouse} to each window; 
the location of the mouse read by the window application is relative to
the window, not the whole screen. The programmer can use
virtual coordinates again.
\l does not need to know run inside rio.
\t actually there is a bug right now

With [[rio]], the programmer does not have to check if the mouse
is on top of its window, or if the mouse is used concurrently
by another program; all of this is handled automatically by
the windowing system, which hides complexity by offering
a virtual mouse. When a window is at the top,
and the mouse cursor over this window,
\l focus defined later, grrr
[[rio]] then {\em dispatches} the mouse event to the corresponding process.
\l sure it is the actual mechanism in rio?
\l in X window can have different policy for that. follow-mouse vs focus

%in-plan9: virtual mouse concept implemented via virtual device /dev/mouse
%  natural. 
%real-world: same? X~Window?

\subsubsection{Overlapping windows}
\label{sec:layer-introduction}

%trans:
In addition to a reduced drawing surface, 
\l and different coordinate system
%
an important difference for a graphical application running inside a window
is that windows can overlap each other, and so hide each other.
%trans:
Where are stored the hidden pixels? How are those hidden
pixels restored when the window is exposed back?

%real-world:
In X~Window, because the early graphics machines did not have
much memory, the hidden pixels are not saved anywhere.
Instead, the display server {\em notifies} the client by
an {\em expose event} when a part of its window is exposed back.
It is the responsibility of the client, and so of the
programmer, to draw back what was hidden.
%real-world: from SunDew (ancestor of NeWS):
%"a window should be just that. it is a surface on which he
%can write, and that it persists. All overlap issues should be
%completely hidden from the client"
% => no refresh/repaint brain damage.

%in-plan9: 
With [[rio]], the programmer does not have to care about
overlapping windows. The windowing system hides complexity
by storing the hidden pixels in {\em off-screen images}.
When a window is exposed back, the windowing system then
copies the pixels from those off-screen images back to the screen.
\l well in fact it is done by draw
\l (like suspended process) (so need save window content somewhere)
This is consistent with the idea of the virtual screen:
the programmer does not have to care about the other windows.
\l the other windows, or the idea itself of being in a window. Abstraction!

%dup: (summarized) Graphics.nw
To manage overlapping windows, 
[[rio]] relies on a special data structure of [[draw]]:
the {image layer} (see the \book{Graphics} and \cite{pike-layers}).
\l [[Desktop]] [[Memdesktop]] and [[Image]] [[Memlayer]]
%
%A {\em BaseImage} is an image tagged in special
%way so that it can have layers upon it.
%[[rio]] uses the image corresponding to the screen as its desktop.
\n too complex for now
A {\em layer} is an image that overlaps
a rectangular sub-area of another image called the {\em base layer}.
With [[draw]], the programmer can use multiple layers
stacked on top of each other and on top of the base layer.
%
When a program draws in a layer,
\l draws on base for pixels not overlapped
the pixels overlapped by another layer are automatically saved
in an off-screen image.
\l alternative is big off-screen image for all, and window compositor
%
All the drawing functions of [[draw.h]] have special code to handle
the case where the image passed as a parameter is a layer.
\n in fact it is in libmemdraw, not libdraw
%The programmer does not have to know whether the image is a layer or not.
%
The programmer can also use
additional functions from [[window.h]] that are valid only
for layers, for instance, moving a layer at the top
with [[topwindow()]]. This function possibly copies the hidden
pixels saved in an off-screen image (if the layer was overlapped)
back to the base layer (e.g., the screen).

%in-plan9:
A layer is similar to a window, but the layer does not have any 
associated process; it is just a graphic construct.
It is one of the building block of [[rio]]. 
%rio-reflection:
Indeed, as you will see later in Section~\ref{sec:new-layer},
with [[rio]] {\em each window is associated to a layer}; 
each window will draw in its layer.
\l and base layer is the screen.
%
Moreover, when the user clicks on a window, [[rio]] internally calls
[[topwindow()]] with the appropriate layer as a parameter.
\l see Section X for the code.
%The public images created by [[rio]] and mentioned previously
%are actually layers of the screen. 

\subsubsection{Creating windows}

A windowing system should offer an API to create windows, not
just to draw things in a window.

%in-plan9:
In \plan, the toplevel windows, whose dimensions are specified by the user
(see Section~\ref{sec:rio-gui}),
are created by [[rio]], but each graphical application
can also create {\em sub-windows} inside its window.
%
Just like [[rio]] internally uses layers to represent toplevel windows, a
graphical application can also use layers to represent sub-windows.
%rio-reflection:
\l after all rio itself is a graphical application
Thanks again to [[window.h]], an application such as the editor [[acme]]
\l cite
can use multiple layers to represent different files in multiple columns.
%
In the same way, a dialog box, a menu, or any {\em widget} can be
represented internally as a layer. By using a layer, the programmer
of the widget does not have to care about the pixels overlapped
by the widget (or the pixels of the widget overlapped by another widget).

%in-plan9:
Note that layers do not have a border. To implement the window decorations,
[[rio]] draws a blue border rectangle inside the layer.
\l and then dimension of layer passed to process? originWindow? clipping?
Note also that sub-windows have to be inside the parent window.
It is not possible to create a layer that extends above the boundaries
of the window.
%
However, [[rio]] offers another API to create toplevel windows.
This API requires advanced features of [[rio]] and so is
explained later in Chapter~\ref{chap:advanced}.
\n /srv/, so there is some windowing system API a bit.

%real-world: X window complex, create window, passed 
% to window manager, rebind parent of window.


\subsubsection{Resizing windows}
\label{sec:principles-resize-window}

%trans:
The last difference between a window application and a graphical
application is that windows can be resized.
\l well can change resolution too for graphics applications, but rare
Unfortunately, as opposed to overlapping windows, this complexity 
can not be hidden to the programmer.

%real-world:
In most windowing systems, the window application is notified of a 
{\em resize event} when its window is resized. It is then the responsibility
of the programmer to provide a {\em callback} for such an event
that redraws everything.

%real-world:
In X~Window, this event is communicated to the client application
through the general {\em event mechanism} of X11. At startup time, 
the application communicates to the display server an
{\em event mask} specifying the set of events the application is interested
in. If the resize event {matches} the event mask, then X~Window
will notify the client of a resize event.
\l what if no event mask and resize? crash?
\l Cleaner? too specific to window context and so cant be transparent?

%in-plan9:
With [[rio]], the event is communicated to the application through the 
[[/dev/mouse]] virtual device file. 
\n [[/mnt/wsys/mouse]] too early to use /mnt/wsys
\l a bit ugly, should have instead a /dev/resize, but then can be transparent
\l in fact also through /dev/mouse for kernel
A graphical application usually reads this file to keep track
of the changes to the mouse location and the states of its buttons.
%
During a resize event, [[/dev/mouse]] contains 
the character [['r']] (for resize), instead of the character [['m']] 
(for mouse).
\l and size of new window? no, another mechanism for that.
%followed by integers encoding the location and the button states of the mouse.
\l see docs/man/3/mouse
\l and then getwindow() to grab new public layer and adjust global view (later)
%rio-reflection: rio does that itself since can be run inside a window




\section{[[rio]] interfaces}

%trans:
I just described the general principles of a windowing system,
and illustrated those principles with examples from X~Window and [[rio]].
%
I will now focus exclusively on [[rio]] and give more details
about its interfaces.

%toc:
[[rio]] is first a program you run through the command line, with 
optional command-line arguments. 
%
Then, it takes over the screen and becomes a graphical application.
%
Finally, it internally spawns a new process acting as a filesystem. 
%
Thus, [[rio]] has three different interfaces, which I will describe 
in the following sections.

\subsection{Command-line interface}

The command-line interface of [[rio]] is pretty simple:

<<function [[usage]]>>=
void
usage(void)
{
    fprint(STDERR, "usage: rio [-f font] [-i initcmd] [-k kbdcmd] [-s]\n");
    exits("usage");
}
@
\n no rio -help, call [[usage()]] only when give wrong argument to a -x above

Most of the time you will run [[rio]] without any argument,
as shown in Section~\ref{sec:getting-started}.
%
The arguments are all optionals and correspond to
advanced features of [[rio]] I will explain in Chapter~\ref{chap:advanced}.


\subsection{Graphical user interface}
\label{sec:rio-gui}

%trans:
The most important interface of [[rio]] is of course its
graphical user interface.
%
Once launched from the command-line, [[rio]] takes over the whole 
%rio-reflection:
screen\footnote{Unless it is run recursively inside one of its window,
as shown in Section~\ref{sec:recursive-rio}.
}
and displays a grey background image, as shown in
Figure~\ref{fig:rio-start}. % of Section~\ref{sec:getting-started}.
%
Then, using the mouse, you can create new windows.
%
Figure~\ref{fig:rio-gui} illustrates the main elements of [[rio]]'s GUI.


%dup: overview/principles/...
As mentioned in Section~\ref{sec:principles}, [[rio]] has a 
minimalist interface: no icon, no title bar, just a thin
blue border around windows.
%
You can left-click on a window to put it at the {top} if it
was overlapped. Moreover, by doing so, the window gets
the {\em focus}; this means every keyboard input will be sent
to this window.
\t window with focus is also called the {\em current window}.
\t also mouse! do cat /dev/mouse and you will see, dispatch only if focus
\l really? focus by click? or is it just if mouse is inside window?
When a window gets the focus, its border changes from a light
blue to a darker blue, as shown at the bottom of Figure~\ref{fig:rio-gui}.
Moreover, for window terminals, if the window loses the focus,
the text inside the window changes from black to a light grey,
as shown in the left of Figure~\ref{fig:rio-gui}.
\l nice visual feedback
\l get an event? or get that because terminal is builtin?


\begin{figure}\begin{center}
\includegraphics[width=8cm]{rio-gui}
\end{center}
\caption{Graphical user interface of [[rio]] after a right-click.}
\label{fig:rio-gui}
\end{figure}
\t annotate subtle things, like blue frame, or light grey text when unfocused
\t menus, winborder, use bubbles and arrows a la powerpoint


By right-clicking outside any window, on the grey background image of [[rio]],
you trigger a {\em system menu} allowing you to 
create, 
resize, 
move, 
delete,
or hide 
a window, as shown in 
the right of Figure~\ref{fig:rio-gui}.
\n actually can also right click in textual window
\n button3menu()
\l also exit rio.
Note that [[rio]] requires a mouse with three buttons (left, middle, and right).
%
To create a new window, activate the system menu,
then hold the right-click, choose [[New]],
and finally release the right-click.
The cursor will then change from a big arrow to a plus sign,
to indicate a different {\em mode} of operation.
%
You must now specify a rectangle by right-clicking again and hold
while drawing a rectangle on the screen, as shown
in Figure~\ref{fig:new-step1-specify-new-window}.
%
Once you release the right-click, a new window terminal will appear,
as shown in Figure~\ref{fig:new-step2-basic-window-terminal}, with
a {shell prompt} at the top.


\begin{figure}\begin{center}
\includegraphics[width=8cm]{new-step1-specify-new-window}
\end{center}
\caption{Creating a new window.}
\label{fig:new-step1-specify-new-window}
\end{figure}


\begin{figure}\begin{center}
\includegraphics[width=8cm]{new-step2-basic-window-terminal}
\end{center}
\caption{Built-in terminal running under [[rio]].}
\label{fig:new-step2-basic-window-terminal}
\end{figure}
\l maybe start to type colors and screenshot of that


Because there is no icon in [[rio]], to launch a graphical
application you need first to create a window
terminal. Once created, you can type in the terminal window
the name of the graphical application you want to launch,
for instance, [[colors]].
%
This application should then take over the virtual screen of the
window terminal\footnote{Just like it takes over the whole screen when
launched outside [[rio]].},
as shown in Figure~\ref{fig:new-step3-color-app}.
%rio-reflection: 
\l same mechanism that rio uses also initially
\l same mechanism that makes possible recursive-rio
%
Once you quit this graphical application, the terminal will be back.
\l Graphical shell! Run commands. but no Dock. No Icon.
\l Also possible to create window programmatically, see Section X.
\t how does it work actually? save content?

\begin{figure}\begin{center}
\includegraphics[width=8cm]{new-step3-color-app}
\end{center}
\caption{[[colors]] graphical application running under [[rio]].}
\label{fig:new-step3-color-app}
\end{figure}

You can also use the border of the window to resize or move the window.
When the mouse is over the border, the cursor changes again to
indicate a possible action. By left-clicking or middle-clicking
on the border, you can respectively resize or move the window.
\l also menu resize/move/delete/hide also cursor change and right-click
\l  to designate the window


For a full description of the GUI of [[rio]], I refer
you to its manual page in [[docs/man/1/rio]] in my \plan repository.
\l also a bit 8-1/2 ancestor of rio with same interface (actually since mpx)
%dup: (adapted) intro/rio
You can also watch the historical demo of the Blit
and [[mpx]] at \url{https://www.youtube.com/watch?v=emh22gT5e9k};
the user interface of [[mpx]] is almost identical to the one in [[rio]].
\l just black and white instead of color


\subsection{Filesystem interface}
\n also windowing system API

%trans:
As opposed to the two previous interfaces,
the last interface of [[rio]] is almost invisible to the user.
%
It is the set of files served by [[rio]] to all its window processes:
the filesystem interface.
%
It is mostly invisible because it is mainly an interface for programs, 
not users.
\l can explore in /mnt/wsys/ though for user
%dup: intro/rio intro/other-systems overview/principle/emulator  overview/principle/api
Moreover, as explained in Section~\ref{sec:windowing-system-api},
[[rio]] is a transparent windowing system;
the files served by [[rio]] mimic and replace {existing} device files managed
by the kernel (e.g., [[/dev/mouse]]), making the interface harder to notice.
\l but a few files more too

\l As I said in Section~\ref{sec:rio}, [[rio]] is also a filesystem in user space.
\l (more accurately a fileserver because in userspace).
\l to understand why, need expose internals of rio. will not do that here. 
\l See Section X for trace of creating new window and connect process to rio fs.

%toc:
In the following sections, I will describe the files served by [[rio]]. 
Those files act as interfaces to access
the screen, 
the mouse,
the keyboard,
but also the windowing system itself.
%dup: intro/rio 
I will prefix those files with [[/mnt/wsys/]] because that is
where the [[rio]] filesystem is originally {mounted} by the
window processes.
\t see Section X for full explanation of connection
However, as mentioned in Section~\ref{sec:rio},
those files are also available in [[/dev]], thanks to the union-mount
feature of the \plan kernel.
%dup: intro/rio overview/principles/api
It is by being accessible in [[/dev/]] that [[rio]] can become a multiplexer, 
as explained in Section~\ref{sec:windowing-system-api}. However, by using
the [[/mnt/wsys]] prefix, it is clearer that the file involved
is the file served by [[rio]] (e.g., [[/mnt/wsys/mouse]]) and not
the real device served by the kernel (e.g., [[/dev/mouse]]).
\n or a parent rio when in recursive rio

In the following sections, I will also repeat partly explanations 
found in the \book{Graphics} and \book{Kernel},  as [[rio]] emulates 
interfaces provided by the graphics system and the kernel. 
%\l morever rio relies a lot on services of draw, will remind those services.
However, the interfaces have a few differences because the context in
which the graphical application runs is different.

\subsubsection{The screen, [[/dev/draw]] and [[/mnt/wsys/winname]]}
\label{sec:winname}
\n was originally in overview/principles/api, but bad cos too rio-specific.
\n then I moved it here but bad cos was too big.
\n I then extracted the general stuff and put it in overview/principles/vs

%trans:
The first interface [[rio]] needs to mimic is the interface to the screen,
%
which under \plan involves the [[/dev/draw/]] directory and the
[[draw.h]] header file. 
%dup: (big summary) Graphics.nw
\l This file declares functions to draw lines, rectangles, text, etc.


Figure~\ref{fig:rio-multiplexer} % \pageref?
showed a windowing system multiplexing
[[/dev/draw]], [[/dev/mouse]], and [[/dev/cons]].
\l could have /dev/screen, instead of /dev/draw, but then harder remote apps
%alt: %dup: (but better explained than in footnote) intro/rio
This was how [[8-1/2]]~\cite{eight-and-a-half}, the ancestor of [[rio]],
was implemented. Under [[8-1/2]], each window was seeing
a [[/mnt/wsys/draw]] virtual device file in which the process
could write drawing commands. [[8-1/2]] would then convert
the logical coordinates in the drawing command to physical coordinates,
\l also clipping, save off-screen image if overlapped, more?
and send the resulting command to the real [[/dev/draw]] device file
managed by the kernel.
%
This was elegant. However, each drawing operation involved two 
\n interprocess communications (IPCs)? actually not really IPC with kernel
communications:
one between the application and the windowing system,
\l actually via kernel too
and the other between the windowing system and the kernel.
Those two round-trips were too inefficient for certain applications.
\l like video-games? other? still inefficient on modern machines?


%dup: (but better explained than in footnote) intro/rio  %dup? Graphics.nw
To remove one round-trip, [[rio]] does not multiplex [[/dev/draw]].
Instead, each window application connects directly to the [[draw]] device,
which is more efficient.
\l FIGURE? where see windows and rio are connected directly
%
However, this forced the [[draw]] device to 
serve multiple processes in addition to [[rio]]
(in [[/dev/draw/2/]], [[/dev/draw/3/]], etc),
and to become a display server.
%
Moreover, this required a new mechanism for [[rio]] to communicate
to [[draw]] which part of the screen is allocated to each
client of [[draw]].
%
This mechanism is complex and involves multiple features
of [[draw]] and [[rio]]:

\begin{enumerate}
\item Instead of [[/mnt/wsys/draw]], [[rio]] serves a file
named [[/mnt/wsys/winname]], which contains a different string
for each window (e.g., [["window.3"]]).
\l actually window.id.namecount
\l how can be different?

\item This string corresponds to the name
of a layer allocated by [[rio]] for the window
(see Section~\ref{sec:layer-introduction} for an introduction to layers).
\n see explanations of layer in principles
\l nameimage
\l just window content? or window decoration too?
This layer has the
dimension specified by the user during the creation of the window
(see Figure~\ref{fig:new-step1-specify-new-window}).
\l actually it is not an image but a window/layer of the screen, so can be
\l  a subimage, and for screen it is a subpart of the screen
\l also includes window decoration?

\item This layer, which is also an image, is made {\em public} by [[rio]]. 
Thanks to an inter-process communication (IPC)
feature of [[draw]], this public image can be accessed
by multiple processes
(see the \book{Graphics}).
\l nameimage()
\l but then security issue

\item On the client side, remember that each graphical
application must first call [[initdraw()]].
[[initdraw()]] calls itself [[gengetwindow()]], which
reads [[/dev/winname]] and grabs a reference to 
the corresponding public image.
\l namedimage(), but really it is just a reference to a Memimage in kernel space
This reference is then stored in the global [[view]].
%
By using [[view]] instead of [[display->image]] (see the \book{Graphics})
for the arguments of the drawing functions of [[draw.h]],
the graphical application can become also a window application, for free.
\l this layer becomes base image. so layer on top of this layer.
\n well still need to implement the resize callback
% FIGURE?

\end{enumerate}

Note that [[initdraw()]] calls [[gengetwindow()]] even when
the graphical application runs outside [[rio]]. To {\em bootstrap}, 
the [[draw]] device serves also a [[/dev/winname]] file, which contains
the string [[noborder.screen.1]]. This string corresponds also
to an image: the whole screen. In that case, the global [[view]]
and [[display->image]] references both the screen.
%rio-reflection: rio calls initdraw, and uses view!

For more information, Section~\ref{sec:trace-draw} explains
the full trace of a drawing operation through the 
windowing system, the graphics system, and the kernel.


\subsubsection{The mouse, [[/mnt/wsys/mouse]] and [[/mnt/wsys/cursor]]}
\label{sec:mnt-wsys-mouse}

%trans:
The second interface [[rio]] needs to mimic is 
%
the interface to the mouse, which under \plan involves the [[/dev/mouse]] 
and [[/dev/cursor]] files, as well as the [[mouse.h]] header file.


%dup:? Kernel.nw
The [[/dev/mouse]] interface defined by the mouse device driver
in the kernel is simple.
%dup: overview/principles/vs/resize
As mentioned in Section~\ref{sec:principles-resize-window}, 
a graphical application can keep track of changes to the mouse location or
the states of its buttons by reading (with [[read()]]) [[/dev/mouse]].
\l synchronously
%
When the user does an action with the mouse, the [[read()]] system call
returns, and the buffer parameter of [[read()]]
\l see \book{Libcore}
is modified to contain the character [['m']] (for mouse), followed by 
integers encoding the location and the button states of the mouse.
\l could have FIGURE with cat /dev/mouse
\l could even have FIGURE with 2 windows and cat /mnt/wsys/1/mouse
%
The graphical application can then inspect those integers and modify 
the GUI, or do nothing.
\l can also write in /dev/mouse


%trans:
As opposed to [[/dev/draw]], [[rio]] does multiplex [[/dev/mouse]]\footnote{Why
the difference? Why is there not a mouse server, 
just like there is a display server? 
%
Because there is no need to optimise the access to [[/dev/mouse]].
%
Indeed, the two round trips underlying the access to
[[/mnt/wsys/mouse]] are not as critical as the access
to an hypothetical [[/mnt/wsys/draw]]. In the context of a video game,
a game application may have to generate 30 to 60 images per
second; this may require hundreds or more calls to drawing
functions of [[draw.h]], and many accesses to [[/dev/draw]].
%
However, user actions are slower and the application does not
need to react to a mouse event so frequently. Moreover, the size of
the data involved with [[/dev/mouse]] is small: just a few bytes
to represent a mouse location and button states.
\l no need to be handle at the frame rate. sure?
} as shown in Figure~\ref{fig:rio-multiplexer}.
%
The main job of [[rio]] regarding the mouse interface
is to relay a [[read()]] by the window application on 
[[/mnt/wsys/mouse]] to a [[read()]] on the real [[/dev/mouse]],
\l actually otherway around, rio reads /dev/mouse and dispatch
and to convert the physical coordinates of the mouse to logical coordinates.
\t does it do it now?
%dup: (but changed a bit) overview/principles/vs/resize
Moreover, as mentioned in Section~\ref{sec:principles-resize-window},
[[rio]] abuses [[/mnt/wsys/mouse]] to also transmit
the resize events to the graphical application. The buffer contains
then the character [['r']] (for resize).
\l followed by stuff?

After a window application reads the [['r']] character 
in [[/mnt/wsys/mouse]],
it is the responsibility of the programmer to call [[getwindow()]],
%
which  is a function similar to the [[gengetwindow()]] function I mentioned
before. % Section X
[[getwindow()]] also reads [[/dev/winname]].
This file should contain a new string
corresponding to a new public image with the new dimension of the window.
%
Then, [[getwindow()]] grabs the reference to this new public image in which
the graphical application should now draw in.
[[getwindow()]] also updates the global [[view]].
\l it does?


Another job of [[rio]] is to multiplex [[/dev/cursor]]
and to offer a {\em virtual cursor} to each application.
%
Thanks to [[/mnt/wsys/cursor]], each application can use
a different cursor and can change the cursor.
%
When the user hovers a window, the cursor changes
according to what the window application wrote in his
[[/mnt/wsys/cursor]] file; if nothing was written, a default
cursor is used.

\bigskip
The fact that a program running in a window opened or not 
its [[/mnt/wsys/mouse]]
\l or cursor?
file is an important information for [[rio]]. Depending on this opened status,
[[rio]] will behave differently. For instance, 
if an application opens [[/mnt/wsys/mouse]], many features of the terminal
emulator are automatically disabled.
\l see rio(4).
Indeed, using the mouse is a strong hint for [[rio]] that the application
is a graphical application, not a command-line application.
%
Another hint is the opening of [[/dev/draw/new]] by the application, 
but this file is not managed by [[rio]], and so out of reach of [[rio]].
%
In the rest of the book, I will use the term {\em graphical window}
for a window in which the underlying program opened [[/mnt/wsys/mouse]],
and {\em textual window} otherwise.

\t mv somewhere else?
%trans:
The last important information regarding the mouse interface concerns
the [[mouse.h]] header file.
%
\t mv with virtual mouse? quite rio specific, but contain principles
A programming alternative
to using directly [[/dev/mouse]] is to use the functions
from [[mouse.h]] such as [[initmouse()]] (see the \book{Graphics}).
\n why discuss now? cos I mention mouse.h above.
%
[[initmouse()]] internally uses [[/dev/mouse]], but wraps 
the device file in a data structure ([[Mousectl]]) allowing
the use of {\em threads} and {\em channels} (see the \book{Libcore}).
%
Using channels gives more flexibility to the programmer. For instance,
the program can {\em react} simultaneously to changes in [[/dev/mouse]] 
and [[/dev/cons]], and so can handle mouse events as well as keyboard
events. Without [[mouse.h]], the programmer can either read
synchronously [[/dev/mouse]], or read synchronously [[/dev/cons]], 
but not both at the same time\footnote{
There is no [[select()]] system call in \plan. Threads,
channels, and the \plan{} function [[alt()]]
are the \plan{}'s way to do things done usually with [[select()]]
under \unix.
}.
%rio-reflection:
Note that
%, as you will see in Chapter~\ref{chap:main},
[[rio]] itself calls [[initmouse()]] at startup time,
and uses heavily channels and threads, as you will see
in the rest of the book.



\subsubsection{The keyboard, [[/mnt/wsys/cons]] and [[/mnt/wsys/consctl]]}

%trans:
The last interface [[rio]] needs to mimic is the interface to the keyboard,
%
which under \plan involves the [[/dev/cons]] and [[/dev/consctl]] files,
as well as the [[keyboard.h]] header file.


%dup? Kernel.nw
[[/dev/cons]] stands for {\em console device}; 
it is the device representing the {terminal}.
%
The [[/dev/cons]] interface defined by the kernel is simple:
a program reading from [[/dev/cons]] will read characters from the keyboard;
\n actually unicode, 
\t actually utf8 encoding of runes!
a program writing to [[/dev/cons]] will output text on the screen.
\n classic text-based user interface
%
At boot time, the first \plan process opens [[/dev/cons]] two times:
\l init?
one in {read}-mode, and the other in {write}-mode.
%dup: overview/principle/terminal-emulator
Those two first file descriptors correspond
to the {\em standard input} and {\em standard output} of the program 
(see the \book{Kernel}).
\n also standard error
\l \ref{sec:terminal-emulator}
%
Those file descriptors and then {inherited} through [[fork()]]
and [[exec()]] by the shell, as well as by the command-line
applications launched from the shell, unless the user used redirections
(see the \book{Shell}).
%
Remember that
the [[printf()]] function from the C library internally does some 
[[write(1, ...)]]m
\l see \book{Libcore}
and the [[scanf()]] function internally does some 
[[read(0, ...)]].
% those conventions are great. can have generic tools.


%dup? Kernel.nw
The kernel offers also a few convenient features by default
regarding the input of characters.
%
For instance, when a program reads [[/dev/cons]],
the user can interactively edit the characters to sent to the program
by using the {\em backspace} or {\em delete} keys to correct typing mistakes.
He can also use the {\em cursor} keys to move in the line.
Moreover, the characters typed are automatically {\em echoed} on the screen,
making it easy to see the typing mistakes.
Finally, the characters are sent only when the user types the 
{\em newline} character.
\l of if too many characters buffered already?
\n mini editor! bootstrapping editor (see Principia.nw)
%
By putting those features in the kernel, all command-line applications
do not have to care about typing mistakes.
\l also buffered input and output? output only when \n? also faster originally?
%alt: how kernel multiplex keyboard? it does not really, only one process
% read the key at the same time
%alt: evdev in linux? yet another mechanism


%dup? Kernel.nw
Note that those line-editing features can also be disabled by the application.
%
Indeed, in certain contexts, the application may not want the
input to be buffered. For instance, a video game wants
to respond as soon as possible to the key typed by the user; it does not
make sense to force each time the user to also type the newline character.
%
This is why the kernel provides also the [[/dev/consctl]] (for console
control) device file. By writing [[rawon]] (for {\em raw access} on)
in [[/dev/consctl]],
\l raw mode vs cooked mode apparently, funny
the application indicates to the kernel that the default line-editing 
features of the kernel should be disabled; the application
wants {raw access} to the keyboard
\l some command line app also use the raw mode? libreadline?
%rio-reflection:
(note that [[rio]] itself writes [[rawon]] in [[/dev/consctl]]
at startup time, so it can handle the keyboard itself).
%
A call to [[read()]] on [[/dev/cons]] will then return after each key
is typed. Moreover, no character will be echoed by default on the screen.



The job of [[rio]] regarding the keyboard interface depends also
on whether the application in the window wants or not raw access 
to the keyboard.
%
This is why [[rio]] multiplex not only [[/dev/cons]], but also [[/dev/consctl]].
\l not shown in Figure~\ref{fig:rio-multiplexer}
The behavior of [[/mnt/wsys/cons]] depends on the opening and content
of [[/mnt/wsys/consctl]].
%The behavior of [[/mnt/wsys/cons]] depends on the opening 
%status of [[/mnt/wsys/mouse]].
\l sure? can have graphical app without rawon?
This is usually correlated with whether or not the window is a
graphical window (raw access on), or textual window (line-editing on).


For graphical windows, writing on [[/mnt/wsys/cons]] should be 
considered an error.
\t Is it?
Indeed, the graphical application should instead use the [[string()]] 
\l or runestring
function from [[draw.h]] to output text on the screen at a specific
location via [[/dev/draw]]
(see the \book{Graphics}).
%
Only reads on [[/mnt/wsys/cons]] should be supported by [[rio]].
Moreover, each key typed should be sent directly to the
graphical application if its window has currently the focus.


For textual windows, the job of [[rio]] and its terminal emulator
is to imitate what the kernel does by default, including the line-editing
features.
%
In fact, under [[rio]], the user can also use {\em copy-pasting} with
the mouse to edit a line before it is sent to the program.
%
Both reads and writes on [[/mnt/wsys/cons]] should be supported by [[rio]]
for textual windows.
%
Reads to [[/mnt/wsys/cons]] by a command-line application
should return only when the user typed the newline character in the 
terminal emulator.
%
Writes to [[/mnt/wsys/cons]] should be converted to calls to
[[string()]] by the terminal emulator, in order to output text at 
\l or runestring
the right place in the window (possibly applying line wrapping).

\n kbdin explained later

%trans:
Similar to the mouse,
%
a programming alternative to using directly [[/dev/cons]] is to use 
the functions from [[keyboard.h]] such as [[initkeyboard()]] 
(see the \book{Graphics}).
%
[[initkeyboard()]] internally enables raw access to the keyboard
by writing [[rawon]] in [[/dev/consctl]].
%
[[initkeyboard()]] internally uses [[/dev/cons]], but wraps 
the device file in a data structure ([[Keyboardctl]]) allowing also
the use of {threads} and {channels}.
%rio-reflection:
Again, as you will see in Chapter~\ref{chap:main},
[[rio]] itself calls [[initkeyboard()]] at startup time.
\l and use Keyboardctl
  
\subsubsection{Other [[/mnt/wsys/]] files}

%trans:
I just presented the main files served by [[rio]] to its window processes. 
Those files are virtual versions of device files managed by the kernel.
%dup: intro/other-system ...
Thanks to those virtual devices, [[rio]] is a transparent
windowing system enabling graphical applications to run inside windows.
\l why also can even run rio inside rio!

[[rio]] serves also files that are interfaces to
advanced features of the windowing system itself.
%
Here is the list of those files and a short description
of their content (Chapter~\ref{chap:window-files}
and Chapter~\ref{chap:advanced} will give more details about those files):

\begin{itemize}

\item [[/mnt/wsys/winid]]: This read-only file contains a 
number unique to each window, the {\em window identifier}.
This identifier is useful in conjunction with [[/mnt/wsys/wsys/]] 
presented below.

\item [[/mnt/wsys/label]]:
[[rio]] does not use title bars, but each window can write a string
called a {\em window label} in its [[/mnt/wsys/label]] file,
to describe the window. 
This label is then used by the system menu; 
the menu lists all the hidden windows by their labels
(see Section~\ref{sec:window-hide})
\l other uses of labels?

\item [[/mnt/wsys/screen]]: This read-only file contains an image
\l dynamic image
(in the \plan image format) representing the content of the screen
at the moment [[/mnt/wsys/screen]] was read.
Thanks to this file, it is very easy to take screenshots in \plan.
\l no need fancy app! lens.c uses it too.
\l can use that for accessibilty?


\item [[/mnt/wsys/window]]: This read-only file contains
also an image, but representing only the content of the window.

\item [[/mnt/wsys/text]]: This read-only file is useful
only for textual windows. It contains a full dump of the text
displayed in the terminal.
\l useful for?

\item [[/mnt/wsys/snarf]]: This file is used for copy-pasting
(see Section~\ref{sec:snarf}).

\item [[/mnt/wsys/wdir]]: This file is used for filename completion 
(see Section~\ref{sec:wdir}).

\item [[/mnt/wsys/wsys/]]: This directory allows to explore
the set of windows. [[/mnt/wsys/wsys/]] is to windows
what [[/proc/]] is to processes (see the \book{Kernel}).
The {\em key} used for [[/mnt/wsys/wsys/]] is not the
process identifier, as in [[/proc]], but the window identifier
presented above.
%
Just like [[/mnt/wsys/]] contains
files representing information about the window of the program,
[[/mnt/wsys/2/]] contains the same files but representing
the information about the window with the window identifier [[2]].



\item [[/mnt/wsys/wctl]]: This file is used to control programmatically 
a window.
%
Just like a user can use the mouse to act on a window, for instance,
by clicking on the border of a window to resize it,
a program can use [[/mnt/wsys/wctl]] to do similar things.
By writing {\em control commands} in [[/mnt/wsys/wctl]], a program
can control its own window.
\l so resize API?
In fact, a program can control also
another window, for instance, by writing in [[/mnt/wsys/wsys/2/wctl]]
(see Section~\ref{sec:mnt-wsys-wctl} for more information).
\l very powerful, lots of uses. Selenium style?


\end{itemize}

%dup: (adapted) Graphics.nw
For more information on the files served by [[rio]]
and their format, I refer you to the documentation of
[[rio]] in [[docs/man/4/rio]] in my \plan repository.
\t also files in /srv/, see Section X.

%% also has special files in /srv/
%% for external process to create new window and still have the mount.
%% for processes outside rio namespace.
%% wsys and wctl are advanced stuff we can delay
%% wctl for sure, allow to control rio from command line but less important
%%/srv
%% rio.user.pid
%% riowctl.user.pid
%%env var:
%% $wsys (e.g., /srv/rio.pad.21)
%% $wctl (e.g., /srv/riowctl.pad.21)
%%
%%can also ctl rio by writing in $wctl
%% also have fileserver that can take command (e.g., wctlnew())
%% the fileserver offer also virtual views for the apps running
%% inside the windows
%% mount #s/rio.user.pid /mnt/wsys 1
%% mount -b #s/rio.user.pid /dev
%
%% manual creation of window (not via menu) see rio(5)
%% mount $wsys /tmp 'new -r 0 0 128 64 -pid' $pid
%% echo hi > /tmp/cons
%% :)







\section{[[hellorio.c]]}
\label{sec:hellorio}

%GUI architectures:
%https://martinfowler.com/eaaDev/uiArchs.html

%trans:
Now that you know the principles and the interfaces of [[rio]],
%
I can present the code of a toy {window application}: [[hellorio]].


[[hellorio]] is a simple application written in C displaying initially
[[Hello Rio]] at the location of the mouse. Then, when the user types
a key, the [[Hello Rio]] message is replaced by the typed character,
as illustrated in Figure~\ref{fig:hellorio}.
Finally, you can quit the application by typing the letter [['q']] (for quit).
\l cleaner than hello world for X11. No need expose ugly stuff! (but resize)
\n and actually hello-also-non-english-world!

\begin{figure}\begin{center}
\includegraphics[width=8cm]{hellorio}
\end{center}
\caption{[[hellorio]] running in a window, after the user typed [['m']].}
\label{fig:hellorio}
\end{figure}


The goal of this section is to illustate some of the concepts I
introduced before with concrete code.
\l which concepts? windowing system API? like use of view? initmouse? initdraw?
\l  but can not see use of virtual files directly, sad
%rio-reflection:
Moreover, the code of [[hellorio]] in [[hellorio.c]],
although simplistic, is a good introduction to the code of [[rio]] itself. 
Indeed, [[rio]] also needs to use the mouse, the keyboard, or 
draw things on the screen. 
[[hellorio.c]] will introduce also the use of channels and threads, which are 
heavily used by [[rio]].
\n threads and procs implicitely, but still introduces defs of channel/threads
\n also define Rune


I already presented in the \book{Graphics} the code of a toy
{graphical application}: [[hellodraw]]. 
%dup: overview/principles/api
As I said in Section~\ref{sec:windowing-system-api}, a graphical application
can also be a window application under \plan.
%
However, this requires a few changes in the code of the graphical application,
for instance, the use of the global [[view]] as mentioned
in Section~\ref{sec:winname}. 
[[hellodraw]] was not using this global, and so could not run inside a window.
\n well it can but then it's ugly
%
Moreover, [[hellodraw]] was just using the graphics facilities of [[draw]],
with functions from [[draw.h]]. 
[[hellorio]] is an interactive graphical application that also uses 
the mouse and the keyboard, with functions from [[mouse.h]] and [[keyboard.h]].
%
Finally, by handling the resize event, [[hellorio]]
can also become a window application.
\l correct window application, nice citizen
\l this is why I do not use hellodraw.c as an example

%react sucks, event model is far better:
% https://tech.polyconseil.fr/code-your-js-app-like-its-86.html

\subsection{Skeleton and output code}
\label{sec:hellorio-skeleton}

Here is the skeleton of [[hellorio.c]]:

<<tests/rio/hellorio.c>>=
#include <u.h>
#include <libc.h>

#include <draw.h>
#include <mouse.h>
#include <keyboard.h>

#include <thread.h>

Image *bgcolor;
Point mouseloc;
Rune str[20];

<<type EventType (hellorio.c)>>

void redraw(void);

void threadmain(int argc, char* argv[]) {
  int result;
  Keyboardctl* keyboardctl;
  Mousectl*    mousectl;
  <<[[threadmain()]] other locals (hellorio.c)>>

  result = initdraw(nil, nil, "Hello Rio");
  <<[[threadmain()]] sanity check result (hellorio.c)>>
  mousectl = initmouse(nil, view);
  <<[[threadmain()]] sanity check mousectl (hellorio.c)>>
  keyboardctl = initkeyboard(nil);
  <<[[threadmain()]] sanity check keyboardctl (hellorio.c)>>

  bgcolor = allocimage(display, Rect(0,0,1,1), RGBA32, true, DMagenta);
  runestrcpy(str, L"Hello Rio");
  mouseloc = Pt(200, 200);

  <<[[threadmain()]] alts setup (hellorio.c)>>
  redraw();
  <<[[threadmain()]] event loop (hellorio.c)>>
}

void redraw(void) 
{
  draw(view, view->r, bgcolor, nil, ZP);
  runestring(view, mouseloc, display->black, ZP, font, str);
  flushimage(display, true);
}
@
\l str[20] for size of rune buffer in Keyboardctl.c 
\l  USED(argc); USED(argv);
%ocaml: dont have to use global, can pass them to redraw
% and can have initdraw return a display
%ocaml: less nil, better interface with default values (or remove
% useless genericity of the interface)

Here are a few important things to note about 
the skeleton of [[hellorio.c]], from top to bottom,
as well as how the code compares to the code of [[hellodraw.c]] 
in the \book{Graphics}:
\l put some Line X. would be clearer.

\begin{itemize}

\item In addition to [[draw.h]], [[hellorio.c]] also includes
[[mouse.h]] and [[keyboard.h]], as it uses the mouse and
the keyboard.


\item [[hellorio.c]] also includes [[thread.h]], a header file
containing functions related to threads,
the [[Channel]] structure, and the declarations of
primitives operating on channels (e.g., [[send()]], [[recv()]]).
\l also Alt
%dup? Libcore 
A {\em channel} is essentially a {queue} of {\em messages}.
\l buffered or unbuffered queue
%
Threads communicate and {synchronize} with each
other by exchanging messages through channels
(see the \book{Libcore}).
\l based on Alef, Newsqueak, and more generally CSP
%
Even though the code in [[hellorio.c]] does not create
threads explicitely, some of the functions called from
[[hellorio.c]] (e.g., [[initmouse()]], [[initkeyboard()]])
do create threads internally
(see the \book{Graphics}).
\n actually procs, not threads, but procs also create (single) threads

%dup? Libcore
The \plan thread library defines two separate constructs
to carry computations: {threads} and {procs}.
%dup: (shorten) 2/thread
A {\em proc} is a \plan process containing 
{cooperatively-scheduled} {\em threads}.
%
Remember that in \plan, processes can share memory with each other
(via the [[RFMEM]] flag to [[rfork()]], see the \book{Kernel}).
%
Thus, just like multiple threads in the same proc share memory,
multiple procs can also share memory,
and can communicate with each other through channels declared 
in this shared address space.
\t then what is the difference? why need 2 constructs?
%
In other operating systems, a \plan proc is similar to a {\em system thread},
and a \plan thread is similar to a {\em light-weight thread} 
(or a {\em coroutine}).
\l and channel is?
\t both are useful, both have pro and cons, depending on task. explained later.
\l  pro of light-weight is cheap and no need lock inside same proc cos
\l  never run in parallel

%dup: Graphics.nw
\item As I said in the \book{Graphics}, with [[draw]]
{\em everything is an image}, including colors, as shown 
by the type of the global [[bgcolor]].


\item The key typed by the user is stored in an array of [[Rune]]s.
%dup? Libcore
A {\em rune} is the name given to
a {\em unicode character} in \plan (see the \book{Libcore}).
%
The type of a key entered in the keyboard is not a [[char]]
but a [[Rune]] in \plan, which is convenient.
%
Indeed, the code of [[hellorio.c]] will work also if the user
enters {chinese characters}, or letters with european accents.
%
Even special combinations such as the [[Control]] key and the [[d]] key
will return a single rune, whose representation [[^d]] will
be correctly displayed on the screen (thanks to [[runestring()]] called
in [[redraw()]]).
\l this simplifies programming, e.g. efuns?
\l but then can catch just hitting Control?


\item Most of the graphics-related code is not
in [[main()]], as in [[hellodraw.c]], but in a separate
function: [[redraw()]]. This is because this code will be
called multiple times, after each input event, as you will see soon.


\item The entry point of [[hellorio.c]] is not 
[[main()]] but [[threadmain()]]. 
%dup: 2/thread
Indeed, the thread library provides already a [[main()]]
that sets up a proc with a single thread executing [[threadmain()]].
\l done because automagically link when include thread.h (see \book{Linker})
\l bootstrap, setup scheduler


\item Similar to [[hellodraw.c]], the first call of [[hellorio.c]]
is to [[initdraw()]], to connect to the display server.
%
[[hellorio.c]] also calls [[initmouse()]] and [[initkeyboard()]]
to connect respectively to the mouse and the keyboard device.
%dup? Graphics.nw
Those two functions internally create a proc 
\t containing a single thread, but then confusing?
reading synchronously on respectively [[/dev/mouse]] and [[/dev/cons]]
(see the \book{Graphics}).
%
Those two functions uses a proc,
\t creates a new proc, and not just simply a thread, because if
\t thread then would block.
and not a thread, because
a thread should not block. Indeed, if for instance a thread is blocked
on a read on [[/dev/mouse]], the other threads in the same proc
\t including threadmain
would also be blocked. Threads are cooperatively-scheduled;
they need to cooperate with each other.
\t by using a proc for code doing IO, safe. Proc with single thread, so block only himself
\l was similar in ocaml before? also issue in lwt no?



\item Regarding the graphics-related code, [[hellorio.c]] is very
similar to [[hellodraw.c]], with the use of functions
of [[draw.h]] such as [[allocimage()]], [[draw()]], [[runestring()]], 
or [[flushimage()]].
%
The main difference is the use of the global [[view]], set by
[[initdraw()]] (see Section~\ref{sec:winname}), instead of [[display->image]],
for the arguments of the drawing functions.
\l security issue, can still draw on the whole screen, hmm
\t use originWindow! by default! so even less change compared to hellodraw.c
%old:
% a bit annoying that have to transform your xy into the final
% xy ourself by adding view->r.min. Not really "abstraction"
% power. I'd rather have my 0x0 to be the top left on _my_ window.
%update: actually you can, but you have to make your image a window
% which means you also have to create a Screen first.

\end{itemize}

The skeleton of [[hellorio.c]], above, omits the error management
code shown below:

<<[[threadmain()]] sanity check result (hellorio.c)>>=
if (result < 0)
  exits("Error in initdraw");
@
<<[[threadmain()]] sanity check mousectl (hellorio.c)>>=
if(mousectl == nil)
  exits("can't find mouse");
@
<<[[threadmain()]] sanity check keyboardctl (hellorio.c)>>=
if(keyboardctl == nil)
  exits("can't find keyboard");
@
%ocaml: use exn

In the rest of this book, I will usually not comment the 
error-management code. Such code is often trivial (but necessary).

\subsection{Input code}
\label{sec:hellorio-input-code}

%trans:
I have shown the code responsible for the visual {output} of [[hellorio]].
%
I can now present the code dealing with the {inputs} to [[hellorio]],
making [[hellorio]] an {interactive} program.


[[hellorio]] must handle three different kinds of inputs: inputs 
from the mouse,
from the keyboard, and 
from the windowing system itself with its resize event.
%
The type below defines those different {\em event types} for [[hellorio]]:

<<type EventType (hellorio.c)>>=
enum EventType {
  EMouse,
  EKey,
  EResize,

  NALT
};
@
\l explain NALT? classic, like in Assembler.nw
%ocaml: use ADT and typed channels instead of flat generic enum
% so less need those .v, .c fields. and intermediate Alt type
% (but still need an intermediate event type that does the union of
% the events for a particular thread)

[[hellorio]] needs to deal {\em simultaneously} with the mouse,
keyboard, and windowing system. Indeed, the program can not just
synchronously read [[/dev/mouse]]; maybe the next event will be
a keyboard event, not a mouse event.
%
To do so, the [[thread.h]] header file defines the 
[[Alt]] (for alternative) structure.
%dup: overview/interface/fs/mouse
As mentioned in Section~\ref{sec:mnt-wsys-mouse},
there is no [[select()]] system call in \plan.
%
Instead, \plan provides the [[alt()]] function
(see the \book{Libcore})
that takes as an argument a {map} of event types to [[Alt]].
\l signature of alt()?
This map is stored first in a local variable:

<<[[threadmain()]] other locals (hellorio.c)>>=
// map<EventType, Alt>
Alt alts[NALT+1];
@
%ocaml: specialized ADT directly

%dup? 2/thread?
Each value of this map (each ``alternative'') contains essentially a channel. 
A call to [[alt()]] will then return if anything is exchanged 
(received or sent) on {\em one of the channels} of the map.
%
In fact, [[alt()]] will also return the event type associated with
the channel in which a message was exchanged.
\l if multiple messages exchanged? first? both?
%
With [[alt()]], it is possible to {listen} to multiple channels
at the same time (or to {emit} to multiple channels at the same time).
\l for emit too, cos can emit only if ready

For each event type, the local variable [[alts]] is initialized
with the channel to receive from (or send to) in the [[Alt.c]] field:


<<[[threadmain()]] alts setup (hellorio.c)>>=
alts[EMouse].c = mousectl->c;
alts[EMouse].v = &mouse;
alts[EMouse].op = CHANRCV;

alts[EKey].c = keyboardctl->c;
alts[EKey].v = keys;
alts[EKey].op = CHANRCV;

alts[EResize].c = mousectl->resizec;
alts[EResize].v = nil;
alts[EResize].op = CHANRCV;
@
%ocaml: similar; use Event.wrap and Event.select and no need
% intermediate Alt .c .v .op untyped, just use ADT

The [[Alt.op]] field contains the type of {\em channel operation},
Here, [[CHANRCV]] because the program is listening (receiving)
on all channels. It is also possible to emit simultaneously
on multiple channels by using instead [[CHANSND]].
\l can send only if other party is ready to receive.

[[mousectl]] and 
[[keyboardctl]], above, are 
two local variables containing the return value of respectively
[[initmouse()]] and 
[[initkeyboard()]]
(see the skeleton of [[hellorio.c]]).
%
The types of those variables are respectively
the structure [[Mousectl]] and
the structure [[Keyboardctl]], 
defined respectively in
[[mouse.h]] and
[[keyboard.h]].
Both structures are explained in the \book{Graphics}.
%
The most important fields in those structures are [[Mousectl.c]]
and [[Keyboardctl.c]] which are the channels used to communicate
with the procs created by [[initmouse()]] and [[initkeyboard()]].
\l actually the single thead in proc. see explanation of skeleton earlier
%
For instance, the proc created by [[initmouse()]] reads synchronously
on [[/dev/mouse]], and when [[read()]] returns data, this data
is sent on [[Mousectl.c]]. This data can then be read by any thread
receiving on [[Mousectl.c]].
%
Thanks to [[alts]], [[hellorio]] can listen simultaneously on changes
in [[/dev/mouse]] or [[/dev/cons]].


The field [[Alt.v]] must contain a pointer to an area where 
to store the data received on a channel (or the data to send,
if the channel operation was [[CHANSND]]).
The size of this area depends on the {\em channel type} 
(see the \book{Libcore}).
%
For the keyboard, [[Keyboardctl.c]] is a channel containing up to
20 buffered keys (so even if the user types really fast, no data is lost).

<<[[threadmain()]] other locals (hellorio.c)>>=
Rune keys[20];
@

For the mouse, [[Mousectl.c]] is a channel containing just one [[Mouse]]:

<<[[threadmain()]] other locals (hellorio.c)>>=
Mouse mouse;
@
\l both this local are taken address of by code above


Each array of [[Alt]]s must finish with a special {\em end marker}: 
[[CHANEND]].

<<[[threadmain()]] alts setup (hellorio.c)>>=
alts[NALT].op = CHANEND;
@

% \subsection{The event loop}

I can finally show the last piece of code of [[hellorio.c]]:
the {\em event loop} and the call to [[alt()]]:
\n I call it event loop even if it's not from event.h, because similar spirit

<<[[threadmain()]] event loop (hellorio.c)>>=
for(;;) {
  switch(alt(alts)){
  <<[[threadmain()]] event loop cases (hellorio.c)>>
  }
  redraw();
}
@
\l you will see many times this kind of loop and switch

When one of the channel in [[alts]] receives a message,
[[alt()]] returns the corresponding event type.
%
The program can then switch on the event type,
inspect the {message} referenced from [[Alt.v]],
and modify globals.


For the mouse, the program modifies the global [[mouseloc]] with
the last coordinate of the mouse:

<<[[threadmain()]] event loop cases (hellorio.c)>>=
case EMouse:
  mouseloc = mouse.xy;
  break;
@

This global is then used in [[redraw()]] as a parameter to [[draw()]]
to display some text at the right location.


For the keyboard, the program modifies the global [[keys]].
%
As mentioned above, the channel type of [[keyboardctl->c]] is an array 
of 20 runes.
%
A channel is a bufferred or unbuffered queue of messages.
%
The call to [[alt()]] stores only one message in the area pointed by [[Alt.v]].
%
It is the responsibility of the programmer to call [[nbrecv()]] to transfer 
the remaining messages in the queue.
\t not super clear

\ifallcode
<<[[threadmain()]] other locals (hellorio.c)>>=
int i;
@
\fi
<<[[threadmain()]] event loop cases (hellorio.c)>>=
case EKey:
    for(i=1; i<nelem(keys)-1; i++)
        if(nbrecv(keyboardctl->c, keys+i) <= 0)
            break;
    keys[i] = L'\0';
    runestrcpy(str, keys);
    if(keys[0] == L'q')
      exits("done");
    break;
@
%ocaml: how to use buffered channels with size in OCaml?

For the resize event, the program just needs
to call [[getwindow()]], which will update the global [[view]],
as explained in Section~\ref{sec:mnt-wsys-mouse}:

<<[[threadmain()]] event loop cases (hellorio.c)>>=
case EResize:
  if(getwindow(display, Refnone) < 0)
    exits("failed to re-attach window");
  break;
@

%trans:
This concludes the code of [[hellorio.c]].

With command-line programs, the program is in control;
the program ask questions to the user. 
With graphical applications (and window applications), the
user is in control; the application {\em reacts} to external events. 
%
This is a new programming model. The application is more than
an interactive program, it is a reactive program.
\l reactive not proactive. callback.
\l inside-out style (see Mini-X tutorial; I saw that sentence other times)


%\subsection{Events versus threads}
% instead of channels (and threads) and alt(), alternative is to use events

% Seen multiple input devices: mouse, keyboard 
% (and potentially also input from rio itself when resize event or move)
% But issue of synchrony.
%dup? Graphics.nw
% In fact already had issue in Graphics.nw.
% 2 models:
% events: one activity, multiple source of events (and asynchronous)
% threads: multiple activities, multiple source of events (and asynchronous)

% for threads, under the hood, it's alts() and channels, shared memory
%  and atomic increment (=~ futex?)
% for events, it's a pipe from one master to multiple slaves and read().

% input events
% user-generated events (action with window manager)
%  expose event! resize event!

%alt: threads and channels! keyboard thread, mouse thread! display thread
% (but rely on event loop under the hood for thread scheduler?)




\section{Code organization}

The code of [[rio]] in my \plan repository 
is split in multiple directories, but the
most important one is [[windows/rio/]].
%
%dup: (and adapted) from Assembler.nw
Table~\ref{tab:code-orga} presents short descriptions
of the source files in [[windows/rio/]], as well as
the main entities (e.g., structures, functions, globals) the file defines,
and the corresponding chapter in this document in which the code
contained in the file is primarily discussed.
%
The other directories of [[rio]] correspond to libraries used 
by code in [[windows/rio]]:
\begin{itemize}

\item [[windows/libframe/]]: This library contains the generic
code of a {\em text widget}. This widget consists of
a scrollbar on the left and an editable text area on the right. 
This library is used by the terminal emulator of [[rio]], and is discussed in 
Section~\ref{sec:frame-widget}. 
%
This library is also used by the \plan editor Acme.

\item [[windows/libplumb/]]: This library is used to interact
with the \plan{} {\em plumb} mechanism~\cite{plumb},
which is triggered in [[rio]]
by the middle-click menu of the terminal emulator 
(see Section~\ref{sec:plumb}).
%
Plumbing is a generalization of the cut-and-paste, drag-and-drop,
and Multipurpose Internet Mail Extensions
(MIME) mechanisms found in maintream operating systems.
%
It allows applications to cooperate with each other without
having to know each other.

\item [[windows/libcomplete/]]: This library is used to provide
filename completion in the terminal emulator 
(see Section~\ref{sec:completion}).

\end{itemize}

The code of [[rio]] depends also on code in [[lib_graphics/]]
and [[lib_core/]], but the code in those directories is explained 
respectively in the \book{Graphics} and \book{Libcore}.
\l also lib9p?


\begin{table*}[tbh!]
\begin{center}
\begin{tabular}{lcllr}
\toprule
{\bf Function}  & {\bf Ch.} & {\bf File} & {\bf Entities} & {\bf LOC} \\
\otoprule
data structures & \ref{chap:core-ds}           & [[dat.h]]                & [<Window>] [<Filsys>] [<Fid>] [<Xfid>]                                    & 0 \\ % Qxxx Wctlmesg
%  and constants
globals                       & \ref{chap:core-ds}           & [[globals.c]]            & [<mousectl>] [<windows>] [<input>] [<filsys>]               & 0 \\ % was in dat.h before [<keyboardctl>]

\midrule
entry point                   & \ref{chap:main}              & [[rio.c]]                & [<threadmain()>]                                                          & 0 \\         
% filsysinit called by main, from fsys.c, xfidinit() in xfid.c
prototypes                    & \ref{chap:main}              & [[fns.h]]                &                                                                           & 0 \\ 

\midrule

keyboard thread               & \ref{chap:processes-threads} & [[thread_keyboard.c]]   &  [<keyboardthread()>]                                                     & 0 \\ % was rio.c before
mouse thread                  & \ref{chap:processes-threads} & [[thread_mouse.c]]      &  [<mousethread()>]                                                        & 0 \\ % was rio.c
window threads                & \ref{chap:processes-threads} & [[threads_window.c]]    &  [<winctl()>]                                                             & 0 \\ % was wind.c
%thread_workerallocator.c
fileserver proc               & \ref{chap:processes-threads} & [[proc_fileserver.c]] & [<filsysproc()>] [<filsysmount()>]                        & 0 \\ % was in fsys.c before % [<filsysinit()>]
master and worker threads     & \ref{chap:processes-threads} & [[threads_worker.c]]    & [<xfidctl()>]                                              & 0 \\ % was in xfid.c before % [<xfidinit()>] 

\midrule

cursor graphics               & \ref{chap:cursor}            & [[data.c]]               & [<crosscursor>] [<corners>]                                                & 0 \\ 
cursor operations             & \ref{chap:cursor}            & [[cursor.c]]             & [<riosetcursor()>]                                                        & 0 \\ %pad: was in wind.c before %related: cornercursor() wsetcursor()

\midrule

window manager                & \ref{chap:wm}                & [[wm.c]]                 & [<button3menu()>] [<new()>] [<drag()>]                                    & 0 \\ %pad: was in rio.c before
window process creation       & \ref{chap:wm}                & [[processes_winshell.c]]   & [<winshell()>]                                                            & 0 \\ %pad: was in wind.c before
window methods                & \ref{chap:wm}                & [[wind.c]]               & [<wtop()>] [<wclose()>]                                    & 0 \\  % [<wpointto()>] 
closing threads               & \ref{chap:wm} & [[threads_misc.c]]      &  [<deletethread()>] [<winclosethread()>]                                  & 0 \\ % was rio.c

\midrule

fileserver utilities          & \ref{chap:filesystem-server} & [[9p.c]]                 & [<filsysrespond()>] [<filsyscancel()>]                                    & 0 \\ % was in fsys.c before
fileserver methods            & \ref{chap:filesystem-server} & [[fsys.c]]               & [<filsysattach()>] [<filsysopen()>]                                       & 0 \\ % dirtab fcall 

\midrule
virtual device methods        & \ref{chap:virtual-devices}   & [[xfid.c]]               & [<xfidopen()>] [<xfidread()>]               & 0 \\                 % [<xfidwrite()>]

\midrule
 
graphical window   & \ref{chap:graphical-windows} & [[graphical_window.c]]   & [<waddraw()>]                                                             & 0 \\ %pad: was in wind.c before
% operations

\midrule
terminal emulator             & \ref{chap:textual-windows}   & [[terminal.c]]           & [<winsert()>] [<wshow()>] [<wkeyctl()>] & 0 \\ %pad: was wind.c before [<button2menu()>] [<wmousectl()>]
% frame.h, frame.c  Frame frinit() 
% editor.c? wselect.c?
terminal scrolling            & \ref{chap:textual-windows}   & [[scrl.c]]               & [<wscrdraw()>] [<wscroll()>]                                              & 0 \\

% chap 12: \ref{chap:window-files}, xfid.c again

\midrule

external window control       & \ref{chap:advanced}          & [[wctl.c]]               &  [<wctlthread()>] [<parsewctl()>]                            & 0 \\ % [<wctlproc()>]
copy/paste clipboard          & \ref{chap:advanced}          & [[snarf.c]]              & [<putsnarf()>] [<getsnarf()>]                                             & 0 \\
%  TODO put globals there
timer                         & \ref{chap:advanced}          & [[timer.c]]              & [<timerstart()>]                                                          & 0 \\
% timer for what? scrolling?

% srv.c?
% completion.c? 
% debugging.c? with wkeyboard stuff? keyboardhide()?
% hold.c?

\midrule

error management              & \ref{chap:error}             & [[error.c]]              & [<error()>] [<derror()>]                                                  & 0 \\ %pad: was in rio.c before
utilities                     & \ref{chap:utilities}         & [[util.c]]               & [<min()>] [<emalloc()>] [<strrune()>]                                     & 0 \\

\otoprule
Total                         &                              &                          &                                                                           & 8142 \\
\bottomrule
\end{tabular}
\end{center}
\caption{Chapters and source files of [[windows/rio/]].}
\label{tab:code-orga}
\end{table*}
\n see SRC_VIEWS in the Makefile, and make loc



\section{Software architecture}
\l maybe put code orga after soft archi?

[[rio]] is first a \plan graphical application. 
It is not a special program;
it relies, like all graphical applications,
on devices managed by the \plan kernel and its graphics stack:
\begin{itemize}

\item [[/dev/draw/]] to access the display device

\item [[/dev/mouse]] and [[/dev/cursor]] to access the mouse device

\item [[/dev/cons]] and [[/dev/consctl]] to access the keyboard device

\end{itemize}

[[rio]] communicates with the kernel through {system calls}
(e.g., [[open()]], [[read()]]) on those devices
(see the \book{Kernel}).

%toc?
%\subsection{Library dependencies}

In fact, [[rio]] does not use directly those devices. Instead, it
uses functions from [[draw.h]], [[mouse.h]], and [[keyboard.h]].
Those header files offer data structures and functions that are 
convenient wrappers around those device files.
%
Thus, [[rio]] depends mainly on [[lib_graphics/libdraw/]], the
library behind [[draw.h]], [[mouse.h]], and [[keyboard.h]]
(see the \book{Graphics}).
\n depends only on libdraw; not libmemdraw or libmemlayer.


[[rio]] uses many functions from [[draw.h]], but also
many functions from [[window.h]].
\l rename layer.h?
Indeed, [[rio]] makes heavy use of [[draw]]'s {layers}
(see Section~\ref{sec:layer-introduction} for an introduction to layers).
%
Many of the window management tasks are actually done by [[draw]], not [[rio]].
For instance, it is the [[draw]] function [[topwindow()]] which
does most of the heavy lifting when you click on a window 
to put it at the top;
it is [[topwindow()]] that restores the pixels overlapped previously 
by other windows.


[[rio]] is also a \plan filesystem that communicates with
the kernel using the 9P protocol 
(see the \book{Network}).
%
[[rio]] is a file server that answers to file requests on virtual
devices accessed by its windows.
\l multiplexer approach. 
Thus, [[rio]] must be two different things at once: a GUI and a server.
%
Moreover, [[rio]] must {coordinate} many {\em independent} {activities}:
user actions with the keyboard,
user actions with the mouse,
computations in the window processes, and
actions from those window processes such as file requests on virtual devices.
\n for draw done separately actually
What is a good software architecture to deal with all those activities?
%
A natural architecture is to use {\em threads}. Indeed, each independent
activity can be represented by an independent thread.
Then, {\em channels} can be used to communicate messages between threads.
%
Both channel and thread functions are declared in [[thread.h]].
Thus, in addition to [[lib_graphics/libdraw/]], [[rio]] depends also on 
[[lib_core/libthread/]], the library behind [[thread.h]]
(see the \book{Libcore}).


%toc:
I will present in the next section the thread (and process)
architecture of [[rio]].
%dup: (changed component -> thread) Graphics.nw
A good way to understand how those threads work together is to
{\em trace} a {user action} through those different threads.
%toc:
This is why in the following sections, I will also explain 
the trace resulting from the creation of a new window by the user, 
the trace of a mouse click and key press in this window, and 
the trace of a call to a drawing function by the program running in this window.

%like me: https://wayland.freedesktop.org/architecture.html
%"A good way to understand the wayland architecture and how it is
%different from X is to follow an event from the input device to the
%point where the change it affects appears on screen."

\subsection{Processes,  procs, and threads relationships}
\label{sec:thread-archi}

Figure~\ref{fig:soft-archi-threads} presents the threads
and processes resulting from the execution of [[rio]]
and two other programs in two different windows,
as displayed in Figure~\ref{fig:hellorio-and-shell}.
%dup: overview/hellorio
As mentioned in Section~\ref{sec:hellorio}, the \plan thread library 
provides two separate constructs to represent computation: 
{procs} and {threads}.
A {proc} is a \plan process containing one or more
{cooperatively-scheduled} {threads}.
%legend:
Procs and processes are represented by enclosing rectangles
in Figure~\ref{fig:soft-archi-threads},
\l  except kernel and devices
while threads are represented by enclosed rectangles.
%
Moreover, multiple procs sharing the same address space are enclosed 
by a dashed rectangle.



\begin{figure}[!]\centering
\begin{verbatim}
+ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
     rio        +----------------------------------------------+
|               |  main proc       +----------+  +----------+  | +----+ |
   +----------+ |                  |threadmain|  |  Worker  |  | |+--+|
|  |+--------+| |  +--------+      |          |  |allocator <--+->|  || |
   ||        || |  |Keyboard|      +----------+  +----------+  | ||  ||
|  ||IO proc |+-+--> thread |  +----------+  +--------------+  | ||f || |
   ||keyboard|| |  |        +-->          <-->   Worker 1   |  | ||i ||
|  ||        || |  +---+----+  | Window 1 |  |(r wsys/cons) <--+->|l || |
   |+--------+| |      |       |(terminal)|  +--------------+  | ||e ||
|  +----^-----+ |      |  +---->          <-->   Worker 2   |  | ||s || |
  +-----+       |      |  |    +----------+  |(w wsys/cons) <--+->|e ||
| |             |      |  |                  +--------------+  | ||r || |
  | +---------+ |      |  |    +----------+  +--------------+  | ||v ||
| | |+-------+| |      +--+---->          <-->   Worker 3   <--+->|e || |
  | ||       || |  +------+-+  | Window 2 |  |(r wsys/mouse)|  | ||r ||
| | ||IO proc|| |  | Mouse  |  |(hellorio)|  +--------------+  | ||  || |
  | || mouse |+-+--> thread +-->          <-->   Worker 4   <--+->|  ||
| | ||       || |  |        |  +----------+  |(r wsys/cons) |  | |+--+| |
  | |+-------+| |  +--------+                +--------------+  | +-^--+
| | +---^-----+ |                                              |   |    |
  |     |       +----------+-----------------------------------+   |
+ + - - + - - - - - - - - -|- - - - - - - - - - - - - - - - - - - -|- - +
  |     |                  |         +-----------+    +---------+  |
  |     +-------+          |         | hellorio  |    |  shell  |  |
  |             |          |         |  process  |    | process |  |
  |             |          v         +-----------+    +---------+  |
 /dev/cons  /dev/mouse /dev/draw/1  /mnt/wsys/mouse  /mnt/wsys/cons|
     ^          ^          |        /mnt/wsys/cons^         | ^    |
     |          |          |        /dev/draw/2 ^ |         | |    |
     |          |          |             |      | |         | |    |
+----+----------+----------v-------------v------+-+---------v-+----v--+
|    |          |          |    Kernel   |       <---------------->   |
+----^----------^----------+-------------+----------------------------+
     |          |          v             |
 +--------+ +--------+ +---------+       |
 |Keyboard| | Mouse  | | Display |       |
 | device | | device | | device  |<------+
 +--------+ +--------+ +---------+
\end{verbatim}
\caption{Processes, procs, and threads in [[rio]].}
\label{fig:soft-archi-threads}
\end{figure}
\n seems like acme has a similar archi
\n wctlproc and timerproc are not shown, to simplify
\n hellorio is actually also a terminal, shell and then below forked hellorio
\l  (unless can do exec hellorio from the shell?) and also has some IO procs.

\begin{figure}\begin{center}
\includegraphics[width=8cm]{hellorio-and-shell}
\end{center}
\caption{[[hellorio]] and a shell running in two different windows.}
\label{fig:hellorio-and-shell}
\end{figure}


Figure~\ref{fig:soft-archi-threads} can be decomposed in four different layers:
\l confusing to use layer?

\begin{itemize}

\item {The hardware layer}, at the very bottom

\item {The kernel layer}, providing abstractions of the hardware

\item {The filesystem layer} (and its many device files), one of the
main abstractions offered by the kernel

\item {The user processes layer}

\end{itemize}

The user processes %in Figure~\ref{fig:soft-archi-threads}
can themselves be divided in three different groups:

\begin{itemize}
\item A set of procs created by [[rio]] and sharing the same address space,
at the top of Figure~\ref{fig:soft-archi-threads}

\item The [[hellorio]] process (see Section~\ref{sec:hellorio}),
running inside a window on the right in Figure~\ref{fig:hellorio-and-shell}

\item A shell process, running in a terminal emulator on the left in 
Figure~\ref{fig:hellorio-and-shell}.

\end{itemize}

%trans:
Of course, the most important group is the first group, 
which contains the procs of [[rio]].
%
[[rio]] is made of four different procs:

\begin{itemize}

\item [[IO-proc-keyboard]]: A proc containing a single thread 
reading [[/dev/cons]],
at the top left in Figure~\ref{fig:soft-archi-threads}


\item [[IO-proc-mouse]]: A proc containing a single thread 
reading [[/dev/mouse]], 
at the middle left in Figure~\ref{fig:soft-archi-threads}

\item [[fileserver]]: A proc containing a single thread
communicating with the kernel using the 9P protocol,
at the top right in Figure~\ref{fig:soft-archi-threads}

\item [[main-proc]]: A proc containing many threads
writing in [[/dev/draw/1/]],
in the middle of Figure~\ref{fig:soft-archi-threads}

\end{itemize}

I mentioned already the first two procs in
Section~\ref{sec:hellorio} in the context of the [[hellorio]] 
program\footnote{In fact, 
[[hellorio]] in Figure~\ref{fig:soft-archi-threads} creates also two IO procs. 
They are not shown in the figure to simplify things.
Those procs would read [[/mnt/wsys/cons]] and [[/mnt/wsys/mouse]].
\l in fact also hide shell parent process of hellorio in Figure.
}.
%
They are the results of calls to respectively [[initkeyboard()]] and 
[[initmouse()]] by [[rio]] during startup.
\l but connect to real devices! also initdraw() so /dev/draw/1/
%
Both procs are usually blocked in a [[read()]] on a device file.
\n actually it is the single thread in the proc that is blocked (said later)
%
Once the user performs an action, with the keyboard or the mouse,
one of the [[read()]] returns and the corresponding proc (actually
the single thread in the proc)
sends a message on the [[keyboardctl->c]] or [[mousectl->c]] channels.
%
Two threads of [[main-proc]], the keyboard thread and the mouse thread,
are listening on those channels.

%dup? Libcore.nw?
The use of multiple procs and threads to read one device file is
due to the design of threads in \plan.
%dup: overview/hellorio
As mentioned in Section~\ref{sec:hellorio}, in \plan,
threads are scheduled cooperatively. They should avoid to block
on a system call doing IO. Indeed, if one of the thread in the
proc is blocked, all the threads in the proc are blocked 
(see the \book{Libcore}).
%dup? overview/hellorio?
\t This is why offload IO to external proc with single thread, so when single thread 
\l  block, does not bother any other threads in the proc
\l note that still shares same address space and  so shared channel with thread

\l a bit cumbersome to have separate procs and threads.
However, one advantage of this design is that threads do not need
to use {locks}, an error-prone concurrency construct,
for {mutual exclusion} with each other. 
By construction, only one thread of a proc is running at one time 
(but multiple procs can run in parallel).
\t and then use messages between threds of different procs to {synchronize}, 
\l  not lock.
\l single-threaded is a big deal? not really, cos it does not block
% heavy computation process from running. It only matters when there
% are events, but those events are mostly human events (mouse move, key press)
% and humans are very slow.
% (actually also every file request, but not for draw, so only
% for virtual device of mouse and keyboard, so same)


The third proc, [[fileserver]], creates a {\em pipe} and reads
in a loop one side of the pipe. 
On the other side of the pipe are clients of [[rio]]'s
filesystem
([[hellorio]] and the shell process in Figure~\ref{fig:soft-archi-threads}).
%
Section~\ref{sec:trace-new-window} will give more details
about this pipe and how [[rio]] and its clients communicate.
\n use mount with fd (said later)

%trans:
The last proc,
%
[[main-proc]], is the most important proc of [[rio]].
It contains many threads.
%
I mentioned already the keyboard and mouse threads above.
Both are created by [[threadmain]], the first thread of [[main-proc]].
%
Moreover, {\em each window is represented by a thread}.
%
Each window, in addition to being associated with an external process 
(e.g., the [[hellorio]] process in Figure~\ref{fig:soft-archi-threads}),
is also associated with a thread 
(e.g., [[Window-2]] in Figure~\ref{fig:soft-archi-threads}).
%
Finally, {\em each opened file of [[rio]]'s filesystem is
represented as a (worker) thread}.
\l also worker allocator
%toc:
The next sections will clarify how those threads work together.

\l Seen components in Figure X. But threads archi seems to not match components
\l Remember For rio: no window compositor,  display server outside, window manager and
\l terminal emulator together. All threads procs of rio =~ window manager.
\l input delivery job mainly.

%\subsection{Data structures relationships}
% meh, maybe too much stuff already to digest.

\subsection{Trace of a new window creation}
\label{sec:trace-new-window}

%trans:
In Figure~\ref{fig:soft-archi-threads},
[[threadmain]], the first thread of [[main-proc]],
creates the two IO procs on the left, the [[fileserver]] proc on the right,
and the keyboard and mouse threads in the middle.
%toc:
In this section, I will
explain the trace leading to the creation of the shell
and [[hellorio]] processes in Figure~\ref{fig:soft-archi-threads},
as well as the creation of the associated window threads. 
%
In the next section, I will explain the creation of the worker threads.

%dup: overview/interface/gui
As I said in Section~\ref{sec:rio-gui}, you create
a new window by first activating the system menu with a right-click,
then choosing [[New]] in this menu, and finally by
drawing a rectangle with the mouse specifying the dimension of a window.
%
The trace for those mouse actions will be explained soon in
Section~\ref{sec:trace-mouse-click}, but for now, the important
thing is that eventually the mouse thread of [[main-proc]] will be in control,
with the information about the new window dimension stored in a local variable.
%
It is the mouse thread that creates windows. 
%toc:
Each window creation involves the creation of 
a new process,
a new namespace,
a new [[Window]] structure,
a new {window thread}, and
a new {image layer}, 
as explained in the following sections.

\subsubsection{A new process}

When you create a new window, [[rio]] internally 
(1) forks a new process (with [[proccreate()]]), 
(2) adjusts the environment in the child process, and finally 
(3) executes (with [[procexec()]]) a command (the \plan shell [[/bin/rc]])
from this child process.
\l new window is automatically textual window with terminal emulator, so shell
%
This is why the creation of the two windows in 
Figure~\ref{fig:hellorio-and-shell} leads to the creation of two processes in
Figure~\ref{fig:soft-archi-threads}: [[hellorio]] and the shell process.
\l actually should be 3 processes, cos fork from shell (but could exec instead?)


The sequence of steps above is a classic idiom in \unix programming.
%
Indeed, this is for instance the way the shell implements {redirections},
as in [[ls > list.txt]]. In that example, the shell adjusts the environment
by changing the standard output file descriptor in the child process
to point to a text file instead of the [[/dev/cons]] console device file
(see the \book{Shell}).
%trans:
For [[rio]], the adjust-the-environment part consists in changing the 
{namespace} in the child process by using 
the [[mount()]] and [[bind()]] system calls.
%(see the \book{Kernel}). 

\subsubsection{A new namespace}
\label{sec:new-namespace}

%dup? Kernel
A {\em namespace} is the \plan equivalent of a {mount-table}
in \unix (and its derivatives such as Linux or macOS). 
A {\em mount-table} allows to plug together multiple {filesystems}
in a single uniform tree.
\l literally you mount a fs on top of another fs, like a greffe
%real-world: ugly c: d: in Windows.
However, in \plan, each process has its own mount-table, its own namespace; 
there is not a global mount-table as in \unix.
%
%dup: (changed) intro/rio  overview/principle/terminal
After the call to [[mount()]] mentioned above, the child process of [[rio]] 
will see special files in [[/mnt/wsys/]], 
thanks to the per-process namespace feature of the \plan kernel.
\n really special cos special Qid because of [[extra]] param to mount
%
Moreover, because of the [[bind()]] call,
the same files will also be accessible under [[/dev/]], and 
will take precedence over any existing files there, 
thanks to the union-mount feature of the \plan kernel.

%\paragraph{A \plan namespace refresher, [[bind()]] and [[mount()]]}
\n too much detail? could skip in Overview? hard to skip.
%trans: 
Before showing the actual calls to [[bind()]] and [[mount()]] in [[rio]],
%dup? Kernel
here are the slightly simplified signatures of [[bind()]]
and [[mount()]] from [[syscall.h]]:

<<simplified signatures of namespace functions [[syscall.h]]>>=
error bind(char *str,   char *path, int flag);
error mount(fdt fd, ..., char *path, int flag, char *extra);
@
\l errorneg1? bind(char *name,   char *old, int flag);
\l errorneg1? mount(fdt fd, int afd, char *old, int flag, char *aname)


%dup? Kernel
[[bind()]] takes as a parameter a string ([[str]]) and a path ([[path]]).
\n path is usually a directory, but can also be a file (but path must exist!)
%
If the string starts with a [[#]], as in [[bind("#m", "/dev/", ...)]],
the string must correspond to the code of a device in the \plan kernel, 
for instance, [[#m]] is the code of the [[mouse]] device.
%
In that case, every access from the process to files under path will 
be {performed} with the methods of the corresponding device, for instance,
[[mousewalk()]] if the process was listing files in [[/dev/]].
\l in [[/dev/]]. it is not /dev/mouse or /dev/draw, but /dev/, subtle.
%
Remember that in \plan, {devices are filesystems}
(see the \book{Kernel}).
%
The mouse device, for instance, manages more than one file
(e.g., [[/dev/mouse]], [[/dev/cursor]]). 
Some devices such as [[draw]] manage even multiple directories 
(e.g., [[/dev/draw/1/]], [[/dev/draw/2/]]).
\n also union-mount for /dev/ (explained later)
\n in fact #i not handled by bind but but namei. can do open("#i/...")
%real-world:
\l Equivalent in Linux is major/minor mknod in plan9. 
\l plan9 devices more flexible, multiple files, complex services! see draw.
%
If the string did not start with a [[#]], every access to
files under path are redirected to the path denoted by the string.
%
In effect, it is like [[path]] becomes an {\em alias} for the 
path denoted by [[str]].
%real-world:
\l kinda symbolic link, but more general (see later)
% see 2/bind (and 1/bind)? bof. actually can bind a file (but can not mount)


%dup? Kernel.nw
With [[mount()]], the kernel delegates the management of
a directory neither to a device in the kernel, nor
to another directory, but to a {userspace} program.
\l or other kernel?
%
Indeed, [[mount()]] takes as a parameter a file descriptor ([[fd]]) and 
a path ([[path]]), 
in order to tell the kernel that every access to files under path should
be handled by the {process behind the file descriptor}
(see the \book{Kernel} and the \book{Network}).
\n again depends on flag, can be union dir (said later)
%
This allows to implement {filesystems in user space},
a powerful and convenient feature.
%
Note that the file descriptor argument can be anything; it can correspond to 
a pipe to a local process, but also to an opened connection on the network.
Thus, filesystems can also be imported (and exported) through 
the network in \plan.
\l but then fd leads to another kernel? not another userspace program?
% see 2/bind (and 1/bind)


%dup? Kernel.nw
Both [[bind()]] and [[mount()]] operate on an existing path
and alter the filesystem tree at this path.
%
Moreover, in \plan, you can not only {plug} a filesystem on top of another 
filesystem at a specific directory, you can also {join} filesystems
in a directory. 
Indeed, a directory can be the union of two or more filesystems.
Such a directory is called a {\em union-mount}.
%
Both [[bind()]] and [[mount()]] take a flag parameter
specifying how to handle the union of the old content of the
directory with the new content of the [[bind()]]'ed device (or directory) 
or the new [[mount()]]'ed user-space filesystem.
%
For instance, the flag argument [[MREPL]] (for replace)
indicates that the old content should be ignored and replaced 
by the new content.
%
The flag argument [[MAFTER]] indicates that the old content
should be kept and should take {precedence} over the new
content in case of {name conflicts}.
Indeed, two filesystems can contain files with identical names.
%
Thanks to the union-mount and a series of calls to [[bind()]],
the [[/dev]] directory can contain many files and directories
managed by multiple devices.

%\paragraph{Rio's namespaces}
%trans: can now understand specific calls

Here are the slightly simplified calls to [[mount()]] and [[bind()]]
in the function [[filsysmount()]]
called in the child process of [[rio]]
when a new window is created:

% kernel -> winshell (as x -> proccreate(winshell) <- new <- button3menu) ->
%  filsysmount

<<[[filsysmount()]] simplified code>>=
err = mount(fs->cfd, ..., "/mnt/wsys", MREPL, windowid);
...
err = bind("/mnt/wsys", "/dev", MBEFORE);
@


With the call to [[bind()]], [[/dev/]] becomes the union of the old [[/dev/]]
directory and the [[/mnt/wsys]] directory.
%dup? overview/soft-archi/new-window 
The flag argument [[MBEFORE]] indicates that files under [[/mnt/wsys]] 
takes precedence over the old files under [[/dev/]].
%
This means than an access to [[/dev/mouse]] by the process
who executed the code above (or the children of this process)
will be redirected to an access to [[/mnt/wsys/mouse]], 
and not to the old [[/dev/mouse]] file that was managed by the kernel 
(and which was there because of a previous call to [[bind("#m", "/dev", ...)]]).
%
This is why in Figure~\ref{fig:soft-archi-threads}, 
the [[hellorio]] and shell processes, at the bottom right, are connected to 
files starting with [[/mnt/wsys/]], while [[rio]] itself is connected
to files starting with [[/dev/]], at the bottom left.


Regarding [[mount()]], the file descriptor argument
corresponds to one side of
a pipe created by the [[fileserver]] proc (see Section~\ref{sec:thread-archi})
and stored in the [[cfd]] (for client file descriptor) field of the 
global [[fs]] (for filesystem).
%
The other side of the pipe is stored in the [[sfd]]
(for server file descriptor) field of [[fs]].
%
Note that file descriptors and namespaces are inherited 
by default through [[rfork()]] (or [[proccreate()]]), 
and maintained through [[exec()]] (or [[procexec()]]).
\n default unless RFFDG flag?
Thus, after the child process of [[rio]] has called [[filsysmount()]]
and [[exec()]]'ed the shell [[/bin/rc]], this shell process 
\n actually it is procexec
will still have in its file descriptor table in the kernel
a link to the pipe created by the [[fileserver]] proc, and in
its mount-table the information about [[/mnt/wsys/]].
\l cfd is fd number (e.g., 4) which kernel knows is a pipe
%
This means that an access from this shell process to [[/mnt/wsys/mouse]]
will be converted by the kernel to a 9P request written in the pipe
(see the \book{Network}).
\l because previous call to mount. mount-table lookup
%
On the other side of the pipe, the [[fileserver]] proc will read the pipe,
decode the 9P request, and return a result to the kernel through
the pipe (e.g., an error code).
\l one pipe, many clients. Kernel manage multiplexing. kernel only
\l one to read and write from pipe, and by having 9p request id know
\l which syscall to dispatch too, which process to wakeup when 9p request
\l answered.
\l (see \book{Network}).


Thus, it is through a pipe that [[rio]] and its clients are communicating.
%dup: with previous paragraph, but good to repeat
This communication is indirect. Indeed, the clients are not
writing directly into the pipe; they are just performing
system calls on (virtual device) files, 
as indicated for example by the arrows between the [[hellorio]]
process and the kernel in Figure~\ref{fig:soft-archi-threads}.
%
However, the kernel redirects those system calls to 9P requests 
on the pipe created initially
by the [[fileserver]] proc and inherited by those clients.
%
The arrow connecting the [[fileserver]] proc to the kernel
on the right of Figure~\ref{fig:soft-archi-threads} is the pipe.


Note that [[mount()]] can take an extra argument (called [[extra]]
in the signature of [[mount()]] above).
%
For [[rio]], this argument contains the window identifier
(in the [[windowid]] local variable in the code above)
of the newly created window.
%
This extra argument is stored in the process mount-table and
passed by the kernel through the 9P request. Thus, 
the [[fileserver]] proc can know from which window (and so from
which process) a file request comes from.
%
This is important because the [[fileserver]] proc reads
from a pipe that is shared by many processes.
\l each process does a special call to mount
\l and same file may return something different for each process.
\n so drawwalk will return special Qid for each process

% See http://epresence.kmdi.utoronto.ca/1/watch/630.aspx
%  mount("/srv/ws", "/dev", M_REPL);
%  W = open("/dev/graphics", O_WRITE);
%  K = open("/dev/cons", O_READ);
%  M = open("/dev/mouse", O_READ);
% then this process read/write of those devices will trigger
% the rio fileserver, which will then dispatch the request
% to the right window thread associated with this process/window,
% and do the right action.

%%later:
%% then to create new window, mount $wsys /mnt/wys/ 1
%% and there you will have new device files. 
%% Can then do the same and bind it in -b /dev and boom, 
%% you have setup the right environment.

\subsubsection{A new [[Window]]}

%trans:
Now that the process for the new window has been created,
and its namespace adjusted,
%
[[rio]] needs to keep track of the new window (and the new process).
%
To do so, [[rio]] allocates a new [[Window]] structure,
which gathers information about a window.
[[rio]] also adds this structure in the global [[windows]],
which contains the list of all [[Window]]s
(see Section~\ref{sec:core-ds-Windows} for more information).
%
The [[Window]] structure has many fields. For instance,
[[Window.id]] contains the {window identifier}, while
[[Window.pid]] contains the {process identifier} of the
process associated with the window.
%chunks:
The other fields will be presented gradually in this document.

\subsubsection{A new thread}
\label{sec:new-thread}
\l and new channels

Each window must deal with inputs from the mouse or the keyboard.
%
Those inputs, which correspond to two independent activities of the
user, are managed in [[rio]] by two independent threads in the left of
Figure~\ref{fig:soft-archi-threads}: the mouse and keyboard threads
(and associated IO procs).
%
Those inputs must then find a way to the right of
Figure~\ref{fig:soft-archi-threads} until the [[fileserver]] proc,
which is connected to the {window processes} (via a pipe).
\n more on this later in full trace of mouse click (said later?)
%
To separate concerns, the mouse and keyboard threads do not
communicate directly with the [[fileserver]] proc. 
%
Instead, they communicate with {\em window threads}
(e.g., [[Window 1]] and [[Window 2]] in the middle of 
Figure~\ref{fig:soft-archi-threads}). Those threads handle
the independent input activities to the independent windows.
\n actually also output from worker thread when write on /mnw/wsys/cons
{\em Each window is represented by a thread}.

Thus, when you create a new window, [[rio]] creates internally 
a new window thread.
%
Moreover, [[rio]] creates multiple channels to communicate with this new thread.
For instance, [[Window.mch]] contains a channel used to exchange messages 
between the mouse thread and the window thread.
\l Window.ck for keyboard


When you move the mouse, the event is transmitted at some point 
to the mouse thread of [[rio]], which gets the information 
by listening on [[mousectl->c]]
%rio-reflection:
(this is similar to what [[hellorio]] did in
Section~\ref{sec:hellorio-input-code}).
%
The mouse thread then looks for the window with the focus, 
which is stored in the global [[current]] (see Section~\ref{sec:current}),
a pointer to a [[Window]] in [[windows]].
%
It then writes information about the mouse event in [[current->mch]].
%
On the other side of the channel, a single window thread is listening 
on this channel and is ready to receive the mouse input for further processing
(for instance, by relaying the event to a {worker thread}, as explained
soon in Section~\ref{sec:trace-mouse-click}).


Because the window with the focus can change, the mouse and keyboard
threads can communicate with different window threads. This is why
in Figure~\ref{fig:soft-archi-threads} the mouse and keyboard threads
are connected to all the window threads.

\subsubsection{A new layer}
\label{sec:new-layer}
\n move discussion to trace of drawing operation and initialization?
\n  maybe good to repeat there anyway.

%trans: 
The last thing [[rio]] internally creates when you create a new window is
a new image layer with the dimension of the window.
%
This image is stored in the [[Window.img]] field of the window.
{\em Each window is associated to one layer}.
\l via [[allocwindow()]]
%dup: overview/principles/window-vs-graphical
As I said in Section~\ref{sec:layer-introduction}, an image layer is a
convenient graphics construct that [[rio]] uses to implement overlapping
windows.
%trans:
What we need now is a way to communicate this layer to the window
application so that this application can draw in this new layer.


%dup: overview/interface/fs/screen
As mentioned in Section~\ref{sec:winname}, each window application is
connected directly to the [[draw]] device,
as shown in Figure~\ref{fig:soft-archi-threads} with
the [[hellorio process]] connected to [[draw]] via [[/dev/draw/2/]].
%dup: overview/interface/fs/screen
The drawing operations by the window application do not go through
a virtual [[/mnt/wsys/draw]] file that would be managed by [[rio]]
(and its [[fileserver]] proc).
%
However, it is [[rio]] that creates the layer and so knows
where the window application should draw.
%
Fortunately, [[draw]] has an IPC feature allowing multiple processes
to share an image or an image layer.
%dup: overview/interface/fs/screen
By giving a {public name} to the new image layer (with [[nameimage()]]),
[[rio]] allows another process to retrieve a handle to the image 
(with [[namedimage()]]) if this process knows the name of the image.
\l security issues? any process could fetch? could encrypt name.
%
This unique name is stored in the [[Window.name]] field of the window.
%trans:
However, we still need a way to communicate this name to the window application.
%dup: overview/interface/fs/screen
To do so, [[rio]] uses the same mechanism it uses to transmit any 
kind of information to its window: a file under [[/mnt/wsys/]], in that case
[[/mnt/wsys/winname]], which contains the string in [[Window.name]].


Note that each window application will read a different string
from his [[/mnt/wsys/winname]] file. Indeed, each window process
has a different namespace since a unique window identifier 
is passed to the [[mount()]] command (see Section~\ref{sec:new-namespace}).
%
When a window application reads [[/mnt/wsys/winname]],
the request goes to the [[fileserver]] proc through a pipe,
and [[fileserver]] knows which [[Window.name]] field to read
since the window identifier is passed also in the request.
\l full trace soon.

\bigskip
%trans:
This concludes the trace of a new window creation. 
%
Now that [[rio]] has created all the necessary entities to support the
new window, I can explain the trace of a mouse click in this new window
in the next section.

\subsection{Trace of a mouse click}
\label{sec:trace-mouse-click}

When you click or move the mouse, the information is first
transmitted from the mouse device to the kernel, at the bottom left 
in Figure~\ref{fig:soft-archi-threads}. This information must then find a way
to [[rio]] and possibly to the window with the focus, for instance,
[[hellorio]] at the bottom right in Figure~\ref{fig:soft-archi-threads}.
%toc:
The goal of this section is to describe the full trace of a mouse
click in the window of [[hellorio]]. 
\l I assume window already has the focus
This trace will go through many elements of Figure~\ref{fig:soft-archi-threads}.
\l FIGURE as shown by data flow in Figure X  (path in special color?)
Moreover, in this section, I will also explain the creation of the 
last remaining threads of [[main-proc]]: the {worker threads}.

\subsubsection{Mouse initialization}

%trans:
Before you click on the mouse,
%
the window application [[hellorio]] must first become ready to receive 
such a mouse event by calling [[initmouse()]]. 
The trace resulting from such a call is explained below:
%rio-reflection:
% in fact also rio initialization itself. initmouse, real /dev/mouse

\begin{enumerate}

\item When [[hellorio]] starts, it
opens [[/dev/mouse]] (via [[initmouse()]])
and reads [[/dev/mouse]] 
(via its own IO proc, see Section~\ref{sec:hellorio}).
\l actually two different steps, two different syscalls. open creates worker.
\l mouseopen! change things for rio!

\item The kernel resolves the access to [[/dev/mouse]] to the file 
[[/mnt/wsys/mouse]], because of a [[bind()]] call 
in the parent process of [[hellorio]]
(see Section~\ref{sec:new-namespace}).
\l not really parent, more previous-yourself 
\n (actually parent because shell, but then would need to show shell in figure)

\item The kernel relays a read on [[/mnt/wsys/mouse]] to
\l actually relay first the opem
a 9P request written in the pipe to [[fileserver]] proc,
because of a call to [[mount()]] in the parent process of [[hellorio]]
(see Section~\ref{sec:new-namespace}).
%
At this point, [[hellorio]] is blocked (actually its mouse IO proc)
waiting for his [[read()]] system call to return.

\item The kernel scheduler eventually schedules the [[fileserver]] proc,
which will read from the pipe, decode the 9P request, and start
to process the request.

\end{enumerate}


\subsubsection{Worker initialization}

%trans:
The question now is what should the [[fileserver]] proc do
with the read request on [[/mnt/wsys/mouse]] from [[hellorio]]?
%
\l can not block reading /dev/mouse, or by communicating with mouse thread.
It can not block until you move the mouse. Indeed, another
process may also need to communicate with the [[fileserver]] proc
in the mean time, for instance, a process in a terminal window may 
want to display some text by writing in its [[/mnt/wsys/cons]] file.
\l would be bad to block every other window app.
%
To manage independent file requests, the [[fileserver]] proc offloads
work to independent {worker threads}.
\l worker allocator
{\em Each worker thread represents an opened file of [[rio]]'s filesystem}.
\l so actually done for open, not read

In the case of [[hellorio]] reading [[/mnt/wsys/mouse]],
the worker thread is called [[Worker 3]] in 
Figure~\ref{fig:soft-archi-threads}.
\l other threads, because other opened files. 2 for shell, 1 for hellorio.
\l  raw mode for hellorio, nonraw for shell
%
This thread will then wait for mouse events by listening
on a special channel, as explained soon.
%
Once [[Worker 3]] receives a mouse event, it can communicate
back (by using another channel) the event to the [[fileserver]] proc,
which can write back the appropriate 9P answers into the pipe.
% (see \book{Network})?
\l then schedules who? hellorio process blocked? Kernel decodes 9P results?
At this point, the kernel will unblock the [[hellorio]] process
(actually its mouse IO proc), which can modify the GUI or do
nothing depending on the mouse event returned from [[/mnt/wsys/mouse]].
\l actually also here read channel mousectl->c

\subsubsection{Mouse event}

%trans:
The remaining question is how does the mouse event arrive
to the [[Worker 3]] thread?
%
Now that [[hellorio]] is ready to receive mouse events, and
[[Worker 3]] has been created, I can finally explain the trace resulting
from a mouse click in the window of [[hellorio]]:

\begin{enumerate}

\item A click on the mouse device,
at the bottom left in Figure~\ref{fig:soft-archi-threads},
generates an hardware interrupt, which is managed by the kernel
(see the \book{Kernel}).


\item The kernel looks for a process waiting on [[/dev/mouse]] and
so unblocks the [[IO-proc-mouse]] proc of [[rio]], at the left
in Figure~\ref{fig:soft-archi-threads}.
\l more complicated, buffer, but let's make it simple here.

\item This proc contains a single thread that was reading on [[/dev/mouse]].
This thread parses the mouse event contained in the data read
from [[/dev/mouse]], and sends it to [[mousectl->c]].

\item The message is received by the mouse thread, which was listening
on [[mousectl->c]]
(see Section~\ref{sec:new-thread}).
%
%dup: overview/soft-archi/new-window/new-thread
The mouse thread then looks for the window with the focus
and relays the message on [[wcurrent->mch]].

\item The [[Window 2]] thread, at the middle 
of Figure~\ref{fig:soft-archi-threads}, which was listening
on [[Window.mch]] (as well as other channels via [[alt()]])
receives the message on [[Window.mch]].
%
It needs then to transmit this message to [[Worker 3]].
%
When the [[fileserver]] proc created the [[Worker 3]] thread,
it also created a channel to communicate with this thread.
%
This channel is stored in the [[Window.mouseread]] field of
the [[Window]] structured allocated for [[hellorio]].
\n actually more complicated, send channel on channel, but for now simplify
Thus, [[Window 2]] can communicate with [[Worker 3]] by writing
the mouse event through this channel.
\l event loop for send too
\t physical to logical translation ???? 

\end{enumerate}

At this point, The [[Worker 3]] thread, which was listening on 
[[Window.mouseread]], receives the mouse event and relays
it to the [[fileserver]] proc as explained above.
\l by using another channel
%
This concludes the trace of mouse click.


Note that if you click with the mouse outside any window, the
mouse event does not go to any window thread. 
%
Instead, the event stops at the mouse thread, which contains code to
process the event to possibly move, resize, hide, or create a new window. 
%dup: overview/soft-archi/trace-new-window
Indeed, as mentioned in Section~\ref{sec:trace-new-window}, it
is the mouse thread that creates windows and all their
associated entities (processes, namespaces, layers, threads,
and [[Window]]s).


% could modify global ? Note then that no lock needed.
% Window thread and Mouse thread cooperative. No race.

% switch(alt(alts)) { event loop in many threads (mouse, winctl, etc)


% menu3 -> xxx() -> wsendctlmesg(w, xxxd) -> send(w->cctl, xxxd) -> winctl thread awake -> wxxx()
% or sometimes xxx() -> wxxx() directly like for whide() because reuse
% an existing Wctlmsg (e.g., Reshaped)

% filsysxxx -> xfidxxx -> wxxx

% click => hardware interrupt => kernel => ioproc(initmouse, read /dev/mouse) =>
%  mousethread => winctl => ??? ... (read /mnt/wsys/mouse)

% why ioproc? otherwise mousethread would block the whole process
% why mousethread? because need dispatch to appropriate window
% why winctl? because depending on state of window, might
%  dispatch to some xfid, or not.

% write to /dev/mouse
% rio process with many threads Await.
% mouse thread listening on mousectl channel, probably a wrapper over
% /dev/mouse listening.
% get data, get current window (shared memory 'input' global),
% write to window mouse channel.
% window thread listening on many channels (alts()), get awake
% and call wmousectl(), pass around address of mouse structure
% containing the info (shared memory).


\subsubsection{Worker allocator}

\t worker thread in space of main-proc. Because need access globals
% such as Windows. Dont want lock. But then created from fileserver.
% How? worker allocator in main-proc, communicate function pointer 
% from fileserver proc. Subtle. Nice.


\subsection{Trace of a key press}
\label{sec:trace-key-press}

%trans:
The trace of a key press in the window of [[hellorio]]
is similar to the trace of a mouse click. 
%
The trace starts also at the bottom left in Figure~\ref{fig:soft-archi-threads},
but this time with the keyboard device.
%
The key event is transmitted from the kernel
to the [[IO-proc-keyboard]] through [[/dev/cons]],
then relayed to the keyboard thread through [[keyboardctl->c]], 
then to the window thread [[Window 2]] through a [[Window.ck]] channel,
then to the worker thread [[Worker 4]] through a [[Window.consread]] channel,
then to the [[fileserver]] proc, and finally
back to the kernel and [[hellorio]] through a pipe.
%
[[hellorio]] finally reads the key event through his [[/mnt/wsys/cons]]
file that was opened (in raw access mode) at startup via a
call to [[initkeyboard()]].


For textual windows, such as the shell process 
in Figure~\ref{fig:soft-archi-threads} (represented by the [[Window 1]] thread),
the trace of a key press is more complicated.
%
Indeed, [[rio]] provides advanced line-editing features that complicates
the flow of data to [[/mnt/wsys/cons]]. Moreover, this file
is opened both in read and write modes, resulting from two
worker threads in Figure~\ref{fig:soft-archi-threads}: [[Worker 1]]
and [[Worker 2]].
\l worker 1 actually draw things then
%
This is why the trace of a key press in a textual window
will be explained later in Chapter~\ref{chap:textual-windows}.


% when keydown the keyboard thread is triggered
% (it was waiting in the msg/event loop in a recv() on /dev/cons probably in raw
% mode), and send the character
% to the input window channel, and the thread corresponding to this window
% who should wait for many channels should be awaken by the thread scheduler
% to process the keyboard input and act on it.

% key => hardware interrupt => kernel => ioproc(initkeyboard, read /dev/cons) =>
%  keyboardthread => winctl => ??? (read /mnt/wsys/cons)

% why ioproc? otherwise keyboardthread would block the whole process
% why keyboardthread? because need dispatch to appropriate window
% why winctl? 

% lots similar but wkeyctl()

%related: but for typing google.com in a browser
%https://github.com/alex/what-happens-when

\subsection{Trace of a drawing operation}
\label{sec:trace-draw}

%trans:
The final trace illustrating Figure~\ref{fig:soft-archi-threads}
is the trace of a drawing operation by [[hellorio]].
%dup: intro/rio overview/interface/fs/screen 
As I said in Section~\ref{sec:winname}, the ancestor of [[rio]],
[[8-1/2]]~\cite{eight-and-a-half}, was offering a
virtual [[/mnt/wsys/draw]] device file;
%
the trace of a drawing operation was then similar to the trace of
a mouse click or a key press
in Section~\ref{sec:trace-mouse-click} and Section~\ref{sec:trace-key-press}.
\l maybe ouput simpler than input; fileserver can do fast IO on /dev/draw
\l  but still need layers
%dup: overview/soft-archi/new-window/new-layer
However, for efficiency reasons, with [[rio]] the window applications 
are connected directly to the [[draw]] device, 
as shown in Figure~\ref{fig:soft-archi-threads} with
the [[hellorio]] process connected to [[draw]] via [[/dev/draw/2/]].
%
This simplifies the trace of a drawing operation, 
\n well memlayer is complicated
but complicates the initialization of graphics for the window process.
%
Indeed, as I explained partly already in different sections, 
[[rio]] and [[draw]] needs to cooperate to enable window 
applications to draw on the screen:


\begin{itemize}

\item [[rio]] is using [[draw]]'s layers to implement overlapping windows 
(see Section~\ref{sec:layer-introduction})

\item [[draw]] is using a client/server architecture to support 
the multiple clients of [[rio]]
(see Section~\ref{sec:winname}) % and sec:display-server

\item [[draw]] supports the naming and sharing of layers across multiple clients
(see Section~\ref{sec:winname}) % and sec:new-layer

\item [[hellorio]] uses in his code the global [[view]], 
which is a reference to a layer, to draw things in its window
(see Section~\ref{sec:hellorio}) % and sec:winname

\item [[rio]] is using [[/mnt/wsys/winname]] to communicate the name of 
a layer to the window 
(see Section~\ref{sec:new-layer}) % and sec:winname

\end{itemize}

The goal of this section is to put together all those 
pieces of information to better understand how a
window application draws on the screen.


\subsubsection{Graphics initialization}

Before being able to call drawing functions from [[draw.h]],
[[hellorio]] must first connect to the [[draw]] device with [[initdraw()]]
(see the \book{Graphics}).
%
This is similar to what [[hellorio]] did 
in the trace of a mouse click with [[initmouse()]], and 
in the trace of a key press with [[initkeyboard()]].
%rio-reflection
In fact, [[rio]] itself also calls at startup those [[initxxx()]] functions.
In the case of [[rio]], all those functions connect to real [[/dev/]] devices,
not virtual devices under [[/mnt/wsys/]].
%
The graphics initialization of [[hellorio]] 
relies actually on two calls done previously by [[rio]]:

\begin{enumerate}
\item The call to [[initdraw()]], which sets the global [[view]],
during the initialization of [[rio]]
\n hard to not talk about rio graphics init. Harder than for mouse and keyboard
\n  because layer created is based on view, so need to explain view.

\item The call to [[allocwindow()]] to create a new layer,
using [[view]] as the base layer,
during the creation by [[rio]] of the new terminal window 
from where [[hellorio]] will be eventially launched

\end{enumerate}

Thanks to those two previous calls, the call to [[initdraw()]] in 
[[hellorio]] can fetch a reference to the layer created by [[rio]].
\n need more, need also nameimage, namespace, and lots of stuff

The following paragraphs will give more details about those steps
by describing the traces of those steps.
%
However, those traces will be partial. Indeed, I will omit 
certain explanations that are contained in the \book{Graphics}.
\l moreover for full explanations, read the following chapters!



\paragraph{[[rio]] and [[initdraw()]]}
The trace of [[initdraw()]] in [[rio]] is as follows:

\begin{enumerate}

\item When [[rio]] starts, it calls [[initdraw()]], which opens
[[/dev/draw/new]] to open a new connexion to the display server
(see the \book{Graphics}).

\item The kernel resolves the access to [[/dev/draw/new]] to
a method of the [[draw]] device in the kernel,
because of a call to [[bind("#i", "/dev/")]] in the 
parent process of [[rio]] (see Section~\ref{sec:getting-started}).
\n actually bind program, but internally calls bind() function
%
Since [[rio]] is the first application to open [[/dev/draw/new]], 
the kernel returns a file handler to [[/dev/draw/1/ctl]].
\n unless recursive rio
This is why in Figure~\ref{fig:soft-archi-threads}, the [[rio]]
process is connected to the [[/dev/draw/1]] directory.

\item [[initdraw()]] reads the information about the screen contained
in [[/dev/draw/1/ctl]] and sets the global [[display]].
\n another syscall, read() this time, not open()
\l less important step, could be removed

\item [[initdraw()]] calls [[gengetwindow()]], which
opens and reads [[/dev/winname]].
\n again two different syscalls

\item The kernel resolves the access to [[/dev/winname]]
to a method of the [[draw]] device. The content returned 
for this file is [["noborder.screen.1"]], the name given by [[draw]] 
to the framebuffer image.
\l unless recursive rio, in which case get a layer name! nest!
\n start change for hellorio trace later 

\item [[initdraw()]] then calls [[namedimage()]] to grab
a reference to the image named [["noborder.screen.1"]].
%
Remember that API calls to [[draw]] such as [[namedimage()]] are
translated by [[libdraw]] in written commands in [[/dev/draw/1/data]]
(see the \book{Graphics}).
\l remember also that images are stored in kernel. Image are just reference
\l  to internal kernel data structure, Memimage, with image identifier.
\n actually there is DImage intermediate even

\item The kernel resolves the access to [[/dev/draw/1/data]]
to a method of the [[draw]] device. This method parses the [[namedimage()]]
command, creates a new image identifier, find the image
corresponding to [["noborder.screen.1"]] (the framebuffer), 
internally {links} the new image identifier to this image,
and finally returns the new image identifier.
\l because noborder.screen.1 drawaddname
\n actually libdraw pass image identifier (display->imageid)
\n new DImage, returns image id.

\item [[initdraw()]] reads information about this new image identifier
in [[/dev/draw/1/ctl]] and stores the information in the global [[view]].
\l Image vs Memimage, in the kernel referring to the screen framebuffer

\end{enumerate}
\l at this point, view and display->image are 2 image identifiers refering
\l  internally to the same kernel image, the framebuffer.

Once [[rio]] called [[initdraw()]], it can draw things on the screen
by passing the global [[view]] as an argument to drawing functions.
%
Moreover, after [[initmouse()]], [[rio]] enables also the user to use the mouse.




\paragraph{[[rio]] and [[allocwindow()]]}
\l [[alloclayer()]]
The trace leading to the creation of a new layer is as follows:

\begin{enumerate}

%dup: (shorten) overview/interface/gui overview/soft-archi/trace-new-window
\item To create a new window, you must right-click on the
mouse while dragging the mouse to specify a rectangle on the screen
(see Section~\ref{sec:rio-gui}).
%
All those actions are handled by code in the mouse thread of [[rio]]. 
%
This code also uses the global [[view]] as an argument to functions
in [[draw.h]], for instance, 
to draw on the screen the white rectangle specified with the mouse, 
as well as its red border (see Figure~\ref{fig:new-step1-specify-new-window}).
\n actually allocwindow() already (and freeimage()); not draw()


\item Once you release the right-click, 
\n actually call allocwindow() all the time
%dup: overview/soft-archi/trace-new-window
[[rio]] creates internally many new entities: a process, a namespace, a
[[Window]] (stored in the global array [[windows]]), and a thread
(see Section~\ref{sec:trace-new-window}).
%
[[rio]] also calls [[allocwindow()]] from [[window.h]] to create a new layer. 
%
It passes [[view]] as the base-layer argument to [[allocwindow()]], and 
the rectangle specified with the mouse for the dimension of the layer.
\n actually pass desktop (but derived from view though)
%
The call to [[allocwindow()]] is translated by [[libdraw]] in a command
written in [[/dev/draw/1/data]]. The [[view]] argument is reduced 
to its image identifier.
\l actually desktop->id


\item The kernel parses the [[allocwindow()]] command written 
in [[/dev/draw/1/data]] and allocates a new layer with a new image identifier.
\l Memlayer, actually allocwindow translated in allocimage with screen id arg
%
It uses the framebuffer as the base layer for this layer,
since the image identifier written in [[/dev/draw/1/data]] was 
previously linked by the kernel to the framebuffer.
\l actually passed baselayer id in [[allocimage()]] command
%
The kernel also records in a list the set of layers associated
with the framebuffer, and put this new layer at the top of the list.
\l MemlayerBase DS
%
If a program draws in this layer, it will draw directly in the framebuffer
since the layer is at the top.
%
Finally, the kernel returns the new image identifier to [[rio]].


\item [[rio]] stores the new image identifier in the [[Window.img]]
field of the [[Window]] structure allocated for the new window.
\l abuse image identifier for Image, but in essence that's what it is
%
[[rio]] creates also a new name for this layer, e.g. [["window.1"]]. 
and stores it in the [[Window.name]] field.
%
[[rio]] then calls [[nameimage()]] with [[Window.img]] and [[Window.name]]
as arguments, to name and share the layer.
%
This call is translated again by [[libdraw]] in a command
written in [[/dev/draw/1/data]]. 

\item The kernel parses the [[nameimage()]] command
and adds in a global hash table in the kernel an association between
[["window.1"]] and the layer created previously.

\end{enumerate}

Remember that when you create a new window, this window
is always first a textual window managed by the terminal emulator.
%
This window is initially connected to a shell process, as shown
at the bottom right in Figure~\ref{fig:soft-archi-threads}.
%
Because the terminal emulator is an integral part of [[rio]],
it has access to the globals of [[rio]] such as [[view]]
or [[windows]].
\l run from window thread, e.g. Window 1.
%
Thus, the terminal emulator can draw in the layer stored previously
in [[Window.img]]. 
It can translate text output from the shell process through [[/mnt/wsys/cons]]
to calls to drawing functions taking [[Window.img]] as an argument
(e.g., [[string()]]).
\l or runestring
\l more on this in Chapter X

At some point, you can launch [[hellorio]] from
this terminal window by typing the name of the command in the shell.

\paragraph{[[hellorio]] and [[initdraw()]]} Here is finally the trace
of [[initdraw()]] in [[hellorio]]:

\begin{enumerate}

\item When [[hellorio]] starts, it also calls [[initdraw()]]
(like [[rio]] did), which opens [[/dev/draw/new]].
%
Since [[hellorio]] is the second application to open this file,
the kernel returns a file handler to [[/dev/draw/2/ctl]].
%
This is why in Figure~\ref{fig:soft-archi-threads},
the [[hellorio]] process is connected to the [[/dev/draw/2]] directory.
%dup: merge step 1,2,3 of trace of initdraw for rio

\item [[initdraw()]] calls [[gengetwindow()]], which opens
and reads [[/dev/winname]].
\n two different syscalls, two different traces normally

\item The kernel resolves this time the access to [[/dev/winname]]
to [[/mnt/wsys/winname]], and communicates the read request
on this file to the [[fileserver]] proc.
%
This is different from the trace of [[initdraw()]] in [[rio]].
Indeed, the namespace set in the parent process of [[hellorio]] by [[rio]]
is different from the namespace of [[rio]] itself.
%dup: more explanations in trace window-click step 2,3,4

\item The [[fileserver]] proc allocates a new worker thread
to serve [[/mnt/wsys/winname]] for [[hellorio]].
\n for the open
%
Note that this thread is not shown in Figure~\ref{fig:soft-archi-threads}.
Indeed, this worker thread exists only during the call to [[initdraw()]].
Before returning, [[initdraw()]] closes [[/dev/winname]], and so
[[fileserver]] releases the worker thread.


\item The worker thread looks for the name of the layer for [[hellorio]]
in the [[Window.name]] field of the [[Window]] associated with [[hellorio]]. 
%
This [[Window]] is stored in the global array [[windows]].
%
To find the appropriate [[Window]], the worker thread
compares the window identifier stored in [[Window.id]] and the window
identifier in the 9P request (which was originally passed to [[mount()]]
in the parent process of [[hellorio]], see Section~\ref{sec:new-namespace}).
%
Finally, the worker thread returns [["window.1"]], the content
of [[Window.name]] for the window from where [[hellorio]] was launched.
\n then return to fileserver proc, write in pipe, etc. see trace mouse click

\item [[initdraw()]] then calls [[namedimage()]] to grab
a reference to the image named [["window.1"]].
%
The kernel creates a new image identifier, 
find the image corresponding to [["window.1"]] by looking in a global
hash table (this image is the layer created by [[rio]] above), 
internally links the new image identifier to this image, and finally
returns the new image identifier.
%
[[initdraw()]] then stores the new image identifier in the global [[view]]
of the [[hellorio]] process.
\n again abuse image identifier for Image
%dup: merge step 6,7,8

\end{enumerate}

This concludes the graphics initialization for [[hellorio]].

\l originwindow()?? !! physical to logical!! maybe better delay to later
\l mouseopen! change things for rio!

\subsubsection{Graphics operation}

%trans: %dup: (adapted, screen -> window) trace rio
Once [[hellorio]] called [[initdraw()]], it can draw things in
its window by passing the global [[view]] as an argument to drawing functions.
%
This time, [[view]] corresponds to an image layer in the kernel,
not the framebuffer. However, this layer is linked to the framebuffer,
as well as the other layers created for the other windows.
%
Here is the trace of the call to [[draw()]] in the [[redraw()]]
function in [[hellorio.c]] (see Section~\ref{sec:hellorio-skeleton}):

\begin{enumerate}

\item When [[hellorio]] calls [[draw()]], the call is translated
by [[libdraw]] in a command written in [[/dev/draw/2/data]]. 
\n actually need wait until flushimage()
The [[view]] argument is reduced to its image identifier.

\item The kernel resolves the access to [[/dev/draw/2/data]] to
a method of the [[draw]] device. This method parses
the [[draw()]] command and fetches the image associated
to the image identifier written in [[/dev/draw/2/data]]. 
\n DImage, vs Memimage, vs Memlayer
\n image identifier local to each client of draw, but not important to know
%
This image is actually a layer, which is associated to the framebuffer.

\item The kernel then calls [[memdraw()]], a function from [[libmemlayer]]
that contains special code to handle image layers.
%
[[memdraw()]] then goes through the list of layers associated
to the framebuffer to check if the layer of [[hellorio]] is the {top layer}. 
\l actually not done like this I think
%
If it is, [[memdraw()]] calls [[memimagedraw()]] from
[[libmemdraw]] to draw pixels directly in the framebuffer. 
%
If it is not the top layer, [[memdraw()]] allocates a new
off-screen image and calls [[memimagedraw()]] to draw
in this image instead for all the rectangles overlapped by
other layers.
\l actually done by layerop, and not sure there is only one off-screen image

\end{enumerate}

Later, if you click on the window of [[hellorio]] to make it the top window, 
[[rio]] will call the [[draw]] function [[topwindow()]].
%
This command will be parsed by the kernel. The kernel will readjust the list
of layers associated to the framebuffer, and copy back the pixels
from the off-screen image associated to the layer of [[hellorio]]
to the framebuffer.

\bigskip
This concludes the trace of a drawing operation, as well as the
presentation of the software architecture of [[rio]].
%
The traces above are simplified, but the essential elements are there. 
For a more precise trace of a drawing operation, see the \book{Graphics}.
%trans:
For more details about the other traces, read the following chapters.



\section{Book structure}

%trans: %dup: (and adapted) from Assembler.nw
You now have enough background to understand the source code of [[rio]].
%toc:
The rest of the book is organized as follows.
%
I will start by describing the core data structures of [[rio]]
in Chapter~\ref{chap:core-ds}.
%
Then, I will use a top-down approach, starting with Chapter~\ref{chap:main}
with the description of [[main()]] and the core initializations in [[rio]].
\n actually code of threadmain, but still description of main
%
I will continue in Chapter~\ref{chap:processes-threads} by presenting
the main functions called by the threads and procs of [[rio]].
I will describe also the messages and channels used by those threads.
%
Then, I will describe the code to manage cursors in 
Chapter~\ref{chap:cursor},
%
before presenting the code of the window manager in Chapter~\ref{chap:wm}. 
Starting from a mouse click, I will describe the main functions
to create, focus, delete, move, resize, and hide windows.
%
In Chapter~\ref{chap:filesystem} I will switch to a bottom-up
approach, and switch the focus from [[main-proc]] to [[fileserver]],
by presenting the filesystem methods of the [[fileserver]] proc.
%
Those methods are entry points that offload the work
to worker threads and specific functions to handle the 
different virtual devices of [[rio]] under [[/mnt/wsys/]]
(e.g., [[/mnt/wsys/cons]], [[/mnt/wsys/mouse]]).
%
I will present the code to serve those virtual devices
in Chapter~\ref{chap:virtual-devices}.
%
Some virtual devices behave differently depending if the
window is a graphical or textual window.
This is why I will describe the specifics of graphical windows
in Chapter~\ref{chap:graphical-windows}, and of textual
windows in Chapter~\ref{chap:textual-windows}, including
the code of the terminal emulator.
%
Chapter~\ref{chap:windowing-system-files} presents the code to serve
the other files under [[/mnt/wsys]] (e.g., [[/mnt/wsys/ctl]]).
%
Chapter~\ref{chap:advanced} presents advanced functionalities
of [[rio]] that I did not present before to simplify the explanations.
\l for instance, 
Finally, Chapter~\ref{chap:conclusion} concludes
and gives pointers to other books in the \principia series.

%toc: %dup: (adapted) Assembler.nw
Some appendices present the code of non-functional properties:
code to help debug [[rio]] in Appendix~\ref{chap:debugging-appendix}, 
and code to manage errors in Appendix~\ref{chap:error}.
%
Appendix~\ref{chap:utilities} contains the code of utility
functions used by [[rio]], but which are not specific to [[rio]].
%
Finally, Appendix~\ref{chap:examples} contains examples of
graphical applications that extends the window-manager component
of [[rio]], for instance, a window-switching bar.




%###############################################################################

\chapter{Core Data Structures}
\label{chap:core-ds}

\begin{verse}
\begin{flushright}
  {\it Show me your code and conceal your data structures, and I shall
    continue to be mystified. Show me your data structures, and I
    won't usually need your code; it'll be obvious.\\
    ~\\
    Fred Brooks}
\end{flushright}
\end{verse}

%toc:
In this chapter, I will present the core data structures of [[rio]],
% rio is GUI and a fileserver. So core DS = visual and interactive,
% windows, and fileserver keep track of opened files.
which are essentially:
% globals to device handler, Window, and filesystem.
TODO


\section{Device handlers}

\subsection{Output device: [[display]] and [[view]]}

% rio is first a graphical app, like other graphical app. 
% So use display, view, etc. See Graphics.nw and draw.h and initdraw called
% early in main().

%Display	*display; // set by initdraw()
%display =~ /dev/draw handler
%ocaml: do not use global, Draw.init returns a display

%Image          *view; 
%old: was called screen but was confusing because screen was of type Image*, 
% whereas there was a Screen type too (which really should be called Desktop)
%dead:
%  <<global view>> =
%  Image	*view;
%  @
% was initialized in main() to screen, but now that I renamed in Graphics
% screen to view, no need anymore this global
% (this made me change screen to view in Graphics.nw)
%ocaml: do not use global, Layer.init returns a view

% view = full screen in rio context (unless run recursively).
% but normally portion of the display for this window.

%ocaml: do not use global for display and view,
% get Draw.init to return them

<<global [[viewr]]>>=
Rectangle	viewr;
@
%view->r
% can remove? no cos when resize, view->r changes but
% want old value (but should be needed only when run rio under rio no?)


% rio will provide actually to its client a view Image too!
% but for subpart of screen (subpart of rio's view).

\subsection{Input devices: [[mousectl]] and [[keyboardctl]]}

% rio is a graphical app which uses the keyboard and mouse.

% structure defined in mouse.h
<<global [[mousectl]]>>=
Mousectl	*mousectl;
@
%ocaml: need to be a global? no, but then true that need to pass it
% around a lot

% wrapper over /dev/mouse, channel wrapper
% actually partially output? with cursor?

% structure defined in keyboard.h
<<global [[keyboardctl]]>>=
Keyboardctl	*keyboardctl;
@
%ocaml: need to be a global? no, and no need to pass it around a lot

% wrapper over /dev/cons (set in raw mode), channel wrapper



<<global [[mouse]]>>=
// alias for &mousectl->Mouse
Mouse	*mouse;
@
%ocaml: not sure need this, can just dereference

% explain inline struct



% and again, rio will provide to its client a "view" of the
% mouse and keyboard device.


\section{Desktop, [[desktop]]}

% rio rely on big support in Graphics.nw to manage overlapping
% images, which is big building block for windowing systems (but still
% a lot remains)

<<global [[desktop]]>>=
Screen	*desktop;
@
%ocaml: again does not need to be a global
%old: was called wscreen 

% = allocscreen(screen, background)
%TODO: rename to screen? or better desktop! or merge with the one in window.h?
% but initdraw allocates by default a screen no? why not reuse
%  this one? because screen by default has also border on it
%  and window is actually subpart inside the border.
%  so when run rio under rio, you want a new desktop, inside the border too???
% created new one on top of existing one because change background?
%  Can not have API that change background setting for the desktop global?

<<global [[background]]>>=
Image	*background;
@
%ocaml: this one does not need to be a global

% used for desktop. It's actually a Color. in plan9 everything
% are images, See Graphics.nw, colors, masks, windows, fonts, etc.
% allocimage in main()


% will see also another color:
<<global [[red]]>>=
Image	*red;
@
%ocaml: convenient to have this as a global. Passing around colors
% is tedious

% when moving around windows, the frame become red!
%//Image	*lightgrey;


% rio can also provide a screen to its client, but less useful,
% just acme uses that.

\section{Windows}
\label{sec:core-ds-Windows}

\subsection{[[Window]]}

% Windowing systems is all about managing windows ... so here it is.
% Big structure (a bit like Proc in Kernel.nw).

% Note that also have window type in Graphics.nw, which is really
% Image with additional methods. Those window/images will be used
% for graphical part, but need more fields, not just graphic part
% to handle windows. 

% Window is server side info about client window. On the client
% side, no real notion of window. Just a graphical app that thinks
% it runs outside of rio. have just display and view (via /dev/winname).

<<struct [[Window]]>>=
struct Window
{
    //--------------------------------------------------------------------
    // ID
    //--------------------------------------------------------------------
    <<[[Window]] id fields>>
    
    //--------------------------------------------------------------------
    // Graphics
    //--------------------------------------------------------------------
    <<[[Window]] graphics fields>>
    
    //--------------------------------------------------------------------
    // Mouse
    //--------------------------------------------------------------------
    <<[[Window]] mouse fields>>
   
    //--------------------------------------------------------------------
    // Keyboard
    //--------------------------------------------------------------------
    <<[[Window]] keyboard fields>>
    
    //--------------------------------------------------------------------
    // Control
    //--------------------------------------------------------------------
    <<[[Window]] control fields>>

    //--------------------------------------------------------------------
    // Process
    //--------------------------------------------------------------------
    <<[[Window]] process fields>>
    
    //--------------------------------------------------------------------
    // Config
    //--------------------------------------------------------------------
    <<[[Window]] config fields>>

    //--------------------------------------------------------------------
    // Textual Window
    //--------------------------------------------------------------------
    <<[[Window]] textual window fields>>

    //--------------------------------------------------------------------
    // Graphical Window
    //--------------------------------------------------------------------
    <<[[Window]] graphical window fields>>

    //--------------------------------------------------------------------
    // Misc
    //--------------------------------------------------------------------
    <<[[Window]] other fields>>

    //--------------------------------------------------------------------
    // Extra
    //--------------------------------------------------------------------
    <<[[Window]] extra fields>>
};
@

% all categories are important above. Window is connected
% to mouse, keyboard, can be controlled, has some id and graphics,
% is connected to external process, and can be textual or graphical.



<<[[Window]] id fields>>=
int	    id;       // visible through /mnt/wsys/winid
char    name[32]; // visible through /mnt/wsys/winname
@
%ocaml: no hardcoded length, flexible string
\l could rename winname

% counter
<<global [[id]]>>=
static	int	id;
@

% id is passed to filsysmount! so will be in /mnt/wsys/<id>/devs



<<[[Window]] graphics fields>>=
// ref_own<Image>, public image for the window (name in /dev/winname)
Image	*i;
@
\t rename img? I already use [[window.img]] before
% will be used by Graphics, e.g., topwindow(w->i) in wtop()
% this is whole image, including its border, see sweep() and wmk()
% shared with window process.
% this is most of the time a layer but it can also be an image when
% the window is hidden!

<<[[Window]] graphics fields>>=
/*
 * Rio once used originwindow, so screenr could be different from i->r.
 * Now they're always the same but the code doesn't assume so.
*/
Rectangle	screenr; /* screen coordinates of window */
@
\t put back originwindow! cleaner to have origin really at Pt(0,0),
% window is more like an abstraction of the screen then.
% but should do that in gengetwindow anyway, since here we have
% a border, and gengetwindow will create another window inside
% the border.
\t why need that here? already info in draw no?

% image->r is physical coord. screenr is logical coord.

% screenr is ZR when hidden

% screenr is whole window, including border, see wmk.
% hmm but then if do originWindow, should not include the border ...





<<[[Window]] id fields>>=
char    *label;   // writable through /mnt/wsys/label
@
% name vs label? name is here for client to find back its window/image via
%  namedimage, so rio sends info back to window. name is just readable.
%  label is actually set by client, and displayed back by rio.
%  label can be arbitrary size and /dev/label is writable


\t adv topics? all those wclose, wclosechan, incref/decref are subtle
<<[[Window]] extra fields>>=
Ref;
@
% when middle click on a window we want to keep it alive!
% don't want someone else via /dev/... to delete it yet, otherwise
% will get segfault if try to access some fields of this window!
% When the application opens a /dev/ we also increment the counter.

% For rio-in-C can have race? because of some proccreate? yes because
% fs server is in another process.

<<[[Window]] extra fields>>=
QLock;
@
\l need? threads are cooperatif so can have race??
% have different process though, but still when need lock?




\subsection{[[windows]]}

% grown in wmk()
<<global [[window]]>>=
// growing_array<ref_own<Window>> (size = nwindow+1)
Window	**windows;
@
%old: was window but better to be windows!!!
% essence of windowing system right here!! manage many windows!!
\l not option<> above, because when delete there is a memmove
%alt: called scenegraph in wayland
%ocaml: Hashtbl

% next free window
<<global [[nwindow]]>>=
int	nwindow;
@
%ocaml: Hashtbl.length

% seems to be actually the size of windows


% each time a window get the focus, it becomes the topmost window
% and topped is incremented
<<global [[topped]]>>=
static	int		topped;
@

<<[[Window]] other fields>>=
int	 	topped;
@
% overlapping windows! see wpointto() to understand how determine focus.
% can know when click which window it concerns by iterating over
% all window and see if window screenr is there and if topmost one there.
% (similar info is in kernel)
\l need that since can compare w == input? maybe because sometimes
\l  nothing has the focus but there is still a top window?

\subsection{[[current]]}
\label{sec:current}
\t rename input to current

% the current window, the one with the focus, the one
%  getting for instance the keyboard messages
<<global [[input]]>>=
//option<ref<Window>>, the window with the focus! the window to send input to
Window	*input;
@
% should rename winput I think. or wcurrent (but there is wcurrent())
% or just 'current'. or 'focuswin'.
% or just 'win'! a bit similar to cpu and up in Kernel.nw (but win can be
%  used for locals? or we shouse use 'w' for locals?)
% in rio(1) he uses the term "current"


% also
% - menuing, when in the middle of a menu action like 
%    pointto(), sweep(), drag(), bandsize(), in which case even if the cursor
%    is on a window, you dont want wsetcursor (<- cornercursor) to change it
% - sweeping, when get system menu out, but this seems used
%    very little
% - moving (local to mousethread)

\subsection{Graphical windows}


% important difference we will see later between graphical
% and textual windows. Many things change accordingly.

<<[[Window]] graphical window fields>>=
bool	mouseopen;
@
%old: was bool_byte
% graphical window & mouse field.

% would like drawopen, but out of reach.

\subsection{Textual windows}

% of course it has text!

<<[[Window]] textual window fields>>=
<<[[Window]] textual window fields, text data>>
<<[[Window]] textual window fields, text cursors>>
<<[[Window]] textual window fields, visible text>>
<<[[Window]] textual window fields, graphics>>
@
%ocaml: group and put in separate structure?

<<[[Window]] textual window fields, text data>>=
// growing_array<Rune> (size = Window.maxr)
Rune		*r;
uint		nr;	/* number of runes in window */
uint		maxr;	/* number of runes allocated in r */
@
%ocaml: array carries its length, so no need maxr

% see wcontents!


% see "Windows should be transparent" intro, talk about
% insert point, cursor, etc.

\t typedef cursor? like in Efuns?

<<[[Window]] textual window fields, text cursors>>=
// index in Window.r
uint		q0; // cursor, where entered text go (and selection start)
// index in Window.r
uint		q1; // selection end or same value than q0 when no selection
@
\l give name ``cursor''?
%ocaml: use option for q1

% use q0/q1 to not confuse with p0/p1 in libframe, called p0 for point 0.

% and nchars?

<<[[Window]] textual window fields, visible text>>=
uint		org;
@
% what is visible on the frame!
% origin
% FIGURE

% user modify q0, by navigating.

% output point? "division between characters the host has seen
% and characters not yet transmitted ... the position in the
% text that separates output from input".

<<[[Window]] textual window fields, text cursors>>=
// index in Window.r
uint		qh; // output point
@
% qh for host (host = application connected to terminal, e.g., rc)

% process modify qh, by output stuff

% "when characters are sent from the host, they are inserted at
% the output point and the output point is advanced.

% "When newline, chars between output point and newline are sent."

% FIGURE! or delay to later?




% Frame actually means image with text inside, with lines,
%  which can be scrolled.

<<[[Window]] textual window fields, graphics>>=
Frame frm;
@
% Image is inside frame or cover frame too?
% graphics & textual window field 
%old: was just Frame; but clearer after naming I think

% will see Frame later.

<<[[Window]] textual window fields, graphics>>=
Rectangle	scrollr;
@

% FIGURE, Scrollbar | gap | Frame (TextWidget really)
\l put screenshot again of fig:rio-gui but annotate this time
\l with scrollr, screenr


% automatic scroll mode! this is actually quite important
%  because when automatic scrolling, if process write on /dev/cons
%  then need output it, otherwise have to block process on
%  its write
<<[[Window]] config fields>>=
bool	scrolling;
@
%old: was bool_byte
% config & textual window field
\t rename autoscroll?



%\subsection{[[Wctlmesg]]}
%later

\section{Filesystem server}

% rio is also a filesystem server! not just graphical app.
% rio uses plan9 ability to have regular process act as filesystem (server).
% userspace filesystem.

\subsection{[[FilSys]] and [[filsys]]}

% how 9p works? how mount works?
% interface is essentialy a pipe! a server waiting for clients.
% (named pipe? no, no need yet, pipe here is between rio and filsys?
%  or kinda named pipe, but managed by mount and srv??)

<<struct [[Filsys]]>>=
struct Filsys
{
    // client
    fdt		cfd;
    // server
    fdt		sfd;

    // ref_own<string>
    char	*user;

    // map<fid, Fid> (next in bucket = Fid.next)
    Fid		*fids[Nhash];

    <<[[Filsys]] other fields>>
};
@
%dead: int		pid;  was pid of proccreate(filsysproc), but not needed
%ocaml: use Hashtbl directly for Filsys.fids

% cfd will be published in /srv/rio.user.pid? but not that important
% cfd will be shared by all the winshell processes that wish to
% interact with the server!

% [[user]] is needed for security purpose, make sure people making request
%  to pipe are the same user

<<global [[filsys]]>>=
Filsys	*filsys;
@
%ocaml: again, does not need to be a global

% this is used only by winshell when calling filsysmount,
%  which needs to know where the pipe is to communicate like
%  everybody else with the rio fileserver


<<constant [[Nhash]]>>=
#define Nhash 16
@
<<[[Fid]] extra fields>>=
// list<Fid> (head = Filsys.fids[i])
Fid		*next;
@
%ocaml: Hashtbl

\subsection{File state: [[Fid]]}

% server needs to maintain state of requested files,
% just like kernel does with file descriptor state.

% The client, and the kernel on behalf of the client, see files
% as a fid. It creates a new fid internally when it encounters a new file.
% Then it tells the server to use this new fid for the result of an attach
% or a walk. The server then needs to remember what this fid was about.

% when userspace filesystem, have notion of fid, Fcall message.

<<struct [[Fid]]>>=
struct Fid
{
    // the key
    int		fid;

    // the state
    bool	open;
    int		mode;

    <<[[Fid]] other fields>>

    // Extra
    <<[[Fid]] extra fields>>
};
@
%ocaml: 'opened: option open_flag' instead of two fields

%see docs/man/5/intro
%a 32-bit unsigned integer that the client uses to identify
%a ``current file'' on the server.


% fid is client's (filsys) idea of a file on the server.
% qid is server's (kernel) idea of a file on the server.

<<[[Fid]] other fields>>=
Qid		qid;
@
% See libc.h, qid.path, vers, etc.
% qid.path will be made of window id and kind of device file
%  with qid enum we will see later

% why not use fid=Qid? because 2 different processes can access the same
% file! or a process can access the same file with different modes; in all
% of those cases, the state of the file can be different!


<<[[Fid]] extra fields>>=
bool	busy;
@
%ocaml: do not reuse, alloc each time and let Gc handles things. No arena.

% looks more like lookupfid than always newfid
% ctor
% filsysproc | filsyswalk -> <>
<<function [[newfid]]>>=
Fid*
newfid(Filsys *fs, int fid)
{
    Fid *f, *ff, **fh;

    ff = nil; // free fid
    fh = &fs->fids[fid&(Nhash-1)];

    // lookup_hash(fid, fs->fids)
    for(f=*fh; f; f=f->next) {
        if(f->fid == fid)
            // found!
            return f;
        else if(ff==nil && !f->busy)
            ff = f;
    }
    // else
    if(ff){
        ff->fid = fid;
        return ff;
    }
    // else

    f = emalloc(sizeof(Fid));
    f->fid = fid;

    // insert_hash(f, fs->fids)
    f->next = *fh;
    *fh = f;

    return f;
}
@
%ocaml: Hashtbl.add and Hashtbl.find
% also bad to be both a lookup and create_if_not_there.
% should be stricter and allows create only at a few places (Attach, Walk)


<<[[Fid]] other fields>>=
Window	*w;
@
% at some point requested file will be associated with corresponding window
% because fid is given a qid (in attach/walk) which will encode
% the windows id.
% So full circle here! get back a Window!







\subsection{Workers and jobs: [[Xfid]]}

<<[[Filsys]] other fields>>=
// chan<ref<Xfid>> (listener = filsysproc, sender = xfidallocthread)
Channel	*cxfidalloc;	/* chan(Xfid*) */
@
%ocaml: not sure we need an arena of worker, can create thread each time
% (too slow?)
 

% saw server will receive 9p request on pipe while reading filsys.sfd.
% But potentially multiple windows, multiple processes
% each using /dev/xxx served by rio and so need threads to handle
% those requests.
% Server filsysproc can be seen as a master.
% Now see slaves workers.


% Fcall see fcall.h, unmarshalled p9 message received
% from pipe
%  Fcall.buf, Fcall.type
%  Fcall.fid! =~ qid?

% it's a DS which reprenset a filesystem request, Fcall,
% but when it's allocated it's also associated with a worker
% via a channel where can send some code to run! very nice!
% and so Xfid contains also all params for this call

\l rename Xfid to WorkerRequest?
<<struct [[Xfid]]>>=
struct Xfid
{
        // incoming parsed request
        Fcall req;
        // answer buffer
        byte	*buf;
 
        // handler to worker thread
        // chan<void(*)(Xfid*)> (listener = xfidctl, senders = filsysxxx)
        Channel	*c;	/* chan(void(*)(Xfid*)) */

        Fid	*f;

        Filsys	*fs;

        <<[[Xfid]] flushing fields>>
        <<[[Xfid]] other fields>>

        // Extra
        Ref;
        <<[[Xfid]] extra fields>>
};
@
%ocaml: no need buf, build directly ADT of answer. no need req too, pass
% directly the parameter of the constructor to the operation.
% no need channel for worker, create thread on the fly
%old: was Fcall; but better to name field.
\t Xfid.fs ? anyway can use the global filsys instead
% The ref seems to be either 0 or 1, so used just to sanity check things
% Ref because possibly concurrently access by xallocthread and xfidctl?

% buf? for filsysrespond? to write back? use same buffer
% after have parsed?

% store fs here because will need it to write back answer to client.


\subsection{9P callbacks: [[fcall]]}

% See Network.nw and plan9 RPC via 9p messages.
% Any process can be a filesystem server for another process.
% so can do mount /srv/rio.user.pid /mnt/wsys 43 
% and now the namespace /mnt/wsys/ will be served by the process
%  on the other side of the pipe in /src/rio.user.pid

% see docs/man/5/* 

% if mount cfd /mnt/wsys, then access from process (or child/execed process
%  which will inherit namespace) to files under /mnt/wsys/ will send
%  messages on cfd which will be processed by other side of pipe
%  and dispatched to right method.

\t could just pass Xfid no? anyway Fid and Filsys are inside Xfid.

% so filsysproc server listening on pipe will interpret 9p 
% incoming request and then dispatch to right function.
% will pass fs, worker handler, and file and then
% the method may or not call worker. It may return nil
% when the worker was used because need async processing.
% That was server know if can reuse or not the worker handler.

<<global [[fcall]]>>=
Xfid* 	(*fcall[Tmax])(Filsys*, Xfid*, Fid*) =
{
    [Tattach]  = filsysattach,

    [Twalk]    = filsyswalk,

    [Topen]    = filsysopen,
    [Tclunk]   = filsysclunk,
    [Tread]    = filsysread,
    [Twrite]   = filsyswrite,
    [Tstat]    = filsysstat,

    <<[[fcall]] other methods>>
};
@
%ocaml: in C this occupes 126 pointers because the first 100
% entries are not used by any Txxx. In OCaml can simply do a match
% and dispatch. No need intermediate filsysxxx (which then
% require to pass around lots of information as extra parameter)

% create/remove forbidden, other stuff could be aspectized too


% remember that Xfid is a Fcall, so signature make senses.
% Get incoming request and handler to worker, and
% return nil if need new worker or worker handler if can reuse.

% T for client Transmit request, R for server reply.
% will see R later in filsysrespond

% close? it is clunk, but it's not called close because
%  not all fid correspond to opened files. Clunk is there to
%  say the client does not care anymore about this fid.

% flush seems advanced feature of 9P not super needed.

%docs/man/5/intro
%Most programs do not see the 9P protocol directly; instead calls to library
%routines that access files are
%translated by the mount driver,
%.IR mnt (3),
%into 9P messages.

% \subsection{Summary}

% show which DS are associated with each big process?
% for instance filsysproc does not have access to windows, only
% to filsys








\chapter{[[main()]]}
\label{chap:main}

% see Libcore.nw, quick refresh on threads in plan9 and
% fact that main is then threadmain.

% main? -> <>
<<function [[threadmain]]>>=
void threadmain(int argc, char *argv[])
{
    <<[[main()]] locals>>

    ARGBEGIN{
    <<[[main()]] command line processing>>
    }ARGEND

    <<[[main()]] set some globals>>

    // Rio, a graphical application

    <<[[main()]] graphics initializations>>

    // Rio, a concurrent application

    <<[[main()]] communication channels creation>>
    <<[[main()]] threads creation>>

    // Rio, a filesystem server

    filsys = filsysinit(xfidinit());
    <<[[main()]] if filsys is nil>>
    else{
        <<[[main()]] error management after everything setup>>

        // blocks until get exit message on exitchan
        recv(exitchan, nil);
    }
    killprocs();
    threadexitsall(nil);
}
@
%dead: written but never read
%  <<global mainpid>> =
%  int		mainpid;
%  @
%  <<[[main()]] set some globals>> =
%  mainpid = getpid();
%  @
\t why need killprocs and threadexitsall? exit not enough?
\t  need killprocs at least because if you exit it will not kill other procs?
\t  but then why need threadexitsall?
%ocaml: just Unix.exit? anyway just one proc and many threads.


% exitchan later, but a channel! when Exit menu in rio via mouse,
% this will send on exitchan a message and unblock threadmain.


<<[[main()]] if filsys is nil>>=
if(filsys == nil)
    fprint(STDERR, "rio: can't create file system server: %r\n");
@
%ocaml: exn in callee

\section{Graphics initialization}

% not that different from hellorio.c! rio is first
% a graphical application!

% see Graphics.nw

<<[[main()]] graphics initializations>>=
if(geninitdraw(nil, derror, nil, "rio", nil, Refnone) < 0){
    fprint(STDERR, "rio: can't open display: %r\n");
    exits("display open");
}
viewr = view->r;

iconinit(); // allocate background and red images

<<[[main()]] mouse initialisation>>
<<[[main()]] keyboard initialisation>>

desktop = allocscreen(view, background, false);
<<[[main()]] sanity check desktop>>

draw(view, viewr, background, nil, ZP);
flushimage(display, true);
@
%ocaml: use exn, and use les nil: better default interface
\l could call initdraw instead of geninitdraw
% background is grey image color?

<<[[main()]] sanity check desktop>>=
if(desktop == nil)
    error("can't allocate desktop");
@
%ocaml: exn

% ref to Error managment appendix?
% also talk about derror argument to geninitdraw?



% threadmain -> <>
<<function [[iconinit]]>>=
void
iconinit(void)
{
    background = allocimage(display, Rect(0,0,1,1), RGB24, true, 0x777777FF);
    red        = allocimage(display, Rect(0,0,1,1), RGB24, true, 0xDD0000FF);
}
@
% why iconinit? icon??
%ocaml: use shorter alloc_color() and Color.mk2()

\section{Mouse initialization}

% The windowing system is a graphical application like other graph app!
% It needs to call initmouse, initkeyboard. 

% threadmain -> <>
<<[[main()]] mouse initialisation>>=
mousectl = initmouse(nil, view);
if(mousectl == nil)
    error("can't find mouse");
mouse = mousectl;
@
%ocaml: better interface without nil and use exn

% cast here, access actually anonymous subfield of mousectl.
% could pass /dev/mouse

% Note that this creates a process! ioproc.

\section{Keyboard initialization}

<<[[main()]] keyboard initialisation>>=
keyboardctl = initkeyboard(nil);
if(keyboardctl == nil)
    error("can't find keyboard");
@
%ocaml: better interface without nil and use exn

% could pass /dev/mouse

% Note that this creates a process too! ioproc.


\section{Channels creation}

% threads communicate and synchronized between each other through
% messages on channels
%alt: locks or mutex or semaphores or monitor

<<global [[exitchan]]>>=
// chan<unit> (listener = threadmain, sender = mousethread(Exit) | ?)
Channel	*exitchan;	/* chan(int) */
@
%ocaml: typed channels! no need for comment!

% It's more chan(void) no? 
% For unix not because can return exit code, but true that for plan9
% should really be a string instead

% rio = waiting for many different kind of messages/"events"
<<[[main()]] communication channels creation>>=
exitchan     = chancreate(sizeof(int), 0);
@

% see also winclosechan and deletechan later
% see also cxfidalloc and cxfidfree later
% there are also lots of channel creation when create windows

\section{Threads creation}

<<constant [[STACK]]>>=
#define	STACK	8192
@
%ocaml: default value that can grows 


<<[[main()]] threads creation>>=
threadcreate(keyboardthread, nil, STACK);
threadcreate(mousethread, nil, STACK);
@
%ocaml: pass keyboardctl, mousectl, etc instead of nil

% but convenient to have them in globals?


% see also right menu and new create a new window and so a new thread!
%  also each open of a /dev/ file creates a thread?
% see also filsysinit also creates many threads and also some processes
% see also thread for deletechan and winclose, but later.

% will see Threads in next chapter.

\section{Filesystem server initialization}

%    filsys = filsysinit(xfidinit());

\subsection{[[filsysinit()]]}

% ctor filsys
% main -> <>
<<function [[filsysinit]]>>=
Filsys*
filsysinit(Channel *cxfidalloc)
{
    int pid;
    Filsys *fs;
    <<[[filsysinit()]] other locals>>

    <<[[filsysinit()]] install dumper>>

    fs = emalloc(sizeof(Filsys));

    if(cexecpipe(&fs->cfd, &fs->sfd) < 0)
        goto Rescue;

    <<[[filsysinit()]] set clockfd>>
    <<[[filsysinit()]] set fs user>>
    pid = getpid();

    fs->cxfidalloc = cxfidalloc;

    <<[[filsysinit()]] wctl pipe, process, and thread creation>>

    proccreate(filsysproc, fs, 10000);

    <<[[filsysinit()]] srv pipe>>

    return fs;

Rescue:
    free(fs);
    return nil;
}
@
%ocaml: need cxfidalloc? because have arena of workers? 
% what if create each time a new thread? too slow?

% filsysproc later

% user and pid are for
%    // to create "/srv/rio.{user}.{pid}"
% but maybe also more
\l aspectize it

% comm channel is a pipe this time, because it's between processes.

<<function [[cexecpipe]]>>=
/*
 * Build pipe with OCEXEC set on second fd.
 * Can't put it on both because we want to post one in /srv.
 */
errorneg1
cexecpipe(fdt *p0, fdt *p1)
{
    /* pipe the hard way to get close on exec */
    if(bind("#|", "/mnt/temp", MREPL) < 0)
        return ERROR_NEG1;
    *p0 = open("/mnt/temp/data", ORDWR);
    *p1 = open("/mnt/temp/data1", ORDWR|OCEXEC);
    unmount(nil, "/mnt/temp");
    if(*p0<0 || *p1<0)
        return ERROR_NEG1;
    return OK_0;
}
@
%ocaml: no OCEXEC on unix? so if exec have to take care! to close
% those things, so have to store them somewhere. Actually ocaml
% has Unix.set_close_on_exec
%ocaml: need create 2 pipes? unix pipes are unidirectional?

% Note that ORDWR! pipes are both ways in Plan9.
% So both sides can read/write on the pipe.

% comment about /srv??

% close on exec for server? so keep only client fd?

% See Kernel.nw for pipe and #| device.


\subsection{Worker allocator: [[xfidinit()]]}

%    filsys = filsysinit(xfidinit());

% workers factory

<<global [[cxfidalloc]]>>=
// chan<ref<Xfid>> (listener = filsysproc, sender = xfidallocthread)
static	Channel	*cxfidalloc;	/* chan(Xfid*) */
@
% could avoid using globals if pass it to xfidallocthread
% as anyway it's stored in filsys

<<global [[cxfidfree]]>>=
// chan<ref<Xfid>> (listner = ??, sender = ??)
static	Channel	*cxfidfree;	/* chan(Xfid*) */
@

% who owns the Xfid? xfidallocthread! and this allocator
% has two channels for new/free.


% threadmain -> <>
<<function [[xfidinit]]>>=
Channel*
xfidinit(void)
{
    cxfidalloc = chancreate(sizeof(Xfid*), 0);
    cxfidfree = chancreate(sizeof(Xfid*), 0);
    threadcreate(xfidallocthread, nil, STACK);
    return cxfidalloc;
}
@
%ocaml: why need extra thread for getting Xfids?
% can not just create them live? Because want an arena?

% xfidallocthread later

% regular threads, so no race between xfidxxx and winctl!








\chapter{Procs and Threads}
\label{chap:processes-threads}

% show already FIGURE about threads and procs in soft archi.

% In the end rio will manage many independent windows/process/activities.
% Independent activities, answer to keyboard/mouse, events,
% so need manage those activities. Threads seems natural.

% GUI is reactive, not batch, so have external events (kinda interrupts),
% such as mouse move, keyboard, and cant have rio polling that.
% Need separate concerns and be efficient. So threads and channels
% and have thread scheduler do its best to yield to the
% thread who needs it. When mouse, then mouse thread. When keyboard,
% keyboard threads, and those threads then dispatch to the appropriate
% window thread that will handle its own window.

% in the end it's similar to what the kernel does. Process are waiting
% reading on fd connected to some devices, and when interrupt, the
% kernel await some process to go on. So can have independent
% activities working.

%alt: quite similar to a kernel? use interrupt handlers then?

% Efficiently Scheduling X Clients:
%http://keithp.com/~keithp/talks/usenix2000/smart.html

%ocaml: need less proc. No need for ioproc and filsysproc.
% But need a process for the winshell!

\section{Keyboard thread}

% maybe can zoom on archi diagram and put channel names
% so put  mousectl->c for IO proc to mouse thread, and
% Window.mouse.c for mouse thread to window thread


% The listening channel is keyboardctl->c, see keyboard.h.
% The sending channel is Window.ck, which we will see soon.
% Each window will have a thread.

% // chan<Rune, 20> (listener = keyboardthread, sender = ioproc(initkeyboard))
% Channel* Keyboardctl.c; // Graphics.nw

% listen/dispatch architecture.

% main -> threadcreate -> <>  (as ?? in threadcreate(<>) <- main)
<<function [[keyboardthread]]>>=
void
keyboardthread(void*)
{
    Rune buf[2][20];
    // points to buf[0] or buf[1]
    Rune *rp;
    int n, i;

    threadsetname("keyboardthread");

    n = 0;
    for(;;){
        rp = buf[n];
        n = 1-n;

        // Listen
        recv(keyboardctl->c, rp);

        for(i=1; i<nelem(buf[0])-1; i++)
            if(nbrecv(keyboardctl->c, rp+i) <= 0)
                break;
        rp[i] = L'\0';

        if(input != nil)
            // Dispatch, to current window thread!
            sendp(input->ck, rp);
    }
}
@
% no alts(), just a single message, so just recv()
\t bug size 20? should have 21 if want put extra '\0'!

% Rune! so super simple, no need to have Ctl, Alt, ... all of
% those composed keys are Rune? 
\l Hmm but then can't intercept when guy just type on Ctlr and release? Quake?

% pretty simple, send key to the window (window ck channel and thread) 
% with the focus

% null char put as end marker (could pass size instead?)
%ocaml: pass a key at a time? Why need buffer of 20? 
% otherwise not reactif enough?

% Why use alternate buffer? so can send with one and recv on the other.
\l But anyway send is blocking no? or is it diff between sendp and send?
%ocaml: values are transmitted by values, so no need use alternate buffers

\t sendp ? vs send? send that does not wait for receiver to be ready?
\t  but instead store in buffer?

%alt: alternative to keyboard thread? select in rio? callback/interrupts?
% why want to use thread for that?
% Have main rio process do scanf? cant cos buffered.
% So need raw mode, but then blocked ... need to listen but not
% be blocked. Want to listen to many external events, do many concurrent
% things.
% This is what threads (and ioproc) provides.

% why need separate thread just for keyboard? because cant have
% all window thread listen at the same time. Need one thread
% and then dispatch (demultiplex).

\section{Mouse thread}

% seen event type for hellorio, here event types for
% mouse thread. listen to multiple channels at the same time
% and can emit on multiple channels when target is ready to receive.

<<enum [[Mxxx]]>>=
enum {
    MMouse,
    <<[[Mxxx]] cases>>
    NALT
};
@
% index for different Alt. 
% Thread will look for multiple messages on different channels
% (just mouse event and resize event?)


<<[[mousethread()]] locals>>=
// map<enum<Mxxx>, Alt>
static Alt alts[NALT+1];
@
% why static? mousethread not called anyway no?
% plus 1 for CHANEND marker

% small rappel here on libthread maybe? alt =~ select.


<<function [[mousethread]]>>=
void
mousethread(void*)
{
    <<[[mousethread()]] locals>>

    threadsetname("mousethread");

    <<[[mousethread()]] alts setup>>
    alts[NALT].op = CHANEND;

    for(;;)
        // message loop
        switch(alt(alts)){
        <<[[mousethread()]] event loop cases>>
        }
}
@
% classic, like hellorio.c

<<[[mousethread()]] alts setup>>=
// listen
alts[MMouse].c = mousectl->c;
alts[MMouse].v = &mousectl->Mouse;
alts[MMouse].op = CHANRCV;
@
% what would be the other Alt?? resize?

%// chan<Mouse> (listener = mousethread, sender = ioproc(initkeyboard))
%Channel* Mousectl.c;

% global mousectl here.

% but for now equivalent mostly to a recv(mousectl->c, &mousectl->Mouse)


<<[[mousethread()]] locals>>=
Window *winput;
Point xy; // logical coord
@
\l why local winput? cant use input directly? need to save it?


% different from keyboard, here does not always dispatch to the
% (possibly graphical) window.
% The mouse action must be interpreted by rio itself as it may relate
% to windows managment! mv, resize, etc.
% Local below differentiates those 2 situations, whether need to 
% relay/send mouse event to window.

<<[[mousethread()]] locals>>=
bool sending = false;
@
% application(client) vs system (rio) mouse event!


<<[[mousethread()]] event loop cases>>=
case MMouse:
    <<[[mousethread()]] if wkeyboard and button 6>>
Again:
    winput = input;
    <<[[mousethread()]] if wkeyboard and ptinrect>>

    if(winput != nil && winput->i != nil){
        /* convert to logical coordinates */
        xy.x = mouse->xy.x + (winput->i->r.min.x - winput->screenr.min.x);
        xy.y = mouse->xy.y + (winput->i->r.min.y - winput->screenr.min.y);

        <<[[mousethread()]] goto Sending if scroll buttons>>

        inside = ptinrect(mouse->xy, insetrect(winput->screenr, Selborder));

        <<[[mousethread()]] set scrolling>>
        <<[[mousethread()]] set moving to true for some conditions>>
        else 
           <<[[mousethread()]] set sending to true for some conditions>>
    }else
        sending = false;

    <<[[mousethread()]] if sending>>
    <<[[mousethread()]] if not sending>>

<<[[mousethread()]] Drain label>>
@
\l how a window can not have an image?
%ocaml: no need to check if window has an image. It has one by construction.
\l just like have winborder, could use wininside function instead
\l  of call to ptinrect

\l why store input in local winput? 

% explain logical coordinates, even though rio does not do anymore
% originwindow, so w->i->r and w->screenr ar the same so cancelled out)

% FIGURE: with winput->screenr, i->r, screen->r, etc and how they relate.


<<constant [[Selborder]]>>=
Selborder		= 4,	/* border of selected window */
@
\l could rename frame_border, but frame is used for editor_widget
%coupling with Borderwidth in draw.h? why not use same constant?
% also abused as an enum with Selborder and Unselborder


\subsection{Application mouse events}

% when set sending to true? what are the conditions to relay mouse events?
% when inside and scroll, left click, or opened mouse
% if not opened then middle and right click are intercepted.

<<[[mousethread()]] set sending to true for some conditions>>=
if(inside && 
   ((mouse->buttons&1) || winput->mouseopen || scrolling))
     sending = true;
@
%ocaml: buttons.left clearer than 1. Also more functional by
% returning boolean insteaf of setting local sending

% If mouseopen then need relay all mouse messages
% If not, then relay at least left button because terminal uses
%  for text selection and to move the text cursor

% scrolling? when started click to scroll? 
% No, when automatic scrolling selected.
\t rename autoscroll
\l but still, why send to app then?

<<[[mousethread()]] locals>>=
Mouse tmp;
@

<<[[mousethread()]] if sending>>=
if(sending){
Sending:
    <<[[mousethread()]] when sending mouse message to window, set the cursor>>

    tmp = mousectl->Mouse;
    tmp.xy = xy; // logical coordinates

    // Dispatch, to current window thread!
    send(winput->mc.c, &tmp);
    continue;
}
@
%ocaml: no need backup mousectl value. Pass data by value in channels.

\l could mv later
<<[[mousethread()]] when sending mouse message to window, set the cursor>>=
if(mouse->buttons == 0){
    // cornercursor will call wsetcursor if cursor not on the border
    cornercursor(winput, mouse->xy, false);
    sending = false;
}else
    wsetcursor(winput, false);
@
% so when click button there is never a system cursor?
%ocaml: set local back to false because of goto Again?

% send until release button?



\subsection{Windowing system mouse events}

<<[[mousethread()]] locals>>=
Window *w;
@

% window manager related stuff
<<[[mousethread()]] if not sending>>=
w = wpointto(mouse->xy);

<<[[mousethread()]] when not sending, set cursor part1>>
<<[[mousethread()]] if moving and buttons>>
<<[[mousethread()]] when not sending, set cursor part2>>

<<[[mousethread()]] when not sending, if buttons>>
moving = false;
break;
@

% moving??

% important function
<<function [[wpointto]]>>=
Window*
wpointto(Point pt)
{
    int i;
    Window *v, *w;

    w = nil;
    for(i=0; i<nwindow; i++){
        v = windows[i];
        if(ptinrect(pt, v->screenr))
         if(!v->deleted)
          if(w==nil || v->topped > w->topped)
            w = v;
    }
    return w;
}
@
% thx to topped can find the topmost one under the cursor
% (linear in number of windows though)
%alt: maintain stack of windows?


<<[[mousethread()]] when not sending, set cursor part1>>=
/* change cursor if over anyone's border */
if(w != nil)
    cornercursor(w, mouse->xy, false);
else
    riosetcursor(nil, false);
@
<<[[mousethread()]] when not sending, set cursor part2>>=
if(w != nil)
    cornercursor(w, mouse->xy, false);
@
\l why 2 times cornercursor? because moving in between??





% hmmm, complicated dispatch function.
% LP split more? and make more readable the action
<<[[mousethread()]] when not sending, if buttons>>=
/* we're not sending the event, but if button is down maybe we should */
if(mouse->buttons){
    /* w->topped will be zero or less if window has been bottomed */
    if(w==nil || (w==winput && w->topped > 0)){
        if(mouse->buttons & 1){
            ;
        }else if(mouse->buttons & 2){
            if(winput && !winput->mouseopen)
                <<[[mousethread()]] middle click under certain conditions>>
        }else if(mouse->buttons & 4)
                <<[[mousethread()]] right click under certain conditions>>
    }else{
        /* if button 1 event in the window, top the window and wait for button up. */
        /* otherwise, top the window and pass the event on */
        <<[[mousethread()]] click on unfocused window, set w>>
        if(w && (mouse->buttons!=1 || winborder(w, mouse->xy)))
            // input changed
            goto Again;

        goto Drain;
    }
}
@
%ocaml: introduce under_mouse type with Nothing|CurrentWin|OtherWin
% and then complex pattern matching so easier than all those if then else
%ocaml: not sure want to goto Again. Complexity needed?

\l but if w == winput then winput has to be topped! because wpointto
\l would not have returned it no?

\l how w can be nil after click on unfocused window? it can not be
%ocaml: use top_win so by construction sure that we set the window


% Drain?

% argh, complex flow, complex conditions.





\t ??? 
<<[[mousethread()]] Drain label>>=
Drain:
    do {
        readmouse(mousectl);
    } while(mousectl->buttons);
    moving = false;
    goto Again;	/* recalculate mouse position, cursor */
@

% note that readmouse does not access directly /dev/mouse.
% It still listens on the channel connected to Mouse.thread_mouse
% so there is concurrency issue. Only one place reads the channel
% at a time. 


\section{Window threads}

% listen to many channels! (and relaying to many channels)

% keyboard listening (and relaying)
% mouse listening (and relaying)
% ctl listening from rio window manager

% special device file listening (/dev/cons) but will see that later

<<enum [[Wxxx]]>>=
enum { 
    WKey, 
    WMouse, 
    WCtl,
    <<[[Wxxx]] cases>>

    NWALT 
};
@
% there will be a lot more! especially for interacting with the
% virtual devices mounted by the window






% rename winctlthread? more consistent?
% ... -> new() -> threadcreate(<>, w)
<<function [[winctl]]>>=
void
winctl(void *arg)
{
    Window *w = arg;
    // map<enum<Wxxx>, Alt>
    Alt alts[NWALT+1];
    <<[[winctl()]] other locals>>
    
    snprint(buf, sizeof buf, "winctl-id%d", w->id);
    threadsetname(buf);

    <<[[winctl()]] channels creation>>

    <<[[winctl()]] alts setup>>
    alts[NWALT].op = CHANEND;

    for(;;){
        <<[[winctl()]] alts adjustments>>

        // event loop
        switch(alt(alts)){
        <<[[winctl()]] event loop cases>>
        }

        if(!w->deleted)
            flushimage(display, true);
    }
}
@
%old: was char buf[4*12+1]; but just used for threadsetname
% so even though it looks like size for interface to /dev/mouse, it was not
\l why plus 1 on NWALT?

%old: 
% npart = 0; was there, but better put with local decl.
% lastb = -1; same

% m = mouse, c = cons
% r = read, w = write
% m = message


\subsection{Keyboard events listening}

<<[[Window]] keyboard fields>>=
// chan<Rune, 20> (listener = winctl, sender = keyboardthread)
Channel	*ck;		/* chan(Rune[10]) */
@
% it's Rune[20] actually no? wrong comment?

% saw send(input->ck) before in keyboard thread.
% so trace of key: 
% kernel (interrupt) -> ioproc(read /dev/cons) !-> keyboardthread !-> winctl
% and not finished ...

<<[[winctl()]] other locals>>=
Rune *kbdr;
@
% allocated by who? because chan 20?

<<[[winctl()]] alts setup>>=
alts[WKey].c = w->ck;
alts[WKey].v = &kbdr;
alts[WKey].op = CHANRCV;
@


<<[[winctl()]] event loop cases>>=
case WKey:
    for(i=0; kbdr[i] != L'\0'; i++)
        wkeyctl(w, kbdr[i]);
    break;
@
%old, probably debug code commented?:
%//		wkeyctl(w, r);
%//		while(nbrecv(w->ck, &r))
%//			wkeyctl(w, r);

% use of end marker L'\0' here, same than in keyboardthread


% winctl -> <> (when key on ck channel)
<<function [[wkeyctl]]>>=
void
wkeyctl(Window *w, Rune r)
{
    <<[[wkeyctl()]] locals>>

    <<[[wkeyctl()]] sanity check rune>>
    <<[[wkeyctl()]] return if window was deleted>>

    /* navigation keys work only when mouse is not open */
    <<[[wkeyctl()]] when mouse not opened and navigation keys>>

    <<[[wkeyctl()]] if rawing>>
    <<[[wkeyctl()]] if holding>>

    <<[[wkeyctl()]] when not rawing>>
}
@
\l actually it's not exactly when not rawing, because the if rawing
\l  path is taken if w->rawing && other condition

% a bit complicated because rio allows weird combinations like
% mouseopen and buffered mode, or not mouseopend and raw mode.
% In last case we want the special navigation keys to still work.

<<[[wkeyctl()]] sanity check rune>>=
if(r == 0)
    return;
@
\l when have rune 0? winctl calls us for sure with r != L'\0'
\l then dead code? other callers of wkeyctl/

% will see those cases later when talk about graphical and textual windows.
% will see actually relay to other channel.


<<[[wkeyctl()]] return if window was deleted>>=
if(w->deleted)
    return;
@
\l how can be deleted and receive keyboard event?

\subsection{Mouse events listening}

<<[[Window]] mouse fields>>=
// mc.c = chan<Mouse> (listener = winctl, sender = mousethread)
Mousectl	mc;
@
% note that not all mouse events arrive here, only the one
% mousethread think they are destined for this window

% same DS than in mousethread

% why need whole Mousectl? why not just channel? because need c and resizec
% and a Mouse, so simpler to just take the whole Mousectl.
\t simplify, have named Mouse, and then mch and resizech ?


% kernel (interrupt) -> ioproc(read /dev/mouse) !-> mousethread !-> winctl
% and not finished ...


<<[[winctl()]] alts setup>>=
alts[WMouse].c = w->mc.c;
alts[WMouse].v = &w->mc.Mouse;
alts[WMouse].op = CHANRCV;
@

% see in mousethread for the application mouse event dispatch:
%    send(winput->mc.c, &tmp);


<<[[winctl()]] other locals>>=
char buf[128]; // /dev/mouse interface
@

<<[[winctl()]] event loop cases>>=
case WMouse:
    <<[[winctl()]] WMouse case if mouseopen>>
    else
    <<[[winctl()]] WMouse case if not mouseopen>>
    break;
@

% no wmousectl()

\subsection{Control events listening}
% e.g., resize, delete, hide, etc.

<<[[Window]] control fields>>=
// chan<Wctlmesg, 20> (listener = winctl, sender = mousethread | ...)
Channel	*cctl;		/* chan(Wctlmesg)[20] */
@
\l ctlch ? more consistent?
\l again why queue of 20? 1 not enough?

<<[[winctl()]] other locals>>=
Wctlmesg wcm;
@
% will see Wctlmesg later.

<<[[winctl()]] alts setup>>=
alts[WCtl].c = w->cctl;
alts[WCtl].v = &wcm;
alts[WCtl].op = CHANRCV;
@

% many calls to wctlsendmesg() that write in w->cctl


<<[[winctl()]] event loop cases>>=
case WCtl:
    if(wctlmesg(w, wcm.type, wcm.r, wcm.image) == Exited){
        <<[[winctl()]] Wctl case, free channels if wctlmesg is Excited>>
        threadexits(nil);
    }
    continue;
@
%ocaml: no need intermediate wctlmesg

% will see wctlmesg later



%\subsection{[[/mnt/wsys/mouse]]  emitting}
%\subsection{[[/mnt/wsys/cons]] emitting}
%\subsection{[[/mnt/wsys/wctl]] emitting}

%\section{Client processes}
% winshell created from mouse threads when New from winctl


\section{Filesystem server proc}
\n actually it's a process but it creates many threads indirectly


% why a process? because block on fs->sfd! would block everything else.
%ocaml: can be a thread thx to ThreadUnix.

<<global [[messagesize]]>>=
int	messagesize = 8192+IOHDRSZ;	/* good start */
@
%ocaml: a field in global 'fs' instead of global

% negociated with kernel in filsysversion in first message
% IOHDRSZ defined in fcall.h

\subsection{[[filsysproc()]]}

%main -> filsysinit -> proccreate -> <>
<<function [[filsysproc]]>>=
static
void
filsysproc(void *arg)
{
    Filsys *fs = arg;
    int n;
    byte *buf;
    Xfid *x = nil;
    Fid *f;
    <<[[filsysproc()]] other locals>>

    threadsetname("FILSYSPROC");

    for(;;){
        buf = emalloc(messagesize+UTFmax);	/* UTFmax for appending partial rune in xfidwrite */

        n = read9pmsg(fs->sfd, buf, messagesize);
        <<[[filsysproc()]] sanity check n>>
        if(x == nil){
            send(fs->cxfidalloc, nil);
            recv(fs->cxfidalloc, &x);
            x->fs = fs;
        }
        x->buf = buf;

        if(convM2S(buf, n, &x->req) != n)
            error("convert error in convM2S");
        <<[[filsysproc()]] dump Fcall if debug>>

        <<[[filsysproc()]] sanity check x type>>
        else{
            <<[[filsysproc()]] if x type is Tversion or Tauth>>
            else
                f = newfid(fs, x->req.fid);
            x->f = f;

            // Dispatch
            x  = (*fcall[x->req.type])(fs, x, f);
        }
        <<[[filsysproc()]] end of loop>>
    }
}
@
%dead:    fs->pid = getpid();  was after threadsetname
%ocaml: do not go through xfid allocator arena, just create each
% time a new thread
%ocaml: do no go through intermediate buffer and read9pmsg/convM2S, do
% both at once
%ocaml: no need intermediate fcall global dispatch. Dispatch inline
% with match.
%ocaml: no newfid here! do it only in Attach or Walk, and for the other
% cases use lookup_fid, not new_fid

% why need send and recv? cant just recv?

% for the comment about UTFMAX, it's because there is a memmove
% far later in xfidwrite when put back a partial rune
% wrote last time

% this reset x after the call? if result could be
% processed immediately, then can reuse, otherwise need
% get a new thread.

% read9pmsg, convM2S, see fcall.h



% Note that filsysproc is a proccreate! need because blocking
% on pipe. Note also that in plan9 proccreate create process
% but share address space (RFMEM)! means filsys and Fids can be modified in
% filsysrespond and access in xfidthreads!

<<[[filsysproc()]] sanity check n>>=
if(n <= 0){
    yield();	/* if threadexitsall'ing, will not return */
    fprint(STDERR, "rio: %d: read9pmsg: %d %r\n", getpid(), n);
    errorshouldabort = false;
    error("eof or i/o error on server channel");
}
@
% yield??



<<[[filsysproc()]] if x type is Tversion or Tauth>>=
if(x->req.type==Tversion || x->req.type==Tauth)
    f = nil;
@
% no fid for those fcalls.



<<[[filsysproc()]] other locals>>=
Fcall fc;
@
%old: was called t, but sometimes called fc in some functions
% and confusing that it's actually a Fcall Reply, not Transmit.
% maybe should call it r?

<<[[filsysproc()]] sanity check x type>>=
if(fcall[x->req.type] == nil)
    x = filsysrespond(fs, x, &fc, Ebadfcall);
@
% when can happen? if receive a response request, but this
% means the kernel is buggy.


\subsection{[[filsysversion()]]}

<<[[fcall]] other methods>>=
[Tversion] = filsysversion,
@

<<function [[filsysversion]]>>=
static
Xfid*
filsysversion(Filsys *fs, Xfid *x, Fid*)
{
    Fcall fc;

    <<[[filsysversion()]] sanity checks>>
    // else
    messagesize = x->req.msize;
    fc.msize = messagesize;
    fc.version = "9P2000";
    return filsysrespond(fs, x, &fc, nil);
}
@
%old: I reordered a bit so could put all sanity checks together

% must answer with same values! otherwise mount syscall will fail


<<global [[firstmessage]]>>=
bool	firstmessage = true;
@
% needed to ensure filsysversion is first request sent

<<[[filsysversion()]] sanity checks>>=
if(!firstmessage)
    return filsysrespond(x->fs, x, &fc, "version request not first message");
@

<<[[filsysproc()]] end of loop>>=
firstmessage = false;
@



<<[[filsysversion()]] sanity checks>>=
if(x->req.msize < 256)
    return filsysrespond(x->fs, x, &fc, "version: message size too small");
if(strncmp(x->req.version, "9P2000", 6) != 0)
    return filsysrespond(x->fs, x, &fc, "unrecognized 9P version");
@
% why 256? need to write in one block data for /mnt/wsys/mouse
% so need some basic space?



\section{[[Xfid]] allocator thread}

%ocaml: create each time a new thread so no need arena allocator

<<enum [[Xxxx]]>>=
enum { 
    Alloc, 
    Free, 

    N 
};
@
\t rename XFAlloc, XFFree, XNALT like for the other threads

<<global [[xfid]]>>=
// list<ref_own<Xfid>> (next = Xfid.next)
static	Xfid	*xfid;
@

<<global [[xfidfree]]>>=
// list<ref_own<Xfid>> (next = Xfid.free)
static	Xfid	*xfidfree;
@


<<[[Xfid]] extra fields>>=
Xfid	*next;
Xfid	*free;
@

% main -> xfidinit -> threadcreate -> <> (as ?? <- threadcreate(<>) <- xfidinit)
<<function [[xfidallocthread]]>>=
void
xfidallocthread(void*)
{
    Xfid *x;
    static Alt alts[N+1];

    alts[Alloc].c = cxfidalloc;
    alts[Alloc].v = nil;
    alts[Alloc].op = CHANRCV;
    alts[Free].c = cxfidfree;
    alts[Free].v = &x;
    alts[Free].op = CHANRCV;
    alts[N].op = CHANEND;

    for(;;){
        // event loop
        switch(alt(alts)){
        case Alloc:
            x = xfidfree;
            if(x)
                xfidfree = x->free;
            else{
                x = emalloc(sizeof(Xfid));
                x->c = chancreate(sizeof(void(*)(Xfid*)), 0);
                <<[[xfidallocthread()]] create flushc channel>>

                // insert_list(x, xfid)
                x->next = xfid;
                xfid = x;

                // new Xfid threads!
                threadcreate(xfidctl, x, 16384);
            }
            <<[[xfidallocthread()]] sanity check x when Alloc>>
            incref(x);

            sendp(cxfidalloc, x);
            break;

        case Free:
            <<[[xfidallocthread()]] sanity check x when Free>>
            // insert_list(x, xfidfree)
            x->free = xfidfree;
            xfidfree = x;
            break;
        }
    }
}
@



<<[[xfidallocthread()]] sanity check x when Alloc>>=
if(x->ref != 0){
    fprint(STDERR, "%p incref %ld\n", x, x->ref);
    error("incref");
}
if(x->flushtag != -1)
    error("flushtag in allocate");
@
%ocaml: exn
\l mv flushtag to later?


<<[[xfidallocthread()]] sanity check x when Free>>=
if(x->ref != 0){
    fprint(STDERR, "%p decref %ld\n", x, x->ref);
    error("decref");
}
if(x->flushtag != -1)
    error("flushtag in free");
@

\section{[[Xfid]] threads}
% =~ workers which will handle a file request

% thread callback ...
<<function [[xfidctl]]>>=
void
xfidctl(void *arg)
{
    Xfid *x = arg;
    void (*f)(Xfid*);
    char buf[64];

    snprint(buf, sizeof buf, "xfid.%p", x);

    threadsetname(buf);

    for(;;){
        f = recvp(x->c);

        // Executing a xfidxxx()
        (*f)(x);

        if(decref(x) == 0)
            sendp(cxfidfree, x);
    }
}
@

% very nice, get code on channel (function pointer),
% and start execute it!
%ocaml: just create each time new thread with closured passed by!
% not even need an arena allocator

\l how decref cannot be 0?
\l how can share an xfid?? why need a Ref?





\chapter{Cursors}
\label{chap:cursor}

%trans: before heart of rio and windows management,
% easier part, cursors.

\section{Cursor graphics}

% put pictures instead of code :)
% what is the code that takes the hexa data and draw?

\subsection{Classic cursors}

% arrow? default in ?

<<global crosscursor (windows/rio/data.c)>>=
Cursor crosscursor = {
    {-7, -7},
    {0x03, 0xC0, 0x03, 0xC0, 0x03, 0xC0, 0x03, 0xC0,
     0x03, 0xC0, 0x03, 0xC0, 0xFF, 0xFF, 0xFF, 0xFF,
     0xFF, 0xFF, 0xFF, 0xFF, 0x03, 0xC0, 0x03, 0xC0,
     0x03, 0xC0, 0x03, 0xC0, 0x03, 0xC0, 0x03, 0xC0, },
    {0x00, 0x00, 0x01, 0x80, 0x01, 0x80, 0x01, 0x80,
     0x01, 0x80, 0x01, 0x80, 0x01, 0x80, 0x7F, 0xFE,
     0x7F, 0xFE, 0x01, 0x80, 0x01, 0x80, 0x01, 0x80,
     0x01, 0x80, 0x01, 0x80, 0x01, 0x80, 0x00, 0x00, }
};
@
% when create new window (sweep())

<<global boxcursor (windows/rio/data.c)>>=
Cursor boxcursor = {
    {-7, -7},
    {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
     0xFF, 0xFF, 0xF8, 0x1F, 0xF8, 0x1F, 0xF8, 0x1F,
     0xF8, 0x1F, 0xF8, 0x1F, 0xF8, 0x1F, 0xFF, 0xFF,
     0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, },
    {0x00, 0x00, 0x7F, 0xFE, 0x7F, 0xFE, 0x7F, 0xFE,
     0x70, 0x0E, 0x70, 0x0E, 0x70, 0x0E, 0x70, 0x0E,
     0x70, 0x0E, 0x70, 0x0E, 0x70, 0x0E, 0x70, 0x0E,
     0x7F, 0xFE, 0x7F, 0xFE, 0x7F, 0xFE, 0x00, 0x00, }
};
@
% when move (drag())

<<global sightcursor (windows/rio/data.c)>>=
Cursor sightcursor = {
    {-7, -7},
    {0x1F, 0xF8, 0x3F, 0xFC, 0x7F, 0xFE, 0xFB, 0xDF,
     0xF3, 0xCF, 0xE3, 0xC7, 0xFF, 0xFF, 0xFF, 0xFF,
     0xFF, 0xFF, 0xFF, 0xFF, 0xE3, 0xC7, 0xF3, 0xCF,
     0x7B, 0xDF, 0x7F, 0xFE, 0x3F, 0xFC, 0x1F, 0xF8, },
    {0x00, 0x00, 0x0F, 0xF0, 0x31, 0x8C, 0x21, 0x84,
     0x41, 0x82, 0x41, 0x82, 0x41, 0x82, 0x7F, 0xFE,
     0x7F, 0xFE, 0x41, 0x82, 0x41, 0x82, 0x41, 0x82,
     0x21, 0x84, 0x31, 0x8C, 0x0F, 0xF0, 0x00, 0x00, }
};
@
% when select delete in system menu

<<global whitearrow (windows/rio/data.c)>>=
Cursor whitearrow = {
    {0, 0},
    {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFF, 0xFC, 
     0xFF, 0xF0, 0xFF, 0xF0, 0xFF, 0xF8, 0xFF, 0xFC, 
     0xFF, 0xFE, 0xFF, 0xFF, 0xFF, 0xFE, 0xFF, 0xFC, 
     0xF3, 0xF8, 0xF1, 0xF0, 0xE0, 0xE0, 0xC0, 0x40, },
    {0xFF, 0xFF, 0xFF, 0xFF, 0xC0, 0x06, 0xC0, 0x1C, 
     0xC0, 0x30, 0xC0, 0x30, 0xC0, 0x38, 0xC0, 0x1C, 
     0xC0, 0x0E, 0xC0, 0x07, 0xCE, 0x0E, 0xDF, 0x1C, 
     0xD3, 0xB8, 0xF1, 0xF0, 0xE0, 0xE0, 0xC0, 0x40, }
};
@
% for holding mode

<<global query (windows/rio/data.c)>>=
Cursor query = {
    {-7,-7},
    {0x0f, 0xf0, 0x1f, 0xf8, 0x3f, 0xfc, 0x7f, 0xfe, 
     0x7c, 0x7e, 0x78, 0x7e, 0x00, 0xfc, 0x01, 0xf8, 
     0x03, 0xf0, 0x07, 0xe0, 0x07, 0xc0, 0x07, 0xc0, 
     0x07, 0xc0, 0x07, 0xc0, 0x07, 0xc0, 0x07, 0xc0, },
    {0x00, 0x00, 0x0f, 0xf0, 0x1f, 0xf8, 0x3c, 0x3c, 
     0x38, 0x1c, 0x00, 0x3c, 0x00, 0x78, 0x00, 0xf0, 
     0x01, 0xe0, 0x03, 0xc0, 0x03, 0x80, 0x03, 0x80, 
     0x00, 0x00, 0x03, 0x80, 0x03, 0x80, 0x00, 0x00, }
};
@
% ???

\subsection{Border and corner cursors}

<<global corners (windows/rio/data.c)>>=
Cursor *corners[9] = {
    &tl,    &t,   &tr,
    &l,    nil,   &r,
    &bl,    &b,   &br,
};
@
% top/below, left/right

<<global [[tl]]>>=
Cursor tl = {
    {-4, -4},
    {0xfe, 0x00, 0x82, 0x00, 0x8c, 0x00, 0x87, 0xff, 
     0xa0, 0x01, 0xb0, 0x01, 0xd0, 0x01, 0x11, 0xff, 
     0x11, 0x00, 0x11, 0x00, 0x11, 0x00, 0x11, 0x00, 
     0x11, 0x00, 0x11, 0x00, 0x11, 0x00, 0x1f, 0x00, },
    {0x00, 0x00, 0x7c, 0x00, 0x70, 0x00, 0x78, 0x00, 
     0x5f, 0xfe, 0x4f, 0xfe, 0x0f, 0xfe, 0x0e, 0x00, 
     0x0e, 0x00, 0x0e, 0x00, 0x0e, 0x00, 0x0e, 0x00, 
     0x0e, 0x00, 0x0e, 0x00, 0x0e, 0x00, 0x00, 0x00, }
};
@

<<global [[t]]>>=
static Cursor t = {
    {-7, -8},
    {0x00, 0x00, 0x00, 0x00, 0x03, 0x80, 0x06, 0xc0, 
     0x1c, 0x70, 0x10, 0x10, 0x0c, 0x60, 0xfc, 0x7f, 
     0x80, 0x01, 0x80, 0x01, 0x80, 0x01, 0xff, 0xff, 
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, },
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 
     0x03, 0x80, 0x0f, 0xe0, 0x03, 0x80, 0x03, 0x80, 
     0x7f, 0xfe, 0x7f, 0xfe, 0x7f, 0xfe, 0x00, 0x00, 
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, }
};
@

<<global [[tr]]>>=
Cursor tr = {
    {-11, -4},
    {0x00, 0x7f, 0x00, 0x41, 0x00, 0x31, 0xff, 0xe1, 
     0x80, 0x05, 0x80, 0x0d, 0x80, 0x0b, 0xff, 0x88, 
     0x00, 0x88, 0x0, 0x88, 0x00, 0x88, 0x00, 0x88, 
     0x00, 0x88, 0x00, 0x88, 0x00, 0x88, 0x00, 0xf8, },
    {0x00, 0x00, 0x00, 0x3e, 0x00, 0x0e, 0x00, 0x1e, 
     0x7f, 0xfa, 0x7f, 0xf2, 0x7f, 0xf0, 0x00, 0x70, 
     0x00, 0x70, 0x00, 0x70, 0x00, 0x70, 0x00, 0x70, 
     0x00, 0x70, 0x00, 0x70, 0x00, 0x70, 0x00, 0x00, }
};
@

<<global [[r]]>>=
Cursor r = {
    {-8, -7},
    {0x07, 0xc0, 0x04, 0x40, 0x04, 0x40, 0x04, 0x58, 
     0x04, 0x68, 0x04, 0x6c, 0x04, 0x06, 0x04, 0x02, 
     0x04, 0x06, 0x04, 0x6c, 0x04, 0x68, 0x04, 0x58, 
     0x04, 0x40, 0x04, 0x40, 0x04, 0x40, 0x07, 0xc0, },
    {0x00, 0x00, 0x03, 0x80, 0x03, 0x80, 0x03, 0x80, 
     0x03, 0x90, 0x03, 0x90, 0x03, 0xf8, 0x03, 0xfc, 
     0x03, 0xf8, 0x03, 0x90, 0x03, 0x90, 0x03, 0x80, 
     0x03, 0x80, 0x03, 0x80, 0x03, 0x80, 0x00, 0x00, }
};
@

<<global [[br]]>>=
Cursor br = {
    {-11, -11},
    {0x00, 0xf8, 0x00, 0x88, 0x00, 0x88, 0x00, 0x88, 
     0x00, 0x88, 0x00, 0x88, 0x00, 0x88, 0x00, 0x88, 
     0xff, 0x88, 0x80, 0x0b, 0x80, 0x0d, 0x80, 0x05, 
     0xff, 0xe1, 0x00, 0x31, 0x00, 0x41, 0x00, 0x7f, },
    {0x00, 0x00, 0x00, 0x70, 0x00, 0x70, 0x00, 0x70, 
     0x0, 0x70, 0x00, 0x70, 0x00, 0x70, 0x00, 0x70, 
     0x00, 0x70, 0x7f, 0xf0, 0x7f, 0xf2, 0x7f, 0xfa, 
     0x00, 0x1e, 0x00, 0x0e, 0x00, 0x3e, 0x00, 0x00, }
};
@

<<global [[b]]>>=
Cursor b = {
    {-7, -7},
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
     0xff, 0xff, 0x80, 0x01, 0x80, 0x01, 0x80, 0x01, 
     0xfc, 0x7f, 0x0c, 0x60, 0x10, 0x10, 0x1c, 0x70, 
     0x06, 0xc0, 0x03, 0x80, 0x00, 0x00, 0x00, 0x00, },
    {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
     0x00, 0x00, 0x7f, 0xfe, 0x7f, 0xfe, 0x7f, 0xfe, 
     0x03, 0x80, 0x03, 0x80, 0x0f, 0xe0, 0x03, 0x80, 
     0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, }
};
@

<<global [[bl]]>>=
Cursor bl = {
    {-4, -11},
    {0x1f, 0x00, 0x11, 0x00, 0x11, 0x00, 0x11, 0x00, 
     0x11, 0x00, 0x11, 0x00, 0x11, 0x00, 0x11, 0x00, 
     0x11, 0xff, 0xd0, 0x01, 0xb0, 0x01, 0xa0, 0x01, 
     0x87, 0xff, 0x8c, 0x00, 0x82, 0x00, 0xfe, 0x00, },
    {0x00, 0x00, 0x0e, 0x00, 0x0e, 0x00, 0x0e, 0x00, 
     0x0e, 0x00, 0x0e, 0x00, 0x0e, 0x00, 0x0e, 0x00, 
     0x0e, 0x00, 0x0f, 0xfe, 0x4f, 0xfe, 0x5f, 0xfe, 
     0x78, 0x00, 0x70, 0x00, 0x7c, 0x00, 0x00, 0x0, }
};
@

<<global [[l]]>>=
Cursor l = {
    {-7, -7},
    {0x03, 0xe0, 0x02, 0x20, 0x02, 0x20, 0x1a, 0x20, 
     0x16, 0x20, 0x36, 0x20, 0x60, 0x20, 0x40, 0x20, 
     0x60, 0x20, 0x36, 0x20, 0x16, 0x20, 0x1a, 0x20, 
     0x02, 0x20, 0x02, 0x20, 0x02, 0x20, 0x03, 0xe0, },
    {0x00, 0x00, 0x01, 0xc0, 0x01, 0xc0, 0x01, 0xc0, 
     0x09, 0xc0, 0x09, 0xc0, 0x1f, 0xc0, 0x3f, 0xc0, 
     0x1f, 0xc0, 0x09, 0xc0, 0x09, 0xc0, 0x01, 0xc0, 
     0x01, 0xc0, 0x01, 0xc0, 0x01, 0xc0, 0x00, 0x00, }
};
@


\section{Setting the cursor}

% rio cursor, window management, vs app cursor!

\subsection{[[riosetcursor()]]}

<<global [[lastcursor]]>>=
Cursor	*lastcursor;
@
%ocaml: not sure we need this opti

<<function [[riosetcursor]]>>=
void
riosetcursor(Cursor *p, bool force)
{
    if(!force && p==lastcursor)
        return;
    setcursor(mousectl, p);
    lastcursor = p;
}
@
%ocaml: no mousectl global
%ocaml: no opti so can simply call Mouse.set_cursor without this wrapper

% setcursor() from mouse.h, will write in /dev/cursor

% what this force is all about? why sometimes need and sometimes not?
% seems like an opti.
\l when need to force? when does not need to force and can leverage opti?


\subsection{[[cornercursor()]]}

% mousethread -> <>
<<function [[cornercursor]]>>=
void
cornercursor(Window *w, Point p, bool force)
{
    if(w != nil && winborder(w, p))
        riosetcursor(corners[whichcorner(w, p)], force);
    else
        wsetcursor(w, force);
}
@
%ocaml: by construction w is not nil
%ocaml: should have separate corner_cursor and corner_cursor_or_window_cursor
% so no need menuing global

% actually put cornercursor only if on the corner


<<function [[winborder]]>>=
bool
winborder(Window *w, Point xy)
{
    return ptinrect(xy, w->screenr) && 
           !ptinrect(xy, insetrect(w->screenr, Selborder));
}
@
%ocaml: pt_on_frame, and put it with pt_inside_frame

% cornercursor -> <>
<<function [[whichcorner]]>>=
int
whichcorner(Window *w, Point p)
{
    int i, j;
    
    i = portion(p.x, w->screenr.min.x, w->screenr.max.x);
    j = portion(p.y, w->screenr.min.y, w->screenr.max.y);
    return 3*j + i;
}
@
% j = 0 means top, j = 1 means middle, j = 2 means below

% whichcorner -> <>
<<function [[portion]]>>=
int
portion(int x, int lo, int hi)
{
    x -= lo;
    hi -= lo;

    if(x < 20)
        return 0; // top
    if(x > hi-20)
        return 2; // below
    return 1; // middle
}
@
%ocaml: type

\subsection{[[wsetcursor()]]}

<<[[Window]] mouse fields>>=
Cursor		cursor;
// option<ref<Cursor>> (to Window.cursor when not None)
Cursor		*cursorp;
@
%ocaml: just one field, that can be an option

% each window can write on his own /dev/cursor
% so when mouse over different windows, need to
% load the appropriate cursor

% will see later how a window can change its cursor (via
%  virtual /dev/cursor handler)

<<function [[wsetcursor]]>>=
void
wsetcursor(Window *w, bool force)
{
    Cursor *p;

    if(w==nil || w->i==nil || Dx(w->screenr)<=0)
        p = nil;
    else if(wpointto(mouse->xy) == w){
        p = w->cursorp;
        <<[[wsetcursor()]] if holding>>
    }else
        p = nil;

    if(!menuing)
        riosetcursor(p, force);
}
@
%old: /*w!=input || */ 
%old:
%    if(!menuing)
%        riosetcursor(p, force && !menuing);
%  but !menuing obviously redundant and true
%ocaml: can not have w == nil and img nil?
\l how can have negative screen? or no img? or no w?

% menuing means that are in the middle of a system action 
% (sweep, move, reshape) in which case do not honor window cursor.
\t but when in middle of system action, the mouse thread is suspended
\t  anyway so how wsetcursor can be called??







\chapter{Window Manager}
\label{chap:wm}


\section{Overview}

% In plan9, the window manager is the same program than the window server.
%alt: separate program as in X11

% Window management operations can be trigged in different ways:
% - right click menu (rio/system menu), can create new window
% - mouse operations on border of window
% - dev/wctl
% - filsys, listening pipe, mount can create new window
% - /srv/riowctl.user.pid

% They all trigger then messages send to the appropriate window thread 
% via wsendctlmsg(w->cctl).

\section{Right-click system menu}

% so most of this chapter is from mousethread() context!
% but will at some point send some Wctlmesg to the window thread
% which will do the modifications.

<<[[mousethread()]] right click under certain conditions>>=
button3menu();
@

% See Graphics book advanced topics and menuhit function!

% mousethread -> event loop -> <>
<<function [[button3menu]]>>=
void
button3menu(void)
{
    int i;

    <<[[button3menu()]] menu3str adjustments with hidden windows>>

    sweeping = true;
    switch(i = menuhit(3, mousectl, &menu3, desktop)){
    <<[[button3menu()]] cases>>
    case -1:
        break;
    }
    sweeping = false;
}
@
%ocaml: Mouse.Right clearer than 3
%old:
%        if(Hidden > Exit){
%        }
%        /* else fall through */
% tricks when Exit was an optional menu item disabled sometimes
% but I made it always apparent now.
\l should not be menuing here instead of sweeping? why need that?
%  because app can write on its /dev/mouse to move cursor but would
%  be weird in middle of menu action to get the cursor moved

% displaying a menu with menuhit is drawing something! on top of what you
% are currently! it's part of the drawing library! See Graphics.nw.
% The menu is simply an overlapping window.

% 3 means 3rd button.

% mousectl->Mouse.xy will contain location to put the menu

% Need cooperative threads? Otherwise can have concurrent access to mousectl.fd?
% No, cos still in mouse_thread context, and readmouse() called from menuhit()
% will read from the same channel in mousectl.c, not directly from fd.

<<global [[sweeping]]>>=
bool	sweeping;
@
% used to forbid some operations like write on /dev/mouse from app
% to move the mouse, because sweeping means we are in the middle of
% some actions from the user where the mouse should not move around
\l should be menuing? to not confuse with sweep()



<<global [[menu3]]>>=
Menu menu3 = { .item = menu3str };
@
% see Graphics.nw, this define only the first field.
%pad: I qualified this field.

<<global [[menu3str]]>>=
char*		menu3str[100] = {
 [New]		"New",
 [Reshape]	"Resize",
 [Move]		"Move",
 [Delete]	"Delete",
 [Hide]		"Hide",
 [Exit]		"Exit",
 nil
};
@
%ocaml: no intermediate enums, just pass a list of strings and closures
%old: was in main()
%  // pad:let's keep the Exit option!
%  if(strstr(argv[0], ".out") == nil){
%  	menu3str[Exit] = nil;
%  	Hidden--;
%  }


<<enum [[_anon_ (windows/rio/rio.c)]]>>=
enum RightMenuCommand
{
    New,

    Reshape,
    Move,
    Delete,
    Hide,

    Exit,

    Hidden,
};
@
%ocaml: no intermediate enums, just pass a list of strings and closures
%pad: I introduced Hidden
%old: used to be a global
% <<global Hidden>> =
% int	Hidden = Exit+1;
% @

% Hidden is for the start of the hidden windows.
% When a window is hidden it's accessible in the right menu! 
% hence the 100 below
% see Section X later.

% RightMenuCommands is similar to Wctlmesg but it's not the same.




<<[[button3menu()]] cases>>=
case Exit:
    send(exitchan, nil);
    break;
@
% threadmain is listening on exitchan

%toc:
% we will see handlers for other actions later.


\section{Window borders click}

<<[[mousethread()]] locals>>=
bool moving = false;
@
% ???
\t how?

% when set moving to true?? when on window border!
<<[[mousethread()]] set moving to true for some conditions>>=
/* topped will be zero or less if window has been bottomed */
if(!sending && !scrolling 
   && winborder(winput, mouse->xy) && winput->topped > 0){
    moving = true;
}
@
%old: sending == false


<<[[mousethread()]] locals>>=
bool inside, band;
Window *oin;
Image *i;
Rectangle r;
@

<<[[mousethread()]] if moving and buttons>>=
if(moving && (mouse->buttons&7)){
    oin = winput;
    band = mouse->buttons & 3; // left or middle click

    sweeping = true;
    if(band)
        i = bandsize(winput);
    else
        i = drag(winput, &r);
    sweeping = false;

    if(i != nil){
        if(winput == oin){
            if(band)
                wsendctlmesg(winput, Reshaped, i->r, i);
            else
                wsendctlmesg(winput, Moved, r, i);
            cornercursor(winput, mouse->xy, true);
        }else
            freeimage(i);
    }
}
@
% when winput can change in middle of operation?
%  thread arrives which changed focused window?

% bandsize and drag later




\section{[[Wctlmesg]]}

<<enum [[wctlmesgkind]]>>=
enum ControlMessage	/* control messages */
{
    Reshaped, // Resized, Hide/Expose
    Moved,
    <<[[Wctlmesgkind]] cases>>
};
@
%ocaml: ADT so Reshaped of Image.t

% different than previous enum for the menu, here it's a message!
% there is a 'd' at the end, Move -> Moved

% wrefresh vs wrepaint?





<<struct [[Wctlmesg]]>>=
struct Wctlmesg
{
    // enum<Wctlmesgkind>
    int		type;

    Rectangle	r;
    Image	*image;
};
@
%ocaml: ADT so image and r only for appropriate enum
% (for instance Reshaped just need an Image, no need for rectangle)

% r? image? because some action involve a rectangle and image 
% like when sweep which defines an area
% (actually why need rectangle, image not enough?)

<<function [[wsendctlmesg]]>>=
void
wsendctlmesg(Window *w, int type, Rectangle r, Image *image)
{
    Wctlmesg wcm;

    wcm.type = type;
    wcm.r = r;
    wcm.image = image;

    send(w->cctl, &wcm);
}
@
%ocaml: ADT so build directly, no need intermediate function

% from winctl event loop! to process on the window thread side a  Wctlmesg
% winctl -> <>
<<function [[wctlmesg]]>>=
int
wctlmesg(Window *w, int m, Rectangle r, Image *i)
{
    char buf[64];

    switch(m){
    <<[[wctlmesg()]] cases>>
    default:
        error("unknown control message");
        break;
    }
    return m;
}
@
\l rename m to type, more consistent
%ocaml: again because of ADT dont need extra arguments, and no
% need default case (exhaustive check)

\l what is the point of returning m if same than parameter?
\l  because the switch can change it?








\section{Window creation}
% via menu

% most important operation. Link with draw.
% Link with external process.
% Start from the mouse!

<<[[button3menu()]] cases>>=
case New:
    new(sweep(), false, scrolling, 0, nil, "/bin/rc", nil);
    break;
@
% 0 is pid, first nil is dir and last nil is argv

% sweep will let user specify a window geometry
% and  allocate a window!

% There are other way to create new window, but will see later.
% this one is simplest.

\subsection{Window thread creation: [[new()]]}

% if pid == 0 then means create a new terminal process
% otherwise, process already there, just need create window.
% who call new with pid != 0? when external process such as a shell
% want to access rio (via mount /srv/rio.user.pid ...) see chapter X

%ctor!
% ((right click -> button3menu()) | wctlnew()) -> <>
<<function [[new]]>>=
Window*
new(Image *i, bool hideit, bool scrollit, int pid, char *dir, char *cmd, char **argv)
{
    Channel *cm, *ck, *cctl;
    Channel *cpid;
    Mousectl *mc;
    Window *w;
    <<[[new()]] other locals>>

    <<[[new()]] sanity check i>>

    <<[[new()]] channels creation>>
    cpid = chancreate(sizeof(int), 0);
    <<[[new()]] sanity check channels>>

    <<[[new()]] mc allocation>>

    // create Window data structure
    w = wmk(i, mc, ck, cctl, scrollit);
    free(mc);	/* wmk copies *mc */

    // growing array
    windows = erealloc(windows, ++nwindow * sizeof(Window*));
    windows[nwindow-1] = w;
    <<[[new()]] if hideit>>

    // create a new thread! for this new window!
    threadcreate(winctl, w, 8192);

    if(!hideit)
        wcurrent(w);

    flushimage(display, true);

    // create a new process
    <<[[new()]] if pid == 0, create winshell process and set pid>>
    <<[[new()]] sanity check pid received from winshell>>
    wsetpid(w, pid, true);

    // create a new layer
    wsetname(w);

    if(dir)
        w->dir = estrdup(dir);

    chanfree(cpid);
    return w;
}
@
%ocaml: hashtbl instead of growing array
%ocaml: do channel creation in wmk instead of split creation of things
% in 2 places
\l why return it? not used in caller anyway
\l not too late to wsetname? can not have situation that child
\l  execute too fast its mount?

% always growing windows? never reuse when a window is closed?

% cpid allow communicate pid of child process back to parent
% and so winctl thread.
%alt: need use channel? cant just get fork return integer value
% simply? because use proccreate(winshell, because dont want to
% block on fork? but fork is fast no? not like blocking IO.
% Also why not use return value from proccreate? it should return
% the pid of winshell (which will then just procexec the shell)



% seen those channels properties before
<<[[new()]] channels creation>>=
cm = chancreate(sizeof(Mouse), 0);
ck = chancreate(sizeof(Rune*), 0);
cctl = chancreate(sizeof(Wctlmesg), 4);
@
% passed to wmk and set in Window fields.
% could do that in wmk instead. not sure why it needs to be in new().
%ocaml: I do that in wmk


<<[[new()]] mc allocation>>=
mc = emalloc(sizeof(Mousectl));
*mc = *mousectl;
mc->image = i;
mc->c = cm;
@
% local image, local channel
\t why copy mousectl? not enough to just get the channel?

\l mc->image? but really they look for the display.



<<[[new()]] sanity check i>>=
if(i == nil)
    return nil;
@
<<[[new()]] sanity check channels>>=
if(cm==nil || ck==nil || cctl==nil)
    error("new: channel alloc failed");
@
%ocaml: exn, or can not happen by construction (for i)

\subsection{[[Window]] allocation: [[wmk()]]}

% active object, monitor

%ctor 
<<function [[wmk]]>>=
Window*
wmk(Image *i, Mousectl *mc, Channel *ck, Channel *cctl, bool scrolling)
{
    Window *w;
    Rectangle r;

    <<[[wmk()]] colors initialisation>>

    w = emalloc(sizeof(Window));

    w->i = i;
    w->screenr = i->r;
    w->cursorp = nil;

    w->id = ++id;
    w->topped = ++topped;

    w->label = estrdup("<unnamed>");

    <<[[wmk()]] channels settings>>
    <<[[wmk()]] textual window settings>>
    <<[[wmk()]] process settings>>

    <<[[wmk()]] drawing border>>
    <<[[wmk()]] drawing scrollbar>>

    incref(w);	/* ref will be removed after mounting; avoids delete before ready to be deleted */
    return w;
}
@
%old: I changed the order of some initialisations, to group textual window
% stuff together




% about incref comment, see call to wclose in winshell after filsysmount
\l subtle

<<[[wmk()]] channels settings>>=
w->mc = *mc;
w->ck = ck;
w->cctl = cctl;
@
%ocaml: build the channel in wmk, so no need pass them around from new()


%\subsection{Window border}

<<[[wmk()]] drawing border>>=
wborder(w, Selborder);
@
\l why wborder here? will do it again in caller in wcurrent
\l  because can hideit but still want the drawing done on the off-screen img?

<<function [[wborder]]>>=
void
wborder(Window *w, int type)
{
    Image *col;

    <<[[wborder()]] sanity check w>>
    <<[[wborder()]] if holding>>
    else{
        if(type == Selborder)
            col = titlecol;
        else
            col = lighttitlecol;
    }

    border(w->i, w->i->r, Selborder, col, ZP);
}
@
%ocaml: proper enum type for type instead of abusing Selborder
\l rename draw_border?

% will see col later

<<global [[titlecol]]>>=
static	Image	*titlecol;
@
<<global [[lighttitlecol]]>>=
static	Image	*lighttitlecol;
@
% set in wmk
%ocaml: set in main too, like red and background

<<[[wmk()]] extra colors initialisation>>=
titlecol     = allocimage(display, Rect(0,0,1,1), CMAP8, true, DGreygreen);
lighttitlecol= allocimage(display, Rect(0,0,1,1), CMAP8, true, DPalegreygreen);
@


<<[[wborder()]] sanity check w>>=
if(w->i == nil)
    return;
@
\l just return? no exn? because when hide a window there is no img?



<<[[wmk()]] process settings>>=
w->notefd = -1;
w->dir = estrdup(startdir);
@

<<[[Window]] other fields>>=
char		*dir; // /dev/wdir
@
% window working dir



<<global [[startdir]]>>=
char		*startdir;
@
<<[[main()]] locals>>=
char buf[256];
@
%old dead? static void *arg[1];
<<[[main()]] set some globals>>=
if(getwd(buf, sizeof buf) == nil)
    startdir = estrdup(".");
else
    startdir = estrdup(buf);
@
%ocaml: call getwd each time, useless opti cache in global startdir

% reset optionally by new() parameter


\subsection{Window process creation: [[winshell()]]}


<<global [[rcargv]]>>=
char *rcargv[] = { "rc", "-i", nil };
@

<<[[new()]] other locals>>=
void **arg;
@

%when new from the system menu
<<[[new()]] if pid == 0, create winshell process and set pid>>=
if(pid == 0){
    arg = emalloc(5 * sizeof(void*));
    arg[0] = w;
    arg[1] = cpid;
    arg[2] = cmd;
    if(argv == nil)
        arg[3] = rcargv;
    else
        arg[3] = argv;
    arg[4] = dir;

    proccreate(winshell, arg, 8192);

    pid = recvul(cpid);
    free(arg);
}
@
%ocaml: build directly good argv, why special case rc for argv here and not
% for cmd?

% pass w so can communicate back with its winctl thread handler

\t why use intermediate winshell and cpid? why not simply fork
\t  here so no need also arg[] as can access this information directly.
\t why proccreate/procexec intermediates?
\t because of code below? to better handle possible errors in child?

% wait for pid. pid will be passed to wsetpid, so know
% which process we are connected to, and which one to kill if delete
% window

% independent process, this is where gonna exec stuff! but before
% set right namespace.



<<[[new()]] sanity check pid received from winshell>>=
if(pid == 0){
    /* window creation failed */
    wsendctlmesg(w, Deleted, ZR, nil);
    chanfree(cpid);
    return nil;
}
@
% this is why you use a cpid! because things can go wrong?


% have already half of it, new, wmk, winctl thread creation,
% and a few channels. Now need a fake /dev/cons, /dev/mouse, etc

% new(..., pid = 0, ...) -> proccreate(<>)
% by default new windows are in "textual mode"
% the cmd is often "rc -i" (rc -i explicit interactive mode because
%   rc expect #c/cons or /mnt/term/dev/cons)
<<function [[winshell]]>>=
void
winshell(void *args)
{
    Window *w;
    Channel *pidc;
    void **arg;
    char *cmd, *dir;
    char **argv;
    errorneg1 err;

    arg = args;

    w    = arg[0];
    pidc = arg[1];
    cmd  = arg[2];
    argv = arg[3];
    dir  = arg[4];

    // copy namespace/file-descriptors/environment-variables (do not share)
    rfork(RFNAMEG|RFFDG|RFENVG);

    <<[[winshell()]] adjust namespace>>
    <<[[winshell()]] reassign STDIN/STDOUT after namespace adjustment>>

    if(wclose(w) == false){	/* remove extra ref hanging from creation */
        notify(nil);
        dup(STDOUT, STDERR); // STDERR = STDOUT
        if(dir)
            chdir(dir);

        // Exec!!
        procexec(pidc, cmd, argv);
        _exits("exec failed"); // should never be reached
    }
}
@
% remove extra ref, see comment in wmk

% procexec take a channel to write pid there that the parent
% is waiting for.

% Will do also the close on exec (OCEXEC) set up earlier.

%ocaml-found:
% redirect stderr! important too because rc for example print its prompt
%  on stderr (see Shell.nw)



<<[[Window]] process fields>>=
int		pid;
@

<<[[Window]] process fields>>=
// /proc/<pid>/notepg
fdt	 	notefd;
@
% can communicate with process though signals!

% new -> <>
<<function [[wsetpid]]>>=
void
wsetpid(Window *w, int pid, bool dolabel)
{
    char buf[128];
    fdt fd;

    w->pid = pid;

    if(dolabel){
        sprint(buf, "rc %d", pid);
        free(w->label);
        w->label = estrdup(buf);
    }

    sprint(buf, "/proc/%d/notepg", pid);
    fd = open(buf, OWRITE|OCEXEC);
    if(w->notefd > 0)
        close(w->notefd);
    w->notefd = fd;
}
@
% how can have already a notefd?

\subsection{Namespace adjustments: [[filsysmount()]]}

<<[[winshell()]] adjust namespace>>=
err = filsysmount(filsys, w->id);
<<[[winshell()]] sanity check err filsysmount>>
@
%pad: I added err to aspectize sanity checking

% use of filsys here! which is why we need it to be a global!

% fork -> winshell (as x <- proccreate(<>) <- new <- mousethread)  -> <>
<<function [[filsysmount]]>>=
/*
 * Called only from a different FD group
 */
errorneg1
filsysmount(Filsys *fs, int id)
{
    char buf[32];
    errorneg1 err;

    close(fs->sfd);	/* close server end so mount won't hang if exiting */
    sprint(buf, "%d", id);
    err = mount(fs->cfd, -1, "/mnt/wsys", MREPL, buf);
    <<[[filsysmount()]] sanity check err mount>>
    err = bind("/mnt/wsys", "/dev", MBEFORE);
    <<[[filsysmount()]] sanity check err bind>>
    return OK_0;
}
@
% pass window id to mount, for /mnt/wsys/x/ and to know
%  later which window to send request to probably.
%pad: I added err


<<[[winshell()]] reassign STDIN/STDOUT after namespace adjustment>>=
// reassign stdin/stdout to virtualized /dev/cons from filsysmount
close(STDIN);
err = open("/dev/cons", OREAD);
<<[[winshell()]] sanity check err open cons stdin>>
close(STDOUT);
err = open("/dev/cons", OWRITE);
<<[[winshell()]] sanity check err open cons stdout>>
@
% important!!

% STDERR is done later by dupping STDOUT


<<[[winshell()]] sanity check err open cons stdin>>=
if(err < 0){
    fprint(STDERR, "can't open /dev/cons: %r\n");
    sendul(pidc, 0);
    threadexits("/dev/cons");
}
@
% so parent can know if something went wrong via pidc!

<<[[winshell()]] sanity check err open cons stdout>>=
if(err < 0){
    fprint(STDERR, "can't open /dev/cons: %r\n");
    sendul(pidc, 0);
    threadexits("open");	/* BUG? was terminate() */
}
@

<<[[winshell()]] sanity check err filsysmount>>=
if(err < 0){
    fprint(STDERR, "mount failed: %r\n");
    sendul(pidc, 0);
    threadexits("mount failed");
}
@



<<[[filsysmount()]] sanity check err mount>>=
if(err < 0){
    fprint(STDERR, "mount failed: %r\n");
    return ERROR_NEG1;
}
@
<<[[filsysmount()]] sanity check err bind>>=
if(err < 0){
    fprint(STDERR, "bind failed: %r\n");
    return ERROR_NEG1;
}
@
%ocaml: exn

\subsection{Public layer: [[wsetname()]]}

%trans: adjusted namespace for client process to see
% virtualized /dev/cons, /dev/mouse.
% Miss /dev/draw. But actually use different mechanism.
% Not virtualized. Would be too slow to have intermediate.

%trans:
% so /dev/winname will be good because adjusted namespace
% but need to make image public! % so client can find it.
%alt: could pass info via putenv? but anyway have already
% a mechanism /dev/xxx so why not use it.

<<[[Window]] id fields>>=
uint		namecount;
@
% counter, per window

% When resize a window, we need to create a new image and client
% need to grab back again this image. Do we change the name
% of this image? or the previous freeimage on the public image
% also free its public name? Graphics.nw?

% new -> <>
<<function [[wsetname]]>>=
void
wsetname(Window *w)
{
    int i, n;
    char err[ERRMAX];
    
    n = sprint(w->name, "window.%d.%d", w->id, w->namecount++);

    if(nameimage(w->i, w->name, true) > 0)
        return;
    // else
    <<[[wsetname()]] if image name already in use, try another name>>
}
@
%pad: I copy pasted and duplicated the code which call nameimage,
% but then can aspectize better the special error case

% thx to that, geninitdraw will work!


<<[[wsetname()]] if image name already in use, try another name>>=
for(i='A'; i<='Z'; i++){
    // ok try again
    if(nameimage(w->i, w->name, true) > 0)
        return;
    // else, retry

    errstr(err, sizeof err);
    if(strcmp(err, "image name in use") != 0)
        break;
    w->name[n] = i;
    w->name[n+1] = '\0';
}
// else
w->name[0] = '\0';
fprint(STDERR, "rio: setname failed: %s\n", err);
@


\subsection{Mouse action [[sweep()]]}
% and layer creation

<<global [[menuing]]>>=
bool menuing;/* menu action is pending; waiting for window to be indicated */
@
% should be called sweeping no? but there is already a sweeping global
\t why need this global? who needs this information? another thread?
\t  used in wsetcursor <- cornercursor to not honor window cursor

% button3menu() | wctlnew() -> new() -> wmk () -> <>
% ex:  new(sweep(), false, scrolling, 0, nil, "/bin/rc", nil);
<<function [[sweep]]>>=
Image*
sweep(void)
{
    Point p0, p;
    Rectangle r;
    Image *i, *oi;

    i = nil;

    menuing = true;
    riosetcursor(&crosscursor, true);
    while(mouse->buttons == 0)
        readmouse(mousectl);

    p0 = onscreen(mouse->xy);
    p = p0;
    r = Rpt(p0, p);
    oi = nil;

    while(mouse->buttons == 4){ // right click
        readmouse(mousectl);

        if(mouse->buttons != 4 && mouse->buttons != 0)
            break;
        if(!eqpt(mouse->xy, p)){
            p = onscreen(mouse->xy);
            r = canonrect(Rpt(p0, p));

            if(Dx(r)>5 && Dy(r)>5){
                i = allocwindow(desktop, r, Refnone, 0xEEEEEEFF); /* grey */
                freeimage(oi);
                <<[[sweep()]] sanity check i>>
                oi = i;
                border(i, r, Selborder, red, ZP);
                flushimage(display, true);
            }
        }
    }
    <<[[sweep()]] sanity check mouse buttons, i, and rectangle size>>
    oi = i;
    i = allocwindow(desktop, oi->r, Refbackup, DWhite);
    freeimage(oi);
    <<[[sweep()]] sanity check i>>
    border(i, r, Selborder, red, ZP);
    cornercursor(input, mouse->xy, true);
    goto Return;
<<[[sweep()]] Rescue handler>>

 Return:
    moveto(mousectl, mouse->xy);	/* force cursor update; ugly */
    menuing = false;
    return i;
}
@
%old: I use Rpt now, before was:
%    r.min = p0;
%    r.max = p0;
%ocaml: use enum instead of hardcoded integers for mouse buttons
%ocaml: use state machine with ADT for state so easier to read?
% the C code in the end has a complex flow. More explicit corner
% cases like what when not click right directly.

\l why need ugly stuff? cornercursor with force at true not enough?
\l and why need menuing? to not wsetcursor? but anyway for sure we 
\l  are on a border

% note that Refnone first, then Refbackup.
\l why? opti?

% should flushimage here before returning instead of doing it in
% the caller.

% readmouse(mousectl), but does not conflict with mousethread??
% or thread/channel lib gives priority to last one waiting on channel?
% but then as soon as received, how ensure mousethread will not recv?
% because scheduler does not preempt threads? (or timerinit does?)


<<function [[onscreen]]>>=
Point
onscreen(Point p)
{
    p.x = max(view->clipr.min.x, p.x);
    p.x = min(view->clipr.max.x, p.x);
    p.y = max(view->clipr.min.y, p.y);
    p.y = min(view->clipr.max.y, p.y);
    return p;
}
@
\l why need that? who uses clipr?


<<[[sweep()]] sanity check i>>=
if(i == nil)
    goto Rescue;
@
%ocaml: exn

<<[[sweep()]] sanity check mouse buttons, i, and rectangle size>>=
if(mouse->buttons != 0)
    goto Rescue;
if(i==nil || Dx(i->r) < 100 || Dy(i->r) < 3*font->height)
    goto Rescue;
@
%ocaml: can come here from different situations and ocaml code clearer for that


<<[[sweep()]] Rescue handler>>=
Rescue:
    freeimage(i);
    i = nil;
    cornercursor(input, mouse->xy, true);
    while(mouse->buttons)
        readmouse(mousectl);
@
\l how can you arrive here while still button? in fact can arrive
\l here either from button or not. See the goto rescue above.
%ocaml: ugly that freeimage accept nil for image






\section{Window focus}
% via mouse

% put code of mousethread related to window focus here!!

<<[[mousethread()]] click on unfocused window, set w>>=
w = wtop(mouse->xy);
@
%ocaml: pass directly 

% w is used to check whether something was topped then
% and whether some special click happened in which case
% we may need to send the event to the app.


% mousethread -> <>
<<function [[wtop]]>>=
Window*
wtop(Point pt)
{
    Window *w;

    w = wpointto(pt);
    if(w){
        if(w->topped == topped)
            return nil;
        topwindow(w->i); // window.h (was in draw.h)
        wcurrent(w);
        flushimage(display, true);
        w->topped = ++topped;
    }
    return w;
}
@
%ocaml: pass w directly because do the wpointto() job in the caller already,
% so also no need to sanity check w

% saw wpointto before, for mousethread to identify windows under cursor

% topwindow not enough? no because border is actually drawn
% by window manager


% new | wtop | ... -> <>
<<function [[wcurrent]]>>=
void
wcurrent(Window *w)
{
    Window *oi;

    <<[[wcurrent()]] if wkeyboard>>
    oi = input;
    // updated input!
    input = w;

    if(oi && oi != w)
        wrepaint(oi);
    if(w){
        wrepaint(w);
        wsetcursor(w, false);
    }
    <<[[wcurrent()]] wakeup w and oi>>
}
@
\l why false to wsetcursor? because maybe w == oi in which case
\l  no need to force a rewrite of the cursor. Last cursor was maybe ok.

% wcurrent | ... -> <>
<<function [[wrepaint]]>>=
void
wrepaint(Window *w)
{

    <<[[wrepaint()]] update cols>>
    <<[[wrepaint()]] after updated cols, redraw content if mouse not opened>>

    if(w == input){
        wborder(w, Selborder);
        wsetcursor(w, false);
    }else
        wborder(w, Unselborder);
}
@
% if ! mouseopen then have a frame with scrollbar, so redraw it
\l again setcursor? but done already in caller
\l a bit of duplication with wcurrent, redo similar work with
\l  check for w == input

% rename wrepaintborders? no, because will also repaint the scrollbar
% and all text in terminal with other color sometimes!


<<constant [[Unselborder]]>>=
Unselborder		= 1,	/* border of unselected window */
@
%ocaml: proper enum, not abusing 1 and 4

% this is where see difference of color between selected and unselected



\section{Window deletion}
% via menu

% 2 steps, Deleted, and then Exited

<<[[button3menu()]] cases>>=
case Delete:
    delete();
    break;
@

\subsection{[[delete()]]}

<<function [[delete]]>>=
void
delete(void)
{
    Window *w;

    w = pointto(true);
    if(w)
        wsendctlmesg(w, Deleted, ZR, nil);
}
@
%ocaml: no need wrapper wsendctlmesg, build directly Cmd

% pointto != wpointto, = mouse action we will see soon


<<[[Wctlmesgkind]] cases>>=
Deleted,
@


<<[[Window]] config fields>>=
bool	deleted;
@
%old: bool_byte
\t needed because can still have pending request on window namespace?
\t  so at least in the fileserver we can give a better response when
\t  an operation on a deleted window is requested?

% why delete complex? because attached process, because attached img!
% need to wait for external process, but can not wait too much
% hence timeout below.



<<[[wctlmesg()]] cases>>=
case Deleted:
    <<[[wctlmesg()]] break if window was deleted>>
    write(w->notefd, "hangup", 6);
    proccreate(deletetimeoutproc, estrdup(w->name), 4096);
    wclosewin(w);
    break;
@
% want to block for action as little as possible, a bit like in kernel
%  where want to do the minimum in an interrupt, hence
%  the use of an auxilary process to take care of waiting for the
%  hangup process and clean resources


<<[[wctlmesg()]] break if window was deleted>>=
if(w->deleted)
    break;
@
% how can happen? because can receive cmd from multiple places?

% wctlmesg | wclose -> <>
<<function [[wclosewin]]>>=
void
wclosewin(Window *w)
{
    int i;

    w->deleted = true;

    if(w == input){
        input = nil;
        wsetcursor(w, false);
    }
    <<[[wclosewin()]] if wkeyboard>>
    <<[[wclosewin()]] remove w from hidden>>

    for(i=0; i<nwindow; i++)
        if(windows[i] == w){
            --nwindow;
            memmove(windows+i, windows+i+1, (nwindow-i)*sizeof(Window*));

            freeimage(w->i);
            w->i = nil;
            return;
        }
    error("unknown window in closewin");
}
@
%ocaml: simply Hashtbl.remove, no need growing array uglyness
%dead:
%    Rectangle r;
%             w->deleted = true; // again??
%             r = w->i->r;
%             /* move it off-screen to hide it, in case client is slow in letting it go */
%             //if(0) originwindow(w->i, r.min, view->r.max);

% why wsetcursor when reset input? should call riocursor instead no?

% Note that freeimage on the layer will make it disappear from the screen
\l but  then why need deletetimeoutproc? Because if the client use
\l nameimage to get a reference to it, then its refcount in the kernel
\l will be > 0 and so it will not disappear. This is why deletetimeoutproc!

% This is when w->i can be nil!!

\subsection{[[deletetimeoutproc()]] and [[deletethread()]]}

\t not sure we need that, does already freeimage in wclosewin

% process
<<function [[deletetimeoutproc]]>>=
void
deletetimeoutproc(void *v)
{
    char *s = v;

    sleep(750);	/* remove window from screen after 3/4 of a second */
    sendp(deletechan, s);
}
@
%ocaml: a thread can sleep

% separate process cos sleep is blocking


<<global [[deletechan]]>>=
// chan<string> (listener = deletethread, sender = deletetimeoutproc)
Channel* deletechan;
@
% deletetimeoutproc (as ? in proccreate(<>) <- wctlmesg(Delete | Moved) <- 
%  mousethread

<<[[main()]] communication channels creation>>=
deletechan   = chancreate(sizeof(char*), 0);
@

<<[[main()]] threads creation>>=
threadcreate(deletethread, nil, STACK);
@

% why not do that in deletetimeoutproc directly? why pass
%  through extra thread?


<<function [[deletethread]]>>=
/* thread to make Deleted windows that the client still holds disappear offscreen after an interval */
void
deletethread(void*)
{
    char *s;
    Image *i;

    threadsetname("deletethread");

    for(;;){
        s = recvp(deletechan);

        i = namedimage(display, s);
        if(i != nil){
            /* move it off-screen to hide it, since client is slow in letting it go */
            originwindow(i, i->r.min, view->r.max);
        }
        freeimage(i);
        free(s);
    }
}
@
% why freeimage here too? not enough in closewin? no because got
% a new reference to it when call namedimage. But note that the client
% will still have one, hence originwindow done above.




\subsection{[[Deleted]] and [[Exited]]}


\t who send to that?
<<global [[winclosechan]]>>=
// chan<ref<Window>> (listener = winclosethread, sender = filsyswalk | filsysclunk )
Channel	*winclosechan; /* chan(Window*); */
@


<<[[main()]] communication channels creation>>=
winclosechan = chancreate(sizeof(Window*), 0);
@
<<[[main()]] threads creation>>=
threadcreate(winclosethread, nil, STACK);
@


<<function [[winclosethread]]>>=
/* thread to allow fsysproc to synchronize window closing with main proc */
void
winclosethread(void*)
{
    Window *w;

    threadsetname("winclosethread");

    for(;;){
        w = recvp(winclosechan);
        wclose(w);
    }
}
@
\t ???



% winclosethread -> <>
<<function [[wclose]]>>=
bool
wclose(Window *w)
{
    int i;

    i = decref(w);
    if(i > 0)
        return false;
    <<[[wclose()]] sanity check i>>
    <<[[wclose()]] sanity check w>>

    wsendctlmesg(w, Exited, ZR, nil);
    return true;
}
@
% decref? but does one incref in new(), decref in winshell,
%  via wclose, then incref in?? xfidattach??
% so wait that everything was closed properly? But if delete window
%  dont want to wait!


<<[[wclose()]] sanity check i>>=
if(i < 0)
    error("negative ref count");
@
<<[[wclose()]] sanity check w>>=
if(!w->deleted)
    wclosewin(w);
@
\l when can this happen? 

<<[[Wctlmesgkind]] cases>>=
Exited,
@

% Exited vs Deleted?
% First user send Deleted, to give a chance for window to do stuff
% then call wclosewin which send Exited


%?? button3menu -> wclose???() -> wclosewin() ; wsendctlmsg(Exited)

<<[[wctlmesg()]] cases>>=
case Exited:
    frclear(&w->frm, true);
    close(w->notefd);
    chanfree(w->mc.c);
    chanfree(w->ck);
    chanfree(w->cctl);
    chanfree(w->conswrite);
    chanfree(w->consread);
    chanfree(w->mouseread);
    chanfree(w->wctlread);
    free(w->raw);
    free(w->r);
    free(w->dir);
    free(w->label);
    free(w);
    break;
@
%ocaml: Gc for most of it






\subsection{Mouse action [[pointto()]]}

% wait = wait for release. In case of delete we wait,
%  but for move pointto() is only the first step so we don't
%  want a release here.

% delete(true) | move -> <>
<<function [[pointto]]>>=
Window*
pointto(bool wait)
{
    Window *w;

    menuing = true;
    riosetcursor(&sightcursor, true);

    while(mouse->buttons == 0)
        readmouse(mousectl);

    if(mouse->buttons == 4)
        w = wpointto(mouse->xy);
    else
        w = nil;

    if(wait){
        while(mouse->buttons){
            <<[[pointto()]] cancel pointto if clicked another button>>
            readmouse(mousectl);
        }
        if(w != nil && wpointto(mouse->xy) != w)
            w = nil;
    }

    cornercursor(input, mouse->xy, false);
    moveto(mousectl, mouse->xy);	/* force cursor update; ugly */
    menuing = false;
    return w;
}
@
% dont understand this force cursor thing, nor the cancel

<<[[pointto()]] cancel pointto if clicked another button>>=
if(mouse->buttons!=4 && w != nil){	/* cancel */
    cornercursor(input, mouse->xy, false);
    w = nil;
}
@
%ocaml: useful feature?




\section{Window move}
% via menu, see also via border click

<<[[button3menu()]] cases>>=
case Move:
    move();
    break;
@

\subsection{[[move()]]}

<<function [[move]]>>=
void
move(void)
{
    Window *w;
    Image *i;
    Rectangle r;

    w = pointto(false);
    if(w == nil)
        return;
    i = drag(w, &r);
    if(i)
        wsendctlmesg(w, Moved, r, i);
    cornercursor(input, mouse->xy, true);
}
@
%pointto() changes the cursor
% pass false here, so does not wait for end of click

% see wctlmesg Moved|Reshaped case
% because Moved is a special case of Reshaped where same size.


\subsection{Mouse action [[drag()]]}

% assumes already has done a pointto
% move | mousethread -> <>
<<function [[drag]]>>=
Image*
drag(Window *w, Rectangle *rp)
{
    Image *i;
    Image *ni = nil;
    Point p, op, d, dm, om;
    Rectangle r;

    i = w->i;

    menuing = true;
    om = mouse->xy;
    riosetcursor(&boxcursor, true);

    dm = subpt(mouse->xy, w->screenr.min);
    d = subpt(i->r.max, i->r.min);
    op = subpt(mouse->xy, dm);

    drawborder(Rect(op.x, op.y, op.x+d.x, op.y+d.y), true);
    flushimage(display, true);

    while(mouse->buttons == 4){
        p = subpt(mouse->xy, dm);
        if(!eqpt(p, op)){
            // will move previously drawn rectangle thx to originwindow
            drawborder(Rect(p.x, p.y, p.x+d.x, p.y+d.y), true);
            flushimage(display, true);
            op = p;
        }
        readmouse(mousectl);
    }

    r = Rect(op.x, op.y, op.x+d.x, op.y+d.y);
    drawborder(r, false);

    cornercursor(w, mouse->xy, true);
    moveto(mousectl, mouse->xy);	/* force cursor update; ugly */
    menuing = false;

    flushimage(display, true);
    if(mouse->buttons == 0)
        ni = allocwindow(desktop, r, Refbackup, DWhite);
    <<[[drag()]] sanity check mouse buttons and ni>>
    draw(ni, ni->r, i, nil, i->r.min);
    *rp = r;
    return ni;
}
@
%old: I rewrote a bit and move ni= outside the if

<<[[drag()]] sanity check mouse buttons and ni>>=
if(mouse->buttons!=0 || ni==nil){
    moveto(mousectl, om);
    while(mouse->buttons)
        readmouse(mousectl);
    *rp = Rect(0, 0, 0, 0);
    return nil;
}
@

% drawborder does delete previous image if there was one

% drag | bandsize -> <>
<<function [[drawborder]]>>=
void
drawborder(Rectangle r, bool show)
{
    static Image *b[4];
    int i;
    if(!show){
        for(i = 0; i < 4; i++){
            freeimage(b[i]);
            b[i] = nil;
        }
    }else{
        r = canonrect(r);
        drawedge(&b[0], Rect(r.min.x, r.min.y, r.min.x+Borderwidth, r.max.y));
        drawedge(&b[1], Rect(r.min.x+Borderwidth, r.min.y, r.max.x-Borderwidth, r.min.y+Borderwidth));
        drawedge(&b[2], Rect(r.max.x-Borderwidth, r.min.y, r.max.x, r.max.y));
        drawedge(&b[3], Rect(r.min.x+Borderwidth, r.max.y-Borderwidth, r.max.x-Borderwidth, r.max.y));
    }
}
@


% drawborder -> <>
<<function [[drawedge]]>>=
void
drawedge(Image **bp, Rectangle r)
{
    Image *b = *bp;
    if(b != nil && Dx(b->r) == Dx(r) && Dy(b->r) == Dy(r))
        originwindow(b, r.min, r.min);
    else{
        freeimage(b);
        *bp = allocwindow(desktop, r, Refbackup, DRed);
    }
}
@
% can not use single rectangle, because then inside will not be
% transparent
% (hmm but do that a bit in sweep() no?)
\t originwindow works here now that I changed stuff in draw?



\section{Window resize}
% via menu, or via mouse on border directly

<<[[button3menu()]] cases>>=
case Reshape:
    resize();
    break;
@

\subsection{[[resize()]]}

<<function [[resize]]>>=
void
resize(void)
{
    Window *w;
    Image *i;

    w = pointto(true);
    if(w == nil)
        return;
    i = sweep();
    if(i)
        wsendctlmesg(w, Reshaped, i->r, i);
}
@
% very similar to move()

% use sweep() to define area.


% seen Moved Reshaped in section X.
% A Moved is actually a special case of Reshaped

<<[[wctlmesg()]] cases>>=
case Moved:
case Reshaped:
    if(w->deleted){
        freeimage(i);
        break;
    }
    w->screenr = r;
    strcpy(buf, w->name);
    wresize(w, i, m==Moved);
    w->wctlready = true;

    proccreate(deletetimeoutproc, estrdup(buf), 4096);

    if(Dx(r) > 0){
        if(w != input)
            wcurrent(w);
    }else if(w == input)
        wcurrent(nil);
    flushimage(display, true);
    break;
@
% no need check w != input because wcurrent already handles it
\l flushimage useless because done already in wctlmesg




<<[[Window]] other fields>>=
bool	 	resized;
@
% why important to remember? for creating a resize
% event to client listening to /mnt/wsys/mouse
% a bit ugly
\t put in Resize event section?

<<function [[wresize]]>>=
void
wresize(Window *w, Image *i, bool move)
{
    Rectangle r, or;

    or = w->i->r;
    if(move || (Dx(or)==Dx(i->r) && Dy(or)==Dy(i->r)))
        draw(i, i->r, w->i, nil, w->i->r.min);
    freeimage(w->i);
    w->i = i;
    wsetname(w); // publish new window name by incrementing namecount
    w->mc.image = i;

    <<[[wresize()]] textual window updates>>

    wborder(w, Selborder);
    w->topped = ++topped;

    w->resized = true;
    w->mouse.counter++;
}
@
% screenr set in caller (but we should maybe do it)

% mouse counter ??? comes with resize thing?
% yes, both case there is a new event in the queue to send
% if process listen to /dev/mouse, he will get the event
%  which will prompt it to redo a getwindow to read back
%  new /dev/winname
\t how this will handle graphical applications which are resized??
\t  ok set w->resized = true, but how force sending resize
\t  message to app? because incr counter?

\subsection{Mouse action [[bandsize()]]}

% with left or middle click, other way to resize.

% mousethread -> <>
<<function [[bandsize]]>>=
Image*
bandsize(Window *w)
{
    Image *i;
    Rectangle r, or;
    Point p, startp;
    int which, but;

    p = mouse->xy;
    but = mouse->buttons;
    which = whichcorner(w, p);
    p = cornerpt(w->screenr, p, which);
    wmovemouse(w, p);

    readmouse(mousectl);
    r = whichrect(w->screenr, p, which);
    drawborder(r, true);

    or = r;
    startp = p;
    
    while(mouse->buttons == but){
        p = onscreen(mouse->xy);
        r = whichrect(w->screenr, p, which);
        if(!eqrect(r, or) && goodrect(r)){
            drawborder(r, true);
            flushimage(display, true);
            or = r;
        }
        readmouse(mousectl);
    }

    p = mouse->xy;
    drawborder(or, false);
    flushimage(display, true);

    wsetcursor(w, true);
    <<[[bandsize()]] sanity check mouse buttons, rectanglr [[or]], point [[p]]>>
    i = allocwindow(desktop, or, Refbackup, DWhite);
    <<[[bandsize()]] sanity check i>>
    border(i, r, Selborder, red, ZP);
    return i;
}
@


<<[[bandsize()]] sanity check mouse buttons, rectanglr [[or]], point [[p]]>>=
if(mouse->buttons!=0 || Dx(or)<100 || Dy(or)<3*font->height){
    while(mouse->buttons)
        readmouse(mousectl);
    return nil;
}
if(abs(p.x - startp.x) + abs(p.y - startp.y) <= 1)
    return nil;
@

<<[[bandsize()]] sanity check i>>=
if(i == nil)
    return nil;
@





<<function [[wmovemouse]]>>=
/*
 * Convert back to physical coordinates
 */
void
wmovemouse(Window *w, Point p)
{
    p.x += w->screenr.min.x - w->i->r.min.x;
    p.y += w->screenr.min.y - w->i->r.min.y;
    moveto(mousectl, p);
}
@

% bandsize -> <>
<<function [[whichrect]]>>=
Rectangle
whichrect(Rectangle r, Point p, int which)
{
    switch(which){
    case 0:	/* top left */
        r = Rect(p.x, p.y, r.max.x, r.max.y);
        break;
    case 2:	/* top right */
        r = Rect(r.min.x, p.y, p.x, r.max.y);
        break;
    case 6:	/* bottom left */
        r = Rect(p.x, r.min.y, r.max.x, p.y);
        break;
    case 8:	/* bottom right */
        r = Rect(r.min.x, r.min.y, p.x, p.y);
        break;
    case 1:	/* top edge */
        r = Rect(r.min.x, p.y, r.max.x, r.max.y);
        break;
    case 5:	/* right edge */
        r = Rect(r.min.x, r.min.y, p.x, r.max.y);
        break;
    case 7:	/* bottom edge */
        r = Rect(r.min.x, r.min.y, r.max.x, p.y);
        break;
    case 3:		/* left edge */
        r = Rect(p.x, r.min.y, r.max.x, r.max.y);
        break;
    }
    return canonrect(r);
}
@


% bandsize -> <>
<<function [[cornerpt]]>>=
Point
cornerpt(Rectangle r, Point p, int which)
{
    switch(which){
    case 0:	/* top left */
        p = Pt(r.min.x, r.min.y);
        break;
    case 2:	/* top right */
        p = Pt(r.max.x,r.min.y);
        break;
    case 6:	/* bottom left */
        p = Pt(r.min.x, r.max.y);
        break;
    case 8:	/* bottom right */
        p = Pt(r.max.x, r.max.y);
        break;
    case 1:	/* top edge */
        p = Pt(p.x,r.min.y);
        break;
    case 5:	/* right edge */
        p = Pt(r.max.x, p.y);
        break;
    case 7:	/* bottom edge */
        p = Pt(p.x, r.max.y);
        break;
    case 3:		/* left edge */
        p = Pt(r.min.x, p.y);
        break;
    }
    return p;
}
@



\section{Window visibility}
\label{sec:window-hide}
% via menu

<<[[button3menu()]] cases>>=
case Hide:
    hide();
    break;
@

\subsection{[[hide()]]}

<<function [[hide]]>>=
void
hide(void)
{
    Window *w;

    w = pointto(true);
    if(w == nil)
        return;
    whide(w);
}
@

\subsection{[[hiddden]]}


<<global [[hidden]]>>=
// array<ref<Window>> (size valid = nhidden)
Window	*hidden[100];
@
<<global [[nhidden]]>>=
int		nhidden;
@
%ocaml: hashtbl instead of growing array.
% hmm but then lose order in which the window were hidden in the menu
% (important? could just sort?)

% hidden windows




% return -1, 0, 1, used in switch somewhere (but not in hide())
<<function [[whide]]>>=
int
whide(Window *w)
{
    Image *i;
    int j;

    for(j=0; j<nhidden; j++)
        if(hidden[j] == w)	/* already hidden */
            return -1;

    i = allocimage(display, w->screenr, w->i->chan, false, DWhite);
    if(i){
        hidden[nhidden++] = w;
        wsendctlmesg(w, Reshaped, ZR, i);
        return 1;
    }
    return 0;
}
@
%ocaml: Hashtbl

% allocimage is not allocwindow, and so it's in-memory image!!

% return 0?? means error cos could not allocate an image

% related = command line hidden

<<[[new()]] if hideit>>=
if(hideit){
    hidden[nhidden++] = w;
    w->screenr = ZR;
}
@

<<[[wclosewin()]] remove w from hidden>>=
// delete_list(w, hidden)
for(i=0; i<nhidden; i++)
    if(hidden[i] == w){
        --nhidden;
        memmove(hidden+i, hidden+i+1, (nhidden-i)*sizeof(hidden[0]));
        hidden[nhidden] = nil;
        break;
    }
@
%ocaml: Hashtbl.remove


<<[[button3menu()]] menu3str adjustments with hidden windows>>=
for(i=0; i<nhidden; i++)
    menu3str[i+Hidden] = hidden[i]->label;
menu3str[i+Hidden] = nil;
@

\subsection{[[unhide()]]}
% could be call show, but already uses wshow for something else
%ocaml: use show, because have module so no ambiguity with Terminal.show

<<[[button3menu()]] cases>>=
default:
    unhide(i);
    break;
@
% default! because everything after Exit is for unhiding

<<function [[unhide]]>>=
void
unhide(int h)
{
    Window *w;

    h -= Hidden;
    w = hidden[h];
    <<[[unhide()]] sanity check w>>
    wunhide(h);
}
@
%ocaml: why wunhide(h) again? just pass w directly.

<<[[unhide()]] sanity check w>>=
if(w == nil)
    return;
@
%ocaml: pass directly w, so no need sanity check

<<function [[wunhide]]>>=
int
wunhide(int h)
{
    Image *i;
    Window *w;

    w = hidden[h];
    i = allocwindow(desktop, w->i->r, Refbackup, DWhite);
    if(i){
        --nhidden;
        memmove(hidden+h, hidden+h+1, (nhidden-h)*sizeof(Window*));
        wsendctlmesg(w, Reshaped, w->i->r, i);
        return 1;
    }
    return 0;
}
@
%ocaml: Hashtbl.remove instead of resize array

% back to allocwindow! Reshaped will make this image public again
% via wsetname






\chapter{Filesystem Server}
\label{chap:filesystem-server}

%trans:
% new -> ... -> winshell -> filsysmount
%    if(mount(fs->cfd, -1, "/mnt/wsys", MREPL, buf) < 0){
% big missing piece.

% Until now we have an app that can create rectangles on the
% screen and move/resize/delete them. But for those rectangle
% to be really window, they must have a process with the right
% namespaces and the right fileserver to serve this namespace.

% mount is in kernel and does the right thing when the argument
% is a filedescriptor.

% Require Kernel.nw and Network.nw for this chapter. 
% I assume a lot.

% so then what happens?
% filsysproc is reading on fs->sfd, server side of the pipe

% read9pmsg, then create or get a worker (Xfid), 
% set its field with the current p9 message, and then fcall
% for right type of message. Then each fcall may proceed,
% or call the worker to do more job.
% if job requires some processing, then return nil meaning someone needs
% to allocate a new worker because this file is currently
% being processed and its state is open (state of fid
% is in f parameter below).

% Saw fcall in core DS and filsysproc dispatcher.
% Saw also worker handler Xfid and Fid file state.


\section{Additional data structures}

\subsection{[[Qxxx]]}

% Saw before
%<<[[Fid]] other fields>> =
%Qid		qid;
%@

% Qid is defined in libc.h. See also Kernel.pdf
 

<<enum [[qid]]>>=
enum Qxxx
{
    Qdir,			/* /dev for this window */
    <<[[qid]] cases>>

    QMAX,
};
@
%ocaml: ADT, Dir | File of devid, and device struct to localize code
% better instead of having the code to handle cons or mouse spread around.
%c: easy int <-> symbolic name

% window id + qxx id  -> final Qid.path
<<function [[QID]]>>=
#define	QID(winid,qxxx)	((winid<<8)|(qxxx))
@
% what about overflow? hope will not have too many windows then
%old: was w,q, but then confusing with q below
%ocaml: confusing that use qid for many things. There is raw qid,
% then parsed qid, then qid file, then qid path

% Qid -> window id
<<function [[WIN]]>>=
#define	WIN(q)	((((ulong)(q).path)>>8) & 0xFFFFFF)
@

% qid -> dev
<<function [[FILE]]>>=
#define	FILE(q)	(((ulong)(q).path) & 0xFF)
@
%ocaml: use pair instead of 2 macros. filecode vs fileid vs qid


\subsection{[[dirtab]]}

<<struct [[Dirtab]]>>=
struct Dirtab
{
    char	*name;
    // bitset<enum<QTxxx>>
    byte	type;
    // enum<Qxxx>
    uint	qid;
    uint	perm;
};
@
\l rename DirEntry (or DirEntryShort) like I want to do in kernel

<<global [[dirtab]]>>=
Dirtab dirtab[]=
{
    { ".",		QTDIR,	Qdir,		0500|DMDIR },
    <<dirtab array elements>>
    { nil, }
};
@
\l could use DMEXEC | DMREAD
%ocaml: clearer perm, and remove redundant DMDIR
% also separate root_entry from toplevel_entries as anyway lots of C code
% does d++ to skip '.'


<<[[Fid]] other fields>>=
// ref<Dirtab>
Dirtab	*dir;
@
\t it's a DirEntryShort! not Dirtab. rename field too!

% so for instance attach will set qid to Qdir
% and dir to dirtable of root! 



\section{[[filsysrespond()]]}

%trans: before seeing attach/... client transmited request
% (Txxx), see utility function to answer to client (Rxxx).
% see docs/man/5/intro, +1 trick, Rerror, etc.

% ... -> <>  called from many Xfid threads, and some filsysxxx too
<<function [[filsysrespond]]>>=
Xfid*
filsysrespond(Filsys *fs, Xfid *x, Fcall *fc, char *err)
{
    int n;

    <<[[filsysrespond()]] if err>>
    else
        fc->type = x->req.type+1; // Reply type just after Transmit type

    fc->fid = x->req.fid;
    fc->tag = x->req.tag;

    <<[[filsysrespond()]] sanitize buf>>
    n = convS2M(fc, x->buf, messagesize);
    <<[[filsysrespond()]] sanity check n>>

    if(write(fs->sfd, x->buf, n) != n)
        error("write error in respond");
    <<[[filsysrespond()]] dump Fcall t if debug>>
    free(x->buf);
    x->buf = nil;
    return x;
}
@
%ocaml: build value with { req with ... }, no malloc, no convS2M
% and explicit constructor for return value makes it clearer than
% those fc->qid = xxx; fc->type = x->req.type+1

% answer with same tag! so kernel can match the response to the question

% but write on sfd goes where? pipe are bidirectional! so goes back
% to clients_fd which is managed by the kernel on behalf of a client.

% and what if multiple things write on it at the same time?
%  we write each time full message, so the kernel will execute the
%  writes in a certain order without interleaving (syscall on a fd are atomics),
%  and the tag/fid is used to identify the request, so they can arrive
%  in any order it does not matter.
% filsysproc and any xfidctl thread can potentially call filsysrespond
\l could rename fc to r? for reply? but then confusing with rectangle

<<[[filsysrespond()]] sanitize buf>>=
if(x->buf == nil)
    x->buf = malloc(messagesize);
@
% should never happen, buf set in filsysproc

<<[[filsysrespond()]] sanity check n>>=
if(n <= 0)
    error("convert error in convS2M");
@

<<[[filsysrespond()]] if err>>=
if(err){
    fc->type = Rerror;
    fc->ename = err;
}
@
%ocaml: separate function for error, not abusing filsysrespond last arg

\section{Attach}

\subsection{[[filsysattach()]]}

\t does not use first argument, so remove it from fcall sig no?
\t hmm used by filsysopen. But true that anyway it's in the Xfid so could
\t remove (or remove it from Xfid)

% -> <>
<<function [[filsysattach]]>>=
static
Xfid*
filsysattach(Filsys *, Xfid *x, Fid *f)
{
    <<[[filsysattach()]] locals>>

    <<[[filsysattach()]] sanity check same user>>

    f->busy = true;
    f->open = false;

    f->qid.path = Qdir; // no window id, Qdir valid for all
    f->qid.type = QTDIR;
    f->qid.vers = 0;
    f->dir = dirtab; // entry for "."

    f->nrpart = 0;

    sendp(x->c, xfidattach);
    return nil;
}
@
\l nrpart? partial rune. Aspectize!
\l  set here back to 0 because reuse fids
%ocaml: no reuse of fid so cleaner.

% return nil, because worker has a job to do asynchronously so filsysproc
% need allocate a new worker for next request.
% once finished this worker will go back in xfidfree.
\l requires really use a thread for that? Any blocking issue?
\l  when write the answer? But then why for walk we dont do it too?

<<[[filsysattach()]] locals>>=
Fcall fc;
@
%old: was called t, we will see such a local often

<<[[filsysattach()]] sanity check same user>>=
if(strcmp(x->req.uname, x->fs->user) != 0)
    return filsysrespond(x->fs, x, &fc, Eperm);
@

% see filsysrespond later, but write back on pipe an answer
% to client using x->buf space.

\subsection{[[xfidattach()]]}

<<global [[all]]>>=
QLock	all;			/* BUG */
@
% I think it's mainly for wsys/ shared access
% it protects access to windows and nwindow



% filsysattach !-> <>
<<function [[xfidattach]]>>=
void
xfidattach(Xfid *x)
{
    Fcall fc;
    int id;
    Window *w = nil;
    bool newlymade = false;
    <<[[xfidattach()]] other locals>>

    fc.qid = x->f->qid;
    qlock(&all);

    <<[[xfidattach()]] if mount "new ...">>
    else{
        // mount(fs->cfd, ..., "/mnt/wsys", ..., "2"), winid
        id = atoi(x->req.aname);
        w = wlookid(id);
    }

    x->f->w = w;
    <<[[xfidattach()]] sanity check w>>
    if(!newlymade)	/* counteract dec() in winshell() */
        incref(w);
    qunlock(&all);

    filsysrespond(x->fs, x, &fc, nil);
}
@
%ocaml: less split between filsysattach and xfidattach 
% and clearer answer message than setting f->qid in one func
% and then fc.qid answer for Attach (not explicit) in other func

%dead: old syntax
%    if(x->aname[0] == 'N'){	/* N 100,100, 200, 200 - old syntax */
%        n = x->aname+1;
%        pid = strtoul(n, &n, 0);
%        if(*n == ',')
%            n++;
%        r.min.x = strtoul(n, &n, 0);
%        if(*n == ',')
%            n++;
%        r.min.y = strtoul(n, &n, 0);
%        if(*n == ',')
%            n++;
%        r.max.x = strtoul(n, &n, 0);
%        if(*n == ',')
%            n++;
%        r.max.y = strtoul(n, &n, 0);

<<function [[wlookid]]>>=
Window*
wlookid(int id)
{
    int i;

    for(i=0; i<nwindow; i++)
        if(windows[i]->id == id)
            return windows[i];
    return nil;
}
@
%ocaml: Hashtbl.find

% need to do that only for attach. Further fid creation
% will come from walk and can copy Fid.w field

% so get back here from mount()!
% pass window id, and now this attach thing is connected
% to the right window


<<[[xfidattach()]] other locals>>=
char *err = Eunkid;
@
% unknown id

<<[[xfidattach()]] sanity check w>>=
if(w == nil){
    qunlock(&all);
    x->f->busy = false;
    filsysrespond(x->fs, x, &fc, err);
    return;
}
@
% free back the fid with busy to false

\section{Walk}

% Walk is complex.
% Clone, walk, multiple elements in one request. Subtle API.

% Note that because union dir, normal that many of requests to walk
% should fail. For instance [draw;new] for nwnames should fail!
% It is not handled by rio (but by the draw device in the kernel)

\subsection{[[filsyswalk()]]}

% docs/man/5/walk

% One message for full path. So efficient network wise,
% no need back and forth for each path elements.
% But that means filsyswalk need to redo part of the job
% of the kernel in namei().

% complicated ...


<<function [[filsyswalk]]>>=
static
Xfid*
filsyswalk(Filsys *fs, Xfid *x, Fid *f)
{
    Fcall fc;
    Qid qid;
    Dirtab *dir;
    int i;
    int id;
    uchar type;
    ulong path;
    Dirtab *d;
    Window *w;
    char *err;
    <<[[filsyswalk()]] other locals>>

    <<[[filsyswalk()]] sanity check if opened>>
    <<[[filsyswalk()]] if clone walk message>>

    fc.nwqid = 0;
    err = nil;

    /* update f->qid, f->dir only if walk completes */
    qid = f->qid;
    dir = f->dir;

    if(x->req.nwname > 0){
        for(i=0; i < x->req.nwname; i++){
            <<[[filsyswalk()]] sanity check current qid is a directory>>
            <<[[filsyswalk()]] if dotdot>>
            <<[[filsyswalk()]] if Qwsys, then goto Accept>>
            <<[[filsyswalk()]] if snarf>>
            id = WIN(f->qid);
            d = dirtab;
            d++;	/* skip '.' */
            for(; d->name; d++)
                if(strcmp(x->req.wname[i], d->name) == 0){
                    path = d->qid;
                    type = d->type;
                    dir = d;
                    goto Accept;
                }
            break;	/* file not found */
        }
        <<[[filsyswalk()]] sanity check i and err>>
    }
    <<[[filsyswalk()]] sanity check err and nwqid>>
    else if(fc.nwqid == x->req.nwname){
        f->dir = dir;
        f->qid = qid;
    }

    return filsysrespond(fs, x, &fc, err);
}
@

<<[[filsyswalk()]] accept label and code>>=
Accept:
<<[[filsyswalk()]] sanity check path elements>>
qid.type = type;
qid.path = QID(id, path);
qid.vers = 0;
fc.wqid[fc.nwqid++] = qid;
continue;
@


\subsection{Cloning [[fid]]}

<<[[filsyswalk()]] other locals>>=
Fid *nf = nil;
@
<<[[filsyswalk()]] if clone walk message>>=
if(x->req.fid  != x->req.newfid){
    /* BUG: check exists */
    nf = newfid(fs, x->req.newfid);
    <<[[filsyswalk()]] when clone walk message, sanity check nf>>
    nf->busy = true;
    nf->open = false;
    nf->dir = f->dir;
    nf->qid = f->qid;
    nf->w = f->w;
    incref(f->w);
    nf->nrpart = 0;	/* not open, so must be zero */
    f = nf;	/* walk f */
}
@
%ocaml: use cleaner Request type where newfid is an option,
% and also check does not exists

% propagate w, so attach is only place where needs to wlookid.

<<[[filsyswalk()]] when clone walk message, sanity check nf>>=
if(nf->busy)
    return filsysrespond(fs, x, &fc, "clone to busy fid");
@



\subsection{[[..]]}


<<[[filsyswalk()]] if dotdot>>=
if(strcmp(x->req.wname[i], "..") == 0){
    type = QTDIR;
    path = Qdir;
    dir = dirtab;
    <<[[filsyswalk()]] when in dotdot, if Qwsysdir adjust path>>
    id = 0;
    <<[[filsyswalk()]] accept label and code>>
}
@
% id 0, topdir does not need winid 
\l but important to share it?


\subsection{Error management}

<<[[filsyswalk()]] sanity check if opened>>=
if(f->open)
    return filsysrespond(fs, x, &fc, "walk of open file");
@

<<[[filsyswalk()]] sanity check i and err>>=
if(i==0 && err==nil)
    err = Eexist;
@
% Eexist for "File does not exist"
\l why check i == 0? return Eexist only if toplevel name is unknown?
\l  for later entries we care less?

<<[[filsyswalk()]] sanity check err and nwqid>>=
if(err!=nil || fc.nwqid < x->req.nwname){
    if(nf){
        if(nf->w)
            sendp(winclosechan, nf->w);
        nf->open = false;
        nf->busy = false;
    }
}
@
\l why close the window when error in path elements?

<<[[filsyswalk()]] sanity check current qid is a directory>>=
if(!(qid.type & QTDIR)){
    err = Enotdir;
    break;
}
@

<<[[filsyswalk()]] sanity check path elements>>=
if(i == MAXWELEM){
    err = "name too long";
    break;
}
@


%\section{Flush}
% adv topics now

\section{Open}

\subsection{[[filsysopen()]]}

<<function [[filsysopen]]>>=
static
Xfid*
filsysopen(Filsys *fs, Xfid *x, Fid *f)
{
    <<[[filsysopen()]] locals>>

    <<[[filsysopen()]] sanity check mode>>
    sendp(x->c, xfidopen);
    return nil;
<<[[filsysopen()]] deny label>>
}
@

% remember that x->mode is really x->Fcall.mode of union

% return nil again to say to filsysproc to allocate a new worker
% for next request. Cant reuse this buffer.

<<[[filsysopen()]] locals>>=
int m;
@
<<[[filsysopen()]] sanity check mode>>=
<<[[filsysopen()]] sanitize mode>>
/* can't execute or remove anything */
if(x->req.mode==OEXEC || (x->req.mode & ORCLOSE))
    goto Deny;

switch(x->req.mode){
case OREAD:
    m = 0400;
    break;
case OWRITE:
    m = 0200;
    break;
case ORDWR:
    m = 0600;
    break;
default:
    goto Deny;
}
if(((f->dir->perm & ~(DMDIR|DMAPPEND)) & m) != m)
    goto Deny;
@
% look for 

<<[[filsysopen()]] sanitize mode>>=
/* can't truncate anything, so just disregard */
x->req.mode &= ~(OTRUNC|OCEXEC);
@


<<[[filsysopen()]] locals>>=
Fcall fc;
@
<<[[filsysopen()]] deny label>>=
Deny:
    return filsysrespond(fs, x, &fc, Eperm);
@

\subsection{[[xfidopen()]]}

% how sure that have a x->f->w?  because cant open if not attach?
<<function [[xfidopen]]>>=
void
xfidopen(Xfid *x)
{
    Fcall fc;
    Window *w = x->f->w;

    <<[[xfidxxx()]] respond error if window was deleted>>
    switch(FILE(x->f->qid)){
    <<[[xfidopen()]] cases>>
    }

    x->f->open = true;
    x->f->mode = x->req.mode;

    fc.qid = x->f->qid;
    fc.iounit = messagesize-IOHDRSZ;
    filsysrespond(x->fs, x, &fc, nil);
}
@
%old: I put the x->f->w with declaration.

<<[[xfidxxx()]] respond error if window was deleted>>=
if(w->deleted){
    filsysrespond(x->fs, x, &fc, Edeleted);
    return;
}
@

\section{Clunk/Close}

\subsection{[[filsysclunk()]]}

<<function [[filsysclunk]]>>=
static
Xfid*
filsysclunk(Filsys *fs, Xfid *x, Fid *f)
{
    Fcall fc;

    if(f->open){
        f->busy = false;
        f->open = false;
        sendp(x->c, xfidclose);
        return nil;
    }
    // else
    if(f->w)
        sendp(winclosechan, f->w);
    f->busy = false;
    f->open = false;
    return filsysrespond(fs, x, &fc, nil);
}
@

% free back fid

% when call clunk and not opened?

% winclosechan ultimately call wclose which removes a reference
% to the window, so looks similar to xfidclose ...
% why not call wclose directly? to not block?
\t why need to keep refcount of Window? when reach 0 and not asked
% by user to close the window? When do exit() which ultimately 
% call close on all the devices?

\subsection{[[xfidclose()]]}


<<function [[xfidclose]]>>=
void
xfidclose(Xfid *x)
{
    Fcall fc;
    Window *w = x->f->w;
    <<[[xfidclose()]] other locals>>

    switch(FILE(x->f->qid)){
    <<[[xfidclose()]] cases>>
    }
    wclose(w);
    filsysrespond(x->fs, x, &fc, nil);
}
@
\l wclose(w)! remove one reference, but subtle why need that
\t why?
% here we do not use wclosechan because we are already in a thread,
% so can afford to wait for wclose to finish


\section{Read}

% This is how to get the content of "." after attached and walked,
% by reading the fid of a directory.
% See Qdir: case in filsysread


\subsection{[[filsysread()]]}


<<function [[filsysread]]>>=
static
Xfid*
filsysread(Filsys *fs, Xfid *x, Fid *f)
{
    int o, e;
    uint clock;
    byte *b;
    int n;
    Fcall fc;
    <<[[filsysread()]] other locals>>

    if(!(f->qid.type & QTDIR)){
        sendp(x->c, xfidread);
        return nil;
    }
    // else, a directory

    o = x->req.offset;
    e = x->req.offset + x->req.count;
    clock = getclock();
    b = malloc(messagesize-IOHDRSZ);	/* avoid memset of emalloc */
    <<[[filsysread()]] sanity check b>>

    n = 0;
    switch(FILE(f->qid)){
    <<[[filsysread()]] cases>>
    }

    fc.data = (char*)b;
    fc.count = n;
    filsysrespond(fs, x, &fc, nil);
    free(b);
    return x;
}
@
% can reuse x, request processed


<<[[filsysread()]] sanity check b>>=
if(b == nil)
    return filsysrespond(fs, x, &fc, "out of memory");
@


\subsection{Reading a directory}

% important case! Qdir! (Qwsysdir will be explained later)

<<[[filsysread()]] other locals>>=
Dirtab *d;
@
<<[[filsysread()]] cases>>=
case Qdir:
case Qwsysdir:
    d = dirtab;
    d++;	/* first entry is '.' */
    for(i=0; d->name != nil && i<e; i+=len){
        len = dostat(fs, WIN(x->f->qid), d, b+n, x->req.count - n, clock);
        if(len <= BIT16SZ)
            break;
        if(i >= o)
            n += len;
        d++;
    }
    break;
@
\l ugly encoding of error with dostat when return BIT16SZ ...
%ocaml: exn?

\subsection{[[xfidread()]]}

<<function [[xfidread]]>>=
void
xfidread(Xfid *x)
{
    uint qid;
    int off, cnt;
    Fcall fc;
    Fcall *req = &x->req;
    Window *w = x->f->w;
    <<[[xfidread()]] other locals>>
    
    <<[[xfidxxx()]] respond error if window was deleted>>
    qid = FILE(x->f->qid);
    off = req->offset;
    cnt = req->count;

    switch(qid){
    <<[[xfidread()]] cases>>
    default:
        fprint(STDERR, "unknown qid %d in read\n", qid);
        sprint(buf, "unknown qid in read");
        filsysrespond(x->fs, x, &fc, buf);
        break;
        }
}
@
\l how default case can happen? should never happen by construction
%ocaml: ADT and exhaustive check so no need default case

% off, cnt, very important.
% actually off not always respected ... Qmouse does not care about off
% see read(2) API?

\section{Write}

\subsection{[[filsyswrite()]]}

<<function [[filsyswrite]]>>=
static
Xfid*
filsyswrite(Filsys*, Xfid *x, Fid*)
{
    sendp(x->c, xfidwrite);
    return nil;
}
@
% there is no way to write to a directory (checked by kernel?), so the code
% of filsyswrite is simpler than filsysread

\subsection{[[xfidwrite()]]}


<<function [[xfidwrite]]>>=
void
xfidwrite(Xfid *x)
{
    Fcall fc;
    Fcall *req = &x->req;
    Window *w = x->f->w;
    uint qid;
    int off, cnt;
    char buf[256];
    <<[[xfidwrite()]] other locals>>
    
    <<[[xfidxxx()]] respond error if window was deleted>>
    qid = FILE(x->f->qid);
    cnt = req->count;
    off = req->offset;
    req->data[cnt] = '\0';

    switch(qid){
    <<[[xfidwrite()]] cases>>
    default:
        fprint(STDERR, buf, "unknown qid %d in write\n", qid);
        sprint(buf, "unknown qid in write");
        filsysrespond(x->fs, x, &fc, buf);
        return;
    }

    fc.count = cnt;
    filsysrespond(x->fs, x, &fc, nil);
}
@




\section{Stats}

\subsection{[[filsysstat()]]}

<<function [[filsysstat]]>>=
static
Xfid*
filsysstat(Filsys *fs, Xfid *x, Fid *f)
{
    Fcall fc;

    fc.stat = emalloc(messagesize-IOHDRSZ);
    fc.nstat = dostat(fs, WIN(x->f->qid), f->dir, fc.stat, messagesize-IOHDRSZ, getclock());
    x = filsysrespond(fs, x, &fc, nil);
    free(fc.stat);
    return x;
}
@

<<function [[dostat]]>>=
static
int
dostat(Filsys *fs, int id, Dirtab *dir, uchar *buf, int nbuf, uint clock)
{
    Dir d;

    d.qid.path = QID(id, dir->qid);
    <<[[dostat()]] adjust vers for snarf>>
    else
        d.qid.vers = 0;
    d.qid.type = dir->type;
    d.mode = dir->perm;
    d.length = 0;	/* would be nice to do better */
    d.name = dir->name;
    d.uid = fs->user;
    d.gid = fs->user;
    d.muid = fs->user;
    d.atime = clock;
    d.mtime = clock;

    return convD2M(&d, buf, nbuf);
}
@




\section{Forbidden operations}

<<[[fcall]] other methods>>=
[Tcreate]  = filsyscreate,
[Tremove]  = filsysremove,
[Twstat]   = filsyswstat,
@


%\subsection{Create, remove}

<<function [[filsyscreate]]>>=
static
Xfid*
filsyscreate(Filsys *fs, Xfid *x, Fid*)
{
    Fcall fc;

    return filsysrespond(fs, x, &fc, Eperm);
}
@

<<function [[filsysremove]]>>=
static
Xfid*
filsysremove(Filsys *fs, Xfid *x, Fid*)
{
    Fcall fc;

    return filsysrespond(fs, x, &fc, Eperm);
}
@

<<function [[filsyswstat]]>>=
static
Xfid*
filsyswstat(Filsys *fs, Xfid *x, Fid*)
{
    Fcall fc;

    return filsysrespond(fs, x, &fc, Eperm);
}
@


% also filsysversion and filsysauth (in advanced topics), security related?






\chapter{Virtual Devices}
\label{chap:virtual-devices}
% [[/mnt/wsys/...]] 

% remember that /mnt/wsys is unioned in /dev/ so access to /dev/mouse
% in client is really /mnt/wsys/mouse handled by rio.

\section{[[/mnt/wsys/mouse]]}
\n simpler than cons

% more a graphical window device.

<<[[qid]] cases>>=
Qmouse,
@
<<dirtab array elements>>=
{ "mouse",		QTFILE,	Qmouse,		0600 },
@

% 0600 so read and write (but not execute)

% xfidopen for Qmouse is now discussed in Graphical windows chapter.

% discussions about mouse events sent to the window thread
% are discussed before.
% but the WMouse case if mouseopen is discussed in Graphical windows chapter
% too.
\l too much spread?

\subsection{Reading part1}
% and window.mouseread

% So if client reads /dev/mouse (after it has been opened of course),
% then xfidread wait for mouse events to come by listening to mouseread!
% The winctl itself listen for mouse events on w->mc.c from mousethread


<<[[Window]] other fields>>=
// chan<chan<Mouse> > (listener = xfidread(Qmouse), sender = winctl)
Channel		*mouseread;	/* chan(Mousereadmesg) */
@
<<[[wmk()]] channels creation>>=
w->mouseread =  chancreate(sizeof(Mousereadmesg), 0);
@
%ocaml: typed channels! and nice mouse channel channel type!

% Why chan of chan? why does not send Mouse directly? because mouse state
% at sending time is not good anymore at receiving time!
% See code in winctl where alts is on receive and send!
% so the first message is really a sync message.
% we could also send a fake mouse state and by convention ask for
% another after, but cleaner to pass another channel.
%
% But sender send only when he has something he is ready
% to send and it's queue anyway? It's queued but if too many
% then head of queue is replaced, so really you want to wait
% before sending the mouse state.

<<struct [[Mousereadmesg]]>>=
struct Mousereadmesg
{
    // chan<Mouse> (listener = xfidread(Qmouse), sender = winctl)
    Channel	*cm;		/* chan(Mouse) */
};
@
%ocaml: no need intermediate structure. Channels are typed.

% passing a channel in a Channel!
% could be a Window field too no? first know if someone wants
% a mouseread, then write on other channel the mouse

<<enum [[_anon_ (windows/rio/xfid.c)]]4>>=
enum { MRdata, MRflush, NMR };
@
% MRflush and flush stuff in adv topics

<<[[xfidread()]] other locals>>=
Alt alts[NCR+1];
Mousereadmesg mrm;
Mouse ms;
int n, c;
@
% c local?
% NCR+1 should be enough for all alts (which looks like have always 2 elems,
% 1 regular and one XXflush)

<<[[xfidread()]] cases>>=
case Qmouse:
    <<[[xfidxxx()]] set flushtag>>

    alts[MRdata].c = w->mouseread;
    alts[MRdata].v = &mrm;
    alts[MRdata].op = CHANRCV;
    <<[[xfidread()]] when Qmouse, set alts for flush>>
    alts[NMR].op = CHANEND;

    switch(alt(alts)){
    case MRdata:
        break;
    <<[[xfidread()]] when Qmouse, switch alt flush case>>
    }
    /* received data */
    <<[[xfidxxx()]] unset flushtag>>
    <<[[xfidread()]] when Qmouse, if flushing>>

    qlock(&x->active);
    recv(mrm.cm, &ms);
    c = 'm';
    <<[[xfidread()]] when Qmouse, adjust c for resize message if resized>>
    n = sprint(buf, "%c%11d %11d %11d %11ld ", c, ms.xy.x, ms.xy.y, ms.buttons, ms.msec);
    w->resized = false;

    fc.data = buf;
    fc.count = min(n, cnt);
    filsysrespond(x->fs, x, &fc, nil);
    qunlock(&x->active);
    break;
@
\l hide even more switch and code after? put alt(alts) how of it?

%ocaml-found:
% note that does not care about off. always respond the same thing.
% because principle is that unix.read will start from last offset
% (the kernel maintain a file pointer), but we dont care about this
% offset!

\subsection{Writing}

% can move the mouse programatically :)
% but it needs to have the focus apparently and be visible

<<[[xfidwrite()]] other locals>>=
char *p;
Point pt;
@

<<[[xfidwrite()]] cases>>=
case Qmouse:
    if(w!=input || Dx(w->screenr)<=0)
        break;
    if(req->data[0] != 'm'){
        filsysrespond(x->fs, x, &fc, Ebadmouse);
        return;
    }
    p = nil;
    pt.x = strtoul(req->data+1, &p, 0);
    if(p == nil){
        filsysrespond(x->fs, x, &fc, Eshort);
        return;
    }
    pt.y = strtoul(p, nil, 0);
    if(w==input && wpointto(mouse->xy)==w)
        wsendctlmesg(w, Movemouse, Rpt(pt, pt), nil);
    break;
@



<<[[Wctlmesgkind]] cases>>=
Movemouse,
@
<<[[wctlmesg()]] cases>>=
case Movemouse:
    if(sweeping || !ptinrect(r.min, w->i->r))
        break;
    wmovemouse(w, r.min);
    break;
@
% use of sweeping to forbid certain mouse move! finally.

\section{[[/mnt/wsys/cons]]}

% quite complicated

<<[[qid]] cases>>=
Qcons,
@
<<dirtab array elements>>=
{ "cons",		QTFILE,	Qcons,		0600 },
@

% utf8! not rune, not char, utf8!

\subsection{Reading part1}

% So if client reads /dev/cons,
% then we wait for key event to come to us by listening to consread!
% The winctl itself listen for key events (rune) on w->ck from keyboardthread

<<[[Window]] other fields>>=
// chan<Consreadmesg> (listener = xfidread(Qcons), sender = winctl)
Channel		*consread;	/* chan(Consreadmesg) */
@
<<[[wmk()]] channels creation>>=
w->consread =  chancreate(sizeof(Consreadmesg), 0);
@

<<struct [[Consreadmesg]]>>=
struct Consreadmesg
{
    // chan<ref<array<Rune>> (listener = winctl, sender = xfidread(Qcons))
    Channel	*c1;		/* chan(tuple(char*, int) == Stringpair) */
    // chan<ref<array<Rune>> (listener = xdidread(Qcons), sender = winctl)
    Channel	*c2;		/* chan(tuple(char*, int) == Stringpair) */
};
@
% pass channels inside channel ... subtle
% why not just one? because need first pass a buffer allocated
%  by xfidread who knows how much he wants.
% file interface is byte, but runes are multi bytes, so need
%  adjust, maybe send partial rune, etc.
% Cant just use one channel in both direction? channel = unidirectional pipe?

% note that channels are in Runes, but OS interface is in bytes
% so we will see adjustments because of that.

<<struct [[Stringpair]]>>=
struct Stringpair	/* rune and nrune or byte and nbyte */
{
    void	*s;
    int		ns;
};
@
%ocaml: just pass a count

% where this is used to send bytes on a channel? actually here!
% when app read its /dev/cons we send bytes to the app.
% when app writes to /dev/cons we receive full runes though

<<enum [[_anon_ (windows/rio/xfid.c)]]3>>=
enum { CRdata, CRflush, NCR };
@

<<[[xfidread()]] other locals>>=
Consreadmesg crm;
Channel *c1, *c2;	/* chan (tuple(char*, int)) */
char *t;
Stringpair pair;
@

<<[[xfidread()]] cases>>=
case Qcons:
    <<[[xfidxxx()]] set flushtag>>

    alts[CRdata].c = w->consread;
    alts[CRdata].v = &crm;
    alts[CRdata].op = CHANRCV;
    <<[[xfidread()]] when Qcons, set alts for flush>>
    alts[NCR].op = CHANEND;

    switch(alt(alts)){
    case CRdata:
        break;
    <<[[xfidread()]] when Qcons, switch alt flush case>>
    }
    /* received data */
    <<[[xfidxxx()]] unset flushtag>>

    c1 = crm.c1;
    c2 = crm.c2;
    t = malloc(cnt+UTFmax+1);	/* room to unpack partial rune plus */
    pair.s = t;
    pair.ns = cnt;
    send(c1, &pair);

    <<[[xfidread()]] when Qcons, if flushing>>

    qlock(&x->active);
    recv(c2, &pair);
    fc.data = pair.s;
    fc.count = pair.ns;
    filsysrespond(x->fs, x, &fc, nil);
    free(t);
    qunlock(&x->active);
    break;
@
%bug: was alts.[NMR] = ... above, but it should be NCR

% pass cnt from filsysread and return maybe less if partial rune
% (and store what partial rune was read in w->nrpart)

% here s and ns are byte and nbyte

\subsection{Writing part1}

% So if client writes to /dev/cons, he wants to output strings
% on the terminal,
% then we wait for conswrite to get the go from winctl.

<<[[Window]] other fields>>=
// chan<Conswritemesg> (listener = xfidwrite(Qcons), sender = winctl)
Channel		*conswrite;	/* chan(Conswritemesg) */
@
<<[[wmk()]] channels creation>>=
w->conswrite = chancreate(sizeof(Conswritemesg), 0);
@

<<struct [[Conswritemesg]]>>=
struct Conswritemesg
{
    // chan<ref<array<Rune>> (listener = winctl, sender = xfidwrite(Qcons))
    Channel	*cw;		/* chan(Stringpair) */
};
@
% Note that here it's rune! we send only full runes. If some bytes
% do not form a full rune, we store it in window and we will use it for
% the next write round

<<enum [[_anon_ (windows/rio/xfid.c)]]2>>=
enum { CWdata, CWflush, NCW };
@


<<[[xfidwrite()]] other locals>>=
Rune *r;
int nr; // nb runes
int nb; // nb bytes
@

<<[[xfidwrite()]] other locals>>=
Alt alts[NCW+1];
Conswritemesg cwm;
Stringpair pair;
@
%NCW+1 enough for all xfidwrite cases

% see cvttorunes function in appendix

<<[[xfidwrite()]] cases>>=
case Qcons:

    <<[[xfidwrite()]] when Qcons, look for previous partial rune bytes>>
    r = runemalloc(cnt);
    cvttorunes(req->data, cnt-UTFmax, r, &nb, &nr, nil);
    <<[[xfidwrite()]] when Qcons, look if more full runes>>
    <<[[xfidwrite()]] when Qcons, store remaining partial rune bytes>>

    <<[[xfidxxx()]] set flushtag>>

    alts[CWdata].c = w->conswrite;
    alts[CWdata].v = &cwm;
    alts[CWdata].op = CHANRCV;
    <<[[xfidwrite()]] when Qcons, set alts for flush>>
    alts[NCW].op = CHANEND;

    switch(alt(alts)){
    case CWdata:
        break;
    <<[[xfidwrite()]] when Qcons, switch alt flush case>>
    }

    /* received data */
    <<[[xfidxxx()]] unset flushtag>>
    <<[[xfidwrite()]] when Qcons, if flushing>>

    qlock(&x->active);
    pair.s = r;
    pair.ns = nr;
    send(cwm.cw, &pair);
    fc.count = req->count;
    filsysrespond(x->fs, x, &fc, nil);
    qunlock(&x->active);
    return;
@

% this time pass full rune, not byte

\subsection{Bytes versus runes, partial runes}

% we have stuff to write! stuff to write in the console,
% but this time it must be Rune! cant pass half rune to winctl
% as it will not be able to display it. So need
% to remember in Fid partial runes.

<<[[Fid]] other fields>>=
uchar	rpart[UTFmax];
int		nrpart;
@
% rune partial


<<[[xfidwrite()]] when Qcons, store remaining partial rune bytes>>=
// assert(cnt-nb < UTFMAX);
if(nb < cnt){
    memmove(x->f->rpart, req->data + nb, cnt-nb);
    x->f->nrpart = cnt-nb;
}
@
% didn't send complete rune, need store those bytes for next run
% of xfidwrite to have complete rune to relay

<<[[xfidwrite()]] when Qcons, look for previous partial rune bytes>>=
nr = x->f->nrpart;
if(nr > 0){
    memmove(req->data + nr, req->data, cnt);	/* there's room: see malloc in filsysproc */
    memmove(req->data, x->f->rpart, nr);
    cnt += nr;
    x->f->nrpart = 0;
}
@


<<[[xfidwrite()]] other locals>>=
int c;
@

% did cnt-UTFMAX, but maybe still full rune in UTFMAX, can have
% 4 simple runes
<<[[xfidwrite()]] when Qcons, look if more full runes>>=
/* approach end of buffer */
while(fullrune(req->data + nb, cnt-nb)){
    c = nb;
    nb += chartorune(&r[nr], req->data + c);
    if(r[nr])
        nr++;
}
@
% see also cvttorunes



\section{[[/mnt/wsys/consctl]]}

<<[[qid]] cases>>=
Qconsctl,
@
<<dirtab array elements>>=
{ "consctl",	QTFILE,	Qconsctl,	0200 },
@
% just write

<<[[Window]] other fields>>=
bool	ctlopen;
@
% exclusive access to /dev/consctl (why?) because sign of a mess otherwise?
%old: bool_byte

<<[[xfidopen()]] cases>>=
case Qconsctl:
    if(w->ctlopen){
        filsysrespond(x->fs, x, &fc, Einuse);
        return;
    }
    w->ctlopen = true;
    break;
@
% like for mouseopen

<<[[xfidclose()]] cases>>=
case Qconsctl:
    <<[[xfidclose()]] Qconsctl case, if rawing>>
    <<[[xfidclose()]] Qconsctl case, if holding>>
    w->ctlopen = false;
    break;
@

<<[[xfidwrite()]] cases>>=
case Qconsctl:
    <<[[xfidwrite()]] Qconsctl case>>
    // else
    filsysrespond(x->fs, x, &fc, "unknown control message");
    return;
@
% will see later writing on consctl, why we need it

\section{[[/mnt/wsys/cursor]]}

<<[[qid]] cases>>=
Qcursor,
@
<<dirtab array elements>>=
{ "cursor",		QTFILE,	Qcursor,	0600 },
@

% seen Window.cursorp before

<<[[xfidclose()]] cases>>=
case Qcursor:
    w->cursorp = nil;
    wsetcursor(w, false);
    break;
@
% will put back default cursor?

<<[[xfidread()]] cases>>=
case Qcursor:
    filsysrespond(x->fs, x, &fc, "cursor read not implemented");
    break;
@

<<[[xfidwrite()]] cases>>=
case Qcursor:
    if(cnt < 2*4+2*2*16)
        w->cursorp = nil;
    else{
        w->cursor.offset.x = BGLONG(req->data+0*4);
        w->cursor.offset.y = BGLONG(req->data+1*4);
        memmove(w->cursor.clr, req->data+2*4, 2*2*16);
        w->cursorp = &w->cursor;
    }
    wsetcursor(w, !sweeping);
    break;
@
% does not adjust cnt? off?

\section{[[/dev/draw/]] and [[/mnt/wsys/winname]]}

% actually this one in rio is not demultiplexed!
% It's not a virtual device.
% so more efficient.
% Done by the namedimage thing and /dev/winname

% security issue? can pass wrong screen id to draw operation?
% anyway, anybody can access the full screen in display->image, hmm

<<[[qid]] cases>>=
Qwinname,
@
<<dirtab array elements>>=
{ "winname",	QTFILE,	Qwinname,	0400 },
@

<<[[xfidread()]] cases>>=
case Qwinname:
    n = strlen(w->name);
    <<[[xfidread()]] when Qwinname case, sanity check n>>
    t = estrdup(w->name);
    goto Text;
@
%ocaml: no need estrdup

% very useful! basis for initdraw and gengetwindow!!

% see goto Text later

<<[[xfidread()]] when Qwinname case, sanity check n>>=
if(n == 0){
    filsysrespond(x->fs, x, &fc, "window has no name");
    break;
}
@
\l when can happen? if bug? if hidden?

%alt: could pass by environment variable? hmm but then
% external process not children of rio who wants to connect?
% will use mount anyway, and env var is anyway a fileserver in plan9
% so simpler to use /mnt/wsys for that too







\chapter{Graphical Windows}
\label{chap:graphical-windows}

% Graphical windows use /dev/draw (and /mnt/wsys/winname), /mnt/wsys/mouse.
% They do not write in /mnt/wsys/cons (instead they use 
%  stringxxx API from draw.h)
% they care optionally about /mnt/wsys/consctl and /mnt/wys/cons
%  for reading from the keyboard in "raw" mode.

\section{Graphical window setup}

% We say setup cos not really creation, since most of the time create first
% textual window and then setup things to become a graphical window
% (we will see later a way to create directly graphical window
%  with  /srv/rio.user.pid)

\subsection{[[initdraw()]]}

% regular graphical apps calls initdraw() in Graphics.nw.
% connect to /dev/draw and /mnt/wys/winname to get window to draw into.
% See Graphics.nw

\subsection{[[initmouse()]], mouse-open mode}

% graphical apps calls usually also initmouse() which open /mnt/wys/mouse.

% direct access to mouse events, no interpretation like cut/copy/paste
% menu as we will see in Section X.

% seen mouseopen attribute in core DS, quite important bool,
%  used by mousethread a lot to do different things
%bool mouseopen;

<<[[xfidopen()]] cases>>=
case Qmouse:
    if(w->mouseopen){
        filsysrespond(x->fs, x, &fc, Einuse);
        return;
    }
    w->mouseopen = true;

    /*
     * Reshaped: there's a race if the appl. opens the
     * window, is resized, and then opens the mouse,
     * but that's rare.  The alternative is to generate
     * a resized event every time a new program starts
     * up in a window that has been resized since the
     * dawn of time.  We choose the lesser evil.
     */
    w->resized = false;
    break;
@

% remember than xfidxxx are executed by xfid threads,
% and because of thread model of plan9, no race between
% winctl and xfid threads so safe to update the w fields!


<<[[xfidclose()]] cases>>=
case Qmouse:
    w->mouseopen = false;

    w->resized = false;
    if(w->i != nil)
        wsendctlmesg(w, Refresh, w->i->r, nil);
    break;
@
\l why Refresh ? when close the mouse?
% put Refresh here?




\subsection{[[initkeyboard()]], raw-access mode}

% not necessarily tied to graphical app, but strongly correlated.
% again, initkeyboard() in Graphics.nw.

% direct access to keyboard event, no interpretation of special navigation 
% key, buffered input, etc (actually have navigation key if mouse not opened
% even if raw mode)

% actually first thing initkeyboard does is to write
% rawon on /dev/consctl, see Graphics.ns

<<[[Window]] config fields>>=
bool	rawing;
@
%old: bool_byte
% actually abused as an int in if(w->rawing++ == 0) as one can write
% multiple rawon message on the consctl


<<[[xfidwrite()]] Qconsctl case>>=
if(strncmp(req->data, "rawon", 5)==0){
    <<[[xfidwrite()]] Qconsctl case, if rawon message and holding mode>>
    if(w->rawing++ == 0)
        wsendctlmesg(w, Rawon, ZR, nil);
    break;
}
if(strncmp(req->data, "rawoff", 6)==0 && w->rawing){
    if(--w->rawing == 0)
        wsendctlmesg(w, Rawoff, ZR, nil);
    break;
}
@
\l useful rawing increment? so can write rawon multiple times? meh

<<[[xfidclose()]] Qconsctl case, if rawing>>=
if(w->rawing){
    w->rawing = false;
    wsendctlmesg(w, Rawoff, ZR, nil);
}
@
% so automatic rawoff on close. Convenient for rio when exit
% that closes devices and restore to nice default.

<<[[Wctlmesgkind]] cases>>=
Rawon,
Rawoff,
@

<<[[wctlmesg()]] cases>>=
case Rawon:
    // already setup w->rawing in xfidwrite, nothing else todo
    break;
case Rawoff:
    <<[[wctlmesg()]] break if window was deleted>>
    <<[[wctlmesg()]] When Rawoff, process raw keys in non rawing mode>>
    break;
@



\section{Mouse events}

%alt: special APIs for graphical client to access mouse? that
% request directly to window manager?
% but then ugly? here transparent whether app run under rio or not!
% always use simply /dev/mouse!


\subsection{Mouse state queue}

<<[[Window]] mouse fields>>=
Mouseinfo	mouse;
@
% There is also Window.Mouse which is a ctl and moustate state.

<<struct [[Mouseinfo]]>>=
struct Mouseinfo
{
    // queue of mouse clicks and releases
    Mousestate	queue[16];

    // consumer
    int	ri;	/* read index into queue */
    // producer
    int	wi;	/* write index */

    bool	qfull;/* filled the queue; no more recording until client comes back */	
    <<[[Mouseinfo]] other fields>>
};	
@
%ocaml: use Queue.t, no need ri/wi, no need intermediate structure
%old: was uchar for qfull

<<[[Mouseinfo]] other fields>>=
ulong	counter;	/* serial no. of last mouse event we received */
ulong	lastcounter;/* serial no. of last mouse event sent to client */
@
% Need counter thing? not enough the ri != wi? or queue length?
% Because queue is just for clicks events! for move, we use just
% counter and give current state when read.
% Also because of resize where increment counter without
%  producing a thing in the queue?

<<[[Mouseinfo]] other fields>>=
int	lastb;	/* last button state we received */
@
% to record only mouse clicks or releases, need to know what
% was the previous state

% producer/consumer, classic.

<<struct [[Mousestate]]>>=
struct Mousestate
{
    Mouse;
    ulong	counter;	/* serial no. of mouse event */
};
@
%ocaml: no extra type, just use pair
% and actually counter field not needed here

\l why need counter in mousestate? because will be in queue
\l and can be used to decice if too old? does not seem used right now ...

\subsection{[[/mnt/wsys/mouse]]  reading part2}

% chain of event, read /mnt/wsys/mouse => ??
% start from actual click -> mousethread listening on
% channel conntected to ioproc reading /dev/mouse.
% -> winctl

\subsubsection{Producer}


% seen WMouse before

<<[[winctl()]] other locals>>=
Mousestate *mp;
int lastb = -1;
@
% mp = m producer, and m = m consumer (but cant use mc cos conflict
% with mouse control)

% received a mouse even from mousethread
<<[[winctl()]] WMouse case if mouseopen>>=
if(w->mouseopen) {
    w->mouse.counter++;

    /* queue click events */
    if(!w->mouse.qfull && lastb != w->mc.buttons) {	/* add to ring */

        //insert_queue(w->mc, w->mouse.queue)
        mp = &w->mouse.queue[w->mouse.wi];
        if(++w->mouse.wi == nelem(w->mouse.queue))
            w->mouse.wi = 0;
        if(w->mouse.wi == w->mouse.ri)
            w->mouse.qfull = true;
        mp->Mouse = w->mc;
        mp->counter = w->mouse.counter;

        lastb = w->mc.buttons;
    }
}
@
%ocaml: just use Queue.t, no need play with index
\l I dont think we need to pass the counter the xfidread

% circular buffer

% if same buttons, then no new event? so you dont get
% the mouse events when you move? but hello rio seems to follow
%  the mouse, so it gets the events?
% Yes! because the queue here is just for the clicks/unlick.
% for a move, the counter will be different and the read will just
% read the current state (see below).

\subsubsection{Consumer}
% Consumer and producer, like in a pipe

<<[[Wxxx]] cases>>=
WMouseread,
@


<<[[winctl()]] other locals>>=
Mousereadmesg mrm;
@
<<[[winctl()]] channels creation>>=
mrm.cm = chancreate(sizeof(Mouse), 0);
@
<<[[winctl()]] Wctl case, free channels if wctlmesg is Excited>>=
chanfree(mrm.cm);
@
%ocaml: no need extra structure, no need chanfree (let gc do it)

% if child process listening on mouseread, we can feed him
% stuff in our queue


<<[[winctl()]] alts setup>>=
alts[WMouseread].c = w->mouseread;
alts[WMouseread].v = &mrm;
alts[WMouseread].op = CHANSND;
@
%CHANSND here!! first time! 

<<[[winctl()]] alts adjustments>>=
if(w->mouseopen && w->mouse.counter != w->mouse.lastcounter)
    alts[WMouseread].op = CHANSND;
else
    alts[WMouseread].op = CHANNOP;
@
% prepare to send something if the mouse was opened and if there is
% something to send.
% Remember that adjustments are made inside the for loop, so
%  after each message has been processed, revisit the alts setting

% Why need to go through 2 stages with the channel?
%  anyway we queue mouse events and we look for counters,
%  so we could send directly? Maybe, but send what? the mouse state
%  at the sending time here may not be good for receiving time!


<<[[winctl()]] other locals>>=
Mousestate m;
@

<<[[winctl()]] event loop cases>>=
case WMouseread:
    /* send a queued event or, if the queue is empty, the current state */
    /* if the queue has filled, we discard all the events it contained. */
    /* the intent is to discard frantic clicking by the user during long latencies. */
    w->mouse.qfull = false;
    // if produced more than read
    if(w->mouse.wi != w->mouse.ri) {
        m = w->mouse.queue[w->mouse.ri];
        if(++w->mouse.ri == nelem(w->mouse.queue))
            w->mouse.ri = 0;
    } else
        m = (Mousestate){w->mc.Mouse, w->mouse.counter};

    w->mouse.lastcounter = m.counter;
    // consumed and relay
    send(mrm.cm, &m.Mouse);
    continue;
@



\section{Keyboard events}

\subsection{Raw keys queue}

<<[[Window]] graphical window fields>>=
// growing_array<Rune> (size = Window.nraw)
Rune		*raw;
uint		nraw;
@
%ocaml: just list, no need nraw

% graphical window & keyboard field

% In addition have runes from the text copied potentially by user
% with the mouse after the output point when use
% /dev/cons in non-raw mode.


\subsection{[[/mnt/wsys/cons]] reading part2}

\subsubsection{Producer}

% seen keyboard listening code already in section X.

% winctl -> <>
<<[[wkeyctl()]] if rawing>>=
if(w->rawing && (w->mouseopen || w->q0 == w->nr)){
    waddraw(w, &r, 1);
    return;
}
@
%old: I transposed the || arguments, clearer for now

% if rawing and graphical mode, then dont care about output pointer.

% faux ami, not a draw operation :) but w_add_raw

% nr? q0? q0 is where entered text go and nr is number of runes
% in growing rune array.

% but because can have raw mode also for textual window,
% in which case add rune (and no echo),
% otherwise the "when not rawing" section will happen


<<function [[waddraw]]>>=
void
waddraw(Window *w, Rune *r, int nr)
{
    w->raw = runerealloc(w->raw, w->nraw+nr);
    runemove(w->raw + w->nraw, r, nr);
    w->nraw += nr;
}
@
%ocaml: Queue.add

% realloc at each key press??


<<[[wctlmesg()]] When Rawoff, process raw keys in non rawing mode>>=
while(w->nraw > 0){
    wkeyctl(w, w->raw[0]);
    --w->nraw;
    runemove(w->raw, w->raw+1, w->nraw);
}
@
%ocaml: use queue

% when switch back from rawon to rawoff, we need to process
% back the raw keys as regular keys

% wkeyctl will not loop back to same code now that rawing has been
%  set off in xfidclose. It just feeds back the rune to 
%  regular textual window mode.



\subsubsection{Consumer}
% Consumer and producer, like in a pipe

<<[[Wxxx]] cases>>=
WCread, 
@

<<[[winctl()]] other locals>>=
Consreadmesg crm;
@

<<[[winctl()]] channels creation>>=
crm.c1 = chancreate(sizeof(Stringpair), 0);
crm.c2 = chancreate(sizeof(Stringpair), 0);
@
<<[[winctl()]] Wctl case, free channels if wctlmesg is Excited>>=
chanfree(crm.c1);
chanfree(crm.c2);
@
%ocaml: no need chanfree, no need intermediate type for pairs

% when have key, it's send to app that listen on /dev/cons,
% so we actually reemit here (what we have listened before on w->ck)
% hence the CHNSND! we write in their STDIN, we act as a relay between
% two entities, hence the two channels which is really kind of a pipe?


<<[[winctl()]] alts setup>>=
alts[WCread].c = w->consread;
alts[WCread].v = &crm;
alts[WCread].op = CHANSND;
@
% CHANSND!!


<<[[winctl()]] alts adjustments>>=
<<[[winctl()]] alts adjustments, if holding>>
else if((w->rawing && w->nraw>0) || npart)
    alts[WCread].op = CHANSND;
else{
    alts[WCread].op = CHANNOP;
    <<[[winctl()]] alts adjustments, revert to CHANSND if newline in queue>>
}
@
%old: I transposed again the || arguments, clearer to see raw first

% ready to send only if have stuff indeed to send!

% similar to Fid.rpart and Fid.nrpart, but this time
% on the side of the winctl, since it is the one who 


<<[[winctl()]] other locals>>=
Stringpair pair;
char *t;
int nb;
int i, c, wid;
@
% app is reading /dev/cons for bytes, not Rune.


% keys_out
<<[[winctl()]] event loop cases>>=
case WCread:
    recv(crm.c1, &pair);
    t = pair.s;
    nb = pair.ns;

    i = 0;
    <<[[winctl()]] when WCRead, copy in t previous partial rune bytes>>

    while(i<nb && (w->nraw > 0 || w->qh < w->nr)){

        // raw mode
        if(w->qh == w->nr){
            wid = runetochar(t+i, &w->raw[0]);
            w->nraw--;
            runemove(w->raw, w->raw+1, w->nraw);
        // buffered mode
        }else
            wid = runetochar(t+i, &w->r[w->qh++]);

        i += wid;
        <<[[winctl()]] when WCRead, break if newline and handle EOF character>>
        }
    }
    <<[[winctl()]] when WCRead, handle EOF character after while loop>>
    <<[[winctl()]] when WCRead, store overflow bytes of partial rune>>

    pair.s = t;
    pair.ns = i;
    send(crm.c2, &pair);
    continue;
@
%old: again I reverted some ||
\t aspectize buffered mode qh and nr

% Everything between output point and last rune is sent.
\t But not buffered? Yes, but will be ready for WCread only
% when a newline has been entered?

\subsubsection{Runes vs bytes, partial runes}
% this time not bytes vs runes but runes vs bytes (or other way around?)

% similar issue than in xfid where need store partial rune bytes

<<[[winctl()]] other locals>>=
char part[3]; // UTFMAX-1
int npart = 0;
@
% end of w->raw[] unprocessed last time

<<[[winctl()]] when WCRead, store overflow bytes of partial rune>>=
if(i > nb){
    npart = i-nb;
    memmove(part, t+nb, npart);
    i = nb;
}
@


<<[[winctl()]] when WCRead, copy in t previous partial rune bytes>>=
i = npart;
npart = 0;
if(i)
    memmove(t, part, i);
@





\section{Resize events}

% actually abuse the mouse device for that, a big ugly.
\l should have a /dev/resize, would be cleaner

<<[[xfidread()]] when Qmouse, adjust c for resize message if resized>>=
if(w->resized)
    c = 'r';
@

% also mounter.counter++ in wresize()


\section{[[/mnt/wsys/window]]}

% simple

<<[[qid]] cases>>=
Qwindow,
@
<<dirtab array elements>>=
{ "window",		QTFILE,	Qwindow,	0400 },
@


<<[[xfidread()]] other locals>>=
Image *i;
Rectangle r;
char buf[128];
char cbuf[30];
@
% 128 enough to read /dev/mouse, or header of image

<<[[xfidread()]] cases>>=
case Qwindow:
    i = w->i;
    if(i == nil || Dx(w->screenr)<=0){
        filsysrespond(x->fs, x, &fc, Enowindow);
        return;
    }
    r = w->screenr;
    /* fall through */

caseImage:
    if(off < 5*12){
        n = sprint(buf, "%11s %11d %11d %11d %11d ",
            chantostr(cbuf, view->chan),
            i->r.min.x, i->r.min.y, i->r.max.x, i->r.max.y);
        t = estrdup(buf);
        goto Text;
    }
    t = malloc(cnt);
    fc.data = t;
    n = readwindow(i, t, r, off, cnt);	/* careful; fc.count is unsigned */
    if(n < 0){
        buf[0] = '\0';
        errstr(buf, sizeof buf);
        filsysrespond(x->fs, x, &fc, buf);
    }else{
        fc.count = n;
        filsysrespond(x->fs, x, &fc, nil);
    }
    free(t);
    return;
@
\l could make a function case_image instead of using labels and goto.

<<function [[readwindow]]>>=
int
readwindow(Image *i, char *t, Rectangle r, int offset, int n)
{
    int ww, y;

    offset -= 5*12;
    ww = bytesperline(r, view->depth);
    r.min.y += offset/ww;
    if(r.min.y >= r.max.y)
        return 0;
    y = r.min.y + n/ww;
    if(y < r.max.y)
        r.max.y = y;
    if(r.max.y <= r.min.y)
        return 0;
    return unloadimage(i, r, (uchar*)t, n);
}
@







\chapter{Textual Windows}
\label{chap:textual-windows}

% The challenge is that we don't want to change all our command-line apps
% to do some drawtext() ... we want backward compatibility; some
% kind of emulation! (and with more services thx to the mouse!)

% it's relatively easy to have an xterm under plan9
% thx to the virtual /dev/cons

% In fact terminal emulator can provide more services! select text
% with mouse, copy paste. This means that can insert text at arbitrary
% places, not just after output, so need keep track of those "cursors".

%https://www.destroyallsoftware.com/talks/a-whole-new-world

% terminal emulator has a lot in common with an editor.
% Code of efuns is similar for many things.

\l put most stuff of libframe in appendix

% so many new terminals in recent years:
% - yaft https://github.com/uobikiemukot/yaft
% - alacritty terminal in rust using opengl
%   https://github.com/jwilm/alacritty
% - kitty also opengl based terminal
% - ...

% https://github.com/k4m4/terminals-are-sexy

\section{Textual window creation}
\n parallel with 'Graphical window setup

% FIGURE again with qh, q0, q1, nr, maxr
% The model.

% FIGURE scrollbar, frame, org (and nchars)
% The view.

% Saw window creation section before. Some additional setup
% for textual windows we skipped.

<<[[wmk()]] textual window settings>>=
<<[[wmk()]] textual window settings, set scrollbar>>
<<[[wmk()]] textual window settings, set frame>>

r = insetrect(w->i->r, Selborder);
draw(w->i, r, cols[BACK], nil, w->frm.entire.min);
@
%ocaml: separate in different terminal.ml module instead of window.alloc
\t entire is a frame property, set by frinit(), but seems
\t  to be equal to r, and anyway it's sp and src is a color
\t  so what's the point of this last argument? why not ZP?
\t also why need to draw that? anyway first repaint will erase that

% will see cols soon

% not mentionned is Window.r, nr, maxr, which are initialized
% to 0 by emalloc(sizeof(Window)) in wmk().
% might be nice to initialize them explicitly to nil or 0
% and say winsert will do first alloc.

\subsection{Scrollbar}

% saw Window.scrollr in core DS

<<[[wmk()]] textual window settings, set scrollbar>>=
r = insetrect(w->i->r, Selborder+1);
w->scrollr = r;
w->scrollr.max.x = r.min.x+Scrollwid;
@

<<constants Scrollxxx>>=
Scrollwid 		= 12,	/* width of scroll bar */
@
%ocaml: use better name, so no need comment
\n could also put that in Scrolling section later, but then
\n force to split wmk too much I think

% related to scrollbar is autoscroll
<<[[wmk()]] textual window settings>>=
w->scrolling = scrolling; // autoscroll
@

% will see scrollbar code at the end. 

\subsection{Frame}
\l bad name frame

% saw Window.frm in core DS

<<[[wmk()]] textual window settings, set frame>>=
r = insetrect(w->i->r, Selborder+1);
r.min.x += Scrollwid+Scrollgap;
frinit(&w->frm, r, font, i, cols);
<<[[wmk()]] textual window settings, extra frame settings>>
@
%old: I repeated the insetrect so easier to aspectize
%ocaml: no need to repeat, because construct new rectangle each time
% so no side effect on r when set scrollr

<<constants Scrollxxx>>=
Scrollgap 		= 4,	/* gap right of scroll bar */
@

% will see frinit soon



\section{Frame widget}
\label{sec:frame-widget}
\t maybe write a simplified text widget like I did for rio-in-ocaml
\t  and then put more complex one in appendix!


% text widget really. in Gtk it's called the TextEditor even?
% In Efuns we use the same term though:
%   "a frame: a view of a buffer for a window"

% frame(2)
% used by rio and sam, factorize code for Editable Text (widget)
% mv in Widgets.nw?

% It is actually not what is around the window. Bad name.
% Rename maybe TextWidget?

% Complex library. Why need that? Can't simply print lines of text?
% Libframe handles tabs, fold long lines, handle mouse selection,
% can insert and delete anywhere and adjust chars around.
% Also handle unicode with possible variable-size chars (but
% do that efficiently by storing widths in boxes).
%ocaml: but should be simpler. code of frinsert is really long.

\subsection{[[Frame]]}

<<struct [[Frame]]>>=
struct Frame
{
    Image	*b;		    /* on which frame appears */
    Rectangle	r;		/* in which text appears */

    Font	*font;		/* of chars in the frame */
    Display	*display;	/* on which frame appears */

    <<[[Frame]] colors>>
    <<[[Frame]] text fields>>
    <<[[Frame]] tick fields>>
    <<[[Frame]] box fields>>
    <<[[Frame]] scroll>>

    <<[[Frame]] other fields>>
};
@
% the actual content is in the englobing data structure (e.g., Window.r)
\l remove display? redundant with b->display anyway
\l rename b to img?


% important field, nchars.
<<[[Frame]] text fields>>=
ushort	nchars;		/* # runes in frame */
@
% FIGURE ? vs org?

<<[[Frame]] text fields>>=
ushort	nlines;		/* # lines with text */
@
% will be maintained by? frinsert and frdelete?



\subsection{[[frinit()]]}

% libframe/
% ... -> new -> wmk() -> <>
<<function [[frinit]]>>=
void
frinit(Frame *f, Rectangle r, Font *ft, Image *b, Image *cols[NCOL])
{
    frsetrects(f, r, b);
    f->font = ft;
    f->display = b->display;

    f->nchars = 0;
    f->nlines = 0;
    <<[[frinit()]] initialize other fields>>
}
@
%old: I reoredered some lines

<<function [[frsetrects]]>>=
void
frsetrects(Frame *f, Rectangle r, Image *b)
{
    f->b = b;
    f->entire = r;
    f->r = r;
    f->r.max.y -= (r.max.y-r.min.y) % f->font->height;
    f->maxlines = (r.max.y-r.min.y) / f->font->height;
}
@
%old: I reoredered a bit again
\l could use Dy

% adjust r to not write on last line that may not contain enough
% pixels for a full height (hence the modulo)

<<[[Frame]] text fields>>=
ushort	maxlines;	/* total # lines in frame */
@

<<[[Frame]] other fields>>=
Rectangle	entire;		/* of full frame */
@
\l why need entire and r? r not enough?


%\subsection{[[frclear()]]}

% called when Exited

<<function [[frclear]]>>=
void
frclear(Frame *f, bool freeall)
{
    <<[[frclear()]] free boxes>>
    <<[[frclear()]] free ticks>>
}
@
%old: I reordered lines, more logical



\subsection{Frame colors}

<<[[Frame]] colors>>=
Image	*cols[NCOL];	/* text and background colors */
@
%ocaml: pass colors to repaint_content function instead


% properties
<<enum [[_anon_ (include/frame.h)]]>>=
enum FrameColors {
    BACK, // Background
    HIGH, // Background highlighted text
    BORD, // Border
    TEXT, // Text
    HTEXT, // Highlited text

    NCOL
};
@
\l rename enums? use full word?
\t Bord is not the same that window border?
%ocaml: full color names and use record

% images/colors for the frame
<<global [[cols]]>>=
// map<Property, Color>
static	Image	*cols[NCOL];
@
% note that this cols will sometimes be altered when unselect a terminal
%  window so the main text becomes grey for example

% cols global is passed to frinit() in wmk()

<<[[frinit()]] initialize other fields>>=
if(cols != nil)
    memmove(f->cols, cols, sizeof f->cols);
@


<<[[wmk()]] colors initialisation>>=
if(cols[0] == nil){
    cols[BACK] = display->white;
    cols[HIGH] = allocimage(display, Rect(0,0,1,1), CMAP8, true, 0xCCCCCCFF);
    cols[BORD] = allocimage(display, Rect(0,0,1,1), CMAP8, true, 0x999999FF);
    cols[TEXT] = display->black;
    cols[HTEXT] = display->black;
    <<[[wmk()]] extra colors initialisation>>
);
}
@
% the cols will be inverted at some point, this is why
% store cols array in Frame and not use globals.


% ?? -> wrepaint
<<[[wrepaint()]] update cols>>=
wsetcols(w);
@


% wrepaint | ... -> <>
<<function [[wsetcols]]>>=
void
wsetcols(Window *w)
{
    <<[[wsetcols()]] if holding>>
    else
        if(w == input)
            w->frm.cols[TEXT] = w->frm.cols[HTEXT] = display->black;
        else
            w->frm.cols[TEXT] = w->frm.cols[HTEXT] = darkgrey;
}
@
%ocaml: pass set of colors to drawing function instead of modifying fields
% and just store is_selected in Terminal. Only necessary field.

% invert color, but who then redraw the content?

<<global [[darkgrey]]>>=
static	Image	*darkgrey;
@
% used for alternative BACK
<<[[wmk()]] extra colors initialisation>>=
/* greys are multiples of 0x11111100+0xFF, 14* being palest */
darkgrey = allocimage(display, Rect(0,0,1,1), CMAP8, true, 0x666666FF);
@

%dead:
%<<global grey>>
%static	Image	*grey;
%@
%<<[[wmk()]] extra colors initialisation>>
%grey     = allocimage(display, Rect(0,0,1,1), CMAP8, true, 0xEEEEEEFF);

% will see far later the code using those cols[]



\subsection{Frame tick}

<<[[Frame]] tick fields>>=
Image	*tick;	/* typing tick */
Image	*tickback;	/* saved image under tick */
@
%ocaml: if use painter model where draw each time from scratch
% on top of each other, then no need tickback

<<[[Frame]] tick fields>>=
bool	ticked;	/* flag: is tick onscreen? */
@
% when selection with mouse, then no tick

<<[[frinit()]] initialize other fields>>=
if(f->tick == nil && f->cols[BACK] != nil)
    frinittick(f);
@
%ocaml: Common.once

<<constant [[FRTICKW]]>>=
#define	FRTICKW	3
@
%fr tick width


<<function [[frinittick]]>>=
void
frinittick(Frame *f)
{
    Image *b = f->display->screenimage;
    Font *ft = f->font;

    <<[[frinittick()]] free old tick>>
    f->tick = allocimage(f->display, Rect(0, 0, FRTICKW, ft->height), b->chan, 0, DWhite);
    <<[[frinittick()]] sanity check tick>>
    <<[[frinittick()]] free old tickback>>
    f->tickback = allocimage(f->display, f->tick->r, b->chan, false, DWhite);
    <<[[frinittick()]] sanity check tickback>>
    /* background color */
    draw(f->tick, f->tick->r, f->cols[BACK], nil, ZP);
    /* vertical line */
    draw(f->tick, Rect(FRTICKW/2, 0, FRTICKW/2+1, ft->height), f->cols[TEXT], nil, ZP);
    /* box on each end */
    draw(f->tick, Rect(0, 0, FRTICKW, FRTICKW), f->cols[TEXT], nil, ZP);
    draw(f->tick, Rect(0, ft->height-FRTICKW, FRTICKW, ft->height), f->cols[TEXT], nil, ZP);
}
@
%old: put assign with decl for b and ft
%ocaml: Common.once

% FIGURE screenshot

<<[[frinittick()]] free old tick>>=
if(f->tick)
    freeimage(f->tick);
@
<<[[frinittick()]] sanity check tick>>=
if(f->tick == nil)
    return;
@
%ocaml: exn at least?
<<[[frinittick()]] free old tickback>>=
if(f->tickback)
    freeimage(f->tickback);
@
<<[[frinittick()]] sanity check tickback>>=
if(f->tickback == nil){
    freeimage(f->tick);
    f->tick = nil;
    return;
}
@


<<[[frclear()]] free ticks>>=
if(freeall){
    freeimage(f->tick);
    freeimage(f->tickback);
    f->tick = nil;
    f->tickback = nil;
}
f->ticked = false;
@
%ocaml: Gc

\subsection{Frame boxes}

<<[[Frame]] box fields>>=
// growing_array<Frbox> (size = nalloc, unused after nbox)
Frbox	*box;
ushort	nbox;
ushort nalloc;
@

<<[[frinit()]] initialize other fields>>=
f->box = nil;
f->nbox = 0;
f->nalloc = 0;
@


\subsubsection{[[Frbox]]}

<<struct [[Frbox]]>>=
struct Frbox
{
    long		wid;		/* in pixels */

    long		nrune;		/* <0 ==> negate and treat as break char */
    union{
        // array<byte> UTF8?
        uchar	*ptr;
        struct{
            short	bc;	/* break char */
            short	minwid;
        };
    };
};
@
%ocaml: proper ADT instead of abuse negative integer for nrune
\l ugly to use short for bc. Why not simply char? or Rune!

% example of boxes?
% - foo
% - \n
% - \b?
% - artificial break?

% minwid?

% store wid so can know if overflow and need split box.
% store if special char, e.g. newline or artificial break?

<<function [[NRUNE]]>>=
#define	NRUNE(b)	((b)->nrune < 0 ? 1 : (b)->nrune)
@

\subsubsection{Adding boxes}

<<constant [[SLOP]]>>=
#define	SLOP	25
@

<<function [[_fraddbox]]>>=
void
_fraddbox(Frame *f, int bn, int n)	/* add n boxes after bn, shift the rest up,
                 * box[bn+n]==box[bn] */
{
    int i;

    <<[[_fraddbox()]] sanity check bn>>
    if(f->nbox+n > f->nalloc)
        _frgrowbox(f, n+SLOP);
    for(i=f->nbox; --i>=bn; )
        f->box[i+n] = f->box[i];
    f->nbox+=n;
}
@

<<function [[_frgrowbox]]>>=
void
_frgrowbox(Frame *f, int delta)
{
    f->nalloc += delta;
    f->box = realloc(f->box, f->nalloc*sizeof(Frbox));
    <<[[_frgrowbox()]] sanity check box>>
}
@


<<[[_fraddbox()]] sanity check bn>>=
if(bn > f->nbox)
    drawerror(f->display, "_fraddbox");
@
<<[[_frgrowbox()]] sanity check box>>=
if(f->box == nil)
    drawerror(f->display, "_frgrowbox");
@

\subsubsection{Free boxes}

<<[[frclear()]] free boxes>>=
if(f->nbox)
    _frdelbox(f, 0, f->nbox-1);
if(f->box)
    free(f->box);
f->box = nil;
@

<<function [[_frdelbox]]>>=
void
_frdelbox(Frame *f, int n0, int n1)	/* inclusive */
{
    <<[[_frdelbox()]] sanity check n0 and n1>>
    _frfreebox(f, n0, n1);
    _frclosebox(f, n0, n1);
}
@

<<function [[_frfreebox]]>>=
void
_frfreebox(Frame *f, int n0, int n1)	/* inclusive */
{
    int i;

    <<[[_frfreebox()]] sanity check n0 and n1>>
    n1++;
    for(i=n0; i<n1; i++)
        if(f->box[i].nrune >= 0)
            free(f->box[i].ptr);
}
@


<<function [[_frclosebox]]>>=
void
_frclosebox(Frame *f, int n0, int n1)	/* inclusive */
{
    int i;

    <<[[_frclosebox()]] sanity check n0 and n1>>
    n1++;
    for(i=n1; i<f->nbox; i++)
        f->box[i-(n1-n0)] = f->box[i];
    f->nbox -= n1-n0;
}
@



<<[[_frdelbox()]] sanity check n0 and n1>>=
if(n0>=f->nbox || n1>=f->nbox || n1<n0)
    drawerror(f->display, "_frdelbox");
@
<<[[_frfreebox()]] sanity check n0 and n1>>=
if(n1<n0)
    return;
if(n0>=f->nbox || n1>=f->nbox)
    drawerror(f->display, "_frfreebox");
@
<<[[_frclosebox()]] sanity check n0 and n1>>=
if(n0>=f->nbox || n1>=f->nbox || n1<n0)
    drawerror(f->display, "_frclosebox");
@

\subsection{Frame strings}

<<constant CHUNK (windows/libframe/frstr.c)>>=
#define	CHUNK	16
@

<<function [[ROUNDUP]]>>=
#define	ROUNDUP(n)	((n+CHUNK)&~(CHUNK-1))
@

<<function [[_frallocstr]]>>=
uchar *
_frallocstr(Frame *f, unsigned n)
{
    uchar *p;

    p = malloc(ROUNDUP(n));
    if(p == nil)
        drawerror(f->display, "out of memory");
    return p;
}
@

<<function [[_frinsure]]>>=
void
_frinsure(Frame *f, int bn, unsigned n)
{
    Frbox *b;
    uchar *p;

    b = &f->box[bn];
    if(b->nrune < 0)
        drawerror(f->display, "_frinsure");
    if(ROUNDUP(b->nrune) > n)	/* > guarantees room for terminal NUL */
        return;
    p = _frallocstr(f, n);
    b = &f->box[bn];
    memmove(p, b->ptr, NBYTE(b)+1);
    free(b->ptr);
    b->ptr = p;
}
@


\subsection{Frame rune position, point, and box number}

% have:
%  - type position_text (e.g., q0) (ulong)
%  - type for position_frame (ulong)
%  - type for boxnumber (ushort)
%  - type position_point (Point.t)
\l should use typedef

% p = position_rune, bn = box number, pt = point

\subsubsection{[[frptofchar()]]}

% Frame point of p'th rune (point is upper left corner of rune)
<<function [[frptofchar]]>>=
Point
frptofchar(Frame *f, ulong p)
{
    return _frptofcharptb(f, p, f->r.min, 0);
}
@

<<function [[_frptofcharptb]]>>=
Point
_frptofcharptb(Frame *f, ulong p, Point pt, int bn)
{
    Frbox *b;
    uchar *s;
    int w, l;
    Rune r;

    for(b = &f->box[bn]; bn<f->nbox; bn++,b++){
        _frcklinewrap(f, &pt, b);
        l=NRUNE(b);
        // p is in this box
        if(p < l){
            if(b->nrune > 0)
                for(s=b->ptr; p>0; s+=w, p--){
                    r = *s;
                    if(r < Runeself)
                        w = 1;
                    else
                        w = chartorune(&r, (char*)s);
                    pt.x += stringnwidth(f->font, (char*)s, 1);
                    <<[[_frptofcharptb()]] sanity check r and pt>>
                }
            break; // found it
        }
        // else
        p -= l;
        _fradvance(f, &pt, b);
    }
    return pt;
}
@
\l ugly break, should use if then else

%\subsubsection{[[_fradvance()]]}

<<function [[_fradvance]]>>=
void
_fradvance(Frame *f, Point *p, Frbox *b)
{
    if(b->nrune<0 && b->bc=='\n'){
        p->x = f->r.min.x;
        p->y += f->font->height;
    }else
        p->x += b->wid;
}
@

% see advantage of boxes here, already computed wid and know where breaks are

<<[[_frptofcharptb()]] sanity check r and pt>>=
if(r==0 || pt.x > f->r.max.x)
    drawerror(f->display, "frptofchar");
@

%\subsubsection{[[_frcklinewrap()]]}

<<function [[_frcklinewrap]]>>=
void
_frcklinewrap(Frame *f, Point *p, Frbox *b)
{
    if((b->nrune<0? b->minwid : b->wid) > f->r.max.x - p->x){
        p->x = f->r.min.x;
        p->y += f->font->height;
    }
}
@
% so not a box for artificial break? just have to check each time
% if box overflow?

<<function [[_frcklinewrap0]]>>=
void
_frcklinewrap0(Frame *f, Point *p, Frbox *b)
{
    if(_frcanfit(f, *p, b) == 0){
        p->x = f->r.min.x;
        p->y += f->font->height;
    }
}
@

% return int option, 0 = None
<<function [[_frcanfit]]>>=
int
_frcanfit(Frame *f, Point pt, Frbox *b)
{
    int left, w, nr;
    uchar *p;
    Rune r;

    left = f->r.max.x - pt.x;
    if(b->nrune < 0)
        return b->minwid <= left;
    if(left >= b->wid)
        return b->nrune;
    for(nr=0,p=b->ptr; *p; p+=w,nr++){
        r = *p;
        if(r < Runeself)
            w = 1;
        else
            w = chartorune(&r, (char*)p);
        left -= stringnwidth(f->font, (char*)p, 1);
        if(left < 0)
            return nr;
    }
    drawerror(f->display, "_frcanfit can't");
    return 0;
}
@




% frptofchar bounded by nb boxes.
\l when want to do bounded search?

<<function [[_frptofcharnb]]>>=
Point
_frptofcharnb(Frame *f, ulong p, int nb)	/* doesn't do final _fradvance to next line */
{
    Point pt;
    int nbox;

    // save
    nbox = f->nbox;
    f->nbox = nb;
    pt = _frptofcharptb(f, p, f->r.min, 0);
    // restore
    f->nbox = nbox;
    return pt;
}
@
\l why not call directly frptofchar?

\subsubsection{[[frcharofpt()]]}

<<function [[frcharofpt]]>>=
ulong
frcharofpt(Frame *f, Point pt)
{
    Point qt;
    int w;
    uchar *s;
    Frbox *b;
    int bn;
    ulong p;
    Rune r;

    pt = _frgrid(f, pt);

    qt = f->r.min;
    // find the line
    for(b=f->box, bn=0, p=0; bn < f->nbox && qt.y < pt.y; bn++,b++){
        _frcklinewrap(f, &qt, b);
        if(qt.y >= pt.y)
            break;
        _fradvance(f, &qt, b);
        p += NRUNE(b);
    }
    // find the box in the line
    for(; bn<f->nbox && qt.x<=pt.x; bn++,b++){
        _frcklinewrap(f, &qt, b);
        if(qt.y > pt.y)
            break;
        if(qt.x + b->wid > pt.x){
            if(b->nrune < 0)
                _fradvance(f, &qt, b);
            else{
                s = b->ptr;
                for(;;){
                    if((r = *s) < Runeself)
                        w = 1;
                    else
                        w = chartorune(&r, (char*)s);
                    <<[[frcharofpt()]] sanity check r>>
                    qt.x += stringnwidth(f->font, (char*)s, 1);
                    s += w;
                    if(qt.x > pt.x)
                        break;
                    p++;
                }
            }
        }else{
            p += NRUNE(b);
            _fradvance(f, &qt, b);
        }
    }
    return p;
}
@

<<function [[_frgrid]]>>=
static
Point
_frgrid(Frame *f, Point p)
{
    p.y -= f->r.min.y;
    p.y -= p.y%f->font->height;
    p.y += f->r.min.y;
    if(p.x > f->r.max.x)
        p.x = f->r.max.x;
    return p;
}
@

<<[[frcharofpt()]] sanity check r>>=
if(r == 0)
    drawerror(f->display, "end of string in frcharofpt");
@

\subsubsection{[[_frdrawtext()]]}

% the simple to draw text, just draw the boxes

% frinsert -> <>
<<function [[_frdrawtext]]>>=
void
_frdrawtext(Frame *f, Point pt, Image *text, Image *back)
{
    Frbox *b;
    int nb;
    static int x;

    for(nb=0,b=f->box; nb<f->nbox; nb++, b++){
        _frcklinewrap(f, &pt, b);
        if(b->nrune >= 0){
            stringbg(f->b, pt, text, ZP, f->font, (char*)b->ptr, back, ZP);
        }
        pt.x += b->wid;
    }
}
@

\subsection{Frame selection}

<<[[Frame]] text fields>>=
ulong	p0, p1;		/* selection */
@
% equivalent of q0 and q1 but translated to frame origin

<<[[frinit()]] initialize other fields>>=
f->p0 = 0;
f->p1 = 0;
@


\section{Content modification}

% Saw Window.r, Window.nr, maxr in core DS chapter.
% Also Window.q0, Window.org, Window.qh

% FIGURE again

% all are "text cursors", so when insert a char
% in the ext, have to update those pointers, shift then by 1 too.
% (See Efuns.nw)

% A bit like in Efuns.nw, except even simpler than gap buffer ...
% when insert, runemove everytime. Fortunatnely terminal
% usually updated at the very end, not in the middle, so it's ok.

% return q0 but might have been modified since winsert
%  can get rid of some lines when too much memory space is used

% will see later this code when type on a key:
<<simplified code when entered a single rune [[r]] in a terminal>>=
winsert(w, &r, 1, w->q0);
wshow(w, w->q0);
@
% note that winsert (might) adjust w->q0!

% so key functions are winsert and wshow!

% Note that at beginning, q0, qh, org, ... are all set to 0.


\subsection{[[winsert()]]}

% wkeyctl -> <>
<<function [[winsert]]>>=
uint
winsert(Window *w, Rune *r, int n, uint q0)
{
    uint m;

    <<[[winsert()]] sanity check n>>
    <<[[winsert()]] if size of rune array is getting really big>>
    <<[[winsert()]] grow rune array if reach maxr>>

    // move to the right the runes after the cursor q0 to make some space
    runemove(w->r + q0 + n, w->r + q0, w->nr - q0);
    // fill the space
    runemove(w->r + q0, r, n);
    w->nr += n;

    <<[[winsert()]] adjust cursors>>

    return q0;
}
@

%example:
% so first time type a key, what happens? 
% n = 1, r points just to one rune, org = 0, nr = 0, q0 = 0
% So first runemove does nothing, then fill r and increment nr


<<[[winsert()]] adjust cursors>>=
/* if output touches, advance selection, not qh; works best for keyboard and output */
if(q0 <= w->q0)
    w->q0 += n; // move the q0 cursor
if(q0 <= w->q1)
    w->q1 += n;
if(q0 < w->qh)
    w->qh += n;

if(q0 < w->org)
    w->org += n;
else
   <<[[winsert()]] when [[q0 >= w->org]], possibly update visible text>>
@

%examlple: so w->q0 will be incremented by 1 but org and qh
% will not change.

% subtle <= vs < for qh. So when type character after
% output point or on output point, then output point stays the same!

% same way if insert at org point, then org point does not change

% adjust cursors


<<[[winsert()]] sanity check n>>=
if(n == 0)
    return q0;
@
\l when called with 0?

% See also Efuns.nw?

\subsection{Growing array}

<<enum [[_anon_ (windows/rio/wind.c)]]>>=
enum
{
    HiWater	= 640000,	/* max size of history */
    LoWater	= 400000,	/* min size of history after max'ed */
    MinWater	= 20000,	/* room to leave available when reallocating */
};
@

<<[[winsert()]] grow rune array if reach maxr>>=
if(w->nr+n > w->maxr){
    /*
     * Minimize realloc breakage:
     *	Allocate at least MinWater
     * 	Double allocation size each time
     *	But don't go much above HiWater
     */
    m = max(min(2*(w->nr+n), HiWater), w->nr+n)+MinWater;
    if(m > HiWater)
        m = max(HiWater+MinWater, w->nr+n);
    if(m > w->maxr){
        w->r = runerealloc(w->r, m);
        w->maxr = m;
    }
}
@
% realloc


<<[[winsert()]] if size of rune array is getting really big>>=
if(w->nr + n > HiWater && q0 >= w->org && q0 >= w->qh){
    m = min(HiWater-LoWater, min(w->org, w->qh));
    w->org -= m;
    w->qh -= m;
    if(w->q0 > m)
        w->q0 -= m;
    else
        w->q0 = 0;
    if(w->q1 > m)
        w->q1 -= m;
    else
        w->q1 = 0;
    w->nr -= m;
    runemove(w->r, w->r+m, w->nr);
    q0 -= m;
}
@
% getting rid of some lines


\section{Content rendering}

\subsection{[[frinsert()]]}

<<[[winsert()]] when [[q0 >= w->org]], possibly update visible text>>=
if(q0 <= w->org + w->frm.nchars)
    frinsert(&w->frm, r, r+n, q0 - w->org); // echo back
@
%ocaml: redraw from scratch model instead, far far simpler!

% so if between w->org and w->org + w->frm.nchars

%example: q0 is equal to org and nchars is 0 so 
% condition is true at first.

% insert runes in frame (r, r+n), and translate position to origin
% (here 0 because q0 == w->org)


<<global [[frame]]>>=
static Frame		frame;
@

<<struct [[points_frinsert]]>>=
struct points_frinsert {
    Point pt0, pt1;
};
@

<<[[frinsert()]] locals>>=
Point pt0, pt1, opt0, ppt0, ppt1, pt;
Frbox *b;
int n, n0, nn0, y;
ulong cn0;
Image *col;
Rectangle r;
static struct points_frinsert *pts;
static int nalloc=0;
int npts;
@

<<constant [[DELTA]]>>=
#define	DELTA	25
@

<<function [[frinsert]]>>=
void
frinsert(Frame *f, Rune *sp, Rune *ep, ulong p0)
{
    <<[[frinsert()]] locals>>

    if(p0>f->nchars || sp==ep || f->b==nil)
        return;

    n0 = _frfindbox(f, 0, 0, p0);
    cn0 = p0;
    nn0 = n0;
    pt0 = _frptofcharnb(f, p0, n0);
    ppt0 = pt0;
    opt0 = pt0;
    pt1 = bxscan(f, sp, ep, &ppt0);
    ppt1 = pt1;

    if(n0 < f->nbox){
        b = &f->box[n0];
        _frcklinewrap(f, &pt0, b);	/* for frdrawsel() */
        _frcklinewrap0(f, &ppt1, b);
    }
    f->modified = true;
    /*
     * ppt0 and ppt1 are start and end of insertion as they will appear when
     * insertion is complete. pt0 is current location of insertion position
     * (p0); pt1 is terminal point (without line wrap) of insertion.
     */

    <<[[frinsert()]] remove tick>>

    /*
     * Find point where old and new x's line up
     * Invariants:
     *	pt0 is where the next box (b, n0) is now
     *	pt1 is where it will be after the insertion
     * If pt1 goes off the rectangle, we can toss everything from there on
     */
    for(b = &f->box[n0],npts=0;
         pt1.x!=pt0.x && pt1.y!=f->r.max.y && n0<f->nbox; b++,n0++,npts++){
        _frcklinewrap(f, &pt0, b);
        _frcklinewrap0(f, &pt1, b);
        if(b->nrune > 0){
            n = _frcanfit(f, pt1, b);
            <<[[frinsert()]] sanity check n canfit>>
            if(n != b->nrune){
                _frsplitbox(f, n0, n);
                b = &f->box[n0];
            }
        }
        if(npts == nalloc){
            pts = realloc(pts, (npts+DELTA)*sizeof(pts[0]));
            nalloc += DELTA;
            b = &f->box[n0];
        }
        pts[npts].pt0 = pt0;
        pts[npts].pt1 = pt1;
        /* has a text box overflowed off the frame? */
        if(pt1.y == f->r.max.y)
            break;
        _fradvance(f, &pt0, b);
        pt1.x += _frnewwid(f, pt1, b);
        cn0 += NRUNE(b);
    }
    if(pt1.y > f->r.max.y)
        drawerror(f->display, "frinsert pt1 too far");
    if(pt1.y==f->r.max.y && n0<f->nbox){
        f->nchars -= _frstrlen(f, n0);
        _frdelbox(f, n0, f->nbox-1);
    }
    if(n0 == f->nbox)
        f->nlines = (pt1.y-f->r.min.y)/f->font->height+(pt1.x>f->r.min.x);
    else if(pt1.y!=pt0.y){
        int q0, q1;

        y = f->r.max.y;
        q0 = pt0.y+f->font->height;
        q1 = pt1.y+f->font->height;
        f->nlines += (q1-q0)/f->font->height;
        if(f->nlines > f->maxlines)
            chopframe(f, ppt1, p0, nn0);
        if(pt1.y < y){
            r = f->r;
            r.min.y = q1;
            r.max.y = y;
            if(q1 < y)
                draw(f->b, r, f->b, nil, Pt(f->r.min.x, q0));
            r.min = pt1;
            r.max.x = pt1.x+(f->r.max.x-pt0.x);
            r.max.y = q1;
            draw(f->b, r, f->b, nil, pt0);
        }
    }
    /*
     * Move the old stuff down to make room.  The loop will move the stuff
     * between the insertion and the point where the x's lined up.
     * The draw()s above moved everything down after the point they lined up.
     */
    for((y=pt1.y==f->r.max.y?pt1.y:0),b = &f->box[n0-1]; --npts>=0; --b){
        pt = pts[npts].pt1;
        if(b->nrune > 0){
            r.min = pt;
            r.max = r.min;
            r.max.x += b->wid;
            r.max.y += f->font->height;
            draw(f->b, r, f->b, nil, pts[npts].pt0);
            /* clear bit hanging off right */
            if(npts==0 && pt.y>pt0.y){
                /*
                 * first new char is bigger than first char we're
                 * displacing, causing line wrap. ugly special case.
                 */
                r.min = opt0;
                r.max = opt0;
                r.max.x = f->r.max.x;
                r.max.y += f->font->height;
                if(f->p0<=cn0 && cn0<f->p1)	/* b+1 is inside selection */
                    col = f->cols[HIGH];
                else
                    col = f->cols[BACK];
                draw(f->b, r, col, nil, r.min);
            }else if(pt.y < y){
                r.min = pt;
                r.max = pt;
                r.min.x += b->wid;
                r.max.x = f->r.max.x;
                r.max.y += f->font->height;
                if(f->p0<=cn0 && cn0<f->p1)	/* b+1 is inside selection */
                    col = f->cols[HIGH];
                else
                    col = f->cols[BACK];
                draw(f->b, r, col, nil, r.min);
            }
            y = pt.y;
            cn0 -= b->nrune;
        }else{
            r.min = pt;
            r.max = pt;
            r.max.x += b->wid;
            r.max.y += f->font->height;
            if(r.max.x >= f->r.max.x)
                r.max.x = f->r.max.x;
            cn0--;
            if(f->p0<=cn0 && cn0<f->p1)	/* b is inside selection */
                col = f->cols[HIGH];
            else
                col = f->cols[BACK];
            draw(f->b, r, col, nil, r.min);
            y = 0;
            if(pt.x == f->r.min.x)
                y = pt.y;
        }
    }
    /* insertion can extend the selection, so the condition here is different */
    if(f->p0<p0 && p0<=f->p1)
        col = f->cols[HIGH];
    else
        col = f->cols[BACK];

    frselectpaint(f, ppt0, ppt1, col);

    _frdrawtext(&frame, ppt0, f->cols[TEXT], col);

    _fraddbox(f, nn0, frame.nbox);
    for(n=0; n<frame.nbox; n++)
        f->box[nn0+n] = frame.box[n];
    if(nn0>0 && f->box[nn0-1].nrune>=0 && ppt0.x-f->box[nn0-1].wid>=f->r.min.x){
        --nn0;
        ppt0.x -= f->box[nn0].wid;
    }
    n0 += frame.nbox;
    _frclean(f, ppt0, nn0, n0<f->nbox-1? n0+1 : n0);

    f->nchars += frame.nchars;
    if(f->p0 >= p0)
        f->p0 += frame.nchars;
    if(f->p0 > f->nchars)
        f->p0 = f->nchars;
    if(f->p1 >= p0)
        f->p1 += frame.nchars;
    if(f->p1 > f->nchars)
        f->p1 = f->nchars;

    <<[[frinsert()]] draw tick>>
}
@

<<[[frinsert()]] sanity check n canfit>>=
if(n == 0)
    drawerror(f->display, "_frcanfit==0");
@

<<[[Frame]] text fields>>=
bool	modified;	/* changed since frselect() */
@
%old: was ushort


\subsubsection{[[_frfindbox()]]}

<<function [[_frfindbox]]>>=
/* find box containing q and put q on a box boundary */
int
_frfindbox(Frame *f, int bn, ulong p, ulong q)	
{
    Frbox *b;

    for(b = &f->box[bn]; bn < f->nbox && p+NRUNE(b) <= q; bn++, b++)
        p += NRUNE(b);
    if(p != q)
        _frsplitbox(f, bn++, (int)(q-p));
    return bn;
}
@

<<function [[_frsplitbox]]>>=
void
_frsplitbox(Frame *f, int bn, int n)
{
    dupbox(f, bn);
    truncatebox(f, &f->box[bn], f->box[bn].nrune-n);
    chopbox(f, &f->box[bn+1], n);
}
@

<<function [[dupbox]]>>=
static
void
dupbox(Frame *f, int bn)
{
    uchar *p;

    if(f->box[bn].nrune < 0)
        drawerror(f->display, "dupbox");
    _fraddbox(f, bn, 1);
    if(f->box[bn].nrune >= 0){
        p = _frallocstr(f, NBYTE(&f->box[bn])+1);
        strcpy((char*)p, (char*)f->box[bn].ptr);
        f->box[bn+1].ptr = p;
    }
}
@

<<function [[NBYTE]]>>=
#define	NBYTE(b)	strlen((char*)(b)->ptr)
@


<<function [[truncatebox]]>>=
static
void
truncatebox(Frame *f, Frbox *b, int n)	/* drop last n chars; no allocation done */
{
    if(b->nrune<0 || b->nrune<n)
        drawerror(f->display, "truncatebox");
    b->nrune -= n;
    runeindex(b->ptr, b->nrune)[0] = 0;
    b->wid = stringwidth(f->font, (char *)b->ptr);
}
@

<<function [[chopbox]]>>=
static
void
chopbox(Frame *f, Frbox *b, int n)	/* drop first n chars; no allocation done */
{
    char *p;

    if(b->nrune<0 || b->nrune<n)
        drawerror(f->display, "chopbox");
    p = (char*)runeindex(b->ptr, n);
    memmove((char*)b->ptr, p, strlen(p)+1);
    b->nrune -= n;
    b->wid = stringwidth(f->font, (char *)b->ptr);
}
@

<<function [[runeindex]]>>=
static
uchar*
runeindex(uchar *p, int n)
{
    int i, w;
    Rune rune;

    for(i=0; i<n; i++,p+=w)
        if(*p < Runeself)
            w = 1;
        else{
            w = chartorune(&rune, (char*)p);
            USED(rune);
        }
    return p;
}
@




\subsubsection{[[bxscan()]]}

<<constant [[TMPSIZE]]>>=
#define	TMPSIZE	256
@

<<function [[bxscan]]>>=
static
Point
bxscan(Frame *f, Rune *sp, Rune *ep, Point *ppt)
{
    int w, c, nb, delta, nl, nr, rw;
    Frbox *b;
    char *s, tmp[TMPSIZE+3];	/* +3 for rune overflow */
    uchar *p;

    frame.r = f->r;
    frame.b = f->b;
    frame.font = f->font;
    frame.maxtab = f->maxtab;
    frame.nbox = 0;
    frame.nchars = 0;
    memmove(frame.cols, f->cols, sizeof frame.cols);
    delta = DELTA;
    nl = 0;
    for(nb=0; sp<ep && nl<=f->maxlines; nb++,frame.nbox++){
        if(nb == frame.nalloc){
            _frgrowbox(&frame, delta);
            if(delta < 10000)
                delta *= 2;
        }
        b = &frame.box[nb];
        c = *sp;
        if(c=='\t' || c=='\n'){
            b->bc = c;
            b->wid = 5000;
            b->minwid = (c=='\n')? 0 : stringwidth(frame.font, " ");
            b->nrune = -1;
            if(c=='\n')
                nl++;
            frame.nchars++;
            sp++;
        }else{
            s = tmp;
            nr = 0;
            w = 0;
            while(sp < ep){
                c = *sp;
                if(c=='\t' || c=='\n')
                    break;
                rw = runetochar(s, sp);
                if(s+rw >= tmp+TMPSIZE)
                    break;
                w += runestringnwidth(frame.font, sp, 1);
                sp++;
                s += rw;
                nr++;
            }
            *s++ = 0;
            p = _frallocstr(f, s-tmp);
            b = &frame.box[nb];
            b->ptr = p;
            memmove(p, tmp, s-tmp);
            b->wid = w;
            b->nrune = nr;
            frame.nchars += nr;
        }
    }
    _frcklinewrap0(f, ppt, &frame.box[0]);
    return _frdraw(&frame, *ppt);
}
@

% frinsert -> bxscan -> <>
<<function [[_frdraw]]>>=
Point
_frdraw(Frame *f, Point pt)
{
    Frbox *b;
    int nb, n;

    for(b=f->box,nb=0; nb<f->nbox; nb++, b++){
        _frcklinewrap0(f, &pt, b);
        if(pt.y == f->r.max.y){
            f->nchars -= _frstrlen(f, nb);
            _frdelbox(f, nb, f->nbox-1);
            break;
        }
        if(b->nrune > 0){
            n = _frcanfit(f, pt, b);
            if(n == 0)
                drawerror(f->display, "_frcanfit==0");
            if(n != b->nrune){
                _frsplitbox(f, nb, n);
                b = &f->box[nb];
            }
            pt.x += b->wid;
        }else{
            if(b->bc == '\n'){
                pt.x = f->r.min.x;
                pt.y+=f->font->height;
            }else
                pt.x += _frnewwid(f, pt, b);
        }
    }
    return pt;
}
@

<<function [[_frnewwid]]>>=
int
_frnewwid(Frame *f, Point pt, Frbox *b)
{
    b->wid = _frnewwid0(f, pt, b);
    return b->wid;
}
@

<<function [[_frnewwid0]]>>=
int
_frnewwid0(Frame *f, Point pt, Frbox *b)
{
    int c, x;

    c = f->r.max.x;
    x = pt.x;
    if(b->nrune>=0 || b->bc!='\t')
        return b->wid;
    if(x+b->minwid > c)
        x = pt.x = f->r.min.x;
    x += f->maxtab;
    x -= (x-f->r.min.x)%f->maxtab;
    if(x-pt.x<b->minwid || x>c)
        x = pt.x+b->minwid;
    return x-pt.x;
}
@

<<function [[_frstrlen]]>>=
int
_frstrlen(Frame *f, int nb)
{
    int n;

    for(n=0; nb<f->nbox; nb++)
        n += NRUNE(&f->box[nb]);
    return n;
}
@

\subsubsection{[[_chopframe()]]}

<<function [[chopframe]]>>=
static
void
chopframe(Frame *f, Point pt, ulong p, int bn)
{
    Frbox *b;

    for(b = &f->box[bn]; ; b++){
        if(b >= &f->box[f->nbox])
            drawerror(f->display, "endofframe");
        _frcklinewrap(f, &pt, b);
        if(pt.y >= f->r.max.y)
            break;
        p += NRUNE(b);
        _fradvance(f, &pt, b);
    }
    f->nchars = p;
    f->nlines = f->maxlines;
    if(b<&f->box[f->nbox])				/* BUG */
        _frdelbox(f, (int)(b-f->box), f->nbox-1);
}
@

\subsubsection{[[_frclean()]]}

<<function [[_frclean]]>>=
void
_frclean(Frame *f, Point pt, int n0, int n1)	/* look for mergeable boxes */
{
    Frbox *b;
    int nb, c;

    c = f->r.max.x;
    for(nb=n0; nb<n1-1; nb++){
        b = &f->box[nb];
        _frcklinewrap(f, &pt, b);
        while(b[0].nrune>=0 && nb<n1-1 && b[1].nrune>=0 && pt.x+b[0].wid+b[1].wid<c){
            _frmergebox(f, nb);
            n1--;
            b = &f->box[nb];
        }
        _fradvance(f, &pt, &f->box[nb]);
    }
    for(; nb<f->nbox; nb++){
        b = &f->box[nb];
        _frcklinewrap(f, &pt, b);
        _fradvance(f, &pt, &f->box[nb]);
    }
    f->lastlinefull = 0;
    if(pt.y >= f->r.max.y)
        f->lastlinefull = 1;
}
@

<<function [[_frmergebox]]>>=
void
_frmergebox(Frame *f, int bn)		/* merge bn and bn+1 */
{
    Frbox *b;

    b = &f->box[bn];
    _frinsure(f, bn, NBYTE(&b[0])+NBYTE(&b[1])+1);
    strcpy((char*)runeindex(b[0].ptr, b[0].nrune), (char*)b[1].ptr);
    b[0].wid += b[1].wid;
    b[0].nrune += b[1].nrune;
    _frdelbox(f, bn+1, bn+1);
}
@



\subsection{[[frdelete()]]}


<<function [[frdelete]]>>=
int
frdelete(Frame *f, ulong p0, ulong p1)
{
    Point pt0, pt1, ppt0;
    Frbox *b;
    int n0, n1, n;
    ulong cn1;
    Rectangle r;
    int nn0;
    Image *col;

    if(p0>=f->nchars || p0==p1 || f->b==nil)
        return 0;
    if(p1 > f->nchars)
        p1 = f->nchars;
    n0 = _frfindbox(f, 0, 0, p0);
    if(n0 == f->nbox)
        drawerror(f->display, "off end in frdelete");
    n1 = _frfindbox(f, n0, p0, p1);
    pt0 = _frptofcharnb(f, p0, n0);
    pt1 = frptofchar(f, p1);
    if(f->p0 == f->p1)
        frtick(f, frptofchar(f, f->p0), 0);
    nn0 = n0;
    ppt0 = pt0;
    _frfreebox(f, n0, n1-1);
    f->modified = 1;

    /*
     * Invariants:
     *  - pt0 points to beginning, pt1 points to end
     *  - n0 is box containing beginning of stuff being deleted
     *  - n1, b are box containing beginning of stuff to be kept after deletion
     *  - cn1 is char position of n1
     *  - f->p0 and f->p1 are not adjusted until after all deletion is done
     */
    b = &f->box[n1];
    cn1 = p1;
    while(pt1.x!=pt0.x && n1<f->nbox){
        _frcklinewrap0(f, &pt0, b);
        _frcklinewrap(f, &pt1, b);
        n = _frcanfit(f, pt0, b);
        if(n==0)
            drawerror(f->display, "_frcanfit==0");
        r.min = pt0;
        r.max = pt0;
        r.max.y += f->font->height;
        if(b->nrune > 0){
            if(n != b->nrune){
                _frsplitbox(f, n1, n);
                b = &f->box[n1];
            }
            r.max.x += b->wid;
            draw(f->b, r, f->b, nil, pt1);
            cn1 += b->nrune;
        }else{
            r.max.x += _frnewwid0(f, pt0, b);
            if(r.max.x > f->r.max.x)
                r.max.x = f->r.max.x;
            col = f->cols[BACK];
            if(f->p0<=cn1 && cn1<f->p1)
                col = f->cols[HIGH];
            draw(f->b, r, col, nil, pt0);
            cn1++;
        }
        _fradvance(f, &pt1, b);
        pt0.x += _frnewwid(f, pt0, b);
        f->box[n0++] = f->box[n1++];
        b++;
    }
    if(n1==f->nbox && pt0.x!=pt1.x)	/* deleting last thing in window; must clean up */
        frselectpaint(f, pt0, pt1, f->cols[BACK]);
    if(pt1.y != pt0.y){
        Point pt2;

        pt2 = _frptofcharptb(f, 32767, pt1, n1);
        if(pt2.y > f->r.max.y)
            drawerror(f->display, "frptofchar in frdelete");
        if(n1 < f->nbox){
            int q0, q1, q2;

            q0 = pt0.y+f->font->height;
            q1 = pt1.y+f->font->height;
            q2 = pt2.y+f->font->height;
            if(q2 > f->r.max.y)
                q2 = f->r.max.y;
            draw(f->b, Rect(pt0.x, pt0.y, pt0.x+(f->r.max.x-pt1.x), q0),
                f->b, nil, pt1);
            draw(f->b, Rect(f->r.min.x, q0, f->r.max.x, q0+(q2-q1)),
                f->b, nil, Pt(f->r.min.x, q1));
            frselectpaint(f, Pt(pt2.x, pt2.y-(pt1.y-pt0.y)), pt2, f->cols[BACK]);
        }else
            frselectpaint(f, pt0, pt2, f->cols[BACK]);
    }
    _frclosebox(f, n0, n1-1);
    if(nn0>0 && f->box[nn0-1].nrune>=0 && ppt0.x-f->box[nn0-1].wid>=(int)f->r.min.x){
        --nn0;
        ppt0.x -= f->box[nn0].wid;
    }
    _frclean(f, ppt0, nn0, n0<f->nbox-1? n0+1 : n0);
    if(f->p1 > p1)
        f->p1 -= p1-p0;
    else if(f->p1 > p0)
        f->p1 = p0;
    if(f->p0 > p1)
        f->p0 -= p1-p0;
    else if(f->p0 > p0)
        f->p0 = p0;
    f->nchars -= p1-p0;
    if(f->p0 == f->p1)
        frtick(f, frptofchar(f, f->p0), 1);
    pt0 = frptofchar(f, f->nchars);
    n = f->nlines;
    f->nlines = (pt0.y-f->r.min.y)/f->font->height+(pt0.x>f->r.min.x);
    return n - f->nlines;
}
@


\subsection{[[wshow()]]}

% Window.nchars is in Frame!

% show text where can see q0.
% Note that it does not move the cursor. Just org is possibly changed.

% saw wshow(w, w->q0);

% wkeyctl -> <>
<<function [[wshow]]>>=
void
wshow(Window *w, uint q0)
{
    int qe;
    int nl;
    uint q;

    qe = w->org + w->frm.nchars;
    if(w->org <= q0 && (q0 < qe || (q0 == qe && qe == w->nr)))
        wscrdraw(w);
    <<[[wshow()]] else, when q0 is out of scope>>
}
@

%example: nchars have been modified by frinsert,
% so q0 == qe

% when can have q0 == qe but not be w=>nr?



\subsection{Drawing the scrollbar: [[wscrdraw()]]}

% w scroll draw
<<[[wmk()]] drawing scrollbar>>=
wscrdraw(w);
@
\l why in wmk? could be in caller. Anyway, wmk before
% set scrollbar and frame, but does not draw them I think.


% wshow | wmk | wsetorigin -> <>
<<function [[wscrdraw]]>>=
void
wscrdraw(Window *w)
{
    Rectangle r, r1, r2;
    Image *b;

    scrtemps();
    <<[[wscrdraw()]] sanity check the window image>>
    r = w->scrollr;
    b = scrtmp;
    // r1 is translation of r to (0,...)
    r1 = r;
    r1.min.x = 0;
    r1.max.x = Dx(r);
    r2 = scrpos(r1, w->org, w->org + w->frm.nchars, w->nr);
    if(!eqrect(r2, w->lastsr)){
        w->lastsr = r2;
        /* move r1, r2 to (0,0) to avoid clipping */
        r2 = rectsubpt(r2, r1.min);
        r1 = rectsubpt(r1, r1.min);
        draw(b, r1, w->frm.cols[BORD], nil, ZP);
        draw(b, r2, w->frm.cols[BACK], nil, ZP);
        // little separation line
        r2.min.x = r2.max.x-1;
        draw(b, r2, w->frm.cols[BORD], nil, ZP);

        // transfer back to main image
        draw(w->i, r, b, nil, Pt(0, r1.min.y));
    }
}
@


% FIGURE? where can see r, r1, r2, r3

<<function [[scrpos]]>>=
static
Rectangle
scrpos(Rectangle r, uint p0, uint p1, uint tot)
{
    Rectangle q;
    int h;

    q = r;
    h = q.max.y - q.min.y; // Dy(r)
    if(tot == 0)
        return q;
    <<[[scrpos()]] adjust integers if total is big>>
    if(p0 > 0)
        q.min.y += h*p0 / tot;
    if(p1 < tot)
        q.max.y -= h*(tot-p1) / tot;

    <<[[scrpos()]] last adjustments>>
    return q;
}
@
\l if p0 
% FIGURE?

<<[[scrpos()]] last adjustments>>=
if(q.max.y < q.min.y+2){
    if(q.min.y+2 <= r.max.y)
        q.max.y = q.min.y+2;
    else
        q.min.y = q.max.y-2;
}
@
% enlarge a bit if really small rectangle, at least 2 pixels

<<[[scrpos()]] adjust integers if total is big>>=
if(tot > 1024*1024){
    tot>>=10;
    p0>>=10;
    p1>>=10;
}
@
\l needed? for overflow?

<<[[Window]] other fields>>=
Rectangle	lastsr;
@
% opti, last scroll rectangle
<<[[wmk()]] textual window settings, extra frame settings>>=
w->lastsr = ZR;
@
% not really frame settings? 
<<[[wresize()]] textual window updates, reset lastsr>>=
w->lastsr = ZR;
@



<<[[wscrdraw()]] sanity check the window image>>=
if(w->i == nil)
    error("scrdraw");
@




<<global [[scrtmp]]>>=
static Image *scrtmp;
@

<<constant [[BIG]]>>=
BIG			= 3,	/* factor by which window dimension can exceed screen */
@
% but weird if window bigger than view. Anyway, it's just a safe value

<<function [[scrtemps]]>>=
static
void
scrtemps(void)
{
    int h;

    if(scrtmp)
        return;
    h = BIG * Dy(view->r);
    scrtmp = allocimage(display, Rect(0, 0, 32, h), view->chan, false, DWhite);
    <<[[scrtemps()]] sanity check scrtmp>>
}
@
%ocaml: use Common.once, so can inline the code in the caller

% 32 for width of scrollbar? no was 12, so why 32?

<<[[scrtemps()]] sanity check scrtmp>>=
if(scrtmp == nil)
    error("scrtemps");
@

\subsection{Drawing the tick: [[frtick()]]}

<<[[frinsert()]] remove tick>>=
if(f->p0 == f->p1)
    frtick(f, frptofchar(f, f->p0), false);
@
<<[[frinsert()]] draw tick>>=
if(f->p0 == f->p1)
    frtick(f, frptofchar(f, f->p0), true);
@

% drawing a tick or restoring what was under the tick
% (a bit like for the mouse cursor)

<<function [[frtick]]>>=
void
frtick(Frame *f, Point pt, bool ticked)
{
    Rectangle r;

    if(f->ticked==ticked || f->tick==nil || !ptinrect(pt, f->r))
        return;
    pt.x--;	/* looks best just left of where requested */
    r = Rect(pt.x, pt.y, pt.x + FRTICKW, pt.y + f->font->height);
    /* can go into left border but not right */
    if(r.max.x > f->r.max.x)
        r.max.x = f->r.max.x;
    if(ticked){
        draw(f->tickback, f->tickback->r, f->b, nil, pt);
        draw(f->b, r, f->tick, nil, ZP);
    }else
        draw(f->b, r, f->tickback, nil, ZP);
    f->ticked = ticked;
}
@
% modified f->ticked! this is why need to save old value of ticked
% before calling frtick sometimes

\subsection{Drawing the text and the selection: [[frdrawsel()]]}

% called also to draw what is not selected

<<function [[frdrawsel]]>>=
void
frdrawsel(Frame *f, Point pt, ulong p0, ulong p1, bool issel)
{
    Image *back, *text;

    if(f->ticked)
        frtick(f, frptofchar(f, f->p0), false);

    if(p0 == p1){
        frtick(f, pt, issel);
        return;
    }
    // else

    if(issel){
        back = f->cols[HIGH];
        text = f->cols[HTEXT];
    }else{
        back = f->cols[BACK];
        text = f->cols[TEXT];
    }

    frdrawsel0(f, pt, p0, p1, back, text);
}
@
% pt is point of? p0?


<<function [[frdrawsel0]]>>=
Point
frdrawsel0(Frame *f, Point pt, ulong p0, ulong p1, Image *back, Image *text)
{
    Frbox *b;
    int nb, nr, w, x, trim;
    Point qt;
    uint p;
    char *ptr;

    p = 0;
    b = f->box;
    trim = 0;
    for(nb=0; nb<f->nbox && p<p1; nb++){
        //todo: nr = NRUNE(b);
        nr = b->nrune;
        if(nr < 0)
            nr = 1;

        if(p+nr <= p0)
            goto Continue;
        if(p >= p0){
            qt = pt;
            _frcklinewrap(f, &pt, b);
            /* fill in the end of a wrapped line */
            if(pt.y > qt.y)
                draw(f->b, Rect(qt.x, qt.y, f->r.max.x, pt.y), back, nil, qt);
        }
        ptr = (char*)b->ptr;
        if(p < p0){	/* beginning of region: advance into box */
            ptr += nbytes(ptr, p0-p);
            nr -= (p0-p);
            p = p0;
        }
        trim = 0;
        if(p+nr > p1){	/* end of region: trim box */
            nr -= (p+nr)-p1;
            trim = 1;
        }
        if(b->nrune<0 || nr==b->nrune)
            w = b->wid;
        else
            w = stringnwidth(f->font, ptr, nr);
        x = pt.x+w;
        if(x > f->r.max.x)
            x = f->r.max.x;
        draw(f->b, Rect(pt.x, pt.y, x, pt.y+f->font->height), back, nil, pt);
        if(b->nrune >= 0)
            stringnbg(f->b, pt, text, ZP, f->font, ptr, nr, back, ZP);
        pt.x += w;
        Continue:
        b++;
        p += nr;
    }
    /* if this is end of last plain text box on wrapped line, fill to end of line */
    if(p1>p0 &&  b>f->box && b<f->box+f->nbox && b[-1].nrune>0 && !trim){
        qt = pt;
        _frcklinewrap(f, &pt, b);
        if(pt.y > qt.y)
            draw(f->b, Rect(qt.x, qt.y, f->r.max.x, pt.y), back, nil, qt);
    }
    return pt;
}
@

<<function [[nbytes]]>>=
static int
nbytes(char *s0, int nr)
{
    char *s;
    Rune r;

    s = s0;
    while(--nr >= 0)
        s += chartorune(&r, s);
    return s-s0;
}
@


\subsection{Moving the frame origin}

% complicated again ...

<<[[wshow()]] else, when q0 is out of scope>>=
else{
    nl = 4 * w->frm.maxlines / 5;
    q = wbacknl(w, q0, nl);
    /* avoid going backwards if trying to go forwards - long lines! */
    if(!(q0 > w->org && q < w->org))
        wsetorigin(w, q, true);

    while(q0 > w->org + w->frm.nchars)
        wsetorigin(w, w->org+1, false);
}
@

<<function [[wbacknl]]>>=
uint
wbacknl(Window *w, uint p, uint n)
{
    int i, j;

    /* look for start of this line if n==0 */
    if(n==0 && p>0 && w->r[p-1]!='\n')
        n = 1;

    i = n;
    while(i-->0 && p>0){
        --p;	/* it's at a newline now; back over it */
        if(p == 0)
            break;
        /* at 128 chars, call it a line anyway */
        for(j=128; --j>0 && p>0; p--)
            if(w->r[p-1]=='\n')
                break;
    }
    return p;
}
@



<<function [[wsetorigin]]>>=
void
wsetorigin(Window *w, uint org, bool exact)
{
    int i, a, fixup;
    Rune *r;
    uint n;
    Frame *frm = &w->frm;

    if(org>0 && !exact){
        /* org is an estimate of the char posn; find a newline */
        /* don't try harder than 256 chars */
        for(i=0; i<256 && org < w->nr; i++){
            if(w->r[org] == '\n'){
                org++;
                break;
            }
            org++;
        }
    }
    a = org - w->org;
    fixup = 0;
    if(a>=0 && a < frm->nchars){
        frdelete(frm, 0, a);
        fixup = 1;	/* frdelete can leave end of last line in wrong selection mode; it doesn't know what follows */
    }else if(a<0 && -a < frm->nchars){
        n = w->org - org;
        r = runemalloc(n);
        runemove(r, w->r+org, n);
        frinsert(frm, r, r+n, 0);
        free(r);
    }else
        frdelete(frm, 0, frm->nchars);
    w->org = org;
    wfill(w);
    wscrdraw(w);
    wsetselect(w, w->q0, w->q1);
    if(fixup && frm->p1 > frm->p0)
        frdrawsel(frm, frptofchar(frm, frm->p1-1), frm->p1-1, frm->p1, 1);
}
@


<<[[Frame]] text fields>>=
ushort	lastlinefull;	/* last line fills frame */
@
<<[[frinit()]] initialize other fields>>=
f->lastlinefull = 0;
@


<<function [[wfill]]>>=
void
wfill(Window *w)
{
    Rune *rp;
    int i, n, m, nl;
    Frame *frm = &w->frm;

    if(frm->lastlinefull)
        return;
    rp = malloc(messagesize);
    do{
        n = w->nr - (w->org + frm->nchars);
        if(n == 0)
            break;
        if(n > 2000)	/* educated guess at reasonable amount */
            n = 2000;
        runemove(rp, w->r + (w->org + frm->nchars), n);
        /*
         * it's expensive to frinsert more than we need, so
         * count newlines.
         */
        nl = frm->maxlines - frm->nlines;
        m = 0;
        for(i=0; i<n; ){
            if(rp[i++] == '\n'){
                m++;
                if(m >= nl)
                    break;
            }
        }
        frinsert(frm, rp, rp+i, frm->nchars);
    } while(frm->lastlinefull == false);
    free(rp);
}
@




\subsection{Selecting}

<<function [[wsetselect]]>>=
void
wsetselect(Window *w, uint q0, uint q1)
{
    int p0, p1;
    Frame *frm = &w->frm;

    /* w->p0 and w->p1 are always right; w->q0 and w->q1 may be off */
    w->q0 = q0;
    w->q1 = q1;
    /* compute desired p0,p1 from q0,q1 */
    p0 = q0-w->org;
    p1 = q1-w->org;
    if(p0 < 0)
        p0 = 0;
    if(p1 < 0)
        p1 = 0;
    if(p0 > frm->nchars)
        p0 = frm->nchars;
    if(p1 > frm->nchars)
        p1 = frm->nchars;
    if(p0 == frm->p0 && p1 == frm->p1)
        return;

    /* screen disagrees with desired selection */
    if(frm->p1 <= p0 || p1 <= frm->p0 || p0==p1 || frm->p1 == frm->p0){
        /* no overlap or too easy to bother trying */
        frdrawsel(frm, frptofchar(frm, frm->p0), frm->p0, frm->p1, 0);
        frdrawsel(frm, frptofchar(frm, p0), p0, p1, 1);
        goto Return;
    }
    /* overlap; avoid unnecessary painting */
    if(p0 < frm->p0){
        /* extend selection backwards */
        frdrawsel(frm, frptofchar(frm, p0), p0, frm->p0, 1);
    }else if(p0 > frm->p0){
        /* trim first part of selection */
        frdrawsel(frm, frptofchar(frm, frm->p0), frm->p0, p0, 0);
    }
    if(p1 > frm->p1){
        /* extend selection forwards */
        frdrawsel(frm, frptofchar(frm, frm->p1), frm->p1, p1, 1);
    }else if(p1 < frm->p1){
        /* trim last part of selection */
        frdrawsel(frm, frptofchar(frm, p1), p1, frm->p1, 0);
    }

    Return:
    frm->p0 = p0;
    frm->p1 = p1;
}
@



<<function [[frselect]]>>=
void
frselect(Frame *f, Mousectl *mc)	/* when called, button 1 is down */
{
    ulong p0, p1, q;
    Point mp, pt0, pt1, qt;
    int reg, b, scrled;

    mp = mc->xy;
    b = mc->buttons;

    f->modified = 0;
    frdrawsel(f, frptofchar(f, f->p0), f->p0, f->p1, 0);
    p0 = p1 = frcharofpt(f, mp);
    f->p0 = p0;
    f->p1 = p1;
    pt0 = frptofchar(f, p0);
    pt1 = frptofchar(f, p1);
    frdrawsel(f, pt0, p0, p1, 1);
    reg = 0;
    do{
        scrled = 0;
        if(f->scroll){
            if(mp.y < f->r.min.y){
                (*f->scroll)(f, -(f->r.min.y-mp.y)/(int)f->font->height-1);
                p0 = f->p1;
                p1 = f->p0;
                scrled = 1;
            }else if(mp.y > f->r.max.y){
                (*f->scroll)(f, (mp.y-f->r.max.y)/(int)f->font->height+1);
                p0 = f->p0;
                p1 = f->p1;
                scrled = 1;
            }
            if(scrled){
                if(reg != region(p1, p0))
                    q = p0, p0 = p1, p1 = q;	/* undo the swap that will happen below */
                pt0 = frptofchar(f, p0);
                pt1 = frptofchar(f, p1);
                reg = region(p1, p0);
            }
        }
        q = frcharofpt(f, mp);
        if(p1 != q){
            if(reg != region(q, p0)){	/* crossed starting point; reset */
                if(reg > 0)
                    frdrawsel(f, pt0, p0, p1, 0);
                else if(reg < 0)
                    frdrawsel(f, pt1, p1, p0, 0);
                p1 = p0;
                pt1 = pt0;
                reg = region(q, p0);
                if(reg == 0)
                    frdrawsel(f, pt0, p0, p1, 1);
            }
            qt = frptofchar(f, q);
            if(reg > 0){
                if(q > p1)
                    frdrawsel(f, pt1, p1, q, 1);
                else if(q < p1)
                    frdrawsel(f, qt, q, p1, 0);
            }else if(reg < 0){
                if(q > p1)
                    frdrawsel(f, pt1, p1, q, 0);
                else
                    frdrawsel(f, qt, q, p1, 1);
            }
            p1 = q;
            pt1 = qt;
        }
        f->modified = 0;
        if(p0 < p1) {
            f->p0 = p0;
            f->p1 = p1;
        }
        else {
            f->p0 = p1;
            f->p1 = p0;
        }
        if(scrled)
            (*f->scroll)(f, 0);
        flushimage(f->display, 1);
        if(!scrled)
            readmouse(mc);
        mp = mc->xy;
    }while(mc->buttons == b);
}
@

<<function [[frselectpaint]]>>=
void
frselectpaint(Frame *f, Point p0, Point p1, Image *col)
{
    int n;
    Point q0, q1;

    q0 = p0;
    q1 = p1;
    q0.y += f->font->height;
    q1.y += f->font->height;
    n = (p1.y-p0.y)/f->font->height;
    if(f->b == nil)
        drawerror(f->display, "frselectpaint b==0");
    if(p0.y == f->r.max.y)
        return;
    if(n == 0)
        draw(f->b, Rpt(p0, q1), col, nil, ZP);
    else{
        if(p0.x >= f->r.max.x)
            p0.x = f->r.max.x-1;
        draw(f->b, Rect(p0.x, p0.y, f->r.max.x, q0.y), col, nil, ZP);
        if(n > 1)
            draw(f->b, Rect(f->r.min.x, q0.y, f->r.max.x, p1.y),
                col, nil, ZP);
        draw(f->b, Rect(f->r.min.x, p1.y, q1.x, q1.y),
            col, nil, ZP);
    }
}
@

<<function [[region]]>>=
static
int
region(int a, int b)
{
    if(a < b)
        return -1;
    if(a == b)
        return 0;
    return 1;
}
@

\subsection{Repainting}

<<[[wrepaint()]] after updated cols, redraw content if mouse not opened>>=
if(!w->mouseopen)
    frredraw(&w->frm);
@
% need to redraw text with different colors when a window is
% selected or not.

<<function [[frredraw]]>>=
void
frredraw(Frame *f)
{
    bool ticked;
    Point pt;

    if(f->p0 == f->p1){
        ticked = f->ticked;
        if(ticked)
            frtick(f, frptofchar(f, f->p0), false);
        // redraw the text
        frdrawsel0(f, frptofchar(f, 0), 0, f->nchars, f->cols[BACK], f->cols[TEXT]);
        if(ticked)
            frtick(f, frptofchar(f, f->p0), true);
        return;
    }
    // else, redraw the selection and the text

    pt = frptofchar(f, 0);
    pt = frdrawsel0(f, pt, 0,     f->p0,     f->cols[BACK], f->cols[TEXT]);
    pt = frdrawsel0(f, pt, f->p0, f->p1,     f->cols[HIGH], f->cols[HTEXT]);
    pt = frdrawsel0(f, pt, f->p1, f->nchars, f->cols[BACK], f->cols[TEXT]);
}
@
%ocaml: tick/tickback because does not use a redraw from scratch simple model

% scrollbar is not redrawn here. wscrdraw is called only when
% things change. No need to redraw when select/unselect a window
% because the scrollbar will not change.


\section{Keyboard events}
\n keyboard before mouse event here

\subsection{Text input queue}

% it's between w->qh and w->nr!
% see core DS chapter
% (not necessarily keyboard event actually, can have put text after
% output point because of copy paste)


\subsection{[[/mnt/wsys/cons]] reading part3}

\subsubsection{Producer}

<<[[wkeyctl()]] when not rawing>>=
// here when no navigation key, no rawing, no 0x1B holding

<<[[wkeyctl()]] snarf and cut if not interrupt key>>
switch(r){
<<[[wkeyctl()]] special key cases and no special mode>>
}
// else

/* otherwise ordinary character; just insert */
<<[[wkeyctl()]] ordinary character>>
@

% will see soon special keys

<<[[wkeyctl()]] locals>>=
uint q0;
@

<<[[wkeyctl()]] ordinary character>>=
q0 = w->q0;
q0 = winsert(w, &r, 1, q0);
wshow(w, q0+1);
@
% insert, and move cursor after (and redisplay)

% winsert will modify w->q0. 
\l So why use intermediate q0?



\subsubsection{Consumer}

% similar to graphical window, except condition
% not just have raw char, now check for newline

<<[[winctl()]] alts adjustments, revert to CHANSND if newline in queue>>=
/* this code depends on NL and EOT fitting in a single byte */
/* kind of expensive for each loop; worth precomputing? */
for(i = w->qh; i < w->nr; i++){
     c = w->r[i];
     // buffering, until get a newline in which case we are ready to send
     if(c=='\n' || c=='\004'){
         alts[WCread].op = CHANSND;
         break;
     }
 }
@
%c: for loop and break are sometimes nice? or miss opportunity in ocaml
% for nicer higher-order function?

% get ready to send to WCread only if newline typed! otherwise buffered
% until newline


%    while(i<nb && (w->nraw > 0 || w->qh < w->nr)){
%        // raw mode
%        if(w->qh == w->nr){
%        // buffered mode
%         ...
%        }else
%            wid = runetochar(t+i, &w->r[w->qh++]);
%        i += wid;
%        <<[[winctl()]] when WCRead, break if newline and handle EOF character>>
%        }
\l should duplicate code with 2 different loops so easier to aspectize

<<[[winctl()]] when WCRead, break if newline and handle EOF character>>=
c = t[i-wid];	/* knows break characters fit in a byte */
if(!w->rawing && (c == '\n' || c=='\004')){
    if(c == '\004')
        i--;
    break;
@
%old: was c = t[i] but I put i+=wid earlier to aspectize this part
% break so will not fill more t, will stop even if guy asked for more.

<<[[winctl()]] when WCRead, handle EOF character after while loop>>=
if(i==nb && w->qh < w->nr && w->r[w->qh]=='\004')
    w->qh++;
@
% ???





\subsection{Navigation keys}
% can help to understand q0, qh, etc

<<[[wkeyctl()]] when mouse not opened and navigation keys>>=
if(!w->mouseopen)
switch(r){
<<[[wkeyctl()]] when mouse not opened, switch key cases>>
default:
    ; // no return! fallthrough
}
@
% this will work for buffered and raw mode.

<<[[wkeyctl()]] locals>>=
uint q1;
int n, nb;
@
% seen q0 before too

\subsubsection{Text boundaries (Home, end)}

<<[[wkeyctl()]] when mouse not opened, switch key cases>>=
case Khome:
    wshow(w, 0);
    return;
@
% which key on my laptop?

<<[[wkeyctl()]] when mouse not opened, switch key cases>>=
case Kend:
    wshow(w, w->nr);
    return;
@

\subsubsection{Down}

% maxlines is very bad name.
% use nblines instead?

<<[[wkeyctl()]] when mouse not opened, switch key cases>>=
case Kdown:
    n = w->frm.maxlines / 3;
    goto case_Down;
@
% go down 1/3 of height

<<[[wkeyctl()]] when mouse not opened, switch key cases>>=
case Kscrollonedown:
    n = mousescrollsize(w->frm.maxlines);
    if(n <= 0)
        n = 1;
    goto case_Down;
@
<<[[wkeyctl()]] when mouse not opened, switch key cases>>=
case Kpgdown:
    n = 2 * w->frm.maxlines / 3;
    // Fallthrough
case_Down:
    q0 = w->org +
        frcharofpt(&w->frm, Pt(w->frm.r.min.x, 
                               w->frm.r.min.y + n * w->frm.font->height));
    wsetorigin(w, q0, true);
    return;
@
% go down 2/3 of height

\subsubsection{Up}

<<[[wkeyctl()]] when mouse not opened, switch key cases>>=
case Kup:
    n = w->frm.maxlines/3;
    goto case_Up;
@
<<[[wkeyctl()]] when mouse not opened, switch key cases>>=
case Kscrolloneup:
    n = mousescrollsize(w->frm.maxlines);
    if(n <= 0)
        n = 1;
    goto case_Up;
@
<<[[wkeyctl()]] when mouse not opened, switch key cases>>=
case Kpgup:
    n = 2*w->frm.maxlines/3;
    // Fallthrough
case_Up:
    q0 = wbacknl(w, w->org, n);
    wsetorigin(w, q0, true);
    return;
@




\subsubsection{Left}

<<[[wkeyctl()]] when mouse not opened, switch key cases>>=
case Kleft:
    if(w->q0 > 0){
        q0 = w->q0 - 1;
        wsetselect(w, q0, q0);
        wshow(w, q0);
    }
    return;
@



\subsubsection{Right}

<<[[wkeyctl()]] when mouse not opened, switch key cases>>=
case Kright:
    if(w->q1 < w->nr){
        q1 = w->q1+1;
        wsetselect(w, q1, q1);
        wshow(w, q1);
    }
    return;
@

\subsubsection{Line boundaries}

% easy
<<[[wkeyctl()]] when mouse not opened, switch key cases>>=
case 0x05:	/* ^E: end of line */
    q0 = w->q0;
    while(q0 < w->nr && w->r[q0] != '\n')
        q0++;
    wsetselect(w, q0, q0);
    wshow(w, w->q0);
    return;
@



<<[[wkeyctl()]] when mouse not opened, switch key cases>>=
case 0x01:	/* ^A: beginning of line */
    if(w->q0==0 || w->q0 == w->qh || w->r[w->q0 - 1]=='\n')
        return;
    nb = wbswidth(w, 0x15 /* ^U */);
    wsetselect(w, w->q0 - nb, w->q0 - nb);
    wshow(w, w->q0);
    return;
@

% why this name? wbswidth? what's the parameter? it's not really used.
<<function [[wbswidth]]>>=
int
wbswidth(Window *w, Rune c)
{
    uint q, stop;
    Rune r;
    <<[[wbswidth()]] other locals>>

    <<[[wbswidth()]] return if erase character>>

    q = w->q0;
    stop = 0;
    if(q > w->qh)
        stop = w->qh;

    while(q > stop){
        r = w->r[q-1];
        if(r == '\n'){		/* eat at most one more character */
            if(q == w->q0)	/* eat the newline */
                --q;
            break; 
        }
        <<[[wbswidth()]] if [[c == 0x17]]>>
        --q;
    }
    return w->q0-q;
}
@



\subsection{Special keys}

\subsubsection{Delete}

<<[[wkeyctl()]] special key cases and no special mode>>=
case 0x08:	/* ^H: erase character */
case 0x15:	/* ^U: erase line */
case 0x17:	/* ^W: erase word */
    if(w->q0==0 || w->q0==w->qh)
        return;
    nb = wbswidth(w, r);
    q1 = w->q0;
    q0 = q1-nb;
    <<[[wkeyctl()]] when erase keys, adjust q0 and nb if before org>>
    if(nb > 0){
        wdelete(w, q0, q0+nb);
        wsetselect(w, q0, q0);
    }
    return;
@
% for backspace nb is 1
\l use of q1 here confusing with w->q1


<<[[wbswidth()]] return if erase character>>=
/* there is known to be at least one character to erase */
if(c == 0x08)	/* ^H: erase character */
    return 1;
@
% just one character to Delete


% called when want to erase word
<<[[wbswidth()]] other locals>>=
bool skipping = true;
uint eq;
@
<<[[wbswidth()]] if [[c == 0x17]]>>=
if(c == 0x17){
    eq = isalnum(r);
    if(eq && skipping)	/* found one; stop skipping */
        skipping = false;
    else if(!eq && !skipping)
        break;
}
@



<<[[wkeyctl()]] when erase keys, adjust q0 and nb if before org>>=
if(q0 < w->org){
    q0 = w->org;
    nb = q1-q0;
}
@



<<function [[wdelete]]>>=
void
wdelete(Window *w, uint q0, uint q1)
{
    uint n, p0, p1;
    Frame *frm = &w->frm;

    n = q1-q0;
    <<[[wdelete()]] sanity check n>>
    runemove(w->r+q0, w->r+q1, w->nr-q1);
    w->nr -= n;

    <<[[wdelete()]] adjust cursors>>
}
@
% similar to winsert (and call to frinsert)

% FIGURE of blit

<<[[wdelete()]] sanity check n>>=
if(n == 0)
    return;
@

<<[[wdelete()]] adjust cursors>>=
if(q0 < w->q0)
    w->q0 -= min(n, w->q0-q0);
if(q0 < w->q1)
    w->q1 -= min(n, w->q1-q0);

if(q1 < w->qh)
    w->qh -= n;
else if(q0 < w->qh)
    w->qh = q0;

if(q1 <= w->org)
    w->org -= n;
else
   <<[[wdelete()]] when [[q1 > w->org]], possibly update visible text>>
@
% FIGURE again

\l what if delete part of selection?


<<[[wdelete()]] when [[q1 > w->org]], possibly update visible text>>=
if(q0 < w->org + frm->nchars){
    p1 = q1 - w->org;
    if(p1 > frm->nchars)
        p1 = frm->nchars;
    if(q0 < w->org){
        w->org = q0;
        p0 = 0;
    }else
        p0 = q0 - w->org;

    frdelete(frm, p0, p1);
    wfill(w);
}
@
%ocaml: simply call repaint


\subsubsection{Interrupt}


% how generate this 0x7F rune?
% #define ... Del=        0x7F, in Kernel.nw
% and seems to be used for kbtabaltgr so need Alt + ?

<<[[wkeyctl()]] locals>>=
int nr;
Rune *rp;
int *notefd;
@

<<[[wkeyctl()]] special key cases and no special mode>>=
case 0x7F:		/* send interrupt */
    w->qh = w->nr;
    wshow(w, w->qh);
    notefd = emalloc(sizeof(int));
    *notefd = w->notefd;
    proccreate(interruptproc, notefd, 4096);
    return;
@

% wkeyctl -> proccreate(<>)
<<function [[interruptproc]]>>=
/*
 * Need to do this in a separate proc because if process we're interrupting
 * is dying and trying to print tombstone, kernel is blocked holding p->debug lock.
 */
void
interruptproc(void *v)
{
    int *notefd;

    notefd = v;
    write(*notefd, "interrupt", 9);
    free(notefd);
}
@

\t and then who handles this "interrupt" string? Kernel? each app?
% when signal not handled then causes process to terminate?


\subsubsection{Tab}


<<[[Frame]] text fields>>=
ushort	maxtab;		/* max size of tab, in pixels */
@

<<[[frinit()]] initialize other fields>>=
f->maxtab = 8 * stringwidth(ft, "0");
@



<<[[wmk()]] textual window settings, extra frame settings>>=
w->frm.maxtab = maxtab * stringwidth(font, "0");
@
% overwrite what was done in frinit
<<[[wresize()]] textual window updates, extra frame settings>>=
w->frm.maxtab = maxtab * stringwidth(w->frm.font, "0");
@

<<global [[maxtab]]>>=
int		maxtab = 0;
@
<<[[main()]] locals>>=
char *s;
@
<<[[main()]] set some globals>>=
s = getenv("tabstop");
if(s != nil)
    maxtab = strtol(s, nil, 0);
if(maxtab == 0)
    maxtab = 4;
free(s);
@


\section{Application output events}

\subsection{[[/mnt/wsys/cons]] writing part2}

% when process writes on /dev/cons, then need update text.

% process output string by writing on /dev/cons!
% newline too, runes

\subsubsection{Producer}

% is user process writing on /mnt/wsys/cons

\subsubsection{Consumer}

<<[[Wxxx]] cases>>=
WCwrite,
@

<<[[winctl()]] other locals>>=
Conswritemesg cwm;
@
<<[[winctl()]] channels creation>>=
cwm.cw = chancreate(sizeof(Stringpair), 0);
@
<<[[winctl()]] Wctl case, free channels if wctlmesg is Excited>>=
chanfree(cwm.cw);
@

<<[[winctl()]] alts setup>>=
alts[WCwrite].c = w->conswrite;
alts[WCwrite].v = &cwm;
alts[WCwrite].op = CHANSND;
@

<<[[winctl()]] alts adjustments>>=
if(!w->scrolling && !w->mouseopen && w->qh >  w->org + w->frm.nchars)
    alts[WCwrite].op = CHANNOP;
else
    // scrolling || mouseopen || w->qh <= w->org + w->frm.nchars
    alts[WCwrite].op = CHANSND;
@

\t scrolling -> autoscroll

% accept conswrite from app if space to print them on the frame!
% or if autoscroll
% and if mouseopen?????




<<[[winctl()]] other locals>>=
Rune *rp;
int nr;
@
<<[[winctl()]] event loop cases>>=
case WCwrite:
    recv(cwm.cw, &pair);
    rp = pair.s;
    nr = pair.ns;

    <<[[winctl()]] when WCwrite, if runes contains backspace>>

    w->qh = winsert(w, rp, nr, w->qh) + nr;
    <<[[winctl()]] when WCwrite, if scrolling or mouseopen>>
    wsetselect(w, w->q0, w->q1);
    wscrdraw(w);

    free(rp);
    break;
@
%ocaml: repaint


<<[[winctl()]] when WCwrite, if scrolling or mouseopen>>=
if(w->scrolling || w->mouseopen)
    wshow(w, w->qh);
@
% ???

<<[[winctl()]] other locals>>=
Rune *bp, *tp, *up;
int initial;
uint qh;
@
<<[[winctl()]] when WCwrite, if runes contains backspace>>=
bp = rp;
for(i=0; i<nr; i++) {
    if(*bp++ == '\b'){
        --bp;
        initial = 0;
        tp = runemalloc(nr);
        runemove(tp, rp, i);
        up = tp+i;
        for(; i<nr; i++){
            *up = *bp++;
            if(*up == '\b')
                if(up == tp)
                    initial++;
                else
                    --up;
            else
                up++;
        }
        if(initial){
            if(initial > w->qh)
                initial = w->qh;
            qh = w->qh-initial;
            wdelete(w, qh, qh+initial);
            w->qh = qh;
        }
        free(rp);
        rp = tp;
        nr = up-tp;
        rp[nr] = 0;
        break;
    }
}
@
% output can emit backspace? ugly.


\section{Mouse events}

% no producer/consumer here, just click generating action,
% textual windows do not read /mnt/wsys/mouse

\subsection{Middle click menu}

% certain condition = when !mouseopen
<<[[mousethread()]] middle click under certain conditions>>=
button2menu(winput);
@

% active only on actual window, not like right menu
% mousethread -> event loop -> <>(winput)
<<function [[button2menu]]>>=
void
button2menu(Window *w)
{
    <<[[button2menu()]] return if window was deleted>>

    incref(w);
    <<[[button2menu()]] menu2str adjustments for scrolling>>
    switch(menuhit(2, mousectl, &menu2, desktop)){
    <<[[button2menu()]] cases>>
    }
    wclose(w); // decref

    wsendctlmesg(w, Wakeup, ZR, nil);
    flushimage(display, true);
}
@

<<[[button2menu()]] return if window was deleted>>=
if(w->deleted)
    return;
@

<<global [[menu2]]>>=
Menu menu2 = { .item = menu2str };
@

<<global [[menu2str]]>>=
char*		menu2str[] = {
 [Cut]		"cut",
 [Paste]	"paste",
 [Snarf]	"snarf",
 [Plumb]	"plumb",
 [Send]		"send",
 [Scroll]	"scroll",
 nil
};
@

<<enum [[_anon_ (windows/rio/rio.c)]]2>>=
enum
{
    Cut,
    Paste,
    Snarf,
    Plumb,
    Send,
    Scroll,
};
@



\subsection{Other clicks}

<<[[winctl()]] WMouse case if not mouseopen>>=
wmousectl(w);
@

% hmm can get middle click here? and right click?? but it should
% have been intercepted before no?
<<function [[wmousectl]]>>=
void
wmousectl(Window *w)
{
    int but;

    if(w->mc.buttons == 1)
        but = 1;
    else if(w->mc.buttons == 2)
        but = 2;
    else if(w->mc.buttons == 4)
        but = 3;
    else{
        if(w->mc.buttons == 8)
            wkeyctl(w, Kscrolloneup);
        if(w->mc.buttons == 16)
            wkeyctl(w, Kscrollonedown);
        return;
    }

    incref(w);		/* hold up window while we track */
    <<[[wmousectl()]] goto Return if window was deleted>>

    <<[[wmousectl()]] if pt in scrollbar>>
    if(but == 1)
        wselect(w);

    /* else all is handled by main process */
   Return:
    wclose(w);
}
@
% transform mouse even in key event :) for scrolling

\t so always wclose??

% see scrolling later, using but value


<<[[wmousectl()]] goto Return if window was deleted>>=
if(w->deleted)
    goto Return;
@

%\section{Word selection}
% adv topics

%\section{Cut, Copy, Paste}
% adv topics



\section{Automatic scrolling mode}
% hard to put in adv topics, this global is pretty important

<<[[button2menu()]] menu2str adjustments for scrolling>>=
if(w->scrolling)
    menu2str[Scroll] = "noscroll";
else
    menu2str[Scroll] = "scroll";
@

<<[[button2menu()]] cases>>=
case Scroll:
    if(w->scrolling ^= 1)
        wshow(w, w->nr);
    break;
@
% go to the end

\section{Scroll bar interaction}

% saw drawing of scroll bar before, showing where we are in the
% "file", but can also click on scrollbar!

% seen Window.scrollr before

<<[[Frame]] scroll>>=
void (*scroll)(Frame*, int); /* scroll function provided by application */
@


<<[[mousethread()]] locals>>=
bool scrolling = false;
@
% != Window.scrolling !! this is when inside scrollbar

% window terminal have scrollbars
<<[[mousethread()]] set scrolling>>=
if(winput->mouseopen)
    scrolling = false;
else 
  if(scrolling)
    scrolling = mouse->buttons;
  else
    scrolling = mouse->buttons && ptinrect(xy, winput->scrollr);
@


<<[[mousethread()]] goto Sending if scroll buttons>>=
/* the up and down scroll buttons are not subject to the usual rules */
if((mouse->buttons&(8|16)) && !winput->mouseopen)
    goto Sending;
@



<<[[wmousectl()]] if pt in scrollbar>>=
if(ptinrect(w->mc.xy, w->scrollr)){
    if(but)
        wscroll(w, but);
    goto Return;
}
@

% if ptinrect scrollr

<<function [[wscroll]]>>=
void
wscroll(Window *w, int but)
{
    uint p0, oldp0;
    Rectangle s;
    int x, y, my, h, first;

    s = insetrect(w->scrollr, 1);
    h = s.max.y-s.min.y;
    x = (s.min.x+s.max.x)/2;
    oldp0 = ~0;
    first = true;
    do{
        flushimage(display, 1);
        if(w->mc.xy.x<s.min.x || s.max.x<=w->mc.xy.x){
            readmouse(&w->mc);
        }else{
            my = w->mc.xy.y;
            if(my < s.min.y)
                my = s.min.y;
            if(my >= s.max.y)
                my = s.max.y;
            if(!eqpt(w->mc.xy, Pt(x, my))){
                wmovemouse(w, Pt(x, my));
                readmouse(&w->mc);		/* absorb event generated by moveto() */
            }
            if(but == 2){
                y = my;
                if(y > s.max.y-2)
                    y = s.max.y-2;
                if(w->nr > 1024*1024)
                    p0 = ((w->nr>>10)*(y-s.min.y)/h)<<10; // >>
                else
                    p0 = w->nr*(y-s.min.y)/h;
                if(oldp0 != p0)
                    wsetorigin(w, p0, false);
                oldp0 = p0;
                readmouse(&w->mc);
                continue;
            }
            if(but == 1)
                p0 = wbacknl(w, w->org, (my-s.min.y)/w->frm.font->height);
            else
                p0 = w->org + frcharofpt(&w->frm, Pt(s.max.x, my));
            if(oldp0 != p0)
                wsetorigin(w, p0, true);
            oldp0 = p0;
            /* debounce */
            if(first){
                flushimage(display, 1);
                sleep(200);
                nbrecv(w->mc.c, &w->mc.Mouse);
                first = false;
            }
            wscrsleep(w, 100);
        }
    }while(w->mc.buttons & (1<<(but-1))); // >>
    while(w->mc.buttons)
        readmouse(&w->mc);
}
@






<<enum [[_anon_ (windows/rio/dat.h)]]2>>=
enum
{
    Kscrolloneup = KF|0x20,
    Kscrollonedown = KF|0x21,
};
@





<<function [[freescrtemps]]>>=
void
freescrtemps(void)
{
    freeimage(scrtmp);
    scrtmp = nil;
}
@




<<function [[wscrsleep]]>>=
void
wscrsleep(Window *w, uint dt)
{
    Timer	*timer;
    int y, b;
    static Alt alts[3];

    timer = timerstart(dt);
    y = w->mc.xy.y;
    b = w->mc.buttons;
    alts[0].c = timer->c;
    alts[0].v = nil;
    alts[0].op = CHANRCV;
    alts[1].c = w->mc.c;
    alts[1].v = &w->mc.Mouse;
    alts[1].op = CHANRCV;
    alts[2].op = CHANEND;
    for(;;)
        switch(alt(alts)){
        case 0:
            timerstop(timer);
            return;
        case 1:
            if(abs(w->mc.xy.y-y)>2 || w->mc.buttons!=b){
                timercancel(timer);
                return;
            }
            break;
        }
}
@














<<function [[framescroll]]>>=
/*
 * called from frame library
 */
void
framescroll(Frame *f, int dl)
{
    if(f != &selectwin->frm)
        error("frameselect not right frame");
    wframescroll(selectwin, dl);
}
@

<<function [[wframescroll]]>>=
void
wframescroll(Window *w, int dl)
{
    uint q0;
    Frame *frm = &w->frm;

    if(dl == 0){
        wscrsleep(w, 100);
        return;
    }
    if(dl < 0){
        q0 = wbacknl(w, w->org, -dl);
        if(selectq > w->org + frm->p0)
            wsetselect(w, w->org + frm->p0, selectq);
        else
            wsetselect(w, selectq, w->org + frm->p0);
    }else{
        if(w->org + frm->nchars == w->nr)
            return;
        q0 = w->org + frcharofpt(frm, Pt(frm->r.min.x, frm->r.min.y + dl * frm->font->height));
        if(selectq >= w->org + frm->p1)
            wsetselect(w, w->org + frm->p1, selectq);
        else
            wsetselect(w, selectq, w->org + frm->p1);
    }
    wsetorigin(w, q0, true);
}
@


\section{Resize}


% similar code to wmk textual settings
<<[[wresize()]] textual window updates>>=
<<[[wresize()]] textual window updates, reset lastsr>>
r = insetrect(i->r, Selborder+1);
w->scrollr = r;
w->scrollr.max.x = r.min.x+Scrollwid;

r.min.x += Scrollwid+Scrollgap;

if(move)
    frsetrects(&w->frm, r, w->i);
else{
    frclear(&w->frm, false);
    frinit(&w->frm, r, w->frm.font, w->i, cols);
    wsetcols(w);
    <<[[wresize()]] textual window updates, extra frame settings>>
    r = insetrect(w->i->r, Selborder);
    draw(w->i, r, cols[BACK], nil, w->frm.entire.min);

    wfill(w);
    wsetselect(w, w->q0, w->q1);
    wscrdraw(w);
}
@
% useful opti to differentiate move and resize?
% maybe could factorize more code with wmk creation.
% Have a paint function! (see codemap)


\section{[[/mnt/wsys/text]]}
% interesting to understand structure!

<<[[qid]] cases>>=
Qtext,
@
<<dirtab array elements>>=
{ "text",		QTFILE,	Qtext,		0400 },
@

<<[[xfidread()]] cases>>=
case Qtext:
    t = wcontents(w, &n);
    goto Text;

Text:
    if(off > n){
        off = n;
        cnt = 0;
    }
    if(off+cnt > n)
        cnt = n-off;

    fc.data = t + off;
    fc.count = cnt;
    filsysrespond(x->fs, x, &fc, nil);
    free(t);
    break;
@

<<function [[wcontents]]>>=
char*
wcontents(Window *w, int *ip)
{
    return runetobyte(w->r, w->nr, ip);
}
@
% runetobyte libc

% What happens if you do cat /dev/text from a window?
% Infinite?

\chapter{Windowing System Files}
\label{chap:window-files}
%[[/mnt/wsys/...]] 

% more the reflective part of rio, a bit like /proc for the kernel.
% (well winname is more important than that though)

\section{[[/mnt/wsys/winid]]}

<<[[qid]] cases>>=
Qwinid,
@
<<dirtab array elements>>=
{ "winid",		QTFILE,	Qwinid,		0400 },
@

<<[[xfidread()]] cases>>=
case Qwinid:
    n = sprint(buf, "%11d ", w->id);
    t = estrdup(buf);
    goto Text;
@
% sanity check n?

%\section{[[/mnt/wsys/winname]]}
% before


\section{[[/mnt/wsys/label]]}

<<[[qid]] cases>>=
Qlabel,
@
<<dirtab array elements>>=
{ "label",		QTFILE,	Qlabel,		0600 },
@

<<[[xfidread()]] cases>>=
case Qlabel:
    n = strlen(w->label);
    if(off > n)
        off = n;
    if(off+cnt > n)
        cnt = n - off;

    fc.data = w->label + off;
    fc.count = cnt;
    filsysrespond(x->fs, x, &fc, nil);
    break;
@
% could use goto Text? we avoid some allocations here


% used in hidden!
% not used in title bar, see rational in "Windows should be transparent",
% pike does not like title bar, useless according to him, encouraging
% to put state info in it which anyway should not exist!

<<[[xfidwrite()]] cases>>=
case Qlabel:
    if(off != 0){
        filsysrespond(x->fs, x, &fc, "non-zero offset writing label");
        return;
    }
    free(w->label);
    w->label = emalloc(cnt+1);
    memmove(w->label, req->data, cnt);
    w->label[cnt] = '\0';
    break;
@



\section{[[/mnt/wsys/screen]]}

% read only

<<[[qid]] cases>>=
Qscreen,
@
<<dirtab array elements>>=
{ "screen",		QTFILE,	Qscreen,	0400 },
@

<<[[xfidread()]] cases>>=
case Qscreen:
    i = display->image;
    if(i == nil){
        filsysrespond(x->fs, x, &fc, "no top-level screen");
        break;
    }
    r = i->r;
    goto caseImage;
@
%old: the caseImage used to be here, but I prefer to put
% it with the Qwindow case

\section{[[/mnt/wsys/wsys/]]}

% https://github.com/sdhand/x11fs

<<[[qid]] cases>>=
Qwsys,		/* directory of window directories */
@
<<dirtab array elements>>=
{ "wsys",		QTDIR,	Qwsys,		0500|DMDIR },
@
% QTDIR!


<<function [[idcmp]]>>=
static
int
idcmp(void *a, void *b)
{
    return *(int*)a - *(int*)b;
}
@


<<[[filsysread()]] other locals>>=
int i, j, k;
int len;
int *ids;
Dirtab dt;
char buf[16];
@


<<[[filsyswalk()]] if Qwsys, then goto Accept>>=
if(qid.path == Qwsys){
    /* is it a numeric name? */
    if(!numeric(x->req.wname[i]))
        break;
    /* yes: it's a directory */
    id = atoi(x->req.wname[i]);
    qlock(&all);
    w = wlookid(id);
    if(w == nil){
        qunlock(&all);
        break;
    }
    path = Qwsysdir;
    type = QTDIR;
    qunlock(&all);
    incref(w);
    sendp(winclosechan, f->w);
    f->w = w;
    dir = dirtab;
    goto Accept;
}
@
% again, why not wclose(w) directly? why winclosechan?

% -> <>
<<function [[numeric]]>>=
static
int
numeric(char *s)
{
    for(; *s!='\0'; s++)
        if(*s<'0' || '9'<*s)
            return 0;
    return 1;
}
@


<<[[filsysread()]] cases>>=
case Qwsys:

    qlock(&all);
    ids = emalloc(nwindow * sizeof(int));
    for(j=0; j<nwindow; j++)
        ids[j] = windows[j]->id;
    qunlock(&all);

    qsort(ids, nwindow, sizeof ids[0], idcmp);
    dt.name = buf;
    for(i=0, j=0; j<nwindow && i<e; i+=len){
        k = ids[j];
        sprint(dt.name, "%d", k);
        dt.qid = QID(k, Qdir);
        dt.type = QTDIR;
        dt.perm = DMDIR|0700;
        len = dostat(fs, k, &dt, b+n, x->req.count - n, clock);
        if(len == 0)
            break;
        if(i >= o)
            n += len;
        j++;
    }
    free(ids);
    break;
@



% see filsyswalk
<<[[qid]] cases>>=
Qwsysdir,		/* window directory, child of wsys */
@

<<[[filsyswalk()]] when in dotdot, if Qwsysdir adjust path>>=
if(FILE(qid) == Qwsysdir)
    path = Qwsys;
@


\section{[[/mnt/wsys/wctl]]}
\label{sec:mnt-wsys-wctl}
% Adv topics? Debugging support chapter?
% allow to command an app? a la watir/selenium/... ?


<<[[Window]] other fields>>=
bool	wctlopen;
bool 	wctlready;
@
%old: was bool_byte for wctlopen, and int for wctlready
% exclusive access to wctlopen



<<[[qid]] cases>>=
Qwctl,
@
<<dirtab array elements>>=
{ "wctl",		QTFILE,	Qwctl,		0600 },
@

<<[[xfidopen()]] cases>>=
case Qwctl:
    if(x->req.mode==OREAD || x->req.mode==ORDWR){
        /*
         * It would be much nicer to implement fan-out for wctl reads,
         * so multiple people can see the resizings, but rio just isn't
         * structured for that.  It's structured for /dev/cons, which gives
         * alternate data to alternate readers.  So to keep things sane for
         * wctl, we compromise and give an error if two people try to
         * open it.  Apologies.
         */
        if(w->wctlopen){
            filsysrespond(x->fs, x, &fc, Einuse);
            return;
        }
        w->wctlopen = true;
        w->wctlready = true;
        wsendctlmesg(w, Wakeup, ZR, nil);
    }
    break;
@

<<[[xfidclose()]] cases>>=
case Qwctl:
    if(x->f->mode==OREAD || x->f->mode==ORDWR)
        w->wctlopen = false;
break;
@



<<[[wcurrent()]] wakeup w and oi>>=
if(w != oi){
    if(oi){
        oi->wctlready = true;
        wsendctlmesg(oi, Wakeup, ZR, nil);
    }
    if(w){
        w->wctlready = true;
        wsendctlmesg(w, Wakeup, ZR, nil);
    }
}
@
% But Wakeup does nothing actually

\subsection{Reading}

\subsubsection{Producer}

\subsubsection{Consumer}



<<enum [[_anon_ (windows/rio/xfid.c)]]5>>=
enum { WCRdata, WCRflush, NWCR };
@

<<[[xfidread()]] other locals>>=
Consreadmesg cwrm;
@

<<[[xfidread()]] cases>>=
case Qwctl:	/* read returns rectangle, hangs if not resized */
    if(cnt < 4*12){
        filsysrespond(x->fs, x, &fc, Etooshort);
        break;
    }
    <<[[xfidxxx()]] set flushtag>>

    alts[WCRdata].c = w->wctlread;
    alts[WCRdata].v = &cwrm;
    alts[WCRdata].op = CHANRCV;
    <<[[xfidread()]] when Qwctl, set alts for flush>>
    alts[NMR].op = CHANEND;

    switch(alt(alts)){
    case WCRdata:
        break;
    <<[[xfidread()]] when Qwctl, switch alt flush case>>
    }

    /* received data */
    <<[[xfidxxx()]] unset flushtag>>
    c1 = cwrm.c1;
    c2 = cwrm.c2;
    t = malloc(cnt+1);	/* be sure to have room for NUL */
    pair.s = t;
    pair.ns = cnt+1;
    send(c1, &pair);
    <<[[xfidread()]] when Qwctl, if flushing>>

    qlock(&x->active);
    recv(c2, &pair);
    fc.data = pair.s;
    if(pair.ns > cnt)
        pair.ns = cnt;
    fc.count = pair.ns;
    filsysrespond(x->fs, x, &fc, nil);
    free(t);
    qunlock(&x->active);
    break;
@




% when read by app it's the current status of the window

<<[[Window]] other fields>>=
// chan<Consreadmesg> (listener = , sender = )
Channel		*wctlread;	/* chan(Consreadmesg) */
@
% abuse Consreadmesg
<<[[wmk()]] channels creation>>=
w->wctlread =  chancreate(sizeof(Consreadmesg), 0);
@


<<[[winctl()]] other locals>>=
Consreadmesg cwrm;
@

<<[[winctl()]] channels creation>>=
cwrm.c1 = chancreate(sizeof(Stringpair), 0);
cwrm.c2 = chancreate(sizeof(Stringpair), 0);
@
<<[[winctl()]] Wctl case, free channels if wctlmesg is Excited>>=
chanfree(cwrm.c1);
chanfree(cwrm.c2);
@


<<[[Wxxx]] cases>>=
WWread,
@


<<[[winctl()]] alts setup>>=
alts[WWread].c = w->wctlread;
alts[WWread].v = &cwrm;
alts[WWread].op = CHANSND;
@

<<[[winctl()]] alts adjustments>>=
if(w->deleted || !w->wctlready)
    alts[WWread].op = CHANNOP;
else
    alts[WWread].op = CHANSND;
@


<<[[winctl()]] other locals>>=
char *s;
@

<<[[winctl()]] event loop cases>>=
case WWread:
    w->wctlready = false;
    recv(cwrm.c1, &pair);
    if(w->deleted || w->i==nil)
        pair.ns = sprint(pair.s, "");
    else{
        s = "visible";
        for(i=0; i<nhidden; i++)
            if(hidden[i] == w){
                s = "hidden";
                break;
            }
        t = "notcurrent";
        if(w == input)
            t = "current";
        pair.ns = snprint(pair.s, pair.ns, "%11d %11d %11d %11d %s %s ",
            w->i->r.min.x, w->i->r.min.y, w->i->r.max.x, w->i->r.max.y, t, s);
    }
    send(cwrm.c2, &pair);
    continue;
@





\subsection{Writing (controlling windows)}

<<[[xfidwrite()]] cases>>=
case Qwctl:
    if(writewctl(x, buf) < 0){
        filsysrespond(x->fs, x, &fc, buf);
        return;
    }
    flushimage(display, true);
    break;
@



<<function [[writewctl]]>>=
int
writewctl(Xfid *x, char *err)
{
    int cnt, cmd, j, id, hideit, scrollit, pid;
    Image *i;
    char *arg, *dir;
    Rectangle rect;
    Window *w;

    w = x->f->w;
    cnt = x->req.count;
    x->req.data[cnt] = '\0';
    id = 0;

    rect = rectsubpt(w->screenr, view->r.min);
    cmd = parsewctl(&arg, rect, &rect, &pid, &id, &hideit, &scrollit, &dir, x->req.data, err);
    if(cmd < 0)
        return -1;

    if(mouse->buttons!=0 && cmd>=Top){
        strcpy(err, "action disallowed when mouse active");
        return -1;
    }

    if(id != 0){
        for(j=0; j<nwindow; j++)
            if(windows[j]->id == id)
                break;
        if(j == nwindow){
            strcpy(err, "no such window id");
            return -1;
        }
        w = windows[j];
        if(w->deleted || w->i==nil){
            strcpy(err, "window deleted");
            return -1;
        }
    }

    switch(cmd){
    case New:
        return wctlnew(rect, arg, pid, hideit, scrollit, dir, err);
    case Set:
        if(pid > 0)
            wsetpid(w, pid, 0);
        return 1;
    case Move:
        rect = Rect(rect.min.x, rect.min.y, rect.min.x+Dx(w->screenr), rect.min.y+Dy(w->screenr));
        rect = rectonscreen(rect);
        /* fall through */
    case Resize:
        if(!goodrect(rect)){
            strcpy(err, Ebadwr);
            return -1;
        }
        if(eqrect(rect, w->screenr))
            return 1;
        i = allocwindow(desktop, rect, Refbackup, DWhite);
        if(i == nil){
            strcpy(err, Ewalloc);
            return -1;
        }
        border(i, rect, Selborder, red, ZP);
        wsendctlmesg(w, Reshaped, i->r, i);
        return 1;
    case Scroll:
        w->scrolling = 1;
        wshow(w, w->nr);
        wsendctlmesg(w, Wakeup, ZR, nil);
        return 1;
    case Noscroll:
        w->scrolling = 0;
        wsendctlmesg(w, Wakeup, ZR, nil);
        return 1;
    case Top:
        wtopme(w);
        return 1;
    case Bottom:
        wbottomme(w);
        return 1;
    case Current:
        wcurrent(w);
        return 1;
    case Hide:
        switch(whide(w)){
        case -1:
            strcpy(err, "window already hidden");
            return -1;
        case 0:
            strcpy(err, "hide failed");
            return -1;
        default:
            break;
        }
        return 1;
    case Unhide:
        for(j=0; j<nhidden; j++)
            if(hidden[j] == w)
                break;
        if(j == nhidden){
            strcpy(err, "window not hidden");
            return -1;
        }
        if(wunhide(j) == 0){
            strcpy(err, "hide failed");
            return -1;
        }
        return 1;
    case Delete:
        wsendctlmesg(w, Deleted, ZR, nil);
        return 1;
    }
    strcpy(err, "invalid wctl message");
    return -1;
}
@

% nice summary of all Wctlmesgkind






%\chapter{Debugging Support}
% ? with rio -k? with /mnt/wsys/wctl?

\chapter{Advanced Topics TODO}
\label{chap:advanced}

\section{External mount: [[/srv/rio.user.pid]]}
% essentially a published pipe? so dont have
% to be children of process who created the pipe
% so =~ named pipe (but again, no need special file, can do via
% special fileserver; general mechanism!)

% this make fileserver accessible more easily to external
% processes. 

% like a named pipe?

% also allow newwindow() we saw in Graphics.nw!

% Until now done filsysmount() from rio itself
% in child process where mount(filesys->cfd, ...) and
% so have access to file descriptor. But for external?
% enter the /srv mechanism of plan9 to publish those things.

% mount $sys ... 

% /srv/rio.user.pid  pipe open for clients to communicate with rio server
<<global srvpipe (windows/rio/fsys.c)>>=
char	srvpipe[64];
@


<<[[filsysinit()]] srv pipe>>=
/*
 * Post srv pipe
 */
sprint(srvpipe, "/srv/rio.%s.%d", fs->user, pid);
post(srvpipe, "wsys", fs->cfd);
@


<<function [[post]]>>=
void
post(char *name, char *envname, fdt srvfd)
{
    fdt fd;
    char buf[32];

    fd = create(name, OWRITE|ORCLOSE|OCEXEC, 0600);
    if(fd < 0)
        error(name);
    sprint(buf, "%d", srvfd);
    if(write(fd, buf, strlen(buf)) != strlen(buf))
        error("srv write");

    putenv(envname, name);
}
@
% why need write srvfd which is fs->cfd? 
% so the file in /srv/.../ just contains a filedescriptor number? enough?
% or is it working with #s special code?




<<[[xfidattach()]] other locals>>=
Rectangle r;
int pid;
bool hideit = false;
bool scrollit;
char *dir, errbuf[ERRMAX];
Image *i;
@

<<[[xfidattach()]] if mount "new ...">>=
if(strncmp(x->req.aname, "new", 3) == 0){	/* new -dx -dy - new syntax, as in wctl */
    pid = 0;
    if(parsewctl(nil, ZR, &r, &pid, nil, &hideit, &scrollit, &dir, x->req.aname, errbuf) < 0)
        err = errbuf;
    else {
        if(!goodrect(r))
            err = Ebadrect;
        else{
            if(hideit)
                i = allocimage(display, r, view->chan, false, DWhite);
            else
                i = allocwindow(desktop, r, Refbackup, DWhite);
            if(i){
                border(i, r, Selborder, display->black, ZP);
                if(pid == 0)
                    pid = -1;	/* make sure we don't pop a shell! - UGH */
                w = new(i, hideit, scrolling, pid, nil, nil, nil);
                flushimage(display, 1);
                newlymade = true;
            }else
                err = Ewindow;
        }
   }
}
@

\section{Command-line control: [[/srv/riowctl.user.pid]]}

% allow to run graphical command from the command line
% allow also programs to create toplevel windows?

<<global [[wctlfd]]>>=
int	wctlfd;
@

<<global srvwctl (windows/rio/fsys.c)>>=
char	srvwctl[64];
@
% why need global?


<<[[filsysinit()]] wctl pipe, process, and thread creation>>=
/*
 * Create and post wctl pipe
 */
<<[[filsysinit()]] create wctl pipe>>

/*
 * Start server processes
 */
<<[[filsysinit()]] create wctl process and thread>>
@



<<[[filsysinit()]] other locals>>=
fdt p0;
// chan<??> (listener = ??, sender = ??)
Channel *c;
@


<<[[filsysinit()]] create wctl pipe>>=
if(cexecpipe(&p0, &wctlfd) < 0)
    goto Rescue;
sprint(srvwctl, "/srv/riowctl.%s.%d", fs->user, pid);
post(srvwctl, "wctl", p0);
close(p0);
@
% vs /dev/wctl? why need pipe mechanism for that? because
% /dev/wctl is for stuff who mounted rio, but external process
% dont have it! so need bootstrap!

<<[[filsysinit()]] create wctl process and thread>>=
c = chancreate(sizeof(char*), 0);
if(c == nil)
    error("wctl channel");

proccreate(wctlproc, c, 4096);
threadcreate(wctlthread, c, 4096);
@
% channel so process and thread can communicate


<<function [[wctlproc]]>>=
void
wctlproc(void *v)
{
    Channel *c = v;
    char *buf;
    int n, eofs;

    threadsetname("WCTLPROC");

    eofs = 0;
    for(;;){
        buf = emalloc(messagesize);
        // blocking call
        n = read(wctlfd, buf, messagesize-1);	/* room for \0 */
        if(n < 0)
            break;
        if(n == 0){
            if(++eofs > 20)
                break;
            continue;
        }
        eofs = 0;

        buf[n] = '\0';
        sendp(c, buf);
    }
}
@




<<function [[wctlthread]]>>=
void
wctlthread(void *v)
{
    Channel *c = v;
    char *buf, *arg, *dir;
    int cmd, id, pid, hideit, scrollit;
    Rectangle rect;
    char err[ERRMAX];

    threadsetname("WCTLTHREAD");

    for(;;){
        buf = recvp(c);

        cmd = parsewctl(&arg, ZR, &rect, &pid, &id, &hideit, &scrollit, &dir, buf, err);

        switch(cmd){
        case New:
            wctlnew(rect, arg, pid, hideit, scrollit, dir, err);
        }
        free(buf);
    }
}
@





\t mv before in other /mnt/wsys/ctl?

<<enum [[_anon_ (windows/rio/wctl.c)]]>>=
/* >= Top are disallowed if mouse button is pressed */
enum
{
    New,
    Resize,
    Move,
    Scroll,
    Noscroll,
    Set,
    Top,
    Bottom,
    Current,
    Hide,
    Unhide,
    Delete,
};
@

<<global [[cmds]]>>=
static char *cmds[] = {
    [New]	= "new",
    [Resize]	= "resize",
    [Move]	= "move",
    [Scroll]	= "scroll",
    [Noscroll]	= "noscroll",
    [Set]	= "set",
    [Top]	= "top",
    [Bottom]	= "bottom",
    [Current]	= "current",
    [Hide]	= "hide",
    [Unhide]	= "unhide",
    [Delete]	= "delete",
    nil
};
@

<<enum [[_anon_ (windows/rio/wctl.c)]]2>>=
enum
{
    Cd,
    Deltax,
    Deltay,
    Hidden,
    Id,

    Maxx,
    Maxy,
    Minx,
    Miny,

    PID,
    R,

    Scrolling,
    Noscrolling,
};
@

<<global [[params]]>>=
static char *params[] = {
    [Cd] 			= "-cd",
    [Deltax]			= "-dx",
    [Deltay]			= "-dy",
    [Hidden]			= "-hide",
    [Id]			= "-id",
    [Maxx]			= "-maxx",
    [Maxy]			= "-maxy",
    [Minx]			= "-minx",
    [Miny]			= "-miny",
    [PID]			= "-pid",
    [R]				= "-r",
    [Scrolling]			= "-scroll",
    [Noscrolling]		= "-noscroll",
    nil
};
@

<<function [[goodrect]]>>=
/*
 * Check that newly created window will be of manageable size
 */
int
goodrect(Rectangle r)
{
    if(!eqrect(canonrect(r), r))
        return 0;
    if(Dx(r)<100 || Dy(r)<3*font->height)
        return 0;
    /* must have some screen and border visible so we can move it out of the way */
    if(Dx(r) >= Dx(view->r) && Dy(r) >= Dy(view->r))
        return 0;
    /* reasonable sizes only please */
    if(Dx(r) > BIG*Dx(view->r))
        return 0;
    if(Dy(r) > BIG*Dx(view->r))
        return 0;
    return 1;
}
@

<<function [[word]]>>=
static
int
word(char **sp, char *tab[])
{
    char *s, *t;
    int i;

    s = *sp;
    while(isspace(*s))
        s++;
    t = s;
    while(*s!='\0' && !isspace(*s))
        s++;
    for(i=0; tab[i]!=nil; i++)
        if(strncmp(tab[i], t, strlen(tab[i])) == 0){
            *sp = s;
            return i;
    }
    return -1;
}
@

<<function [[set]]>>=
int
set(int sign, int neg, int abs, int pos)
{
    if(sign < 0)
        return neg;
    if(sign > 0)
        return pos;
    return abs;
}
@

<<function [[newrect]]>>=
Rectangle
newrect(void)
{
    static int i = 0;
    int minx, miny, dx, dy;

    dx = min(600, Dx(view->r) - 2*Borderwidth);
    dy = min(400, Dy(view->r) - 2*Borderwidth);
    minx = 32 + 16*i;
    miny = 32 + 16*i;
    i++;
    i %= 10;

    return Rect(minx, miny, minx+dx, miny+dy);
}
@

<<function [[shift]]>>=
void
shift(int *minp, int *maxp, int min, int max)
{
    if(*minp < min){
        *maxp += min-*minp;
        *minp = min;
    }
    if(*maxp > max){
        *minp += max-*maxp;
        *maxp = max;
    }
}
@

<<function [[rectonscreen]]>>=
Rectangle
rectonscreen(Rectangle r)
{
    shift(&r.min.x, &r.max.x, view->r.min.x, view->r.max.x);
    shift(&r.min.y, &r.max.y, view->r.min.y, view->r.max.y);
    return r;
}
@

<<function [[riostrtol]]>>=
/* permit square brackets, in the manner of %R */
int
riostrtol(char *s, char **t)
{
    int n;

    while(*s!='\0' && (*s==' ' || *s=='\t' || *s=='['))
        s++;
    if(*s == '[')
        s++;
    n = strtol(s, t, 10);
    if(*t != s)
        while((*t)[0] == ']')
            (*t)++;
    return n;
}
@

<<function [[parsewctl]]>>=
int
parsewctl(char **argp, Rectangle r, Rectangle *rp, int *pidp, int *idp, int *hiddenp, int *scrollingp, char **cdp, char *s, char *err)
{
    int cmd, param, xy, sign;
    char *t;

    *pidp = 0;
    *hiddenp = 0;
    *scrollingp = scrolling;
    *cdp = nil;
    cmd = word(&s, cmds);
    if(cmd < 0){
        strcpy(err, "unrecognized wctl command");
        return -1;
    }
    if(cmd == New)
        r = newrect();

    strcpy(err, "missing or bad wctl parameter");

    while((param = word(&s, params)) >= 0){
        switch(param){	/* special cases */
        case Hidden:
            *hiddenp = 1;
            continue;
        case Scrolling:
            *scrollingp = 1;
            continue;
        case Noscrolling:
            *scrollingp = 0;
            continue;
        case R:
            r.min.x = riostrtol(s, &t);
            if(t == s)
                return -1;
            s = t;
            r.min.y = riostrtol(s, &t);
            if(t == s)
                return -1;
            s = t;
            r.max.x = riostrtol(s, &t);
            if(t == s)
                return -1;
            s = t;
            r.max.y = riostrtol(s, &t);
            if(t == s)
                return -1;
            s = t;
            continue;
        }
        while(isspace(*s))
            s++;
        if(param == Cd){
            *cdp = s;
            while(*s && !isspace(*s))
                s++;
            if(*s != '\0')
                *s++ = '\0';
            continue;
        }
        sign = 0;
        if(*s == '-'){
            sign = -1;
            s++;
        }else if(*s == '+'){
            sign = +1;
            s++;
        }
        if(!isdigit(*s))
            return -1;
        xy = riostrtol(s, &s);

        switch(param){
        case Minx:
            r.min.x = set(sign, r.min.x-xy, xy, r.min.x+xy);
            break;
        case Miny:
            r.min.y = set(sign, r.min.y-xy, xy, r.min.y+xy);
            break;
        case Maxx:
            r.max.x = set(sign, r.max.x-xy, xy, r.max.x+xy);
            break;
        case Maxy:
            r.max.y = set(sign, r.max.y-xy, xy, r.max.y+xy);
            break;
        case Deltax:
            r.max.x = set(sign, r.max.x-xy, r.min.x+xy, r.max.x+xy);
            break;
        case Deltay:
            r.max.y = set(sign, r.max.y-xy, r.min.y+xy, r.max.y+xy);
            break;
        case Id:
            if(idp != nil)
                *idp = xy;
            break;
        case PID:
            if(pidp != nil)
                *pidp = xy;
            break;
        case -1:
            strcpy(err, "unrecognized wctl parameter");
            return -1;
        }
    }

    *rp = rectonscreen(rectaddpt(r, view->r.min));

    while(isspace(*s))
        s++;
    if(cmd!=New && *s!='\0'){
        strcpy(err, "extraneous text in wctl message");
        return -1;
    }

    if(argp)
        *argp = s;

    return cmd;
}
@

<<function [[wctlnew]]>>=
int
wctlnew(Rectangle rect, char *arg, int pid, int hideit, int scrollit, char *dir, char *err)
{
    char **argv;
    Image *i;

    if(!goodrect(rect)){
        strcpy(err, Ebadwr);
        return -1;
    }
    argv = emalloc(4*sizeof(char*));
    argv[0] = "rc";
    argv[1] = "-c";
    while(isspace(*arg))
        arg++;
    if(*arg == '\0'){
        argv[1] = "-i";
        argv[2] = nil;
    }else{
        argv[2] = arg;
        argv[3] = nil;
    }
    if(hideit)
        i = allocimage(display, rect, view->chan, false, DWhite);
    else
        i = allocwindow(desktop, rect, Refbackup, DWhite);
    if(i == nil){
        strcpy(err, Ewalloc);
        return -1;
    }
    border(i, rect, Selborder, red, ZP);

    new(i, hideit, scrollit, pid, dir, "/bin/rc", argv);

    free(argv);	/* when new() returns, argv and args have been copied */
    return 1;
}
@




<<function [[wtopme]]>>=
void
wtopme(Window *w)
{
    if(w!=nil && w->i!=nil && !w->deleted && w->topped!=topped){
        topwindow(w->i);
        flushimage(display, 1);
        w->topped = ++topped;
    }
}
@

<<function [[wbottomme]]>>=
void
wbottomme(Window *w)
{
    if(w!=nil && w->i!=nil && !w->deleted){
        bottomwindow(w->i);
        flushimage(display, 1);
        w->topped = - ++topped;
    }
}
@


\section{Recursive [[rio]]}
\label{sec:recursive-rio}

\t screenshot with rio and see hidden color inside a nested rio
\t or a cut system menu

\l then can also show FIGURE of rio multiplexer with 2 levels this time!


% could be in Debugging section, after all it's mostly
%  to make easy to develop rio

% actually it works without doing much thing!
% because use /dev/xxx too!

<<[[Mxxx]] cases>>=
MReshape,
@
% a Mxxx because in plan9 resize events are communicated through
%  /dev/mouse (ugly)

%mouse(3)
%The mouse and cursor files are multiplexed by rio(1) to give the
%illusion of a private mouse to each of its clients. The semantics are
%otherwise the same except that notification of a window resize is
%passed to the application using a mouse message beginning with r
%rather than m; see rio(4) for details.

% so normally MReshape does not happen! only when rio is run under rio!

<<[[mousethread()]] alts setup>>=
alts[MReshape].c = mousectl->resizec;
alts[MReshape].v = nil;
alts[MReshape].op = CHANRCV;
@

<<[[mousethread()]] event loop cases>>=
case MReshape:
    resized();
    break;
@

% resized is what regular applications are supposed to do.

% from MReshape, how can get this event? from resize of rio window itself?
% so get that when run vgactl? or when run rio inside rio and resize
% sub rio window?
<<function [[resized]]>>=
void
resized(void)
{
    Image *im;
    int i, j;
    bool ishidden;
    Rectangle r;
    Point o, n;
    Window *w;

    // updates view (and screen)
    if(getwindow(display, Refnone) < 0)
        error("failed to re-attach window");

    freescrtemps();
    freescreen(desktop);

    desktop = allocscreen(view, background, false);
    <<[[resized()]] sanity check desktop>>
    draw(view, view->r, background, nil, ZP);

    // old view rectangle
    o = subpt(viewr.max, viewr.min);
    n = subpt(view->clipr.max, view->clipr.min);

    for(i=0; i<nwindow; i++){
        w = windows[i];
        <<[[resized()]] continue if window was deleted>>
        r = rectsubpt(w->i->r, viewr.min);
        r.min.x = (r.min.x*n.x)/o.x;
        r.min.y = (r.min.y*n.y)/o.y;
        r.max.x = (r.max.x*n.x)/o.x;
        r.max.y = (r.max.y*n.y)/o.y;
        r = rectaddpt(r, view->clipr.min);

        ishidden = false;
        for(j=0; j<nhidden; j++)
            if(w == hidden[j]){
                ishidden = true;
                break;
            }
        if(ishidden){
            im = allocimage(display, r, view->chan, false, DWhite);
            r = ZR;
        }else
            im = allocwindow(desktop, r, Refbackup, DWhite);

        if(im)
            wsendctlmesg(w, Reshaped, r, im);
    }
    viewr = view->r;
    flushimage(display, true);
}
@
% force redisplay by Reshaped!

% Nice code where see the full state of rio and how to iterate
%  over it


<<[[resized()]] sanity check desktop>>=
if(desktop == nil)
    error("can't re-allocate desktop");
@

<<[[resized()]] continue if window was deleted>>=
if(w->deleted)
    continue;
@


\section{Advanced terminal editing}

\subsection{Snarf}
\label{sec:snarf}
%\subsection{[[/dev/snarf]]}

<<[[wkeyctl()]] snarf and cut if not interrupt key>>=
if(r != 0x7F){ // 0x7F = Interrupt key
    wsnarf(w);
    wcut(w);
}
@

\subsubsection{Snarf menu}

<<[[button2menu()]] cases>>=
case Cut:
    wsnarf(w);
    wcut(w);
    wscrdraw(w);
    break;

case Snarf:
    wsnarf(w);
    break;

case Paste:
    getsnarf();
    wpaste(w);
    wscrdraw(w);
    break;

case Send:
    getsnarf();
    wsnarf(w);
    if(nsnarf == 0)
        break;
    if(w->rawing){
        waddraw(w, snarf, nsnarf);
        if(snarf[nsnarf-1]!='\n' && snarf[nsnarf-1]!='\004')
                      waddraw(w, L"\n", 1);
    }else{
        winsert(w, snarf, nsnarf, w->nr);
        if(snarf[nsnarf-1]!='\n' && snarf[nsnarf-1]!='\004')
            winsert(w, L"\n", 1, w->nr);
    }
    wsetselect(w, w->nr, w->nr);
    wshow(w, w->nr);
    break;
@



<<function [[wsnarf]]>>=
void
wsnarf(Window *w)
{
    if(w->q1 == w->q0)
        return;
    nsnarf = w->q1 - w->q0;
    snarf = runerealloc(snarf, nsnarf);
    snarfversion++;	/* maybe modified by parent */
    runemove(snarf, w->r+w->q0, nsnarf);
    putsnarf();
}
@


<<function [[wcut]]>>=
void
wcut(Window *w)
{
    if(w->q1 == w->q0)
        return;
    wdelete(w, w->q0, w->q1);
    wsetselect(w, w->q0, w->q0);
}
@





<<function [[wpaste]]>>=
void
wpaste(Window *w)
{
    uint q0;

    if(nsnarf == 0)
        return;
    wcut(w);
    q0 = w->q0;
    if(w->rawing && q0==w->nr){
        waddraw(w, snarf, nsnarf);
        wsetselect(w, q0, q0);
    }else{
        q0 = winsert(w, snarf, nsnarf, w->q0);
        wsetselect(w, q0, q0+nsnarf);
    }
}
@




\subsubsection{[[/mnt/wsys/snarf]]}

<<[[qid]] cases>>=
Qsnarf,
@

<<dirtab array elements>>=
{ "snarf",		QTFILE,	Qsnarf,		0600 },
@

<<[[filsyswalk()]] if snarf>>=
if(snarffd>=0 && strcmp(x->req.wname[i], "snarf")==0)
    break;	/* don't serve /dev/snarf if it's provided in the environment */
@


<<[[xfidopen()]] cases>>=
case Qsnarf:
    if(x->req.mode==ORDWR || x->req.mode==OWRITE){
        if(tsnarf)
            free(tsnarf);	/* collision, but OK */
        ntsnarf = 0;
        tsnarf = malloc(1);
    }
    break;
@

<<[[xfidclose()]] other locals>>=
int nb, nulls;
@

<<[[xfidclose()]] cases>>=
/* odd behavior but really ok: replace snarf buffer when /dev/snarf is closed */
case Qsnarf:
    if(x->f->mode==ORDWR || x->f->mode==OWRITE){
        snarf = runerealloc(snarf, ntsnarf+1);
        cvttorunes(tsnarf, ntsnarf, snarf, &nb, &nsnarf, &nulls);
        free(tsnarf);
        tsnarf = nil;
        ntsnarf = 0;
    }
    break;
@

<<[[xfidread()]] cases>>=
/* The algorithm for snarf and text is expensive but easy and rarely used */
case Qsnarf:
    getsnarf();
    if(nsnarf)
        t = runetobyte(snarf, nsnarf, &n);
    else {
        t = nil;
        n = 0;
    }
    goto Text;
@

<<constant [[MAXSNARF]]>>=
#define	MAXSNARF	100*1024
@

<<[[xfidwrite()]] cases>>=
case Qsnarf:
    /* always append only */
    if(ntsnarf > MAXSNARF){	/* avoid thrashing when people cut huge text */
        filsysrespond(x->fs, x, &fc, Elong);
        return;
    }
    tsnarf = erealloc(tsnarf, ntsnarf+cnt+1);	/* room for NUL */
    memmove(tsnarf+ntsnarf, req->data, cnt);
    ntsnarf += cnt;
    snarfversion++;
    break;
@


<<[[dostat()]] adjust vers for snarf>>=
if(dir->qid == Qsnarf)
    d.qid.vers = snarfversion;
@

<<global [[tsnarf]]>>=
static	char	*tsnarf;
@

<<global [[ntsnarf]]>>=
static	int	ntsnarf;
@






<<global [[snarffd]]>>=
fdt		snarffd;
@

<<[[main()]] set some globals>>=
snarffd = open("/dev/snarf", OREAD|OCEXEC);
@
% used to be in his own chunk but I think does not matter

<<global [[nsnarf]]>>=
int		nsnarf;
@

<<global [[snarf]]>>=
Rune*	snarf;
@

<<global [[snarfversion]]>>=
int		snarfversion;	/* updated each time it is written */
@


<<function [[putsnarf]]>>=
/*
 * /dev/snarf updates when the file is closed, so we must open our own
 * fd here rather than use snarffd
 */
void
putsnarf(void)
{
    int fd, i, n;

    if(snarffd<0 || nsnarf==0)
        return;
    fd = open("/dev/snarf", OWRITE);
    if(fd < 0)
        return;
    /* snarf buffer could be huge, so fprint will truncate; do it in blocks */
    for(i=0; i<nsnarf; i+=n){
        n = nsnarf-i;
        if(n >= 256)
            n = 256;
        if(fprint(fd, "%.*S", n, snarf+i) < 0)
            break;
    }
    close(fd);
}
@

<<function [[getsnarf]]>>=
void
getsnarf(void)
{
    int i, n, nb, nulls;
    char *sn, buf[1024];

    if(snarffd < 0)
        return;
    sn = nil;
    i = 0;
    seek(snarffd, 0, 0);
    while((n = read(snarffd, buf, sizeof buf)) > 0){
        sn = erealloc(sn, i+n+1);
        memmove(sn+i, buf, n);
        i += n;
        sn[i] = 0;
    }
    if(i > 0){
        snarf = runerealloc(snarf, i+1);
        cvttorunes(sn, i, snarf, &nb, &nsnarf, &nulls);
        free(sn);
    }
}
@



\subsection{Plumb}
\label{sec:plumb}


<<[[button2menu()]] cases>>=
case Plumb:
    wplumb(w);
    break;
@

<<function [[wplumb]]>>=
void
wplumb(Window *w)
{
    Plumbmsg *m;
    static int fd = -2;
    char buf[32];
    uint p0, p1;
    Cursor *c;

    if(fd == -2)
        fd = plumbopen("send", OWRITE|OCEXEC);
    if(fd < 0)
        return;
    m = emalloc(sizeof(Plumbmsg));
    m->src = estrdup("rio");
    m->dst = nil;
    m->wdir = estrdup(w->dir);
    m->type = estrdup("text");
    p0 = w->q0;
    p1 = w->q1;
    if(w->q1 > w->q0)
        m->attr = nil;
    else{
        while(p0>0 && w->r[p0-1]!=' ' && w->r[p0-1]!='\t' && w->r[p0-1]!='\n')
            p0--;
        while(p1<w->nr && w->r[p1]!=' ' && w->r[p1]!='\t' && w->r[p1]!='\n')
            p1++;
        sprint(buf, "click=%d", w->q0-p0);
        m->attr = plumbunpackattr(buf);
    }
    if(p1-p0 > messagesize-1024){
        plumbfree(m);
        return;	/* too large for 9P */
    }
    m->data = runetobyte(w->r+p0, p1-p0, &m->ndata);
    if(plumbsend(fd, m) < 0){
        c = lastcursor;
        riosetcursor(&query, 1);
        sleep(300);
        riosetcursor(c, 1);
    }
    plumbfree(m);
}
@



%/*
% * Message format:
% *	source application\n
% *	destination port\n
% *	working directory\n
% *	type\n
% *	attributes\n
% *	nbytes\n
% *	n bytes of data
% */

<<struct [[Plumbmsg]]>>=
struct Plumbmsg
{
    char		*src;
    char		*dst;
    char		*wdir;
    char		*type;
    Plumbattr		*attr;
    int			ndata;
    char		*data;
};
@

<<struct [[Plumbattr]]>>=
struct Plumbattr
{
    char		*name;
    char		*value;
    Plumbattr		*next;
};
@


<<function [[plumbsendtext]]>>=
int
plumbsendtext(int fd, char *src, char *dst, char *wdir, char *data)
{
    Plumbmsg m;

    m.src = src;
    m.dst = dst;
    m.wdir = wdir;
    m.type = "text";
    m.attr = nil;
    m.ndata = strlen(data);
    m.data = data;
    return plumbsend(fd, &m);
}
@



\subsubsection{Plumb messages}

<<function [[plumbopen]]>>=
int
plumbopen(char *name, int omode)
{
    int fd, f;
    char *s, *plumber;
    char buf[128], err[ERRMAX];

    if(name[0] == '/')
        return open(name, omode);
        
    /* find elusive plumber */
    if(access("/mnt/plumb/send", AWRITE) >= 0)
        plumber = "/mnt/plumb";
    else if(access("/mnt/term/mnt/plumb/send", AWRITE) >= 0)
        plumber = "/mnt/term/mnt/plumb";
    else{
        /* last resort: try mounting service */
        plumber = "/mnt/plumb";
        s = getenv("plumbsrv");
        if(s == nil)
            return -1;
        f = open(s, ORDWR);
        free(s);
        if(f < 0)
            return -1;
        if(mount(f, -1, "/mnt/plumb", MREPL, "") < 0){
            close(f);
            return -1;
        }
        if(access("/mnt/plumb/send", AWRITE) < 0)
            return -1;
    }

    snprint(buf, sizeof buf, "%s/%s", plumber, name);
    fd = open(buf, omode);
    if(fd >= 0)
        return fd;

    /* try creating port; used by non-standard plumb implementations */
    rerrstr(err, sizeof err);
    fd = create(buf, omode, 0600);
    if(fd >= 0)
        return fd;
    errstr(err, sizeof err);

    return -1;
}
@

<<function [[Strlen]]>>=
static int
Strlen(char *s)
{
    if(s == nil)
        return 0;
    return strlen(s);
}
@

<<function [[Strcpy]]>>=
static char*
Strcpy(char *s, char *t)
{
    if(t == nil)
        return s;
    return strcpy(s, t) + strlen(t);
}
@

<<function [[quote]]>>=
/* quote attribute value, if necessary */
static char*
quote(char *s, char *buf, char *bufe)
{
    char *t;
    int c;

    if(s == nil){
        buf[0] = '\0';
        return buf;
    }
    if(strpbrk(s, " '=\t") == nil)
        return s;
    t = buf;
    *t++ = '\'';
    while(t < bufe-2){
        c = *s++;
        if(c == '\0')
            break;
        *t++ = c;
        if(c == '\'')
            *t++ = c;
    }
    *t++ = '\'';
    *t = '\0';
    return buf;
}
@

<<function [[plumbpackattr]]>>=
char*
plumbpackattr(Plumbattr *attr)
{
    int n;
    Plumbattr *a;
    char *s, *t, *buf, *bufe;

    if(attr == nil)
        return nil;
    if((buf = malloc(4096)) == nil)
        return nil;
    bufe = buf + 4096;
    n = 0;
    for(a=attr; a!=nil; a=a->next)
        n += Strlen(a->name) + 1 + Strlen(quote(a->value, buf, bufe)) + 1;
    s = malloc(n);
    if(s == nil) {
        free(buf);
        return nil;
    }
    t = s;
    *t = '\0';
    for(a=attr; a!=nil; a=a->next){
        if(t != s)
            *t++ = ' ';
        strcpy(t, a->name);
        strcat(t, "=");
        strcat(t, quote(a->value, buf, bufe));
        t += strlen(t);
    }
    if(t > s+n)
        abort();
    free(buf);
    return s;
}
@

<<function [[plumblookup]]>>=
char*
plumblookup(Plumbattr *attr, char *name)
{
    while(attr){
        if(strcmp(attr->name, name) == 0)
            return attr->value;
        attr = attr->next;
    }
    return nil;
}
@

<<function [[plumbpack]]>>=
char*
plumbpack(Plumbmsg *m, int *np)
{
    int n, ndata;
    char *buf, *p, *attr;

    ndata = m->ndata;
    if(ndata < 0)
        ndata = Strlen(m->data);
    attr = plumbpackattr(m->attr);
    n = Strlen(m->src)+1 + Strlen(m->dst)+1 + Strlen(m->wdir)+1 +
        Strlen(m->type)+1 + Strlen(attr)+1 + 16 + ndata;
    buf = malloc(n+1);	/* +1 for '\0' */
    if(buf == nil){
        free(attr);
        return nil;
    }
    p = Strcpy(buf, m->src);
    *p++ = '\n';
    p = Strcpy(p, m->dst);
    *p++ = '\n';
    p = Strcpy(p, m->wdir);
    *p++ = '\n';
    p = Strcpy(p, m->type);
    *p++ = '\n';
    p = Strcpy(p, attr);
    *p++ = '\n';
    p += sprint(p, "%d\n", ndata);
    memmove(p, m->data, ndata);
    *np = (p-buf)+ndata;
    buf[*np] = '\0';	/* null terminate just in case */
    if(*np >= n+1)
        abort();
    free(attr);
    return buf;
}
@

<<function [[plumbsend]]>>=
int
plumbsend(int fd, Plumbmsg *m)
{
    char *buf;
    int n;

    buf = plumbpack(m, &n);
    if(buf == nil)
        return -1;
    n = write(fd, buf, n);
    free(buf);
    return n;
}
@

<<function [[plumbline]]>>=
static int
plumbline(char **linep, char *buf, int i, int n, int *bad)
{
    int starti;
    char *p;

    starti = i;
    while(i<n && buf[i]!='\n')
        i++;
    if(i == n)
        *bad = 1;
    else{
        p = malloc((i-starti) + 1);
        if(p == nil)
            *bad = 1;
        else{
            memmove(p, buf+starti, i-starti);
            p[i-starti] = '\0';
        }
        *linep = p;
        i++;
    }
    return i;
}
@

<<function [[plumbfree]]>>=
void
plumbfree(Plumbmsg *m)
{
    Plumbattr *a, *next;

    free(m->src);
    free(m->dst);
    free(m->wdir);
    free(m->type);
    for(a=m->attr; a!=nil; a=next){
        next = a->next;
        free(a->name);
        free(a->value);
        free(a);
    }
    free(m->data);
    free(m);
}
@

<<function [[plumbunpackattr]]>>=
Plumbattr*
plumbunpackattr(char *p)
{
    Plumbattr *attr, *prev, *a;
    char *q, *v, *buf, *bufe;
    int c, quoting;

    buf = malloc(4096);
    if(buf == nil)
        return nil;
    bufe = buf + 4096;
    attr = prev = nil;
    while(*p!='\0' && *p!='\n'){
        while(*p==' ' || *p=='\t')
            p++;
        if(*p == '\0')
            break;
        for(q=p; *q!='\0' && *q!='\n' && *q!=' ' && *q!='\t'; q++)
            if(*q == '=')
                break;
        if(*q != '=')
            break;	/* malformed attribute */
        a = malloc(sizeof(Plumbattr));
        if(a == nil)
            break;
        a->name = malloc(q-p+1);
        if(a->name == nil){
            free(a);
            break;
        }
        memmove(a->name, p, q-p);
        a->name[q-p] = '\0';
        /* process quotes in value */
        q++;	/* skip '=' */
        v = buf;
        quoting = 0;
        while(*q!='\0' && *q!='\n'){
            if(v >= bufe)
                break;
            c = *q++;
            if(quoting){
                if(c == '\''){
                    if(*q == '\'')
                        q++;
                    else{
                        quoting = 0;
                        continue;
                    }
                }
            }else{
                if(c==' ' || c=='\t')
                    break;
                if(c == '\''){
                    quoting = 1;
                    continue;
                }
            }
            *v++ = c;
        }
        a->value = malloc(v-buf+1);
        if(a->value == nil){
            free(a->name);
            free(a);
            break;
        }
        memmove(a->value, buf, v-buf);
        a->value[v-buf] = '\0';
        a->next = nil;
        if(prev == nil)
            attr = a;
        else
            prev->next = a;
        prev = a;
        p = q;
    }
    free(buf);
    return attr;
}
@

<<function [[plumbaddattr]]>>=
Plumbattr*
plumbaddattr(Plumbattr *attr, Plumbattr *new)
{
    Plumbattr *l;

    l = attr;
    if(l == nil)
        return new;
    while(l->next != nil)
        l = l->next;
    l->next = new;
    return attr;
}
@

<<function [[plumbdelattr]]>>=
Plumbattr*
plumbdelattr(Plumbattr *attr, char *name)
{
    Plumbattr *l, *prev;

    prev = nil;
    for(l=attr; l!=nil; l=l->next){
        if(strcmp(name, l->name) == 0)
            break;
        prev = l;
    }
    if(l == nil)
        return nil;
    if(prev)
        prev->next = l->next;
    else
        attr = l->next;
    free(l->name);
    free(l->value);
    free(l);
    return attr;
}
@

<<function [[plumbunpackpartial]]>>=
Plumbmsg*
plumbunpackpartial(char *buf, int n, int *morep)
{
    Plumbmsg *m;
    int i, bad;
    char *ntext, *attr;

    m = malloc(sizeof(Plumbmsg));
    if(m == nil)
        return nil;
    memset(m, 0, sizeof(Plumbmsg));
    if(morep != nil)
        *morep = 0;
    bad = 0;
    i = plumbline(&m->src, buf, 0, n, &bad);
    i = plumbline(&m->dst, buf, i, n, &bad);
    i = plumbline(&m->wdir, buf, i, n, &bad);
    i = plumbline(&m->type, buf, i, n, &bad);
    i = plumbline(&attr, buf, i, n, &bad);
    i = plumbline(&ntext, buf, i, n, &bad);
    if(bad){
        plumbfree(m);
        return nil;
    }
    m->attr = plumbunpackattr(attr);
    free(attr);
    m->ndata = atoi(ntext);
    if(m->ndata != n-i){
        bad = 1;
        if(morep!=nil && m->ndata>n-i)
            *morep = m->ndata - (n-i);
    }
    free(ntext);
    if(!bad){
        m->data = malloc(n-i+1);	/* +1 for '\0' */
        if(m->data == nil)
            bad = 1;
        else{
            memmove(m->data, buf+i, m->ndata);
            m->ndata = n-i;
            /* null-terminate in case it's text */
            m->data[m->ndata] = '\0';
        }
    }
    if(bad){
        plumbfree(m);
        m = nil;
    }
    return m;
}
@

<<function [[plumbunpack]]>>=
Plumbmsg*
plumbunpack(char *buf, int n)
{
    return plumbunpackpartial(buf, n, nil);
}
@

<<function [[plumbrecv]]>>=
Plumbmsg*
plumbrecv(int fd)
{
    char *buf;
    Plumbmsg *m;
    int n, more;

    buf = malloc(8192);
    if(buf == nil)
        return nil;
    n = read(fd, buf, 8192);
    m = nil;
    if(n > 0){
        m = plumbunpackpartial(buf, n, &more);
        if(m==nil && more>0){
            /* we now know how many more bytes to read for complete message */
            buf = realloc(buf, n+more);
            if(buf == nil)
                return nil;
            if(readn(fd, buf+n, more) == more)
                m = plumbunpackpartial(buf, n+more, nil);
        }
    }
    free(buf);
    return m;
}
@


\subsubsection{Event-based plumbing}


<<struct [[EQueue]]>>=
struct EQueue
{
    int		id;
    char		*buf;
    int		nbuf;
    EQueue	*next;
};
@

<<global [[equeue]]>>=
static	EQueue	*equeue;
@

<<global [[eqlock]]>>=
static	Lock		eqlock;
@

<<function [[partial]]>>=
static
int
partial(int id, Event *e, uchar *b, int n)
{
    EQueue *eq, *p;
    int nmore;

    lock(&eqlock);
    for(eq = equeue; eq != nil; eq = eq->next)
        if(eq->id == id)
            break;
    unlock(&eqlock);
    if(eq == nil)
        return 0;
    /* partial message exists for this id */
    eq->buf = realloc(eq->buf, eq->nbuf+n);
    if(eq->buf == nil)
        drawerror(display, "eplumb: cannot allocate buffer");
    memmove(eq->buf+eq->nbuf, b, n);
    eq->nbuf += n;
    e->v = plumbunpackpartial((char*)eq->buf, eq->nbuf, &nmore);
    if(nmore == 0){	/* no more to read in this message */
        lock(&eqlock);
        if(eq == equeue)
            equeue = eq->next;
        else{
            for(p = equeue; p!=nil && p->next!=eq; p = p->next)
                ;
            if(p == nil)
                drawerror(display, "eplumb: bad event queue");
            p->next = eq->next;
        }
        unlock(&eqlock);
        free(eq->buf);
        free(eq);
    }
    return 1;
}
@

<<function [[addpartial]]>>=
static
void
addpartial(int id, char *b, int n)
{
    EQueue *eq;

    eq = malloc(sizeof(EQueue));
    if(eq == nil)
        return;
    eq->id = id;
    eq->nbuf = n;
    eq->buf = malloc(n);
    if(eq->buf == nil){
        free(eq);
        return;
    }
    memmove(eq->buf, b, n);
    lock(&eqlock);
    eq->next = equeue;
    equeue = eq;
    unlock(&eqlock);
}
@

<<function [[plumbevent]]>>=
static
int
plumbevent(int id, Event *e, uchar *b, int n)
{
    int nmore;

    if(partial(id, e, b, n) == 0){
        /* no partial message already waiting for this id */
        e->v = plumbunpackpartial((char*)b, n, &nmore);
        if(nmore > 0)	/* incomplete message */
            addpartial(id, (char*)b, n);
    }
    if(e->v == nil)
        return 0;
    return id;
}
@

<<function [[eplumb]]>>=
int
eplumb(int key, char *port)
{
    int fd;

    fd = plumbopen(port, OREAD|OCEXEC);
    if(fd < 0)
        return -1;
    return estartfn(key, fd, 8192, plumbevent);
}
@


\subsection{Auto complete}
\label{sec:completion}

<<[[wkeyctl()]] special key cases and no special mode>>=
case 0x06:	/* ^F: file name completion */
case Kins:		/* Insert: file name completion */
    rp = namecomplete(w);
    if(rp == nil)
        return;
    nr = runestrlen(rp);
    q0 = w->q0;
    q0 = winsert(w, rp, nr, q0);
    wshow(w, q0+nr);
    free(rp);
    return;
@


<<struct [[Completion]]>>=
struct Completion{
    uchar advance;	/* whether forward progress has been made */
    uchar complete;	/* whether the completion now represents a file or directory */
    char *string; /* the string to advance, suffixed " " or "/" for file or directory */
    int nmatch;		/* number of files that matched */
    int nfile;		/* number of files returned */
    char **filename;	/* their names */
};
@

% wkeyctl -> <>
<<function [[namecomplete]]>>=
Rune*
namecomplete(Window *w)
{
    int nstr, npath;
    Rune *rp, *path, *str;
    Completion *c;
    char *s, *dir, *root;

    /* control-f: filename completion; works back to white space or / */
    if(w->q0<w->nr && w->r[w->q0]>' ')	/* must be at end of word */
        return nil;
    nstr = windfilewidth(w, w->q0, true);
    str = runemalloc(nstr);
    runemove(str, w->r+(w->q0-nstr), nstr);
    npath = windfilewidth(w, w->q0-nstr, false);
    path = runemalloc(npath);
    runemove(path, w->r+(w->q0-nstr-npath), npath);
    rp = nil;

    /* is path rooted? if not, we need to make it relative to window path */
    if(npath>0 && path[0]=='/'){
        dir = malloc(UTFmax*npath+1);
        sprint(dir, "%.*S", npath, path);
    }else{
        if(strcmp(w->dir, "") == 0)
            root = ".";
        else
            root = w->dir;
        dir = malloc(strlen(root)+1+UTFmax*npath+1);
        sprint(dir, "%s/%.*S", root, npath, path);
    }
    dir = cleanname(dir);

    s = smprint("%.*S", nstr, str);
    c = complete(dir, s);
    free(s);
    if(c == nil)
        goto Return;

    if(!c->advance)
        showcandidates(w, c);

    if(c->advance)
        rp = runesmprint("%s", c->string);

  Return:
    freecompletion(c);
    free(dir);
    free(path);
    free(str);
    return rp;
}
@


<<function [[showcandidates]]>>=
void
showcandidates(Window *w, Completion *c)
{
    int i;
    Fmt f;
    Rune *rp;
    uint nr, qline, q0;
    char *s;

    runefmtstrinit(&f);
    if (c->nmatch == 0)
        s = "[no matches in ";
    else
        s = "[";
    if(c->nfile > 32)
        fmtprint(&f, "%s%d files]\n", s, c->nfile);
    else{
        fmtprint(&f, "%s", s);
        for(i=0; i<c->nfile; i++){
            if(i > 0)
                fmtprint(&f, " ");
            fmtprint(&f, "%s", c->filename[i]);
        }
        fmtprint(&f, "]\n");
    }
    /* place text at beginning of line before host point */
    qline = w->qh;
    while(qline>0 && w->r[qline-1] != '\n')
        qline--;

    rp = runefmtstrflush(&f);
    nr = runestrlen(rp);

    q0 = w->q0;
    q0 += winsert(w, rp, runestrlen(rp), qline) - qline;
    free(rp);
    wsetselect(w, q0+nr, q0+nr);
}
@


% showcandidates -> <>
<<function [[windfilewidth]]>>=
int
windfilewidth(Window *w, uint q0, int oneelement)
{
    uint q;
    Rune r;

    q = q0;
    while(q > 0){
        r = w->r[q-1];
        if(r<=' ')
            break;
        if(oneelement && r=='/')
            break;
        --q;
    }
    return q0-q;
}
@

\subsubsection{[[complete()]]}
% libcomplete

<<function [[complete]]>>=
Completion*
complete(char *dir, char *s)
{
    long i, l, n, nfile, len, nbytes;
    int fd, minlen;
    Dir *dirp;
    char **name, *p;
    ulong* mode;
    Completion *c;

    if(strchr(s, '/') != nil){
        werrstr("slash character in name argument to complete()");
        return nil;
    }

    fd = open(dir, OREAD);
    if(fd < 0)
        return nil;

    n = dirreadall(fd, &dirp);
    if(n <= 0){
        close(fd);
        return nil;
    }

    /* find longest string, for allocation */
    len = 0;
    for(i=0; i<n; i++){
        l = strlen(dirp[i].name) + 1 + 1; /* +1 for /   +1 for \0 */
        if(l > len)
            len = l;
    }

    name = malloc(n*sizeof(char*));
    mode = malloc(n*sizeof(ulong));
    c = malloc(sizeof(Completion) + len);
    if(name == nil || mode == nil || c == nil)
        goto Return;
    memset(c, 0, sizeof(Completion));

    /* find the matches */
    len = strlen(s);
    nfile = 0;
    minlen = 1000000;
    for(i=0; i<n; i++)
        if(strncmp(s, dirp[i].name, len) == 0){
            name[nfile] = dirp[i].name;
            mode[nfile] = dirp[i].mode;
            if(minlen > strlen(dirp[i].name))
                minlen = strlen(dirp[i].name);
            nfile++;
        }

    if(nfile > 0) {
        /* report interesting results */
        /* trim length back to longest common initial string */
        for(i=1; i<nfile; i++)
            minlen = longestprefixlength(name[0], name[i], minlen);

        /* build the answer */
        c->complete = (nfile == 1);
        c->advance = c->complete || (minlen > len);
        c->string = (char*)(c+1);
        memmove(c->string, name[0]+len, minlen-len);
        if(c->complete)
            c->string[minlen++ - len] = (mode[0]&DMDIR)? '/' : ' ';
        c->string[minlen - len] = '\0';
        c->nmatch = nfile;
    } else {
        /* no match, so return all possible strings */
        for(i=0; i<n; i++){
            name[i] = dirp[i].name;
            mode[i] = dirp[i].mode;
        }
        nfile = n;
        c->nmatch = 0;
    }

    /* attach list of names */
    nbytes = nfile * sizeof(char*);
    for(i=0; i<nfile; i++)
        nbytes += strlen(name[i]) + 1 + 1;
    c->filename = malloc(nbytes);
    if(c->filename == nil)
        goto Return;
    p = (char*)(c->filename + nfile);
    for(i=0; i<nfile; i++){
        c->filename[i] = p;
        strcpy(p, name[i]);
        p += strlen(p);
        if(mode[i] & DMDIR)
            *p++ = '/';
        *p++ = '\0';
    }
    c->nfile = nfile;
    qsort(c->filename, c->nfile, sizeof(c->filename[0]), strpcmp);

  Return:
    free(name);
    free(mode);
    free(dirp);
    close(fd);
    return c;
}
@


<<function [[longestprefixlength]]>>=
static int
longestprefixlength(char *a, char *b, int n)
{
    int i, w;
    Rune ra, rb;

    for(i=0; i<n; i+=w){
        w = chartorune(&ra, a);
        chartorune(&rb, b);
        if(ra != rb)
            break;
        a += w;
        b += w;
    }
    return i;
}
@

<<function [[freecompletion]]>>=
void
freecompletion(Completion *c)
{
    if(c){
        free(c->filename);
        free(c);
    }
}
@

<<function [[strpcmp]]>>=
static int
strpcmp(const void *va, const void *vb)
{
    char *a, *b;

    a = *(char**)va;
    b = *(char**)vb;
    return strcmp(a, b);
}
@

\subsubsection{[[/mnt/wsys/wdir]]}
\label{sec:wdir}
% dead? I don't see any good use of w->dir. or use for
%  pluminb via wdir (flowing from w->dir).
%  Or used for filename completion? so terminal emulator
%  updates that? but program can also modifies it?

<<[[qid]] cases>>=
Qwdir,
@
<<dirtab array elements>>=
{ "wdir",		QTFILE,	Qwdir,		0600 },
@

<<[[xfidread()]] cases>>=
case Qwdir:
    t = estrdup(w->dir);
    n = strlen(t);
    goto Text;
@


% so can write on /dev/wdir, but effect?
% a bit like chdir()?

<<[[xfidwrite()]] cases>>=
case Qwdir:
    if(cnt == 0)
        break;
    if(req->data[cnt-1] == '\n'){
        if(cnt == 1)
            break;
        req->data[cnt-1] = '\0';
    }
    /* assume data comes in a single write */
    /*
      * Problem: programs like dossrv, ftp produce illegal UTF;
      * we must cope by converting it first.
      */
    snprint(buf, sizeof buf, "%.*s", cnt, req->data);
    if(buf[0] == '/'){
        free(w->dir);
        w->dir = estrdup(buf);
    }else{
        p = emalloc(strlen(w->dir) + 1 + strlen(buf) + 1);
        sprint(p, "%s/%s", w->dir, buf);
        free(w->dir);
        w->dir = cleanname(p);
    }
    break;
@


\subsection{Word selection}

<<global [[clickwin]]>>=
static Window	*clickwin;
@

<<global [[clickmsec]]>>=
static uint	clickmsec;
@

<<global [[selectwin]]>>=
static Window	*selectwin;
@

<<global [[selectq]]>>=
static uint	selectq;
@



<<function [[wselect]]>>=
void
wselect(Window *w)
{
    uint q0, q1;
    int b, x, y, first;
    Frame *frm = &w->frm;

    first = 1;
    selectwin = w;
    /*
     * Double-click immediately if it might make sense.
     */
    b = w->mc.buttons;
    q0 = w->q0;
    q1 = w->q1;
    selectq = w->org + frcharofpt(frm, w->mc.xy);
    if(clickwin==w && w->mc.msec-clickmsec<500)
    if(q0==q1 && selectq==w->q0){
        wdoubleclick(w, &q0, &q1);
        wsetselect(w, q0, q1);
        flushimage(display, 1);
        x = w->mc.xy.x;
        y = w->mc.xy.y;
        /* stay here until something interesting happens */
        do
            readmouse(&w->mc);
        while(w->mc.buttons==b && abs(w->mc.xy.x-x)<3 && abs(w->mc.xy.y-y)<3);
        w->mc.xy.x = x;	/* in case we're calling frselect */
        w->mc.xy.y = y;
        q0 = w->q0;	/* may have changed */
        q1 = w->q1;
        selectq = q0;
    }
    if(w->mc.buttons == b){
        frm->scroll = framescroll;
        frselect(frm, &w->mc);
        /* horrible botch: while asleep, may have lost selection altogether */
        if(selectq > w->nr)
            selectq = w->org + frm->p0;
        frm->scroll = nil;
        if(selectq < w->org)
            q0 = selectq;
        else
            q0 = w->org + frm->p0;
        if(selectq > w->org + frm->nchars)
            q1 = selectq;
        else
            q1 = w->org + frm->p1;
    }
    if(q0 == q1){
        if(q0==w->q0 && clickwin==w && w->mc.msec-clickmsec<500){
            wdoubleclick(w, &q0, &q1);
            clickwin = nil;
        }else{
            clickwin = w;
            clickmsec = w->mc.msec;
        }
    }else
        clickwin = nil;
    wsetselect(w, q0, q1);
    flushimage(display, 1);
    while(w->mc.buttons){
        w->mc.msec = 0;
        b = w->mc.buttons;
        if(b & 6){
            if(b & 2){
                wsnarf(w);
                wcut(w);
            }else{
                if(first){
                    first = 0;
                    getsnarf();
                }
                wpaste(w);
            }
        }
        wscrdraw(w);
        flushimage(display, 1);
        while(w->mc.buttons == b)
            readmouse(&w->mc);
        clickwin = nil;
    }
}
@




<<global [[left1]]>>=
static Rune left1[] =  { L'{', L'[', L'(', L'<', L'«', 0 };
@

<<global [[right1]]>>=
static Rune right1[] = { L'}', L']', L')', L'>', L'»', 0 };
@

<<global [[left2]]>>=
static Rune left2[] =  { L'\n', 0 };
@

<<global [[left3]]>>=
static Rune left3[] =  { L'\'', L'"', L'`', 0 };
@

<<global [[left]]>>=
Rune *left[] = {
    left1,
    left2,
    left3,
    nil
};
@

<<global [[right]]>>=
Rune *right[] = {
    right1,
    left2,
    left3,
    nil
};
@



<<function [[wdoubleclick]]>>=
void
wdoubleclick(Window *w, uint *q0, uint *q1)
{
    int c, i;
    Rune *r, *l, *p;
    uint q;

    for(i=0; left[i]!=nil; i++){
        q = *q0;
        l = left[i];
        r = right[i];
        /* try matching character to left, looking right */
        if(q == 0)
            c = '\n';
        else
            c = w->r[q-1];
        p = strrune(l, c);
        if(p != nil){
            if(wclickmatch(w, c, r[p-l], 1, &q))
                *q1 = q-(c!='\n');
            return;
        }
        /* try matching character to right, looking left */
        if(q == w->nr)
            c = '\n';
        else
            c = w->r[q];
        p = strrune(r, c);
        if(p != nil){
            if(wclickmatch(w, c, l[p-r], -1, &q)){
                *q1 = *q0+(*q0<w->nr && c=='\n');
                *q0 = q;
                if(c!='\n' || q!=0 || w->r[0]=='\n')
                    (*q0)++;
            }
            return;
        }
    }
    /* try filling out word to right */
    while(*q1<w->nr && isalnum(w->r[*q1]))
        (*q1)++;
    /* try filling out word to left */
    while(*q0>0 && isalnum(w->r[*q0-1]))
        (*q0)--;
}
@


<<function [[wclickmatch]]>>=
int
wclickmatch(Window *w, int cl, int cr, int dir, uint *q)
{
    Rune c;
    int nest;

    nest = 1;
    for(;;){
        if(dir > 0){
            if(*q == w->nr)
                break;
            c = w->r[*q];
            (*q)++;
        }else{
            if(*q == 0)
                break;
            (*q)--;
            c = w->r[*q];
        }
        if(c == cr){
            if(--nest==0)
                return 1;
        }else if(c == cl)
            nest++;
    }
    return cl=='\n' && nest==1;
}
@



\section{Automatic scrolling: [[rio -s]]}


<<global [[scrolling]]>>=
bool		scrolling;
@
\t rename autoscroll too (w->autoscroll and global autoscroll)

<<[[main()]] command line processing>>=
case 's':
    scrolling = true;
    break;
@
% who uses that then? thread_window to decide or not
% to read more from process stdout (see 'qh vs q0 || scrolling')

% and then wmk set w->scrolling to default global value in scrolling
% passed when new()


\section{Initial command: [[rio -i]]}

<<[[main()]] locals>>=
char *initstr = nil;
@

<<[[main()]] command line processing>>=
case 'i':
    initstr = ARGF();
    if(initstr == nil)
        usage();
    break;
@

<<[[main()]] if initstr or kdbin>>=
if(initstr)
    proccreate(initcmd, initstr, STACK);
@

% process initcmd -> rename procinitcmd? or initcmdproc?
<<function [[initcmd]]>>=
void
initcmd(void *arg)
{
    char *cmd;

    cmd = arg;
    rfork(RFENVG|RFFDG|RFNOTEG|RFNAMEG);
    procexecl(nil, "/bin/rc", "rc", "-c", cmd, nil);
    fprint(STDERR, "rio: exec failed: %r\n");
    exits("exec");
}
@

\section{Fake keyboard input: [[rio -k]]}
% what for? to help debug app? to automate testing?
% put in Debugging support chapter? or Debugging chapter
% if it helps debug only rio itself

\subsection{[[rio -k]]}

<<[[main()]] locals>>=
char *kbdin = nil;
@

<<[[main()]] command line processing>>=
case 'k':
    if(kbdin != nil)
        usage();
    kbdin = ARGF();
    if(kbdin == nil)
        usage();
    break;
@



<<global [[wkeyboard]]>>=
Window	*wkeyboard;	/* window of simulated keyboard */
@




<<global [[kbdargv]]>>=
char *kbdargv[] = { "rc", "-c", nil, nil };
@

<<[[main()]] locals>>=
Image *i;
Rectangle r;
@

<<[[main()]] if initstr or kdbin>>=
if(kbdin){
    kbdargv[2] = kbdin;
    r = view->r;
    r.max.x = r.min.x+300;
    r.max.y = r.min.y+80;
    i = allocwindow(desktop, r, Refbackup, DWhite);
    wkeyboard = new(i, false, scrolling, 0, nil, "/bin/rc", kbdargv);
    if(wkeyboard == nil)
        error("can't create keyboard window");
}
@



\subsection{[[wkeyboard]]}

<<[[mousethread()]] if wkeyboard and button 6>>=
if(wkeyboard!=nil && (mouse->buttons & (1<<5))){
    keyboardhide();
    break;
}
@

<<[[mousethread()]] if wkeyboard and ptinrect>>=
/* override everything for the keyboard window */
if(wkeyboard!=nil && ptinrect(mouse->xy, wkeyboard->screenr)){
    /* make sure it's on top; this call is free if it is */
    wtopme(wkeyboard);
    winput = wkeyboard;
}
@

<<[[wcurrent()]] if wkeyboard>>=
if(wkeyboard!=nil && w==wkeyboard)
    return;
@

<<[[wclosewin()]] if wkeyboard>>=
if(w == wkeyboard)
    wkeyboard = nil;
@

\subsection{[[/mnt/wsys/kdbin]]}

<<[[qid]] cases>>=
Qkbdin,
@
<<dirtab array elements>>=
{ "kbdin",		QTFILE,	Qkbdin,		0200 },
@

<<[[xfidopen()]] cases>>=
case Qkbdin:
    if(w !=  wkeyboard){
        filsysrespond(x->fs, x, &fc, Eperm);
        return;
    }
    break;
@

<<[[xfidwrite()]] cases>>=
case Qkbdin:
    keyboardsend(req->data, cnt);
    break;
@

<<function [[keyboardsend]]>>=
/*
 * Used by /dev/kbdin
 */
void
keyboardsend(char *s, int cnt)
{
    Rune *r;
    int i, nb, nr;

    r = runemalloc(cnt);
    /* BUGlet: partial runes will be converted to error runes */
    cvttorunes(s, cnt, r, &nb, &nr, nil);
    for(i=0; i<nr; i++)
        send(keyboardctl->c, &r[i]);
    free(r);
}
@

\subsection{Keyboard hide}

% button 6 ???

<<function [[keyboardhide]]>>=
/*
 * Button 6 - keyboard toggle - has been pressed.
 * Send event to keyboard, wait for button up, send that.
 * Note: there is no coordinate translation done here; this
 * is just about getting button 6 to the keyboard simulator.
 */
void
keyboardhide(void)
{
    send(wkeyboard->mc.c, mouse);
    do
        readmouse(mousectl);
    while(mouse->buttons & (1<<5));
    send(wkeyboard->mc.c, mouse);
}
@


\section{Font selection: [[rio -f]]}

<<global [[fontname]]>>=
char		*fontname;
@

<<[[main()]] command line processing>>=
case 'f':
    fontname = ARGF();
    if(fontname == nil)
        usage();
    break;
@

<<[[main()]] set some globals>>=
if(fontname == nil)
    fontname = getenv("font");
if(fontname == nil)
    fontname = "/lib/font/bit/lucm/unicode.9.font";

/* check font before barging ahead */
if(access(fontname, 0) < 0){
    fprint(STDERR, "rio: can't access %s: %r\n", fontname);
    exits("font open");
}

putenv("font", fontname);
@


\section{Holding mode}

% ??? why someone wants to write holdon? to stop key event to
% go to app?

% also a textual window field?
<<[[Window]] config fields>>=
bool	holding;
@
%old: bool_byte

% main effect! no sending on /dev/cons

<<[[winctl()]] alts adjustments, if holding>>=
if(w->holding)
    alts[WCread].op = CHANNOP;
@



% visual effect

<<[[wsetcursor()]] if holding>>=
if(p==nil && w->holding)
    p = &whitearrow;
@

<<[[wborder()]] if holding>>=
if(w->holding){
    if(type == Selborder)
        col = holdcol;
    else
        col = paleholdcol;
}
@


<<[[wsetcols()]] if holding>>=
if(w->holding)
    if(w == input)
        w->frm.cols[TEXT] = w->frm.cols[HTEXT] = holdcol;
    else
        w->frm.cols[TEXT] = w->frm.cols[HTEXT] = lightholdcol;
@



% for holding mode
<<global [[holdcol]]>>=
static	Image	*holdcol;
@

<<global [[paleholdcol]]>>=
static	Image	*paleholdcol;
@

<<global [[lightholdcol]]>>=
static	Image	*lightholdcol;
@

<<[[wmk()]] extra colors initialisation>>=
holdcol      = allocimage(display, Rect(0,0,1,1), CMAP8, true, DMedblue);
lightholdcol = allocimage(display, Rect(0,0,1,1), CMAP8, true, DGreyblue);
paleholdcol  = allocimage(display, Rect(0,0,1,1), CMAP8, true, DPalegreyblue
@

% how set it up (dev/consctl or special key)

<<[[Wctlmesgkind]] cases>>=
Holdon,
Holdoff,
@

<<[[xfidwrite()]] Qconsctl case>>=
if(strncmp(req->data, "holdon", 6)==0){
    if(w->holding++ == 0)
        wsendctlmesg(w, Holdon, ZR, nil);
    break;
}
if(strncmp(req->data, "holdoff", 7)==0 && w->holding){
    if(--w->holding == false)
        wsendctlmesg(w, Holdoff, ZR, nil);
    break;
}
@

<<[[xfidclose()]] Qconsctl case, if holding>>=
if(w->holding){
    w->holding = false;
    wsendctlmesg(w, Holdoff, ZR, nil);
}
@

<<[[xfidwrite()]] Qconsctl case, if rawon message and holding mode>>=
if(w->holding){
    w->holding = false;
    wsendctlmesg(w, Holdoff, ZR, nil);
}
@




<<[[wkeyctl()]] if holding>>=
if(r==0x1B || (w->holding && r==0x7F)){	/* toggle hold */
    if(w->holding)
        --w->holding;
    else
        w->holding++;
    wrepaint(w);
    if(r == 0x1B)
        return;
}
@
% use = false and = true instead?

% wrepaint because wsetborder will change certain colors now!
<<[[wctlmesg()]] cases>>=
case Holdon:
case Holdoff:
    <<[[wctlmesg()]] break if window was deleted>>
    wrepaint(w);
    flushimage(display, true);
    break;
@


\section{Signals, notes}

% saw some hangup before note when delete a window
% and want to kill associated process

<<global [[oknotes]]>>=
char *oknotes[] =
{
    "delete",
    "hangup",
    "kill",
    "exit",
    nil
};
@


% threadmain -> threadnotify(<>, 1);
<<function [[shutdown]]>>=
int
shutdown(void *, char *msg)
{
    int i;
    static Lock shutdownlk;
    
    killprocs();
    for(i=0; oknotes[i]; i++)
        if(strncmp(oknotes[i], msg, strlen(oknotes[i])) == 0){
            lock(&shutdownlk);	/* only one can threadexitsall */
            threadexitsall(msg);
        }
    fprint(STDERR, "rio %d: abort: %s\n", getpid(), msg);
    abort();
    exits(msg);
    return 0;
}
@

<<function [[killprocs]]>>=
void
killprocs(void)
{
    int i;

    for(i=0; i<nwindow; i++)
        postnote(PNGROUP, windows[i]->pid, "hangup");
}
@


\section{Timer}

% seems only used by wscrsleep so maybe should be in adv topics,
%  but maybe it's an interesting thing to show

<<global [[clockfd]]>>=
fdt	clockfd;
@

<<[[filsysinit()]] set clockfd>>=
clockfd = open("/dev/time", OREAD|OCEXEC);
@

%  -> <>
% used to give current date for files /dev/xxx
<<function [[getclock]]>>=
static
uint
getclock(void)
{
    char buf[32];

    seek(clockfd, 0, 0);
    read(clockfd, buf, sizeof buf);
    return atoi(buf);
}
@







% who uses the timer and timerproc?
% wscrsleep


<<struct [[Timer]]>>=
struct Timer
{
    int		dt;
    int		cancel;
    Channel	*c;	/* chan(int) */
    Timer	*next;
};
@

<<[[main()]] threads creation>>=
timerinit();
@
% need be before the other thread? or order does not matter?

<<function [[timerinit]]>>=
void
timerinit(void)
{
    ctimer = chancreate(sizeof(Timer*), 100);
    proccreate(timerproc, nil, STACK);
}
@

<<function [[timerproc]]>>=
static
void
timerproc(void*)
{
    int i, nt, na, dt, del;
    Timer **t, *x;
    uint old, new;

    rfork(RFFDG);
    threadsetname("TIMERPROC");

    t = nil;
    na = 0;
    nt = 0;
    old = msec();
    for(;;){
        sleep(1);	/* will sleep minimum incr */
        new = msec();
        dt = new-old;
        old = new;
        if(dt < 0)	/* timer wrapped; go around, losing a tick */
            continue;
        for(i=0; i<nt; i++){
            x = t[i];
            x->dt -= dt;
            del = 0;
            if(x->cancel){
                timerstop(x);
                del = 1;
            }else if(x->dt <= 0){
                /*
                 * avoid possible deadlock if client is
                 * now sending on ctimer
                 */
                if(nbsendul(x->c, 0) > 0)
                    del = 1;
            }
            if(del){
                memmove(&t[i], &t[i+1], (nt-i-1)*sizeof t[0]);
                --nt;
                --i;
            }
        }
        if(nt == 0){
            x = recvp(ctimer);
    gotit:
            if(nt == na){
                na += 10;
                t = realloc(t, na*sizeof(Timer*));
                if(t == nil)
                    abort();
            }
            t[nt++] = x;
            old = msec();
        }
        if(nbrecv(ctimer, &x) > 0)
            goto gotit;
    }
}
@






<<global [[ctimer]]>>=
// chan<?> (listener = ?, sender = ?)
static Channel*	ctimer;	/* chan(Timer*)[100] */
@

<<global [[timer]]>>=
static Timer *timer;
@

<<function [[msec]]>>=
static
uint
msec(void)
{
    return nsec()/1000000;
}
@

<<function [[timerstop]]>>=
void
timerstop(Timer *t)
{
    t->next = timer;
    timer = t;
}
@

<<function [[timercancel]]>>=
void
timercancel(Timer *t)
{
    t->cancel = true;
}
@



<<function [[timerstart]]>>=
/*
 * timeralloc() and timerfree() don't lock, so can only be
 * called from the main proc.
 */
Timer*
timerstart(int dt)
{
    Timer *t;

    t = timer;
    if(t)
        timer = timer->next;
    else{
        t = emalloc(sizeof(Timer));
        t->c = chancreate(sizeof(int), 0);
    }
    t->next = nil;
    t->dt = dt;
    t->cancel = false;
    sendp(ctimer, t);
    return t;
}
@





\section{Flushing}

%from docs/man/5/flush
%"When the response to a request is no longer needed, such as when
%a user interrupts a process doing a read (2), a Tflush
%request is sent to the server to purge the pending response."

% so looks like an advanced fileserver feature which is not super needed.


<<[[Xfid]] flushing fields>>=
int	flushtag;	/* our tag, so flush can find us */
// chan<int> (listener = ?, sender = ?)
Channel	*flushc;/* channel(int) to notify us we're being flushed */
bool	flushing;	/* another Xfid is trying to flush us */
@

<<[[xfidallocthread()]] create flushc channel>>=
x->flushc = chancreate(sizeof(int), 0);	/* notification only; nodata */
x->flushtag = -1;
@

<<[[Xfid]] other fields>>=
QLock	active;
@
% seems used for concurrent access by xfidflush

<<[[fcall]] other methods>>=
[Tflush]   = filsysflush,
@

<<function [[filsysflush]]>>=
static
Xfid*
filsysflush(Filsys*, Xfid *x, Fid*)
{
    sendp(x->c, xfidflush);
    return nil;
}
@


<<function [[xfidflush]]>>=
void
xfidflush(Xfid *x)
{
    Fcall fc;
    Xfid *xf;

    for(xf=xfid; xf; xf=xf->next)
        if(xf->flushtag == x->req.oldtag){
            xf->flushtag = -1;
            xf->flushing = true;
            incref(xf);	/* to hold data structures up at tail of synchronization */
            if(xf->ref == 1)
                error("ref 1 in flush");
            if(canqlock(&xf->active)){
                qunlock(&xf->active);
                sendul(xf->flushc, 0);
            }else{
                qlock(&xf->active);	/* wait for him to finish */
                qunlock(&xf->active);
            }
            xf->flushing = false;

            if(decref(xf) == 0)
                sendp(cxfidfree, xf);
            break;
        }
    filsysrespond(x->fs, x, &fc, nil);
}
@


% -> <>
<<function [[filsyscancel]]>>=
void
filsyscancel(Xfid *x)
{
    if(x->buf){
        free(x->buf);
        x->buf = nil;
    }
}
@

<<[[xfidxxx()]] set flushtag>>=
x->flushtag = req->tag;
@
<<[[xfidxxx()]] unset flushtag>>=
x->flushtag = -1;
@



<<[[xfidread()]] when Qmouse, set alts for flush>>=
alts[MRflush].c = x->flushc;
alts[MRflush].v = nil;
alts[MRflush].op = CHANRCV;
@
<<[[xfidread()]] when Qmouse, switch alt flush case>>=
case MRflush:
    filsyscancel(x);
    return;
@
<<[[xfidread()]] when Qmouse, if flushing>>=
if(x->flushing){
    recv(x->flushc, nil);		/* wake up flushing xfid */
    recv(mrm.cm, nil);			/* wake up window and toss data */
    filsyscancel(x);
    return;
}
@

<<[[xfidread()]] when Qcons, set alts for flush>>=
alts[CRflush].c = x->flushc;
alts[CRflush].v = nil;
alts[CRflush].op = CHANRCV;
@
<<[[xfidread()]] when Qcons, switch alt flush case>>=
case CRflush:
    filsyscancel(x);
    return;
@
<<[[xfidread()]] when Qcons, if flushing>>=
if(x->flushing){
    recv(x->flushc, nil);	/* wake up flushing xfid */
    recv(c2, nil);			/* wake up window and toss data */
    free(t);
    filsyscancel(x);
    return;
}
@

<<[[xfidwrite()]] when Qcons, set alts for flush>>=
alts[CWflush].c = x->flushc;
alts[CWflush].v = nil;
alts[CWflush].op = CHANRCV;
@
<<[[xfidwrite()]] when Qcons, switch alt flush case>>=
case CWflush:
    filsyscancel(x);
    return;
@
<<[[xfidwrite()]] when Qcons, if flushing>>=
if(x->flushing){
    recv(x->flushc, nil);	/* wake up flushing xfid */
    pair.s = runemalloc(1);
    pair.ns = 0;
    send(cwm.cw, &pair);		/* wake up window with empty data */
    filsyscancel(x);
    return;
}
@


<<[[xfidread()]] when Qwctl, set alts for flush>>=
alts[WCRflush].c = x->flushc;
alts[WCRflush].v = nil;
alts[WCRflush].op = CHANRCV;
@
<<[[xfidread()]] when Qwctl, switch alt flush case>>=
case WCRflush:
    filsyscancel(x);
    return;
@
<<[[xfidread()]] when Qwctl, if flushing>>=
if(x->flushing){
    recv(x->flushc, nil);	/* wake up flushing xfid */
    recv(c2, nil);			/* wake up window and toss data */
    free(t);
    filsyscancel(x);
    return;
}
@

\section{Security}

<<[[filsysinit()]] other locals>>=
fdt fd;
char buf[128];
int n;
@

<<[[filsysinit()]] set fs user>>=
fd = open("/dev/user", OREAD);
strcpy(buf, "Jean-Paul_Belmondo"); // lol
if(fd >= 0){
    n = read(fd, buf, sizeof buf-1);
    if(n > 0)
        buf[n] = '\0';
    close(fd);
}
fs->user = estrdup(buf);
@
%ocaml: let user = cat("/dev/user") |> String.concat "" 

% useful beyond the /srv/rio.user.pid? Yes for security
% the worker and filesystem make sure request match the owner of rio





% none :( like X11? worse?
% can draw everywhere ... so can fish applications.
% BUT in the end security in macOS is just based on trusted
% reviewed apps so they didn't really improved things.

<<[[fcall]] other methods>>=
[Tauth]    = filsysauth,
@

<<function [[filsysauth]]>>=
static
Xfid*
filsysauth(Filsys *fs, Xfid *x, Fid*)
{
    Fcall fc;

    return filsysrespond(fs, x, &fc, "rio: authentication not required");
}
@

\section{TODO [[Wakeup]]}


\t distribute
<<[[Wctlmesgkind]] cases>>=
Wakeup,
@

% wcurrent | button2menu | xfidopen(Qwctl) --> <>
<<[[wctlmesg()]] cases>>=
case Wakeup:
    break;
@
\l what is the point? a nop?

\section{TODO [[Refresh]]}

\t distribute
<<[[Wctlmesgkind]] cases>>=
Refresh,
@
% seems called when close the mouse, maybe to restore frame
% maybe can put in Textual windows chapter

% xfidclose (Qmouse) -> <>
<<[[wctlmesg()]] cases>>=
case Refresh:
    if(w->deleted || Dx(w->screenr)<=0 || !rectclip(&r, w->i->r))
        break;
    if(!w->mouseopen)
        wrefresh(w, r);
    flushimage(display, true);
    break;
@

<<function [[wrefresh]]>>=
void
wrefresh(Window *w, Rectangle)
{
    Frame *frm = &w->frm;

    /* BUG: rectangle is ignored */
    if(w == input)
        wborder(w, Selborder);
    else
        wborder(w, Unselborder);
    if(w->mouseopen)
        return;
    // else

    draw(w->i, insetrect(w->i->r, Borderwidth), frm->cols[BACK], nil, 
         w->i->r.min);
    frm->ticked = false;
    if(frm->p0 > 0)
        frdrawsel(frm, frptofchar(frm, 0), 0, frm->p0, 0);
    if(frm->p1 < frm->nchars)
        frdrawsel(frm, frptofchar(frm, frm->p1), frm->p1, frm->nchars, 0);
    frdrawsel(frm, frptofchar(frm, frm->p0), frm->p0, frm->p1, 1);
    w->lastsr = ZR;
    wscrdraw(w);
}
@





\chapter{Conclusion}
\label{chap:conclusion}









%###############################################################################

\appendix

\chapter{Debugging}
\label{chap:debugging-appendix}

%\section{9P messages}

% in fsys.c
<<constant [[DEBUG]]>>=
#define DEBUG false
@
%ocaml: flag of rio instead

<<[[filsysinit()]] install dumper>>=
fmtinstall('F', fcallfmt);
@
% fcallfmt defined in fcall.h?

<<[[filsysproc()]] dump Fcall if debug>>=
if(DEBUG)
    fprint(STDERR, "rio:<-%F\n", &x->req);
@

<<[[filsysrespond()]] dump Fcall t if debug>>=
if(DEBUG)
    fprint(STDERR, "rio:->%F\n", fc);
@

%\chapter{Profiling}

\chapter{Error Management}
\label{chap:error}

\section{Error codes}

% fsys.c
<<global [[Eperm]]>>=
char Eperm[] = "permission denied";
@

<<global [[Eexist]]>>=
char Eexist[] = "file does not exist";
@

<<global [[Enotdir]]>>=
char Enotdir[] = "not a directory";
@

<<global [[Ebadfcall]]>>=
char	Ebadfcall[] = "bad fcall type";
@

<<global [[Eoffset]]>>=
char	Eoffset[] = "illegal offset";
@


% wctl.c
<<global [[Ebadwr]]>>=
char	Ebadwr[]		= "bad rectangle in wctl request";
@

<<global [[Ewalloc]]>>=
char	Ewalloc[]		= "window allocation failed in wctl request";
@


% xfid.c

<<global [[Einuse]]>>=
char Einuse[] =		"file in use";
@

<<global [[Edeleted]]>>=
char Edeleted[] =	"window deleted";
@

<<global [[Ebadreq]]>>=
char Ebadreq[] =	"bad graphics request";
@

<<global [[Etooshort]]>>=
char Etooshort[] =	"buffer too small";
@

<<global [[Ebadtile]]>>=
char Ebadtile[] =	"unknown tile";
@

<<global [[Eshort]]>>=
char Eshort[] =		"short i/o request";
@

<<global [[Elong]]>>=
char Elong[] = 		"snarf buffer too long";
@

<<global [[Eunkid]]>>=
char Eunkid[] = 	"unknown id in attach";
@

<<global [[Ebadrect]]>>=
char Ebadrect[] = 	"bad rectangle in attach";
@

<<global [[Ewindow]]>>=
char Ewindow[] = 	"cannot make window";
@

<<global [[Enowindow]]>>=
char Enowindow[] = 	"window has no image";
@

<<global [[Ebadmouse]]>>=
char Ebadmouse[] = 	"bad format on /dev/mouse";
@

<<global [[Ebadwrect]]>>=
char Ebadwrect[] = 	"rectangle outside screen";
@

<<global [[Ebadoffset]]>>=
char Ebadoffset[] = 	"window read not on scan line boundary";
@

\section{[[error()]], [[derror()]]}


<<global [[errorshouldabort]]>>=
bool errorshouldabort = false;
@
% who its back to false?


<<[[main()]] error management after everything setup>>=
errorshouldabort = true;/* suicide if there's trouble after this */
<<[[main()]] if initstr or kdbin>>
threadnotify(shutdown, true);
@


<<function [[error]]>>=
void
error(char *s)
{
    fprint(STDERR, "rio: %s: %r\n", s);
    if(errorshouldabort)
        abort();
    threadexitsall("error");
}
@
% abort? diff with exit? generate a fault so go in broken state so
% can be debugged!


% main -> ... <- (as ? <- geninitdraw(<>) <- main)
<<function [[derror]]>>=
void
derror(Display*, char *errorstr)
{
    error(errorstr);
}
@



\chapter{Utilities}
\label{chap:utilities}

<<function [[min]]>>=
int
min(int a, int b)
{
    if(a < b)
        return a;
    return b;
}
@

<<function max (windows/rio/util.c)>>=
int
max(int a, int b)
{
    if(a > b)
        return a;
    return b;
}
@



<<function [[erealloc]]>>=
void*
erealloc(void *p, uint n)
{
    p = realloc(p, n);
    if(p == nil)
        error("realloc failed");
    return p;
}
@

<<function [[emalloc]]>>=
void*
emalloc(uint n)
{
    void *p;

    p = malloc(n);
    if(p == nil)
        error("malloc failed");
    memset(p, 0, n);
    return p;
}
@

<<function [[estrdup]]>>=
char*
estrdup(char *s)
{
    char *p;

    p = malloc(strlen(s)+1);
    if(p == nil)
        error("strdup failed");
    strcpy(p, s);
    return p;
}
@



% not sure why redefine it
<<function [[isalnum]]>>=
//@Scheck: not dead, but conflict with the one in ctype.h
int isalnum(Rune c)
{
    /*
     * Hard to get absolutely right.  Use what we know about ASCII
     * and assume anything above the Latin control characters is
     * potentially an alphanumeric.
     */
    if(c <= ' ')
        return false;
    if(0x7F<=c && c<=0xA0)
        return false;
    if(utfrune("!\"#$%&'()*+,-./:;<=>?@[\\]^`{|}~", c))
        return false;
    return true;
}
@
%$



<<function [[runemalloc]]>>=
#define	runemalloc(n)		malloc((n)*sizeof(Rune))
@

<<function [[runerealloc]]>>=
#define	runerealloc(a, n)	realloc(a, (n)*sizeof(Rune))
@

<<function [[runemove]]>>=
#define	runemove(a, b, n)	memmove(a, b, (n)*sizeof(Rune))
@


% cvt ?? 
<<function [[cvttorunes]]>>=
void
cvttorunes(char *p, int n, Rune *r, int *nb, int *nr, int *nulls)
{
    uchar *q;
    Rune *s;
    int j, w;

    /*
     * Always guaranteed that n bytes may be interpreted
     * without worrying about partial runes.  This may mean
     * reading up to UTFmax-1 more bytes than n; the caller
     * knows this.  If n is a firm limit, the caller should
     * set p[n] = 0.
     */
    q = (uchar*)p;
    s = r;
    for(j=0; j<n; j+=w){
        if(*q < Runeself){
            w = 1;
            *s = *q++;
        }else{
            w = chartorune(s, (char*)q);
            q += w;
        }
        if(*s)
            s++;
        else if(nulls)
                *nulls = true;
    }
    *nb = (char*)q-p;
    *nr = s-r;
}
@




<<function [[strrune]]>>=
Rune*
strrune(Rune *s, Rune c)
{
    Rune c1;

    if(c == 0) {
        while(*s++)
            ;
        return s-1;
    }

    while(c1 = *s++)
        if(c1 == c)
            return s-1;
    return nil;
}
@

<<function [[runetobyte]]>>=
char*
runetobyte(Rune *r, int n, int *ip)
{
    char *s;
    int m;

    s = emalloc(n*UTFmax+1);
    m = snprint(s, n*UTFmax+1, "%.*S", n, r);
    *ip = m;
    return s;
}
@





%\chapter{Frame Library}
% really Text Widget

\chapter{Examples of Windowing System Applications TODO}
\label{chap:examples}

% statusbar
% winwatch

% See Windows_extra.nw

\chapter{Extra Code}

#include "Windows_extra.nw"

%\chapter{Changelog}
%\label{sec:changelog}
% code via make loc = 9500 LOC
% orig nw = 9000, just lpized and few comments, 100? pages pdf
% now: ? LOC ? pages, so added ?? LOE (Lines of explanations)

\chapter*{Glossary}
\label{sec:glossary}
\addcontentsline{toc}{chapter}{Glossary}

\begin{verbatim}
API = Application Programming Interface
GUI = Graphical User Interface
IDE = Integrated Development Environment
IPC = Inter Process Communication
RPC = Remote Procedure Call
LOC = Lines Of Code
PTY = Pseudo TTY
TTY = Teletype
WIMP = Window Icon Menu Pointer
MIME = Multipurpose Internet Mail Extensions
PDA = Personal Digital Assistant
\end{verbatim}

\chapter*{Indexes}
\addcontentsline{toc}{chapter}{Index}

%src: wc.nw in noweb source
Here is a list of the identifiers used, and where they appear.
Underlined entries indicate the place of definition.
This index is generated automatically.

%\twocolumn does not work
\nowebindex

%\chapter{References} 
\addcontentsline{toc}{chapter}{References}

\bibliography{../docs/latex/Principia}
\bibliographystyle{alpha}

%******************************************************************************
% Postlude
%******************************************************************************

\end{document}
