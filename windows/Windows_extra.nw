\section{[[include/]]}

\subsection*{[[include/complete.h]]}

%-------------------------------------------------------------

<<include/complete.h>>=
#pragma	lib	"libcomplete.a"
#pragma src "/sys/src/libcomplete"

typedef struct Completion Completion;

<<struct Completion>>

Completion* 	complete(char *dir, char *s);
void 		freecompletion(Completion*);
@

\subsection*{[[include/frame.h]]}





%-------------------------------------------------------------

<<include/frame.h>>=
#pragma	src	"/sys/src/libframe"
#pragma	lib	"libframe.a"

typedef struct Frbox Frbox;
typedef struct Frame Frame;

<<enum _anon_ (include/frame.h)>>

<<constant FRTICKW>>

<<struct Frbox>>

<<struct Frame>>

ulong	frcharofpt(Frame*, Point);
Point	frptofchar(Frame*, ulong);

int	frdelete(Frame*, ulong, ulong);
void	frinsert(Frame*, Rune*, Rune*, ulong);

void	frselect(Frame*, Mousectl*);
void	frselectpaint(Frame*, Point, Point, Image*);

void	frdrawsel(Frame*, Point, ulong, ulong, int);
Point 	frdrawsel0(Frame*, Point, ulong, ulong, Image*, Image*);

void	frinit(Frame*, Rectangle, Font*, Image*, Image**);
void	frsetrects(Frame*, Rectangle, Image*);
void	frclear(Frame*, int);

// private??? frame_private.h?
uchar	*_frallocstr(Frame*, unsigned);
void	_frinsure(Frame*, int, unsigned);
Point	_frdraw(Frame*, Point);
void	_frgrowbox(Frame*, int);
void	_frfreebox(Frame*, int, int);
void	_frmergebox(Frame*, int);
void	_frdelbox(Frame*, int, int);
void	_frsplitbox(Frame*, int, int);
int	_frfindbox(Frame*, int, ulong, ulong);
void	_frclosebox(Frame*, int, int);
int	_frcanfit(Frame*, Point, Frbox*);
void	_frcklinewrap(Frame*, Point*, Frbox*);
void	_frcklinewrap0(Frame*, Point*, Frbox*);
void	_fradvance(Frame*, Point*, Frbox*);
int	_frnewwid(Frame*, Point, Frbox*);
int	_frnewwid0(Frame*, Point, Frbox*);
void	_frclean(Frame*, Point, int, int);
void	_frdrawtext(Frame*, Point, Image*, Image*);
void	_fraddbox(Frame*, int, int);
Point	_frptofcharptb(Frame*, ulong, Point, int);
Point	_frptofcharnb(Frame*, ulong, int);
int	_frstrlen(Frame*, int);

void	frtick(Frame*, Point, int);
void	frinittick(Frame*);

void	frredraw(Frame*);

<<function NRUNE>>
<<function NBYTE>>
@


\subsection*{[[include/plumb.h]]}


%-------------------------------------------------------------

<<include/plumb.h>>=
#pragma	lib	"libplumb.a"
#pragma	src	"/sys/src/libplumb"

/*
 * Message format:
 *	source application\n
 *	destination port\n
 *	working directory\n
 *	type\n
 *	attributes\n
 *	nbytes\n
 *	n bytes of data
 */

typedef struct Plumbattr Plumbattr;
typedef struct Plumbmsg Plumbmsg;

<<struct Plumbmsg>>

<<struct Plumbattr>>

int		    plumbsend(int, Plumbmsg*);
int		    plumbsendtext(int, char*, char*, char*, char*);
Plumbmsg*	plumbrecv(int);
char*		plumbpack(Plumbmsg*, int*);
Plumbmsg*	plumbunpack(char*, int);
Plumbmsg*	plumbunpackpartial(char*, int, int*);
char*		plumbpackattr(Plumbattr*);
Plumbattr*	plumbunpackattr(char*);
Plumbattr*	plumbaddattr(Plumbattr*, Plumbattr*);
Plumbattr*	plumbdelattr(Plumbattr*, char*);
void		plumbfree(Plumbmsg*);
char*		plumblookup(Plumbattr*, char*);
int		    plumbopen(char*, int);

int		eplumb(int, char*);
@


\section{[[windows/rio/]]}

\subsection*{[[windows/rio/dat.h]]}

<<enum _anon_ (windows/rio/dat.h)3>>=
enum
{
    <<constant Selborder>>
    <<constant Unselborder>>
    <<constants Scrollxxx>>
    <<constant BIG>>
};
@
%dead:
% extern Image	*view;

%-------------------------------------------------------------

<<windows/rio/dat.h>>=

// forward decls
typedef	struct	Window Window;
typedef	struct	Wctlmesg Wctlmesg;
typedef	struct	Filsys Filsys;
typedef	struct	Fid Fid;
typedef	struct	Xfid Xfid;
typedef	struct	Consreadmesg Consreadmesg;
typedef	struct	Conswritemesg Conswritemesg;
typedef	struct	Stringpair Stringpair;
typedef	struct	Dirtab Dirtab;
typedef	struct	Mouseinfo	Mouseinfo;
typedef	struct	Mousereadmesg Mousereadmesg;
typedef	struct	Mousestate	Mousestate;
typedef	struct	Ref Ref;
typedef	struct	Timer Timer;

//----------------------------------------------------------------------------
// Data structures and constants
//----------------------------------------------------------------------------

<<enum qid>>

<<function QID>>
<<function WIN>>
<<function FILE>>


<<enum _anon_ (windows/rio/dat.h)2>>

<<constant STACK>>

<<enum _anon_ (windows/rio/dat.h)3>>

<<constant DEBUG>>

<<enum wctlmesgkind>>

<<struct Wctlmesg>>

<<struct Conswritemesg>>

<<struct Consreadmesg>>

<<struct Mousereadmesg>>

<<struct Stringpair>>

<<struct Mousestate>>

<<struct Mouseinfo>>

<<struct Window>>

<<struct Dirtab>>

<<struct Fid>>

<<struct Xfid>>


<<constant Nhash>>

<<struct Filsys>>


<<struct Timer>>

//----------------------------------------------------------------------------
// Globals
//----------------------------------------------------------------------------

// see also draw.h globals: display, font, view

// globals.c

extern Screen	*desktop;
extern Image	*background;
extern Image	*red;

extern Window	**windows;
extern int		nwindow;
extern Window	*input;

extern Window	*hidden[100];
extern int		nhidden;

extern Filsys	*filsys;

extern Keyboardctl	*keyboardctl;
extern Mousectl	*mousectl;
extern Mouse	*mouse;

extern Channel	*exitchan; // was static in rio.c
extern Channel*	winclosechan;
extern Channel*	deletechan;

extern int		snarfversion;	/* updated each time it is written */

extern int		sweeping;
extern bool		menuing;
extern int		scrolling;

extern char		*startdir;

// misc
extern Window	*wkeyboard;	/* window of simulated keyboard */
extern QLock	all;			/* BUG */
extern fdt		wctlfd;
extern int		maxtab;


// 9p.c
extern int		messagesize;	/* negotiated in 9P version setup */


// thread_mouse.c
extern Rectangle	viewr; // was static in rio.c

// data.c
extern Cursor	boxcursor;
extern Cursor	crosscursor;
extern Cursor	sightcursor;
extern Cursor	whitearrow;
extern Cursor	query;
extern Cursor	*corners[9];

// cursor.c
extern Cursor	*lastcursor; // was static in wind.c

// snarf.c
extern fdt		snarffd;
extern Rune*	snarf;
extern int		nsnarf;

// error.c
extern bool		errorshouldabort;
extern char Eperm[];

@


\subsection*{[[windows/rio/fns.h]]}
%pad: lots of stuff was in dat.h before, but more consistent to
% have every proto in fns.h no? or was better have DS and
% related function/method together?

%-------------------------------------------------------------

<<windows/rio/fns.h>>=

// thread_keyboard.c (for rio.c)
void	keyboardthread(void*);
// thread_mouse.c    (for rio.c)
void	mousethread(void*);
// threads_misc.c    (for rio.c)
void 	winclosethread(void*);
void 	deletethread(void*);
// threads_worker.c (for rio.c)
Channel* xfidinit(void);
void	xfidflush(Xfid*);
// proc_fileserver (for rio.c and process_winshell.c)
Filsys*	filsysinit(Channel*);
int		filsysmount(Filsys*, int);
// threads_window.c
void    winctl(void*);
// processes_winshell
void	winshell(void*);

// data.c (for rio.c)
void	iconinit(void);
// timer.c (for rio.c and scrl.c)
void	timerinit(void);
void	timerstop(Timer*);
void	timercancel(Timer*);
Timer*	timerstart(int);


// fsys.c (for rio.c and xfid.c and process_winshell.c)

// cursor.c
void	riosetcursor(Cursor*, int);

// wm.c (for thread_mouse.c)
void    cornercursor(Window *w, Point p, bool force);
Image	*bandsize(Window*);
Image*	drag(Window*, Rectangle*);
void    button3menu(void);
Window *new(Image*, int, int, int, char*, char*, char**); // for wkeyboard
int	whide(Window*); // for wctl
int	wunhide(int);   // for wctl

// wind.c
void    wsendctlmesg(Window*, int, Rectangle, Image*);
Window*	wmk(Image*, Mousectl*, Channel*, Channel*, int);
int		wclose(Window*);
void	wclosewin(Window*);
Window*	wpointto(Point);
void	wcurrent(Window*);
Window*	wlookid(int);
void	wresize(Window*, Image*, int);
void	wrefresh(Window*, Rectangle);
void	wrepaint(Window*);
int		winborder(Window*, Point);
Window*	wtop(Point);
void	wtopme(Window*);
void	wbottomme(Window*);
void	wsetcursor(Window*, bool);
void	wmovemouse(Window*, Point);
void	wfill(Window*);
void	wsetname(Window*);
void	wsetpid(Window*, int, int);


// TODO
int	    goodrect(Rectangle);

// graphical_window.c
void	waddraw(Window*, Rune*, int);

// terminal.c
void    button2menu(Window *w);
void	wkeyctl(Window*, Rune);
void	wmousectl(Window*);
void	wdelete(Window*, uint, uint);
uint	winsert(Window*, Rune*, int, uint);
void	wshow(Window*, uint);
void	wsetselect(Window*, uint, uint);
void	wsetorigin(Window*, uint, int);
uint	wbacknl(Window*, uint, uint);
char*	wcontents(Window*, int*);

// scroll.c
void	freescrtemps(void);
void	wscrdraw(Window*);
void 	wscrsleep(Window*, uint);
void	wscroll(Window*, int);

// snarf.c
void	putsnarf(void);
void	getsnarf(void);

// 9p.c (for fsys.c and xfid.c)
Xfid*	filsysrespond(Filsys*, Xfid*, Fcall*, char*);
void	filsyscancel(Xfid*);

// xfid.c  (for fsys.c)
void	xfidattach(Xfid*);
void	xfidopen(Xfid*);
void	xfidclose(Xfid*);
void	xfidread(Xfid*);
void	xfidwrite(Xfid*);

// wctl.c (for fsys.c and xfid.c)
void	wctlproc(void*);
void	wctlthread(void*);
int	    parsewctl(char**, Rectangle, Rectangle*, int*, int*, int*, int*, char**, char*, char*);
int	    writewctl(Xfid*, char*);

// util.c
int	    min(int, int);
int	    max(int, int);
Rune*	strrune(Rune*, Rune);
int	    isalnum(Rune);
void	cvttorunes(char*, int, Rune*, int*, int*, int*);
char* 	runetobyte(Rune*, int, int*);/* was (byte*,int) runetobyte(Rune*,int);*/
void*	erealloc(void*, uint);
void* 	emalloc(uint);
char* 	estrdup(char*);

<<function runemalloc>>
<<function runerealloc>>
<<function runemove>>

// error.c
void    derror(Display*, char *); // for main.c
void	error(char*);

@


\subsection*{[[windows/rio/globals.c]]}
%pad: I created this file; its content was in dat.h, but without EXTERN
% macro trick so not sure how it worked


%-------------------------------------------------------------

<<windows/rio/globals.c>>=
#include <u.h>
#include <libc.h>

#include <draw.h>
#include <thread.h>
#include <cursor.h>
#include <mouse.h>
#include <keyboard.h>

#include <frame.h>

#include <fcall.h>

#include "dat.h"
#include "fns.h"

<<global mousectl>>
<<global mouse>>
<<global keyboardctl>>

<<global desktop>>
<<global background>>
<<global red>>

<<global window>>
<<global wkeyboard>>
<<global nwindow>>


<<global exitchan>>

<<global winclosechan>>

<<global deletechan>>


<<global input>>
<<global all>>
<<global filsys>>
<<global hidden>>
<<global nhidden>>
<<global scrolling>>


<<global startdir>>
<<global sweeping>>
<<global wctlfd>>
<<global menuing>>
<<global snarfversion>>

<<global maxtab>>

@

\subsection*{[[windows/rio/rio.c]]}

%-------------------------------------------------------------

<<windows/rio/rio.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <window.h>
#include <thread.h>
#include <cursor.h>
#include <mouse.h>
#include <keyboard.h>
#include <frame.h>
#include <fcall.h>
#include <plumb.h>

#include "dat.h"
#include "fns.h"

/*
 *  WASHINGTON (AP) - The Food and Drug Administration warned
 * consumers Wednesday not to use ``Rio'' hair relaxer products
 * because they may cause severe hair loss or turn hair green....
 *    The FDA urged consumers who have experienced problems with Rio
 * to notify their local FDA office, local health department or the
 * company at 1‑800‑543‑3002.
 */

<<global fontname>>

<<global kbdargv>>


<<function usage>>


<<function initcmd>>

<<global oknotes>>

<<function killprocs>>


<<function shutdown>>


<<function threadmain>>

@


\subsection*{[[windows/rio/thread_mouse.c]]}
%pad: I created this file; its content was in rio.c before.

%-------------------------------------------------------------

<<windows/rio/thread_mouse.c>>=
#include <u.h>
#include <libc.h>

// for dat.h
#include <draw.h>
#include <mouse.h>
#include <cursor.h>
#include <keyboard.h>
#include <frame.h>
#include <fcall.h>
#include <thread.h>

#include <window.h>

#include "dat.h"
#include "fns.h"

<<enum Mxxx>>


<<function keyboardhide>>

<<global viewr>>

<<function resized>>


<<function mousethread>>

@

\subsection*{[[windows/rio/thread_keyboard.c]]}
%pad: I created this file; its content was in rio.c before.

%-------------------------------------------------------------

<<windows/rio/thread_keyboard.c>>=
#include <u.h>
#include <libc.h>

// for dat.h
#include <draw.h>
#include <mouse.h>
#include <cursor.h>
#include <keyboard.h>
#include <frame.h>
#include <fcall.h>
#include <thread.h>

#include "dat.h"
#include "fns.h"

<<function keyboardthread>>

@

\subsection*{[[windows/rio/threads_window.c]]}
%pad: I created this file; its content was in wind.c before.

%-------------------------------------------------------------

<<windows/rio/threads_window.c>>=

#include <u.h>
#include <libc.h>

// for dat.h
#include <draw.h>
#include <mouse.h>
#include <cursor.h>
#include <keyboard.h>
#include <frame.h>
#include <fcall.h>
#include <thread.h>

#include <window.h>

#include "dat.h"
#include "fns.h"


<<enum Wxxx>>

<<function deletetimeoutproc>>


<<function wctlmesg>>


<<function winctl>>


@

\subsection*{[[windows/rio/threads_worker.c]]}
%pad: I created this file; its content was in ?? before.

%-------------------------------------------------------------

<<windows/rio/threads_worker.c>>=
#include <u.h>
#include <libc.h>

// for dat.h
#include <draw.h>
#include <mouse.h>
#include <cursor.h>
#include <keyboard.h>
#include <frame.h>
#include <fcall.h>
#include <thread.h>

#include "dat.h"
#include "fns.h"

<<global xfidfree>>
<<global xfid>>
<<global cxfidalloc>>
<<global cxfidfree>>

<<enum Xxxx>>


<<function xfidctl>>


<<function xfidflush>>


<<function xfidallocthread>>

<<function xfidinit>>


@

\subsection*{[[windows/rio/threads_misc.c]]}
%pad: I created this file; its content was in rio.c before.

%-------------------------------------------------------------

<<windows/rio/threads_misc.c>>=
#include <u.h>
#include <libc.h>

// for dat.h
#include <draw.h>
#include <mouse.h>
#include <cursor.h>
#include <keyboard.h>
#include <frame.h>
#include <fcall.h>
#include <thread.h>

#include <window.h>

#include "dat.h"
#include "fns.h"


<<function winclosethread>>

<<function deletethread>>

@

\subsection*{[[windows/rio/wm.c]]}
%pad: I created this file; its content was in rio.c before.

%-------------------------------------------------------------

<<windows/rio/wm.c>>=
#include <u.h>
#include <libc.h>

// for dat.h
#include <draw.h>
#include <mouse.h>
#include <cursor.h>
#include <keyboard.h>
#include <frame.h>
#include <fcall.h>
#include <thread.h>

#include <window.h>

#include "dat.h"
#include "fns.h"

// Most of the functions in this file are executed from
// a threadmouse() context (via button3menu()). They send
// a Wctlmesg to the window thread to get the actual modifications
// done on the global windows state.

//----------------------------------------------------------------------------
// Menu
//----------------------------------------------------------------------------

<<enum _anon_ (windows/rio/rio.c)>>

<<global menu3str>>

<<global menu3>>


//----------------------------------------------------------------------------
// Helpers
//----------------------------------------------------------------------------

<<function goodrect>>


<<function portion>>

<<function whichcorner>>

<<function cornercursor>>



//----------------------------------------------------------------------------
// Mouse actions
//----------------------------------------------------------------------------

<<function pointto>>




<<function onscreen>>

<<function sweep>>






<<function drawedge>>

<<function drawborder>>

<<function drag>>



<<function cornerpt>>

<<function whichrect>>

<<function bandsize>>


//----------------------------------------------------------------------------
// Window management
//----------------------------------------------------------------------------

<<function delete>>

<<function resize>>

<<function move>>

<<function whide>>

<<function wunhide>>

<<function hide>>

<<function unhide>>




<<global rcargv>>


<<function new>>


//----------------------------------------------------------------------------
// Entry point
//----------------------------------------------------------------------------


<<function button3menu>>

@

\subsection*{[[windows/rio/data.c]]}


%-------------------------------------------------------------

<<windows/rio/data.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <thread.h>
#include <cursor.h>
#include <mouse.h>
#include <keyboard.h>
#include <frame.h>
#include <fcall.h>

#include "dat.h"
#include "fns.h"

<<global crosscursor (windows/rio/data.c)>>

<<global boxcursor (windows/rio/data.c)>>

<<global sightcursor (windows/rio/data.c)>>

<<global whitearrow (windows/rio/data.c)>>

<<global query (windows/rio/data.c)>>

<<global tl>>

<<global t>>

<<global tr>>

<<global r>>

<<global br>>

<<global b>>

<<global bl>>

<<global l>>

<<global corners (windows/rio/data.c)>>

<<function iconinit>>
@

\subsection*{[[windows/rio/cursor.c]]}
%pad: I created this file; its content was in wind.c before.


%-------------------------------------------------------------

<<windows/rio/cursor.c>>=
#include <u.h>
#include <libc.h>

// for dat.h
#include <draw.h>
#include <mouse.h>
#include <cursor.h>
#include <keyboard.h>
#include <frame.h>
#include <fcall.h>
#include <thread.h>

#include "dat.h"
#include "fns.h"

<<global lastcursor>>


<<function riosetcursor>>

@


\subsection*{[[windows/rio/wind.c]]}

%-------------------------------------------------------------

<<windows/rio/wind.c>>=
#include <u.h>
#include <libc.h>

#include <draw.h>
#include <window.h>
#include <thread.h>
#include <cursor.h>
#include <mouse.h>
#include <keyboard.h>

#include <frame.h>
#include <fcall.h>

#include "dat.h"
#include "fns.h"

<<global topped>>
<<global id>>

<<global cols>>
<<global darkgrey>>


<<global titlecol>>
<<global lighttitlecol>>
<<global holdcol>>
<<global lightholdcol>>
<<global paleholdcol>>


<<function wsendctlmesg>>


<<function wborder>>

<<function wsetcols>>


<<function wmk>>

<<function wsetname>>

<<function wresize>>

<<function wrefresh>>

<<function wclose>>






<<function wrepaint>>


<<function winborder>>


<<function wmovemouse>>


<<function wpointto>>

<<function wcurrent>>

<<function wsetcursor>>


<<function wtop>>

<<function wtopme>>

<<function wbottomme>>

<<function wlookid>>

<<function wclosewin>>

<<function wsetpid>>


@


\subsection*{[[windows/rio/processes_winshell.c]]}
%pad: I created this file; its content was in wind.c before.


%-------------------------------------------------------------

<<windows/rio/processes_winshell.c>>=
#include <u.h>
#include <libc.h>

// for dat.h
#include <draw.h>
#include <mouse.h>
#include <cursor.h>
#include <keyboard.h>
#include <frame.h>
#include <fcall.h>
#include <thread.h>

#include "dat.h"
#include "fns.h"

<<function winshell>>

@

\subsection*{[[windows/rio/terminal.c]]}
%pad: I created this file; its content was in rio.c and wind.c before.


%-------------------------------------------------------------

<<windows/rio/terminal.c>>=
#include <u.h>
#include <libc.h>

// for dat.h
#include <draw.h>
#include <mouse.h>
#include <cursor.h>
#include <keyboard.h>
#include <frame.h>
#include <fcall.h>
#include <thread.h>

#include <plumb.h>
#include <complete.h>


#include "dat.h"
#include "fns.h"

<<enum _anon_ (windows/rio/wind.c)>>

<<enum _anon_ (windows/rio/rio.c)2>>

<<global menu2str>>

<<global menu2>>

<<global clickwin>>
<<global clickmsec>>
<<global selectwin>>
<<global selectq>>



//----------------------------------------------------------------------------
// Completion
//----------------------------------------------------------------------------


<<function windfilewidth>>

<<function showcandidates>>

<<function namecomplete>>


//----------------------------------------------------------------------------
// Editor
//----------------------------------------------------------------------------

<<function wbswidth>>

<<function wfill>>


<<function wdelete>>

<<function wbacknl>>

<<function wsetorigin>>


<<function wshow>>


<<function wsetselect>>

<<function winsert>>


<<function wcontents>>


//----------------------------------------------------------------------------
// Cut/copy/paste
//----------------------------------------------------------------------------

<<function wsnarf>>

<<function wcut>>

<<function wpaste>>


//----------------------------------------------------------------------------
// Scrolling
//----------------------------------------------------------------------------

<<function wframescroll>>

<<function framescroll>>


//----------------------------------------------------------------------------
// Selection
//----------------------------------------------------------------------------

<<function wclickmatch>>


<<global left1>>
<<global right1>>
<<global left2>>
<<global left3>>

<<global left>>
<<global right>>

<<function wdoubleclick>>




<<function wselect>>

//----------------------------------------------------------------------------
// Clicking
//----------------------------------------------------------------------------



//----------------------------------------------------------------------------
// Plumb
//----------------------------------------------------------------------------

<<function wplumb>>



//----------------------------------------------------------------------------
// Middle click
//----------------------------------------------------------------------------


<<function button2menu>>



//----------------------------------------------------------------------------
// Mouse dispatch
//----------------------------------------------------------------------------

<<function wmousectl>>

//----------------------------------------------------------------------------
// Key dispatch
//----------------------------------------------------------------------------


<<function interruptproc>>



<<function wkeyctl>>

@

\subsection*{[[windows/rio/snarf.c]]}
%pad: I created this file; its content was in rio.c before.

%-------------------------------------------------------------

<<windows/rio/snarf.c>>=
#include <u.h>
#include <libc.h>

// for dat.h
#include <draw.h>
#include <mouse.h>
#include <cursor.h>
#include <keyboard.h>
#include <frame.h>
#include <fcall.h>
#include <thread.h>

#include "dat.h"
#include "fns.h"

<<global snarffd>>

<<global snarf>>
<<global nsnarf>>


<<function putsnarf>>

<<function getsnarf>>

@

\subsection*{[[windows/rio/graphical_window.c]]}
%pad: I created this file; its content was in wind.c before.


%-------------------------------------------------------------

<<windows/rio/graphical_window.c>>=
#include <u.h>
#include <libc.h>

// for dat.h
#include <draw.h>
#include <mouse.h>
#include <cursor.h>
#include <keyboard.h>
#include <frame.h>
#include <fcall.h>
#include <thread.h>

#include "dat.h"
#include "fns.h"

<<function waddraw>>

@

\subsection*{[[windows/rio/9p.c]]}
%pad: I created this file, the functions were in fsys.c before

%-------------------------------------------------------------

<<windows/rio/9p.c>>=
#include <u.h>
#include <libc.h>

// for dat.h
#include <draw.h>
#include <mouse.h>
#include <cursor.h>
#include <keyboard.h>
#include <frame.h>
#include <fcall.h>
#include <thread.h>

#include "dat.h"
#include "fns.h"

<<global messagesize>>

<<function filsysrespond>>

<<function filsyscancel>>

@

\subsection*{[[windows/rio/proc_fileserver.c]]}
%pad: I created this file, the functions were in fsys.c before

%-------------------------------------------------------------

<<windows/rio/proc_fileserver.c>>=
#include <u.h>
#include <libc.h>

// for dat.h
#include <draw.h>
#include <mouse.h>
#include <cursor.h>
#include <keyboard.h>
#include <frame.h>
#include <fcall.h>
#include <thread.h>

#include "dat.h"
#include "fns.h"

extern Xfid* 	(*fcall[])(Filsys*, Xfid*, Fid*);
extern char	Ebadfcall[];
extern bool	firstmessage;
extern Fid*		newfid(Filsys*, int);
extern fdt	clockfd;

<<global srvpipe (windows/rio/fsys.c)>>
<<global srvwctl (windows/rio/fsys.c)>>

<<function filsysproc>>

<<function cexecpipe>>

<<function post>>


<<function filsysinit>>

<<function filsysmount>>


@


\subsection*{[[windows/rio/fsys.c]]}

%-------------------------------------------------------------

<<windows/rio/fsys.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <thread.h>
#include <cursor.h>
#include <mouse.h>
#include <keyboard.h>
#include <frame.h>
#include <fcall.h>

#include "dat.h"
#include "fns.h"

<<global Eexist>>
<<global Enotdir>>
<<global Ebadfcall>>
<<global Eoffset>>


<<global dirtab>>

static uint		getclock(void);
Fid*		newfid(Filsys*, int);
static int		dostat(Filsys*, int, Dirtab*, uchar*, int, uint);

<<global clockfd>>
<<global firstmessage>>


static	Xfid*	filsysflush(Filsys*, Xfid*, Fid*);
static	Xfid*	filsysversion(Filsys*, Xfid*, Fid*);
static	Xfid*	filsysauth(Filsys*, Xfid*, Fid*);
static	Xfid*	filsysnop(Filsys*, Xfid*, Fid*);
static	Xfid*	filsysattach(Filsys*, Xfid*, Fid*);
static	Xfid*	filsyswalk(Filsys*, Xfid*, Fid*);
static	Xfid*	filsysopen(Filsys*, Xfid*, Fid*);
static	Xfid*	filsyscreate(Filsys*, Xfid*, Fid*);
static	Xfid*	filsysread(Filsys*, Xfid*, Fid*);
static	Xfid*	filsyswrite(Filsys*, Xfid*, Fid*);
static	Xfid*	filsysclunk(Filsys*, Xfid*, Fid*);
static	Xfid*	filsysremove(Filsys*, Xfid*, Fid*);
static	Xfid*	filsysstat(Filsys*, Xfid*, Fid*);
static	Xfid*	filsyswstat(Filsys*, Xfid*, Fid*);

<<global fcall>>




<<function filsysversion>>

<<function filsysauth>>

<<function filsysflush>>

<<function filsysattach>>

<<function numeric>>

<<function filsyswalk>>

<<function filsysopen>>

<<function filsyscreate>>

<<function idcmp>>

<<function filsysread>>

<<function filsyswrite>>

<<function filsysclunk>>

<<function filsysremove>>

<<function filsysstat>>

<<function filsyswstat>>

<<function newfid>>

<<function getclock>>

<<function dostat>>
@


\subsection*{[[windows/rio/xfid.c]]}

%-------------------------------------------------------------

<<windows/rio/xfid.c>>=
#include <u.h>
#include <libc.h>

#include <draw.h>
#include <marshal.h>
#include <window.h>
#include <thread.h>
#include <cursor.h>
#include <mouse.h>
#include <keyboard.h>
#include <frame.h>
#include <fcall.h>
#include <plumb.h>

#include "dat.h"
#include "fns.h"

<<constant MAXSNARF>>

<<global Einuse>>
<<global Edeleted>>
<<global Ebadreq>>
<<global Etooshort>>
<<global Ebadtile>>
<<global Eshort>>
<<global Elong>>
<<global Eunkid>>
<<global Ebadrect>>
<<global Ewindow>>
<<global Enowindow>>
<<global Ebadmouse>>
<<global Ebadwrect>>
<<global Ebadoffset>>

<<global tsnarf>>
<<global ntsnarf>>



<<function xfidattach>>

<<function xfidopen>>

<<function xfidclose>>


<<function keyboardsend>>


<<enum _anon_ (windows/rio/xfid.c)2>>

<<function xfidwrite>>

<<function readwindow>>

<<enum _anon_ (windows/rio/xfid.c)3>>
<<enum _anon_ (windows/rio/xfid.c)4>>
<<enum _anon_ (windows/rio/xfid.c)5>>

<<function xfidread>>

@


\subsection*{[[windows/rio/scrl.c]]}


%-------------------------------------------------------------

<<windows/rio/scrl.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <thread.h>
#include <cursor.h>
#include <mouse.h>
#include <keyboard.h>
#include <frame.h>
#include <fcall.h>

#include "dat.h"
#include "fns.h"

<<global scrtmp>>

<<function scrtemps>>

<<function freescrtemps>>

<<function scrpos>>

<<function wscrdraw>>

<<function wscrsleep>>

<<function wscroll>>
@


\subsection*{[[windows/rio/time.c]]}

%-------------------------------------------------------------

<<windows/rio/time.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <thread.h>
#include <cursor.h>
#include <mouse.h>
#include <keyboard.h>
#include <frame.h>
#include <fcall.h>

#include "dat.h"
#include "fns.h"

<<global ctimer>>
<<global timer>>

<<function msec>>

<<function timerstop>>

<<function timercancel>>

<<function timerproc>>

<<function timerinit>>

<<function timerstart>>
@


\subsection*{[[windows/rio/wctl.c]]}


%-------------------------------------------------------------

<<windows/rio/wctl.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <window.h>
#include <thread.h>
#include <cursor.h>
#include <mouse.h>
#include <keyboard.h>
#include <frame.h>
#include <fcall.h>
#include <plumb.h>

#include "dat.h"
#include "fns.h"

#include <ctype.h>

<<global Ebadwr>>
<<global Ewalloc>>

<<enum _anon_ (windows/rio/wctl.c)>>

<<global cmds>>

<<enum _anon_ (windows/rio/wctl.c)2>>

<<global params>>


<<function word>>

<<function set>>

<<function newrect>>

<<function shift>>

<<function rectonscreen>>

<<function riostrtol>>


<<function parsewctl>>

<<function wctlnew>>

<<function writewctl>>

<<function wctlthread>>

<<function wctlproc>>
@


\subsection*{[[windows/rio/error.c]]}
%pad: I created this file; its content was in rio.c and util.c before.

%-------------------------------------------------------------

<<windows/rio/error.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <thread.h>

<<global errorshouldabort>>

// could be in 9p.c too
<<global Eperm>>


<<function error>>


<<function derror>>

@


\subsection*{[[windows/rio/util.c]]}


%-------------------------------------------------------------

<<windows/rio/util.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <thread.h>
#include <cursor.h>
#include <mouse.h>
#include <keyboard.h>
#include <frame.h>
#include <fcall.h>

#include "dat.h"
#include "fns.h"

<<function cvttorunes>>


<<function erealloc>>

<<function emalloc>>

<<function estrdup>>

<<function isalnum>>

<<function strrune>>

<<function min>>

<<function max (windows/rio/util.c)>>

<<function runetobyte>>

@


\section{[[windows/apps/]]}

\subsection*{[[windows/apps/lens.c]]}

% put in Graphics.nw instead

<<enum _anon_ (windows/apps/lens.c)>>=
enum {
    Edge = 5,
    Maxmag = 16
};
@

<<enum _anon_ (windows/apps/lens.c)2>>=
enum {
    Mzoom,
    Munzoom,
    Mgrid,
    Mredraw,
    Mexit
};
@

<<global menustr>>=
static char *menustr[] = {
    "zoom",
    "unzoom",
    "grid",
    "redraw",
    "exit",
    nil
};
@

<<global menu (windows/apps/lens.c)>>=
static Menu menu = {
    menustr,
    nil,
    -1
};
@

<<global lastp>>=
static Point lastp;
@

<<global red (windows/apps/lens.c)>>=
static Image *red;
@

<<global tmp (windows/apps/lens.c)>>=
static Image *tmp;
@

<<global grid>>=
static Image *grid;
@

<<global chequer>>=
static Image *chequer;
@

<<global screenfd>>=
static int	screenfd;
@

<<global mag>>=
static int	mag = 4;
@

<<global showgrid>>=
static int	showgrid = 0;
@

<<global screenr>>=
static Rectangle	screenr;
@

<<global screenbuf>>=
static uchar	*screenbuf;
@

<<function drawit>>=
void
drawit(void)
{
    Rectangle r;
    border(view, view->r, Edge, red, ZP);
    magnify();
    r = insetrect(view->r, Edge);
    draw(view, r, tmp, nil, tmp->r.min);
    flushimage(display, true);
}
@

<<global bypp>>=
static int bypp;
@

<<function main (windows/apps/lens.c)>>=
void
main(int argc, char *argv[])
{
    Event e;
    char buf[5*12];
    ulong chan;
    int d;

    USED(argc, argv);

    if(initdraw(nil, nil, "lens") < 0){
        fprint(2, "lens: initdraw failed: %r\n");
        exits("initdraw");
    }
    einit(Emouse|Ekeyboard);

    red = allocimage(display, Rect(0, 0, 1, 1), CMAP8, 1, DRed);
    chequer = allocimage(display, Rect(0, 0, 2, 2), GREY1, 1, DBlack);

    draw(chequer, Rect(0, 0, 1, 1), display->white, nil, ZP);
    draw(chequer, Rect(1, 1, 2, 2), display->white, nil, ZP);
    lastp = divpt(addpt(view->r.min, view->r.max), 2);

    screenfd = open("/dev/screen", OREAD);
    if(screenfd < 0){
        fprint(2, "lens: can't open /dev/screen: %r\n");
        exits("screen");
    }
    if(read(screenfd, buf, sizeof buf) != sizeof buf){
        fprint(2, "lens: can't read /dev/screen: %r\n");
        exits("screen");
    }
    chan = strtochan(buf);
    d = chantodepth(chan);
    if(d < 8){
        fprint(2, "lens: can't handle screen format %11.11s\n", buf);
        exits("screen");
    }
    bypp = d/8;
    screenr.min.x = atoi(buf+1*12);
    screenr.min.y = atoi(buf+2*12);
    screenr.max.x = atoi(buf+3*12);
    screenr.max.y = atoi(buf+4*12);
    screenbuf = malloc(bypp*Dx(screenr)*Dy(screenr));
    if(screenbuf == nil){
        fprint(2, "lens: buffer malloc failed: %r\n");
        exits("malloc");
    }
    eresized(0);

    for(;;)
        switch(event(&e)){
        case Ekeyboard:
            switch(e.kbdc){
            case 'q':
            case 0x7f:
            case '\04':
            caseexit:
                exits(nil);
            case '=':
            case '+':
            casezoom:
                if(mag < Maxmag){
                    mag++;
                    makegrid();
                    drawit();
                }
                break;
            case 'g':
            casegrid:
                showgrid = !showgrid;
                makegrid();
                drawit();
                break;
            case '-':
            case '_':
            caseunzoom:
                if(mag > 1){
                    mag--;
                    makegrid();
                    drawit();
                }
                break;
            case '.':
            case ' ':
            caseredraw:
                drawit();
                break;
            case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9': case'0':
                mag = e.kbdc-'0';
                if(mag == 0)
                    mag = 10;
                makegrid();
                drawit();
                break;
            }
            break;
        case Emouse:
            if(e.mouse.buttons & 1){
                lastp = e.mouse.xy;
                drawit();
            }
            if(e.mouse.buttons & 4)
                switch(emenuhit(3, &e.mouse, &menu)){
                case Mzoom:
                    goto casezoom;
                case Munzoom:
                    goto caseunzoom;
                case Mgrid:
                    goto casegrid;
                case Mredraw:
                    goto caseredraw;
                case Mexit:
                    goto caseexit;
                }
            break;
        }
}
@

<<function makegrid>>=
void
makegrid(void)
{
    int m;
    if (grid != nil) {
        freeimage(grid);
        grid = nil;
    }
    if (showgrid) {
        m = mag;
        if (m < 5)
            m *= 10;
        grid = allocimage(display, Rect(0, 0, m, m),
            CHAN2(CGrey, 8, CAlpha, 8), 1, DTransparent);
        if (grid != nil){
            draw(grid, Rect(0, 0, m, 1), chequer, nil, ZP);
            draw(grid, Rect(0, 1, 1, m), chequer, nil, ZP);
        }
    }
}
@

<<function eresized (windows/apps/lens.c)>>=
void
eresized(int new)
{
    if(new && getwindow(display, Refnone) < 0){
        fprint(2, "lens: can't reattach to window: %r\n");
        exits("attach");
    }
    freeimage(tmp);
    tmp = allocimage(display, Rect(0, 0, Dx(view->r)-Edge, Dy(view->r)-Edge+Maxmag), view->chan, 0, DNofill);
    if(tmp == nil){
        fprint(2, "lens: allocimage failed: %r\n");
        exits("allocimage");
    }
    drawit();
}
@

<<function magnify>>=
void
magnify(void)
{
    int x, y, xx, yy, dd, i;
    int dx, dy;
    int xoff, yoff;
    uchar out[8192];
    uchar sp[4];

    dx = (Dx(tmp->r)+mag-1)/mag;
    dy = (Dy(tmp->r)+mag-1)/mag;
    xoff = lastp.x-Dx(tmp->r)/(mag*2);
    yoff  = lastp.y-Dy(tmp->r)/(mag*2);

    yy = yoff;
    dd = dy;
    if(yy < 0){
        dd += dy;
        yy = 0;
    }
    if(yy+dd > Dy(screenr))
        dd = Dy(screenr)-yy;
    seek(screenfd, 5*12+bypp*yy*Dx(screenr), 0);
    if(readn(screenfd, screenbuf+bypp*yy*Dx(screenr), bypp*Dx(screenr)*dd) != bypp*Dx(screenr)*dd){
        fprint(2, "lens: can't read screen: %r\n");
        return;
    }

    for(y=0; y<dy; y++){
        yy = yoff+y;
        if(yy>=0 && yy<Dy(screenr))
            for(x=0; x<dx; x++){
                xx = xoff+x;
                if(xx>=0 && xx<Dx(screenr))	/* snarf pixel at xx, yy */
                    for(i=0; i<bypp; i++)
                        sp[i] = screenbuf[bypp*(yy*Dx(screenr)+xx)+i];
                else
                    sp[0] = sp[1] = sp[2] = sp[3] = 0;

                for(xx=0; xx<mag; xx++)
                    if(x*mag+xx < tmp->r.max.x)
                        for(i=0; i<bypp; i++)
                            out[(x*mag+xx)*bypp+i] = sp[i];
            }
        else
            memset(out, 0, bypp*Dx(tmp->r));
        for(yy=0; yy<mag && y*mag+yy<Dy(tmp->r); yy++){
            werrstr("no error");
            if(loadimage(tmp, Rect(0, y*mag+yy, Dx(tmp->r), y*mag+yy+1), out, bypp*Dx(tmp->r)) != bypp*Dx(tmp->r)){
                exits("load");
            }
        }
    }
    if (showgrid && mag && grid)
        draw(tmp, tmp->r, grid, nil, mulpt(Pt(xoff, yoff), mag));
}
@


%-------------------------------------------------------------

<<windows/apps/lens.c>>=
#include <u.h>
#include <libc.h>

#include <draw.h>
#include <window.h>
#include <event.h>

<<enum _anon_ (windows/apps/lens.c)>>

<<enum _anon_ (windows/apps/lens.c)2>>

<<global menustr>>

<<global menu (windows/apps/lens.c)>>

<<global lastp>>
<<global red (windows/apps/lens.c)>>
<<global tmp (windows/apps/lens.c)>>
<<global grid>>
<<global chequer>>
<<global screenfd>>
<<global mag>>
<<global showgrid>>
<<global screenr>>
<<global screenbuf>>

void magnify(void);
void makegrid(void);

<<function drawit>>

<<global bypp>>

<<function main (windows/apps/lens.c)>>

<<function makegrid>>

<<function eresized (windows/apps/lens.c)>>

<<function magnify>>
@


\subsection*{[[windows/apps/statusbar.c]]}

<<enum _anon_ (windows/apps/statusbar.c)>>=
enum {PNCTL=3};
@

<<global nokill>>=
static int nokill;
@

<<global textmode>>=
static int textmode;
@

<<global title>>=
static char *title;
@

<<global light>>=
static Image *light;
@

<<global dark>>=
static Image *dark;
@

<<global text (windows/apps/statusbar.c)>>=
static Image *text;
@

<<function initcolor>>=
static void
initcolor(void)
{
    text = display->black;
    light = allocimagemix(display, DPalegreen, DWhite);
    dark = allocimage(display, Rect(0,0,1,1), CMAP8, 1, DDarkgreen);
}
@

<<global rbar>>=
static Rectangle rbar;
@

<<global ptext>>=
static Point ptext;
@

<<global last>>=
static int last;
@

<<global lastp (windows/apps/statusbar.c)>>=
static int lastp = -1;
@

<<global backup>>=
static char backup[80];
@

<<function drawbar>>=
void
drawbar(void)
{
    int i, j;
    int p;
    char buf[400], bar[200];
    static char lastbar[200];

    if(n > d || n < 0 || d <= 0)
        return;

    i = (Dx(rbar)*n)/d;
    p = (n*100LL)/d;

    if(textmode){
        if(Dx(rbar) > 150){
            rbar.min.x = 0;
            rbar.max.x = 150;
            return;
        }
        bar[0] = '|';
        for(j=0; j<i; j++)
            bar[j+1] = '#';
        for(; j<Dx(rbar); j++)
            bar[j+1] = '-';
        bar[j++] = '|';
        bar[j++] = ' ';
        sprint(bar+j, "%3d%% ", p);
        for(i=0; bar[i]==lastbar[i] && bar[i]; i++)
            ;
        memset(buf, '\b', strlen(lastbar)-i);
        strcpy(buf+strlen(lastbar)-i, bar+i);
        if(buf[0])
            write(1, buf, strlen(buf));
        strcpy(lastbar, bar);
        return;
    }

    if(lastp == p && last == i)
        return;

    if(lastp != p){
        sprint(buf, "%d%%", p);
        
        stringbg(view, addpt(view->r.min, Pt(Dx(rbar)-30, 4)), text, ZP, display->defaultfont, buf, light, ZP);
        lastp = p;
    }

    if(last != i){
        if(i > last)
            draw(view, Rect(rbar.min.x+last, rbar.min.y, rbar.min.x+i, rbar.max.y),
                dark, nil, ZP);
        else
            draw(view, Rect(rbar.min.x+i, rbar.min.y, rbar.min.x+last, rbar.max.y),
                light, nil, ZP);
        last = i;
    }
    flushimage(display, 1);
}
@

<<function eresized (windows/apps/statusbar.c)>>=
void
eresized(int new)
{
    Point p, q;
    Rectangle r;

    if(new && getwindow(display, Refnone) < 0)
        fprint(2,"can't reattach to window");

    r = view->r;
    draw(view, r, light, nil, ZP);
    p = string(view, addpt(r.min, Pt(4,4)), text, ZP,
        display->defaultfont, title);

    p.x = r.min.x+4;
    p.y += display->defaultfont->height+4;

    q = subpt(r.max, Pt(4,4));
    rbar = Rpt(p, q);

    ptext = Pt(r.max.x-4-stringwidth(display->defaultfont, "100%"), r.min.x+4);
    border(view, rbar, -2, dark, ZP);
    last = 0;
    lastp = -1;

    drawbar();
}
@

<<function bar>>=
void
bar(Biobuf *b)
{
    char *p, *f[2];
    Event e;
    int k, die, parent, child;

    parent = getpid();

    die = 0;
    if(textmode)
        child = -1;
    else
    switch(child = rfork(RFMEM|RFPROC)) {
    case 0:
        sleep(1000);
        while(!die && (k = eread(Ekeyboard|Emouse, &e))) {
            if(nokill==0 && k == Ekeyboard && (e.kbdc == 0x7F || e.kbdc == 0x03)) { /* del, ctl-c */
                die = 1;
                postnote(PNPROC, parent, "interrupt");
                _exits("interrupt");
            }
        }
        _exits(0);
    }

    while(!die && (p = Brdline(b, '\n'))) {
        p[Blinelen(b)-1] = '\0';
        if(tokenize(p, f, 2) != 2)
            continue;
        n = strtoll(f[0], 0, 0);
        d = strtoll(f[1], 0, 0);
        drawbar();
    }
    postnote(PNCTL, child, "kill");
}
@

<<function usage (windows/apps/statusbar.c)>>=
static void
usage(void)
{
    fprint(2, "usage: aux/statusbar [-kt] [-w minx,miny,maxx,maxy] 'title'\n");
    exits("usage");
}
@

<<function main (windows/apps/statusbar.c)>>=
void
main(int argc, char **argv)
{
    Biobuf b;
    char *p, *q;
    int lfd;

    p = "0,0,200,60";
    
    ARGBEGIN{
    case 'w':
        p = ARGF();
        break;
    case 't':
        textmode = 1;
        break;
    case 'k':
        nokill = 1;
        break;
    default:
        usage();
    }ARGEND;

    if(argc != 1)
        usage();

    title = argv[0];

    lfd = dup(0, -1);

    while(q = strchr(p, ','))
        *q = ' ';
    Binit(&b, lfd, OREAD);
    if(textmode || newwin(p) < 0){
        textmode = 1;
        rbar = Rect(0, 0, 60, 1);
    }else{
        if(initdraw(0, 0, "bar") < 0)
            exits("initdraw");
        initcolor();
        einit(Emouse|Ekeyboard);
        eresized(0);
    }
    bar(&b);

    exits(0);
}
@

<<function rdenv>>=
/* all code below this line should be in the library, but is stolen from colors instead */
static char*
rdenv(char *name)
{
    char *v;
    int fd, size;

    fd = open(name, OREAD);
    if(fd < 0)
        return 0;
    size = seek(fd, 0, 2);
    v = malloc(size+1);
    if(v == 0){
        fprint(2, "%s: can't malloc: %r\n", argv0);
        exits("no mem");
    }
    seek(fd, 0, 0);
    read(fd, v, size);
    v[size] = 0;
    close(fd);
    return v;
}
@

<<function newwin>>=
int
newwin(char *win)
{
    char *srv, *mntsrv;
    char spec[100];
    int srvfd, cons, pid;

    switch(rfork(RFFDG|RFPROC|RFNAMEG|RFENVG|RFNOTEG|RFNOWAIT)){
    case -1:
        fprint(2, "statusbar: can't fork: %r\n");
        return -1;
    case 0:
        break;
    default:
        exits(0);
    }

    srv = rdenv("/env/wsys");
    if(srv == 0){
        mntsrv = rdenv("/mnt/term/env/wsys");
        if(mntsrv == 0){
            fprint(2, "statusbar: can't find $wsys\n"); //$
            return -1;
        }
        srv = malloc(strlen(mntsrv)+10);
        sprint(srv, "/mnt/term%s", mntsrv);
        free(mntsrv);
        pid  = 0;			/* can't send notes to remote processes! */
    }else
        pid = getpid();
    USED(pid);
    srvfd = open(srv, ORDWR);
    free(srv);
    if(srvfd == -1){
        fprint(2, "statusbar: can't open %s: %r\n", srv);
        return -1;
    }
    sprint(spec, "new -r %s", win);
    if(mount(srvfd, -1, "/mnt/wsys", 0, spec) == -1){
        fprint(2, "statusbar: can't mount /mnt/wsys: %r (spec=%s)\n", spec);
        return -1;
    }
    close(srvfd);
    unmount("/mnt/acme", "/dev");
    bind("/mnt/wsys", "/dev", MBEFORE);
    cons = open("/dev/cons", OREAD);
    if(cons==-1){
    NoCons:
        fprint(2, "statusbar: can't open /dev/cons: %r");
        return -1;
    }
    dup(cons, 0);
    close(cons);
    cons = open("/dev/cons", OWRITE);
    if(cons==-1)
        goto NoCons;
    dup(cons, 1);
    dup(cons, 2);
    close(cons);
//	wctlfd = open("/dev/wctl", OWRITE);
    return 0;
}
@
%$

<<function screenrect>>=
Rectangle
screenrect(void)
{
    int fd;
    char buf[12*5];

    fd = open("/dev/screen", OREAD);
    if(fd == -1)
        fd=open("/mnt/term/dev/screen", OREAD);
    if(fd == -1){
        fprint(2, "%s: can't open /dev/screen: %r\n", argv0);
        exits("window read");
    }
    if(read(fd, buf, sizeof buf) != sizeof buf){
        fprint(2, "%s: can't read /dev/screen: %r\n", argv0);
        exits("screen read");
    }
    close(fd);
    return Rect(atoi(buf+12), atoi(buf+24), atoi(buf+36), atoi(buf+48));
}
@

<<function postnote>>=
int
postnote(int group, int pid, char *note)
{
    char file[128];
    int f, r;

    switch(group) {
    case PNPROC:
        sprint(file, "/proc/%d/note", pid);
        break;
    case PNGROUP:
        sprint(file, "/proc/%d/notepg", pid);
        break;
    case PNCTL:
        sprint(file, "/proc/%d/ctl", pid);
        break;
    default:
        return -1;
    }

    f = open(file, OWRITE);
    if(f < 0)
        return -1;

    r = strlen(note);
    if(write(f, note, r) != r) {
        close(f);
        return -1;
    }
    close(f);
    return 0;
}
@


%-------------------------------------------------------------

<<windows/apps/statusbar.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <window.h>
#include <bio.h>
#include <event.h>

<<enum _anon_ (windows/apps/statusbar.c)>>

static char* rdenv(char*);
int newwin(char*);
Rectangle screenrect(void);

<<global nokill>>
<<global textmode>>
<<global title>>

<<global light>>
<<global dark>>
<<global text (windows/apps/statusbar.c)>>

<<function initcolor>>

<<global rbar>>
<<global ptext>>
static vlong n, d;
<<global last>>
<<global lastp (windows/apps/statusbar.c)>>

<<global backup>>

<<function drawbar>>

<<function eresized (windows/apps/statusbar.c)>>

<<function bar>>


<<function usage (windows/apps/statusbar.c)>>

<<function main (windows/apps/statusbar.c)>>


<<function rdenv>>

<<function newwin>>

<<function screenrect>>

<<function postnote>>
@


\subsection*{[[windows/apps/winwatch.c]]}

<<struct Win>>=
struct Win {
    int n;
    int dirty;
    char *label;
    Rectangle r;
};
@

<<global exclude>>=
static Reprog  *exclude  = nil;
@

<<global win>>=
static Win *win;
@

<<global nwin>>=
static int nwin;
@

<<global mwin>>=
static int mwin;
@

<<global onwin>>=
static int onwin;
@

<<global lightblue>>=
static Image *lightblue;
@

<<enum _anon_ (windows/apps/winwatch.c)>>=
enum {
    PAD = 3,
    MARGIN = 5
};
@

<<function erealloc (windows/apps/winwatch.c)>>=
static void*
erealloc(void *v, ulong n)
{
    v = realloc(v, n);
    if(v == nil)
        sysfatal("out of memory reallocating %lud", n);
    return v;
}
@

<<function emalloc (windows/apps/winwatch.c)>>=
static void*
emalloc(ulong n)
{
    void *v;

    v = malloc(n);
    if(v == nil)
        sysfatal("out of memory allocating %lud", n);
    memset(v, 0, n);
    return v;
}
@

<<function estrdup (windows/apps/winwatch.c)>>=
static char*
estrdup(char *s)
{
    int l;
    char *t;

    if (s == nil)
        return nil;
    l = strlen(s)+1;
    t = emalloc(l);
    memcpy(t, s, l);

    return t;
}
@

<<function refreshwin>>=
static void
refreshwin(void)
{
    char label[128];
    int i, fd, lfd, n, nr, nw, m;
    Dir *pd;

    if((fd = open("/dev/wsys", OREAD)) < 0)
        return;

    nw = 0;
/* i'd rather read one at a time but rio won't let me */
    while((nr=dirread(fd, &pd)) > 0){
        for(i=0; i<nr; i++){
            n = atoi(pd[i].name);
            sprint(label, "/dev/wsys/%d/label", n);
            if((lfd = open(label, OREAD)) < 0)
                continue;
            m = read(lfd, label, sizeof(label)-1);
            close(lfd);
            if(m < 0)
                continue;
            label[m] = '\0';
            if(exclude != nil && regexec(exclude,label,nil,0))
                continue;

            if(nw < nwin && win[nw].n == n && strcmp(win[nw].label, label)==0){
                nw++;
                continue;
            }
    
            if(nw < nwin){
                free(win[nw].label);
                win[nw].label = nil;
            }
            
            if(nw >= mwin){
                mwin += 8;
                win = erealloc(win, mwin*sizeof(win[0]));
            }
            win[nw].n = n;
            win[nw].label = estrdup(label);
            win[nw].dirty = 1;
            win[nw].r = Rect(0,0,0,0);
            nw++;
        }
        free(pd);
    }
    while(nwin > nw)
        free(win[--nwin].label);
    nwin = nw;
    close(fd);
}
@

<<function drawnowin>>=
static void
drawnowin(int i)
{
    Rectangle r;

    r = Rect(0,0,(Dx(view->r)-2*MARGIN+PAD)/cols-PAD, font->height);
    r = rectaddpt(rectaddpt(r, Pt(MARGIN+(PAD+Dx(r))*(i/rows),
                MARGIN+(PAD+Dy(r))*(i%rows))), view->r.min);
    draw(view, insetrect(r, -1), lightblue, nil, ZP);
}
@

<<function drawwin>>=
static void
drawwin(int i)
{
    draw(view, win[i].r, lightblue, nil, ZP);
    _string(view, addpt(win[i].r.min, Pt(2,0)), display->black, ZP,
        font, win[i].label, nil, strlen(win[i].label), 
        win[i].r, nil, ZP, SoverD);
    border(view, win[i].r, 1, display->black, ZP);	
    win[i].dirty = 0;
}
@

<<function geometry>>=
static int
geometry(void)
{
    int i, ncols, z;
    Rectangle r;

    z = 0;
    rows = (Dy(view->r)-2*MARGIN+PAD)/(font->height+PAD);
    if(rows*cols < nwin || rows*cols >= nwin*2){
        ncols = nwin <= 0 ? 1 : (nwin+rows-1)/rows;
        if(ncols != cols){
            cols = ncols;
            z = 1;
        }
    }

    r = Rect(0,0,(Dx(view->r)-2*MARGIN+PAD)/cols-PAD, font->height);
    for(i=0; i<nwin; i++)
        win[i].r = rectaddpt(rectaddpt(r, Pt(MARGIN+(PAD+Dx(r))*(i/rows),
                    MARGIN+(PAD+Dy(r))*(i%rows))), view->r.min);

    return z;
}
@

<<function redraw (windows/apps/winwatch.c)>>=
static void
redraw(Image *view, int all)
{
    int i;

    all |= geometry();
    if(all)
        draw(view, view->r, lightblue, nil, ZP);
    for(i=0; i<nwin; i++)
        if(all || win[i].dirty)
            drawwin(i);
    if(!all)
        for(; i<onwin; i++)
            drawnowin(i);

    onwin = nwin;
}
@

<<function eresized (windows/apps/winwatch.c)>>=
void
eresized(int new)
{
    if(new && getwindow(display, Refmesg) < 0)
        fprint(2,"can't reattach to window");
    geometry();
    redraw(view, 1);
}
@

<<function click>>=
static void
click(Mouse m)
{
    int fd, i, j;	
    char buf[128];

    if(m.buttons == 0 || (m.buttons & ~4))
        return;

    for(i=0; i<nwin; i++)
        if(ptinrect(m.xy, win[i].r))
            break;
    if(i == nwin)
        return;

    do
        m = emouse();
    while(m.buttons == 4);

    if(m.buttons != 0){
        do
            m = emouse();
        while(m.buttons);
        return;
    }

    for(j=0; j<nwin; j++)
        if(ptinrect(m.xy, win[j].r))
            break;
    if(j != i)
        return;

    sprint(buf, "/dev/wsys/%d/wctl", win[i].n);
    if((fd = open(buf, OWRITE)) < 0)
        return;
    write(fd, "unhide\n", 7);
    write(fd, "top\n", 4);
    write(fd, "current\n", 8);
    close(fd);
}
@

<<function usage (windows/apps/winwatch.c)>>=
static void
usage(void)
{
    fprint(2, "usage: winwatch [-e exclude] [-f font]\n");
    exits("usage");
}
@

<<function main (windows/apps/winwatch.c)>>=
void
main(int argc, char **argv)
{
    char *fontname;
    int Etimer;
    Event e;

    fontname = "/lib/font/bit/lucidasans/unicode.8.font";
    ARGBEGIN{
    case 'f':
        fontname = EARGF(usage());
        break;
    case 'e':
        exclude = regcomp(EARGF(usage()));
        if(exclude == nil)
            sysfatal("Bad regexp");
        break;
    default:
        usage();
    }ARGEND

    if(argc)
        usage();

    initdraw(0, 0, "winwatch");
    lightblue = allocimagemix(display, DPalebluegreen, DWhite);
    if(lightblue == nil)
        sysfatal("allocimagemix: %r");
    if((font = openfont(display, fontname)) == nil)
        sysfatal("font '%s' not found", fontname);

    refreshwin();
    redraw(view, 1);
    einit(Emouse|Ekeyboard);
    Etimer = etimer(0, 2500);

    for(;;){
        switch(eread(Emouse|Ekeyboard|Etimer, &e)){
        case Ekeyboard:
            if(e.kbdc==0x7F || e.kbdc=='q')
                exits(0);
            break;
        case Emouse:
            if(e.mouse.buttons)
                click(e.mouse);
            /* fall through  */
        default:	/* Etimer */
            refreshwin();
            redraw(view, 0);
            break;
        }
    }
}
@


%-------------------------------------------------------------

<<windows/apps/winwatch.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
//#include <draw_private.h> // for _string, but should not use it
#include <window.h>
#include <event.h>
#include <regexp.h>

extern Point _string(Image *dst, Point pt, Image *src, Point sp, Font *f, char *s, Rune *r, int len, Rectangle clipr, Image *bg, Point bgp, Drawop op);

typedef struct Win Win;
<<struct Win>>



<<global exclude>>
<<global win>>
<<global nwin>>
<<global mwin>>
<<global onwin>>
static int rows, cols;
<<global lightblue>>

extern Font *font;

<<enum _anon_ (windows/apps/winwatch.c)>>

<<function erealloc (windows/apps/winwatch.c)>>

<<function emalloc (windows/apps/winwatch.c)>>

<<function estrdup (windows/apps/winwatch.c)>>


<<function refreshwin>>

<<function drawnowin>>

<<function drawwin>>

<<function geometry>>

<<function redraw (windows/apps/winwatch.c)>>

<<function eresized (windows/apps/winwatch.c)>>

<<function click>>

<<function usage (windows/apps/winwatch.c)>>

<<function main (windows/apps/winwatch.c)>>
@


\section{[[windows/libcomplete/]]}

\subsection*{[[windows/libcomplete/complete.c]]}


%-------------------------------------------------------------

<<windows/libcomplete/complete.c>>=
#include <u.h>
#include <libc.h>
#include "complete.h"

<<function longestprefixlength>>

<<function freecompletion>>

<<function strpcmp>>

<<function complete>>
@


\section{[[windows/libframe/]]}

\subsection*{[[windows/libframe/frbox.c]]}



%-------------------------------------------------------------

<<windows/libframe/frbox.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <thread.h>
#include <mouse.h>
#include <frame.h>

<<constant SLOP>>

<<function _fraddbox>>

<<function _frclosebox>>

<<function _frdelbox>>

<<function _frfreebox>>

<<function _frgrowbox>>

<<function dupbox>>

<<function runeindex>>

<<function truncatebox>>

<<function chopbox>>

<<function _frsplitbox>>

<<function _frmergebox>>

<<function _frfindbox>>
@


\subsection*{[[windows/libframe/frdelete.c]]}


%-------------------------------------------------------------

<<windows/libframe/frdelete.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <thread.h>
#include <mouse.h>
#include <frame.h>

<<function frdelete>>
@


\subsection*{[[windows/libframe/frdraw.c]]}



%-------------------------------------------------------------

<<windows/libframe/frdraw.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <thread.h>
#include <mouse.h>
#include <frame.h>

<<function _frdrawtext>>

<<function nbytes>>

<<function frdrawsel>>

<<function frdrawsel0>>

<<function frredraw>>

<<function frtick>>

<<function _frdraw>>

<<function _frstrlen>>
@


\subsection*{[[windows/libframe/frinit.c]]}


%-------------------------------------------------------------

<<windows/libframe/frinit.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <thread.h>
#include <mouse.h>
#include <frame.h>

<<function frinit>>

<<function frinittick>>

<<function frsetrects>>

<<function frclear>>
@


\subsection*{[[windows/libframe/frinsert.c]]}



%-------------------------------------------------------------

<<windows/libframe/frinsert.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <thread.h>
#include <mouse.h>
#include <frame.h>

<<constant DELTA>>
<<constant TMPSIZE>>
<<global frame>>

<<function bxscan>>

<<function chopframe>>

<<struct points_frinsert>>

<<function frinsert>>
@


\subsection*{[[windows/libframe/frptofchar.c]]}



%-------------------------------------------------------------

<<windows/libframe/frptofchar.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <thread.h>
#include <mouse.h>
#include <frame.h>

<<function _frptofcharptb>>

<<function frptofchar>>

<<function _frptofcharnb>>

<<function _frgrid>>

<<function frcharofpt>>
@


\subsection*{[[windows/libframe/frselect.c]]}


%-------------------------------------------------------------

<<windows/libframe/frselect.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <thread.h>
#include <mouse.h>
#include <frame.h>

<<function region>>

<<function frselect>>

<<function frselectpaint>>
@


\subsection*{[[windows/libframe/frstr.c]]}


%-------------------------------------------------------------

<<windows/libframe/frstr.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <thread.h>
#include <mouse.h>
#include <frame.h>

<<constant CHUNK (windows/libframe/frstr.c)>>
<<function ROUNDUP>>

<<function _frallocstr>>

<<function _frinsure>>
@


\subsection*{[[windows/libframe/frutil.c]]}



%-------------------------------------------------------------

<<windows/libframe/frutil.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <thread.h>
#include <mouse.h>
#include <frame.h>

<<function _frcanfit>>

<<function _frcklinewrap>>

<<function _frcklinewrap0>>

<<function _fradvance>>

<<function _frnewwid>>

<<function _frnewwid0>>

<<function _frclean>>
@








\section{[[windows/libplumb/]]}

\subsection*{[[windows/libplumb/event.c]]}

<<struct EQueue>>=
struct EQueue
{
    int		id;
    char		*buf;
    int		nbuf;
    EQueue	*next;
};
@

<<global equeue>>=
static	EQueue	*equeue;
@

<<global eqlock>>=
static	Lock		eqlock;
@

<<function partial>>=
static
int
partial(int id, Event *e, uchar *b, int n)
{
    EQueue *eq, *p;
    int nmore;

    lock(&eqlock);
    for(eq = equeue; eq != nil; eq = eq->next)
        if(eq->id == id)
            break;
    unlock(&eqlock);
    if(eq == nil)
        return 0;
    /* partial message exists for this id */
    eq->buf = realloc(eq->buf, eq->nbuf+n);
    if(eq->buf == nil)
        drawerror(display, "eplumb: cannot allocate buffer");
    memmove(eq->buf+eq->nbuf, b, n);
    eq->nbuf += n;
    e->v = plumbunpackpartial((char*)eq->buf, eq->nbuf, &nmore);
    if(nmore == 0){	/* no more to read in this message */
        lock(&eqlock);
        if(eq == equeue)
            equeue = eq->next;
        else{
            for(p = equeue; p!=nil && p->next!=eq; p = p->next)
                ;
            if(p == nil)
                drawerror(display, "eplumb: bad event queue");
            p->next = eq->next;
        }
        unlock(&eqlock);
        free(eq->buf);
        free(eq);
    }
    return 1;
}
@

<<function addpartial>>=
static
void
addpartial(int id, char *b, int n)
{
    EQueue *eq;

    eq = malloc(sizeof(EQueue));
    if(eq == nil)
        return;
    eq->id = id;
    eq->nbuf = n;
    eq->buf = malloc(n);
    if(eq->buf == nil){
        free(eq);
        return;
    }
    memmove(eq->buf, b, n);
    lock(&eqlock);
    eq->next = equeue;
    equeue = eq;
    unlock(&eqlock);
}
@

<<function plumbevent>>=
static
int
plumbevent(int id, Event *e, uchar *b, int n)
{
    int nmore;

    if(partial(id, e, b, n) == 0){
        /* no partial message already waiting for this id */
        e->v = plumbunpackpartial((char*)b, n, &nmore);
        if(nmore > 0)	/* incomplete message */
            addpartial(id, (char*)b, n);
    }
    if(e->v == nil)
        return 0;
    return id;
}
@

<<function eplumb>>=
int
eplumb(int key, char *port)
{
    int fd;

    fd = plumbopen(port, OREAD|OCEXEC);
    if(fd < 0)
        return -1;
    return estartfn(key, fd, 8192, plumbevent);
}
@


%-------------------------------------------------------------

<<windows/libplumb/event.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <event.h>
#include "plumb.h"

typedef struct EQueue EQueue;

<<struct EQueue>>

<<global equeue>>
<<global eqlock>>

<<function partial>>

<<function addpartial>>

<<function plumbevent>>

<<function eplumb>>
@


\subsection*{[[windows/libplumb/mesg.c]]}

<<function plumbopen>>=
int
plumbopen(char *name, int omode)
{
    int fd, f;
    char *s, *plumber;
    char buf[128], err[ERRMAX];

    if(name[0] == '/')
        return open(name, omode);
        
    /* find elusive plumber */
    if(access("/mnt/plumb/send", AWRITE) >= 0)
        plumber = "/mnt/plumb";
    else if(access("/mnt/term/mnt/plumb/send", AWRITE) >= 0)
        plumber = "/mnt/term/mnt/plumb";
    else{
        /* last resort: try mounting service */
        plumber = "/mnt/plumb";
        s = getenv("plumbsrv");
        if(s == nil)
            return -1;
        f = open(s, ORDWR);
        free(s);
        if(f < 0)
            return -1;
        if(mount(f, -1, "/mnt/plumb", MREPL, "") < 0){
            close(f);
            return -1;
        }
        if(access("/mnt/plumb/send", AWRITE) < 0)
            return -1;
    }

    snprint(buf, sizeof buf, "%s/%s", plumber, name);
    fd = open(buf, omode);
    if(fd >= 0)
        return fd;

    /* try creating port; used by non-standard plumb implementations */
    rerrstr(err, sizeof err);
    fd = create(buf, omode, 0600);
    if(fd >= 0)
        return fd;
    errstr(err, sizeof err);

    return -1;
}
@

<<function Strlen>>=
static int
Strlen(char *s)
{
    if(s == nil)
        return 0;
    return strlen(s);
}
@

<<function Strcpy>>=
static char*
Strcpy(char *s, char *t)
{
    if(t == nil)
        return s;
    return strcpy(s, t) + strlen(t);
}
@

<<function quote>>=
/* quote attribute value, if necessary */
static char*
quote(char *s, char *buf, char *bufe)
{
    char *t;
    int c;

    if(s == nil){
        buf[0] = '\0';
        return buf;
    }
    if(strpbrk(s, " '=\t") == nil)
        return s;
    t = buf;
    *t++ = '\'';
    while(t < bufe-2){
        c = *s++;
        if(c == '\0')
            break;
        *t++ = c;
        if(c == '\'')
            *t++ = c;
    }
    *t++ = '\'';
    *t = '\0';
    return buf;
}
@

<<function plumbpackattr>>=
char*
plumbpackattr(Plumbattr *attr)
{
    int n;
    Plumbattr *a;
    char *s, *t, *buf, *bufe;

    if(attr == nil)
        return nil;
    if((buf = malloc(4096)) == nil)
        return nil;
    bufe = buf + 4096;
    n = 0;
    for(a=attr; a!=nil; a=a->next)
        n += Strlen(a->name) + 1 + Strlen(quote(a->value, buf, bufe)) + 1;
    s = malloc(n);
    if(s == nil) {
        free(buf);
        return nil;
    }
    t = s;
    *t = '\0';
    for(a=attr; a!=nil; a=a->next){
        if(t != s)
            *t++ = ' ';
        strcpy(t, a->name);
        strcat(t, "=");
        strcat(t, quote(a->value, buf, bufe));
        t += strlen(t);
    }
    if(t > s+n)
        abort();
    free(buf);
    return s;
}
@

<<function plumblookup>>=
char*
plumblookup(Plumbattr *attr, char *name)
{
    while(attr){
        if(strcmp(attr->name, name) == 0)
            return attr->value;
        attr = attr->next;
    }
    return nil;
}
@

<<function plumbpack>>=
char*
plumbpack(Plumbmsg *m, int *np)
{
    int n, ndata;
    char *buf, *p, *attr;

    ndata = m->ndata;
    if(ndata < 0)
        ndata = Strlen(m->data);
    attr = plumbpackattr(m->attr);
    n = Strlen(m->src)+1 + Strlen(m->dst)+1 + Strlen(m->wdir)+1 +
        Strlen(m->type)+1 + Strlen(attr)+1 + 16 + ndata;
    buf = malloc(n+1);	/* +1 for '\0' */
    if(buf == nil){
        free(attr);
        return nil;
    }
    p = Strcpy(buf, m->src);
    *p++ = '\n';
    p = Strcpy(p, m->dst);
    *p++ = '\n';
    p = Strcpy(p, m->wdir);
    *p++ = '\n';
    p = Strcpy(p, m->type);
    *p++ = '\n';
    p = Strcpy(p, attr);
    *p++ = '\n';
    p += sprint(p, "%d\n", ndata);
    memmove(p, m->data, ndata);
    *np = (p-buf)+ndata;
    buf[*np] = '\0';	/* null terminate just in case */
    if(*np >= n+1)
        abort();
    free(attr);
    return buf;
}
@

<<function plumbsend>>=
int
plumbsend(int fd, Plumbmsg *m)
{
    char *buf;
    int n;

    buf = plumbpack(m, &n);
    if(buf == nil)
        return -1;
    n = write(fd, buf, n);
    free(buf);
    return n;
}
@

<<function plumbline>>=
static int
plumbline(char **linep, char *buf, int i, int n, int *bad)
{
    int starti;
    char *p;

    starti = i;
    while(i<n && buf[i]!='\n')
        i++;
    if(i == n)
        *bad = 1;
    else{
        p = malloc((i-starti) + 1);
        if(p == nil)
            *bad = 1;
        else{
            memmove(p, buf+starti, i-starti);
            p[i-starti] = '\0';
        }
        *linep = p;
        i++;
    }
    return i;
}
@

<<function plumbfree>>=
void
plumbfree(Plumbmsg *m)
{
    Plumbattr *a, *next;

    free(m->src);
    free(m->dst);
    free(m->wdir);
    free(m->type);
    for(a=m->attr; a!=nil; a=next){
        next = a->next;
        free(a->name);
        free(a->value);
        free(a);
    }
    free(m->data);
    free(m);
}
@

<<function plumbunpackattr>>=
Plumbattr*
plumbunpackattr(char *p)
{
    Plumbattr *attr, *prev, *a;
    char *q, *v, *buf, *bufe;
    int c, quoting;

    buf = malloc(4096);
    if(buf == nil)
        return nil;
    bufe = buf + 4096;
    attr = prev = nil;
    while(*p!='\0' && *p!='\n'){
        while(*p==' ' || *p=='\t')
            p++;
        if(*p == '\0')
            break;
        for(q=p; *q!='\0' && *q!='\n' && *q!=' ' && *q!='\t'; q++)
            if(*q == '=')
                break;
        if(*q != '=')
            break;	/* malformed attribute */
        a = malloc(sizeof(Plumbattr));
        if(a == nil)
            break;
        a->name = malloc(q-p+1);
        if(a->name == nil){
            free(a);
            break;
        }
        memmove(a->name, p, q-p);
        a->name[q-p] = '\0';
        /* process quotes in value */
        q++;	/* skip '=' */
        v = buf;
        quoting = 0;
        while(*q!='\0' && *q!='\n'){
            if(v >= bufe)
                break;
            c = *q++;
            if(quoting){
                if(c == '\''){
                    if(*q == '\'')
                        q++;
                    else{
                        quoting = 0;
                        continue;
                    }
                }
            }else{
                if(c==' ' || c=='\t')
                    break;
                if(c == '\''){
                    quoting = 1;
                    continue;
                }
            }
            *v++ = c;
        }
        a->value = malloc(v-buf+1);
        if(a->value == nil){
            free(a->name);
            free(a);
            break;
        }
        memmove(a->value, buf, v-buf);
        a->value[v-buf] = '\0';
        a->next = nil;
        if(prev == nil)
            attr = a;
        else
            prev->next = a;
        prev = a;
        p = q;
    }
    free(buf);
    return attr;
}
@

<<function plumbaddattr>>=
Plumbattr*
plumbaddattr(Plumbattr *attr, Plumbattr *new)
{
    Plumbattr *l;

    l = attr;
    if(l == nil)
        return new;
    while(l->next != nil)
        l = l->next;
    l->next = new;
    return attr;
}
@

<<function plumbdelattr>>=
Plumbattr*
plumbdelattr(Plumbattr *attr, char *name)
{
    Plumbattr *l, *prev;

    prev = nil;
    for(l=attr; l!=nil; l=l->next){
        if(strcmp(name, l->name) == 0)
            break;
        prev = l;
    }
    if(l == nil)
        return nil;
    if(prev)
        prev->next = l->next;
    else
        attr = l->next;
    free(l->name);
    free(l->value);
    free(l);
    return attr;
}
@

<<function plumbunpackpartial>>=
Plumbmsg*
plumbunpackpartial(char *buf, int n, int *morep)
{
    Plumbmsg *m;
    int i, bad;
    char *ntext, *attr;

    m = malloc(sizeof(Plumbmsg));
    if(m == nil)
        return nil;
    memset(m, 0, sizeof(Plumbmsg));
    if(morep != nil)
        *morep = 0;
    bad = 0;
    i = plumbline(&m->src, buf, 0, n, &bad);
    i = plumbline(&m->dst, buf, i, n, &bad);
    i = plumbline(&m->wdir, buf, i, n, &bad);
    i = plumbline(&m->type, buf, i, n, &bad);
    i = plumbline(&attr, buf, i, n, &bad);
    i = plumbline(&ntext, buf, i, n, &bad);
    if(bad){
        plumbfree(m);
        return nil;
    }
    m->attr = plumbunpackattr(attr);
    free(attr);
    m->ndata = atoi(ntext);
    if(m->ndata != n-i){
        bad = 1;
        if(morep!=nil && m->ndata>n-i)
            *morep = m->ndata - (n-i);
    }
    free(ntext);
    if(!bad){
        m->data = malloc(n-i+1);	/* +1 for '\0' */
        if(m->data == nil)
            bad = 1;
        else{
            memmove(m->data, buf+i, m->ndata);
            m->ndata = n-i;
            /* null-terminate in case it's text */
            m->data[m->ndata] = '\0';
        }
    }
    if(bad){
        plumbfree(m);
        m = nil;
    }
    return m;
}
@

<<function plumbunpack>>=
Plumbmsg*
plumbunpack(char *buf, int n)
{
    return plumbunpackpartial(buf, n, nil);
}
@

<<function plumbrecv>>=
Plumbmsg*
plumbrecv(int fd)
{
    char *buf;
    Plumbmsg *m;
    int n, more;

    buf = malloc(8192);
    if(buf == nil)
        return nil;
    n = read(fd, buf, 8192);
    m = nil;
    if(n > 0){
        m = plumbunpackpartial(buf, n, &more);
        if(m==nil && more>0){
            /* we now know how many more bytes to read for complete message */
            buf = realloc(buf, n+more);
            if(buf == nil)
                return nil;
            if(readn(fd, buf+n, more) == more)
                m = plumbunpackpartial(buf, n+more, nil);
        }
    }
    free(buf);
    return m;
}
@


%-------------------------------------------------------------

<<windows/libplumb/mesg.c>>=
#include <u.h>
#include <libc.h>
#include "plumb.h"

<<function plumbopen>>

<<function Strlen>>

<<function Strcpy>>

<<function quote>>

<<function plumbpackattr>>

<<function plumblookup>>

<<function plumbpack>>

<<function plumbsend>>

<<function plumbline>>

<<function plumbfree>>

<<function plumbunpackattr>>

<<function plumbaddattr>>

<<function plumbdelattr>>

<<function plumbunpackpartial>>

<<function plumbunpack>>

<<function plumbrecv>>
@


\subsection*{[[windows/libplumb/plumbsendtext.c]]}

<<function plumbsendtext>>=
int
plumbsendtext(int fd, char *src, char *dst, char *wdir, char *data)
{
    Plumbmsg m;

    m.src = src;
    m.dst = dst;
    m.wdir = wdir;
    m.type = "text";
    m.attr = nil;
    m.ndata = strlen(data);
    m.data = data;
    return plumbsend(fd, &m);
}
@


%-------------------------------------------------------------

<<windows/libplumb/plumbsendtext.c>>=
#include <u.h>
#include <libc.h>
#include "plumb.h"

<<function plumbsendtext>>
@


