\section{[[include/]]}

\subsection*{[[include/complete.h]]}

%-------------------------------------------------------------

<<include/complete.h>>=
#pragma	lib	"libcomplete.a"
#pragma src "/sys/src/libcomplete"

typedef struct Completion Completion;

<<struct Completion>>

Completion* 	complete(char *dir, char *s);
void 		freecompletion(Completion*);
@

\subsection*{[[include/frame.h]]}


<<function NRUNE>>=
#define	NRUNE(b)	((b)->nrune<0 ? 1 : (b)->nrune)
@

<<function NBYTE>>=
#define	NBYTE(b)	strlen((char*)(b)->ptr)
@


%-------------------------------------------------------------

<<include/frame.h>>=
#pragma	src	"/sys/src/libframe"
#pragma	lib	"libframe.a"

typedef struct Frbox Frbox;
typedef struct Frame Frame;

<<enum _anon_ (include/frame.h)>>

<<constant FRTICKW>>

<<struct Frbox>>

<<struct Frame>>

ulong	frcharofpt(Frame*, Point);
Point	frptofchar(Frame*, ulong);
int	frdelete(Frame*, ulong, ulong);
void	frinsert(Frame*, Rune*, Rune*, ulong);
void	frselect(Frame*, Mousectl*);
void	frselectpaint(Frame*, Point, Point, Image*);
void	frdrawsel(Frame*, Point, ulong, ulong, int);
Point 	frdrawsel0(Frame*, Point, ulong, ulong, Image*, Image*);
void	frinit(Frame*, Rectangle, Font*, Image*, Image**);
void	frsetrects(Frame*, Rectangle, Image*);
void	frclear(Frame*, int);

uchar	*_frallocstr(Frame*, unsigned);
void	_frinsure(Frame*, int, unsigned);
Point	_frdraw(Frame*, Point);
void	_frgrowbox(Frame*, int);
void	_frfreebox(Frame*, int, int);
void	_frmergebox(Frame*, int);
void	_frdelbox(Frame*, int, int);
void	_frsplitbox(Frame*, int, int);
int	_frfindbox(Frame*, int, ulong, ulong);
void	_frclosebox(Frame*, int, int);
int	_frcanfit(Frame*, Point, Frbox*);
void	_frcklinewrap(Frame*, Point*, Frbox*);
void	_frcklinewrap0(Frame*, Point*, Frbox*);
void	_fradvance(Frame*, Point*, Frbox*);
int	_frnewwid(Frame*, Point, Frbox*);
int	_frnewwid0(Frame*, Point, Frbox*);
void	_frclean(Frame*, Point, int, int);
void	_frdrawtext(Frame*, Point, Image*, Image*);
void	_fraddbox(Frame*, int, int);
Point	_frptofcharptb(Frame*, ulong, Point, int);
Point	_frptofcharnb(Frame*, ulong, int);
int	_frstrlen(Frame*, int);
void	frtick(Frame*, Point, int);
void	frinittick(Frame*);
void	frredraw(Frame*);

<<function NRUNE>>
<<function NBYTE>>
@


\subsection*{[[include/plumb.h]]}


%-------------------------------------------------------------

<<include/plumb.h>>=
#pragma	lib	"libplumb.a"
#pragma	src	"/sys/src/libplumb"

/*
 * Message format:
 *	source application\n
 *	destination port\n
 *	working directory\n
 *	type\n
 *	attributes\n
 *	nbytes\n
 *	n bytes of data
 */

typedef struct Plumbattr Plumbattr;
typedef struct Plumbmsg Plumbmsg;

<<struct Plumbmsg>>

<<struct Plumbattr>>

int		plumbsend(int, Plumbmsg*);
int		plumbsendtext(int, char*, char*, char*, char*);
Plumbmsg*	plumbrecv(int);
char*		plumbpack(Plumbmsg*, int*);
Plumbmsg*	plumbunpack(char*, int);
Plumbmsg*	plumbunpackpartial(char*, int, int*);
char*		plumbpackattr(Plumbattr*);
Plumbattr*	plumbunpackattr(char*);
Plumbattr*	plumbaddattr(Plumbattr*, Plumbattr*);
Plumbattr*	plumbdelattr(Plumbattr*, char*);
void		plumbfree(Plumbmsg*);
char*		plumblookup(Plumbattr*, char*);
int		plumbopen(char*, int);
int		eplumb(int, char*);
@


\section{[[windows/rio/]]}

\subsection*{[[windows/rio/globals.c]]}


%-------------------------------------------------------------

<<windows/rio/globals.c>>=
#include <u.h>
#include <libc.h>

#include <draw.h>
#include <thread.h>
#include <cursor.h>
#include <mouse.h>
#include <keyboard.h>

#include <frame.h>

#include <fcall.h>

#include "dat.h"
#include "fns.h"

<<global mousectl>>
<<global mouse>>
<<global keyboardctl>>

<<global wscreen>>
<<global background>>
<<global red>>

<<global window>>
<<global wkeyboard>>
<<global nwindow>>

<<global snarffd>>
<<global input>>
<<global all>>
<<global filsys>>
<<global hidden>>
<<global nhidden>>
<<global nsnarf>>
<<global snarf>>
<<global scrolling>>
<<global maxtab>>
<<global deletechan>>
<<global startdir>>
<<global sweeping>>
<<global wctlfd>>
<<global menuing>>
<<global snarfversion>>
<<global errorshouldabort>>
<<global winclosechan>>
<<global messagesize>>
@

\subsection*{[[windows/rio/dat.h]]}

<<enum _anon_ (windows/rio/dat.h)3>>=
enum
{
    <<constant Selborder>>
    <<constant Unselborder>>
    <<constants Scrollxxx>>
    <<constant BIG>>
};
@

%dead:
% extern Image	*view;

%-------------------------------------------------------------

<<windows/rio/dat.h>>=
<<enum qid>>

<<enum _anon_ (windows/rio/dat.h)2>>

<<constant STACK>>

typedef	struct	Consreadmesg Consreadmesg;
typedef	struct	Conswritemesg Conswritemesg;
typedef	struct	Stringpair Stringpair;
typedef	struct	Dirtab Dirtab;
typedef	struct	Fid Fid;
typedef	struct	Filsys Filsys;
typedef	struct	Mouseinfo	Mouseinfo;
typedef	struct	Mousereadmesg Mousereadmesg;
typedef	struct	Mousestate	Mousestate;
typedef	struct	Ref Ref;
typedef	struct	Timer Timer;
typedef	struct	Wctlmesg Wctlmesg;
typedef	struct	Window Window;
typedef	struct	Xfid Xfid;

<<enum _anon_ (windows/rio/dat.h)3>>

<<function QID>>
<<function WIN>>
<<function FILE>>

<<enum wctlmesgkind>>

<<struct Wctlmesg>>

<<struct Conswritemesg>>

<<struct Consreadmesg>>

<<struct Mousereadmesg>>

<<struct Stringpair>>

<<struct Mousestate>>

<<struct Mouseinfo>>

<<struct Window>>

<<struct Dirtab>>

<<struct Fid>>

<<struct Xfid>>


<<constant Nhash>>

<<struct Filsys>>


<<struct Timer>>

// draw.h
extern Display	*display;
extern Font	*font;


extern Mousectl	*mousectl;
extern Mouse	*mouse;
extern Keyboardctl	*keyboardctl;

extern Screen	*wscreen;
extern Cursor	boxcursor;
extern Cursor	crosscursor;
extern Cursor	sightcursor;
extern Cursor	whitearrow;
extern Cursor	query;
extern Cursor	*corners[9];

extern Image	*background;
//extern Image	*lightgrey;
extern Image	*red;

extern Window	**windows;

extern Window	*wkeyboard;	/* window of simulated keyboard */
extern int		nwindow;
extern int		snarffd;
extern Window	*input;
extern QLock	all;			/* BUG */
extern Filsys	*filsys;
extern Window	*hidden[100];
extern int		nhidden;
extern int		nsnarf;
extern Rune*	snarf;
extern int		scrolling;
extern int		maxtab;
extern Channel*	winclosechan;
extern Channel*	deletechan;
extern char		*startdir;
extern int		sweeping;
extern int		wctlfd;
extern bool		errorshouldabort;
extern bool		menuing;
extern int		snarfversion;	/* updated each time it is written */
extern int		messagesize;	/* negotiated in 9P version setup */
@


\subsection*{[[windows/rio/data.c]]}


%-------------------------------------------------------------

<<windows/rio/data.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <thread.h>
#include <cursor.h>
#include <mouse.h>
#include <keyboard.h>
#include <frame.h>
#include <fcall.h>

#include "dat.h"
#include "fns.h"

<<global crosscursor (windows/rio/data.c)>>

<<global boxcursor (windows/rio/data.c)>>

<<global sightcursor (windows/rio/data.c)>>

<<global whitearrow (windows/rio/data.c)>>

<<global query (windows/rio/data.c)>>

<<global tl>>

<<global t>>

<<global tr>>

<<global r>>

<<global br>>

<<global b>>

<<global bl>>

<<global l>>

<<global corners (windows/rio/data.c)>>

<<function iconinit>>
@


\subsection*{[[windows/rio/fns.h]]}


%-------------------------------------------------------------

<<windows/rio/fns.h>>=

// Window stuff
int		winborder(Window*, Point);
void		winctl(void*);
void		winshell(void*);
Window*		wlookid(int);
Window*		wmk(Image*, Mousectl*, Channel*, Channel*, int);
Window*		wpointto(Point);
Window*		wtop(Point);
void		wtopme(Window*);
void		wbottomme(Window*);
char*		wcontents(Window*, int*);
int		wclose(Window*);

uint		wbacknl(Window*, uint, uint);
uint		winsert(Window*, Rune*, int, uint);
void		waddraw(Window*, Rune*, int);
void		wcurrent(Window*);
void		wcut(Window*);
void		wmovemouse(Window*, Point);
void		wpaste(Window*);
void		wplumb(Window*);

void		wscrdraw(Window*);
void		wscroll(Window*, int);
void		wsendctlmesg(Window*, int, Rectangle, Image*);
void		wsetcursor(Window*, bool);
void		wsetname(Window*);
void		wsetorigin(Window*, uint, int);
void		wsetpid(Window*, int, int);
void		wsetselect(Window*, uint, uint);
void		wshow(Window*, uint);
void		wsnarf(Window*);
void 		wscrsleep(Window*, uint);


// XFid stuff
Channel*	xfidinit(void);
void		xfidflush(Xfid*);
void		xfidattach(Xfid*);
void		xfidopen(Xfid*);
void		xfidclose(Xfid*);
void		xfidread(Xfid*);
void		xfidwrite(Xfid*);

// Filsys stuff
Filsys*	filsysinit(Channel*);
int		filsysmount(Filsys*, int);
Xfid*		filsysrespond(Filsys*, Xfid*, Fcall*, char*);
void		filsyscancel(Xfid*);

void		wctlproc(void*);
void		wctlthread(void*);

void		deletetimeoutproc(void*);



// Misc stuff
void	keyboardsend(char*, int);
int	whide(Window*);
int	wunhide(int);
void	freescrtemps(void);
int	parsewctl(char**, Rectangle, Rectangle*, int*, int*, int*, int*, char**, char*, char*);
int	writewctl(Xfid*, char*);
Window *new(Image*, int, int, int, char*, char*, char**);
void	riosetcursor(Cursor*, int);
int	min(int, int);
int	max(int, int);
Rune*	strrune(Rune*, Rune);
int	isalnum(Rune);
void	timerstop(Timer*);
void	timercancel(Timer*);
Timer*	timerstart(int);
void	error(char*);
void	iconinit(void);
void	*erealloc(void*, uint);
void 	*emalloc(uint);
char 	*estrdup(char*);
void	cvttorunes(char*, int, Rune*, int*, int*, int*);
/* was (byte*,int)	runetobyte(Rune*, int); */
char* 	runetobyte(Rune*, int, int*);
void	putsnarf(void);
void	getsnarf(void);
void	timerinit(void);
int	goodrect(Rectangle);


<<function runemalloc>>
<<function runerealloc>>
<<function runemove>>
@


\subsection*{[[windows/rio/fsys.c]]}

%-------------------------------------------------------------

<<windows/rio/fsys.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <thread.h>
#include <cursor.h>
#include <mouse.h>
#include <keyboard.h>
#include <frame.h>
#include <fcall.h>

#include "dat.h"
#include "fns.h"

<<global Eperm>>
<<global Eexist>>
<<global Enotdir>>
<<global Ebadfcall>>
<<global Eoffset>>


<<constant DEBUG>>

<<global dirtab>>

static uint		getclock(void);
static void		filsysproc(void*);
static Fid*		newfid(Filsys*, int);
static int		dostat(Filsys*, int, Dirtab*, uchar*, int, uint);

<<global clockfd>>
<<global firstmessage>>

<<global srvpipe (windows/rio/fsys.c)>>
<<global srvwctl (windows/rio/fsys.c)>>

static	Xfid*	filsysflush(Filsys*, Xfid*, Fid*);
static	Xfid*	filsysversion(Filsys*, Xfid*, Fid*);
static	Xfid*	filsysauth(Filsys*, Xfid*, Fid*);
static	Xfid*	filsysnop(Filsys*, Xfid*, Fid*);
static	Xfid*	filsysattach(Filsys*, Xfid*, Fid*);
static	Xfid*	filsyswalk(Filsys*, Xfid*, Fid*);
static	Xfid*	filsysopen(Filsys*, Xfid*, Fid*);
static	Xfid*	filsyscreate(Filsys*, Xfid*, Fid*);
static	Xfid*	filsysread(Filsys*, Xfid*, Fid*);
static	Xfid*	filsyswrite(Filsys*, Xfid*, Fid*);
static	Xfid*	filsysclunk(Filsys*, Xfid*, Fid*);
static	Xfid*	filsysremove(Filsys*, Xfid*, Fid*);
static	Xfid*	filsysstat(Filsys*, Xfid*, Fid*);
static	Xfid*	filsyswstat(Filsys*, Xfid*, Fid*);

<<global fcall>>

<<function post>>

<<function cexecpipe>>

<<function filsysinit>>

<<function filsysproc>>

<<function filsysmount>>

<<function filsysrespond>>

<<function filsyscancel>>

<<function filsysversion>>

<<function filsysauth>>

<<function filsysflush>>

<<function filsysattach>>

<<function numeric>>

<<function filsyswalk>>

<<function filsysopen>>

<<function filsyscreate>>

<<function idcmp>>

<<function filsysread>>

<<function filsyswrite>>

<<function filsysclunk>>

<<function filsysremove>>

<<function filsysstat>>

<<function filsyswstat>>

<<function newfid>>

<<function getclock>>

<<function dostat>>
@


\subsection*{[[windows/rio/rio.c]]}

%-------------------------------------------------------------

<<windows/rio/rio.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <thread.h>
#include <cursor.h>
#include <mouse.h>
#include <keyboard.h>
#include <frame.h>
#include <fcall.h>
#include <plumb.h>

#include "dat.h"
#include "fns.h"

/*
 *  WASHINGTON (AP) - The Food and Drug Administration warned
 * consumers Wednesday not to use ``Rio'' hair relaxer products
 * because they may cause severe hair loss or turn hair green....
 *    The FDA urged consumers who have experienced problems with Rio
 * to notify their local FDA office, local health department or the
 * company at 1‑800‑543‑3002.
 */

void	killprocs(void);
int	shutdown(void*, char*);
void	button3menu(void);
void	button2menu(Window*);

void	resize(void);
void	move(void);
void	delete(void);
void	hide(void);
void	unhide(int);
Image	*sweep(void);
Image	*bandsize(Window*);
Image*	drag(Window*, Rectangle*);
void	resized(void);

void	mousethread(void*);
void	keyboardthread(void*);
void 	winclosethread(void*);
void 	deletethread(void*);
void	initcmd(void*);

<<global exitchan>>
<<global viewr>>
<<global fontname>>

<<enum _anon_ (windows/rio/rio.c)>>

<<enum _anon_ (windows/rio/rio.c)2>>

<<global menu2str>>

<<global menu2>>

<<global menu3str>>

<<global menu3>>

<<global rcargv>>
<<global kbdargv>>



<<function derror>>

<<function usage>>

<<function threadmain>>

<<function putsnarf>>

<<function getsnarf>>

<<function initcmd>>

<<global oknotes>>

<<function shutdown>>

<<function killprocs>>

<<function keyboardthread>>

<<function keyboardsend>>

<<function portion>>

<<function whichcorner>>

<<function cornercursor>>

<<function winclosethread>>

<<function deletethread>>

<<function deletetimeoutproc>>

<<function keyboardhide>>

<<enum Mxxx>>

<<function mousethread>>

<<function resized>>

<<function button3menu>>

<<function button2menu>>

<<function onscreen>>

<<function sweep>>

<<function drawedge>>

<<function drawborder>>

<<function drag>>

<<function cornerpt>>

<<function whichrect>>

<<function bandsize>>

<<function pointto>>

<<function delete>>

<<function resize>>

<<function move>>

<<function whide>>

<<function wunhide>>

<<function hide>>

<<function unhide>>

<<function new>>
@


\subsection*{[[windows/rio/scrl.c]]}


%-------------------------------------------------------------

<<windows/rio/scrl.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <thread.h>
#include <cursor.h>
#include <mouse.h>
#include <keyboard.h>
#include <frame.h>
#include <fcall.h>

#include "dat.h"
#include "fns.h"

<<global scrtmp>>

<<function scrtemps>>

<<function freescrtemps>>

<<function scrpos>>

<<function wscrdraw>>

<<function wscrsleep>>

<<function wscroll>>
@


\subsection*{[[windows/rio/time.c]]}

%-------------------------------------------------------------

<<windows/rio/time.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <thread.h>
#include <cursor.h>
#include <mouse.h>
#include <keyboard.h>
#include <frame.h>
#include <fcall.h>

#include "dat.h"
#include "fns.h"

<<global ctimer>>
<<global timer>>

<<function msec>>

<<function timerstop>>

<<function timercancel>>

<<function timerproc>>

<<function timerinit>>

<<function timerstart>>
@


\subsection*{[[windows/rio/util.c]]}


%-------------------------------------------------------------

<<windows/rio/util.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <thread.h>
#include <cursor.h>
#include <mouse.h>
#include <keyboard.h>
#include <frame.h>
#include <fcall.h>

#include "dat.h"
#include "fns.h"

<<function cvttorunes>>

<<function error>>

<<function erealloc>>

<<function emalloc>>

<<function estrdup>>

<<function isalnum>>

<<function strrune>>

<<function min>>

<<function max (windows/rio/util.c)>>

<<function runetobyte>>

@


\subsection*{[[windows/rio/wctl.c]]}


%-------------------------------------------------------------

<<windows/rio/wctl.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <thread.h>
#include <cursor.h>
#include <mouse.h>
#include <keyboard.h>
#include <frame.h>
#include <fcall.h>
#include <plumb.h>

#include "dat.h"
#include "fns.h"

#include <ctype.h>

<<global Ebadwr>>
<<global Ewalloc>>

<<enum _anon_ (windows/rio/wctl.c)>>

<<global cmds>>

<<enum _anon_ (windows/rio/wctl.c)2>>

<<global params>>

<<function goodrect>>

<<function word>>

<<function set>>

<<function newrect>>

<<function shift>>

<<function rectonscreen>>

<<function riostrtol>>


<<function parsewctl>>

<<function wctlnew>>

<<function writewctl>>

<<function wctlthread>>

<<function wctlproc>>
@


\subsection*{[[windows/rio/wind.c]]}

%-------------------------------------------------------------

<<windows/rio/wind.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <thread.h>
#include <cursor.h>
#include <mouse.h>
#include <keyboard.h>
#include <frame.h>
#include <fcall.h>
#include <plumb.h>

#include <complete.h>

#include "dat.h"
#include "fns.h"


void	wrefresh(Window*, Rectangle);
void	wresize(Window*, Image*, int);
void	wkeyctl(Window*, Rune);
void	wsetcols(Window*);
void	wrepaint(Window*);
int 	wbswidth(Window*, Rune);
void	wmousectl(Window*);
void	wdelete(Window*, uint, uint);
void	wframescroll(Window*, int);
void	wselect(Window*);
int 	wctlmesg(Window*, int, Rectangle, Image*);
void	wborder(Window*, int);
void	wclosewin(Window*);
void	wdoubleclick(Window*, uint*, uint*);
int 	wclickmatch(Window*, int, int, int, uint*);
void	wfill(Window*);


<<enum _anon_ (windows/rio/wind.c)>>

<<global topped>>
<<global id>>

<<global cols>>
<<global grey>>
<<global darkgrey>>
<<global lastcursor>>
<<global titlecol>>
<<global lighttitlecol>>
<<global holdcol>>
<<global lightholdcol>>
<<global paleholdcol>>

<<function wmk>>

<<function wsetname>>

<<function wresize>>

<<function wrefresh>>

<<function wclose>>

<<enum Wxxx>>

<<function winctl>>

<<function waddraw>>

<<function interruptproc>>

<<function windfilewidth>>

<<function showcandidates>>

<<function namecomplete>>

<<function wkeyctl>>

<<function wsetcols>>

<<function wrepaint>>

<<function wbswidth>>

<<function wsnarf>>

<<function wcut>>

<<function wpaste>>

<<function wplumb>>

<<function winborder>>

<<function wmousectl>>

<<function wdelete>>


<<global clickwin>>
<<global clickmsec>>
<<global selectwin>>
<<global selectq>>

<<function framescroll>>

<<function wframescroll>>

<<function wselect>>

<<function wsendctlmesg>>

<<function wctlmesg>>

<<function wmovemouse>>

<<function wborder>>

<<function wpointto>>

<<function wcurrent>>

<<function wsetcursor>>

<<function riosetcursor>>

<<function wtop>>

<<function wtopme>>

<<function wbottomme>>

<<function wlookid>>

<<function wclosewin>>

<<function wsetpid>>

<<function winshell>>

<<global left1>>
<<global right1>>
<<global left2>>
<<global left3>>

<<global left>>
<<global right>>

<<function wdoubleclick>>

<<function wclickmatch>>


<<function wbacknl>>

<<function wshow>>

<<function wsetorigin>>

<<function wsetselect>>

<<function winsert>>

<<function wfill>>

<<function wcontents>>
@


\subsection*{[[windows/rio/xfid.c]]}

%-------------------------------------------------------------

<<windows/rio/xfid.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <thread.h>
#include <cursor.h>
#include <mouse.h>
#include <keyboard.h>
#include <frame.h>
#include <fcall.h>
#include <plumb.h>

#include "dat.h"
#include "fns.h"

void		xfidctl(void*);

<<constant MAXSNARF>>

<<global Einuse>>
<<global Edeleted>>
<<global Ebadreq>>
<<global Etooshort>>
<<global Ebadtile>>
<<global Eshort>>
<<global Elong>>
<<global Eunkid>>
<<global Ebadrect>>
<<global Ewindow>>
<<global Enowindow>>
<<global Ebadmouse>>
<<global Ebadwrect>>
<<global Ebadoffset>>
extern char Eperm[];

<<global xfidfree>>
<<global xfid>>
<<global cxfidalloc>>
<<global cxfidfree>>

<<global tsnarf>>
<<global ntsnarf>>

<<enum Xxxx>>

<<function xfidallocthread>>

<<function xfidinit>>

<<function xfidctl>>

<<function xfidflush>>

<<function xfidattach>>

<<function xfidopen>>

<<function xfidclose>>

<<enum _anon_ (windows/rio/xfid.c)2>>

<<function xfidwrite>>

<<function readwindow>>

<<enum _anon_ (windows/rio/xfid.c)3>>
<<enum _anon_ (windows/rio/xfid.c)4>>
<<enum _anon_ (windows/rio/xfid.c)5>>

<<function xfidread>>
@


\section{[[windows/apps/]]}

\subsection*{[[windows/apps/lens.c]]}

% put in Graphics.nw instead

<<enum _anon_ (windows/apps/lens.c)>>=
enum {
    Edge = 5,
    Maxmag = 16
};
@

<<enum _anon_ (windows/apps/lens.c)2>>=
enum {
    Mzoom,
    Munzoom,
    Mgrid,
    Mredraw,
    Mexit
};
@

<<global menustr>>=
static char *menustr[] = {
    "zoom",
    "unzoom",
    "grid",
    "redraw",
    "exit",
    nil
};
@

<<global menu (windows/apps/lens.c)>>=
static Menu menu = {
    menustr,
    nil,
    -1
};
@

<<global lastp>>=
static Point lastp;
@

<<global red (windows/apps/lens.c)>>=
static Image *red;
@

<<global tmp (windows/apps/lens.c)>>=
static Image *tmp;
@

<<global grid>>=
static Image *grid;
@

<<global chequer>>=
static Image *chequer;
@

<<global screenfd>>=
static int	screenfd;
@

<<global mag>>=
static int	mag = 4;
@

<<global showgrid>>=
static int	showgrid = 0;
@

<<global screenr>>=
static Rectangle	screenr;
@

<<global screenbuf>>=
static uchar	*screenbuf;
@

<<function drawit>>=
void
drawit(void)
{
    Rectangle r;
    border(view, view->r, Edge, red, ZP);
    magnify();
    r = insetrect(view->r, Edge);
    draw(view, r, tmp, nil, tmp->r.min);
    flushimage(display, true);
}
@

<<global bypp>>=
static int bypp;
@

<<function main (windows/apps/lens.c)>>=
void
main(int argc, char *argv[])
{
    Event e;
    char buf[5*12];
    ulong chan;
    int d;

    USED(argc, argv);

    if(initdraw(nil, nil, "lens") < 0){
        fprint(2, "lens: initdraw failed: %r\n");
        exits("initdraw");
    }
    einit(Emouse|Ekeyboard);

    red = allocimage(display, Rect(0, 0, 1, 1), CMAP8, 1, DRed);
    chequer = allocimage(display, Rect(0, 0, 2, 2), GREY1, 1, DBlack);

    draw(chequer, Rect(0, 0, 1, 1), display->white, nil, ZP);
    draw(chequer, Rect(1, 1, 2, 2), display->white, nil, ZP);
    lastp = divpt(addpt(view->r.min, view->r.max), 2);
    screenfd = open("/dev/screen", OREAD);
    if(screenfd < 0){
        fprint(2, "lens: can't open /dev/screen: %r\n");
        exits("screen");
    }
    if(read(screenfd, buf, sizeof buf) != sizeof buf){
        fprint(2, "lens: can't read /dev/screen: %r\n");
        exits("screen");
    }
    chan = strtochan(buf);
    d = chantodepth(chan);
    if(d < 8){
        fprint(2, "lens: can't handle screen format %11.11s\n", buf);
        exits("screen");
    }
    bypp = d/8;
    screenr.min.x = atoi(buf+1*12);
    screenr.min.y = atoi(buf+2*12);
    screenr.max.x = atoi(buf+3*12);
    screenr.max.y = atoi(buf+4*12);
    screenbuf = malloc(bypp*Dx(screenr)*Dy(screenr));
    if(screenbuf == nil){
        fprint(2, "lens: buffer malloc failed: %r\n");
        exits("malloc");
    }
    eresized(0);

    for(;;)
        switch(event(&e)){
        case Ekeyboard:
            switch(e.kbdc){
            case 'q':
            case 0x7f:
            case '\04':
            caseexit:
                exits(nil);
            case '=':
            case '+':
            casezoom:
                if(mag < Maxmag){
                    mag++;
                    makegrid();
                    drawit();
                }
                break;
            case 'g':
            casegrid:
                showgrid = !showgrid;
                makegrid();
                drawit();
                break;
            case '-':
            case '_':
            caseunzoom:
                if(mag > 1){
                    mag--;
                    makegrid();
                    drawit();
                }
                break;
            case '.':
            case ' ':
            caseredraw:
                drawit();
                break;
            case '1': case '2': case '3': case '4': case '5': case '6': case '7': case '8': case '9': case'0':
                mag = e.kbdc-'0';
                if(mag == 0)
                    mag = 10;
                makegrid();
                drawit();
                break;
            }
            break;
        case Emouse:
            if(e.mouse.buttons & 1){
                lastp = e.mouse.xy;
                drawit();
            }
            if(e.mouse.buttons & 4)
                switch(emenuhit(3, &e.mouse, &menu)){
                case Mzoom:
                    goto casezoom;
                case Munzoom:
                    goto caseunzoom;
                case Mgrid:
                    goto casegrid;
                case Mredraw:
                    goto caseredraw;
                case Mexit:
                    goto caseexit;
                }
            break;
        }
}
@

<<function makegrid>>=
void
makegrid(void)
{
    int m;
    if (grid != nil) {
        freeimage(grid);
        grid = nil;
    }
    if (showgrid) {
        m = mag;
        if (m < 5)
            m *= 10;
        grid = allocimage(display, Rect(0, 0, m, m),
            CHAN2(CGrey, 8, CAlpha, 8), 1, DTransparent);
        if (grid != nil){
            draw(grid, Rect(0, 0, m, 1), chequer, nil, ZP);
            draw(grid, Rect(0, 1, 1, m), chequer, nil, ZP);
        }
    }
}
@

<<function eresized (windows/apps/lens.c)>>=
void
eresized(int new)
{
    if(new && getwindow(display, Refnone) < 0){
        fprint(2, "lens: can't reattach to window: %r\n");
        exits("attach");
    }
    freeimage(tmp);
    tmp = allocimage(display, Rect(0, 0, Dx(view->r)-Edge, Dy(view->r)-Edge+Maxmag), view->chan, 0, DNofill);
    if(tmp == nil){
        fprint(2, "lens: allocimage failed: %r\n");
        exits("allocimage");
    }
    drawit();
}
@

<<function magnify>>=
void
magnify(void)
{
    int x, y, xx, yy, dd, i;
    int dx, dy;
    int xoff, yoff;
    uchar out[8192];
    uchar sp[4];

    dx = (Dx(tmp->r)+mag-1)/mag;
    dy = (Dy(tmp->r)+mag-1)/mag;
    xoff = lastp.x-Dx(tmp->r)/(mag*2);
    yoff  = lastp.y-Dy(tmp->r)/(mag*2);

    yy = yoff;
    dd = dy;
    if(yy < 0){
        dd += dy;
        yy = 0;
    }
    if(yy+dd > Dy(screenr))
        dd = Dy(screenr)-yy;
    seek(screenfd, 5*12+bypp*yy*Dx(screenr), 0);
    if(readn(screenfd, screenbuf+bypp*yy*Dx(screenr), bypp*Dx(screenr)*dd) != bypp*Dx(screenr)*dd){
        fprint(2, "lens: can't read screen: %r\n");
        return;
    }

    for(y=0; y<dy; y++){
        yy = yoff+y;
        if(yy>=0 && yy<Dy(screenr))
            for(x=0; x<dx; x++){
                xx = xoff+x;
                if(xx>=0 && xx<Dx(screenr))	/* snarf pixel at xx, yy */
                    for(i=0; i<bypp; i++)
                        sp[i] = screenbuf[bypp*(yy*Dx(screenr)+xx)+i];
                else
                    sp[0] = sp[1] = sp[2] = sp[3] = 0;

                for(xx=0; xx<mag; xx++)
                    if(x*mag+xx < tmp->r.max.x)
                        for(i=0; i<bypp; i++)
                            out[(x*mag+xx)*bypp+i] = sp[i];
            }
        else
            memset(out, 0, bypp*Dx(tmp->r));
        for(yy=0; yy<mag && y*mag+yy<Dy(tmp->r); yy++){
            werrstr("no error");
            if(loadimage(tmp, Rect(0, y*mag+yy, Dx(tmp->r), y*mag+yy+1), out, bypp*Dx(tmp->r)) != bypp*Dx(tmp->r)){
                exits("load");
            }
        }
    }
    if (showgrid && mag && grid)
        draw(tmp, tmp->r, grid, nil, mulpt(Pt(xoff, yoff), mag));
}
@


%-------------------------------------------------------------

<<windows/apps/lens.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <event.h>

<<enum _anon_ (windows/apps/lens.c)>>

<<enum _anon_ (windows/apps/lens.c)2>>

<<global menustr>>

<<global menu (windows/apps/lens.c)>>

<<global lastp>>
<<global red (windows/apps/lens.c)>>
<<global tmp (windows/apps/lens.c)>>
<<global grid>>
<<global chequer>>
<<global screenfd>>
<<global mag>>
<<global showgrid>>
<<global screenr>>
<<global screenbuf>>

void magnify(void);
void makegrid(void);

<<function drawit>>

<<global bypp>>

<<function main (windows/apps/lens.c)>>

<<function makegrid>>

<<function eresized (windows/apps/lens.c)>>

<<function magnify>>
@


\subsection*{[[windows/apps/statusbar.c]]}

<<enum _anon_ (windows/apps/statusbar.c)>>=
enum {PNCTL=3};
@

<<global nokill>>=
static int nokill;
@

<<global textmode>>=
static int textmode;
@

<<global title>>=
static char *title;
@

<<global light>>=
static Image *light;
@

<<global dark>>=
static Image *dark;
@

<<global text (windows/apps/statusbar.c)>>=
static Image *text;
@

<<function initcolor>>=
static void
initcolor(void)
{
    text = display->black;
    light = allocimagemix(display, DPalegreen, DWhite);
    dark = allocimage(display, Rect(0,0,1,1), CMAP8, 1, DDarkgreen);
}
@

<<global rbar>>=
static Rectangle rbar;
@

<<global ptext>>=
static Point ptext;
@

<<global last>>=
static int last;
@

<<global lastp (windows/apps/statusbar.c)>>=
static int lastp = -1;
@

<<global backup>>=
static char backup[80];
@

<<function drawbar>>=
void
drawbar(void)
{
    int i, j;
    int p;
    char buf[400], bar[200];
    static char lastbar[200];

    if(n > d || n < 0 || d <= 0)
        return;

    i = (Dx(rbar)*n)/d;
    p = (n*100LL)/d;

    if(textmode){
        if(Dx(rbar) > 150){
            rbar.min.x = 0;
            rbar.max.x = 150;
            return;
        }
        bar[0] = '|';
        for(j=0; j<i; j++)
            bar[j+1] = '#';
        for(; j<Dx(rbar); j++)
            bar[j+1] = '-';
        bar[j++] = '|';
        bar[j++] = ' ';
        sprint(bar+j, "%3d%% ", p);
        for(i=0; bar[i]==lastbar[i] && bar[i]; i++)
            ;
        memset(buf, '\b', strlen(lastbar)-i);
        strcpy(buf+strlen(lastbar)-i, bar+i);
        if(buf[0])
            write(1, buf, strlen(buf));
        strcpy(lastbar, bar);
        return;
    }

    if(lastp == p && last == i)
        return;

    if(lastp != p){
        sprint(buf, "%d%%", p);
        
        stringbg(view, addpt(view->r.min, Pt(Dx(rbar)-30, 4)), text, ZP, display->defaultfont, buf, light, ZP);
        lastp = p;
    }

    if(last != i){
        if(i > last)
            draw(view, Rect(rbar.min.x+last, rbar.min.y, rbar.min.x+i, rbar.max.y),
                dark, nil, ZP);
        else
            draw(view, Rect(rbar.min.x+i, rbar.min.y, rbar.min.x+last, rbar.max.y),
                light, nil, ZP);
        last = i;
    }
    flushimage(display, 1);
}
@

<<function eresized (windows/apps/statusbar.c)>>=
void
eresized(int new)
{
    Point p, q;
    Rectangle r;

    if(new && getwindow(display, Refnone) < 0)
        fprint(2,"can't reattach to window");

    r = view->r;
    draw(view, r, light, nil, ZP);
    p = string(view, addpt(r.min, Pt(4,4)), text, ZP,
        display->defaultfont, title);

    p.x = r.min.x+4;
    p.y += display->defaultfont->height+4;

    q = subpt(r.max, Pt(4,4));
    rbar = Rpt(p, q);

    ptext = Pt(r.max.x-4-stringwidth(display->defaultfont, "100%"), r.min.x+4);
    border(view, rbar, -2, dark, ZP);
    last = 0;
    lastp = -1;

    drawbar();
}
@

<<function bar>>=
void
bar(Biobuf *b)
{
    char *p, *f[2];
    Event e;
    int k, die, parent, child;

    parent = getpid();

    die = 0;
    if(textmode)
        child = -1;
    else
    switch(child = rfork(RFMEM|RFPROC)) {
    case 0:
        sleep(1000);
        while(!die && (k = eread(Ekeyboard|Emouse, &e))) {
            if(nokill==0 && k == Ekeyboard && (e.kbdc == 0x7F || e.kbdc == 0x03)) { /* del, ctl-c */
                die = 1;
                postnote(PNPROC, parent, "interrupt");
                _exits("interrupt");
            }
        }
        _exits(0);
    }

    while(!die && (p = Brdline(b, '\n'))) {
        p[Blinelen(b)-1] = '\0';
        if(tokenize(p, f, 2) != 2)
            continue;
        n = strtoll(f[0], 0, 0);
        d = strtoll(f[1], 0, 0);
        drawbar();
    }
    postnote(PNCTL, child, "kill");
}
@

<<function usage (windows/apps/statusbar.c)>>=
static void
usage(void)
{
    fprint(2, "usage: aux/statusbar [-kt] [-w minx,miny,maxx,maxy] 'title'\n");
    exits("usage");
}
@

<<function main (windows/apps/statusbar.c)>>=
void
main(int argc, char **argv)
{
    Biobuf b;
    char *p, *q;
    int lfd;

    p = "0,0,200,60";
    
    ARGBEGIN{
    case 'w':
        p = ARGF();
        break;
    case 't':
        textmode = 1;
        break;
    case 'k':
        nokill = 1;
        break;
    default:
        usage();
    }ARGEND;

    if(argc != 1)
        usage();

    title = argv[0];

    lfd = dup(0, -1);

    while(q = strchr(p, ','))
        *q = ' ';
    Binit(&b, lfd, OREAD);
    if(textmode || newwin(p) < 0){
        textmode = 1;
        rbar = Rect(0, 0, 60, 1);
    }else{
        if(initdraw(0, 0, "bar") < 0)
            exits("initdraw");
        initcolor();
        einit(Emouse|Ekeyboard);
        eresized(0);
    }
    bar(&b);

    exits(0);
}
@

<<function rdenv>>=
/* all code below this line should be in the library, but is stolen from colors instead */
static char*
rdenv(char *name)
{
    char *v;
    int fd, size;

    fd = open(name, OREAD);
    if(fd < 0)
        return 0;
    size = seek(fd, 0, 2);
    v = malloc(size+1);
    if(v == 0){
        fprint(2, "%s: can't malloc: %r\n", argv0);
        exits("no mem");
    }
    seek(fd, 0, 0);
    read(fd, v, size);
    v[size] = 0;
    close(fd);
    return v;
}
@

<<function newwin>>=
int
newwin(char *win)
{
    char *srv, *mntsrv;
    char spec[100];
    int srvfd, cons, pid;

    switch(rfork(RFFDG|RFPROC|RFNAMEG|RFENVG|RFNOTEG|RFNOWAIT)){
    case -1:
        fprint(2, "statusbar: can't fork: %r\n");
        return -1;
    case 0:
        break;
    default:
        exits(0);
    }

    srv = rdenv("/env/wsys");
    if(srv == 0){
        mntsrv = rdenv("/mnt/term/env/wsys");
        if(mntsrv == 0){
            fprint(2, "statusbar: can't find $wsys\n"); //$
            return -1;
        }
        srv = malloc(strlen(mntsrv)+10);
        sprint(srv, "/mnt/term%s", mntsrv);
        free(mntsrv);
        pid  = 0;			/* can't send notes to remote processes! */
    }else
        pid = getpid();
    USED(pid);
    srvfd = open(srv, ORDWR);
    free(srv);
    if(srvfd == -1){
        fprint(2, "statusbar: can't open %s: %r\n", srv);
        return -1;
    }
    sprint(spec, "new -r %s", win);
    if(mount(srvfd, -1, "/mnt/wsys", 0, spec) == -1){
        fprint(2, "statusbar: can't mount /mnt/wsys: %r (spec=%s)\n", spec);
        return -1;
    }
    close(srvfd);
    unmount("/mnt/acme", "/dev");
    bind("/mnt/wsys", "/dev", MBEFORE);
    cons = open("/dev/cons", OREAD);
    if(cons==-1){
    NoCons:
        fprint(2, "statusbar: can't open /dev/cons: %r");
        return -1;
    }
    dup(cons, 0);
    close(cons);
    cons = open("/dev/cons", OWRITE);
    if(cons==-1)
        goto NoCons;
    dup(cons, 1);
    dup(cons, 2);
    close(cons);
//	wctlfd = open("/dev/wctl", OWRITE);
    return 0;
}
@
%$

<<function screenrect>>=
Rectangle
screenrect(void)
{
    int fd;
    char buf[12*5];

    fd = open("/dev/screen", OREAD);
    if(fd == -1)
        fd=open("/mnt/term/dev/screen", OREAD);
    if(fd == -1){
        fprint(2, "%s: can't open /dev/screen: %r\n", argv0);
        exits("window read");
    }
    if(read(fd, buf, sizeof buf) != sizeof buf){
        fprint(2, "%s: can't read /dev/screen: %r\n", argv0);
        exits("screen read");
    }
    close(fd);
    return Rect(atoi(buf+12), atoi(buf+24), atoi(buf+36), atoi(buf+48));
}
@

<<function postnote>>=
int
postnote(int group, int pid, char *note)
{
    char file[128];
    int f, r;

    switch(group) {
    case PNPROC:
        sprint(file, "/proc/%d/note", pid);
        break;
    case PNGROUP:
        sprint(file, "/proc/%d/notepg", pid);
        break;
    case PNCTL:
        sprint(file, "/proc/%d/ctl", pid);
        break;
    default:
        return -1;
    }

    f = open(file, OWRITE);
    if(f < 0)
        return -1;

    r = strlen(note);
    if(write(f, note, r) != r) {
        close(f);
        return -1;
    }
    close(f);
    return 0;
}
@


%-------------------------------------------------------------

<<windows/apps/statusbar.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <bio.h>
#include <event.h>

<<enum _anon_ (windows/apps/statusbar.c)>>

static char* rdenv(char*);
int newwin(char*);
Rectangle screenrect(void);

<<global nokill>>
<<global textmode>>
<<global title>>

<<global light>>
<<global dark>>
<<global text (windows/apps/statusbar.c)>>

<<function initcolor>>

<<global rbar>>
<<global ptext>>
static vlong n, d;
<<global last>>
<<global lastp (windows/apps/statusbar.c)>>

<<global backup>>

<<function drawbar>>

<<function eresized (windows/apps/statusbar.c)>>

<<function bar>>


<<function usage (windows/apps/statusbar.c)>>

<<function main (windows/apps/statusbar.c)>>


<<function rdenv>>

<<function newwin>>

<<function screenrect>>

<<function postnote>>
@


\subsection*{[[windows/apps/winwatch.c]]}

<<struct Win>>=
struct Win {
    int n;
    int dirty;
    char *label;
    Rectangle r;
};
@

<<global exclude>>=
static Reprog  *exclude  = nil;
@

<<global win>>=
static Win *win;
@

<<global nwin>>=
static int nwin;
@

<<global mwin>>=
static int mwin;
@

<<global onwin>>=
static int onwin;
@

<<global lightblue>>=
static Image *lightblue;
@

<<enum _anon_ (windows/apps/winwatch.c)>>=
enum {
    PAD = 3,
    MARGIN = 5
};
@

<<function erealloc (windows/apps/winwatch.c)>>=
static void*
erealloc(void *v, ulong n)
{
    v = realloc(v, n);
    if(v == nil)
        sysfatal("out of memory reallocating %lud", n);
    return v;
}
@

<<function emalloc (windows/apps/winwatch.c)>>=
static void*
emalloc(ulong n)
{
    void *v;

    v = malloc(n);
    if(v == nil)
        sysfatal("out of memory allocating %lud", n);
    memset(v, 0, n);
    return v;
}
@

<<function estrdup (windows/apps/winwatch.c)>>=
static char*
estrdup(char *s)
{
    int l;
    char *t;

    if (s == nil)
        return nil;
    l = strlen(s)+1;
    t = emalloc(l);
    memcpy(t, s, l);

    return t;
}
@

<<function refreshwin>>=
static void
refreshwin(void)
{
    char label[128];
    int i, fd, lfd, n, nr, nw, m;
    Dir *pd;

    if((fd = open("/dev/wsys", OREAD)) < 0)
        return;

    nw = 0;
/* i'd rather read one at a time but rio won't let me */
    while((nr=dirread(fd, &pd)) > 0){
        for(i=0; i<nr; i++){
            n = atoi(pd[i].name);
            sprint(label, "/dev/wsys/%d/label", n);
            if((lfd = open(label, OREAD)) < 0)
                continue;
            m = read(lfd, label, sizeof(label)-1);
            close(lfd);
            if(m < 0)
                continue;
            label[m] = '\0';
            if(exclude != nil && regexec(exclude,label,nil,0))
                continue;

            if(nw < nwin && win[nw].n == n && strcmp(win[nw].label, label)==0){
                nw++;
                continue;
            }
    
            if(nw < nwin){
                free(win[nw].label);
                win[nw].label = nil;
            }
            
            if(nw >= mwin){
                mwin += 8;
                win = erealloc(win, mwin*sizeof(win[0]));
            }
            win[nw].n = n;
            win[nw].label = estrdup(label);
            win[nw].dirty = 1;
            win[nw].r = Rect(0,0,0,0);
            nw++;
        }
        free(pd);
    }
    while(nwin > nw)
        free(win[--nwin].label);
    nwin = nw;
    close(fd);
}
@

<<function drawnowin>>=
static void
drawnowin(int i)
{
    Rectangle r;

    r = Rect(0,0,(Dx(view->r)-2*MARGIN+PAD)/cols-PAD, font->height);
    r = rectaddpt(rectaddpt(r, Pt(MARGIN+(PAD+Dx(r))*(i/rows),
                MARGIN+(PAD+Dy(r))*(i%rows))), view->r.min);
    draw(view, insetrect(r, -1), lightblue, nil, ZP);
}
@

<<function drawwin>>=
static void
drawwin(int i)
{
    draw(view, win[i].r, lightblue, nil, ZP);
    _string(view, addpt(win[i].r.min, Pt(2,0)), display->black, ZP,
        font, win[i].label, nil, strlen(win[i].label), 
        win[i].r, nil, ZP, SoverD);
    border(view, win[i].r, 1, display->black, ZP);	
    win[i].dirty = 0;
}
@

<<function geometry>>=
static int
geometry(void)
{
    int i, ncols, z;
    Rectangle r;

    z = 0;
    rows = (Dy(view->r)-2*MARGIN+PAD)/(font->height+PAD);
    if(rows*cols < nwin || rows*cols >= nwin*2){
        ncols = nwin <= 0 ? 1 : (nwin+rows-1)/rows;
        if(ncols != cols){
            cols = ncols;
            z = 1;
        }
    }

    r = Rect(0,0,(Dx(view->r)-2*MARGIN+PAD)/cols-PAD, font->height);
    for(i=0; i<nwin; i++)
        win[i].r = rectaddpt(rectaddpt(r, Pt(MARGIN+(PAD+Dx(r))*(i/rows),
                    MARGIN+(PAD+Dy(r))*(i%rows))), view->r.min);

    return z;
}
@

<<function redraw (windows/apps/winwatch.c)>>=
static void
redraw(Image *view, int all)
{
    int i;

    all |= geometry();
    if(all)
        draw(view, view->r, lightblue, nil, ZP);
    for(i=0; i<nwin; i++)
        if(all || win[i].dirty)
            drawwin(i);
    if(!all)
        for(; i<onwin; i++)
            drawnowin(i);

    onwin = nwin;
}
@

<<function eresized (windows/apps/winwatch.c)>>=
void
eresized(int new)
{
    if(new && getwindow(display, Refmesg) < 0)
        fprint(2,"can't reattach to window");
    geometry();
    redraw(view, 1);
}
@

<<function click>>=
static void
click(Mouse m)
{
    int fd, i, j;	
    char buf[128];

    if(m.buttons == 0 || (m.buttons & ~4))
        return;

    for(i=0; i<nwin; i++)
        if(ptinrect(m.xy, win[i].r))
            break;
    if(i == nwin)
        return;

    do
        m = emouse();
    while(m.buttons == 4);

    if(m.buttons != 0){
        do
            m = emouse();
        while(m.buttons);
        return;
    }

    for(j=0; j<nwin; j++)
        if(ptinrect(m.xy, win[j].r))
            break;
    if(j != i)
        return;

    sprint(buf, "/dev/wsys/%d/wctl", win[i].n);
    if((fd = open(buf, OWRITE)) < 0)
        return;
    write(fd, "unhide\n", 7);
    write(fd, "top\n", 4);
    write(fd, "current\n", 8);
    close(fd);
}
@

<<function usage (windows/apps/winwatch.c)>>=
static void
usage(void)
{
    fprint(2, "usage: winwatch [-e exclude] [-f font]\n");
    exits("usage");
}
@

<<function main (windows/apps/winwatch.c)>>=
void
main(int argc, char **argv)
{
    char *fontname;
    int Etimer;
    Event e;

    fontname = "/lib/font/bit/lucidasans/unicode.8.font";
    ARGBEGIN{
    case 'f':
        fontname = EARGF(usage());
        break;
    case 'e':
        exclude = regcomp(EARGF(usage()));
        if(exclude == nil)
            sysfatal("Bad regexp");
        break;
    default:
        usage();
    }ARGEND

    if(argc)
        usage();

    initdraw(0, 0, "winwatch");
    lightblue = allocimagemix(display, DPalebluegreen, DWhite);
    if(lightblue == nil)
        sysfatal("allocimagemix: %r");
    if((font = openfont(display, fontname)) == nil)
        sysfatal("font '%s' not found", fontname);

    refreshwin();
    redraw(view, 1);
    einit(Emouse|Ekeyboard);
    Etimer = etimer(0, 2500);

    for(;;){
        switch(eread(Emouse|Ekeyboard|Etimer, &e)){
        case Ekeyboard:
            if(e.kbdc==0x7F || e.kbdc=='q')
                exits(0);
            break;
        case Emouse:
            if(e.mouse.buttons)
                click(e.mouse);
            /* fall through  */
        default:	/* Etimer */
            refreshwin();
            redraw(view, 0);
            break;
        }
    }
}
@


%-------------------------------------------------------------

<<windows/apps/winwatch.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <event.h>
#include <regexp.h>

typedef struct Win Win;
<<struct Win>>



<<global exclude>>
<<global win>>
<<global nwin>>
<<global mwin>>
<<global onwin>>
static int rows, cols;
<<global lightblue>>

extern Font *font;

<<enum _anon_ (windows/apps/winwatch.c)>>

<<function erealloc (windows/apps/winwatch.c)>>

<<function emalloc (windows/apps/winwatch.c)>>

<<function estrdup (windows/apps/winwatch.c)>>


<<function refreshwin>>

<<function drawnowin>>

<<function drawwin>>

<<function geometry>>

<<function redraw (windows/apps/winwatch.c)>>

<<function eresized (windows/apps/winwatch.c)>>

<<function click>>

<<function usage (windows/apps/winwatch.c)>>

<<function main (windows/apps/winwatch.c)>>
@


\section{[[windows/libcomplete/]]}

\subsection*{[[windows/libcomplete/complete.c]]}

<<function longestprefixlength>>=
static int
longestprefixlength(char *a, char *b, int n)
{
    int i, w;
    Rune ra, rb;

    for(i=0; i<n; i+=w){
        w = chartorune(&ra, a);
        chartorune(&rb, b);
        if(ra != rb)
            break;
        a += w;
        b += w;
    }
    return i;
}
@

<<function freecompletion>>=
void
freecompletion(Completion *c)
{
    if(c){
        free(c->filename);
        free(c);
    }
}
@

<<function strpcmp>>=
static int
strpcmp(const void *va, const void *vb)
{
    char *a, *b;

    a = *(char**)va;
    b = *(char**)vb;
    return strcmp(a, b);
}
@

<<function complete>>=
Completion*
complete(char *dir, char *s)
{
    long i, l, n, nfile, len, nbytes;
    int fd, minlen;
    Dir *dirp;
    char **name, *p;
    ulong* mode;
    Completion *c;

    if(strchr(s, '/') != nil){
        werrstr("slash character in name argument to complete()");
        return nil;
    }

    fd = open(dir, OREAD);
    if(fd < 0)
        return nil;

    n = dirreadall(fd, &dirp);
    if(n <= 0){
        close(fd);
        return nil;
    }

    /* find longest string, for allocation */
    len = 0;
    for(i=0; i<n; i++){
        l = strlen(dirp[i].name) + 1 + 1; /* +1 for /   +1 for \0 */
        if(l > len)
            len = l;
    }

    name = malloc(n*sizeof(char*));
    mode = malloc(n*sizeof(ulong));
    c = malloc(sizeof(Completion) + len);
    if(name == nil || mode == nil || c == nil)
        goto Return;
    memset(c, 0, sizeof(Completion));

    /* find the matches */
    len = strlen(s);
    nfile = 0;
    minlen = 1000000;
    for(i=0; i<n; i++)
        if(strncmp(s, dirp[i].name, len) == 0){
            name[nfile] = dirp[i].name;
            mode[nfile] = dirp[i].mode;
            if(minlen > strlen(dirp[i].name))
                minlen = strlen(dirp[i].name);
            nfile++;
        }

    if(nfile > 0) {
        /* report interesting results */
        /* trim length back to longest common initial string */
        for(i=1; i<nfile; i++)
            minlen = longestprefixlength(name[0], name[i], minlen);

        /* build the answer */
        c->complete = (nfile == 1);
        c->advance = c->complete || (minlen > len);
        c->string = (char*)(c+1);
        memmove(c->string, name[0]+len, minlen-len);
        if(c->complete)
            c->string[minlen++ - len] = (mode[0]&DMDIR)? '/' : ' ';
        c->string[minlen - len] = '\0';
        c->nmatch = nfile;
    } else {
        /* no match, so return all possible strings */
        for(i=0; i<n; i++){
            name[i] = dirp[i].name;
            mode[i] = dirp[i].mode;
        }
        nfile = n;
        c->nmatch = 0;
    }

    /* attach list of names */
    nbytes = nfile * sizeof(char*);
    for(i=0; i<nfile; i++)
        nbytes += strlen(name[i]) + 1 + 1;
    c->filename = malloc(nbytes);
    if(c->filename == nil)
        goto Return;
    p = (char*)(c->filename + nfile);
    for(i=0; i<nfile; i++){
        c->filename[i] = p;
        strcpy(p, name[i]);
        p += strlen(p);
        if(mode[i] & DMDIR)
            *p++ = '/';
        *p++ = '\0';
    }
    c->nfile = nfile;
    qsort(c->filename, c->nfile, sizeof(c->filename[0]), strpcmp);

  Return:
    free(name);
    free(mode);
    free(dirp);
    close(fd);
    return c;
}
@


%-------------------------------------------------------------

<<windows/libcomplete/complete.c>>=
#include <u.h>
#include <libc.h>
#include "complete.h"

<<function longestprefixlength>>

<<function freecompletion>>

<<function strpcmp>>

<<function complete>>
@


\section{[[windows/libframe/]]}

\subsection*{[[windows/libframe/frbox.c]]}

<<constant SLOP>>=
#define	SLOP	25
@

<<function _fraddbox>>=
void
_fraddbox(Frame *f, int bn, int n)	/* add n boxes after bn, shift the rest up,
                 * box[bn+n]==box[bn] */
{
    int i;

    if(bn > f->nbox)
        drawerror(f->display, "_fraddbox");
    if(f->nbox+n > f->nalloc)
        _frgrowbox(f, n+SLOP);
    for(i=f->nbox; --i>=bn; )
        f->box[i+n] = f->box[i];
    f->nbox+=n;
}
@

<<function _frclosebox>>=
void
_frclosebox(Frame *f, int n0, int n1)	/* inclusive */
{
    int i;

    if(n0>=f->nbox || n1>=f->nbox || n1<n0)
        drawerror(f->display, "_frclosebox");
    n1++;
    for(i=n1; i<f->nbox; i++)
        f->box[i-(n1-n0)] = f->box[i];
    f->nbox -= n1-n0;
}
@

<<function _frdelbox>>=
void
_frdelbox(Frame *f, int n0, int n1)	/* inclusive */
{
    if(n0>=f->nbox || n1>=f->nbox || n1<n0)
        drawerror(f->display, "_frdelbox");
    _frfreebox(f, n0, n1);
    _frclosebox(f, n0, n1);
}
@

<<function _frfreebox>>=
void
_frfreebox(Frame *f, int n0, int n1)	/* inclusive */
{
    int i;

    if(n1<n0)
        return;
    if(n0>=f->nbox || n1>=f->nbox)
        drawerror(f->display, "_frfreebox");
    n1++;
    for(i=n0; i<n1; i++)
        if(f->box[i].nrune >= 0)
            free(f->box[i].ptr);
}
@

<<function _frgrowbox>>=
void
_frgrowbox(Frame *f, int delta)
{
    f->nalloc += delta;
    f->box = realloc(f->box, f->nalloc*sizeof(Frbox));
    if(f->box == 0)
        drawerror(f->display, "_frgrowbox");
}
@

<<function dupbox>>=
static
void
dupbox(Frame *f, int bn)
{
    uchar *p;

    if(f->box[bn].nrune < 0)
        drawerror(f->display, "dupbox");
    _fraddbox(f, bn, 1);
    if(f->box[bn].nrune >= 0){
        p = _frallocstr(f, NBYTE(&f->box[bn])+1);
        strcpy((char*)p, (char*)f->box[bn].ptr);
        f->box[bn+1].ptr = p;
    }
}
@

<<function runeindex>>=
static
uchar*
runeindex(uchar *p, int n)
{
    int i, w;
    Rune rune;

    for(i=0; i<n; i++,p+=w)
        if(*p < Runeself)
            w = 1;
        else{
            w = chartorune(&rune, (char*)p);
            USED(rune);
        }
    return p;
}
@

<<function truncatebox>>=
static
void
truncatebox(Frame *f, Frbox *b, int n)	/* drop last n chars; no allocation done */
{
    if(b->nrune<0 || b->nrune<n)
        drawerror(f->display, "truncatebox");
    b->nrune -= n;
    runeindex(b->ptr, b->nrune)[0] = 0;
    b->wid = stringwidth(f->font, (char *)b->ptr);
}
@

<<function chopbox>>=
static
void
chopbox(Frame *f, Frbox *b, int n)	/* drop first n chars; no allocation done */
{
    char *p;

    if(b->nrune<0 || b->nrune<n)
        drawerror(f->display, "chopbox");
    p = (char*)runeindex(b->ptr, n);
    memmove((char*)b->ptr, p, strlen(p)+1);
    b->nrune -= n;
    b->wid = stringwidth(f->font, (char *)b->ptr);
}
@

<<function _frsplitbox>>=
void
_frsplitbox(Frame *f, int bn, int n)
{
    dupbox(f, bn);
    truncatebox(f, &f->box[bn], f->box[bn].nrune-n);
    chopbox(f, &f->box[bn+1], n);
}
@

<<function _frmergebox>>=
void
_frmergebox(Frame *f, int bn)		/* merge bn and bn+1 */
{
    Frbox *b;

    b = &f->box[bn];
    _frinsure(f, bn, NBYTE(&b[0])+NBYTE(&b[1])+1);
    strcpy((char*)runeindex(b[0].ptr, b[0].nrune), (char*)b[1].ptr);
    b[0].wid += b[1].wid;
    b[0].nrune += b[1].nrune;
    _frdelbox(f, bn+1, bn+1);
}
@

<<function _frfindbox>>=
int
_frfindbox(Frame *f, int bn, ulong p, ulong q)	/* find box containing q and put q on a box boundary */
{
    Frbox *b;

    for(b = &f->box[bn]; bn<f->nbox && p+NRUNE(b)<=q; bn++, b++)
        p += NRUNE(b);
    if(p != q)
        _frsplitbox(f, bn++, (int)(q-p));
    return bn;
}
@


%-------------------------------------------------------------

<<windows/libframe/frbox.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <thread.h>
#include <mouse.h>
#include <frame.h>

<<constant SLOP>>

<<function _fraddbox>>

<<function _frclosebox>>

<<function _frdelbox>>

<<function _frfreebox>>

<<function _frgrowbox>>

<<function dupbox>>

<<function runeindex>>

<<function truncatebox>>

<<function chopbox>>

<<function _frsplitbox>>

<<function _frmergebox>>

<<function _frfindbox>>
@


\subsection*{[[windows/libframe/frdelete.c]]}

<<function frdelete>>=
int
frdelete(Frame *f, ulong p0, ulong p1)
{
    Point pt0, pt1, ppt0;
    Frbox *b;
    int n0, n1, n;
    ulong cn1;
    Rectangle r;
    int nn0;
    Image *col;

    if(p0>=f->nchars || p0==p1 || f->b==nil)
        return 0;
    if(p1 > f->nchars)
        p1 = f->nchars;
    n0 = _frfindbox(f, 0, 0, p0);
    if(n0 == f->nbox)
        drawerror(f->display, "off end in frdelete");
    n1 = _frfindbox(f, n0, p0, p1);
    pt0 = _frptofcharnb(f, p0, n0);
    pt1 = frptofchar(f, p1);
    if(f->p0 == f->p1)
        frtick(f, frptofchar(f, f->p0), 0);
    nn0 = n0;
    ppt0 = pt0;
    _frfreebox(f, n0, n1-1);
    f->modified = 1;

    /*
     * Invariants:
     *  - pt0 points to beginning, pt1 points to end
     *  - n0 is box containing beginning of stuff being deleted
     *  - n1, b are box containing beginning of stuff to be kept after deletion
     *  - cn1 is char position of n1
     *  - f->p0 and f->p1 are not adjusted until after all deletion is done
     */
    b = &f->box[n1];
    cn1 = p1;
    while(pt1.x!=pt0.x && n1<f->nbox){
        _frcklinewrap0(f, &pt0, b);
        _frcklinewrap(f, &pt1, b);
        n = _frcanfit(f, pt0, b);
        if(n==0)
            drawerror(f->display, "_frcanfit==0");
        r.min = pt0;
        r.max = pt0;
        r.max.y += f->font->height;
        if(b->nrune > 0){
            if(n != b->nrune){
                _frsplitbox(f, n1, n);
                b = &f->box[n1];
            }
            r.max.x += b->wid;
            draw(f->b, r, f->b, nil, pt1);
            cn1 += b->nrune;
        }else{
            r.max.x += _frnewwid0(f, pt0, b);
            if(r.max.x > f->r.max.x)
                r.max.x = f->r.max.x;
            col = f->cols[BACK];
            if(f->p0<=cn1 && cn1<f->p1)
                col = f->cols[HIGH];
            draw(f->b, r, col, nil, pt0);
            cn1++;
        }
        _fradvance(f, &pt1, b);
        pt0.x += _frnewwid(f, pt0, b);
        f->box[n0++] = f->box[n1++];
        b++;
    }
    if(n1==f->nbox && pt0.x!=pt1.x)	/* deleting last thing in window; must clean up */
        frselectpaint(f, pt0, pt1, f->cols[BACK]);
    if(pt1.y != pt0.y){
        Point pt2;

        pt2 = _frptofcharptb(f, 32767, pt1, n1);
        if(pt2.y > f->r.max.y)
            drawerror(f->display, "frptofchar in frdelete");
        if(n1 < f->nbox){
            int q0, q1, q2;

            q0 = pt0.y+f->font->height;
            q1 = pt1.y+f->font->height;
            q2 = pt2.y+f->font->height;
            if(q2 > f->r.max.y)
                q2 = f->r.max.y;
            draw(f->b, Rect(pt0.x, pt0.y, pt0.x+(f->r.max.x-pt1.x), q0),
                f->b, nil, pt1);
            draw(f->b, Rect(f->r.min.x, q0, f->r.max.x, q0+(q2-q1)),
                f->b, nil, Pt(f->r.min.x, q1));
            frselectpaint(f, Pt(pt2.x, pt2.y-(pt1.y-pt0.y)), pt2, f->cols[BACK]);
        }else
            frselectpaint(f, pt0, pt2, f->cols[BACK]);
    }
    _frclosebox(f, n0, n1-1);
    if(nn0>0 && f->box[nn0-1].nrune>=0 && ppt0.x-f->box[nn0-1].wid>=(int)f->r.min.x){
        --nn0;
        ppt0.x -= f->box[nn0].wid;
    }
    _frclean(f, ppt0, nn0, n0<f->nbox-1? n0+1 : n0);
    if(f->p1 > p1)
        f->p1 -= p1-p0;
    else if(f->p1 > p0)
        f->p1 = p0;
    if(f->p0 > p1)
        f->p0 -= p1-p0;
    else if(f->p0 > p0)
        f->p0 = p0;
    f->nchars -= p1-p0;
    if(f->p0 == f->p1)
        frtick(f, frptofchar(f, f->p0), 1);
    pt0 = frptofchar(f, f->nchars);
    n = f->nlines;
    f->nlines = (pt0.y-f->r.min.y)/f->font->height+(pt0.x>f->r.min.x);
    return n - f->nlines;
}
@


%-------------------------------------------------------------

<<windows/libframe/frdelete.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <thread.h>
#include <mouse.h>
#include <frame.h>

<<function frdelete>>
@


\subsection*{[[windows/libframe/frdraw.c]]}

<<function _frdrawtext>>=
void
_frdrawtext(Frame *f, Point pt, Image *text, Image *back)
{
    Frbox *b;
    int nb;
    static int x;

    for(nb=0,b=f->box; nb<f->nbox; nb++, b++){
        _frcklinewrap(f, &pt, b);
        if(b->nrune >= 0){
            stringbg(f->b, pt, text, ZP, f->font, (char*)b->ptr, back, ZP);
        }
        pt.x += b->wid;
    }
}
@

<<function nbytes>>=
static int
nbytes(char *s0, int nr)
{
    char *s;
    Rune r;

    s = s0;
    while(--nr >= 0)
        s += chartorune(&r, s);
    return s-s0;
}
@

<<function frdrawsel>>=
void
frdrawsel(Frame *f, Point pt, ulong p0, ulong p1, int issel)
{
    Image *back, *text;

    if(f->ticked)
        frtick(f, frptofchar(f, f->p0), 0);

    if(p0 == p1){
        frtick(f, pt, issel);
        return;
    }

    if(issel){
        back = f->cols[HIGH];
        text = f->cols[HTEXT];
    }else{
        back = f->cols[BACK];
        text = f->cols[TEXT];
    }

    frdrawsel0(f, pt, p0, p1, back, text);
}
@

<<function frdrawsel0>>=
Point
frdrawsel0(Frame *f, Point pt, ulong p0, ulong p1, Image *back, Image *text)
{
    Frbox *b;
    int nb, nr, w, x, trim;
    Point qt;
    uint p;
    char *ptr;

    p = 0;
    b = f->box;
    trim = 0;
    for(nb=0; nb<f->nbox && p<p1; nb++){
        nr = b->nrune;
        if(nr < 0)
            nr = 1;
        if(p+nr <= p0)
            goto Continue;
        if(p >= p0){
            qt = pt;
            _frcklinewrap(f, &pt, b);
            /* fill in the end of a wrapped line */
            if(pt.y > qt.y)
                draw(f->b, Rect(qt.x, qt.y, f->r.max.x, pt.y), back, nil, qt);
        }
        ptr = (char*)b->ptr;
        if(p < p0){	/* beginning of region: advance into box */
            ptr += nbytes(ptr, p0-p);
            nr -= (p0-p);
            p = p0;
        }
        trim = 0;
        if(p+nr > p1){	/* end of region: trim box */
            nr -= (p+nr)-p1;
            trim = 1;
        }
        if(b->nrune<0 || nr==b->nrune)
            w = b->wid;
        else
            w = stringnwidth(f->font, ptr, nr);
        x = pt.x+w;
        if(x > f->r.max.x)
            x = f->r.max.x;
        draw(f->b, Rect(pt.x, pt.y, x, pt.y+f->font->height), back, nil, pt);
        if(b->nrune >= 0)
            stringnbg(f->b, pt, text, ZP, f->font, ptr, nr, back, ZP);
        pt.x += w;
        Continue:
        b++;
        p += nr;
    }
    /* if this is end of last plain text box on wrapped line, fill to end of line */
    if(p1>p0 &&  b>f->box && b<f->box+f->nbox && b[-1].nrune>0 && !trim){
        qt = pt;
        _frcklinewrap(f, &pt, b);
        if(pt.y > qt.y)
            draw(f->b, Rect(qt.x, qt.y, f->r.max.x, pt.y), back, nil, qt);
    }
    return pt;
}
@

<<function frredraw>>=
void
frredraw(Frame *f)
{
    int ticked;
    Point pt;

    if(f->p0 == f->p1){
        ticked = f->ticked;
        if(ticked)
            frtick(f, frptofchar(f, f->p0), 0);
        frdrawsel0(f, frptofchar(f, 0), 0, f->nchars, f->cols[BACK], f->cols[TEXT]);
        if(ticked)
            frtick(f, frptofchar(f, f->p0), 1);
        return;
    }

    pt = frptofchar(f, 0);
    pt = frdrawsel0(f, pt, 0, f->p0, f->cols[BACK], f->cols[TEXT]);
    pt = frdrawsel0(f, pt, f->p0, f->p1, f->cols[HIGH], f->cols[HTEXT]);
    pt = frdrawsel0(f, pt, f->p1, f->nchars, f->cols[BACK], f->cols[TEXT]);
}
@

<<constant FRTICKW>>=
#define	FRTICKW	3
@

<<function frtick>>=
void
frtick(Frame *f, Point pt, int ticked)
{
    Rectangle r;

    if(f->ticked==ticked || f->tick==0 || !ptinrect(pt, f->r))
        return;
    pt.x--;	/* looks best just left of where requested */
    r = Rect(pt.x, pt.y, pt.x+FRTICKW, pt.y+f->font->height);
    /* can go into left border but not right */
    if(r.max.x > f->r.max.x)
        r.max.x = f->r.max.x;
    if(ticked){
        draw(f->tickback, f->tickback->r, f->b, nil, pt);
        draw(f->b, r, f->tick, nil, ZP);
    }else
        draw(f->b, r, f->tickback, nil, ZP);
    f->ticked = ticked;
}
@

<<function _frdraw>>=
Point
_frdraw(Frame *f, Point pt)
{
    Frbox *b;
    int nb, n;

    for(b=f->box,nb=0; nb<f->nbox; nb++, b++){
        _frcklinewrap0(f, &pt, b);
        if(pt.y == f->r.max.y){
            f->nchars -= _frstrlen(f, nb);
            _frdelbox(f, nb, f->nbox-1);
            break;
        }
        if(b->nrune > 0){
            n = _frcanfit(f, pt, b);
            if(n == 0)
                drawerror(f->display, "_frcanfit==0");
            if(n != b->nrune){
                _frsplitbox(f, nb, n);
                b = &f->box[nb];
            }
            pt.x += b->wid;
        }else{
            if(b->bc == '\n'){
                pt.x = f->r.min.x;
                pt.y+=f->font->height;
            }else
                pt.x += _frnewwid(f, pt, b);
        }
    }
    return pt;
}
@

<<function _frstrlen>>=
int
_frstrlen(Frame *f, int nb)
{
    int n;

    for(n=0; nb<f->nbox; nb++)
        n += NRUNE(&f->box[nb]);
    return n;
}
@


%-------------------------------------------------------------

<<windows/libframe/frdraw.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <thread.h>
#include <mouse.h>
#include <frame.h>

<<function _frdrawtext>>

<<function nbytes>>

<<function frdrawsel>>

<<function frdrawsel0>>

<<function frredraw>>

<<function frtick>>

<<function _frdraw>>

<<function _frstrlen>>
@


\subsection*{[[windows/libframe/frinit.c]]}


<<function frinittick>>=
void
frinittick(Frame *f)
{
    Image *b;
    Font *ft;

    b = f->display->screenimage;
    ft = f->font;
    if(f->tick)
        freeimage(f->tick);
    f->tick = allocimage(f->display, Rect(0, 0, FRTICKW, ft->height), b->chan, 0, DWhite);
    if(f->tick == nil)
        return;
    if(f->tickback)
        freeimage(f->tickback);
    f->tickback = allocimage(f->display, f->tick->r, b->chan, 0, DWhite);
    if(f->tickback == 0){
        freeimage(f->tick);
        f->tick = 0;
        return;
    }
    /* background color */
    draw(f->tick, f->tick->r, f->cols[BACK], nil, ZP);
    /* vertical line */
    draw(f->tick, Rect(FRTICKW/2, 0, FRTICKW/2+1, ft->height), f->cols[TEXT], nil, ZP);
    /* box on each end */
    draw(f->tick, Rect(0, 0, FRTICKW, FRTICKW), f->cols[TEXT], nil, ZP);
    draw(f->tick, Rect(0, ft->height-FRTICKW, FRTICKW, ft->height), f->cols[TEXT], nil, ZP);
}
@

<<function frsetrects>>=
void
frsetrects(Frame *f, Rectangle r, Image *b)
{
    f->b = b;
    f->entire = r;
    f->r = r;
    f->r.max.y -= (r.max.y-r.min.y)%f->font->height;
    f->maxlines = (r.max.y-r.min.y)/f->font->height;
}
@

<<function frclear>>=
void
frclear(Frame *f, int freeall)
{
    if(f->nbox)
        _frdelbox(f, 0, f->nbox-1);
    if(f->box)
        free(f->box);
    if(freeall){
        freeimage(f->tick);
        freeimage(f->tickback);
        f->tick = 0;
        f->tickback = 0;
    }
    f->box = 0;
    f->ticked = 0;
}
@


%-------------------------------------------------------------

<<windows/libframe/frinit.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <thread.h>
#include <mouse.h>
#include <frame.h>

<<function frinit>>

<<function frinittick>>

<<function frsetrects>>

<<function frclear>>
@


\subsection*{[[windows/libframe/frinsert.c]]}

<<constant DELTA>>=
#define	DELTA	25
@

<<constant TMPSIZE>>=
#define	TMPSIZE	256
@

<<global frame>>=
static Frame		frame;
@

<<function bxscan>>=
static
Point
bxscan(Frame *f, Rune *sp, Rune *ep, Point *ppt)
{
    int w, c, nb, delta, nl, nr, rw;
    Frbox *b;
    char *s, tmp[TMPSIZE+3];	/* +3 for rune overflow */
    uchar *p;

    frame.r = f->r;
    frame.b = f->b;
    frame.font = f->font;
    frame.maxtab = f->maxtab;
    frame.nbox = 0;
    frame.nchars = 0;
    memmove(frame.cols, f->cols, sizeof frame.cols);
    delta = DELTA;
    nl = 0;
    for(nb=0; sp<ep && nl<=f->maxlines; nb++,frame.nbox++){
        if(nb == frame.nalloc){
            _frgrowbox(&frame, delta);
            if(delta < 10000)
                delta *= 2;
        }
        b = &frame.box[nb];
        c = *sp;
        if(c=='\t' || c=='\n'){
            b->bc = c;
            b->wid = 5000;
            b->minwid = (c=='\n')? 0 : stringwidth(frame.font, " ");
            b->nrune = -1;
            if(c=='\n')
                nl++;
            frame.nchars++;
            sp++;
        }else{
            s = tmp;
            nr = 0;
            w = 0;
            while(sp < ep){
                c = *sp;
                if(c=='\t' || c=='\n')
                    break;
                rw = runetochar(s, sp);
                if(s+rw >= tmp+TMPSIZE)
                    break;
                w += runestringnwidth(frame.font, sp, 1);
                sp++;
                s += rw;
                nr++;
            }
            *s++ = 0;
            p = _frallocstr(f, s-tmp);
            b = &frame.box[nb];
            b->ptr = p;
            memmove(p, tmp, s-tmp);
            b->wid = w;
            b->nrune = nr;
            frame.nchars += nr;
        }
    }
    _frcklinewrap0(f, ppt, &frame.box[0]);
    return _frdraw(&frame, *ppt);
}
@

<<function chopframe>>=
static
void
chopframe(Frame *f, Point pt, ulong p, int bn)
{
    Frbox *b;

    for(b = &f->box[bn]; ; b++){
        if(b >= &f->box[f->nbox])
            drawerror(f->display, "endofframe");
        _frcklinewrap(f, &pt, b);
        if(pt.y >= f->r.max.y)
            break;
        p += NRUNE(b);
        _fradvance(f, &pt, b);
    }
    f->nchars = p;
    f->nlines = f->maxlines;
    if(b<&f->box[f->nbox])				/* BUG */
        _frdelbox(f, (int)(b-f->box), f->nbox-1);
}
@

<<struct points_frinsert>>=
struct points_frinsert {
    Point pt0, pt1;
};
@

<<function frinsert>>=
void
frinsert(Frame *f, Rune *sp, Rune *ep, ulong p0)
{
    Point pt0, pt1, opt0, ppt0, ppt1, pt;
    Frbox *b;
    int n, n0, nn0, y;
    ulong cn0;
    Image *col;
    Rectangle r;
    static struct points_frinsert *pts;
    static int nalloc=0;
    int npts;

    if(p0>f->nchars || sp==ep || f->b==nil)
        return;
    n0 = _frfindbox(f, 0, 0, p0);
    cn0 = p0;
    nn0 = n0;
    pt0 = _frptofcharnb(f, p0, n0);
    ppt0 = pt0;
    opt0 = pt0;
    pt1 = bxscan(f, sp, ep, &ppt0);
    ppt1 = pt1;
    if(n0 < f->nbox){
        _frcklinewrap(f, &pt0, b = &f->box[n0]);	/* for frdrawsel() */
        _frcklinewrap0(f, &ppt1, b);
    }
    f->modified = 1;
    /*
     * ppt0 and ppt1 are start and end of insertion as they will appear when
     * insertion is complete. pt0 is current location of insertion position
     * (p0); pt1 is terminal point (without line wrap) of insertion.
     */
    if(f->p0 == f->p1)
        frtick(f, frptofchar(f, f->p0), 0);

    /*
     * Find point where old and new x's line up
     * Invariants:
     *	pt0 is where the next box (b, n0) is now
     *	pt1 is where it will be after the insertion
     * If pt1 goes off the rectangle, we can toss everything from there on
     */
    for(b = &f->box[n0],npts=0;
         pt1.x!=pt0.x && pt1.y!=f->r.max.y && n0<f->nbox; b++,n0++,npts++){
        _frcklinewrap(f, &pt0, b);
        _frcklinewrap0(f, &pt1, b);
        if(b->nrune > 0){
            n = _frcanfit(f, pt1, b);
            if(n == 0)
                drawerror(f->display, "_frcanfit==0");
            if(n != b->nrune){
                _frsplitbox(f, n0, n);
                b = &f->box[n0];
            }
        }
        if(npts == nalloc){
            pts = realloc(pts, (npts+DELTA)*sizeof(pts[0]));
            nalloc += DELTA;
            b = &f->box[n0];
        }
        pts[npts].pt0 = pt0;
        pts[npts].pt1 = pt1;
        /* has a text box overflowed off the frame? */
        if(pt1.y == f->r.max.y)
            break;
        _fradvance(f, &pt0, b);
        pt1.x += _frnewwid(f, pt1, b);
        cn0 += NRUNE(b);
    }
    if(pt1.y > f->r.max.y)
        drawerror(f->display, "frinsert pt1 too far");
    if(pt1.y==f->r.max.y && n0<f->nbox){
        f->nchars -= _frstrlen(f, n0);
        _frdelbox(f, n0, f->nbox-1);
    }
    if(n0 == f->nbox)
        f->nlines = (pt1.y-f->r.min.y)/f->font->height+(pt1.x>f->r.min.x);
    else if(pt1.y!=pt0.y){
        int q0, q1;

        y = f->r.max.y;
        q0 = pt0.y+f->font->height;
        q1 = pt1.y+f->font->height;
        f->nlines += (q1-q0)/f->font->height;
        if(f->nlines > f->maxlines)
            chopframe(f, ppt1, p0, nn0);
        if(pt1.y < y){
            r = f->r;
            r.min.y = q1;
            r.max.y = y;
            if(q1 < y)
                draw(f->b, r, f->b, nil, Pt(f->r.min.x, q0));
            r.min = pt1;
            r.max.x = pt1.x+(f->r.max.x-pt0.x);
            r.max.y = q1;
            draw(f->b, r, f->b, nil, pt0);
        }
    }
    /*
     * Move the old stuff down to make room.  The loop will move the stuff
     * between the insertion and the point where the x's lined up.
     * The draw()s above moved everything down after the point they lined up.
     */
    for((y=pt1.y==f->r.max.y?pt1.y:0),b = &f->box[n0-1]; --npts>=0; --b){
        pt = pts[npts].pt1;
        if(b->nrune > 0){
            r.min = pt;
            r.max = r.min;
            r.max.x += b->wid;
            r.max.y += f->font->height;
            draw(f->b, r, f->b, nil, pts[npts].pt0);
            /* clear bit hanging off right */
            if(npts==0 && pt.y>pt0.y){
                /*
                 * first new char is bigger than first char we're
                 * displacing, causing line wrap. ugly special case.
                 */
                r.min = opt0;
                r.max = opt0;
                r.max.x = f->r.max.x;
                r.max.y += f->font->height;
                if(f->p0<=cn0 && cn0<f->p1)	/* b+1 is inside selection */
                    col = f->cols[HIGH];
                else
                    col = f->cols[BACK];
                draw(f->b, r, col, nil, r.min);
            }else if(pt.y < y){
                r.min = pt;
                r.max = pt;
                r.min.x += b->wid;
                r.max.x = f->r.max.x;
                r.max.y += f->font->height;
                if(f->p0<=cn0 && cn0<f->p1)	/* b+1 is inside selection */
                    col = f->cols[HIGH];
                else
                    col = f->cols[BACK];
                draw(f->b, r, col, nil, r.min);
            }
            y = pt.y;
            cn0 -= b->nrune;
        }else{
            r.min = pt;
            r.max = pt;
            r.max.x += b->wid;
            r.max.y += f->font->height;
            if(r.max.x >= f->r.max.x)
                r.max.x = f->r.max.x;
            cn0--;
            if(f->p0<=cn0 && cn0<f->p1)	/* b is inside selection */
                col = f->cols[HIGH];
            else
                col = f->cols[BACK];
            draw(f->b, r, col, nil, r.min);
            y = 0;
            if(pt.x == f->r.min.x)
                y = pt.y;
        }
    }
    /* insertion can extend the selection, so the condition here is different */
    if(f->p0<p0 && p0<=f->p1)
        col = f->cols[HIGH];
    else
        col = f->cols[BACK];
    frselectpaint(f, ppt0, ppt1, col);
    _frdrawtext(&frame, ppt0, f->cols[TEXT], col);
    _fraddbox(f, nn0, frame.nbox);
    for(n=0; n<frame.nbox; n++)
        f->box[nn0+n] = frame.box[n];
    if(nn0>0 && f->box[nn0-1].nrune>=0 && ppt0.x-f->box[nn0-1].wid>=f->r.min.x){
        --nn0;
        ppt0.x -= f->box[nn0].wid;
    }
    n0 += frame.nbox;
    _frclean(f, ppt0, nn0, n0<f->nbox-1? n0+1 : n0);
    f->nchars += frame.nchars;
    if(f->p0 >= p0)
        f->p0 += frame.nchars;
    if(f->p0 > f->nchars)
        f->p0 = f->nchars;
    if(f->p1 >= p0)
        f->p1 += frame.nchars;
    if(f->p1 > f->nchars)
        f->p1 = f->nchars;
    if(f->p0 == f->p1)
        frtick(f, frptofchar(f, f->p0), 1);
}
@


%-------------------------------------------------------------

<<windows/libframe/frinsert.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <thread.h>
#include <mouse.h>
#include <frame.h>

<<constant DELTA>>
<<constant TMPSIZE>>
<<global frame>>

<<function bxscan>>

<<function chopframe>>

<<struct points_frinsert>>

<<function frinsert>>
@


\subsection*{[[windows/libframe/frptofchar.c]]}

<<function _frptofcharptb>>=
Point
_frptofcharptb(Frame *f, ulong p, Point pt, int bn)
{
    uchar *s;
    Frbox *b;
    int w, l;
    Rune r;

    for(b = &f->box[bn]; bn<f->nbox; bn++,b++){
        _frcklinewrap(f, &pt, b);
        if(p < (l=NRUNE(b))){
            if(b->nrune > 0)
                for(s=b->ptr; p>0; s+=w, p--){
                    if((r = *s) < Runeself)
                        w = 1;
                    else
                        w = chartorune(&r, (char*)s);
                    pt.x += stringnwidth(f->font, (char*)s, 1);
                    if(r==0 || pt.x>f->r.max.x)
                        drawerror(f->display, "frptofchar");
                }
            break;
        }
        p -= l;
        _fradvance(f, &pt, b);
    }
    return pt;
}
@

<<function frptofchar>>=
Point
frptofchar(Frame *f, ulong p)
{
    return _frptofcharptb(f, p, f->r.min, 0);
}
@

<<function _frptofcharnb>>=
Point
_frptofcharnb(Frame *f, ulong p, int nb)	/* doesn't do final _fradvance to next line */
{
    Point pt;
    int nbox;

    nbox = f->nbox;
    f->nbox = nb;
    pt = _frptofcharptb(f, p, f->r.min, 0);
    f->nbox = nbox;
    return pt;
}
@

<<function _frgrid>>=
static
Point
_frgrid(Frame *f, Point p)
{
    p.y -= f->r.min.y;
    p.y -= p.y%f->font->height;
    p.y += f->r.min.y;
    if(p.x > f->r.max.x)
        p.x = f->r.max.x;
    return p;
}
@

<<function frcharofpt>>=
ulong
frcharofpt(Frame *f, Point pt)
{
    Point qt;
    int w, bn;
    uchar *s;
    Frbox *b;
    ulong p;
    Rune r;

    pt = _frgrid(f, pt);
    qt = f->r.min;
    for(b=f->box,bn=0,p=0; bn<f->nbox && qt.y<pt.y; bn++,b++){
        _frcklinewrap(f, &qt, b);
        if(qt.y >= pt.y)
            break;
        _fradvance(f, &qt, b);
        p += NRUNE(b);
    }
    for(; bn<f->nbox && qt.x<=pt.x; bn++,b++){
        _frcklinewrap(f, &qt, b);
        if(qt.y > pt.y)
            break;
        if(qt.x+b->wid > pt.x){
            if(b->nrune < 0)
                _fradvance(f, &qt, b);
            else{
                s = b->ptr;
                for(;;){
                    if((r = *s) < Runeself)
                        w = 1;
                    else
                        w = chartorune(&r, (char*)s);
                    if(r == 0)
                        drawerror(f->display, "end of string in frcharofpt");
                    qt.x += stringnwidth(f->font, (char*)s, 1);
                    s += w;
                    if(qt.x > pt.x)
                        break;
                    p++;
                }
            }
        }else{
            p += NRUNE(b);
            _fradvance(f, &qt, b);
        }
    }
    return p;
}
@


%-------------------------------------------------------------

<<windows/libframe/frptofchar.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <thread.h>
#include <mouse.h>
#include <frame.h>

<<function _frptofcharptb>>

<<function frptofchar>>

<<function _frptofcharnb>>

<<function _frgrid>>

<<function frcharofpt>>
@


\subsection*{[[windows/libframe/frselect.c]]}

<<function region>>=
static
int
region(int a, int b)
{
    if(a < b)
        return -1;
    if(a == b)
        return 0;
    return 1;
}
@

<<function frselect>>=
void
frselect(Frame *f, Mousectl *mc)	/* when called, button 1 is down */
{
    ulong p0, p1, q;
    Point mp, pt0, pt1, qt;
    int reg, b, scrled;

    mp = mc->xy;
    b = mc->buttons;

    f->modified = 0;
    frdrawsel(f, frptofchar(f, f->p0), f->p0, f->p1, 0);
    p0 = p1 = frcharofpt(f, mp);
    f->p0 = p0;
    f->p1 = p1;
    pt0 = frptofchar(f, p0);
    pt1 = frptofchar(f, p1);
    frdrawsel(f, pt0, p0, p1, 1);
    reg = 0;
    do{
        scrled = 0;
        if(f->scroll){
            if(mp.y < f->r.min.y){
                (*f->scroll)(f, -(f->r.min.y-mp.y)/(int)f->font->height-1);
                p0 = f->p1;
                p1 = f->p0;
                scrled = 1;
            }else if(mp.y > f->r.max.y){
                (*f->scroll)(f, (mp.y-f->r.max.y)/(int)f->font->height+1);
                p0 = f->p0;
                p1 = f->p1;
                scrled = 1;
            }
            if(scrled){
                if(reg != region(p1, p0))
                    q = p0, p0 = p1, p1 = q;	/* undo the swap that will happen below */
                pt0 = frptofchar(f, p0);
                pt1 = frptofchar(f, p1);
                reg = region(p1, p0);
            }
        }
        q = frcharofpt(f, mp);
        if(p1 != q){
            if(reg != region(q, p0)){	/* crossed starting point; reset */
                if(reg > 0)
                    frdrawsel(f, pt0, p0, p1, 0);
                else if(reg < 0)
                    frdrawsel(f, pt1, p1, p0, 0);
                p1 = p0;
                pt1 = pt0;
                reg = region(q, p0);
                if(reg == 0)
                    frdrawsel(f, pt0, p0, p1, 1);
            }
            qt = frptofchar(f, q);
            if(reg > 0){
                if(q > p1)
                    frdrawsel(f, pt1, p1, q, 1);
                else if(q < p1)
                    frdrawsel(f, qt, q, p1, 0);
            }else if(reg < 0){
                if(q > p1)
                    frdrawsel(f, pt1, p1, q, 0);
                else
                    frdrawsel(f, qt, q, p1, 1);
            }
            p1 = q;
            pt1 = qt;
        }
        f->modified = 0;
        if(p0 < p1) {
            f->p0 = p0;
            f->p1 = p1;
        }
        else {
            f->p0 = p1;
            f->p1 = p0;
        }
        if(scrled)
            (*f->scroll)(f, 0);
        flushimage(f->display, 1);
        if(!scrled)
            readmouse(mc);
        mp = mc->xy;
    }while(mc->buttons == b);
}
@

<<function frselectpaint>>=
void
frselectpaint(Frame *f, Point p0, Point p1, Image *col)
{
    int n;
    Point q0, q1;

    q0 = p0;
    q1 = p1;
    q0.y += f->font->height;
    q1.y += f->font->height;
    n = (p1.y-p0.y)/f->font->height;
    if(f->b == nil)
        drawerror(f->display, "frselectpaint b==0");
    if(p0.y == f->r.max.y)
        return;
    if(n == 0)
        draw(f->b, Rpt(p0, q1), col, nil, ZP);
    else{
        if(p0.x >= f->r.max.x)
            p0.x = f->r.max.x-1;
        draw(f->b, Rect(p0.x, p0.y, f->r.max.x, q0.y), col, nil, ZP);
        if(n > 1)
            draw(f->b, Rect(f->r.min.x, q0.y, f->r.max.x, p1.y),
                col, nil, ZP);
        draw(f->b, Rect(f->r.min.x, p1.y, q1.x, q1.y),
            col, nil, ZP);
    }
}
@


%-------------------------------------------------------------

<<windows/libframe/frselect.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <thread.h>
#include <mouse.h>
#include <frame.h>

<<function region>>

<<function frselect>>

<<function frselectpaint>>
@


\subsection*{[[windows/libframe/frstr.c]]}

<<constant CHUNK (windows/libframe/frstr.c)>>=
#define	CHUNK	16
@

<<function ROUNDUP>>=
#define	ROUNDUP(n)	((n+CHUNK)&~(CHUNK-1))
@

<<function _frallocstr>>=
uchar *
_frallocstr(Frame *f, unsigned n)
{
    uchar *p;

    p = malloc(ROUNDUP(n));
    if(p == 0)
        drawerror(f->display, "out of memory");
    return p;
}
@

<<function _frinsure>>=
void
_frinsure(Frame *f, int bn, unsigned n)
{
    Frbox *b;
    uchar *p;

    b = &f->box[bn];
    if(b->nrune < 0)
        drawerror(f->display, "_frinsure");
    if(ROUNDUP(b->nrune) > n)	/* > guarantees room for terminal NUL */
        return;
    p = _frallocstr(f, n);
    b = &f->box[bn];
    memmove(p, b->ptr, NBYTE(b)+1);
    free(b->ptr);
    b->ptr = p;
}
@


%-------------------------------------------------------------

<<windows/libframe/frstr.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <thread.h>
#include <mouse.h>
#include <frame.h>

<<constant CHUNK (windows/libframe/frstr.c)>>
<<function ROUNDUP>>

<<function _frallocstr>>

<<function _frinsure>>
@


\subsection*{[[windows/libframe/frutil.c]]}

<<function _frcanfit>>=
int
_frcanfit(Frame *f, Point pt, Frbox *b)
{
    int left, w, nr;
    uchar *p;
    Rune r;

    left = f->r.max.x-pt.x;
    if(b->nrune < 0)
        return b->minwid <= left;
    if(left >= b->wid)
        return b->nrune;
    for(nr=0,p=b->ptr; *p; p+=w,nr++){
        r = *p;
        if(r < Runeself)
            w = 1;
        else
            w = chartorune(&r, (char*)p);
        left -= stringnwidth(f->font, (char*)p, 1);
        if(left < 0)
            return nr;
    }
    drawerror(f->display, "_frcanfit can't");
    return 0;
}
@

<<function _frcklinewrap>>=
void
_frcklinewrap(Frame *f, Point *p, Frbox *b)
{
    if((b->nrune<0? b->minwid : b->wid) > f->r.max.x-p->x){
        p->x = f->r.min.x;
        p->y += f->font->height;
    }
}
@

<<function _frcklinewrap0>>=
void
_frcklinewrap0(Frame *f, Point *p, Frbox *b)
{
    if(_frcanfit(f, *p, b) == 0){
        p->x = f->r.min.x;
        p->y += f->font->height;
    }
}
@

<<function _fradvance>>=
void
_fradvance(Frame *f, Point *p, Frbox *b)
{
    if(b->nrune<0 && b->bc=='\n'){
        p->x = f->r.min.x;
        p->y += f->font->height;
    }else
        p->x += b->wid;
}
@

<<function _frnewwid>>=
int
_frnewwid(Frame *f, Point pt, Frbox *b)
{
    b->wid = _frnewwid0(f, pt, b);
    return b->wid;
}
@

<<function _frnewwid0>>=
int
_frnewwid0(Frame *f, Point pt, Frbox *b)
{
    int c, x;

    c = f->r.max.x;
    x = pt.x;
    if(b->nrune>=0 || b->bc!='\t')
        return b->wid;
    if(x+b->minwid > c)
        x = pt.x = f->r.min.x;
    x += f->maxtab;
    x -= (x-f->r.min.x)%f->maxtab;
    if(x-pt.x<b->minwid || x>c)
        x = pt.x+b->minwid;
    return x-pt.x;
}
@

<<function _frclean>>=
void
_frclean(Frame *f, Point pt, int n0, int n1)	/* look for mergeable boxes */
{
    Frbox *b;
    int nb, c;

    c = f->r.max.x;
    for(nb=n0; nb<n1-1; nb++){
        b = &f->box[nb];
        _frcklinewrap(f, &pt, b);
        while(b[0].nrune>=0 && nb<n1-1 && b[1].nrune>=0 && pt.x+b[0].wid+b[1].wid<c){
            _frmergebox(f, nb);
            n1--;
            b = &f->box[nb];
        }
        _fradvance(f, &pt, &f->box[nb]);
    }
    for(; nb<f->nbox; nb++){
        b = &f->box[nb];
        _frcklinewrap(f, &pt, b);
        _fradvance(f, &pt, &f->box[nb]);
    }
    f->lastlinefull = 0;
    if(pt.y >= f->r.max.y)
        f->lastlinefull = 1;
}
@


%-------------------------------------------------------------

<<windows/libframe/frutil.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <thread.h>
#include <mouse.h>
#include <frame.h>

<<function _frcanfit>>

<<function _frcklinewrap>>

<<function _frcklinewrap0>>

<<function _fradvance>>

<<function _frnewwid>>

<<function _frnewwid0>>

<<function _frclean>>
@








\section{[[windows/libplumb/]]}

\subsection*{[[windows/libplumb/event.c]]}

<<struct EQueue>>=
struct EQueue
{
    int		id;
    char		*buf;
    int		nbuf;
    EQueue	*next;
};
@

<<global equeue>>=
static	EQueue	*equeue;
@

<<global eqlock>>=
static	Lock		eqlock;
@

<<function partial>>=
static
int
partial(int id, Event *e, uchar *b, int n)
{
    EQueue *eq, *p;
    int nmore;

    lock(&eqlock);
    for(eq = equeue; eq != nil; eq = eq->next)
        if(eq->id == id)
            break;
    unlock(&eqlock);
    if(eq == nil)
        return 0;
    /* partial message exists for this id */
    eq->buf = realloc(eq->buf, eq->nbuf+n);
    if(eq->buf == nil)
        drawerror(display, "eplumb: cannot allocate buffer");
    memmove(eq->buf+eq->nbuf, b, n);
    eq->nbuf += n;
    e->v = plumbunpackpartial((char*)eq->buf, eq->nbuf, &nmore);
    if(nmore == 0){	/* no more to read in this message */
        lock(&eqlock);
        if(eq == equeue)
            equeue = eq->next;
        else{
            for(p = equeue; p!=nil && p->next!=eq; p = p->next)
                ;
            if(p == nil)
                drawerror(display, "eplumb: bad event queue");
            p->next = eq->next;
        }
        unlock(&eqlock);
        free(eq->buf);
        free(eq);
    }
    return 1;
}
@

<<function addpartial>>=
static
void
addpartial(int id, char *b, int n)
{
    EQueue *eq;

    eq = malloc(sizeof(EQueue));
    if(eq == nil)
        return;
    eq->id = id;
    eq->nbuf = n;
    eq->buf = malloc(n);
    if(eq->buf == nil){
        free(eq);
        return;
    }
    memmove(eq->buf, b, n);
    lock(&eqlock);
    eq->next = equeue;
    equeue = eq;
    unlock(&eqlock);
}
@

<<function plumbevent>>=
static
int
plumbevent(int id, Event *e, uchar *b, int n)
{
    int nmore;

    if(partial(id, e, b, n) == 0){
        /* no partial message already waiting for this id */
        e->v = plumbunpackpartial((char*)b, n, &nmore);
        if(nmore > 0)	/* incomplete message */
            addpartial(id, (char*)b, n);
    }
    if(e->v == nil)
        return 0;
    return id;
}
@

<<function eplumb>>=
int
eplumb(int key, char *port)
{
    int fd;

    fd = plumbopen(port, OREAD|OCEXEC);
    if(fd < 0)
        return -1;
    return estartfn(key, fd, 8192, plumbevent);
}
@


%-------------------------------------------------------------

<<windows/libplumb/event.c>>=
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <event.h>
#include "plumb.h"

typedef struct EQueue EQueue;

<<struct EQueue>>

<<global equeue>>
<<global eqlock>>

<<function partial>>

<<function addpartial>>

<<function plumbevent>>

<<function eplumb>>
@


\subsection*{[[windows/libplumb/mesg.c]]}

<<function plumbopen>>=
int
plumbopen(char *name, int omode)
{
    int fd, f;
    char *s, *plumber;
    char buf[128], err[ERRMAX];

    if(name[0] == '/')
        return open(name, omode);
        
    /* find elusive plumber */
    if(access("/mnt/plumb/send", AWRITE) >= 0)
        plumber = "/mnt/plumb";
    else if(access("/mnt/term/mnt/plumb/send", AWRITE) >= 0)
        plumber = "/mnt/term/mnt/plumb";
    else{
        /* last resort: try mounting service */
        plumber = "/mnt/plumb";
        s = getenv("plumbsrv");
        if(s == nil)
            return -1;
        f = open(s, ORDWR);
        free(s);
        if(f < 0)
            return -1;
        if(mount(f, -1, "/mnt/plumb", MREPL, "") < 0){
            close(f);
            return -1;
        }
        if(access("/mnt/plumb/send", AWRITE) < 0)
            return -1;
    }

    snprint(buf, sizeof buf, "%s/%s", plumber, name);
    fd = open(buf, omode);
    if(fd >= 0)
        return fd;

    /* try creating port; used by non-standard plumb implementations */
    rerrstr(err, sizeof err);
    fd = create(buf, omode, 0600);
    if(fd >= 0)
        return fd;
    errstr(err, sizeof err);

    return -1;
}
@

<<function Strlen>>=
static int
Strlen(char *s)
{
    if(s == nil)
        return 0;
    return strlen(s);
}
@

<<function Strcpy>>=
static char*
Strcpy(char *s, char *t)
{
    if(t == nil)
        return s;
    return strcpy(s, t) + strlen(t);
}
@

<<function quote>>=
/* quote attribute value, if necessary */
static char*
quote(char *s, char *buf, char *bufe)
{
    char *t;
    int c;

    if(s == nil){
        buf[0] = '\0';
        return buf;
    }
    if(strpbrk(s, " '=\t") == nil)
        return s;
    t = buf;
    *t++ = '\'';
    while(t < bufe-2){
        c = *s++;
        if(c == '\0')
            break;
        *t++ = c;
        if(c == '\'')
            *t++ = c;
    }
    *t++ = '\'';
    *t = '\0';
    return buf;
}
@

<<function plumbpackattr>>=
char*
plumbpackattr(Plumbattr *attr)
{
    int n;
    Plumbattr *a;
    char *s, *t, *buf, *bufe;

    if(attr == nil)
        return nil;
    if((buf = malloc(4096)) == nil)
        return nil;
    bufe = buf + 4096;
    n = 0;
    for(a=attr; a!=nil; a=a->next)
        n += Strlen(a->name) + 1 + Strlen(quote(a->value, buf, bufe)) + 1;
    s = malloc(n);
    if(s == nil) {
        free(buf);
        return nil;
    }
    t = s;
    *t = '\0';
    for(a=attr; a!=nil; a=a->next){
        if(t != s)
            *t++ = ' ';
        strcpy(t, a->name);
        strcat(t, "=");
        strcat(t, quote(a->value, buf, bufe));
        t += strlen(t);
    }
    if(t > s+n)
        abort();
    free(buf);
    return s;
}
@

<<function plumblookup>>=
char*
plumblookup(Plumbattr *attr, char *name)
{
    while(attr){
        if(strcmp(attr->name, name) == 0)
            return attr->value;
        attr = attr->next;
    }
    return nil;
}
@

<<function plumbpack>>=
char*
plumbpack(Plumbmsg *m, int *np)
{
    int n, ndata;
    char *buf, *p, *attr;

    ndata = m->ndata;
    if(ndata < 0)
        ndata = Strlen(m->data);
    attr = plumbpackattr(m->attr);
    n = Strlen(m->src)+1 + Strlen(m->dst)+1 + Strlen(m->wdir)+1 +
        Strlen(m->type)+1 + Strlen(attr)+1 + 16 + ndata;
    buf = malloc(n+1);	/* +1 for '\0' */
    if(buf == nil){
        free(attr);
        return nil;
    }
    p = Strcpy(buf, m->src);
    *p++ = '\n';
    p = Strcpy(p, m->dst);
    *p++ = '\n';
    p = Strcpy(p, m->wdir);
    *p++ = '\n';
    p = Strcpy(p, m->type);
    *p++ = '\n';
    p = Strcpy(p, attr);
    *p++ = '\n';
    p += sprint(p, "%d\n", ndata);
    memmove(p, m->data, ndata);
    *np = (p-buf)+ndata;
    buf[*np] = '\0';	/* null terminate just in case */
    if(*np >= n+1)
        abort();
    free(attr);
    return buf;
}
@

<<function plumbsend>>=
int
plumbsend(int fd, Plumbmsg *m)
{
    char *buf;
    int n;

    buf = plumbpack(m, &n);
    if(buf == nil)
        return -1;
    n = write(fd, buf, n);
    free(buf);
    return n;
}
@

<<function plumbline>>=
static int
plumbline(char **linep, char *buf, int i, int n, int *bad)
{
    int starti;
    char *p;

    starti = i;
    while(i<n && buf[i]!='\n')
        i++;
    if(i == n)
        *bad = 1;
    else{
        p = malloc((i-starti) + 1);
        if(p == nil)
            *bad = 1;
        else{
            memmove(p, buf+starti, i-starti);
            p[i-starti] = '\0';
        }
        *linep = p;
        i++;
    }
    return i;
}
@

<<function plumbfree>>=
void
plumbfree(Plumbmsg *m)
{
    Plumbattr *a, *next;

    free(m->src);
    free(m->dst);
    free(m->wdir);
    free(m->type);
    for(a=m->attr; a!=nil; a=next){
        next = a->next;
        free(a->name);
        free(a->value);
        free(a);
    }
    free(m->data);
    free(m);
}
@

<<function plumbunpackattr>>=
Plumbattr*
plumbunpackattr(char *p)
{
    Plumbattr *attr, *prev, *a;
    char *q, *v, *buf, *bufe;
    int c, quoting;

    buf = malloc(4096);
    if(buf == nil)
        return nil;
    bufe = buf + 4096;
    attr = prev = nil;
    while(*p!='\0' && *p!='\n'){
        while(*p==' ' || *p=='\t')
            p++;
        if(*p == '\0')
            break;
        for(q=p; *q!='\0' && *q!='\n' && *q!=' ' && *q!='\t'; q++)
            if(*q == '=')
                break;
        if(*q != '=')
            break;	/* malformed attribute */
        a = malloc(sizeof(Plumbattr));
        if(a == nil)
            break;
        a->name = malloc(q-p+1);
        if(a->name == nil){
            free(a);
            break;
        }
        memmove(a->name, p, q-p);
        a->name[q-p] = '\0';
        /* process quotes in value */
        q++;	/* skip '=' */
        v = buf;
        quoting = 0;
        while(*q!='\0' && *q!='\n'){
            if(v >= bufe)
                break;
            c = *q++;
            if(quoting){
                if(c == '\''){
                    if(*q == '\'')
                        q++;
                    else{
                        quoting = 0;
                        continue;
                    }
                }
            }else{
                if(c==' ' || c=='\t')
                    break;
                if(c == '\''){
                    quoting = 1;
                    continue;
                }
            }
            *v++ = c;
        }
        a->value = malloc(v-buf+1);
        if(a->value == nil){
            free(a->name);
            free(a);
            break;
        }
        memmove(a->value, buf, v-buf);
        a->value[v-buf] = '\0';
        a->next = nil;
        if(prev == nil)
            attr = a;
        else
            prev->next = a;
        prev = a;
        p = q;
    }
    free(buf);
    return attr;
}
@

<<function plumbaddattr>>=
Plumbattr*
plumbaddattr(Plumbattr *attr, Plumbattr *new)
{
    Plumbattr *l;

    l = attr;
    if(l == nil)
        return new;
    while(l->next != nil)
        l = l->next;
    l->next = new;
    return attr;
}
@

<<function plumbdelattr>>=
Plumbattr*
plumbdelattr(Plumbattr *attr, char *name)
{
    Plumbattr *l, *prev;

    prev = nil;
    for(l=attr; l!=nil; l=l->next){
        if(strcmp(name, l->name) == 0)
            break;
        prev = l;
    }
    if(l == nil)
        return nil;
    if(prev)
        prev->next = l->next;
    else
        attr = l->next;
    free(l->name);
    free(l->value);
    free(l);
    return attr;
}
@

<<function plumbunpackpartial>>=
Plumbmsg*
plumbunpackpartial(char *buf, int n, int *morep)
{
    Plumbmsg *m;
    int i, bad;
    char *ntext, *attr;

    m = malloc(sizeof(Plumbmsg));
    if(m == nil)
        return nil;
    memset(m, 0, sizeof(Plumbmsg));
    if(morep != nil)
        *morep = 0;
    bad = 0;
    i = plumbline(&m->src, buf, 0, n, &bad);
    i = plumbline(&m->dst, buf, i, n, &bad);
    i = plumbline(&m->wdir, buf, i, n, &bad);
    i = plumbline(&m->type, buf, i, n, &bad);
    i = plumbline(&attr, buf, i, n, &bad);
    i = plumbline(&ntext, buf, i, n, &bad);
    if(bad){
        plumbfree(m);
        return nil;
    }
    m->attr = plumbunpackattr(attr);
    free(attr);
    m->ndata = atoi(ntext);
    if(m->ndata != n-i){
        bad = 1;
        if(morep!=nil && m->ndata>n-i)
            *morep = m->ndata - (n-i);
    }
    free(ntext);
    if(!bad){
        m->data = malloc(n-i+1);	/* +1 for '\0' */
        if(m->data == nil)
            bad = 1;
        else{
            memmove(m->data, buf+i, m->ndata);
            m->ndata = n-i;
            /* null-terminate in case it's text */
            m->data[m->ndata] = '\0';
        }
    }
    if(bad){
        plumbfree(m);
        m = nil;
    }
    return m;
}
@

<<function plumbunpack>>=
Plumbmsg*
plumbunpack(char *buf, int n)
{
    return plumbunpackpartial(buf, n, nil);
}
@

<<function plumbrecv>>=
Plumbmsg*
plumbrecv(int fd)
{
    char *buf;
    Plumbmsg *m;
    int n, more;

    buf = malloc(8192);
    if(buf == nil)
        return nil;
    n = read(fd, buf, 8192);
    m = nil;
    if(n > 0){
        m = plumbunpackpartial(buf, n, &more);
        if(m==nil && more>0){
            /* we now know how many more bytes to read for complete message */
            buf = realloc(buf, n+more);
            if(buf == nil)
                return nil;
            if(readn(fd, buf+n, more) == more)
                m = plumbunpackpartial(buf, n+more, nil);
        }
    }
    free(buf);
    return m;
}
@


%-------------------------------------------------------------

<<windows/libplumb/mesg.c>>=
#include <u.h>
#include <libc.h>
#include "plumb.h"

<<function plumbopen>>

<<function Strlen>>

<<function Strcpy>>

<<function quote>>

<<function plumbpackattr>>

<<function plumblookup>>

<<function plumbpack>>

<<function plumbsend>>

<<function plumbline>>

<<function plumbfree>>

<<function plumbunpackattr>>

<<function plumbaddattr>>

<<function plumbdelattr>>

<<function plumbunpackpartial>>

<<function plumbunpack>>

<<function plumbrecv>>
@


\subsection*{[[windows/libplumb/plumbsendtext.c]]}

<<function plumbsendtext>>=
int
plumbsendtext(int fd, char *src, char *dst, char *wdir, char *data)
{
    Plumbmsg m;

    m.src = src;
    m.dst = dst;
    m.wdir = wdir;
    m.type = "text";
    m.attr = nil;
    m.ndata = strlen(data);
    m.data = data;
    return plumbsend(fd, &m);
}
@


%-------------------------------------------------------------

<<windows/libplumb/plumbsendtext.c>>=
#include <u.h>
#include <libc.h>
#include "plumb.h"

<<function plumbsendtext>>
@


