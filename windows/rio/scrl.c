/*s: windows/rio/scrl.c */
#include <u.h>
#include <libc.h>
#include <draw.h>
#include <thread.h>
#include <cursor.h>
#include <mouse.h>
#include <keyboard.h>
#include <frame.h>
#include <fcall.h>

#include "dat.h"
#include "fns.h"

/*s: global [[scrtmp]] */
static Image *scrtmp;
/*e: global [[scrtmp]] */

/*s: function [[scrtemps]] */
static
void
scrtemps(void)
{
    int h;

    if(scrtmp)
        return;
    h = BIG * Dy(view->r);
    scrtmp = allocimage(display, Rect(0, 0, 32, h), view->chan, false, DWhite);
    /*s: [[scrtemps()]] sanity check scrtmp */
    if(scrtmp == nil)
        error("scrtemps");
    /*e: [[scrtemps()]] sanity check scrtmp */
}
/*e: function [[scrtemps]] */

/*s: function [[freescrtemps]] */
void
freescrtemps(void)
{
    freeimage(scrtmp);
    scrtmp = nil;
}
/*e: function [[freescrtemps]] */

/*s: function [[scrpos]] */
static
Rectangle
scrpos(Rectangle r, uint p0, uint p1, uint tot)
{
    Rectangle q;
    int h;

    q = r;
    h = q.max.y - q.min.y; // Dy(r)
    if(tot == 0)
        return q;
    /*s: [[scrpos()]] adjust integers if total is big */
    if(tot > 1024*1024){
        tot>>=10;
        p0>>=10;
        p1>>=10;
    }
    /*e: [[scrpos()]] adjust integers if total is big */
    if(p0 > 0)
        q.min.y += h*p0 / tot;
    if(p1 < tot)
        q.max.y -= h*(tot-p1) / tot;

    /*s: [[scrpos()]] last adjustments */
    if(q.max.y < q.min.y+2){
        if(q.min.y+2 <= r.max.y)
            q.max.y = q.min.y+2;
        else
            q.min.y = q.max.y-2;
    }
    /*e: [[scrpos()]] last adjustments */
    return q;
}
/*e: function [[scrpos]] */

/*s: function [[wscrdraw]] */
void
wscrdraw(Window *w)
{
    Rectangle r, r1, r2;
    Image *b;

    scrtemps();
    /*s: [[wscrdraw()]] sanity check the window image */
    if(w->i == nil)
        error("scrdraw");
    /*e: [[wscrdraw()]] sanity check the window image */
    r = w->scrollr;
    b = scrtmp;
    // r1 is translation of r to (0,...)
    r1 = r;
    r1.min.x = 0;
    r1.max.x = Dx(r);
    r2 = scrpos(r1, w->org, w->org + w->frm.nchars, w->nr);
    if(!eqrect(r2, w->lastsr)){
        w->lastsr = r2;
        /* move r1, r2 to (0,0) to avoid clipping */
        r2 = rectsubpt(r2, r1.min);
        r1 = rectsubpt(r1, r1.min);
        draw(b, r1, w->frm.cols[BORD], nil, ZP);
        draw(b, r2, w->frm.cols[BACK], nil, ZP);
        // little separation line
        r2.min.x = r2.max.x-1;
        draw(b, r2, w->frm.cols[BORD], nil, ZP);

        // transfer back to main image
        draw(w->i, r, b, nil, Pt(0, r1.min.y));
    }
}
/*e: function [[wscrdraw]] */

/*s: function [[wscrsleep]] */
void
wscrsleep(Window *w, uint dt)
{
    Timer	*timer;
    int y, b;
    static Alt alts[3];

    timer = timerstart(dt);
    y = w->mc.xy.y;
    b = w->mc.buttons;
    alts[0].c = timer->c;
    alts[0].v = nil;
    alts[0].op = CHANRCV;
    alts[1].c = w->mc.c;
    alts[1].v = &w->mc.Mouse;
    alts[1].op = CHANRCV;
    alts[2].op = CHANEND;
    for(;;)
        switch(alt(alts)){
        case 0:
            timerstop(timer);
            return;
        case 1:
            if(abs(w->mc.xy.y-y)>2 || w->mc.buttons!=b){
                timercancel(timer);
                return;
            }
            break;
        }
}
/*e: function [[wscrsleep]] */

/*s: function [[wscroll]] */
void
wscroll(Window *w, int but)
{
    uint p0, oldp0;
    Rectangle s;
    int x, y, my, h, first;

    s = insetrect(w->scrollr, 1);
    h = s.max.y-s.min.y;
    x = (s.min.x+s.max.x)/2;
    oldp0 = ~0;
    first = true;
    do{
        flushimage(display, 1);
        if(w->mc.xy.x<s.min.x || s.max.x<=w->mc.xy.x){
            readmouse(&w->mc);
        }else{
            my = w->mc.xy.y;
            if(my < s.min.y)
                my = s.min.y;
            if(my >= s.max.y)
                my = s.max.y;
            if(!eqpt(w->mc.xy, Pt(x, my))){
                wmovemouse(w, Pt(x, my));
                readmouse(&w->mc);		/* absorb event generated by moveto() */
            }
            if(but == 2){
                y = my;
                if(y > s.max.y-2)
                    y = s.max.y-2;
                if(w->nr > 1024*1024)
                    p0 = ((w->nr>>10)*(y-s.min.y)/h)<<10; // >>
                else
                    p0 = w->nr*(y-s.min.y)/h;
                if(oldp0 != p0)
                    wsetorigin(w, p0, false);
                oldp0 = p0;
                readmouse(&w->mc);
                continue;
            }
            if(but == 1)
                p0 = wbacknl(w, w->org, (my-s.min.y)/w->frm.font->height);
            else
                p0 = w->org + frcharofpt(&w->frm, Pt(s.max.x, my));
            if(oldp0 != p0)
                wsetorigin(w, p0, true);
            oldp0 = p0;
            /* debounce */
            if(first){
                flushimage(display, 1);
                sleep(200);
                nbrecv(w->mc.c, &w->mc.Mouse);
                first = false;
            }
            wscrsleep(w, 100);
        }
    }while(w->mc.buttons & (1<<(but-1))); // >>
    while(w->mc.buttons)
        readmouse(&w->mc);
}
/*e: function [[wscroll]] */
/*e: windows/rio/scrl.c */
