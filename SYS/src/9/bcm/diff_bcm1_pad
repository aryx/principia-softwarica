diff -u -p -b -B -r -x .semantic.cache -x .depend -x CVS -x .hg -x .svn -x .git -x _darcs ./arch.c /home/pad/work/plan9-github/sys/src/9/bcm/arch.c
--- ./arch.c	2017-01-16 19:37:03.000000000 -0800
+++ /home/pad/work/plan9-github/sys/src/9/bcm/arch.c	2015-01-09 12:17:46.000000000 -0800
@@ -1,240 +1 @@
-#include "u.h"
-#include "../port/lib.h"
-#include "mem.h"
-#include "dat.h"
-#include "fns.h"
-#include "../port/error.h"
-
-#include <tos.h>
-#include "ureg.h"
-
-#include "arm.h"
-
-/*
- * A lot of this stuff doesn't belong here
- * but this is a convenient dumping ground for
- * later sorting into the appropriate buckets.
- */
-
-/* Give enough context in the ureg to produce a kernel stack for
- * a sleeping process
- */
-void
-setkernur(Ureg* ureg, Proc* p)
-{
-	ureg->pc = p->sched.pc;
-	ureg->sp = p->sched.sp+4;
-	ureg->r14 = PTR2UINT(sched);
-}
-
-/*
- * called in syscallfmt.c, sysfile.c, sysproc.c
- */
-void
-validalign(uintptr addr, unsigned align)
-{
-	/*
-	 * Plan 9 is a 32-bit O/S, and the hardware it runs on
-	 * does not usually have instructions which move 64-bit
-	 * quantities directly, synthesizing the operations
-	 * with 32-bit move instructions. Therefore, the compiler
-	 * (and hardware) usually only enforce 32-bit alignment,
-	 * if at all.
-	 *
-	 * Take this out if the architecture warrants it.
-	 */
-	if(align == sizeof(vlong))
-		align = sizeof(long);
-
-	/*
-	 * Check align is a power of 2, then addr alignment.
-	 */
-	if((align != 0 && !(align & (align-1))) && !(addr & (align-1)))
-		return;
-	postnote(up, 1, "sys: odd address", NDebug);
-	error(Ebadarg);
-	/*NOTREACHED*/
-}
-
-/* go to user space */
-void
-kexit(Ureg*)
-{
-	uvlong t;
-	Tos *tos;
-
-	/* precise time accounting, kernel exit */
-	tos = (Tos*)(USTKTOP-sizeof(Tos));
-	cycles(&t);
-	tos->kcycles += t - up->kentry;
-	tos->pcycles = up->pcycles;
-	tos->cyclefreq = cpu->cpuhz;
-	tos->pid = up->pid;
-
-	/* make visible immediately to user proc */
-	cachedwbinvse(tos, sizeof *tos);
-}
-
-/*
- *  return the userpc the last exception happened at
- */
-uintptr
-userpc(void)
-{
-	Ureg *ureg = up->dbgreg;
-	return ureg->pc;
-}
-
-/* This routine must save the values of registers the user is not permitted
- * to write from devproc and then restore the saved values before returning.
- */
-void
-setregisters(Ureg* ureg, char* pureg, char* uva, int n)
-{
-	USED(ureg, pureg, uva, n);
-}
-
-/*
- *  this is the body for all kproc's
- */
-static void
-linkproc(void)
-{
-	spllo();
-	up->kpfun(up->kparg);
-	pexit("kproc exiting", 0);
-}
-
-/*
- *  setup stack and initial PC for a new kernel proc.  This is architecture
- *  dependent because of the starting stack location
- */
-void
-kprocchild(Proc *p, void (*func)(void*), void *arg)
-{
-	p->sched.pc = PTR2UINT(linkproc);
-	p->sched.sp = PTR2UINT(p->kstack+KSTACK);
-
-	p->kpfun = func;
-	p->kparg = arg;
-}
-
-/*
- *  pc output by dumpaproc
- */
-uintptr
-dbgpc(Proc* p)
-{
-	Ureg *ureg;
-
-	ureg = p->dbgreg;
-	if(ureg == 0)
-		return 0;
-
-	return ureg->pc;
-}
-
-/*
- *  set mach dependent process state for a new process
- */
-void
-procsetup(Proc* p)
-{
-	fpusysprocsetup(p);
-}
-
-/*
- *  Save the mach dependent part of the process state.
- */
-void
-procsave(Proc* p)
-{
-	uvlong t;
-
-	cycles(&t);
-	p->pcycles += t;
-
-// TODO: save and restore VFPv3 FP state once 5[cal] know the new registers.
-	fpuprocsave(p);
-}
-
-void
-procrestore(Proc* p)
-{
-	uvlong t;
-
-	if(p->kp)
-		return;
-	cycles(&t);
-	p->pcycles -= t;
-
-	fpuprocrestore(p);
-}
-
-int
-userureg(Ureg* ureg)
-{
-	return (ureg->psr & PsrMask) == PsrMusr;
-}
-
-/*
- * atomic ops
- * make sure that we don't drag in the C library versions
- */
-
-long
-_xdec(long *p)
-{
-	int s, v;
-
-	s = splhi();
-	v = --*p;
-	splx(s);
-	return v;
-}
-
-void
-_xinc(long *p)
-{
-	int s;
-
-	s = splhi();
-	++*p;
-	splx(s);
-}
-
-int
-ainc(int *p)
-{
-	int s, v;
-
-	s = splhi();
-	v = ++*p;
-	splx(s);
-	return v;
-}
-
-int
-adec(int *p)
-{
-	int s, v;
-
-	s = splhi();
-	v = --*p;
-	splx(s);
-	return v;
-}
-
-int
-cas32(void* addr, u32int old, u32int new)
-{
-	int r, s;
-
-	s = splhi();
-	if(r = (*(u32int*)addr == old))
-		*(u32int*)addr = new;
-	splx(s);
-	if (r)
-		coherence();
-	return r;
-}
+#include "../omap/arch.c"
diff -u -p -b -B -r -x .semantic.cache -x .depend -x CVS -x .hg -x .svn -x .git -x _darcs ./archbcm.c /home/pad/work/plan9-github/sys/src/9/bcm/archbcm.c
--- ./archbcm.c	2017-01-09 22:00:48.000000000 -0800
+++ /home/pad/work/plan9-github/sys/src/9/bcm/archbcm.c	2015-01-09 12:17:46.000000000 -0800
@@ -74,7 +74,7 @@ wdogoff(void)
 void
 cpuidprint(void)
 {
-	print("cpu%d: %dMHz ARM1176JZF-S\n", cpu->cpuno, cpu->cpumhz);
+	print("cpu%d: %dMHz ARM1176JZF-S\n", m->machno, m->cpumhz);
 }
 
 void
diff -u -p -b -B -r -x .semantic.cache -x .depend -x CVS -x .hg -x .svn -x .git -x _darcs ./boot.rc /home/pad/work/plan9-github/sys/src/9/bcm/boot.rc
--- ./boot.rc	2017-01-16 22:29:50.000000000 -0800
+++ /home/pad/work/plan9-github/sys/src/9/bcm/boot.rc	2015-01-09 12:17:46.000000000 -0800
@@ -1,77 +1,30 @@
 #!/boot/rc -m /boot/rcmain
 
-/boot/echo booooooooting...
-
+/boot/echo -n boot...
 path=(/bin /boot)
-
-# basic devices
-
-bind -c '#e' /env
-bind -a '#ec' /env # plan9.ini settings (*var variables).
-bind -c '#s' /srv
 bind '#p' /proc
-# used by rc and many programs, e.g. via open("#d/0")
 bind '#d' /fd
-# can't use sys, because too much code assumes /sys/ have an include/, src/
-bind '#k' /ksys
-
-echo -n 'start' > '#c/swap'
-
 bind -a '#P' /dev
-
-# storage
-
+bind -a '#t' /dev
 bind -a '#S' /dev
-
-echo fdisk...
+bind -a '#I' /net
+echo -n rpi >/dev/hostowner
+echo -n fdisk...
 fdisk -p /dev/sdM0/data >/dev/sdM0/ctl
-#dossrv -f/dev/sdM0/dos boot
-dossrv
-mount -c /srv/dos /root /dev/sdM0/dos
-bind -a -c /root /
-bind -a /arm/bin /bin
-#less: bind /$cputype/bin /bin
-bind -a /rc/bin /bin
-
-# mouse and display
-
-bind -a '#i' /dev # devdraw
+dossrv -f/dev/sdM0/dos boot
+rootdir=/root/plan9
+rootspec=''
+mount -c /srv/boot /root
+bind -ac $rootdir /
+bind -ac $rootdir/mnt /mnt
 
-# for rio
-
-ramfs -m /mnt
-mkdir /mnt/temp # see thread(2), used to create pipes
-mkdir /mnt/wsys
-# dont forget -n, otherwise rio gets confused with 'bad character in filename'
-echo -n pad > /ksys/hostowner
-
-# network
-
-bind '#I' /net
-#bind -a '#l0' /net
-
-# for 5c, 5a, 5l
-objtype=arm
-
-
-#bind -a '#t' /dev
-
-#rootdir=/root/plan9
-#rootspec=''
-#mount -c /srv/boot /root
-#bind -ac $rootdir /
-#bind -ac $rootdir/mnt /mnt
-
-usbd
-
-#if (! ~ $#init 0)
-#	exec `{echo $init}
-#if (~ $service cpu)
-#	exec /$cputype/init -c
-#if not
-#	exec /$cputype/init -t
-
-# should normally run /root/init, but prefer to simply run rc for now
+bind /$cputype/bin /bin
+bind -a /rc/bin /bin
 
-exec /boot/rc -m /boot/rcmain -i
-#exec rio
+if (! ~ $#init 0)
+	exec `{echo $init}
+if (~ $service cpu)
+	exec /$cputype/init -c
+if not
+	exec /$cputype/init -t
+exec /boot/rc -m/boot/rcmain -i
diff -u -p -b -B -r -x .semantic.cache -x .depend -x CVS -x .hg -x .svn -x .git -x _darcs ./clock.c /home/pad/work/plan9-github/sys/src/9/bcm/clock.c
--- ./clock.c	2017-01-10 12:11:49.000000000 -0800
+++ /home/pad/work/plan9-github/sys/src/9/bcm/clock.c	2015-01-09 12:17:46.000000000 -0800
@@ -108,16 +108,16 @@ clockinit(void)
 		t1 = lcycles();
 	}while(tn->clo != tend);
 	t1 -= t0;
-	cpu->cpuhz = 100 * t1;
-	cpu->cpumhz = (cpu->cpuhz + Mhz/2 - 1) / Mhz;
-	cpu->cyclefreq = cpu->cpuhz;
+	m->cpuhz = 100 * t1;
+	m->cpumhz = (m->cpuhz + Mhz/2 - 1) / Mhz;
+	m->cyclefreq = m->cpuhz;
 
 	tn->c3 = tn->clo - 1;
 	intrenable(IRQtimer3, clockintr, nil, 0, "clock");
 }
 
 void
-timerset(Tval next)
+timerset(uvlong next)
 {
 	Systimers *tn;
 	vlong now, period;
@@ -145,8 +145,8 @@ fastticks(uvlong *hz)
 		hi = tn->chi;
 		lo = tn->clo;
 	}while(tn->chi != hi);
-	cpu->fastclock = (uvlong)hi<<32 | lo;
-	return cpu->fastclock;
+	m->fastclock = (uvlong)hi<<32 | lo;
+	return m->fastclock;
 }
 
 ulong
diff -u -p -b -B -r -x .semantic.cache -x .depend -x CVS -x .hg -x .svn -x .git -x _darcs ./coproc.c /home/pad/work/plan9-github/sys/src/9/bcm/coproc.c
--- ./coproc.c	2017-01-09 22:01:45.000000000 -0800
+++ /home/pad/work/plan9-github/sys/src/9/bcm/coproc.c	2015-01-09 12:17:46.000000000 -0800
@@ -1,200 +1 @@
-/*
- * arm co-processors
- * mainly to cope with arm hard-wiring register numbers into instructions.
- *
- * CP15 (system control) is the one that gets used the most in practice.
- * these routines must be callable from KZERO space or the 0 segment.
- */
-#include "u.h"
-#include "../port/lib.h"
-#include "mem.h"
-#include "dat.h"
-#include "fns.h"
-#include "io.h"
-
-#include "arm.h"
-
-enum {
-	/* alternates:	0xe12fff1e	BX (R14); last e is R14 */
-	/*		0xe28ef000	B 0(R14); second e is R14 (ken) */
-	Retinst	= 0xe1a0f00e,		/* MOV R14, R15 */
-
-	Opmask	= MASK(3),
-	Regmask	= MASK(4),
-};
-
-typedef ulong (*Pufv)(void);
-typedef void  (*Pvfu)(ulong);
-
-static void
-setupcpop(ulong instr[2], ulong opcode, int cp, int op1, int crn, int crm,
-	int op2)
-{
-	ulong instrsz[2];
-
-	op1 &= Opmask;
-	op2 &= Opmask;
-	crn &= Regmask;
-	crm &= Regmask;
-	cp  &= Regmask;
-	instr[0] = opcode | op1 << 21 | crn << 16 | cp << 8 | op2 << 5 | crm;
-	instr[1] = Retinst;
-
-	cachedwbse(instr, sizeof instrsz);
-	cacheiinv();
-}
-
-ulong
-cprd(int cp, int op1, int crn, int crm, int op2)
-{
-	int s, r;
-	volatile ulong instr[2];
-	Pufv fp;
-
-	s = splhi();
-	/*
-	 * MRC.  return value will be in R0, which is convenient.
-	 * Rt will be R0.
-	 */
-	setupcpop(instr, 0xee100010, cp, op1, crn, crm, op2);
-	fp = (Pufv)instr;
-	r = fp();
-	splx(s);
-	return r;
-}
-
-void
-cpwr(int cp, int op1, int crn, int crm, int op2, ulong val)
-{
-	int s;
-	volatile ulong instr[2];
-	Pvfu fp;
-
-	s = splhi();
-	setupcpop(instr, 0xee000010, cp, op1, crn, crm, op2); /* MCR, Rt is R0 */
-	fp = (Pvfu)instr;
-	fp(val);
-	coherence();
-	splx(s);
-}
-
-ulong
-cprdsc(int op1, int crn, int crm, int op2)
-{
-	return cprd(CpSC, op1, crn, crm, op2);
-}
-
-void
-cpwrsc(int op1, int crn, int crm, int op2, ulong val)
-{
-	cpwr(CpSC, op1, crn, crm, op2, val);
-}
-
-/* floating point */
-
-/* fp coproc control */
-static void
-setupfpctlop(ulong instr[2], int opcode, int fpctlreg)
-{
-	ulong instrsz[2];
-
-	fpctlreg &= Nfpctlregs - 1;
-	instr[0] = opcode | fpctlreg << 16 | 0 << 12 | CpFP << 8;
-	instr[1] = Retinst;
-
-	cachedwbse(instr, sizeof instrsz);
-	cacheiinv();
-}
-
-ulong
-fprd(int fpreg)
-{
-	int s, r;
-	volatile ulong instr[2];
-	Pufv fp;
-
-	if (!cpu->fpon) {
-		dumpstack();
-		panic("fprd: cpu%d fpu off", cpu->cpuno);
-	}
-	s = splhi();
-	/*
-	 * VMRS.  return value will be in R0, which is convenient.
-	 * Rt will be R0.
-	 */
-	setupfpctlop(instr, 0xeef00010, fpreg);
-	fp = (Pufv)instr;
-	r = fp();
-	splx(s);
-	return r;
-}
-
-void
-fpwr(int fpreg, ulong val)
-{
-	int s;
-	volatile ulong instr[2];
-	Pvfu fp;
-
-	/* fpu might be off and this VMSR might enable it */
-	s = splhi();
-	setupfpctlop(instr, 0xeee00010, fpreg);		/* VMSR, Rt is R0 */
-	fp = (Pvfu)instr;
-	fp(val);
-	coherence();
-	splx(s);
-}
-
-/* fp register access; don't bother with single precision */
-static void
-setupfpop(ulong instr[2], int opcode, int fpreg)
-{
-	ulong instrsz[2];
-
-	instr[0] = opcode | 0 << 16 | (fpreg & (16 - 1)) << 12;
-	if (fpreg >= 16)
-		instr[0] |= 1 << 22;		/* high bit of dfp reg # */
-	instr[1] = Retinst;
-
-	cachedwbse(instr, sizeof instrsz);
-	cacheiinv();
-}
-
-ulong
-fpsavereg(int fpreg, uvlong *fpp)
-{
-	int s, r;
-	volatile ulong instr[2];
-	ulong (*fp)(uvlong *);
-
-	if (!cpu->fpon)
-		panic("fpsavereg: cpu%d fpu off", cpu->cpuno);
-	s = splhi();
-	/*
-	 * VSTR.  pointer will be in R0, which is convenient.
-	 * Rt will be R0.
-	 */
-	setupfpop(instr, 0xed000000 | CpDFP << 8, fpreg);
-	fp = (ulong (*)(uvlong *))instr;
-	r = fp(fpp);
-	splx(s);
-	coherence();
-	return r;			/* not too meaningful */
-}
-
-void
-fprestreg(int fpreg, uvlong val)
-{
-	int s;
-	volatile ulong instr[2];
-	void (*fp)(uvlong *);
-
-	if (!cpu->fpon)
-		panic("fprestreg: cpu%d fpu off", cpu->cpuno);
-	s = splhi();
-	setupfpop(instr, 0xed100000 | CpDFP << 8, fpreg); /* VLDR, Rt is R0 */
-	fp = (void (*)(uvlong *))instr;
-	fp(&val);
-	coherence();
-	splx(s);
-}
+#include "../teg2/coproc.c"
diff -u -p -b -B -r -x .semantic.cache -x .depend -x CVS -x .hg -x .svn -x .git -x _darcs ./dat.h /home/pad/work/plan9-github/sys/src/9/bcm/dat.h
--- ./dat.h	2017-01-10 19:09:03.000000000 -0800
+++ /home/pad/work/plan9-github/sys/src/9/bcm/dat.h	2015-01-09 12:17:46.000000000 -0800
@@ -1,7 +1,3 @@
-
-// misc constants
-#define MAXSYSARG	5	/* for mount(fd, mpt, flag, arg, srv) */
-
 /*
  * Time.
  *
@@ -11,70 +7,117 @@
 #define	HZ		100			/* clock frequency */
 #define	MS2HZ		(1000/HZ)		/* millisec per clock tick */
 #define	TK2SEC(t)	((t)/HZ)		/* ticks to seconds */
-enum {
-	Mhz	= 1000 * 1000,
-};
 
 enum {
-	Maxfpregs	= 32,	/* could be 16 or 32, see Mach.fpnregs */
-	Nfpctlregs	= 16,
+	Mhz	= 1000 * 1000,
 };
 
-// was a default in portdat.h
-#define STAGESIZE 64
-#define KMESGSIZE (16*1024)
-
-// pad memory pointers
-// physical address
-typedef uintptr phys_addr;
-// virtual address (which should be a user address)
-typedef uintptr virt_addr;
-// kernel address (mostly physical + KZERO)
-typedef uintptr kern_addr;
-
-typedef ulong* kern_addr2;
-typedef ulong* virt_addr2;
-typedef void* virt_addr3;
-typedef void* kern_addr3;
-
-//#define nil (void*)0 in lib.h
-#define nilptr 0
+typedef struct Conf	Conf;
+typedef struct Confmem	Confmem;
+typedef struct FPsave	FPsave;
+typedef struct ISAConf	ISAConf;
+typedef struct Label	Label;
+typedef struct Lock	Lock;
+typedef struct Memcache	Memcache;
+typedef struct MMMU	MMMU;
+typedef struct Mach	Mach;
+typedef struct Notsave	Notsave;
+typedef struct Page	Page;
+typedef struct PhysUart	PhysUart;
+typedef struct PMMU	PMMU;
+typedef struct Proc	Proc;
+typedef u32int		PTE;
+typedef struct Uart	Uart;
+typedef struct Ureg	Ureg;
+typedef uvlong		Tval;
 
+#pragma incomplete Ureg
 
+#define MAXSYSARG	5	/* for mount(fd, mpt, flag, arg, srv) */
 
-#include "dat_forward.h"
-#include "../port/portdat_forward.h"
+/*
+ *  parameters for sysproc.c
+ */
+#define AOUT_MAGIC	(E_MAGIC)
 
-// defines Lock (used inline in Cpu in portdat_core.h so must be before)
-#include "../port/portdat_concurrency.h"
+struct Lock
+{
+	ulong	key;
+	u32int	sr;
+	uintptr	pc;
+	Proc*	p;
+	Mach*	m;
+	int	isilock;
+};
 
-// defines Conf, Cpu, ... Label
-#include "dat_core.h"
-#include "../port/portdat_core.h"
+struct Label
+{
+	uintptr	sp;
+	uintptr	pc;
+};
 
-// defines Page, Pagetable, Segment, KImage
-#include "dat_memory.h"
-#include "../port/portdat_memory.h"
+enum {
+	Maxfpregs	= 32,	/* could be 16 or 32, see Mach.fpnregs */
+	Nfpctlregs	= 16,
+};
 
-// defines Chan
-#include "../port/portdat_files.h"
+/*
+ * emulated or vfp3 floating point
+ */
+struct FPsave
+{
+	ulong	status;
+	ulong	control;
+	/*
+	 * vfp3 with ieee fp regs; uvlong is sufficient for hardware but
+	 * each must be able to hold an Internal from fpi.h for sw emulation.
+	 */
+	ulong	regs[Maxfpregs][3];
 
-// defines ??
-#include "dat_arch.h"
+	int	fpstate;
+	uintptr	pc;		/* of failed fp instr. */
+};
 
-// defines Proc
-#include "dat_processes.h"
-#include "../port/portdat_processes.h"
+/*
+ * FPsave.fpstate
+ */
+enum
+{
+	FPinit,
+	FPactive,
+	FPinactive,
+	FPemu,
 
-// defines Cmd
-#include "../port/portdat_misc.h"
+	/* bits or'd with the state */
+	FPillegal= 0x100,
+};
 
-// defines Uart
-#include "dat_buses.h"
-#include "../port/portdat_buses.h"
+struct Confmem
+{
+	uintptr	base;
+	usize	npage;
+	uintptr	limit;
+	uintptr	kbase;
+	uintptr	klimit;
+};
 
-// defines keyboard queue, consdevtab
-#include "../port/portdat_console.h"
+struct Conf
+{
+	ulong	nmach;		/* processors */
+	ulong	nproc;		/* processes */
+	Confmem	mem[1];		/* physical memory */
+	ulong	npage;		/* total physical pages of memory */
+	usize	upages;		/* user page pool */
+	ulong	copymode;	/* 0 is copy on write, 1 is copy on reference */
+	ulong	ialloc;		/* max interrupt time allocation in bytes */
+	ulong	pipeqsize;	/* size in bytes of pipe queues */
+	ulong	nimage;		/* number of page cache image headers */
+	ulong	nswap;		/* number of swap pages */
+	int	nswppo;		/* max # of pageouts per segment pass */
+	ulong	hz;		/* processor cycle freq */
+	ulong	mhz;
+	int	monitor;	/* flag */
+};
 
 /*
  *  things saved in the Proc structure during a notify
@@ -83,16 +126,133 @@ struct Notsave {
 	int	emptiness;
 };
 
-// TODO add register! but 5c-ocaml does not like it
-extern register Cpu* cpu;			/* R10 */
-extern register Proc* up;			/* R9 */
+/*
+ *  MMU stuff in Mach.
+ */
+struct MMMU
+{
+	PTE*	mmul1;		/* l1 for this processor */
+	int	mmul1lo;
+	int	mmul1hi;
+	int	mmupid;
+};
 
-extern uintptr kseg0;
+/*
+ *  MMU stuff in proc
+ */
+#define NCOLOR	1		/* 1 level cache, don't worry about VCE's */
+struct PMMU
+{
+	Page*	mmul2;
+	Page*	mmul2cache;	/* free mmu pages */
+};
+
+#include "../port/portdat.h"
+
+struct Mach
+{
+	int	machno;			/* physical id of processor */
+	uintptr	splpc;			/* pc of last caller to splhi */
+
+	Proc*	proc;			/* current process */
+
+	MMMU;
+	int	flushmmu;		/* flush current proc mmu state */
+
+	ulong	ticks;			/* of the clock since boot time */
+	Label	sched;			/* scheduler wakeup */
+	Lock	alarmlock;		/* access to alarm list */
+	void*	alarm;			/* alarms bound to this clock */
+
+	Proc*	readied;		/* for runproc */
+	ulong	schedticks;		/* next forced context switch */
+
+	int	cputype;
+	ulong	delayloop;
+
+	/* stats */
+	int	tlbfault;
+	int	tlbpurge;
+	int	pfault;
+	int	cs;
+	int	syscall;
+	int	load;
+	int	intr;
+	uvlong	fastclock;		/* last sampled value */
+	ulong	spuriousintr;
+	int	lastintr;
+	int	ilockdepth;
+	Perf	perf;			/* performance counters */
+
+
+	int	cpumhz;
+	uvlong	cpuhz;			/* speed of cpu */
+	uvlong	cyclefreq;		/* Frequency of user readable cycle counter */
+
+	/* vfp2 or vfp3 fpu */
+	int	havefp;
+	int	havefpvalid;
+	int	fpon;
+	int	fpconfiged;
+	int	fpnregs;
+	ulong	fpscr;			/* sw copy */
+	int	fppid;			/* pid of last fault */
+	uintptr	fppc;			/* addr of last fault */
+	int	fpcnt;			/* how many consecutive at that addr */
+
+	/* save areas for exceptions, hold R0-R4 */
+	u32int	sfiq[5];
+	u32int	sirq[5];
+	u32int	sund[5];
+	u32int	sabt[5];
+	u32int	smon[5];		/* probably not needed */
+	u32int	ssys[5];
+
+	int	stack[1];
+};
+
+/*
+ * Fake kmap.
+ */
+typedef void		KMap;
+#define	VA(k)		((uintptr)(k))
+#define	kmap(p)		(KMap*)((p)->pa|kseg0)
+#define	kunmap(k)
+
+struct
+{
+	Lock;
+	int	machs;			/* bitmap of active CPUs */
+	int	exiting;		/* shutdown */
+	int	ispanic;		/* shutdown in response to a panic */
+}active;
 
+extern register Mach* m;			/* R10 */
+extern register Proc* up;			/* R9 */
+extern uintptr kseg0;
+extern Mach* machaddr[MAXMACH];
 extern ulong memsize;
 extern int normalprint;
 
+/*
+ *  a parsed plan9.ini line
+ */
+#define NISAOPT		8
+
+struct ISAConf {
+	char	*type;
+	ulong	port;
+	int	irq;
+	ulong	dma;
+	ulong	mem;
+	ulong	size;
+	ulong	freq;
 
+	int	nopt;
+	char	*opt[NISAOPT];
+};
+
+#define	MACHP(n)	(machaddr[n])
 
 /*
  * Horrid. But the alternative is 'defined'.
@@ -107,3 +267,20 @@ int vflag;
 extern char dbgflg[256];
 
 #define dbgprint	print		/* for now */
+
+/*
+ *  hardware info about a device
+ */
+typedef struct {
+	ulong	port;
+	int	size;
+} Devport;
+
+struct DevConf
+{
+	ulong	intnum;			/* interrupt number */
+	char	*type;			/* card type, malloced */
+	int	nports;			/* Number of ports */
+	Devport	*ports;			/* The ports themselves */
+};
+
Only in .: dat_arch.h
Only in .: dat_buses.h
Only in .: dat_core.h
Only in .: dat_forward.h
Only in .: dat_memory.h
Only in .: dat_processes.h
diff -u -p -b -B -r -x .semantic.cache -x .depend -x CVS -x .hg -x .svn -x .git -x _darcs ./devarch.c /home/pad/work/plan9-github/sys/src/9/bcm/devarch.c
--- ./devarch.c	2017-01-10 12:24:06.000000000 -0800
+++ /home/pad/work/plan9-github/sys/src/9/bcm/devarch.c	2015-01-09 12:17:46.000000000 -0800
@@ -127,24 +127,24 @@ archwrite(Chan *c, void *a, long n, vlon
 void archinit(void);
 
 Dev archdevtab = {
-	.dc = 'P',
-	.name = "arch",
+	'P',
+	"arch",
 
-	.reset = devreset,
-	.init = archinit,
-	.shutdown = devshutdown,
-	.attach = archattach,
-	.walk = archwalk,
-	.stat = archstat,
-	.open = archopen,
-	.create = devcreate,
-	.close = archclose,
-	.read = archread,
-	.bread = devbread,
-	.write = archwrite,
-	.bwrite = devbwrite,
-	.remove = devremove,
-	.wstat = devwstat,
+	devreset,
+	archinit,
+	devshutdown,
+	archattach,
+	archwalk,
+	archstat,
+	archopen,
+	devcreate,
+	archclose,
+	archread,
+	devbread,
+	archwrite,
+	devbwrite,
+	devremove,
+	devwstat,
 };
 
 static long
@@ -152,7 +152,7 @@ cputyperead(Chan*, void *a, long n, vlon
 {
 	char str[128];
 
-	snprint(str, sizeof str, "ARM11 %d\n", cpu->cpumhz);
+	snprint(str, sizeof str, "ARM11 %d\n", m->cpumhz);
 	return readstr(offset, a, n, str);
 }
 
diff -u -p -b -B -r -x .semantic.cache -x .depend -x CVS -x .hg -x .svn -x .git -x _darcs ./devether.c /home/pad/work/plan9-github/sys/src/9/bcm/devether.c
--- ./devether.c	2017-01-10 12:25:04.000000000 -0800
+++ /home/pad/work/plan9-github/sys/src/9/bcm/devether.c	2015-01-09 12:17:46.000000000 -0800
@@ -1,530 +1 @@
-#include "u.h"
-#include "../port/lib.h"
-#include "mem.h"
-#include "dat.h"
-#include "fns.h"
-#include "io.h"
-#include "../port/error.h"
-
-#include "../port/netif.h"
-#include "etherif.h"
-
-extern int archether(unsigned ctlno, Ether *ether);
-
-static Ether *etherxx[MaxEther];
-
-Chan*
-etherattach(char* spec)
-{
-	int ctlrno;
-	char *p;
-	Chan *chan;
-
-	ctlrno = 0;
-	if(spec && *spec){
-		ctlrno = strtoul(spec, &p, 0);
-		if((ctlrno == 0 && p == spec) || *p != 0)
-			error(Ebadarg);
-		if(ctlrno < 0 || ctlrno >= MaxEther)
-			error(Ebadarg);
-	}
-	if(etherxx[ctlrno] == 0)
-		error(Enodev);
-
-	chan = devattach('l', spec);
-	if(waserror()){
-		chanfree(chan);
-		nexterror();
-	}
-	chan->dev = ctlrno;
-	if(etherxx[ctlrno]->attach)
-		etherxx[ctlrno]->attach(etherxx[ctlrno]);
-	poperror();
-	return chan;
-}
-
-static Walkqid*
-etherwalk(Chan* chan, Chan* nchan, char** name, int nname)
-{
-	return netifwalk(etherxx[chan->dev], chan, nchan, name, nname);
-}
-
-static int
-etherstat(Chan* chan, uchar* dp, int n)
-{
-	return netifstat(etherxx[chan->dev], chan, dp, n);
-}
-
-static Chan*
-etheropen(Chan* chan, int omode)
-{
-	return netifopen(etherxx[chan->dev], chan, omode);
-}
-
-static void
-ethercreate(Chan*, char*, int, ulong)
-{
-}
-
-static void
-etherclose(Chan* chan)
-{
-	netifclose(etherxx[chan->dev], chan);
-}
-
-static long
-etherread(Chan* chan, void* buf, long n, vlong off)
-{
-	Ether *ether;
-	ulong offset = off;
-
-	ether = etherxx[chan->dev];
-	if((chan->qid.type & QTDIR) == 0 && ether->ifstat){
-		/*
-		 * With some controllers it is necessary to reach
-		 * into the chip to extract statistics.
-		 */
-		if(NETTYPE(chan->qid.path) == Nifstatqid)
-			return ether->ifstat(ether, buf, n, offset);
-		else if(NETTYPE(chan->qid.path) == Nstatqid)
-			ether->ifstat(ether, buf, 0, offset);
-	}
-
-	return netifread(ether, chan, buf, n, offset);
-}
-
-static Block*
-etherbread(Chan* chan, long n, ulong offset)
-{
-	return netifbread(etherxx[chan->dev], chan, n, offset);
-}
-
-static int
-etherwstat(Chan* chan, uchar* dp, int n)
-{
-	return netifwstat(etherxx[chan->dev], chan, dp, n);
-}
-
-static void
-etherrtrace(Netfile* f, Etherpkt* pkt, int len)
-{
-	int i, n;
-	Block *bp;
-
-	if(qwindow(f->in) <= 0)
-		return;
-	if(len > 58)
-		n = 58;
-	else
-		n = len;
-	bp = iallocb(64);
-	if(bp == nil)
-		return;
-	memmove(bp->wp, pkt->d, n);
-	i = TK2MS(CPUS(0)->ticks);
-	bp->wp[58] = len>>8;
-	bp->wp[59] = len;
-	bp->wp[60] = i>>24;
-	bp->wp[61] = i>>16;
-	bp->wp[62] = i>>8;
-	bp->wp[63] = i;
-	bp->wp += 64;
-	qpass(f->in, bp);
-}
-
-Block*
-etheriq(Ether* ether, Block* bp, int fromwire)
-{
-	Etherpkt *pkt;
-	ushort type;
-	int len, multi, tome, fromme;
-	Netfile **ep, *f, **fp, *fx;
-	Block *xbp;
-
-	ether->inpackets++;
-
-	pkt = (Etherpkt*)bp->rp;
-	len = BLEN(bp);
-	type = (pkt->type[0]<<8)|pkt->type[1];
-	fx = 0;
-	ep = &ether->f[Ntypes];
-
-	multi = pkt->d[0] & 1;
-	/* check for valid multicast addresses */
-	if(multi && memcmp(pkt->d, ether->bcast, sizeof(pkt->d)) != 0 &&
-	    ether->prom == 0){
-		if(!activemulti(ether, pkt->d, sizeof(pkt->d))){
-			if(fromwire){
-				freeb(bp);
-				bp = 0;
-			}
-			return bp;
-		}
-	}
-	/* is it for me? */
-	tome = memcmp(pkt->d, ether->ea, sizeof(pkt->d)) == 0;
-	fromme = memcmp(pkt->s, ether->ea, sizeof(pkt->s)) == 0;
-
-	/*
-	 * Multiplex the packet to all the connections which want it.
-	 * If the packet is not to be used subsequently (fromwire != 0),
-	 * attempt to simply pass it into one of the connections, thereby
-	 * saving a copy of the data (usual case hopefully).
-	 */
-	for(fp = ether->f; fp < ep; fp++){
-		if((f = *fp) != nil && (f->type == type || f->type < 0) &&
-		    (tome || multi || f->prom)){
-			/* Don't want to hear bridged packets */
-			if(f->bridge && !fromwire && !fromme)
-				continue;
-			if(!f->headersonly){
-				if(fromwire && fx == 0)
-					fx = f;
-				else if(xbp = iallocb(len)){
-					memmove(xbp->wp, pkt, len);
-					xbp->wp += len;
-					if(qpass(f->in, xbp) < 0)
-						ether->soverflows++;
-				}
-				else
-					ether->soverflows++;
-			}
-			else
-				etherrtrace(f, pkt, len);
-		}
-	}
-
-	if(fx){
-		if(qpass(fx->in, bp) < 0)
-			ether->soverflows++;
-		return 0;
-	}
-	if(fromwire){
-		freeb(bp);
-		return 0;
-	}
-	return bp;
-}
-
-static int
-etheroq(Ether* ether, Block* bp)
-{
-	int len, loopback, s;
-	Etherpkt *pkt;
-
-	ether->outpackets++;
-
-	/*
-	 * Check if the packet has to be placed back onto the input queue,
-	 * i.e. if it's a loopback or broadcast packet or the interface is
-	 * in promiscuous mode.
-	 * If it's a loopback packet indicate to etheriq that the data isn't
-	 * needed and return, etheriq will pass-on or free the block.
-	 * To enable bridging to work, only packets that were originated
-	 * by this interface are fed back.
-	 */
-	pkt = (Etherpkt*)bp->rp;
-	len = BLEN(bp);
-	loopback = memcmp(pkt->d, ether->ea, sizeof(pkt->d)) == 0;
-	if(loopback || memcmp(pkt->d, ether->bcast, sizeof(pkt->d)) == 0 || ether->prom){
-		s = splhi();
-		etheriq(ether, bp, 0);
-		splx(s);
-	}
-
-	if(!loopback){
-		qbwrite(ether->oq, bp);
-		if(ether->transmit != nil)
-			ether->transmit(ether);
-	} else
-		freeb(bp);
-
-	return len;
-}
-
-static long
-etherwrite(Chan* chan, void* buf, long n, vlong)
-{
-	Ether *ether;
-	Block *bp;
-	int nn, onoff;
-	Cmdbuf *cb;
-
-	ether = etherxx[chan->dev];
-	if(NETTYPE(chan->qid.path) != Ndataqid) {
-		nn = netifwrite(ether, chan, buf, n);
-		if(nn >= 0)
-			return nn;
-		cb = parsecmd(buf, n);
-		if(cb->f[0] && strcmp(cb->f[0], "nonblocking") == 0){
-			if(cb->nf <= 1)
-				onoff = 1;
-			else
-				onoff = atoi(cb->f[1]);
-			qnoblock(ether->oq, onoff);
-			free(cb);
-			return n;
-		}
-		free(cb);
-		if(ether->ctl!=nil)
-			return ether->ctl(ether,buf,n);
-			
-		error(Ebadctl);
-	}
-
-	if(n > ether->maxmtu)
-		error(Etoobig);
-	if(n < ether->minmtu)
-		error(Etoosmall);
-
-	bp = allocb(n);
-	if(waserror()){
-		freeb(bp);
-		nexterror();
-	}
-	memmove(bp->rp, buf, n);
-	memmove(bp->rp+Eaddrlen, ether->ea, Eaddrlen);
-	poperror();
-	bp->wp += n;
-
-	return etheroq(ether, bp);
-}
-
-static long
-etherbwrite(Chan* chan, Block* bp, ulong)
-{
-	Ether *ether;
-	long n;
-
-	n = BLEN(bp);
-	if(NETTYPE(chan->qid.path) != Ndataqid){
-		if(waserror()) {
-			freeb(bp);
-			nexterror();
-		}
-		n = etherwrite(chan, bp->rp, n, 0);
-		poperror();
-		freeb(bp);
-		return n;
-	}
-	ether = etherxx[chan->dev];
-
-	if(n > ether->maxmtu){
-		freeb(bp);
-		error(Etoobig);
-	}
-	if(n < ether->minmtu){
-		freeb(bp);
-		error(Etoosmall);
-	}
-
-	return etheroq(ether, bp);
-}
-
-static struct {
-	char*	type;
-	int	(*reset)(Ether*);
-} cards[MaxEther+1];
-
-void
-addethercard(char* t, int (*r)(Ether*))
-{
-	static int ncard;
-
-	if(ncard == MaxEther)
-		panic("too many ether cards");
-	cards[ncard].type = t;
-	cards[ncard].reset = r;
-	ncard++;
-}
-
-int
-parseether(uchar *to, char *from)
-{
-	char nip[4];
-	char *p;
-	int i;
-
-	p = from;
-	for(i = 0; i < Eaddrlen; i++){
-		if(*p == 0)
-			return -1;
-		nip[0] = *p++;
-		if(*p == 0)
-			return -1;
-		nip[1] = *p++;
-		nip[2] = 0;
-		to[i] = strtoul(nip, 0, 16);
-		if(*p == ':')
-			p++;
-	}
-	return 0;
-}
-
-static void
-etherreset(void)
-{
-	Ether *ether;
-	int i, n, ctlrno;
-	char name[KNAMELEN], buf[128];
-
-	for(ether = 0, ctlrno = 0; ctlrno < MaxEther; ctlrno++){
-		if(ether == 0)
-			ether = malloc(sizeof(Ether));
-		memset(ether, 0, sizeof(Ether));
-		ether->ctlrno = ctlrno;
-		ether->mbps = 10;
-		ether->minmtu = ETHERMINTU;
-		ether->maxmtu = ETHERMAXTU;
-
-		if(archether(ctlrno, ether) <= 0)
-			continue;
-
-		if(isaconfig("ether", ctlrno, ether) == 0){
-//			free(ether);
-//			return nil;
-			continue;
-		}
-		for(n = 0; cards[n].type; n++){
-			if(cistrcmp(cards[n].type, ether->type))
-				continue;
-			for(i = 0; i < ether->nopt; i++)
-				if(cistrncmp(ether->opt[i], "ea=", 3) == 0){
-					if(parseether(ether->ea,
-					    &ether->opt[i][3]) == -1)
-						memset(ether->ea, 0, Eaddrlen);
-				} else if(cistrcmp(ether->opt[i],
-				    "100BASE-TXFD") == 0)
-					ether->mbps = 100;
-			if(cards[n].reset(ether))
-				break;
-			snprint(name, sizeof(name), "ether%d", ctlrno);
-
-			if(ether->interrupt != nil && ether->irq >= 0)
-				intrenable(ether->irq, ether->interrupt,
-					ether, 0, name);
-
-			i = snprint(buf, sizeof buf,
-				"#l%d: %s: %dMbps port %#lux irq %d",
-				ctlrno, ether->type, ether->mbps, ether->port,
-				ether->irq);
-			if(ether->mem)
-				i += snprint(buf+i, sizeof buf - i,
-					" addr %#lux", PADDR(ether->mem));
-			if(ether->size)
-				i += snprint(buf+i, sizeof buf - i,
-					" size %#luX", ether->size);
-			i += snprint(buf+i, sizeof buf - i,
-				": %2.2ux%2.2ux%2.2ux%2.2ux%2.2ux%2.2ux",
-				ether->ea[0], ether->ea[1], ether->ea[2],
-				ether->ea[3], ether->ea[4], ether->ea[5]);
-			snprint(buf+i, sizeof buf - i, "\n");
-			iprint("%s", buf);  /* it may be too early for print */
-
-			if(ether->mbps >= 1000)
-				netifinit(ether, name, Ntypes, 4*1024*1024);
-			else if(ether->mbps >= 100)
-				netifinit(ether, name, Ntypes, 1024*1024);
-			else
-				netifinit(ether, name, Ntypes, 65*1024);
-			if(ether->oq == 0)
-				ether->oq = qopen(ether->limit, Qmsg, 0, 0);
-			if(ether->oq == 0)
-				panic("etherreset %s", name);
-			ether->alen = Eaddrlen;
-			memmove(ether->addr, ether->ea, Eaddrlen);
-			memset(ether->bcast, 0xFF, Eaddrlen);
-
-			etherxx[ctlrno] = ether;
-			ether = 0;
-			break;
-		}
-	}
-	if(ether)
-		free(ether);
-}
-
-static void
-ethershutdown(void)
-{
-	Ether *ether;
-	int i;
-
-	for(i = 0; i < MaxEther; i++){
-		ether = etherxx[i];
-		if(ether == nil)
-			continue;
-		if(ether->shutdown == nil) {
-			print("#l%d: no shutdown function\n", i);
-			continue;
-		}
-		(*ether->shutdown)(ether);
-	}
-}
-
-
-#define POLY 0xedb88320
-
-/* really slow 32 bit crc for ethers */
-ulong
-ethercrc(uchar *p, int len)
-{
-	int i, j;
-	ulong crc, b;
-
-	crc = 0xffffffff;
-	for(i = 0; i < len; i++){
-		b = *p++;
-		for(j = 0; j < 8; j++){
-			crc = (crc>>1) ^ (((crc^b) & 1) ? POLY : 0);
-			b >>= 1;
-		}
-	}
-	return crc;
-}
-
-void
-dumpoq(Queue *oq)
-{
-	if (oq == nil)
-		print("no outq! ");
-	else if (qisclosed(oq))
-		print("outq closed ");
-	else if (qfull(oq))
-		print("outq full ");
-	else
-		print("outq %d ", qlen(oq));
-}
-
-void
-dumpnetif(Netif *netif)
-{
-	print("netif %s ", netif->name);
-	print("limit %d mbps %d link %d ",
-		netif->limit, netif->mbps, netif->link);
-	print("inpkts %lld outpkts %lld errs %d\n",
-		netif->inpackets, netif->outpackets,
-		netif->crcs + netif->oerrs + netif->frames + netif->overflows +
-		netif->buffs + netif->soverflows);
-}
-
-Dev etherdevtab = {
-	.dc = 'l',
-	.name = "ether",
-
-	.reset = etherreset,
-	.init = devinit,
-	.shutdown = ethershutdown,
-	.attach = etherattach,
-	.walk = etherwalk,
-	.stat = etherstat,
-	.open = etheropen,
-	.create = ethercreate,
-	.close = etherclose,
-	.read = etherread,
-	.bread = etherbread,
-	.write = etherwrite,
-	.bwrite = etherbwrite,
-	.remove = devremove,
-	.wstat = etherwstat,
-};
+#include "../omap/devether.c"
diff -u -p -b -B -r -x .semantic.cache -x .depend -x CVS -x .hg -x .svn -x .git -x _darcs ./devfakertc.c /home/pad/work/plan9-github/sys/src/9/bcm/devfakertc.c
--- ./devfakertc.c	2017-01-10 12:26:04.000000000 -0800
+++ /home/pad/work/plan9-github/sys/src/9/bcm/devfakertc.c	2015-01-09 12:17:46.000000000 -0800
@@ -102,23 +102,23 @@ rtcclose(Chan*)
 }
 
 Dev fakertcdevtab = {
-	.dc = 'r',
-	.name = "rtc",
+	'r',
+	"rtc",
 
-	.reset = devreset,
-	.init = rtcinit,
-	.shutdown = devshutdown,
-	.attach = rtcattach,
-	.walk = rtcwalk,
-	.stat = rtcstat,
-	.open = rtcopen,
-	.create = devcreate,
-	.close = rtcclose,
-	.read = rtcread,
-	.bread = devbread,
-	.write = rtcwrite,
-	.bwrite = devbwrite,
-	.remove = devremove,
-	.wstat = devwstat,
+	devreset,
+	rtcinit,
+	devshutdown,
+	rtcattach,
+	rtcwalk,
+	rtcstat,
+	rtcopen,
+	devcreate,
+	rtcclose,
+	rtcread,
+	devbread,
+	rtcwrite,
+	devbwrite,
+	devremove,
+	devwstat,
 };
 
diff -u -p -b -B -r -x .semantic.cache -x .depend -x CVS -x .hg -x .svn -x .git -x _darcs ./devusb.c /home/pad/work/plan9-github/sys/src/9/bcm/devusb.c
--- ./devusb.c	2017-01-10 12:40:15.000000000 -0800
+++ /home/pad/work/plan9-github/sys/src/9/bcm/devusb.c	2015-01-09 12:17:46.000000000 -0800
@@ -1469,22 +1469,22 @@ usbshutdown(void)
 }
 
 Dev usbdevtab = {
-	.dc = L'u',
-	.name = "usb",
+	L'u',
+	"usb",
 
-	.reset = usbreset,
-	.init = usbinit,
-	.shutdown = usbshutdown,
-	.attach = usbattach,
-	.walk = usbwalk,
-	.stat = usbstat,
-	.open = usbopen,
-	.create = devcreate,
-	.close = usbclose,
-	.read = usbread,
-	.bread = usbbread,
-	.write = usbwrite,
-	.bwrite = usbbwrite,
-	.remove = devremove,
-	.wstat = devwstat,
+	usbreset,
+	usbinit,
+	usbshutdown,
+	usbattach,
+	usbwalk,
+	usbstat,
+	usbopen,
+	devcreate,
+	usbclose,
+	usbread,
+	usbbread,
+	usbwrite,
+	usbbwrite,
+	devremove,
+	devwstat,
 };
diff -u -p -b -B -r -x .semantic.cache -x .depend -x CVS -x .hg -x .svn -x .git -x _darcs ./emmc.c /home/pad/work/plan9-github/sys/src/9/bcm/emmc.c
--- ./emmc.c	2017-01-16 12:13:05.000000000 -0800
+++ /home/pad/work/plan9-github/sys/src/9/bcm/emmc.c	2017-01-15 17:43:56.000000000 -0800
@@ -276,9 +276,9 @@ emmccmd(u32int cmd, u32int arg, u32int *
 		WR(Interrupt, i);
 	}
 	WR(Cmdtm, c);
-	now = cpu->ticks;
+	now = m->ticks;
 	while(((i=r[Interrupt])&(Cmddone|Err)) == 0)
-		if(cpu->ticks - now > HZ)
+		if(m->ticks-now > HZ)
 			break;
 	if((i&(Cmddone|Err)) != Cmddone){
 		if((i&~Err) != Ctoerr)
diff -u -p -b -B -r -x .semantic.cache -x .depend -x CVS -x .hg -x .svn -x .git -x _darcs ./etherif.h /home/pad/work/plan9-github/sys/src/9/bcm/etherif.h
--- ./etherif.h	2015-10-17 09:32:22.000000000 -0700
+++ /home/pad/work/plan9-github/sys/src/9/bcm/etherif.h	2015-01-09 12:17:46.000000000 -0800
@@ -1,41 +1 @@
-enum
-{
-	MaxEther	= 4,
-	Ntypes		= 8,
-};
-
-typedef struct Ether Ether;
-struct Ether {
-	RWlock;
-	ISAConf;			/* hardware info */
-
-	int	ctlrno;
-	int	minmtu;
-	int 	maxmtu;
-
-	Netif;
-
-	void	(*attach)(Ether*);	/* filled in by reset routine */
-	void	(*detach)(Ether*);
-	void	(*transmit)(Ether*);
-	void	(*interrupt)(Ureg*, void*);
-	long	(*ifstat)(Ether*, void*, long, ulong);
-	long 	(*ctl)(Ether*, void*, long); /* custom ctl messages */
-	void	(*power)(Ether*, int);	/* power on/off */
-	void	(*shutdown)(Ether*);	/* shutdown hardware before reboot */
-
-	void*	ctlr;
-	uchar	ea[Eaddrlen];
-	void*	address;
-	int	irq;
-
-	Queue*	oq;
-};
-
-extern Block* etheriq(Ether*, Block*, int);
-extern void addethercard(char*, int(*)(Ether*));
-extern ulong ethercrc(uchar*, int);
-extern int parseether(uchar*, char*);
-
-#define NEXT(x, l)	(((x)+1)%(l))
-#define PREV(x, l)	(((x) == 0) ? (l)-1: (x)-1)
+#include "../omap/etherif.h"
diff -u -p -b -B -r -x .semantic.cache -x .depend -x CVS -x .hg -x .svn -x .git -x _darcs ./fns.h /home/pad/work/plan9-github/sys/src/9/bcm/fns.h
--- ./fns.h	2017-01-16 21:34:37.000000000 -0800
+++ /home/pad/work/plan9-github/sys/src/9/bcm/fns.h	2017-01-13 10:49:41.000000000 -0800
@@ -1,15 +1,4 @@
-#include "../port/portfns_core.h"
-#include "../port/portfns_concurrency.h"
-#include "../port/portfns_memory.h"
-#include "../port/portfns_files.h"
-#include "../port/portfns_processes.h"
-#include "../port/portfns_misc.h"
-#include "../port/portfns_console.h"
-#include "../port/portfns_buses.h"
-#include "../port/portfns_devices.h"
-#include "../port/portfns_security.h"
-#include "../port/portfns_network.h"
-#include "../port/portfns_init.h"
+#include "../port/portfns.h"
 
 Dirtab*	addarchfile(char*, int, long(*)(Chan*, void*, long, vlong), 
 	long(*)(Chan*, void*, long, vlong));
@@ -27,28 +16,13 @@ extern void checkmmu(uintptr, uintptr);
 extern void clockinit(void);
 extern void clockshutdown(void);
 extern int cmpswap(long*, long, long);
-//extern void coherence(void);
+extern void (*coherence)(void);
+extern void coherence1(void);
 extern ulong cprd(int cp, int op1, int crn, int crm, int op2);
 extern ulong cprdsc(int op1, int crn, int crm, int op2);
 extern void cpuidprint(void);
 extern void cpwr(int cp, int op1, int crn, int crm, int op2, ulong val);
 extern void cpwrsc(int op1, int crn, int crm, int op2, ulong val);
-
-// was in portfns.h but commented because not used in x86
-long    lcycles(void);
-
-// could be in portfns.h, same type in every arch, but called from arch-specific
-void    forkret(void);
-void		dumpregs(Ureg*);
-void		confinit(void);
-void		printinit(void);
-void		userinit(void);
-void		bootlinks(void);
-void  memorysummary(void);
-
-// lib/latin1.c
-long    latin1(Rune*, int);
-
 #define cycles(ip) *(ip) = lcycles()
 extern void dmastart(int, int, int, void*, void*, int);
 extern int dmawait(int);
@@ -58,7 +32,7 @@ extern u32int farget(void);
 extern void fpon(void);
 extern ulong fprd(int fpreg);
 extern void fprestreg(int fpreg, uvlong val);
-extern void fpsave(ArchFPsave *);
+extern void fpsave(FPsave *);
 extern ulong fpsavereg(int fpreg, uvlong *fpp);
 extern void fpwr(int fpreg, ulong val);
 extern u32int fsrget(void);
@@ -80,6 +54,9 @@ extern void mmuinvalidate(void);
 extern void mmuinvalidateaddr(u32int);
 extern uintptr mmukmap(uintptr, uintptr, usize);
 extern void okay(int);
+extern void procrestore(Proc *);
+extern void procsave(Proc*);
+extern void procsetup(Proc*);
 extern void screeninit(void);
 #define sdfree(p) free(p)
 #define sdmalloc(n)	mallocalign(n, CACHELINESZ, 0, 0)
@@ -113,20 +90,17 @@ extern void fpusysprocsetup(Proc*);
 extern void fpusysrfork(Ureg*);
 extern void fpusysrforkchild(Proc*, Ureg*, Proc*);
 extern int fpuemu(Ureg*);
-
-
 /*
  * Things called from port.
  */
 extern void delay(int);				/* only scheddump() */
 extern int islo(void);
 extern void microdelay(int);			/* only edf.c */
-
-extern void validalign(uintptr, unsigned);
-
+extern void idlehands(void);
 extern void setkernur(Ureg*, Proc*);		/* only devproc.c */
 extern void* sysexecregs(uintptr, ulong, int);
 extern void sysprocsetup(Proc*);
+extern void validalign(uintptr, unsigned);
 
 extern void kexit(Ureg*);
 
@@ -137,6 +111,7 @@ extern void kexit(Ureg*);
 #define PTR2UINT(p)	((uintptr)(p))
 #define UINT2PTR(i)	((void*)(i))
 
+#define	waserror()	(up->nerrlab++, setlabel(&up->errlab[up->nerrlab-1]))
 
 #define KADDR(pa)	UINT2PTR(KZERO    | ((uintptr)(pa) & ~KSEGM))
 #define PADDR(va)	PTR2UINT(PHYSDRAM | ((uintptr)(va) & ~KSEGM))
diff -u -p -b -B -r -x .semantic.cache -x .depend -x CVS -x .hg -x .svn -x .git -x _darcs ./fpiarm.c /home/pad/work/plan9-github/sys/src/9/bcm/fpiarm.c
--- ./fpiarm.c	2017-01-10 11:37:11.000000000 -0800
+++ /home/pad/work/plan9-github/sys/src/9/bcm/fpiarm.c	2015-01-09 12:17:46.000000000 -0800
@@ -216,7 +216,7 @@ fcmp(Internal *n, Internal *m)
 }
 
 static void
-fld(void (*f)(Internal*, void*), int d, ulong ea, int n, ArchFPsave *ufp)
+fld(void (*f)(Internal*, void*), int d, ulong ea, int n, FPsave *ufp)
 {
 	void *mem;
 
@@ -227,7 +227,7 @@ fld(void (*f)(Internal*, void*), int d,
 }
 
 static void
-fst(void (*f)(void*, Internal*), ulong ea, int s, int n, ArchFPsave *ufp)
+fst(void (*f)(void*, Internal*), ulong ea, int s, int n, FPsave *ufp)
 {
 	Internal tmp;
 	void *mem;
@@ -292,7 +292,7 @@ unimp(ulong pc, ulong op)
 }
 
 static void
-fpemu(ulong pc, ulong op, Ureg *ur, ArchFPsave *ufp)
+fpemu(ulong pc, ulong op, Ureg *ur, FPsave *ufp)
 {
 	int rn, rd, tag, o;
 	long off;
@@ -465,7 +465,7 @@ int
 fpiarm(Ureg *ur)
 {
 	ulong op, o, cp;
-	ArchFPsave *ufp;
+	FPsave *ufp;
 	int n;
 
 	if(up == nil)
diff -u -p -b -B -r -x .semantic.cache -x .depend -x CVS -x .hg -x .svn -x .git -x _darcs ./init9.s /home/pad/work/plan9-github/sys/src/9/bcm/init9.s
--- ./init9.s	2015-10-17 09:32:22.000000000 -0700
+++ /home/pad/work/plan9-github/sys/src/9/bcm/init9.s	2015-01-09 12:17:46.000000000 -0800
@@ -1,25 +1 @@
-/*
- * This is the same as the C programme:
- *
- *	void
- *	main(char* argv0)
- *	{
- *		startboot(argv0, &argv0);
- *	}
- *
- * It is in assembler because SB needs to be
- * set and doing this in C drags in too many
- * other routines.
- */
-TEXT main(SB), 1, $8
-	MOVW	$setR12(SB), R12		/* load the SB */
-	MOVW	$boot(SB), R0
-
-	ADD	$12, R13, R1			/* pointer to 0(FP) */
-
-	MOVW	R0, 4(R13)			/* pass argc, argv */
-	MOVW	R1, 8(R13)
-
-	BL	startboot(SB)
-_loop:
-	B	_loop
+#include "../omap/init9.s"
diff -u -p -b -B -r -x .semantic.cache -x .depend -x CVS -x .hg -x .svn -x .git -x _darcs ./kbd.c /home/pad/work/plan9-github/sys/src/9/bcm/kbd.c
--- ./kbd.c	2017-01-16 21:37:25.000000000 -0800
+++ /home/pad/work/plan9-github/sys/src/9/bcm/kbd.c	2015-01-09 12:17:46.000000000 -0800
@@ -1,467 +1 @@
-/*
- * simulated keyboard input for systems with none (except via uart or usb)
- *
- * gutted version of ps2 version from ../pc
- */
-#include	"u.h"
-#include	"../port/lib.h"
-#include	"mem.h"
-#include	"dat.h"
-#include	"fns.h"
-#include	"io.h"
-#include	"../port/error.h"
-
-enum {
-	Spec=		0xF800,		/* Unicode private space */
-	PF=		Spec|0x20,	/* num pad function key */
-	View=		Spec|0x00,	/* view (shift window up) */
-	KF=		0xF000,		/* function key (begin Unicode private space) */
-	Shift=		Spec|0x60,
-	Break=		Spec|0x61,
-	Ctrl=		Spec|0x62,
-	Latin=		Spec|0x63,
-	Caps=		Spec|0x64,
-	Num=		Spec|0x65,
-	Middle=		Spec|0x66,
-	Altgr=		Spec|0x67,
-	Kmouse=		Spec|0x100,
-	No=		0x00,		/* peter */
-
-	Home=		KF|13,
-	Up=		KF|14,
-	Pgup=		KF|15,
-	Print=		KF|16,
-	Left=		KF|17,
-	Right=		KF|18,
-	End=		KF|24,
-	Down=		View,
-	Pgdown=		KF|19,
-	Ins=		KF|20,
-	Del=		0x7F,
-	Scroll=		KF|21,
-
-	Nscan=	128,
-
-	Int=	0,			/* kbscans indices */
-	Ext,
-	Nscans,
-};
-
-/*
- * The codes at 0x79 and 0x7b are produced by the PFU Happy Hacking keyboard.
- * A 'standard' keyboard doesn't produce anything above 0x58.
- */
-Rune kbtab[Nscan] =
-{
-[0x00]	No,	0x1b,	'1',	'2',	'3',	'4',	'5',	'6',
-[0x08]	'7',	'8',	'9',	'0',	'-',	'=',	'\b',	'\t',
-[0x10]	'q',	'w',	'e',	'r',	't',	'y',	'u',	'i',
-[0x18]	'o',	'p',	'[',	']',	'\n',	Ctrl,	'a',	's',
-[0x20]	'd',	'f',	'g',	'h',	'j',	'k',	'l',	';',
-[0x28]	'\'',	'`',	Shift,	'\\',	'z',	'x',	'c',	'v',
-[0x30]	'b',	'n',	'm',	',',	'.',	'/',	Shift,	'*',
-[0x38]	Latin,	' ',	Ctrl,	KF|1,	KF|2,	KF|3,	KF|4,	KF|5,
-[0x40]	KF|6,	KF|7,	KF|8,	KF|9,	KF|10,	Num,	Scroll,	'7',
-[0x48]	'8',	'9',	'-',	'4',	'5',	'6',	'+',	'1',
-[0x50]	'2',	'3',	'0',	'.',	No,	No,	No,	KF|11,
-[0x58]	KF|12,	No,	No,	No,	No,	No,	No,	No,
-[0x60]	No,	No,	No,	No,	No,	No,	No,	No,
-[0x68]	No,	No,	No,	No,	No,	No,	No,	No,
-[0x70]	No,	No,	No,	No,	No,	No,	No,	No,
-[0x78]	No,	View,	No,	Up,	No,	No,	No,	No,
-};
-
-Rune kbtabshift[Nscan] =
-{
-[0x00]	No,	0x1b,	'!',	'@',	'#',	'$',	'%',	'^',
-[0x08]	'&',	'*',	'(',	')',	'_',	'+',	'\b',	'\t',
-[0x10]	'Q',	'W',	'E',	'R',	'T',	'Y',	'U',	'I',
-[0x18]	'O',	'P',	'{',	'}',	'\n',	Ctrl,	'A',	'S',
-[0x20]	'D',	'F',	'G',	'H',	'J',	'K',	'L',	':',
-[0x28]	'"',	'~',	Shift,	'|',	'Z',	'X',	'C',	'V',
-[0x30]	'B',	'N',	'M',	'<',	'>',	'?',	Shift,	'*',
-[0x38]	Latin,	' ',	Ctrl,	KF|1,	KF|2,	KF|3,	KF|4,	KF|5,
-[0x40]	KF|6,	KF|7,	KF|8,	KF|9,	KF|10,	Num,	Scroll,	'7',
-[0x48]	'8',	'9',	'-',	'4',	'5',	'6',	'+',	'1',
-[0x50]	'2',	'3',	'0',	'.',	No,	No,	No,	KF|11,
-[0x58]	KF|12,	No,	No,	No,	No,	No,	No,	No,
-[0x60]	No,	No,	No,	No,	No,	No,	No,	No,
-[0x68]	No,	No,	No,	No,	No,	No,	No,	No,
-[0x70]	No,	No,	No,	No,	No,	No,	No,	No,
-[0x78]	No,	Up,	No,	Up,	No,	No,	No,	No,
-};
-
-Rune kbtabesc1[Nscan] =
-{
-[0x00]	No,	No,	No,	No,	No,	No,	No,	No,
-[0x08]	No,	No,	No,	No,	No,	No,	No,	No,
-[0x10]	No,	No,	No,	No,	No,	No,	No,	No,
-[0x18]	No,	No,	No,	No,	'\n',	Ctrl,	No,	No,
-[0x20]	No,	No,	No,	No,	No,	No,	No,	No,
-[0x28]	No,	No,	Shift,	No,	No,	No,	No,	No,
-[0x30]	No,	No,	No,	No,	No,	'/',	No,	Print,
-[0x38]	Altgr,	No,	No,	No,	No,	No,	No,	No,
-[0x40]	No,	No,	No,	No,	No,	No,	Break,	Home,
-[0x48]	Up,	Pgup,	No,	Left,	No,	Right,	No,	End,
-[0x50]	Down,	Pgdown,	Ins,	Del,	No,	No,	No,	No,
-[0x58]	No,	No,	No,	No,	No,	No,	No,	No,
-[0x60]	No,	No,	No,	No,	No,	No,	No,	No,
-[0x68]	No,	No,	No,	No,	No,	No,	No,	No,
-[0x70]	No,	No,	No,	No,	No,	No,	No,	No,
-[0x78]	No,	Up,	No,	No,	No,	No,	No,	No,
-};
-
-Rune kbtabshiftesc1[Nscan] =
-{
-[0x00]	No,	No,	No,	No,	No,	No,	No,	No,
-[0x08]	No,	No,	No,	No,	No,	No,	No,	No,
-[0x10]	No,	No,	No,	No,	No,	No,	No,	No,
-[0x18]	No,	No,	No,	No,	No,	No,	No,	No,
-[0x20]	No,	No,	No,	No,	No,	No,	No,	No,
-[0x28]	No,	No,	No,	No,	No,	No,	No,	No,
-[0x30]	No,	No,	No,	No,	No,	No,	No,	No,
-[0x38]	No,	No,	No,	No,	No,	No,	No,	No,
-[0x40]	No,	No,	No,	No,	No,	No,	No,	No,
-[0x48]	Up,	No,	No,	No,	No,	No,	No,	No,
-[0x50]	No,	No,	No,	No,	No,	No,	No,	No,
-[0x58]	No,	No,	No,	No,	No,	No,	No,	No,
-[0x60]	No,	No,	No,	No,	No,	No,	No,	No,
-[0x68]	No,	No,	No,	No,	No,	No,	No,	No,
-[0x70]	No,	No,	No,	No,	No,	No,	No,	No,
-[0x78]	No,	Up,	No,	No,	No,	No,	No,	No,
-};
-
-Rune kbtabctrlesc1[Nscan] =
-{
-[0x00]	No,	No,	No,	No,	No,	No,	No,	No,
-[0x08]	No,	No,	No,	No,	No,	No,	No,	No,
-[0x10]	No,	No,	No,	No,	No,	No,	No,	No,
-[0x18]	No,	No,	No,	No,	No,	No,	No,	No,
-[0x20]	No,	No,	No,	No,	No,	No,	No,	No,
-[0x28]	No,	No,	No,	No,	No,	No,	No,	No,
-[0x30]	No,	No,	No,	No,	No,	No,	No,	No,
-[0x38]	No,	No,	No,	No,	No,	No,	No,	No,
-[0x40]	No,	No,	No,	No,	No,	No,	No,	No,
-[0x48]	Up,	No,	No,	No,	No,	No,	No,	No,
-[0x50]	No,	No,	No,	No,	No,	No,	No,	No,
-[0x58]	No,	No,	No,	No,	No,	No,	No,	No,
-[0x60]	No,	No,	No,	No,	No,	No,	No,	No,
-[0x68]	No,	No,	No,	No,	No,	No,	No,	No,
-[0x70]	No,	No,	No,	No,	No,	No,	No,	No,
-[0x78]	No,	Up,	No,	No,	No,	No,	No,	No,
-};
-
-Rune kbtabaltgr[Nscan] =
-{
-[0x00]	No,	No,	No,	No,	No,	No,	No,	No,
-[0x08]	No,	No,	No,	No,	No,	No,	No,	No,
-[0x10]	No,	No,	No,	No,	No,	No,	No,	No,
-[0x18]	No,	No,	No,	No,	'\n',	Ctrl,	No,	No,
-[0x20]	No,	No,	No,	No,	No,	No,	No,	No,
-[0x28]	No,	No,	Shift,	No,	No,	No,	No,	No,
-[0x30]	No,	No,	No,	No,	No,	'/',	No,	Print,
-[0x38]	Altgr,	No,	No,	No,	No,	No,	No,	No,
-[0x40]	No,	No,	No,	No,	No,	No,	Break,	Home,
-[0x48]	Up,	Pgup,	No,	Left,	No,	Right,	No,	End,
-[0x50]	Down,	Pgdown,	Ins,	Del,	No,	No,	No,	No,
-[0x58]	No,	No,	No,	No,	No,	No,	No,	No,
-[0x60]	No,	No,	No,	No,	No,	No,	No,	No,
-[0x68]	No,	No,	No,	No,	No,	No,	No,	No,
-[0x70]	No,	No,	No,	No,	No,	No,	No,	No,
-[0x78]	No,	Up,	No,	No,	No,	No,	No,	No,
-};
-
-Rune kbtabctrl[Nscan] =
-{
-[0x00]	No,	'', 	'', 	'', 	'', 	'', 	'', 	'',
-[0x08]	'', 	'', 	'', 	'', 	'', 	'', 	'\b',	'\t',
-[0x10]	'', 	'', 	'', 	'', 	'', 	'', 	'', 	'\t',
-[0x18]	'', 	'', 	'', 	'', 	'\n',	Ctrl,	'', 	'',
-[0x20]	'', 	'', 	'', 	'\b',	'\n',	'', 	'', 	'',
-[0x28]	'', 	No, 	Shift,	'', 	'', 	'', 	'', 	'',
-[0x30]	'', 	'', 	'', 	'', 	'', 	'', 	Shift,	'\n',
-[0x38]	Latin,	No, 	Ctrl,	'', 	'', 	'', 	'', 	'',
-[0x40]	'', 	'', 	'', 	'', 	'', 	'', 	'', 	'',
-[0x48]	'', 	'', 	'', 	'', 	'', 	'', 	'', 	'',
-[0x50]	'', 	'', 	'', 	'', 	No,	No,	No,	'',
-[0x58]	'', 	No,	No,	No,	No,	No,	No,	No,
-[0x60]	No,	No,	No,	No,	No,	No,	No,	No,
-[0x68]	No,	No,	No,	No,	No,	No,	No,	No,
-[0x70]	No,	No,	No,	No,	No,	No,	No,	No,
-[0x78]	No,	'', 	No,	'\b',	No,	No,	No,	No,
-};
-
-int mouseshifted;
-void (*kbdmouse)(int);
-
-// now in main.c
-//bool kdebug;
-extern bool kdebug;
-
-typedef struct Kbscan Kbscan;
-struct Kbscan {
-	int	esc1;
-	int	esc2;
-	int	alt;
-	int	altgr;
-	int	caps;
-	int	ctl;
-	int	num;
-	int	shift;
-	int	collecting;
-	int	nk;
-	Rune	kc[5];
-	int	buttons;
-};
-
-Kbscan kbscans[Nscans];	/* kernel and external scan code state */
-
-/*
- * Scan code processing
- */
-void
-kbdputsc(int c, int external)
-{
-	int i, keyup;
-	Kbscan *kbscan;
-
-	if(external)
-		kbscan = &kbscans[Ext];
-	else
-		kbscan = &kbscans[Int];
-
-	if(kdebug)
-		print("sc %x ms %d\n", c, mouseshifted);
-	/*
-	 *  e0's is the first of a 2 character sequence, e1 the first
-	 *  of a 3 character sequence (on the safari)
-	 */
-	if(c == 0xe0){
-		kbscan->esc1 = 1;
-		return;
-	} else if(c == 0xe1){
-		kbscan->esc2 = 2;
-		return;
-	}
-
-	keyup = c & 0x80;
-	c &= 0x7f;
-	if(c > sizeof kbtab){
-		c |= keyup;
-		if(c != 0xFF)	/* these come fairly often: CAPSLOCK U Y */
-			print("unknown key %ux\n", c);
-		return;
-	}
-
-	if(kbscan->esc1 && kbscan->shift){
-		c = kbtabshiftesc1[c];
-		kbscan->esc1 = 0;
-	} else if(kbscan->esc1){
-		c = kbtabesc1[c];
-		kbscan->esc1 = 0;
-	} else if(kbscan->esc2){
-		kbscan->esc2--;
-		return;
-	} else if(kbscan->shift)
-		c = kbtabshift[c];
-	else if(kbscan->altgr)
-		c = kbtabaltgr[c];
-	else if(kbscan->ctl)
-		c = kbtabctrl[c];
-	else
-		c = kbtab[c];
-
-	if(kbscan->caps && c<='z' && c>='a')
-		c += 'A' - 'a';
-
-	/*
-	 *  keyup only important for shifts
-	 */
-	if(keyup){
-		switch(c){
-		case Latin:
-			kbscan->alt = 0;
-			break;
-		case Shift:
-			kbscan->shift = 0;
-			mouseshifted = 0;
-			if(kdebug)
-				print("shiftclr\n");
-			break;
-		case Ctrl:
-			kbscan->ctl = 0;
-			break;
-		case Altgr:
-			kbscan->altgr = 0;
-			break;
-		case Kmouse|1:
-		case Kmouse|2:
-		case Kmouse|3:
-		case Kmouse|4:
-		case Kmouse|5:
-			kbscan->buttons &= ~(1<<(c-Kmouse-1));
-			if(kbdmouse)
-				kbdmouse(kbscan->buttons);
-			break;
-		}
-		return;
-	}
-
-	/*
-	 *  normal character
-	 */
-	if(!(c & (Spec|KF))){
-		if(kbscan->ctl)
-			if(kbscan->alt && c == Del)
-				exit(0);
-		if(!kbscan->collecting){
-			kbdputc(c);
-			return;
-		}
-		kbscan->kc[kbscan->nk++] = c;
-		c = latin1(kbscan->kc, kbscan->nk);
-		if(c < -1)	/* need more keystrokes */
-			return;
-		if(c != -1)	/* valid sequence */
-			kbdputc(c);
-		else	/* dump characters */
-			for(i=0; i<kbscan->nk; i++)
-				kbdputc(kbscan->kc[i]);
-		kbscan->nk = 0;
-		kbscan->collecting = 0;
-		return;
-	} else {
-		switch(c){
-		case Caps:
-			kbscan->caps ^= 1;
-			return;
-		case Num:
-			kbscan->num ^= 1;
-			return;
-		case Shift:
-			kbscan->shift = 1;
-			if(kdebug)
-				print("shift\n");
-			mouseshifted = 1;
-			return;
-		case Latin:
-			kbscan->alt = 1;
-			/*
-			 * VMware and Qemu use Ctl-Alt as the key combination
-			 * to make the VM give up keyboard and mouse focus.
-			 * This has the unfortunate side effect that when you
-			 * come back into focus, Plan 9 thinks you want to type
-			 * a compose sequence (you just typed alt).
-			 *
-			 * As a clumsy hack around this, we look for ctl-alt and
-			 * don't treat it as the start of a compose sequence.
-			 */
-			if(!kbscan->ctl){
-				kbscan->collecting = 1;
-				kbscan->nk = 0;
-			}
-			return;
-		case Ctrl:
-			kbscan->ctl = 1;
-			return;
-		case Altgr:
-			kbscan->altgr = 1;
-			return;
-		case Kmouse|1:
-		case Kmouse|2:
-		case Kmouse|3:
-		case Kmouse|4:
-		case Kmouse|5:
-			kbscan->buttons |= 1<<(c-Kmouse-1);
-			if(kbdmouse)
-				kbdmouse(kbscan->buttons);
-			return;
-		case KF|11:
-			print("kbd debug on, F12 turns it off\n");
-			kdebug = 1;
-			break;
-		case KF|12:
-			kdebug = 0;
-			break;
-		}
-	}
-	kbdputc(c);
-}
-
-void
-kbdenable(void)
-{
-#ifdef notdef
-	kbdq = qopen(4*1024, 0, 0, 0);
-	if(kbdq == nil)
-		panic("kbdinit");
-	qnoblock(kbdq, 1);
-#endif
-	kbscans[Int].num = 0;
-}
-
-void
-kbdputmap(ushort m, ushort scanc, Rune r)
-{
-	if(scanc >= Nscan)
-		error(Ebadarg);
-	switch(m) {
-	default:
-		error(Ebadarg);
-	case 0:
-		kbtab[scanc] = r;
-		break;
-	case 1:
-		kbtabshift[scanc] = r;
-		break;
-	case 2:
-		kbtabesc1[scanc] = r;
-		break;
-	case 3:
-		kbtabaltgr[scanc] = r;
-		break;
-	case 4:
-		kbtabctrl[scanc] = r;
-		break;
-	case 5:
-		kbtabctrlesc1[scanc] = r;
-		break;
-	case 6:
-		kbtabshiftesc1[scanc] = r;
-		break;
-	}
-}
-
-int
-kbdgetmap(uint offset, int *t, int *sc, Rune *r)
-{
-	if ((int)offset < 0)
-		error(Ebadarg);
-	*t = offset/Nscan;
-	*sc = offset%Nscan;
-	switch(*t) {
-	default:
-		return 0;
-	case 0:
-		*r = kbtab[*sc];
-		return 1;
-	case 1:
-		*r = kbtabshift[*sc];
-		return 1;
-	case 2:
-		*r = kbtabesc1[*sc];
-		return 1;
-	case 3:
-		*r = kbtabaltgr[*sc];
-		return 1;
-	case 4:
-		*r = kbtabctrl[*sc];
-		return 1;
-	case 5:
-		*r = kbtabctrlesc1[*sc];
-		return 1;
-	case 6:
-		*r = kbtabshiftesc1[*sc];
-		return 1;
-	}
-}
+#include "../omap/kbd.c"
diff -u -p -b -B -r -x .semantic.cache -x .depend -x CVS -x .hg -x .svn -x .git -x _darcs ./l.s /home/pad/work/plan9-github/sys/src/9/bcm/l.s
--- ./l.s	2017-01-10 23:10:26.000000000 -0800
+++ /home/pad/work/plan9-github/sys/src/9/bcm/l.s	2017-01-17 12:05:54.000000000 -0800
@@ -35,7 +35,7 @@ TEXT _start(SB), 1, $-4
 	/*
 	 * clear mach and page tables
 	 */
-	MOVW	$PADDR(CPUADDR), R1
+	MOVW	$PADDR(MACHADDR), R1
 	MOVW	$PADDR(KTZERO), R2
 _ramZ:
 	MOVW	R0, (R1)
@@ -47,7 +47,7 @@ _ramZ:
 	 * start stack at top of mach (physical addr)
 	 * set up page tables for kernel
 	 */
-	MOVW	$PADDR(CPUADDR+CPUSIZE-4), R13
+	MOVW	$PADDR(MACHADDR+MACHSIZE-4), R13
 	BL	,mmuinit(SB)
 
 	/*
@@ -70,7 +70,7 @@ _ramZ:
 	 * switch SB, SP, and PC into KZERO space
 	 */
 	MOVW	$setR12(SB), R12
-	MOVW	$(CPUADDR+CPUSIZE-4), R13
+	MOVW	$(MACHADDR+MACHSIZE-4), R13
 	MOVW	$_startpg(SB), R15
 
 TEXT _startpg(SB), 1, $-4
@@ -105,10 +105,8 @@ TEXT lcycles(SB), 1, $-4
 	MRC	CpSC, 0, R0, C(CpSPM), C(CpSPMperf), CpSPMcyc
 	RET
 
-
-        
 TEXT splhi(SB), 1, $-4
-	MOVW	$(CPUADDR+4), R2		/* save caller pc in Mach */
+	MOVW	$(MACHADDR+4), R2		/* save caller pc in Mach */
 	MOVW	R14, 0(R2)
 
 	MOVW	CPSR, R0			/* turn off irqs (but not fiqs) */
@@ -117,7 +115,7 @@ TEXT splhi(SB), 1, $-4
 	RET
 
 TEXT splfhi(SB), 1, $-4
-	MOVW	$(CPUADDR+4), R2		/* save caller pc in Mach */
+	MOVW	$(MACHADDR+4), R2		/* save caller pc in Mach */
 	MOVW	R14, 0(R2)
 
 	MOVW	CPSR, R0			/* turn off irqs and fiqs */
@@ -138,7 +136,7 @@ TEXT spllo(SB), 1, $-4
 	RET
 
 TEXT splx(SB), 1, $-4
-	MOVW	$(CPUADDR+0x04), R2		/* save caller pc in Mach */
+	MOVW	$(MACHADDR+0x04), R2		/* save caller pc in Mach */
 	MOVW	R14, 0(R2)
 
 	MOVW	R0, R1				/* reset interrupt level */
diff -u -p -b -B -r -x .semantic.cache -x .depend -x CVS -x .hg -x .svn -x .git -x _darcs ./lexception.s /home/pad/work/plan9-github/sys/src/9/bcm/lexception.s
--- ./lexception.s	2017-01-10 15:53:36.000000000 -0800
+++ /home/pad/work/plan9-github/sys/src/9/bcm/lexception.s	2015-01-09 12:17:46.000000000 -0800
@@ -39,8 +39,8 @@ TEXT _vsvc(SB), 1, $-4			/* SWI */
 
 	MOVW	$setR12(SB), R12	/* Make sure we've got the kernel's SB loaded */
 
-//	MOVW	$(KSEG0+16*KiB-CPUSIZE), R10	/* m */
-	MOVW	$(CPUADDR), R10	/* m */
+//	MOVW	$(KSEG0+16*KiB-MACHSIZE), R10	/* m */
+	MOVW	$(MACHADDR), R10	/* m */
 	MOVW	8(R10), R9		/* up */
 
 	MOVW	R13, R0			/* first arg is pointer to ureg */
@@ -140,8 +140,8 @@ _userexcep:
 
 	MOVW	$setR12(SB), R12	/* Make sure we've got the kernel's SB loaded */
 
-//	MOVW	$(KSEG0+16*KiB-CPUSIZE), R10	/* m */
-	MOVW	$(CPUADDR), R10	/* m */
+//	MOVW	$(KSEG0+16*KiB-MACHSIZE), R10	/* m */
+	MOVW	$(MACHADDR), R10	/* m */
 	MOVW	8(R10), R9		/* up */
 
 	MOVW	R13, R0			/* first arg is pointer to ureg */
@@ -164,7 +164,7 @@ TEXT _vfiq(SB), 1, $-4			/* FIQ */
 	MOVM.DB.W [R8-R10], (R13)	/* save in ureg */
 	MOVM.DB.W.S [R0-R14], (R13)	/* save interrupted regs */
 	MOVW	$setR12(SB), R12	/* Make sure we've got the kernel's SB loaded */
-	MOVW	$(CPUADDR), R10	/* m */
+	MOVW	$(MACHADDR), R10	/* m */
 	MOVW	8(R10), R9		/* up */
 	MOVW	R13, R0			/* first arg is pointer to ureg */
 	SUB	$(4*2), R13		/* space for argument+link (for debugger) */
diff -u -p -b -B -r -x .semantic.cache -x .depend -x CVS -x .hg -x .svn -x .git -x _darcs ./lproc.s /home/pad/work/plan9-github/sys/src/9/bcm/lproc.s
--- ./lproc.s	2015-10-17 09:32:22.000000000 -0700
+++ /home/pad/work/plan9-github/sys/src/9/bcm/lproc.s	2015-01-09 12:17:46.000000000 -0800
@@ -1,47 +1 @@
-#include "mem.h"
-#include "arm.h"
-
-/*
- *  This is the first jump from kernel to user mode.
- *  Fake a return from interrupt.
- *
- *  Enter with R0 containing the user stack pointer.
- *  UTZERO + 0x20 is always the entry point.
- *
- */
-TEXT touser(SB), 1, $-4
-	/* store the user stack pointer into the USR_r13 */
-	MOVM.DB.W [R0], (R13)
-	/* avoid the ambiguity described in notes/movm.w. */
-//	MOVM.S.IA.W (R13), [R13]
-	MOVM.S	(R13), [R13]
-	ADD	$4, R13
-
-	/* set up a PSR for user level */
-	MOVW	$(PsrMusr), R0
-	MOVW	R0, SPSR
-
-	/* save the PC on the stack */
-	MOVW	$(UTZERO+0x20), R0
-	MOVM.DB.W [R0], (R13)
-
-	/*
-	 * note that 5a's RFE is not the v6 arch. instruction (0xe89d0a00,
-	 * I think), which loads CPSR from the word after the PC at (R13),
-	 * but rather the pre-v6 simulation `MOVM.IA.S.W (R13), [R15]'
-	 * (0xe8fd8000 since MOVM is LDM in this case), which loads CPSR
-	 * not from memory but from SPSR due to `.S'.
-	 */
-	RFE
-
-/*
- *  here to jump to a newly forked process
- */
-TEXT forkret(SB), 1, $-4
-	ADD	$(4*15), R13		/* make r13 point to ureg->type */
-	MOVW	8(R13), R14		/* restore link */
-	MOVW	4(R13), R0		/* restore SPSR */
-	MOVW	R0, SPSR		/* ... */
-	MOVM.DB.S (R13), [R0-R14]	/* restore registers */
-	ADD	$8, R13			/* pop past ureg->{type+psr} */
-	RFE				/* MOVM.IA.S.W (R13), [R15] */
+#include "../omap/lproc.s"
diff -u -p -b -B -r -x .semantic.cache -x .depend -x CVS -x .hg -x .svn -x .git -x _darcs ./main.c /home/pad/work/plan9-github/sys/src/9/bcm/main.c
--- ./main.c	2017-01-16 20:39:12.000000000 -0800
+++ /home/pad/work/plan9-github/sys/src/9/bcm/main.c	2017-01-17 12:06:42.000000000 -0800
@@ -5,13 +5,14 @@
 #include "dat.h"
 #include "fns.h"
 
-// initcode binary
 #include "init.h"
 #include <pool.h>
 
-// rebootcode binary
 #include "reboot.h"
 
+void (*coherence)(void);
+
+
 enum {
 	/* space for syscall args, return PC, top-of-stack struct */
 	Ustkheadroom	= sizeof(Sargs) + sizeof(uintptr) + sizeof(Tos),
@@ -25,22 +26,13 @@ enum {
  * Where configuration info is left for the loaded programme.
  */
 #define BOOTARGS	((char*)CONFADDR)
-#define	BOOTARGSLEN	(CPUADDR-CONFADDR)
-
+#define	BOOTARGSLEN	(MACHADDR-CONFADDR)
+#define	MAXCONF		64
 #define MAXCONFLINE	160
 
-// conf.c
-extern  Dev*  conf_devtab[];
-
-
-extern	char*	conffile;
-
-// in l.s
-extern void    coherence1(void);
-
-
 uintptr kseg0 = KZERO;
-
+Mach*	machaddr[MAXMACH];
+Conf	conf;
 ulong	memsize = 128*1024*1024;
 
 /*
@@ -55,9 +47,9 @@ static int oargblen;
 static uintptr sp;		/* XXX - must go - user stack of init proc */
 
 /* store plan9.ini contents here at least until we stash them in #ec */
-//TODO: now in portdat.h
-//static char confname[MAXCONF][KNAMELEN];
-//static char confval[MAXCONF][MAXCONFLINE];
+static char confname[MAXCONF][KNAMELEN];
+static char confval[MAXCONF][MAXCONFLINE];
+static int nconf;
 
 typedef struct Atag Atag;
 struct Atag {
@@ -98,9 +90,9 @@ getconf(char *name)
 {
 	int i;
 
-//	i = findconf(name);
-//	if(i >= 0)
-//		return confval[i];
+	//i = findconf(name);
+	//if(i >= 0)
+	//	return confval[i];
 	return nil;
 }
 
@@ -207,15 +199,15 @@ ataginit(Atag *a)
 void
 machinit(void)
 {
-	cpu->cpuno = 0;
-	cpus[cpu->cpuno] = cpu;
+	m->machno = 0;
+	machaddr[m->machno] = m;
 
-	cpu->ticks = 1;
-	cpu->perf.period = 1;
+	m->ticks = 1;
+	m->perf.period = 1;
 
-	conf.ncpu = 1;
+	conf.nmach = 1;
 
-	active.cpus = 1;
+	active.machs = 1;
 	active.exiting = 0;
 
 	up = nil;
@@ -237,13 +229,10 @@ main(void)
 	extern char edata[], end[];
 	uint rev;
     
-    iprint = devcons_iprint;
-    //hook_ioalloc = devarch_hook_ioalloc;
-    devtab = conf_devtab;
     coherence = coherence1;
 
 	okay(1);
-	cpu = (Cpu*)CPUADDR;
+	m = (Mach*)MACHADDR;
 	memset(edata, 0, end - edata);	/* clear bss */
 	machinit();
 	mmuinit1();
@@ -266,26 +255,21 @@ main(void)
 		for(;;)
 			;
 	}
-
 	trapinit();
 	clockinit();
-	lineqinit();
+	printinit();
 	timersinit();
-
+	if(conf.monitor)
 		swcursorinit();
-
 	cpuidprint();
 	archreset();
 
-	procinit();
-	imageinit();
-
+	procinit0();
+	initseg();
 	links();
 	chandevreset();			/* most devices are discovered here */
-
 	pageinit();
 	swapinit();
-
 	userinit();
 	schedinit();
 	assert(0);			/* shouldn't have returned */
@@ -401,9 +385,7 @@ userinit(void)
 	 * Kernel Stack
 	 */
 	p->sched.pc = PTR2UINT(init0);
-	p->sched.sp = PTR2UINT(p->kstack + KSTACK 
-                           - sizeof(up->sargs.args)
-                           - sizeof(uintptr));
+	p->sched.sp = PTR2UINT(p->kstack+KSTACK-sizeof(up->s.args)-sizeof(uintptr));
 	p->sched.sp = STACKALIGN(p->sched.sp);
 
 	/*
@@ -415,7 +397,7 @@ userinit(void)
 	 * shouldn't be the case here.
 	 */
 	s = newseg(SG_STACK, USTKTOP-USTKSIZE, USTKSIZE/BY2PG);
-	s->flushme = true;
+	s->flushme++;
 	p->seg[SSEG] = s;
 	pg = newpage(1, 0, USTKTOP-BY2PG);
 	segpage(s, pg);
@@ -431,7 +413,7 @@ userinit(void)
 	pg = newpage(1, 0, UTZERO);
 	memset(pg->cachectl, PG_TXTFLUSH, sizeof(pg->cachectl));
 	segpage(s, pg);
-	k = kmap(s->pagedir[0]->pagetab[0]);
+	k = kmap(s->map[0]->pages[0]);
 	memmove(UINT2PTR(VA(k)), initcode, sizeof initcode);
 	kunmap(k);
 
@@ -485,7 +467,7 @@ confinit(void)
 	conf.ialloc = ((conf.npage-conf.upages)/2)*BY2PG;
 
 	/* only one processor */
-	conf.ncpu = 1;
+	conf.nmach = 1;
 
 	/* set up other configuration parameters */
 	conf.nproc = 100 + ((conf.npage*BY2PG)/MB)*5;
@@ -508,9 +490,9 @@ confinit(void)
 	kpages *= BY2PG;
 	kpages -= conf.upages*sizeof(Page)
 		+ conf.nproc*sizeof(Proc)
-		+ conf.nimage*sizeof(KImage)
+		+ conf.nimage*sizeof(Image)
 		+ conf.nswap
-		+ conf.nswppo*sizeof(Page); // BUG, Page -> Page*?
+		+ conf.nswppo*sizeof(Page);
 	mainmem->maxsize = kpages;
 	if(!cpuserver)
 		/*
@@ -530,19 +512,19 @@ shutdown(int ispanic)
 	lock(&active);
 	if(ispanic)
 		active.ispanic = ispanic;
-	else if(cpu->cpuno == 0 && (active.cpus & (1 << cpu->cpuno)) == 0)
+	else if(m->machno == 0 && (active.machs & (1<<m->machno)) == 0)
 		active.ispanic = 0;
-	once = active.cpus & (1 << cpu->cpuno);
-	active.cpus &= ~(1 << cpu->cpuno);
+	once = active.machs & (1<<m->machno);
+	active.machs &= ~(1<<m->machno);
 	active.exiting = 1;
 	unlock(&active);
 
 	if(once)
-		iprint("cpu%d: exiting\n", cpu->cpuno);
+		iprint("cpu%d: exiting\n", m->machno);
 	spllo();
 	for(ms = 5*1000; ms > 0; ms -= TK2MS(2)){
 		delay(TK2MS(2));
-		if(active.cpus == 0 && consactive() == 0)
+		if(active.machs == 0 && consactive() == 0)
 			break;
 	}
 	delay(1000);
@@ -623,18 +605,3 @@ cmpswap(long *addr, long old, long new)
 {
 	return cas32(addr, old, new);
 }
-
-// called from devcons.c
-void
-memorysummary(void) {
-}
-
-ulong
-us(void)
-{
-  return -1;
-}
-
-bool kdebug;
-
-
diff -u -p -b -B -r -x .semantic.cache -x .depend -x CVS -x .hg -x .svn -x .git -x _darcs ./mem.h /home/pad/work/plan9-github/sys/src/9/bcm/mem.h
--- ./mem.h	2017-01-12 11:31:55.000000000 -0800
+++ /home/pad/work/plan9-github/sys/src/9/bcm/mem.h	2017-01-17 12:05:38.000000000 -0800
@@ -11,8 +11,8 @@
 #define	BY2PG		(4*KiB)			/* bytes per page */
 #define	PGSHIFT		12			/* log(BY2PG) */
 
-#define	MAXCPUS		1			/* max # cpus system can run */
-#define	CPUSIZE	BY2PG
+#define	MAXMACH		1			/* max # cpus system can run */
+#define	MACHSIZE	BY2PG
 
 #define KSTKSIZE	(8*KiB)
 #define STACKALIGN(sp)	((sp) & ~3)		/* bug: assure with alloc */
@@ -32,9 +32,7 @@
 #define	KSEGM		0xE0000000
 #define	KZERO		KSEG0			/* kernel address space */
 #define CONFADDR	(KZERO+0x100)		/* unparsed plan9.ini */
-
-#define	CPUADDR	(KZERO+0x2000)		/* Cpu structure */
-
+#define	MACHADDR	(KZERO+0x2000)		/* Mach structure */
 #define	L2		    (KZERO+0x3000)		/* L2 ptes for vectors etc */
 #define	VCBUFFER	(KZERO+0x3400)		/* videocore mailbox buffer */
 #define	FIQSTKTOP	(KZERO+0x4000)		/* FIQ stack */
@@ -70,12 +67,10 @@
 #define BY2V		8			/* only used in xalloc.c */
 
 #define CACHELINESZ	32
-
-#define	PAGETABMAPMEM	(1024*1024)
-#define	PAGETABSIZE	(PAGETABMAPMEM/BY2PG)
-
-#define	PAGEDIRSIZE	1984
-#define	SMALLPAGEDIRSIZE	16
+#define	PTEMAPMEM	(1024*1024)
+#define	PTEPERTAB	(PTEMAPMEM/BY2PG)
+#define	SEGMAPSIZE	1984
+#define	SSEGMAPSIZE	16
 #define	PPN(x)		((x)&~(BY2PG-1))
 
 /*
diff -u -p -b -B -r -x .semantic.cache -x .depend -x CVS -x .hg -x .svn -x .git -x _darcs ./mkfile /home/pad/work/plan9-github/sys/src/9/bcm/mkfile
--- ./mkfile	2017-01-17 11:46:31.000000000 -0800
+++ /home/pad/work/plan9-github/sys/src/9/bcm/mkfile	2017-01-13 18:08:03.000000000 -0800
@@ -1,44 +1,31 @@
-
-# CONF is the configuration file, processed by many mkxxx scripts
 CONF=pi
-CONFLIST=pi
+CONFLIST=pi picpu pifat
+EXTRACOPIES=
+
+loadaddr=0x80008000
 
 objtype=arm
 </$objtype/mkfile
 p=9
 
-# The Raspberry Pi loads the kernel at 0x8000 Physical, but we link
-# the kernel at high address space above 0x80000000 because that's where
-# the kernel will be virtually, so 0x80000000 + 0x8000 = 0x80008000
-# (see also KTZERO in mem.h)
-loadaddr=0x80008000
-
 DEVS=`{rc ../port/mkdevlist $CONF}
 
 PORT=\
-     portfns.$O\
-     portdat.$O\
-	 portdat_memory.$O\
-	 portdat_processes.$O\
 	alarm.$O\
- 	 pool.$O\
 	alloc.$O\
-	 sysmemory.$O\
 	allocb.$O\
 	auth.$O\
 	cache.$O\
-	mnt.$O\
 	chan.$O\
 	dev.$O\
-	env.$O\
 	edf.$O\
 	fault.$O\
+	mul64fract.$O\
 	page.$O\
 	parse.$O\
 	pgrp.$O\
 	portclock.$O\
 	print.$O\
-     error.$O\
 	proc.$O\
 	qio.$O\
 	qlock.$O\
@@ -46,19 +33,12 @@ PORT=\
 	rebootcmd.$O\
 	segment.$O\
 	swap.$O\
-	file.$O\
+	syscallfmt.$O\
 	sysfile.$O\
- 	 syssema.$O\
 	sysproc.$O\
-     systab.$O\
-    syscallfmt.$O\
 	taslock.$O\
-     ref.$O\
 	tod.$O\
 	xalloc.$O\
-     portscreen.$O\
-    \
-	mul64fract.$O\
 
 OBJ=\
 	l.$O\
@@ -79,42 +59,56 @@ OBJ=\
 	$DEVS\
 	$PORT\
 
-# the order matters!
+# HFILES=
+
 LIB=\
 	/$objtype/lib/libmemlayer.a\
 	/$objtype/lib/libmemdraw.a\
 	/$objtype/lib/libdraw.a\
 	/$objtype/lib/libip.a\
+	/$objtype/lib/libsec.a\
+	/$objtype/lib/libmp.a\
 	/$objtype/lib/libc.a\
 
-9:V: $p$CONF
-
-DATE=`{date -n}
+9:V: $p$CONF s$p$CONF
 
-# use of -l so no automagic lib and no _main
 $p$CONF:D:	$CONF.c $OBJ $LIB mkfile
-	$CC $CFLAGS '-DKERNDATE='$DATE $CONF.c
+	$CC $CFLAGS '-DKERNDATE='`{date -n} $CONF.c
 	echo '# linking raw kernel'	# H6: no headers, data segment aligned
-	$LD -f -o $target -H6 -R4096 -T$loadaddr -l $OBJ $CONF.$O $LIB
-
-
-install:V: $p$CONF
-	cp $p$CONF /$objtype/
+	$LD -f -l -o $target -H6 -R4096 -T$loadaddr $OBJ $CONF.$O $LIB
 
+s$p$CONF:DQ:	$CONF.$O $OBJ $LIB
+	echo '# linking kernel with symbols'
+	$LD -l  -o $target -R4096 -T$loadaddr $OBJ $CONF.$O $LIB
+	#size $target
+
+$p$CONF.gz:D:	$p$CONF
+	gzip -9 <$p$CONF >$target
+
+$OBJ: $HFILES
+
+install:V: /$objtype/$p$CONF
+
+/$objtype/$p$CONF:D: $p$CONF s$p$CONF
+	cp -x $p$CONF s$p$CONF /$objtype/ &
+	for(i in $EXTRACOPIES)
+		{ 9fs $i && cp $p$CONF s$p$CONF /n/$i/$objtype && echo -n $i... & }
+	wait
+	echo
+	touch $target
 
 <../boot/bootmkfile
 <../port/portmkfile
 <|../port/mkbootrules $CONF
 
-#TODO: should be done via 'mk depend'
-
-arch.$O clockbcm.$O fpiarm.$O main.$O mmu.$O screen.$O syscall.$O trap.$O: \
+arch.$O clock.$O fpiarm.$O main.$O mmu.$O screen.$O syscall.$O trap.$O: \
 	/$objtype/include/ureg.h
-archbcm.$O devether.$O: etherif.h ../port/netif.h
+
+archbcm.$O devether.$0: etherif.h ../port/netif.h
 archbcm.$O: ../port/flashif.h
 fpi.$O fpiarm.$O fpimem.$O: ../port/fpi.h
 l.$O lexception.$O lproc.$O mmu.$O: arm.s mem.h
-main.$O: init.h reboot.h
+main.$O: errstr.h init.h reboot.h
 devmouse.$O mouse.$O screen.$O: screen.h
 devusb.$O: ../port/usb.h
 usbehci.$O usbohci.$O usbuhci.$O: ../port/usb.h usbehci.h uncached.h
diff -u -p -b -B -r -x .semantic.cache -x .depend -x CVS -x .hg -x .svn -x .git -x _darcs ./mmu.c /home/pad/work/plan9-github/sys/src/9/bcm/mmu.c
--- ./mmu.c	2017-01-16 18:42:33.000000000 -0800
+++ /home/pad/work/plan9-github/sys/src/9/bcm/mmu.c	2015-01-09 12:17:46.000000000 -0800
@@ -60,7 +60,7 @@ mmuinit1(void)
 	PTE *l1;
 
 	l1 = (PTE*)L1;
-	cpu->mmul1 = l1;
+	m->mmul1 = l1;
 
 	/*
 	 * undo identity map of first MB of ram
@@ -76,7 +76,7 @@ mmul2empty(Proc* proc, int clear)
 	PTE *l1;
 	Page **l2, *page;
 
-	l1 = cpu->mmul1;
+	l1 = m->mmul1;
 	l2 = &proc->mmul2;
 	for(page = *l2; page != nil; page = page->next){
 		if(clear)
@@ -97,23 +97,23 @@ mmul1empty(void)
 	PTE *l1;
 
 	/* clean out any user mappings still in l1 */
-	if(cpu->mmul1lo > L1lo){
-		if(cpu->mmul1lo == 1)
-			cpu->mmul1[L1lo] = Fault;
+	if(m->mmul1lo > L1lo){
+		if(m->mmul1lo == 1)
+			m->mmul1[L1lo] = Fault;
 		else
-			memset(&cpu->mmul1[L1lo], 0, cpu->mmul1lo*sizeof(PTE));
-		cpu->mmul1lo = L1lo;
+			memset(&m->mmul1[L1lo], 0, m->mmul1lo*sizeof(PTE));
+		m->mmul1lo = L1lo;
 	}
-	if(cpu->mmul1hi < L1hi){
-		l1 = &cpu->mmul1[cpu->mmul1hi];
-		if((L1hi - cpu->mmul1hi) == 1)
+	if(m->mmul1hi < L1hi){
+		l1 = &m->mmul1[m->mmul1hi];
+		if((L1hi - m->mmul1hi) == 1)
 			*l1 = Fault;
 		else
-			memset(l1, 0, (L1hi - cpu->mmul1hi)*sizeof(PTE));
-		cpu->mmul1hi = L1hi;
+			memset(l1, 0, (L1hi - m->mmul1hi)*sizeof(PTE));
+		m->mmul1hi = L1hi;
 	}
 #else
-	memset(&cpu->mmul1[L1lo], 0, (L1hi - L1lo)*sizeof(PTE));
+	memset(&m->mmul1[L1lo], 0, (L1hi - L1lo)*sizeof(PTE));
 #endif /* notdef */
 }
 
@@ -125,9 +125,9 @@ mmuswitch(Proc* proc)
 	Page *page;
 
 	/* do kprocs get here and if so, do they need to? */
-	if(cpu->mmupid == proc->pid && !proc->newtlb)
+	if(m->mmupid == proc->pid && !proc->newtlb)
 		return;
-	cpu->mmupid = proc->pid;
+	m->mmupid = proc->pid;
 
 	/* write back dirty and invalidate l1 caches */
 	cacheuwbinv();
@@ -140,15 +140,15 @@ mmuswitch(Proc* proc)
 	mmul1empty();
 
 	/* move in new map */
-	l1 = cpu->mmul1;
+	l1 = m->mmul1;
 	for(page = proc->mmul2; page != nil; page = page->next){
 		x = page->daddr;
 		l1[x] = PPN(page->pa)|Dom0|Coarse;
 		/* know here that L1lo < x < L1hi */
-		if(x+1 - cpu->mmul1lo < cpu->mmul1hi - x)
-			cpu->mmul1lo = x+1;
+		if(x+1 - m->mmul1lo < m->mmul1hi - x)
+			m->mmul1lo = x+1;
 		else
-			cpu->mmul1hi = x;
+			m->mmul1hi = x;
 	}
 
 	/* make sure map is in memory */
@@ -185,15 +185,15 @@ mmurelease(Proc* proc)
 			panic("mmurelease: page->ref %d", page->ref);
 		pagechainhead(page);
 	}
-	if(proc->mmul2cache && palloc.freememr.p)
-		wakeup(&palloc.freememr);
+	if(proc->mmul2cache && palloc.r.p)
+		wakeup(&palloc.r);
 	proc->mmul2cache = nil;
 
 	mmul1empty();
 
 	/* make sure map is in memory */
 	/* could be smarter about how much? */
-	cachedwbse(&cpu->mmul1[L1X(UZERO)], (L1hi - L1lo)*sizeof(PTE));
+	cachedwbse(&m->mmul1[L1X(UZERO)], (L1hi - L1lo)*sizeof(PTE));
 
 	/* lose any possible stale tlb entries */
 	mmuinvalidate();
@@ -207,7 +207,7 @@ putmmu(uintptr va, uintptr pa, Page* pag
 	PTE *l1, *pte;
 
 	x = L1X(va);
-	l1 = &cpu->mmul1[x];
+	l1 = &m->mmul1[x];
 	if(*l1 == Fault){
 		/* wasteful - l2 pages only have 256 entries - fix */
 		if(up->mmul2cache == nil){
@@ -230,11 +230,11 @@ putmmu(uintptr va, uintptr pa, Page* pag
 		*l1 = PPN(pg->pa)|Dom0|Coarse;
 		cachedwbse(l1, sizeof *l1);
 
-		if(x >= cpu->mmul1lo && x < cpu->mmul1hi){
-			if(x+1 - cpu->mmul1lo < cpu->mmul1hi - x)
-				cpu->mmul1lo = x+1;
+		if(x >= m->mmul1lo && x < m->mmul1hi){
+			if(x+1 - m->mmul1lo < m->mmul1hi - x)
+				m->mmul1lo = x+1;
 			else
-				cpu->mmul1hi = x;
+				m->mmul1hi = x;
 		}
 	}
 	pte = UINT2PTR(KADDR(PPN(*l1)));
@@ -295,7 +295,7 @@ mmukmap(uintptr va, uintptr pa, usize si
 	o = pa & (MiB-1);
 	pa -= o;
 	size += o;
-	pte = pte0 = &cpu->mmul1[L1X(va)];
+	pte = pte0 = &m->mmul1[L1X(va)];
 	for(n = 0; n < size; n += MiB)
 		if(*pte++ != Fault)
 			return 0;
diff -u -p -b -B -r -x .semantic.cache -x .depend -x CVS -x .hg -x .svn -x .git -x _darcs ./mouse.c /home/pad/work/plan9-github/sys/src/9/bcm/mouse.c
--- ./mouse.c	2017-01-17 11:46:31.000000000 -0800
+++ /home/pad/work/plan9-github/sys/src/9/bcm/mouse.c	2015-01-09 12:17:46.000000000 -0800
@@ -1,257 +1 @@
-#include "u.h"
-#include "../port/lib.h"
-#include "mem.h"
-#include "dat.h"
-#include "fns.h"
-#include "../port/error.h"
-#include "io.h"
-
-#define	Image	IMAGE
-#include <draw.h>
-#include <memdraw.h>
-#include <cursor.h>
-
-#include "screen.h"
-
-/*
- *  mouse types
- */
-enum
-{
-	Mouseother=	0,
-	Mouseserial=	1,
-	MousePS2=	2,
-};
-
-extern int mouseshifted;
-
-static QLock mousectlqlock;
-static int mousetype;
-static int intellimouse;
-static int packetsize;
-static int resolution;
-static int accelerated;
-static int mousehwaccel;
-static char mouseport[5];
-
-enum
-{
-	CMaccelerated,
-	CMhwaccel,
-	CMintellimouse,
-	CMlinear,
-	CMps2,
-	CMps2intellimouse,
-	CMres,
-	CMreset,
-	CMserial,
-};
-
-static Cmdtab mousectlmsg[] =
-{
-	CMaccelerated,		"accelerated",		0,
-	CMhwaccel,		"hwaccel",		2,
-	CMintellimouse,		"intellimouse",		1,
-	CMlinear,		"linear",		1,
-	CMps2,			"ps2",			1,
-	CMps2intellimouse,	"ps2intellimouse",	1,
-	CMres,			"res",			0,
-	CMreset,		"reset",		1,
-	CMserial,		"serial",		0,
-};
-
-/*
- *  ps/2 mouse message is three bytes
- *
- *	byte 0 -	0 0 SDY SDX 1 M R L
- *	byte 1 -	DX
- *	byte 2 -	DY
- *
- *  shift & right button is the same as middle button
- *
- * Intellimouse and AccuPoint with extra buttons deliver
- *	byte 3 -	00 or 01 or FF according to extra button state.
- * extra buttons are mapped in this code to buttons 4 and 5.
- * AccuPoint generates repeated events for these buttons;
-*  it and Intellimouse generate 'down' events only, so
- * user-level code is required to generate button 'up' events
- * if they are needed by the application.
- * Also on laptops with AccuPoint AND external mouse, the
- * controller may deliver 3 or 4 bytes according to the type
- * of the external mouse; code must adapt.
- *
- * On the NEC Versa series (and perhaps others?) we seem to
- * lose a byte from the packet every once in a while, which
- * means we lose where we are in the instruction stream.
- * To resynchronize, if we get a byte more than two seconds
- * after the previous byte, we assume it's the first in a packet.
- */
-static void
-ps2mouseputc(int c, int shift)
-{
-	static short msg[4];
-	static int nb;
-	static uchar b[] = {0, 1, 4, 5, 2, 3, 6, 7, 0, 1, 2, 3, 2, 3, 6, 7 };
-	static ulong lasttick;
-	ulong m;
-	int buttons, dx, dy;
-
-	shift |= mouseshifted;
-	m = CPUS(0)->ticks;
-	if(TK2SEC(m - lasttick) > 2)
-		nb = 0;
-	lasttick = m;
-	if(nb==0 && (c&0xc8)!=0x08)
-		if(intellimouse && (c==0x00 || c==0x01 || c==0xFF)){
-			packetsize = 4;
-			return;
-		}
-
-	msg[nb] = c;
-	if(++nb == packetsize){
-		nb = 0;
-		if(msg[0] & 0x10)
-			msg[1] |= 0xFF00;
-		if(msg[0] & 0x20)
-			msg[2] |= 0xFF00;
-
-		buttons = b[(msg[0]&7) | (shift ? 8 : 0)];
-		if(intellimouse && packetsize==4){
-			if((msg[3]&0xc8) == 0x08){
-				packetsize = 3;
-				msg[0] = msg[3];
-				nb = 1;
-			}else{
-				if((msg[3] >> 3) & 1)
-					buttons |= 1<<3;
-				else if(msg[3] & 0x7)
-					buttons |= 1<<4;
-			}
-		}
-		dx = msg[1];
-		dy = -msg[2];
-		mousetrack(dx, dy, buttons, TK2MS(CPUS(0)->ticks));
-	}
-}
-
-/*
- *  set up a ps2 mouse
- */
-static void
-ps2mouse(void)
-{
-	if(mousetype == MousePS2)
-		return;
-
-//	i8042auxenable(ps2mouseputc);
-//	i8042auxcmd(0xEA);	// TODO
-//	i8042auxcmd(0xF4);
-
-	mousetype = MousePS2;
-	packetsize = 3;
-	mousehwaccel = 1;
-}
-
-/*
- * The PS/2 Trackpoint multiplexor on the IBM Thinkpad T23 ignores
- * acceleration commands.  It is supposed to pass them on
- * to the attached device, but my Logitech mouse is simply
- * not behaving any differently.  For such devices, we allow
- * the user to use "hwaccel off" to tell us to back off to
- * software acceleration even if we're using the PS/2 port.
- * (Serial mice are always software accelerated.)
- * For more information on the Thinkpad multiplexor, see
- * http://wwwcssrv.almaden.ibm.com/trackpoint/
- */
-static void
-setaccelerated(int x)
-{
-	accelerated = x;
-	mouseaccelerate(x);
-}
-
-static void
-setlinear(void)
-{
-	accelerated = 0;
-	mouseaccelerate(0);
-}
-
-static void
-setres(int n)
-{
-	resolution = n;
-}
-
-static void
-setintellimouse(void)
-{
-	intellimouse = 1;
-	packetsize = 4;
-}
-
-static void
-resetmouse(void)
-{
-	packetsize = 3;
-}
-
-// for screen.h
-void
-kmousectl(Cmdbuf *cb)
-{
-	Cmdtab *ct;
-
-	qlock(&mousectlqlock);
-	if(waserror()){
-		qunlock(&mousectlqlock);
-		nexterror();
-	}
-
-	ct = lookupcmd(cb, mousectlmsg, nelem(mousectlmsg));
-	switch(ct->index){
-	case CMaccelerated:
-		setaccelerated(cb->nf == 1? 1: atoi(cb->f[1]));
-		break;
-	case CMintellimouse:
-		setintellimouse();
-		break;
-	case CMlinear:
-		setlinear();
-		break;
-	case CMps2:
-		intellimouse = 0;
-		break;
-	case CMps2intellimouse:
-		setintellimouse();
-		break;
-	case CMres:
-		if(cb->nf >= 2)
-			setres(atoi(cb->f[1]));
-		else
-			setres(1);
-		break;
-	case CMreset:
-		resetmouse();
-		if(accelerated)
-			setaccelerated(accelerated);
-		if(resolution)
-			setres(resolution);
-		if(intellimouse)
-			setintellimouse();
-		break;
-	case CMserial:
-		error("serial mice not supported");
-		break;
-	case CMhwaccel:
-		if(strcmp(cb->f[1], "on")==0)
-			mousehwaccel = 1;
-		else if(strcmp(cb->f[1], "off")==0)
-			mousehwaccel = 0;
-		else
-			cmderror(cb, "bad mouse control message");
-	}
-
-	qunlock(&mousectlqlock);
-	poperror();
-}
+#include "../omap/mouse.c"
Only in .: pad.txt
diff -u -p -b -B -r -x .semantic.cache -x .depend -x CVS -x .hg -x .svn -x .git -x _darcs ./pi /home/pad/work/plan9-github/sys/src/9/bcm/pi
--- ./pi	2017-01-17 11:46:31.000000000 -0800
+++ /home/pad/work/plan9-github/sys/src/9/bcm/pi	2017-01-15 15:43:20.000000000 -0800
@@ -1,14 +1,3 @@
-# A simple kernel configuration for running under Raspberry Pi 1.
-
-# The format of this file is:
-#  <section>
-#  TAB<file>SPACE+<file_dependencies>*
-#
-# One must use TAB, and not spaces for indenting entries in a section.
-# The dev section entries have an implicit dev prefixed
-# so an entry like  '    draw  vgascreen foo' really means
-# that devdraw.c depends on vgascreen.c and foo.c
-
 dev
 	root
 	cons
@@ -12,49 +1,35 @@
 dev
 	root
 	cons
-
 	env
-	proc
-	sys
-
 	pipe
-	dup
-
-	arch
-
+	proc
 	mnt
 	srv
-
-	fakertc
-
+	dup
+	arch
+	ssl
+	tls
+	cap
 	fs
-
-	ether	netif
-	ip		arp chandial ip ipv6 ipaux iproute netlog nullmedium pktmedium ptclbsum
-
-	draw	screen     drawalloc drawerror drawinit drawmesg drawmisc drawname drawwindow
-
+	ip		arp chandial ip ipv6 ipaux iproute netlog nullmedium pktmedium ptclbsum inferno
+	draw	screen
 	mouse	mouse
+	kbmap
+	kbin	kbd latin1
 	uart
 
+	fakertc
 	sd
 	usb
-
-	kbmap
-	kbin	kbd latin1
-
-#	cap
-#	ssl
-#	tls
+	ether	netif
 
 link
 	archbcm
-
-	ethermedium
 	loopbackmedium
+	ethermedium
 	usbdwc
-
-#	etherusb
+	etherusb
 
 ip
 	tcp
@@ -62,8 +37,7 @@ ip
 	ipifc
 	icmp
 	icmp6
-	il
-
+	ipmux
 
 misc
 	uartmini
@@ -77,26 +51,11 @@ port
 
 boot boot #S/sdM0/
 	local
+	tcp
 
-#pad: can also put the 'boot' behind sh to bypass the default boot program
 bootdir
-	boot.rc boot
-	../../../../root/rc/lib/rcmain
-	../../../../root/arm/bin/rc
-	../../../../root/arm/bin/echo
-	../../../../root/arm/bin/bind
-	../../../../root/arm/bin/fdisk
-	../../../../root/arm/bin/dossrv
-	../../../../root/arm/bin/mount
-	../../../../root/arm/bin/usb/usbd
-	../../../../root/arm/bin/ls
-
-# when testing with minimal shell
-
-# minimal set
-#	boot$CONF.out	boot
-#	/386/bin/sh
+	boot$CONF.out	boot
 #	/arm/bin/ip/ipconfig
 #	/arm/bin/auth/factotum
-#	/arm/bin/fossil/fossil
-#	/arm/bin/usb/usbd
+	/arm/bin/fossil/fossil
+	/arm/bin/usb/usbd
Only in /home/pad/work/plan9-github/sys/src/9/bcm/: picpu
Only in /home/pad/work/plan9-github/sys/src/9/bcm/: pifat
Only in .: readme.txt
Only in /home/pad/work/plan9-github/sys/src/9/bcm/: save9pi
diff -u -p -b -B -r -x .semantic.cache -x .depend -x CVS -x .hg -x .svn -x .git -x _darcs ./screen.c /home/pad/work/plan9-github/sys/src/9/bcm/screen.c
--- ./screen.c	2017-01-17 11:46:31.000000000 -0800
+++ /home/pad/work/plan9-github/sys/src/9/bcm/screen.c	2017-01-17 12:07:22.000000000 -0800
@@ -8,13 +8,10 @@
 #include "dat.h"
 #include "fns.h"
 
+#define	Image	IMAGE
 #include <draw.h>
-#include <font.h>
-
 #include <memdraw.h>
 #include <cursor.h>
-
-//#include "../port/screen.h"
 #include "screen.h"
 
 enum {
@@ -43,19 +39,20 @@ Cursor	arrow = {
 Memimage *gscreen;
 
 static Memdata xgdata;
+
 static Memimage xgscreen =
 {
-	.r = { 0, 0, Wid, Ht },
-	.clipr = { 0, 0, Wid, Ht },
-	.depth = Depth,
-	.nchan = 3,
-	.chan = RGB16,
-	.cmap = nil,
-	.data = &xgdata,
-	.zero = 0,
-	.width = 0,
-	.layer = nil,
-	.flags = 0,
+	{ 0, 0, Wid, Ht },	/* r */
+	{ 0, 0, Wid, Ht },	/* clipr */
+	Depth,			/* depth */
+	3,			/* nchan */
+	RGB16,			/* chan */
+	nil,			/* cmap */
+	&xgdata,		/* data */
+	0,			/* zero */
+	0, 			/* width in words of a single scan line */
+	0,			/* layer */
+	0,			/* flags */
 };
 
 static Memimage *conscol;
@@ -60,30 +57,18 @@ static Memimage xgscreen =
 
 static Memimage *conscol;
 static Memimage *back;
-
 static Memsubfont *memdefont;
 
 static Lock screenlock;
 
-static int	h, w;
-
 static Point	curpos;
+static int	h, w;
 static Rectangle window;
 
 static void myscreenputs(char *s, int n);
 static void screenputc(char *buf);
 static void screenwin(void);
 
-
-//old: #define ishwimage(i)	1		/* for ../port/devdraw.c */
-bool
-ishwimage(Memimage* i)
-{
-  USED(i);
-  return true;
-}
-
-
 /*
  * Software cursor. 
  */
@@ -213,7 +198,7 @@ swload(Cursor *curs)
 
 /* called from devmouse */
 void
-ksetcursor(Cursor* curs)
+setcursor(Cursor* curs)
 {
 	cursoroff(0);
 	swload(curs);
@@ -283,15 +268,6 @@ swcursorinit(void)
 	memfillcolor(swimg1, DBlack);
 }
 
-
-
-
-
-/*
- *
- */
-
-
 int
 hwdraw(Memdrawparam *par)
 {
@@ -339,7 +315,7 @@ screeninit(void)
 	int set;
 	ulong chan;
 
-	set = (screensize() == 0);
+	set = screensize() == 0;
 	fb = fbinit(set, &xgscreen.r.max.x, &xgscreen.r.max.y, &xgscreen.depth);
 	if(fb == nil){
 		print("can't initialise %dx%dx%d framebuffer \n",
@@ -364,7 +339,7 @@ screeninit(void)
 		break;
 	}
 	memsetchan(&xgscreen, chan);
-//	conf.monitor = 1;
+	conf.monitor = 1;
 	xgdata.bdata = fb;
 	xgdata.ref = 1;
 	gscreen = &xgscreen;
diff -u -p -b -B -r -x .semantic.cache -x .depend -x CVS -x .hg -x .svn -x .git -x _darcs ./screen.h /home/pad/work/plan9-github/sys/src/9/bcm/screen.h
--- ./screen.h	2017-01-11 11:36:44.000000000 -0800
+++ /home/pad/work/plan9-github/sys/src/9/bcm/screen.h	2015-01-09 12:17:46.000000000 -0800
@@ -1,4 +1,4 @@
-
+typedef struct Cursor Cursor;
 typedef struct Cursorinfo Cursorinfo;
 struct Cursorinfo {
 	Cursor;
@@ -8,9 +8,8 @@ struct Cursorinfo {
 /* devmouse.c */
 extern void mousetrack(int, int, int, int);
 extern Point mousexy(void);
-extern void mouseaccelerate(int);
 
-// specific? maybe should not be in this interface file
+extern void mouseaccelerate(int);
 extern int m3mouseputc(Queue*, int);
 extern int m5mouseputc(Queue*, int);
 extern int mouseputc(Queue*, int);
@@ -19,22 +18,18 @@ extern Cursorinfo cursor;
 extern Cursor arrow;
 
 /* mouse.c */
-//kmousectl now
 extern void mousectl(Cmdbuf*);
-//I think I've moved it
 extern void mouseresize(void);
 
 /* screen.c */
 extern void	blankscreen(int);
 extern void	flushmemscreen(Rectangle);
 extern uchar*	attachscreen(Rectangle*, ulong*, int*, int*, int*);
-
-extern void	ksetcursor(Cursor*);
-
 extern int	cursoron(int);
 extern void	cursoroff(int);
+extern void	setcursor(Cursor*);
 
 /* devdraw.c */
 extern QLock	drawlock;
 
-
+#define ishwimage(i)	1		/* for ../port/devdraw.c */
Only in /home/pad/work/plan9-github/sys/src/9/bcm/: softfpu.c
diff -u -p -b -B -r -x .semantic.cache -x .depend -x CVS -x .hg -x .svn -x .git -x _darcs ./syscall.c /home/pad/work/plan9-github/sys/src/9/bcm/syscall.c
--- ./syscall.c	2017-01-10 15:05:07.000000000 -0800
+++ /home/pad/work/plan9-github/sys/src/9/bcm/syscall.c	2015-01-09 12:17:46.000000000 -0800
@@ -1,356 +1 @@
-#include "u.h"
-#include "../port/lib.h"
-#include "mem.h"
-#include "dat.h"
-#include "fns.h"
-#include "../port/error.h"
-#include "../port/systab.h"
-
-#include <tos.h>
-#include "ureg.h"
-
-#include "arm.h"
-
-typedef struct {
-	uintptr	ip;
-	Ureg*	arg0;
-	char*	arg1;
-	char	msg[ERRMAX];
-	Ureg*	old;
-	Ureg	ureg;
-} NFrame;
-
-/*
- *   Return user to state before notify()
- */
-static void
-noted(Ureg* cur, uintptr arg0)
-{
-	NFrame *nf;
-	Ureg *nur;
-
-	qlock(&up->debug);
-	if(arg0 != NRSTR && !up->notified){
-		qunlock(&up->debug);
-		pprint("call to noted() when not notified\n");
-		pexit("Suicide", 0);
-	}
-	up->notified = 0;
-	fpunoted();
-
-	nf = up->ureg;
-
-	/* sanity clause */
-	if(!okaddr(PTR2UINT(nf), sizeof(NFrame), 0)){
-		qunlock(&up->debug);
-		pprint("bad ureg in noted %#p\n", nf);
-		pexit("Suicide", 0);
-	}
-
-	/* don't let user change system flags */
-	nur = &nf->ureg;
-	nur->psr &= PsrMask|PsrDfiq|PsrDirq;
-	nur->psr |= (cur->psr & ~(PsrMask|PsrDfiq|PsrDirq));
-
-	memmove(cur, nur, sizeof(Ureg));
-
-	switch((int)arg0){
-	case NCONT:
-	case NRSTR:
-		if(!okaddr(nur->pc, BY2WD, 0) || !okaddr(nur->sp, BY2WD, 0)){
-			qunlock(&up->debug);
-			pprint("suicide: trap in noted\n");
-			pexit("Suicide", 0);
-		}
-		up->ureg = nf->old;
-		qunlock(&up->debug);
-		break;
-	case NSAVE:
-		if(!okaddr(nur->pc, BY2WD, 0) || !okaddr(nur->sp, BY2WD, 0)){
-			qunlock(&up->debug);
-			pprint("suicide: trap in noted\n");
-			pexit("Suicide", 0);
-		}
-		qunlock(&up->debug);
-
-		splhi();
-		nf->arg1 = nf->msg;
-		nf->arg0 = &nf->ureg;
-		nf->ip = 0;
-		cur->sp = PTR2UINT(nf);
-		cur->r0 = PTR2UINT(nf->arg0);
-		break;
-	default:
-		pprint("unknown noted arg %#p\n", arg0);
-		up->lastnote.flag = NDebug;
-		/*FALLTHROUGH*/
-	case NDFLT:
-		if(up->lastnote.flag == NDebug){ 
-			qunlock(&up->debug);
-			pprint("suicide: %s\n", up->lastnote.msg);
-		}
-		else
-			qunlock(&up->debug);
-		pexit(up->lastnote.msg, up->lastnote.flag != NDebug);
-	}
-}
-
-/*
- *  Call user, if necessary, with note.
- *  Pass user the Ureg struct and the note on his stack.
- */
-int
-notify(Ureg* ureg)
-{
-	int l;
-	Note *n;
-	u32int s;
-	uintptr sp;
-	NFrame *nf;
-
-	if(up->procctl)
-		procctl(up);
-	if(up->nnote == 0)
-		return 0;
-
-	fpunotify(ureg);
-
-	s = spllo();
-	qlock(&up->debug);
-
-	up->notepending = 0;
-	n = &up->note[0];
-	if(strncmp(n->msg, "sys:", 4) == 0){
-		l = strlen(n->msg);
-		if(l > ERRMAX-23)	/* " pc=0x0123456789abcdef\0" */
-			l = ERRMAX-23;
-		snprint(n->msg + l, sizeof n->msg - l, " pc=%#lux", ureg->pc);
-	}
-
-	if(n->flag != NUser && (up->notified || up->notify == 0)){
-		if(n->flag == NDebug)
-			pprint("suicide: %s\n", n->msg);
-		qunlock(&up->debug);
-		pexit(n->msg, n->flag != NDebug);
-	}
-
-	if(up->notified){
-		qunlock(&up->debug);
-		splhi();
-		return 0;
-	}
-		
-	if(up->notify == nil){
-		qunlock(&up->debug);
-		pexit(n->msg, n->flag != NDebug);
-	}
-	if(!okaddr(PTR2UINT(up->notify), 1, 0)){
-		pprint("suicide: notify function address %#p\n", up->notify);
-		qunlock(&up->debug);
-		pexit("Suicide", 0);
-	}
-
-	sp = ureg->sp - sizeof(NFrame);
-	if(!okaddr(sp, sizeof(NFrame), 1)){
-		qunlock(&up->debug);
-		pprint("suicide: notify stack address %#p\n", sp);
-		pexit("Suicide", 0);
-	}
-
-	nf = UINT2PTR(sp);
-	memmove(&nf->ureg, ureg, sizeof(Ureg));
-	nf->old = up->ureg;
-	up->ureg = nf;
-	memmove(nf->msg, up->note[0].msg, ERRMAX);
-	nf->arg1 = nf->msg;
-	nf->arg0 = &nf->ureg;
-	ureg->r0 = PTR2UINT(nf->arg0);
-	nf->ip = 0;
-
-	ureg->sp = sp;
-	ureg->pc = PTR2UINT(up->notify);
-	up->notified = 1;
-	up->nnote--;
-	memmove(&up->lastnote, &up->note[0], sizeof(Note));
-	memmove(&up->note[0], &up->note[1], up->nnote*sizeof(Note));
-
-	qunlock(&up->debug);
-	splx(s);
-
-	return 1;
-}
-
-void
-syscall(Ureg* ureg)
-{
-	char *e;
-	u32int s;
-	ulong sp;
-	long ret;
-	int i, scallnr;
-	vlong startns, stopns;
-
-	if(!userureg(ureg))
-		panic("syscall: from kernel: pc %#lux r14 %#lux psr %#lux",
-			ureg->pc, ureg->r14, ureg->psr);
-
-	cycles(&up->kentry);
-
-	cpu->syscall++;
-	up->insyscall = 1;
-	up->pc = ureg->pc;
-	up->dbgreg = ureg;
-
-	scallnr = ureg->r0;
-	// up->scallnr = scallnr;
-	if(scallnr == RFORK)
-		fpusysrfork(ureg);
-	spllo();
-	sp = ureg->sp;
-
-	if(up->procctl == Proc_tracesyscall){
-		/*
-		 * Redundant validaddr.  Do we care?
-		 * Tracing syscalls is not exactly a fast path...
-		 * Beware, validaddr currently does a pexit rather
-		 * than an error if there's a problem; that might
-		 * change in the future.
-		 */
-		if(sp < (USTKTOP-BY2PG) || sp > (USTKTOP-sizeof(Sargs)-BY2WD))
-			validaddr(sp, sizeof(Sargs)+BY2WD, 0);
-
-		syscallfmt(scallnr, ureg->pc, (va_list)(sp+BY2WD));
-		up->procctl = Proc_stopme;
-		procctl(up);
-		if (up->syscalltrace) 
-			free(up->syscalltrace);
-		up->syscalltrace = nil;
-	}
-
-	up->nerrlab = 0;
-	ret = -1;
-	startns = todget(nil);
-	if(!waserror()){
-		if(scallnr >= nsyscall){
-			pprint("bad sys call number %d pc %#lux\n",
-				scallnr, ureg->pc);
-			postnote(up, 1, "sys: bad sys call", NDebug);
-			error(Ebadarg);
-		}
-
-		if(sp < (USTKTOP-BY2PG) || sp > (USTKTOP-sizeof(Sargs)-BY2WD))
-			validaddr(sp, sizeof(Sargs)+BY2WD, 0);
-
-		up->sargs = *((Sargs*)(sp+BY2WD));
-		up->psstate = sysctab[scallnr];
-
-	/*	iprint("%s: syscall %s\n", up->text, sysctab[scallnr]?sysctab[scallnr]:"huh?"); */
-
-		ret = systab[scallnr](up->sargs.args);
-		poperror();
-	}else{
-		/* failure: save the error buffer for errstr */
-		e = up->syserrstr;
-		up->syserrstr = up->errstr;
-		up->errstr = e;
-	}
-	if(up->nerrlab){
-		print("bad errstack [%d]: %d extra\n", scallnr, up->nerrlab);
-		for(i = 0; i < NERR; i++)
-			print("sp=%#p pc=%#p\n",
-				up->errlab[i].sp, up->errlab[i].pc);
-		panic("error stack");
-	}
-
-	/*
-	 *  Put return value in frame.  On the x86 the syscall is
-	 *  just another trap and the return value from syscall is
-	 *  ignored.  On other machines the return value is put into
-	 *  the results register by caller of syscall.
-	 */
-	ureg->r0 = ret;
-
-	if(up->procctl == Proc_tracesyscall){
-		stopns = todget(nil);
-		up->procctl = Proc_stopme;
-		sysretfmt(scallnr, (va_list)(sp+BY2WD), ret, startns, stopns);
-		s = splhi();
-		procctl(up);
-		splx(s);
-		if(up->syscalltrace)
-			free(up->syscalltrace);
-		up->syscalltrace = nil;
-	}
-
-	up->insyscall = 0;
-	up->psstate = 0;
-
-	if(scallnr == NOTED)
-		noted(ureg, *(ulong*)(sp+BY2WD));
-
-	splhi();
-	if(scallnr != RFORK && (up->procctl || up->nnote))
-		notify(ureg);
-
-	/* if we delayed sched because we held a lock, sched now */
-	if(up->delaysched){
-		sched();
-		splhi();
-	}
-	kexit(ureg);
-}
-
-long
-execregs(ulong entry, ulong ssize, ulong nargs)
-{
-	ulong *sp;
-	Ureg *ureg;
-
-	sp = (ulong*)(USTKTOP - ssize);
-	*--sp = nargs;
-
-	ureg = up->dbgreg;
-//	memset(ureg, 0, 15*sizeof(ulong));
-	ureg->r13 = (ulong)sp;
-	ureg->pc = entry;
-//print("%lud: EXECREGS pc %#ux sp %#ux nargs %ld\n", up->pid, ureg->pc, ureg->r13, nargs);
-
-	/*
-	 * return the address of kernel/user shared data
-	 * (e.g. clock stuff)
-	 */
-	return USTKTOP-sizeof(Tos);
-}
-
-void
-sysprocsetup(Proc* p)
-{
-	fpusysprocsetup(p);
-}
-
-/* 
- *  Craft a return frame which will cause the child to pop out of
- *  the scheduler in user mode with the return register zero.  Set
- *  pc to point to a l.s return function.
- */
-void
-forkchild(Proc *p, Ureg *ureg)
-{
-	Ureg *cureg;
-
-//print("%lud setting up for forking child %lud\n", up->pid, p->pid);
-	p->sched.sp = (ulong)p->kstack+KSTACK-sizeof(Ureg);
-	p->sched.pc = (ulong)forkret;
-
-	cureg = (Ureg*)(p->sched.sp);
-	memmove(cureg, ureg, sizeof(Ureg));
-
-	/* syscall returns 0 for child */
-	cureg->r0 = 0;
-
-	/* Things from bottom of syscall which were never executed */
-	p->psstate = 0;
-	p->insyscall = 0;
-
-	fpusysrforkchild(p, cureg, up);
-}
+#include "../kw/syscall.c"
diff -u -p -b -B -r -x .semantic.cache -x .depend -x CVS -x .hg -x .svn -x .git -x _darcs ./trap.c /home/pad/work/plan9-github/sys/src/9/bcm/trap.c
--- ./trap.c	2017-01-10 15:08:40.000000000 -0800
+++ /home/pad/work/plan9-github/sys/src/9/bcm/trap.c	2015-01-09 12:17:46.000000000 -0800
@@ -88,10 +88,10 @@ trapinit(void)
 
 	/* set up the stacks for the interrupt modes */
 	setr13(PsrMfiq, (u32int*)(FIQSTKTOP));
-	setr13(PsrMirq, cpu->sirq);
-	setr13(PsrMabt, cpu->sabt);
-	setr13(PsrMund, cpu->sund);
-	setr13(PsrMsys, cpu->ssys);
+	setr13(PsrMirq, m->sirq);
+	setr13(PsrMabt, m->sabt);
+	setr13(PsrMund, m->sund);
+	setr13(PsrMsys, m->ssys);
 
 	coherence();
 }
@@ -143,7 +143,7 @@ fiq(Ureg *ureg)
 	v = vfiq;
 	if(v == nil)
 		panic("unexpected item in bagging area");
-	cpu->intr++;
+	m->intr++;
 	ureg->pc -= 4;
 	coherence();
 	v->f(ureg, v->a);
@@ -280,7 +280,7 @@ trap(Ureg *ureg)
 	if(up != nil)
 		rem = ((char*)ureg)-up->kstack;
 	else
-		rem = ((char*)ureg)-((char*)cpu + sizeof(Cpu));
+		rem = ((char*)ureg)-((char*)m+sizeof(Mach));
 	if(rem < 256) {
 		iprint("trap: %d stack bytes left, up %#p ureg %#p at pc %#lux\n",
 			rem, up, ureg, ureg->pc);
@@ -313,7 +313,7 @@ trap(Ureg *ureg)
 		break;
 	case PsrMirq:
 		clockintr = irq(ureg);
-		cpu->intr++;
+		m->intr++;
 		break;
 	case PsrMabt:			/* prefetch fault */
 		x = ifsrget();
@@ -491,14 +491,14 @@ dumpstackwithureg(Ureg *ureg)
 	i = 0;
 	if(up != nil && (uintptr)&l <= (uintptr)up->kstack+KSTACK)
 		estack = (uintptr)up->kstack+KSTACK;
-	else if((uintptr)&l >= (uintptr)cpu->stack
-	     && (uintptr)&l <= (uintptr)cpu + CPUSIZE)
-		estack = (uintptr)cpu + CPUSIZE;
+	else if((uintptr)&l >= (uintptr)m->stack
+	     && (uintptr)&l <= (uintptr)m+MACHSIZE)
+		estack = (uintptr)m+MACHSIZE;
 	else{
 		if(up != nil)
 			iprint("&up->kstack %#p &l %#p\n", up->kstack, &l);
 		else
-			iprint("&m %#p &l %#p\n", cpu, &l);
+			iprint("&m %#p &l %#p\n", m, &l);
 		return;
 	}
 	for(l = (uintptr)&l; l < estack; l += sizeof(uintptr)){
@@ -569,7 +569,7 @@ dumpregs(Ureg* ureg)
 		iprint("user stack: %#p-%#p\n", up->kstack, up->kstack+KSTACK-4);
 	else
 		iprint("kernel stack: %8.8lux-%8.8lux\n",
-			(ulong)(cpu+1), (ulong)cpu+BY2PG-4);
+			(ulong)(m+1), (ulong)m+BY2PG-4);
 	dumplongs("stack", (ulong *)(ureg + 1), 16);
 	delay(2000);
 	dumpstack();
diff -u -p -b -B -r -x .semantic.cache -x .depend -x CVS -x .hg -x .svn -x .git -x _darcs ./usbdwc.c /home/pad/work/plan9-github/sys/src/9/bcm/usbdwc.c
--- ./usbdwc.c	2017-01-10 15:14:16.000000000 -0800
+++ /home/pad/work/plan9-github/sys/src/9/bcm/usbdwc.c	2015-01-09 12:17:46.000000000 -0800
@@ -234,9 +234,9 @@ restart:
 			r->gnptxsts, r->hptxsts);
 		mask = Chhltd;
 		hc->hcchar |= Chdis;
-		start = cpu->ticks;
+		start = m->ticks;
 		while(hc->hcchar & Chen){
-			if(cpu->ticks - start >= 100){
+			if(m->ticks - start >= 100){
 				print("ep%d.%d channel won't halt hcchar %8.8ux\n",
 					ep->dev->nb, ep->nb, hc->hcchar);
 				break;
@@ -244,7 +244,6 @@ restart:
 		}
 		logdump(ep);
 	}
-    return -1; // unreachable
 }
 
 static int
@@ -399,9 +398,9 @@ chanio(Ep *ep, Hostchan *hc, int dir, in
 				continue;
 			if(i & Nak){
 				if(ep->ttype == Tintr)
-					tsleep(&up->sleepr, returnfalse, 0, ep->pollival);
+					tsleep(&up->sleep, return0, 0, ep->pollival);
 				else
-					tsleep(&up->sleepr, returnfalse, 0, 1);
+					tsleep(&up->sleep, return0, 0, 1);
 				continue;
 			}
 			logdump(ep);
@@ -613,7 +612,7 @@ init(Hci *hp)
 	greset(r, Csftrst);
 
 	r->gusbcfg |= Force_host_mode;
-	tsleep(&up->sleepr, returnfalse, 0, 25);
+	tsleep(&up->sleep, return0, 0, 25);
 	r->gahbcfg |= Dmaenable;
 
 	n = (r->ghwcfg3 & Dfifo_depth) >> ODfifo_depth;
@@ -622,7 +621,7 @@ init(Hci *hp)
 	ptx = 0x200;
 	r->grxfsiz = rx;
 	r->gnptxfsiz = rx | tx<<ODepth;
-	tsleep(&up->sleepr, returnfalse, 0, 1);
+	tsleep(&up->sleep, return0, 0, 1);
 	r->hptxfsiz = (rx + tx) | ptx << ODepth;
 	greset(r, Rxfflsh);
 	r->grstctl = TXF_ALL;
@@ -767,9 +766,9 @@ epread(Ep *ep, void *a, long n)
 		poperror();
 		return nr;
 	case Tintr:
-		elapsed = TK2MS(cpu->ticks) - epio->lastpoll;
+		elapsed = TK2MS(m->ticks) - epio->lastpoll;
 		if(elapsed < ep->pollival)
-			tsleep(&up->sleepr, returnfalse, 0, ep->pollival - elapsed);
+			tsleep(&up->sleep, return0, 0, ep->pollival - elapsed);
 		/* fall through */
 	case Tbulk:
 		/* XXX cache madness */
@@ -777,7 +776,7 @@ epread(Ep *ep, void *a, long n)
 		p = (uchar*)ROUND((uintptr)b->base, CACHELINESZ);
 		cachedwbinvse(p, n);
 		nr = eptrans(ep, Read, p, n);
-		epio->lastpoll = TK2MS(cpu->ticks);
+		epio->lastpoll = TK2MS(m->ticks);
 		memmove(a, p, nr);
 		qunlock(epio);
 		freeb(b);
@@ -808,9 +807,9 @@ epwrite(Ep *ep, void *a, long n)
 	default:
 		error(Egreg);
 	case Tintr:
-		elapsed = TK2MS(cpu->ticks) - epio->lastpoll;
+		elapsed = TK2MS(m->ticks) - epio->lastpoll;
 		if(elapsed < ep->pollival)
-			tsleep(&up->sleepr, returnfalse, 0, ep->pollival - elapsed);
+			tsleep(&up->sleep, return0, 0, ep->pollival - elapsed);
 		/* fall through */
 	case Tctl:
 	case Tbulk:
@@ -823,7 +822,7 @@ epwrite(Ep *ep, void *a, long n)
 			n = ctltrans(ep, p, n);
 		else{
 			n = eptrans(ep, Write, p, n);
-			epio->lastpoll = TK2MS(cpu->ticks);
+			epio->lastpoll = TK2MS(m->ticks);
 		}
 		qunlock(epio);
 		freeb(b);
@@ -850,7 +849,7 @@ portenable(Hci *hp, int port, int on)
 	dprint("usbotg enable=%d; sts %#x\n", on, r->hport0);
 	if(!on)
 		r->hport0 = Prtpwr | Prtena;
-	tsleep(&up->sleepr, returnfalse, 0, Enabledelay);
+	tsleep(&up->sleep, return0, 0, Enabledelay);
 	dprint("usbotg enable=%d; sts %#x\n", on, r->hport0);
 	return 0;
 }
@@ -869,9 +868,9 @@ portreset(Hci *hp, int port, int on)
 	if(!on)
 		return 0;
 	r->hport0 = Prtpwr | Prtrst;
-	tsleep(&up->sleepr, returnfalse, 0, ResetdelayHS);
+	tsleep(&up->sleep, return0, 0, ResetdelayHS);
 	r->hport0 = Prtpwr;
-	tsleep(&up->sleepr, returnfalse, 0, Enabledelay);
+	tsleep(&up->sleep, return0, 0, Enabledelay);
 	s = r->hport0;
 	b = s & (Prtconndet|Prtenchng|Prtovrcurrchng);
 	if(b != 0)
diff -u -p -b -B -r -x .semantic.cache -x .depend -x CVS -x .hg -x .svn -x .git -x _darcs ./vcore.c /home/pad/work/plan9-github/sys/src/9/bcm/vcore.c
--- ./vcore.c	2017-01-16 18:20:29.000000000 -0800
+++ /home/pad/work/plan9-github/sys/src/9/bcm/vcore.c	2017-01-17 12:07:39.000000000 -0800
@@ -190,7 +190,7 @@ fbinit(int set, int *width, int *height,
 		return 0;
 	va = mmukmap(FRAMEBUFFER, PADDR(fi->base), fi->screensize);
 	if(va)
-		memset((char*)va, 0x7F, fi->screensize);
+		memset((char*)va, 0x2F, fi->screensize);
 	return (void*)va;
 }
 
diff -u -p -b -B -r -x .semantic.cache -x .depend -x CVS -x .hg -x .svn -x .git -x _darcs ./vfp3.c /home/pad/work/plan9-github/sys/src/9/bcm/vfp3.c
--- ./vfp3.c	2017-01-10 15:15:17.000000000 -0800
+++ /home/pad/work/plan9-github/sys/src/9/bcm/vfp3.c	2015-01-09 12:17:46.000000000 -0800
@@ -1,516 +1 @@
-/*
- * VFPv2 or VFPv3 floating point unit
- */
-#include "u.h"
-#include "../port/lib.h"
-#include "mem.h"
-#include "dat.h"
-#include "fns.h"
-#include "ureg.h"
-#include "arm.h"
-
-/* subarchitecture code in cpu->havefp */
-enum {
-	VFPv2	= 2,
-	VFPv3	= 3,
-};
-
-/* fp control regs.  most are read-only */
-enum {
-	Fpsid =	0,
-	Fpscr =	1,			/* rw */
-	Mvfr1 =	6,
-	Mvfr0 =	7,
-	Fpexc =	8,			/* rw */
-	Fpinst= 9,			/* optional, for exceptions */
-	Fpinst2=10,
-};
-enum {
-	/* Fpexc bits */
-	Fpex =		1u << 31,
-	Fpenabled =	1 << 30,
-	Fpdex =		1 << 29,	/* defined synch exception */
-//	Fp2v =		1 << 28,	/* Fpinst2 reg is valid */
-//	Fpvv =		1 << 27,	/* if Fpdex, vecitr is valid */
-//	Fptfv = 	1 << 26,	/* trapped fault is valid */
-//	Fpvecitr =	MASK(3) << 8,
-	/* FSR bits appear here */
-	Fpmbc =		Fpdex,		/* bits exception handler must clear */
-
-	/* Fpscr bits; see u.h for more */
-	Stride =	MASK(2) << 20,
-	Len =		MASK(3) << 16,
-	Dn=		1 << 25,
-	Fz=		1 << 24,
-	/* trap exception enables (not allowed in vfp3) */
-	FPIDNRM =	1 << 15,	/* input denormal */
-	Alltraps = FPIDNRM | FPINEX | FPUNFL | FPOVFL | FPZDIV | FPINVAL,
-	/* pending exceptions */
-	FPAIDNRM =	1 << 7,		/* input denormal */
-	Allexc = FPAIDNRM | FPAINEX | FPAUNFL | FPAOVFL | FPAZDIV | FPAINVAL,
-	/* condition codes */
-	Allcc =		MASK(4) << 28,
-};
-enum {
-	/* CpCPaccess bits */
-	Cpaccnosimd =	1u << 31,
-	Cpaccd16 =	1 << 30,
-};
-
-static char *
-subarch(int impl, uint sa)
-{
-	static char *armarchs[] = {
-		"VFPv1 (unsupported)",
-		"VFPv2",
-		"VFPv3+ with common VFP subarch v2",
-		"VFPv3+ with null subarch",
-		"VFPv3+ with common VFP subarch v3",
-	};
-
-	if (impl != 'A' || sa >= nelem(armarchs))
-		return "GOK";
-	else
-		return armarchs[sa];
-}
-
-static char *
-implement(uchar impl)
-{
-	if (impl == 'A')
-		return "arm";
-	else
-		return "unknown";
-}
-
-static int
-havefp(void)
-{
-	int gotfp;
-	ulong acc, sid;
-
-	if (cpu->havefpvalid)
-		return cpu->havefp;
-
-	cpu->havefp = 0;
-	gotfp = 1 << CpFP | 1 << CpDFP;
-	cpwrsc(0, CpCONTROL, 0, CpCPaccess, MASK(28));
-	acc = cprdsc(0, CpCONTROL, 0, CpCPaccess);
-	if ((acc & (MASK(2) << (2*CpFP))) == 0) {
-		gotfp &= ~(1 << CpFP);
-		print("fpon: no single FP coprocessor\n");
-	}
-	if ((acc & (MASK(2) << (2*CpDFP))) == 0) {
-		gotfp &= ~(1 << CpDFP);
-		print("fpon: no double FP coprocessor\n");
-	}
-	if (!gotfp) {
-		print("fpon: no FP coprocessors\n");
-		cpu->havefpvalid = 1;
-		return 0;
-	}
-	cpu->fpon = 1;			/* don't panic */
-	sid = fprd(Fpsid);
-	cpu->fpon = 0;
-	switch((sid >> 16) & MASK(7)){
-	case 0:				/* VFPv1 */
-		break;
-	case 1:				/* VFPv2 */
-		cpu->havefp = VFPv2;
-		cpu->fpnregs = 16;
-		break;
-	default:			/* VFPv3 or later */
-		cpu->havefp = VFPv3;
-		cpu->fpnregs = (acc & Cpaccd16) ? 16 : 32;
-		break;
-	}
-	if (cpu->cpuno == 0)
-		print("fp: %d registers, %s simd\n", cpu->fpnregs,
-			(acc & Cpaccnosimd? " no": ""));
-	cpu->havefpvalid = 1;
-	return 1;
-}
-
-/*
- * these can be called to turn the fpu on or off for user procs,
- * not just at system start up or shutdown.
- */
-
-void
-fpoff(void)
-{
-	if (cpu->fpon) {
-		fpwr(Fpexc, 0);
-		cpu->fpon = 0;
-	}
-}
-
-void
-fpononly(void)
-{
-	if (!cpu->fpon && havefp()) {
-		/* enable fp.  must be first operation on the FPUs. */
-		fpwr(Fpexc, Fpenabled);
-		cpu->fpon = 1;
-	}
-}
-
-static void
-fpcfg(void)
-{
-	int impl;
-	ulong sid;
-	static int printed;
-
-	/* clear pending exceptions; no traps in vfp3; all v7 ops are scalar */
-	cpu->fpscr = Dn | Fz | FPRNR | (FPINVAL | FPZDIV | FPOVFL) & ~Alltraps;
-	fpwr(Fpscr, cpu->fpscr);
-	cpu->fpconfiged = 1;
-
-	if (printed)
-		return;
-	sid = fprd(Fpsid);
-	impl = sid >> 24;
-	print("fp: %s arch %s; rev %ld\n", implement(impl),
-		subarch(impl, (sid >> 16) & MASK(7)), sid & MASK(4));
-	printed = 1;
-}
-
-void
-fpinit(void)
-{
-	if (havefp()) {
-		fpononly();
-		fpcfg();
-	}
-}
-
-void
-fpon(void)
-{
-	if (havefp()) {
-	 	fpononly();
-		if (cpu->fpconfiged)
-			fpwr(Fpscr, (fprd(Fpscr) & Allcc) | cpu->fpscr);
-		else
-			fpcfg();	/* 1st time on this fpu; configure it */
-	}
-}
-
-void
-fpclear(void)
-{
-//	ulong scr;
-
-	fpon();
-//	scr = fprd(Fpscr);
-//	cpu->fpscr = scr & ~Allexc;
-//	fpwr(Fpscr, cpu->fpscr);
-
-	fpwr(Fpexc, fprd(Fpexc) & ~Fpmbc);
-}
-
-
-/*
- * Called when a note is about to be delivered to a
- * user process, usually at the end of a system call.
- * Note handlers are not allowed to use the FPU so
- * the state is marked (after saving if necessary) and
- * checked in the Device Not Available handler.
- */
-void
-fpunotify(Ureg*)
-{
-	if(up->fpstate == FPactive){
-		fpsave(&up->fpsave);
-		up->fpstate = FPinactive;
-	}
-	up->fpstate |= FPillegal;
-}
-
-/*
- * Called from sysnoted() via the machine-dependent
- * noted() routine.
- * Clear the flag set above in fpunotify().
- */
-void
-fpunoted(void)
-{
-	up->fpstate &= ~FPillegal;
-}
-
-/*
- * Called early in the non-interruptible path of
- * sysrfork() via the machine-dependent syscall() routine.
- * Save the state so that it can be easily copied
- * to the child process later.
- */
-void
-fpusysrfork(Ureg*)
-{
-	if(up->fpstate == FPactive){
-		fpsave(&up->fpsave);
-		up->fpstate = FPinactive;
-	}
-}
-
-/*
- * Called later in sysrfork() via the machine-dependent
- * sysrforkchild() routine.
- * Copy the parent FPU state to the child.
- */
-void
-fpusysrforkchild(Proc *p, Ureg *, Proc *up)
-{
-	/* don't penalize the child, it hasn't done FP in a note handler. */
-	p->fpstate = up->fpstate & ~FPillegal;
-}
-
-/* should only be called if p->fpstate == FPactive */
-void
-fpsave(ArchFPsave *fps)
-{
-	int n;
-
-	fpon();
-	fps->control = fps->status = fprd(Fpscr);
-	assert(cpu->fpnregs);
-	for (n = 0; n < cpu->fpnregs; n++)
-		fpsavereg(n, (uvlong *)fps->regs[n]);
-	fpoff();
-}
-
-static void
-fprestore(Proc *p)
-{
-	int n;
-
-	fpon();
-	fpwr(Fpscr, p->fpsave.control);
-	cpu->fpscr = fprd(Fpscr) & ~Allcc;
-	assert(cpu->fpnregs);
-	for (n = 0; n < cpu->fpnregs; n++)
-		fprestreg(n, *(uvlong *)p->fpsave.regs[n]);
-}
-
-/*
- * Called from sched() and sleep() via the machine-dependent
- * procsave() routine.
- * About to go in to the scheduler.
- * If the process wasn't using the FPU
- * there's nothing to do.
- */
-void
-fpuprocsave(Proc *p)
-{
-	if(p->fpstate == FPactive){
-		if(p->state == Moribund)
-			fpclear();
-		else{
-			/*
-			 * Fpsave() stores without handling pending
-			 * unmasked exeptions. Postnote() can't be called
-			 * here as sleep() already has up->rlock, so
-			 * the handling of pending exceptions is delayed
-			 * until the process runs again and generates an
-			 * emulation fault to activate the FPU.
-			 */
-			fpsave(&p->fpsave);
-		}
-		p->fpstate = FPinactive;
-	}
-}
-
-/*
- * The process has been rescheduled and is about to run.
- * Nothing to do here right now. If the process tries to use
- * the FPU again it will cause a Device Not Available
- * exception and the state will then be restored.
- */
-void
-fpuprocrestore(Proc *)
-{
-}
-
-/*
- * Disable the FPU.
- * Called from sysexec() via sysprocsetup() to
- * set the FPU for the new process.
- */
-void
-fpusysprocsetup(Proc *p)
-{
-	p->fpstate = FPinit;
-	fpoff();
-}
-
-static void
-mathnote(void)
-{
-	ulong status;
-	char *msg, note[ERRMAX];
-
-	status = up->fpsave.status;
-
-	/*
-	 * Some attention should probably be paid here to the
-	 * exception masks and error summary.
-	 */
-	if (status & FPAINEX)
-		msg = "inexact";
-	else if (status & FPAOVFL)
-		msg = "overflow";
-	else if (status & FPAUNFL)
-		msg = "underflow";
-	else if (status & FPAZDIV)
-		msg = "divide by zero";
-	else if (status & FPAINVAL)
-		msg = "bad operation";
-	else
-		msg = "spurious";
-	snprint(note, sizeof note, "sys: fp: %s fppc=%#p status=%#lux",
-		msg, up->fpsave.pc, status);
-	postnote(up, 1, note, NDebug);
-}
-
-static void
-mathemu(Ureg *)
-{
-	switch(up->fpstate){
-	case FPemu:
-		error("illegal instruction: VFP opcode in emulated mode");
-	case FPinit:
-		fpinit();
-		up->fpstate = FPactive;
-		break;
-	case FPinactive:
-		/*
-		 * Before restoring the state, check for any pending
-		 * exceptions.  There's no way to restore the state without
-		 * generating an unmasked exception.
-		 * More attention should probably be paid here to the
-		 * exception masks and error summary.
-		 */
-		if(up->fpsave.status & (FPAINEX|FPAUNFL|FPAOVFL|FPAZDIV|FPAINVAL)){
-			mathnote();
-			break;
-		}
-		fprestore(up);
-		up->fpstate = FPactive;
-		break;
-	case FPactive:
-		error("illegal instruction: bad vfp fpu opcode");
-		break;
-	}
-	fpclear();
-}
-
-void
-fpstuck(uintptr pc)
-{
-	if (cpu->fppc == pc && cpu->fppid == up->pid) {
-		cpu->fpcnt++;
-		if (cpu->fpcnt > 4)
-			panic("fpuemu: cpu%d stuck at pid %ld %s pc %#p "
-				"instr %#8.8lux", cpu->cpuno, up->pid, up->text,
-				pc, *(ulong *)pc);
-	} else {
-		cpu->fppid = up->pid;
-		cpu->fppc = pc;
-		cpu->fpcnt = 0;
-	}
-}
-
-enum {
-	N = 1<<31,
-	Z = 1<<30,
-	C = 1<<29,
-	V = 1<<28,
-	REGPC = 15,
-};
-
-static int
-condok(int cc, int c)
-{
-	switch(c){
-	case 0:	/* Z set */
-		return cc&Z;
-	case 1:	/* Z clear */
-		return (cc&Z) == 0;
-	case 2:	/* C set */
-		return cc&C;
-	case 3:	/* C clear */
-		return (cc&C) == 0;
-	case 4:	/* N set */
-		return cc&N;
-	case 5:	/* N clear */
-		return (cc&N) == 0;
-	case 6:	/* V set */
-		return cc&V;
-	case 7:	/* V clear */
-		return (cc&V) == 0;
-	case 8:	/* C set and Z clear */
-		return cc&C && (cc&Z) == 0;
-	case 9:	/* C clear or Z set */
-		return (cc&C) == 0 || cc&Z;
-	case 10:	/* N set and V set, or N clear and V clear */
-		return (~cc&(N|V))==0 || (cc&(N|V)) == 0;
-	case 11:	/* N set and V clear, or N clear and V set */
-		return (cc&(N|V))==N || (cc&(N|V))==V;
-	case 12:	/* Z clear, and either N set and V set or N clear and V clear */
-		return (cc&Z) == 0 && ((~cc&(N|V))==0 || (cc&(N|V))==0);
-	case 13:	/* Z set, or N set and V clear or N clear and V set */
-		return (cc&Z) || (cc&(N|V))==N || (cc&(N|V))==V;
-	case 14:	/* always */
-		return 1;
-	case 15:	/* never (reserved) */
-		return 0;
-	}
-	return 0;	/* not reached */
-}
-
-/* only called to deal with user-mode instruction faults */
-int
-fpuemu(Ureg* ureg)
-{
-	int s, nfp, cop, op;
-	uintptr pc;
-
-	if(waserror()){
-		postnote(up, 1, up->errstr, NDebug);
-		return 1;
-	}
-
-	if(up->fpstate & FPillegal)
-		error("floating point in note handler");
-
-	nfp = 0;
-	pc = ureg->pc;
-	validaddr(pc, 4, 0);
-	if(!condok(ureg->psr, *(ulong*)pc >> 28))
-		iprint("fpuemu: conditional instr shouldn't have got here\n");
-	op  = (*(ulong *)pc >> 24) & MASK(4);
-	cop = (*(ulong *)pc >>  8) & MASK(4);
-	if(cpu->fpon)
-		fpstuck(pc);		/* debugging; could move down 1 line */
-	if (ISFPAOP(cop, op)) {		/* old arm 7500 fpa opcode? */
-//		iprint("fpuemu: fpa instr %#8.8lux at %#p\n", *(ulong *)pc, pc);
-//		error("illegal instruction: old arm 7500 fpa opcode");
-		s = spllo();
-		if(waserror()){
-			splx(s);
-			nexterror();
-		}
-		nfp = fpiarm(ureg);	/* advances pc past emulated instr(s) */
-		if (nfp > 1)		/* could adjust this threshold */
-			cpu->fppc = cpu->fpcnt = 0;
-		splx(s);
-		poperror();
-	} else if (ISVFPOP(cop, op)) {	/* if vfp, fpu must be off */
-		mathemu(ureg);		/* enable fpu & retry */
-		nfp = 1;
-	}
-
-	poperror();
-	return nfp;
-}
+#include "../teg2/vfp3.c"
Only in /home/pad/work/plan9-github/sys/src/9/bcm/: words
