\section{[[commons2/]]}

\subsection*{[[commons2/local.mli]]}


%-------------------------------------------------------------

<<commons2/local.mli>>=

<<signature type Local.vars>>
<<signature function Local.vars>>

<<signature type Local.var>>
<<signature functions Local.create_xxx>>
(* internal *)
<<signature function Local.create>>

<<signature function Local.get>>
<<signature function Local.set>>

<<signature functions Local>>
@

\subsection*{[[commons2/local.ml]]}


%-------------------------------------------------------------

<<commons2/local.ml>>=
<<copyright header>>

(* We use strings instead of ints to enable migration of datas between
editors (data must be symbolic) *)
  
<<type Local.var>>

<<module Local.Vars>>

<<type Local.vars>>
<<function Local.vars>>

<<global Local.vars_table>>

<<function Local.create>>

<<function Local.no_print>>
<<function Local.no_input>>
<<function Local.create_abstr>>
  
external id : 'a -> 'a = "%identity"

<<function Local.create_string>>
<<function Local.create_int>>
<<function Local.create_float>>
  
<<function Local.get>>
<<function Local.set>>
      
<<function Local.get_print>>
  
<<function Local.set_input>>
  
<<function Local.list>>
  
<<constant Local.print>>
<<constant Local.input>>
@


\section{[[core/]]}

\subsection*{[[core/var.ml]]}

<<core/var.ml>>=
<<copyright header efuns>>
open Efuns
open Globals

<<function Efuns.set_global>>
<<function Efuns.set_local>>
<<function Efuns.get_var>>
          
<<function Efuns.get_global>>
<<function Efuns.get_local>>
  
<<function Efuns.set_minor_var>>
<<function Efuns.set_major_var>>
  

@

\subsection*{[[core/attr.ml]]}

<<core/attr.ml>>=
<<copyright header efuns>>
open Efuns

(* see also Text.make_attr *)

<<function Window.get_font>>
        
<<function Window.get_color>>

@

\subsection*{[[core/hook.ml]]}

<<core/hook.ml>>=
<<copyright header efuns>>

<<constant Efuns.start_hooks>>
<<function Efuns.add_start_hook>>

<<function Efuns.exec_hooks>>

<<function Efuns.add_hook>>

<<function Frame.exec_named_hooks>>

<<function Ebuffer.exec_named_buf_hooks>>

<<function Ebuffer.exec_named_buf_hooks_with_abort>>

@

\subsection*{[[core/action.ml]]}

<<core/action.ml>>=
<<copyright header efuns>>
open Efuns

<<global Efuns.actions>>

<<function Efuns.define_action>>

<<function Efuns.define_buffer_action>>

<<function Efuns.get_action>>

<<function Efuns.execute_action>>

<<function Efuns.execute_buffer_action>>

@

\subsection*{[[core/globals.ml]]}

<<core/globals.ml>>=
<<copyright header efuns>>
open Efuns

(* there are other globals: actions, start_hooks, etc *)

<<global Efuns.global_location>>
<<function Efuns.location>>

<<function Efuns.with_lock>>

<<function Efuns.error>>

(*************************************************************************)
(*      Initialization      *)
(*************************************************************************)
  
(* Les variables importantes dans le reste du programme. *)
open Options

<<constant Efuns.check>>

<<constants Efuns.debug_xxx>>

<<constant Efuns.load_path>>

<<constant Efuns.path>>
  
<<constant Efuns.efuns_path>>
  
<<toplevel Efuns._1>>

(* used in some major mode *)
<<constant Efuns.font>>
  
(*--------------------    Ressources *)
<<constant Efuns.xdefaults>>

<<constant Efuns.x_res>>
<<toplevel Efuns._2>>
  
<<constant Efuns.t>>

(* for ipc/server too *)
<<constant Efuns.displayname>>

(*
  let _ = Printf.printf "%d %d %s %s %s" !width !height !font !fg !bg; 
  print_newline () 
*)
@

\subsection*{[[core/efuns.ml]]}


%-------------------------------------------------------------

<<core/efuns.ml>>=
<<copyright header2>>
(* Useful types for Efuns *)

(*************************************************************************)
(* Keymaps and actions *)
(*************************************************************************)

(* actually used only by top_window.ml *)
<<exception Efuns.UnboundKey>>

<<type Efuns.map>>
<<type Efuns.keySym>>
<<type Efuns.key>>

<<type Efuns.action>>

<<type Efuns.action_name>>

<<type Efuns.generic_action>>

<<type Efuns.mod_ident>>

<<type Efuns.keys>>

<<type Efuns.prefix>>

<<type Efuns.binding>>

(*************************************************************************)
(* Buffers *)
(*************************************************************************)

<<type Efuns.buffer>>

<<type Efuns.major_mode>>

<<type Efuns.minor_mode>>

(*************************************************************************)
(* Frames *)
(*************************************************************************)
  
<<type Efuns.frame>>

<<type Efuns.status_info>>

<<type Efuns.status>>

<<type Efuns.frm_line>>

(*************************************************************************)
(* Windows *)
(*************************************************************************)

<<type Efuns.top_window>>

<<type Efuns.window>>

<<type Efuns.window_up>>

<<type Efuns.window_down>>

(*************************************************************************)
(* The world *)
(*************************************************************************)

<<type Efuns.location>>

(*************************************************************************)
(* Regexps *)
(*************************************************************************)

<<type Efuns.sens>>
<<type Efuns.to_regexp>>

<<function Efuns.string_to_regex>>

open Options    
<<constant Efuns.regexp_option>>

(*************************************************************************)
(* Misc *)
(*************************************************************************)

(* used by frame, so can't be in top_window.ml *)
<<function Efuns.backend>>

@


\subsection*{[[core/text.ml]]}



%(* A FAIRE:
%On doit faire converger ce text vers un text directement affichable par
%WX_text. Pour cela:
%
%Modifier WX_text pour qu'il se satisfasse de l'interface de Text.
%En particulier, il doit n'utiliser que les fonctions suivantes:
%
%Text.representation text line --> string (buffer or copy) * int (position)
%Text.items line -> item array
%  
%Il doit aussi utiliser la structure un peu particuliere de l'arbre utiliser
%ici.
%  
%*)

%-------------------------------------------------------------

<<core/text.ml>>=
<<copyright header2>>
open Options

(*****************************************************************************)
(* Types *)
(*****************************************************************************)

<<type Text.position>>

<<type Text.position2>>

<<type Text.point>>

<<type Text.coord>>

<<type Text.delta>>

<<type Text.attribute>>


<<type Text.version>>

<<type Text.session>>


<<type Text.line>>

<<type Text.box>>

<<type Text.text>>
  
<<type Text.action>>

type t = text

(*****************************************************************************)
(* Global properties *)
(*****************************************************************************)
  
<<function Text.version>>
  
<<function Text.nbre_lines>>
  
<<function Text.size>>

(*****************************************************************************)
(* Line x Col *)
(*****************************************************************************)
  
<<function Text.point_col>>

<<function Text.find_line_of_pos>>
let find_line_of_pos a b =
  Common.profile_code "Text.find_line_of_pos" (fun () -> find_line_of_pos a b)

<<function Text.point_line>>

<<function Text.point_coord>>

(*****************************************************************************)
(* Helpers *)
(*****************************************************************************)

<<function Text.mk_line_with_pos>>

<<function Text.cancel_repr>>

(*****************************************************************************)
(* Attributes *)
(*****************************************************************************)

<<constant Text.highlight_bit>>

<<function Text.make_attr>>

<<constant Text.direct_attr>>
<<constant Text.inverse_attr>>

<<function Text.unset_attrs>>
<<function Text.set_attrs>>

<<function Text.get_attr>>
<<function Text.set_attr>>

(*****************************************************************************)
(* Gap *)
(*****************************************************************************)

<<function Text.move_gpoint_to>>
let move_gpoint_to a b = Common.profile_code "Text.move_gpoint_to"
  (fun () -> move_gpoint_to a b)

<<constant Text.add_amount>>
<<function Text.extend_gap>>
let extend_gap a b = Common.profile_code "Text.extend_gap"
  (fun () -> extend_gap a b)

(*****************************************************************************)
(* Low level insert/delete *)
(*****************************************************************************)

<<function Text.low_insert>>

<<function Text.low_delete>>

(*****************************************************************************)
(* Undo *)
(*****************************************************************************)

<<function Text.undo>>

<<function Text.start_session>>
  
<<function Text.commit_session>>

<<function Text.with_session>>


(*****************************************************************************)
(* Insert/delete public API *)
(*****************************************************************************)

<<function Text.insert_res>>

<<function Text.insert>>
  
<<function Text.delete_res>>

<<function Text.delete>>

<<function Text.insert_at_end>>


(*****************************************************************************)
(* Constructor *)
(*****************************************************************************)
  
<<function Text.compute_newlines>>

<<function Text.create>>
  
(*****************************************************************************)
(* Points *)
(*****************************************************************************)

<<function Text.new_point>>

<<function Text.dup_point>>

<<function Text.goto_point>>

<<function Text.move_point_to>>

<<function Text.remove_point>>

<<function Text.with_dup_point>>

<<function Text.with_new_point>>


(*****************************************************************************)
(* IO *)
(*****************************************************************************)

<<function Text.read>>

<<function Text.save>>

(*****************************************************************************)
(* Distance, delta *)
(*****************************************************************************)

<<function Text.low_distance>>

<<function Text.distance>>

<<function Text.compare>>

(*****************************************************************************)
(* Text Getters/setters *)
(*****************************************************************************)
  
<<function Text.get_char>>

(*****************************************************************************)
(* Moving *)
(*****************************************************************************)

<<function Text.fmove_res>>

<<function Text.bmove_res>>

<<function Text.bmove>>

<<function Text.fmove>>


<<function Text.move_res>>

<<function Text.move>>

(*****************************************************************************)
(* Position *)
(*****************************************************************************)
  
<<function Text.get_position>>

<<function Text.set_position>>

<<function Text.goto_line>>

(*****************************************************************************)
(* Sub content  *)
(*****************************************************************************)

let iter text cursor delta f =
  with_dup_point text cursor (fun cursor ->
    for _i = 0 to delta - 1 do
      f cursor;
      fmove text cursor 1
    done
  )

(*
let iter buf debut fin =
  let text = buf.buf_text in
  Text.with_new_point text (fun curseur ->
  Text.with_new_point text (fun final ->
    Text.set_position text curseur debut;
    Text.set_position text final fin;
    while curseur < final do
      let attr = Text.get_attr text curseur in
      Text.set_attr text curseur (attr lor Text.highlight_bit);
      Text.fmove text curseur 1
    done;
*)


(* should be in search/replace, but it's used by blit too *)
<<function Text.clean_text>>
    

<<function Text.blit>>
    
<<function Text.sub>>

<<function Text.region>>

(*****************************************************************************)
(* Search/replace  *)
(*****************************************************************************)

<<function Text.search_forward>>

<<function Text.replace_matched>>
  
<<function Text.search_forward_matched>>

<<function Text.search_forward_groups>>

<<function Text.search_backward>>

<<function Text.search_backward_groups>>

(*****************************************************************************)
(* Representation  *)
(*****************************************************************************)

<<constant Text.repr_string>>

<<constant Text.repr_size>>

<<constant Text.dummy_line>>
  
<<constant Text.tabreprs>>

<<type Text.charreprs>>

<<function Text.compute_representation>>
let compute_representation a b c = Common.profile_code "Text.compute_repr"
  (fun () -> compute_representation a b c)

(*****************************************************************************)
(* Point_to_xxx  *)
(*****************************************************************************)

<<function Text.point_to_eol>>

<<function Text.point_to_bol>>

<<function Text.point_to_eof>>

<<function Text.point_to_bof>>

<<function Text.point_to_lof>>

<<function Text.point_to_lol>>


<<function Text.point_to_line>>


(*****************************************************************************)
(* Misc  *)
(*****************************************************************************)

<<function Text.to_string>>

<<function Text.clear>>

<<function Text.update>>

<<function Text.lexing>>

    
<<function Text.readonly>>
  
<<function Text.toggle_readonly>>
  
@

%<<function Text.goto_xy>>=
%(*
%let goto_xy text point x y =
%%  let y =
%    if y < text.text_nlines then y
%    else text.text_nlines - 1
%  in
%  point.pos <- text.text_newlines.(y).position;
%  point.line <- y;
%  fmove text point x |> ignore
%*)
%@

%<<function Text.add>>=
%(*
%let add text point delta =
%  let gpos = text.gpoint.pos in
%  let gap_end = gpos + text.gsize in
%  if point <= gpos && point + delta > gpos then
%    point + delta + text.gsize
%  else
%  if point >= gap_end && point+delta < gap_end then
%    point + delta - text.gsize
%  else
%    point + delta
%*)
%@



%<<function Text.find_xy>>=
%let find_xy text point line pos =
%  let gpos = text.gpoint.pos in
%  let gline = text.gpoint.line in
%  let gap_end = gpos + text.gsize in
%
%  let y,x =
%    if pos >= gap_end then
%      (* go forward *)
%      let rec iter line =
%        if line >= text.text_nlines 
%        then text.text_nlines - 1
%        else
%          if text.text_newlines.(line).position > pos 
%          then line - 1
%          else iter (line + 1)
%      in
%      let line = 
%        if point > gap_end && pos > point 
%        then iter (line+1) 
%        else iter (gline+1) 
%      in
%      if line = gline 
%      then
%        let gchars = gpos - text.text_newlines.(gline).position in
%        line, gchars + pos - gap_end
%      else
%        line, pos - text.text_newlines.(line).position
%    else
%    (* go backward *)
%    let rec iter line =
%      if line > 0 
%      then
%        if text.text_newlines.(line).position > pos 
%        then iter (line - 1)
%        else line
%      else 0
%    in
%    let line = 
%      if point < gpos && pos <= point 
%      then iter line 
%      else iter gline in
%    line, pos - text.text_newlines.(line).position
%  in
%  x,y
%@
% was called find_xy, but confusing with xy used in efuns where
% they are more screen coordinates with ^M and 80col adjustments
% and anyway callsites can be translated to calls to the simpler
% find_line_of_pos.



%(*      
%module TextTree = WX_text.Make(Text)
%open TextTree
%*)
%  
%(* type t = tree tree_desc   *)
%
%(* external id: t -> tree tree_desc = "%identity" *)
%
%(*
%let print msg text =
%  let s = text.text_string in
%  let gpoint = text.gpoint in
%  let gsize  = text.gsize in
%  let len = text.text_size in
%  let gap_end = gpoint + gsize in
%    Printf.printf "%s: <<%s[gap:%d]%s>>" msg (String.sub s 0 gpoint) gsize 
%      (String.sub s gap_end (len - gap_end));
%    print_newline ()
% 
%let print_newlines text =
%  print_string "Newlines :";
%  for i = 0 to text.text_nlines - 1 do
%    Printf.printf " %d" text.text_newlines.(i).position;
%  done;
%  print_newline ()
%*)


%(*
%  let rec iter tree lines =
%    match tree with
%      Parts text ->
%        if lines = text.tree_nlines || lines = -1 then
%          (* Insert in the last part *)
%          iter text.tree_parts.(Array.length text.tree_parts - 1) (-1)
%        else
%        let rec iter2 lines i =
%          let tlines = match text.tree_parts.(i) with
%              Parts t -> t.tree_nlines
%            | Lines t -> t.tree_nlines 
%          in
%          if tlines > lines then
%            iter text.tree_parts.(i) lines
%          else
%            iter2 (lines - tlines) (i+1)
%        in
%        iter2 lines 0;
%        text.tree_modified <- true;
%        text.tree_nlines <- text.tree_nlines + nbr
%    | Lines text ->
%        let newtext = Array.create text.tree_nlines text.tree_parts.(0) in
%        Array.blit text.tree_parts 0 newtext 0 lines;
%        Array.blit t.text_newlines gline newtext lines nbr;
%        Array.blit text.tree_parts lines newtext (lines+nbr) (
%          text.tree_nlines - lines);
%        text.tree_modified <- true;        
%        text.tree_nlines <- text.tree_nlines + nbr
%  in
%  iter (Parts tree) gline
%*)


%type tree_desc =
%      { mutable tree_nlines: int;
%        mutable tree_width: int;
%        mutable tree_height: int;
%(*        mutable tree_parts: 'a array; *)
%(*        mutable tree_up: tree tree_desc; *)
%        mutable tree_pos: int;
%        mutable tree_modified: bool;
%        mutable line_height: int;
%        mutable line_width: int;
%
%        mutable tree_text: text 
%}
%
%let make_text text lines =
%  let nlines = Array.length lines in
%  let tree = {
%      tree_nlines = nlines;
%      tree_width = 0;
%      tree_height = 0;
%(*
%      tree_parts = [| Lines {
%          tree_nlines = nlines;
%          tree_width = 0;
%          tree_height = 0;
%          tree_parts = lines;
%          tree_up = tree;
%          tree_pos = 0;
%          tree_modified = true;
%          line_height = 0;
%          line_width = 0;
%          tree_text = text;      
%        }|];
%      tree_up = tree;
%*)
%      tree_pos = 0;
%      tree_modified = true;
%      line_height = 0;
%      line_width = 0;
%      tree_text = text;
%    }
%  in tree
%
%type t = tree_desc


\subsection*{[[core/ebuffer.ml]]}


%<<function Ebuffer.catch>>=
%(*
%let catch format buf f =
%  try
%    f ()
%  with e ->
%    let loc = Globals.location() in
%    let name = "*Messages*" in
%    let m = Printf.sprintf format (Utils.printexn e) in
%    try
%      let buf = Hashtbl.find loc.loc_buffers name in
%      Text.insert_at_end buf.buf_text (m ^ "\n");
%    with Not_found ->
%      create name None (Text.create (m^"\n")) (Keymap.create ())  |>ignore
%*)
%@



%-------------------------------------------------------------

<<core/ebuffer.ml>>=
<<copyright header2>>
open Common
open Efuns

(* this file is called ebuffer.ml because buffer.ml already exists in stdlib *)

<<constant Ebuffer.create_buf_hook>>
<<constant Ebuffer.modes_alist>>

<<function Ebuffer.create_syntax_table>>

<<constant Ebuffer.default_syntax_table>>

<<function Ebuffer.get_name>>

<<function Ebuffer.new_minor_mode>>

<<function Ebuffer.new_major_mode>>

<<constant Ebuffer.fondamental_mode>>
  
<<constant Ebuffer.tab_size>>

<<function Ebuffer.create>>

<<function Ebuffer.kill>>

open Options
  
<<constant Ebuffer.save_buffer_hooks>>
  
<<constant Ebuffer.saved_buffer_hooks>>

<<function Ebuffer.save>>
 
<<function Ebuffer.read>>

<<function Ebuffer.find_buffer_opt>>

<<constant Ebuffer.help_buffer_content>>

<<function Ebuffer.default>>
      
<<function Ebuffer.compute_representation>>

<<exception Ebuffer.BufferAlreadyOpened>>

<<function Ebuffer.change_name>>
  
<<function Ebuffer.set_mark>>

<<function Ebuffer.get_mark>>

<<function Ebuffer.remove_mark>>

<<constant Ebuffer.modes_old>>
<<constant Ebuffer.regexp_alist>>

<<function Ebuffer.set_major_mode>>

<<function Ebuffer.set_minor_mode>>

<<function Ebuffer.del_minor_mode>>
  
<<function Ebuffer.modep>>

<<constant Ebuffer.suffix_reg>>
  
<<function Ebuffer.set_buffer_mode>>
      
<<function Ebuffer.get_binding>>

<<function Ebuffer.message>>
      
<<toplevel Ebuffer._1>>
@


\subsection*{[[core/keymap.ml]]}


%<<function Keymap.unbound_key>>=
%let unbound_key buffer _ = raise UnboundKey
%@
%dead?
%<<function Keymap.define_char_binding>>=
%let define_char_binding map char (f : frame -> 'a) =
%  add_binding map [NormalMap,Char.code char] f
%@
%dead?
%dead: let keysym_to_name = []
% (it's in XK now)

%(*
%La gestion des keymaps est inadapte'e a` la modification dynamique.
%En effet, on aurait envie de pouvoir modifier les bindings selon divers
%  crite`res, tels que le buffer (possible), le mode(pas possible).
%*)
% ???

%-------------------------------------------------------------

<<core/keymap.ml>>=
<<copyright header2>>
open Efuns

<<function Keymap.dummy_action>>

<<function Keymap.create>>


<<function Keymap.print_key>>
            
<<function Keymap.print_key_list>>
   

<<function Keymap.get_binding>>
          
<<function Keymap.set_binding>>

<<function Keymap.add_binding>>
          
   
<<constant Keymap.c_h>>
<<constant Keymap.c_x>>
<<constant Keymap.c_c>>
<<constant Keymap.n_5>>

<<function Keymap.all_bindings>>
  
<<function Keymap.interactive>>

<<function Keymap.add_interactive>>

<<function Keymap.add_global_key>>
<<function Keymap.add_local_key>>
<<function Keymap.add_minor_key>>
<<function Keymap.add_major_key>>

<<function Keymap.define_interactive_action>>

@


\subsection*{[[core/minibuffer.ml]]}



%-------------------------------------------------------------

<<core/minibuffer.ml>>=
<<copyright header2>>
open Efuns

<<constant Minibuffer.charreprs>>
<<toplevel Minibuffer._1>>

<<function Minibuffer.buf_create>>

<<function Minibuffer.kill>>

<<function Minibuffer.return>>

<<function Minibuffer.create>>

<<function Minibuffer.create_return>>

<<function Minibuffer.update_request>>
  
@


\subsection*{[[core/window.ml]]}


%old: function Window.display>>=

%-------------------------------------------------------------

<<core/window.ml>>=
<<copyright header2>>
open Efuns

<<function Window.create_at_top>>

<<function Window.create>>

<<function Window.top>>

<<function Window.iter>>

<<function Window.first>>

<<function Window.last>>

<<function Window.next>>
      
<<function Window.prev>>
       
@


\subsection*{[[core/frame.ml]]}


%<<function Frame.resize>>=
%let resize frame =
%  install frame.frm_window frame
%@


%-------------------------------------------------------------

<<core/frame.ml>>=
<<copyright header2>>
open Common
open Options

open Efuns
open Text (* for the line fields *)

(*****************************************************************************)
(* Status line *)
(*****************************************************************************)

<<constant Frame.status_format>>

<<function Frame.status_print>>


<<function Frame.status_modified>>

<<function Frame.status_col>>

<<function Frame.status_major_mode>>

<<function Frame.status_line>>

<<function Frame.status_name>>

(*****************************************************************************)
(* Kill *)
(*****************************************************************************)

<<function Frame.kill>>

<<function Frame.kill_all>>

(*****************************************************************************)
(* Display *)
(*****************************************************************************)

<<function Frame.install>>

(*****************************************************************************)
(* Constructor *)
(*****************************************************************************)

<<constant Frame.editname>>
<<constant Frame.dummy_mode>>
  
<<function Frame.create_without_top>>

<<function Frame.active>>
      
<<function Frame.create>>

<<function Frame.create_inactive>>

(*****************************************************************************)
(* Cursor *)
(*****************************************************************************)

<<function Frame.point_to_cursor>>

<<function Frame.cursor_to_point>>


(*****************************************************************************)
(* Display *)
(*****************************************************************************)

<<function Frame.display_line>>

<<function Frame.point_to_xy_opt>>

<<function Frame.set_cursor>>

<<function Frame.update_table>>
let update_table a = Common.profile_code "Frame.update_table"
  (fun () -> update_table a)

<<function Frame.display>>
let display a = Common.profile_code "Frame.display"
  (fun () -> display a)

(*****************************************************************************)
(* Misc  *)
(*****************************************************************************)

<<exception Frame.BufferKilled>>
<<function Frame.unkill>>

<<function Frame.move_point>>

<<function Frame.current_dir>>

<<exception Frame.FoundFrame>>

<<function Frame.find_buffer_frame>>

<<constant Frame.change_buffer_hooks>>

<<function Frame.load_file>>

<<function Frame.change_buffer>>

<<function Frame.save_buffer>>

<<function Frame.bindings_help>>

<<function Simple.to_frame>>
  
@


\section{[[features/]]}



\subsection*{[[features/highlight.ml]]}

%-------------------------------------------------------------

<<features/highlight.ml>>=
<<copyright header efuns>>
open Efuns

<<constant Simple.highlighted>>
<<constant Simple.highlight_bit>>

<<function Simple.unhightlight_region>>

<<function Simple.hightlight_region>>

<<constant Simple.highlighted_chars>>

<<function Simple.unhightlight>>
  
<<function Simple.highlight>>

<<toplevel Highlight._>>
@

\subsection*{[[features/parameter.ml]]}

%-------------------------------------------------------------

<<features/parameter.ml>>=
<<copyright header efuns>>
open Options

<<type Simple.parameter>>
  
<<constant Simple.parameters_var>>
  
<<function Simple.add_parameter>>

<<function Simple.add_option_parameter>>
  
<<constant Simple.all_params>>
<<function Simple.all_parameters>>

@

\subsection*{[[features/mouse.ml]]}

%-------------------------------------------------------------

<<features/mouse.ml>>=
<<copyright header efuns>>
open Efuns

<<function Simple.mouse_drag_region>>

<<function Simple.mouse_yank_at_click>>

<<function Simple.mouse_save_then_kill>>

<<function Simple.mouse_set_frame>>

<<toplevel Mouse._>>

@

\subsection*{[[features/indent.ml]]}

%-------------------------------------------------------------

<<features/indent.ml>>=
<<copyright header efuns>>

<<function Simple.set_indent>>

@

\subsection*{[[features/structure.ml]]}

%-------------------------------------------------------------

<<features/structure.ml>>=
<<copyright header efuns>>
open Efuns

<<function Simple.next_hole>>


<<function Simple.insert_structure>>

<<function Simple.install_structures>>

@

\subsection*{[[features/simple.ml]]}

% value_to_key -> <>
<<function Simple.string_to_modifier>>=
let string_to_modifier s =  
  let mask = ref 0 in
  for i = 0 to String.length s - 1 do
    mask := !mask lor (match s.[i] with
      | 'C' -> controlMask
      | 'A' -> mod1Mask
      | 'M' -> mod1Mask
      | '1' -> mod1Mask
      | _ -> 0
    )
  done;
  !mask
@

<<constant Simple.name_to_keysym>>=
let name_to_keysym = 
  ("Button1", XK.xk_Pointer_Button1) ::
  ("Button2", XK.xk_Pointer_Button2) ::
  ("Button3", XK.xk_Pointer_Button3) ::
  ("Button4", XK.xk_Pointer_Button4) ::
  ("Button5", XK.xk_Pointer_Button5) ::
  XK.name_to_keysym
@


<<function Simple.value_to_key>>=
(* form: SC-Button1 *)
let value_to_key v =
  match v with 
    Value s -> 
      let key, mods = 
        try
          let index = String.index s '-' in
          let mods = String.sub s 0 index in
          let key = String.sub s (index+1) (String.length s - index - 1) in
          key, mods
        with _ -> s, ""
      in
      let key = List.assoc key name_to_keysym in
      let mods = string_to_modifier mods in
      let map = 
        if mods land (controlMask lor mod1Mask) = (controlMask lor mod1Mask)
        then ControlMetaMap else
        if mods land controlMask <> 0 then ControlMap else
        if mods land mod1Mask <> 0 then MetaMap else NormalMap
      in
      map, key
      
  | _ -> raise Not_found
@

<<function Simple.key_to_value>>=
let key_to_value k = Value (Keymap.print_key k)
@




<<function Simple.line_size>>=
let line_size frame =
  (point_to_end frame) + (point_to_end frame)
@


<<constant Simple.last_kill>>=
let last_kill = ref None
@

<<function Simple.kill_text>>=
let kill_text text point len =
  let point,str = Text.delete_res text point len in
  match !last_kill with
  | Some (oldtext,oldpoint) when
    oldpoint = point && oldtext == text ->
      kill_ring.(0) <- kill_ring.(0)^str
  | _ ->
      last_kill := Some (text,point);
      kill_string str
@


<<function Simple.kill_eol>>=
let kill_eol buf point =
  let text = buf.buf_text in
  let eol = Text.point_to_eol text point in
  let len =
    if eol = 0 then 1 else eol
  in
  kill_text text point len
@

<<function Simple.kill_bol>>=
let kill_bol buf point =
  let text = buf.buf_text in
  let len = Text.point_to_bol text point in
  if len > 0 then
    ( Text.bmove text point len;
      kill_text text point len)
@

<<function Simple.to_frame>>=
let to_frame f frame =
  f frame.frm_buffer frame.frm_point
@


<<function Simple.current_word>>=
let current_word buf point =
  (beginning_of_word buf point) ^ (end_of_word buf point)
@



<<function Simple.set_indent>>=
(* modify the indentation of (point) line. Does not modify point *)
let set_indent text point offset = 
  Text.with_dup_point text point (fun curseur ->
    Text.bmove text curseur (Text.point_to_bol text curseur);
    let rec iter offset =
      let c = Text.get_char text curseur in
      if offset > 0 then
        if c = ' ' then
          (Text.fmove text curseur 1; iter (offset - 1))
        else
        if c = '\t' then
          (Text.delete text curseur 1;
           iter offset)
        else
          (Text.insert text curseur (String.make offset ' '))
      else
      if c = ' ' || c='\t' then
        (Text.delete text curseur 1;
          iter 0)
    in
    iter offset
  )
@

<<toplevel Simple._1>>=
let _ =
  <<Simple toplevel setup>>
  Hook.add_start_hook (fun () ->
    let loc = Globals.location () in
    let gmap = loc.loc_map in

    <<[[Simple._]] start hook>>


    Keymap.add_interactive (loc.loc_map) "fondamental_mode" 
      (fun frame -> Ebuffer.set_major_mode frame.frm_buffer 
          Ebuffer.fondamental_mode);

    Var.set_global line_comment ""
  )
@


%-------------------------------------------------------------

<<features/simple.ml>>=
<<copyright header2>>
open Efuns
open Xtypes

(*****************************************************************************)
(* Insertion *)
(*****************************************************************************)

<<function Simple.insert_string>>
  
<<constant Simple.single_char>>
<<function Simple.insert_char>>

<<function Simple.insert_return>>

<<function Simple.previous_char>>

<<function Simple.unset_attr>>
  
<<function Simple.insert_at_place>>


<<constant Simple.overwrite_mode>>
  
  
<<function Simple.self_insert_command>>
    
<<function Simple.char_insert_command>>

(*****************************************************************************)
(* Deletion *)
(*****************************************************************************)

<<function Simple.delete_char>>

<<function Simple.delete_backspace_char>>

<<function Simple.hungry_char>>

<<function Simple.hungry_electric_delete>>

(*****************************************************************************)
(* Navigation *)
(*****************************************************************************)

<<function Simple.move_backward>>

<<function Simple.move_forward>>

<<function Simple.begin_to_point>>

<<function Simple.point_to_end>>


<<function Simple.line_size>>

<<function Simple.beginning_of_line>>

<<function Simple.end_of_line>>


<<constant Simple.temporary_goal_column>>

<<function Simple.goal_column>>

<<function Simple.move_to_goal_column>>

<<function Simple.forward_line>>

<<function Simple.backward_line>>


(*****************************************************************************)
(* Kill *)
(*****************************************************************************)

<<constant Simple.kill_size>>
<<constant Simple.kill_max>>
<<constant Simple.kill_ring>>
<<constant Simple.last_kill>>
<<constant Simple.last_insert>>

<<function Simple.kill_string>>


<<function Simple.kill_text>>

<<function Simple.kill_end_of_line>>

<<function Simple.kill_eol>>

<<function Simple.kill_bol>>

<<function Simple.insert_killed>>

<<function Simple.insert_next_killed>>


<<function Simple.kill_region>>

<<function Simple.copy_region>>
  

(*****************************************************************************)
(* Words *)
(*****************************************************************************)

<<function Simple.in_next_word>>

<<function Simple.in_prev_word>>


<<function Simple.to_begin_of_word>>

<<function Simple.to_end_of_word>>


<<function Simple.backward_word>>

<<function Simple.forward_word>>

<<function Simple.beginning_of_word>>

<<function Simple.end_of_word>>

<<function Simple.current_word>>
 
<<function Simple.delete_backward_word>>

<<function Simple.delete_forward_word>>

<<function Simple.on_word>>
  
<<function Simple.transpose_words>>


<<function Simple.transpose_chars>>

(*****************************************************************************)
(* Paragraphs *)
(*****************************************************************************)

<<function Simple.backward_paragraph>>

<<function Simple.forward_paragraph>>

(*****************************************************************************)
(* Scroll *)
(*****************************************************************************)

(*
let move_backward frame =
   Functions.move_backward frame 1; ()

let move_forward frame = 
  Functions.move_forward frame 1; () 
*) 
  
<<function Simple.forward_screen>>

<<function Simple.backward_screen>>

<<function Simple.scroll_line>>

<<function Simple.scroll_down>>

<<function Simple.scroll_up>>

<<function Simple.scroll_other_up>>

<<function Simple.scroll_other_down>>

<<function Simple.recenter>>

(*****************************************************************************)
(* Position history *)
(*****************************************************************************)

<<constant Simple.history_pos_max>>

<<function Simple.save_current_pos>>

<<function Simple.goto_last_saved_pos>>

(*****************************************************************************)
(* File *)
(*****************************************************************************)

<<function Simple.end_of_file>>

<<function Simple.begin_of_file>>

(*****************************************************************************)
(* Undo *)
(*****************************************************************************)

<<function Simple.undo>>

(*****************************************************************************)
(* Color helpers *)
(*****************************************************************************)

<<function Simple.color>>
let color a b c d = Common.profile_code "Simple.color" 
  (fun () -> color a b c d)

(*****************************************************************************)
(* Points *)
(*****************************************************************************)

<<function Simple.point_at_mark>>


(*****************************************************************************)
(* Electric *)
(*****************************************************************************)

<<function Simple.electric_insert_space>>

<<function Simple.simplify>>

<<constant Simple.line_comment>>

<<function Simple.fill_paragraph>>
  
<<function Simple.insert_special_char>>

(*****************************************************************************)
(* Keys *)
(*****************************************************************************)
open Options

<<function Simple.string_to_modifier>>
  
<<constant Simple.name_to_keysym>>
  
<<function Simple.value_to_key>>
  
<<function Simple.key_to_value>>
      
<<constant Simple.key_option>>

<<constant Simple.binding_option>>

(*****************************************************************************)
(* Toplevel *)
(*****************************************************************************)
  
<<toplevel Simple._1>>
  
@

%  (*
%external id : 'a -> 'a = "%identity"
%let add_string_parameter location name param = 
%  add_parameter location name id id param
%let add_int_parameter location name param = 
%  add_parameter location name int_of_string string_of_int param
%let add_float_parameter location name param = 
%  add_parameter location name float_of_string string_of_float param
%let add_bool_parameter location name param = 
%  add_parameter location name bool_of_string string_of_bool param
%    *)
% ????

 
%(*
%     let move_backward frame =
%   Functions.move_backward frame 1; ()
%
%let move_forward frame = 
%  Functions.move_forward frame 1; () 
%*) 




%<<function Simple.modifier_to_string>>=
%(*
%let modifier_to_string mask = 
%  let s = if mask land shiftMask = 0 then "" else "S" in
%  let s = if mask land controlMask = 0 then s else "C" ^ s in
%  let s = if mask land mod1Mask = 0 then s else "M" ^ s in
%  let s = if mask land mod2Mask = 0 then s else "2" ^ s in
%  let s = if mask land mod3Mask = 0 then s else "3" ^ s in
%  let s = if mask land mod4Mask = 0 then s else "4" ^ s in
%  let s = if mask land mod5Mask = 0 then s else "5" ^ s in
%  s
%*)
%@

%<<function Simple.value_to_keysym>>=
%(*
%let value_to_keysym v =
%  match v with
%    Value v -> List.assoc v name_to_keysym
%  | _ -> raise Not_found
%*)
%@

%<<function Simple.keysym_to_value>>=
%(*
%let keysym_to_value k =
%  Value (List.assoc k XK.keysym_to_name)
%*)
%@

%<<function Simple.format_to>>=
%let format_to frame =
%  let point = frame.frm_point in
%  let buf = frame.frm_buffer in
%  let text = buf.buf_text in
%  Format.set_formatter_output_functions 
%    (fun str pos len ->
%      let s = String.sub str pos len in
%      Text.insert text point s;
%      Text.fmove text point len)
%  (fun () -> ())
%@
%

%<<function Simple.format_to_string>>=
%let format_to_string () =
%  let string = ref "" in
%  Format.set_formatter_output_functions 
%    (fun str pos len ->
%      let s = String.sub str pos len in
%      string := !string ^ s)
%  (fun () -> ());
%  string
%@



%<<function Simple.current_word>>=
%(*
%let current_word buf point =
%  let text = buf.buf_text in
%  let syntax = buf.buf_syntax_table in
%  let start = dup_point text point in
%  to_begin_of_word text start syntax;
%  let term = dup_point text point in
%  to_end_of_word text term syntax;
%  let word = Text.region text start term in
%  remove_point text start;
%  remove_point text term;
%  word
%*)
%@


\subsection*{[[features/select.ml]]}


<<function Select.select_yes_or_no>>=
let select_yes_or_no frame request action =
  let top_window = Window.top frame.frm_window in
  let map = Keymap.create () in
  let yes_reply mini_frame = 
    Minibuffer.kill mini_frame frame;
    top_window.top_second_cursor <- None;
    action true
  in
  let no_reply  mini_frame = 
    Minibuffer.kill mini_frame frame;
    top_window.top_second_cursor <- None;
    action false
  in
  Keymap.add_binding map [NormalMap, Char.code 'y'] yes_reply;
  Keymap.add_binding map [NormalMap, Char.code 'Y'] yes_reply;
  Keymap.add_binding map [NormalMap, Char.code 'n'] no_reply;
  Keymap.add_binding map [NormalMap, Char.code 'N'] no_reply;
  let mini = Minibuffer.create frame map request in
  mini.frm_buffer.buf_map_partial <- false;
  mini
@

<<function Select.find_completion_frame>>=
let find_completion_frame frame =
  let buf = Ebuffer.default "*Completions*" in
  Frame.find_buffer_frame buf
@

<<function Select.display_completions>>=
let display_completions frame list =
  let top_window = Window.top frame.frm_window in
  if list = [] 
  then Top_window.message top_window "No Completions"
  else
    let rec iter list s =
      match list with
      | [] -> s
      | [f] -> Printf.sprintf "%s\n%s" s f
      | f1::f2::tail  ->
          iter tail (Printf.sprintf "%s\n%-40s%s" s f1 f2)
    in
    let buf = Ebuffer.default "*Completions*" in
    let text = buf.buf_text in
    Text.update text (iter list "Completions :");
    
    let hooks = try Var.get_global completions_buf_hook with Not_found -> [] in
    Hook.exec_hooks hooks buf;

    (try Frame.find_buffer_frame buf
     with Not_found -> Frame.create_inactive (Multi_frames.cut_frame frame) buf
    ) |> ignore
@

<<function Text.update>>=
let update text str =
  let newlines = compute_newlines str in
  let len = String.length str in
  text.text_points |> List.iter (fun point -> 
    point.pos <- get_position text point
  );
  text.text_string <- str;
  text.text_attrs <- (Array.create len direct_attr);
  text.text_size <- len;
  text.gpoint <- { pos = 0; line = 0 };
  text.gsize <- 0;
  text.text_newlines <- newlines;
  text.text_nlines <- Array.length newlines;
  text.text_modified <- text.text_modified + 1 ;
  text.text_clean <- true;
  text.text_history <- [];
  text.text_points |> List.iter (fun point -> 
      let pos = point.pos in
      point.pos <- 0;
      point.line <- 0;
      set_position text point pos
  ) 
  
@

<<function Select.remove_completions>>=
let remove_completions frame =
  try
    let frame = find_completion_frame frame in
    Multi_frames.remove_frame frame
  with Not_found -> ()
@

<<function Select.set_history>>=
let set_history map string history =
  let current = ref 0 in
  Keymap.add_binding map [NormalMap, XK.xk_Up] (fun mini_frame ->
    if !current = List.length !history 
    then Top_window.mini_message mini_frame "No previous line in history"
    else begin
      let ele = Utils.list_nth !current !history in
      incr current;
      let buf = mini_frame.frm_buffer in
      let text = buf.buf_text in
      Text.clear text;
      string := ele;
      Simple.insert_string mini_frame ele
    end
  );      
  Keymap.add_binding map [NormalMap, XK.xk_Down] (fun mini_frame ->
    if !current < 1 
    then Top_window.mini_message mini_frame "No other line in history"
    else begin
      decr current;
      let ele = Utils.list_nth !current !history in
      let buf = mini_frame.frm_buffer in
      let text = buf.buf_text in
      Text.clear text;
      string := ele;
      Simple.insert_string mini_frame ele; ()
    end
  )
@

<<function Text.clear>>=
let clear text =
  low_delete text 0 (text.text_size - text.gsize) |> ignore;
  text.text_history <- [];
  List.iter (fun p -> p.pos <- 0; p.line <- 0) text.text_points
@



<<constant Select.file_hist>>=
let file_hist = ref []
@

<<constant Select.dont_complete>>=
(* todo: could use File_type.is_obj_file to unify the treatment of obj file
 * in C-x C-f and shell
 *)
let dont_complete = define_option ["avoid_filenames"] ""
    (list_option string_option) 
  [ ".*\\.o$"; ".*\\.cm.$";".*\\.cmxa$";".*~";".*\\.a$";"core$";"\\..*"]
@

<<constant Select.dont_complete_regexps>>=
let dont_complete_regexps = ref ([],Str.regexp "")
@

<<function Select.dont_complete_regexp>>=
let dont_complete_regexp () =
  let (old,reg) = !dont_complete_regexps in
  if old == !!dont_complete 
  then reg
  else
    let reg = Str2.regexp_from_list !!dont_complete in
    dont_complete_regexps := (!!dont_complete, reg);
    reg
@

<<function Select.avoid_completion>>=
let avoid_completion s =
  let bad_regexp = dont_complete_regexp () in
  not (Str.string_match bad_regexp s 0)
@

<<function Select.is_userdir>>=
let is_userdir string =
  let n = String.length string in
  (n > 1) && (string.[0] = '~') &&
  (try
      String.rindex string '/' |> ignore;
      false
   with Not_found -> true
   )
@

<<function Select.complete_filename>>=
let complete_filename frame good_file filename =
  if is_userdir filename 
  then (* Parse_file.users *) failwith "Select.complete_filename: TODO"
  else
  let filename = Utils.string_to_filename filename in
  let dirname = dirname frame filename in
  let file_list = Utils.file_list dirname in
  let file_list = file_list |> List.map (fun file ->
    let path = Filename.concat dirname file in
    try 
      let stat = Unix.stat path in
      match stat.Unix.st_kind with
      | Unix.S_DIR -> file ^ "/"
      | _ -> file
    with exn -> 
      pr2 (spf "complete_filename: exn = %s" (Common.exn_to_s exn));
      file
  )
  in

  match file_list with
  | a::b::_ -> 
      begin
        match 
          List.fold_left (fun list ele ->
              if good_file ele then ele :: list else list
          ) [] file_list
        with
          [] -> file_list 
            (* if no completion is OK, return files that should have 
          been avoided *)
        | list -> list
      end
  | _ -> file_list
@

<<function Select.select_file>>=
let select_file frame request history start action =
  let map = Keymap.create () in
  let string = ref "" in
  Keymap.add_binding map [ControlMap, Char.code 'g'] (fun mini_frame ->
    pr2 "HERE";
    remove_completions mini_frame;
    Minibuffer.kill mini_frame frame
  );
  let completion = ref "_*NoCompletion*_" in
  let completions = ref [] in
  Keymap.add_binding map [NormalMap, XK.xk_Tab] (fun mini_frame ->
    let text = mini_frame.frm_buffer.buf_text in
    (*if (!completion <> !string) then  *)
    begin
      string := Text.to_string text;
      completions := complete_filename frame avoid_completion !string;
      let suffix, n = 
        Utils.common_suffix !completions (basename !string) in
      let suffix = 
        let s = !string ^ suffix in
        let len = String.length s in
        if len>0 && s.[len - 1] <> '/' 
        then
          try
            let filename = Utils.string_to_filename s in
            let dirname = dirname frame filename in
            let basename = basename filename in
            let stat = Unix.stat (Filename.concat dirname basename) in
            match stat.Unix.st_kind with
            |  Unix.S_DIR -> suffix ^ "/"
            | _ -> suffix
          with _ -> suffix
        else suffix
      in
      completion := !string;
      Text.insert text mini_frame.frm_point suffix;
      Text.fmove text mini_frame.frm_point (String.length suffix);
      string := Text.to_string text;
       if n>1 
       then
          display_completions frame
            (Utils.completion !completions (basename !string))
    end
(* TODO later, but right now have some bad side effects.
 e.g. if do TAB in one dir, then do M-back to remove a dir, and rerun
 TAB then it does not update the completion buffer with the candidates
 for the new dir, so for now commented!
   else
    (* can be improved, by displaying another part of the completion buffer *)
      display_completions frame
          (Utils.completion !completions (basename !string))
*)
  );
  set_history map string history;
  incremental_mini_buffer frame map request start
    (fun frame str -> string := str)
    (fun old_frame str -> 
      history := str :: !history;
      remove_completions frame;
      let str = Utils.string_to_filename str in
      action str
    ) |> ignore;
  Keymap.add_binding map [NormalMap, XK.xk_Prior] (fun frame ->
    let frame = find_completion_frame frame in
    Simple.backward_screen frame
  );
  Keymap.add_binding map [NormalMap, XK.xk_Next] (fun frame ->
    let frame = find_completion_frame frame in
    Simple.forward_screen frame
  );
  Keymap.add_binding map [NormalMap, Char.code '~'] (fun frame ->
    let buf = frame.frm_buffer in
    let text = buf.buf_text in
    let point = frame.frm_point in
    Simple.kill_bol buf point;
    Simple.self_insert_command frame;      
    string := Text.to_string text
  );
  Keymap.add_binding map [NormalMap, Char.code '/'] (fun frame ->
    let buf = frame.frm_buffer in
    let text = buf.buf_text in
    let point = frame.frm_point in
    if Text.bmove_res text point 1 = 1 then
      ( let c = Text.get_char text point in
        Text.fmove text point 1;
        if c = '/' then
          Simple.kill_bol buf point);
    Simple.self_insert_command frame;
    string := Text.to_string text            
  );
  ()
@

<<function Select.select_filename>>=
let select_filename frame request action =
  let curdir = Frame.current_dir frame in
  select_file frame request file_hist (Utils.filename_to_string curdir) action
@




<<function Select.get_previous_frame>>=
let get_previous_frame () = 
  match !prev_buffers with
  | [] -> ""
  | x::xs -> x
@

<<constant Select.buf_hist>>=
let buf_hist = ref []
@

<<function Select.select_buffer>>=
let select_buffer frame request default action =
  Select.select frame (request^"(default :"^ default ^ ") ") buf_hist ""
    (fun _ -> buffer_list frame) 
    (fun s ->s) 
    (fun str ->
      let str = if str = "" then default else str in
      action str)
@

<<function Select.select_string>>=
let select_string frame request history default action =
  let map = Keymap.create () in
  let string = ref "" in
  set_history map string history;
  Minibuffer.create_return frame map request default
    (fun _ str -> 
      (match !history with
          hd :: _ when hd = str -> ()
        | _ -> if str <> "" then
              history := str :: !history);
      action str
    ) |> ignore
@

<<function Select.simple_select>>=
let simple_select frame request action =
  let map = Keymap.create () in
  Minibuffer.create_return frame map request "" (fun _ str -> action str) 
   |> ignore
@


%-------------------------------------------------------------

<<features/select.ml>>=
<<copyright header2>>
open Common
open Options
open Efuns

(* small wrappers around Filename but that better handles
 * completion on directories.
 *)
let basename str =
  if str = "" || str =~ ".*/$"
  then ""
  else Filename.basename str

let dirname frame filename =
  let str =
    if Filename.is_relative filename 
    then Filename.concat (Frame.current_dir frame) filename
    else filename
  in
  match str with
  | "" -> Frame.current_dir frame
  | _ when str =~ ".*/$" -> filename
  | _ -> Filename.dirname str


<<function Select.select_yes_or_no>>

<<function Select.find_completion_frame>>

let completions_buf_hook = Local.create_abstr "completions_buf_hook"

<<function Select.display_completions>>

<<function Select.remove_completions>>

<<function Select.set_history>>

<<function Select.incremental_mini_buffer>>

<<function Select.select>>
  
  (****************************************************
  
               Filename selection
  
  ****************************************************)

<<constant Select.file_hist>>

<<constant Select.dont_complete>>
  
<<constant Select.dont_complete_regexps>>
<<function Select.dont_complete_regexp>>

<<function Select.avoid_completion>>

<<function Select.is_userdir>>

<<function Select.complete_filename>>

<<function Select.select_file>>

<<function Select.select_filename>>


  (****************************************************
  
               Other selection
  
  ****************************************************)

<<function Select.select_string>>


<<function Select.simple_select>>
  
  
@


\subsection*{[[features/complexe.ml]]}
% used to be complex.ml, but conflict with stdlib

<<function Complex.save_buffers_and_action>>=
let rec save_buffers_and_action frame buffers action =
  match buffers with
    [] -> let () = action frame in ()
  | (_,buf) :: buffers ->
      let text = buf.buf_text in
      if buf.buf_last_saved = Text.version text  ||
        buf.buf_name.[0] = '*'
      then
        save_buffers_and_action frame buffers action
      else
      let map = Keymap.create () in
      let request = Printf.sprintf "Save buffer %s ? (y,n,!,a)" buf.buf_name
      in
      let yes mini_frame =
        Minibuffer.kill mini_frame frame;
        Ebuffer.save buf;
        save_buffers_and_action frame buffers action
      in
      let no mini_frame =
        Minibuffer.kill mini_frame frame;
        save_buffers_and_action frame buffers action; ()
      in
      let action_immediately mini_frame = 
        Minibuffer.kill mini_frame frame;
        let () = action mini_frame in ()
      in
      let abort mini_frame =
        Minibuffer.kill mini_frame frame
      in
      Keymap.add_binding map [NormalMap, Char.code 'y'] yes;
      Keymap.add_binding map [NormalMap, Char.code 'Y'] yes;
      Keymap.add_binding map [NormalMap, Char.code 'n'] no;
      Keymap.add_binding map [NormalMap, Char.code 'N'] no;
      Keymap.add_binding map [NormalMap, Char.code '!'] action_immediately;
      Keymap.add_binding map [NormalMap, Char.code 'a'] abort;
      Keymap.add_binding map [NormalMap, Char.code 'A'] abort;
      Keymap.add_binding map [ControlMap, Char.code 'g'] abort;
      Minibuffer.create frame map request |> ignore
@



<<function Complex.reload>>=
let reload frame = 
  let buf = frame.frm_buffer in
  let text = buf.buf_text in
  match buf.buf_filename with
    None -> ()
  | Some file ->
      let inc = open_in file in
      let s = Utils.read_string inc in
      close_in inc;
      let point = frame.frm_point in
      let pos = Text.get_position text point in
      Text.clear buf.buf_text;
      Text.insert_at_end text s;
      Text.set_position text point pos;
      List.iter (fun f -> f buf) buf.buf_major_mode.maj_hooks;
      List.iter (fun minor_mode -> List.iter
          (fun f -> f buf) minor_mode.min_hooks) buf.buf_minor_modes;
      Frame.status_modified frame false 
@





<<constant Complex.display_hist>>=
(*let display_hist = ref []*)
@

<<function Complex.open_display>>=
let open_display frame =
  failwith "Complex.open_display: TODO"
(*
  select frame "open_display :" display_hist ""
    (fun _ -> [])
  (fun s -> s)
  (fun name -> 
      let top_window = Window.top frame.frm_window in
      let location = top_window.top_location in
      let dpy_oo = new WX_display.t name in
      let root_oo = new WX_root.t dpy_oo 0 in
      let display = WX_xterm.create_display root_oo
          location.loc_colors_names location.loc_fonts_names
        in
      Top_window.create location display |> ignore
   )
*)
@





<<constant Complex.umask>>=
let umask = 
  let old = Unix.umask 0 in 
  Unix.umask old |> ignore;
  old
@

<<constant Complex.file_perm>>=
let file_perm = Local.create "file_perm" string_of_int int_of_string
@
% create_int?

<<function Complex.mkdir>>=
let mkdir frame =
  Select.select_filename frame "Make directory: "
    (fun str -> 
      let file_perm = try Var.get_var frame.frm_buffer file_perm with _ -> 
            0x1ff land (lnot umask) in
      Unix.mkdir str file_perm)
@



<<constant Complex.value_hist>>=
let value_hist = ref []
@

<<constant Complex.all_vars>>=
let all_vars = ref None
@

<<function Complex.all_variables>>=
let all_variables frame _ =
  let buf = frame.frm_buffer in
  match !all_vars with
    Some (f,l) when f == frame -> l
  | _ ->
      let list = 
        (Local.list buf.buf_vars) @ 
        (Local.list (Globals.location()).loc_vars) 
      in
      all_vars := Some (frame, list);
      list
@

<<function Complex.set_local_variable>>=
let set_local_variable frame = 
  Select.select frame "set_local_variable : " variable_hist
    "" (all_variables frame) (fun s -> s) (fun variable ->
      Select.select_string frame (Printf.sprintf "%s : " variable)
      value_hist "" (fun value ->
          Local.input frame.frm_buffer.buf_vars variable value))
@

<<function Complex.set_global_variable>>=
let set_global_variable frame =
  Select.select frame "set_global_variable : " variable_hist
    "" (all_variables frame) (fun s -> s) (fun variable ->
      Select.select_string frame (Printf.sprintf "%s : " variable)
      value_hist "" (fun value ->
          Local.input (Globals.location()).loc_vars variable value))
@



<<toplevel Complex._1>>=
let _ =
  Hook.add_start_hook (fun () ->
    let loc = Globals.location() in
      Keymap.add_interactive loc.loc_map "make_directory" mkdir;
      Keymap.add_interactive loc.loc_map "set_local_variable" 
        set_local_variable;
      Keymap.add_interactive loc.loc_map "set_global_variable" 
        set_global_variable;
      Keymap.add_interactive loc.loc_map "set_parameter" set_parameter;
      Keymap.add_interactive loc.loc_map "get_parameter" get_parameter;
      
  )
@


%-------------------------------------------------------------

<<features/complexe.ml>>=
<<copyright header2>>
open Efuns
open Unix

<<function Complex.save_buffers_and_action>>

<<constant Complex.buf_mtime>>

<<function Complex.update_time>>
      
<<function Complex.reload>>
      
<<function Complex.check_file>>
    
<<function Complex.exit_efuns>>

<<function Complex.save_some_buffers>>

<<function Complex.load_buffer>>

<<function Complex.insert_file>>

<<function Complex.write_buffer>>

<<function Complex.save_buffer>>

<<function Complex.window_load_buffer>>

<<function Complex.window_change_buffer>>

<<function Complex.change_font>>

<<constant Complex.display_hist>>
<<function Complex.open_display>>

<<function Complex.goto_line>>

<<function Complex.goto_char>>


<<function Complex.get_pos>>

<<function Complex.mark_at_point>>

<<constant Complex.umask>>
  
<<constant Complex.file_perm>>
<<function Complex.mkdir>>

<<constant Complex.eval_history>>
<<function Complex.eval>>

<<constant Complex.variable_hist>>
<<constant Complex.value_hist>>
  
<<constant Complex.all_vars>>
<<function Complex.all_variables>>
  
<<function Complex.set_local_variable>>
  
<<function Complex.set_global_variable>>
  
<<function Complex.get_variable>>

open Options
  
<<constant Complex.parameters_hist>>
  
<<function Complex.set_parameter>>
  
<<function Complex.get_parameter>>

 
<<toplevel Complex._1>>
  
@


\subsection*{[[features/system.ml]]}


%-------------------------------------------------------------

<<features/system.ml>>=
open Common
open Efuns
open Unix

type end_action = (Efuns.buffer -> int -> unit)

(* Takes pwd in parameter. The alternative is to do
 * a Unix.chdir just before the command.
 *)

<<function System.open_process>>

<<function System.system>>

<<function System.start_command>>

<<constant System.shell_hist>>
<<function System.shell_command>>
  
@


\subsection*{[[features/search.ml]]}

<<toplevel Search._1>>=
(*let _ = Time.init ()*)
@


<<function Search.to_regexp>>=
let to_regexp flag str =
  match flag with
  | Regexp ->
      (if !case_fold 
       then Str.regexp_case_fold 
       else Str.regexp
      ) str
  | RegexpString ->
      (if !case_fold 
       then Str.regexp_string_case_fold
       else Str.regexp_string
      ) str
@

<<type Search.query>>=
type query = NoQuery | Query of frame * string
@


<<function Search.no_query>>=
let no_query f = f true
@

<<function Search.query>>=
let query frame request f =
  let top_window = Window.top frame.frm_window in
  top_window.top_second_cursor <- Some frame;
  Select.select_yes_or_no frame request f |> ignore
@

<<constant Search.string_history>>=
let string_history = ref []
@



<<constant Search.library_regexp>>=
let library_regexp = Str.regexp ".*\\.cm[oa]"
@

<<function Search.library_file>>=
let library_file str =
  Str.string_match library_regexp str 0
@

<<function Search.select_lib_filename>>=
let select_lib_filename frame request action =
  Select.select frame request Select.file_hist (Frame.current_dir frame)
  (Select.complete_filename frame library_file)
  Filename.basename action
@


%-------------------------------------------------------------

<<features/search.ml>>=
<<copyright header2>>
open Efuns
    
<<toplevel Search._1>>

<<constant Search.case_fold>>
<<function Search.to_regexp>>

<<type Search.query>>

<<function Search.replace>>


<<function Search.no_query>>
<<function Search.query>>

<<constant Search.string_history>>
<<function Search.select_replace>>

<<function Search.replace_string>>

<<function Search.query_replace_string>>

<<function Search.replace_regexp>>

<<function Search.query_replace_regexp>>

<<constant Search.library_regexp>>
<<function Search.library_file>>

<<function Search.select_lib_filename>>

<<constant Search.last_search>>
<<function Search.isearch>>


<<constant Search.isearch_forward_regexp>>
<<constant Search.isearch_forward>>
<<constant Search.isearch_backward>>
<<constant Search.isearch_backward_regexp>>
  
@


\subsection*{[[features/interactive.ml]]}



%-------------------------------------------------------------

<<features/interactive.ml>>=
<<copyright header2>>
open Efuns
  
<<function Interactive.create_bindings>>

<<constant Interactive.meta_hist>>

<<function Interactive.buf_interactives>>
  
<<function Interactive.exec_interactive>>
      
<<function Interactive.call_interactive>>
@


\subsection*{[[features/abbrevs.ml]]}

%-------------------------------------------------------------

<<features/abbrevs.ml>>=
<<copyright header2>>
(*
Expansion des abbreviations: 
deux fonctions principales: 
- "dabbrev_expand": expansion des mots a partir de mots trouves dans les
     buffers (binding normap "M-/").
- "expand_sabbrev": expansion des mots a partir d'abbreviations trouvees
    dans des tables associees au buffer (variable "abbrev_table") 
    (binding normal: un caractere de fin de mot (espace,newline,..))
*)
open Efuns


<<function Abbrevs.escaped>>
  
<<constant Abbrevs.dabbrev_buf>>
<<function Abbrevs.dabbrev_expand>>

<<constant Abbrevs.abbrev_table>>
  
<<function Abbrevs.expand_sabbrev>>

<<toplevel Abbrevs._1>>
  
@


\subsection*{[[features/multi_buffers.ml]]}


%-------------------------------------------------------------

<<features/multi_buffers.ml>>=
<<copyright header2>>
open Efuns

<<function Simple.buffer_list>>

<<constant Select.prev_buffers>>
<<function Select.set_previous_frame>>
<<function Select.get_previous_frame>>

(* C-M-l *)
let switch_to_other_buffer frame =
  let default = get_previous_frame () in
  set_previous_frame frame;
  Frame.change_buffer frame.frm_window default
  

<<constant Select.buf_hist>>
<<function Select.select_buffer>>


<<function Simple.next_buffer>>

<<function Simple.kill_buffer>>

<<constant Complex.up_buffer>>
<<function Complex.down_buffer>>

<<function Complex.up_buffer>>
  
<<function Complex.left_buffer>>

<<function Complex.right_buffer>>

<<function Complex.change_buffer>>

@

\subsection*{[[features/multi_frames.ml]]}


%-------------------------------------------------------------

<<features/multi_frames.ml>>=
<<copyright header2>>
open Efuns
  
<<function Multi_frames.cut_frame>>

<<function Multi_frames.remove_frame>>

<<function Multi_frames.v_cut_frame>>

<<function Multi_frames.h_cut_frame>>

<<function Multi_frames.delete_frame>>

<<function Multi_frames.one_frame>>
      
      
<<function Multi_frames.next_frame>>
@


\subsection*{[[features/compil.ml]]}

<<type Compil.error>>=
type error = {
    (* error location *)    
    err_filename : string;
    err_line : int;
    err_begin : int;
    err_end : int;
    (* error message *)
    err_msg : int;
  }
@

<<constant Compil.c_error_regexp>>=
let c_error_regexp = define_option ["compil"; "error_regexp"] "" regexp_option
  (string_to_regex "^\\([^:\n]+\\):\\([0-9]+\\):.*$")
@
%$

<<function Compil.c_find_error>>=
(* todo: vs C_mode.c_find_error? *)
let find_error_gen re text error_point =
  let groups = 
    Text.search_forward_groups text re
      error_point 2 in
  let error =
    {  
      err_msg = Text.get_position text error_point;
      err_filename = groups.(0);
      err_line = (int_of_string groups.(1)) - 1;
      err_begin = 0;
      err_end = 0;
    } in
  Text.fmove text error_point 1;
  error
@



%<<function Compil.set_compilation_buffer>>=
%(*
%let set_compilation_buffer frame comp_buf cdir =
%  (*let error_point = new_point comp_buf.buf_text in*)
%  let window =
%    match !compilation_frame with
%    | None -> 
%        Multi_frames.cut_frame frame
%    | Some (frame,point, _) ->
%        Text.remove_point frame.frm_buffer.buf_text point;  
%        if frame.frm_killed 
%        then Multi_frames.cut_frame frame 
%        else frame.frm_window
%  in
%  let error_point = Text.new_point comp_buf.buf_text in
%  let comp_frame = Frame.create window None comp_buf in
%  compilation_frame := Some (comp_frame, error_point, cdir)
%*)
%@

<<constant Compil.grep_command>>=
let grep_command = define_option ["compil"; "grep_command"] "" string_option
    "grep -n"
@

<<constant Compil.grep_hist>>=
let grep_hist = ref [""]
@



%-------------------------------------------------------------

<<features/compil.ml>>=
<<copyright header2>>
open Common
open Options
open Efuns

<<constant Compil.compilation_frame>>

<<type Compil.error>>

type find_error_fun = Text.t -> Text.point -> error

<<constant Compil.c_error_regexp>>

<<function Compil.c_find_error>>

<<constant Compil.find_error>>

let find_error_location_regexp = Local.create_abstr "find_error_loc_regexp"
let find_error_error_regexp = Local.create_abstr "find_error_err_regexp"
  
<<function Compil.next_error>>

<<constant Compil.compile_find_makefile>>
  
<<constant Compil.make_command>>

let color_buffer buf =
  Dircolors.colorize buf;

  let re =
    try Var.get_var buf find_error_location_regexp
    with Not_found | Failure _ -> snd !!c_error_regexp
  in
  Simple.color buf re false
    (Text.make_attr (Attr.get_color "green") 1 0 false);

  let re =
    try Var.get_var buf find_error_error_regexp
    with Not_found | Failure _ -> Str.regexp "Error"
  in
  Simple.color buf re false
    (Text.make_attr (Attr.get_color "red") 1 0 false);
  ()

let install buf =
  color_buffer buf

let mode = Ebuffer.new_major_mode "Compilation" [install]
  
<<constant Compil.make_hist>>
<<function Compil.compile>>

<<constant Compil.grep_command>>
  
<<constant Compil.grep_hist>>
<<function Compil.grep>>
@










\section{[[graphics/]]}

\subsection*{[[graphics/top_window.ml]]}


%<<[[Efuns.frame]] other fields>>=
%mutable frm_repeat_action : int;
%@
%% for undo?
%
%<<[[Top_window.try_map()]] set repeat action>>=
%frame.frm_repeat_action <- 
%  if (f == frame.frm_last_action) 
%  then frame.frm_repeat_action + 1
%  else 0;
%@




<<function Top_window.mini_message>>=
let mini_message frame msg =
  let top_window = Window.top frame.frm_window in
  message top_window msg
@




<<function Top_window.wrap>>=
let wrap top_window f () = 
  let loc = Globals.location() in
  Mutex.lock loc.loc_mutex;  
  clean_display ();    
  clear_message top_window;
  keypressed := XK.xk_Menu;
  let frame = top_window.top_active_frame in
  Hook.exec_hooks (try Var.get_global handle_key_start_hook with _ ->[]) frame;
  begin
    try f top_window 
    with e -> message top_window (Printf.sprintf "Uncaught exception %s" 
                                    (Utils.printexn e))
  end;
  Hook.exec_hooks (try Var.get_global handle_key_end_hook with _ -> []) ();    
  update_display ();
  Mutex.unlock loc.loc_mutex
@



<<constant Top_window.buffers_menu>>=
let buffers_menu = ref 
  (fun (top_window : top_window) (button : (*WX_button.t*) unit) ()
  -> ())
@


<<constant Top_window.menus>>=
(*
let menus = define_option ["menus"] ""
    (list_option (tuple2_option (string_option, list_option string2_option)))
  []
*)
@

<<function Top_window.wrap_item>>=
(*
let wrap_item top_window (n,f) =
  n, wrap top_window (fun top_window -> f top_window.top_active_frame)
*)
@

<<constant Top_window.check_abort>>=
(*let check_abort = ref 0*)
@

<<constant Top_window.check_abort_delay>>=
(*let check_abort_delay = ref 100*)
@

<<function Top_window.check_abort>>=
let check_abort frame =
  failwith "Top_window.check_abort: TODO"
(*
  incr check_abort; 
  if !check_abort mod !check_abort_delay = 0 then
    let top_window = Window.top frame.frm_window in
    let xterm = top_window.top_term in
    xterm#check_abort
  else false
*)
@


%-------------------------------------------------------------

<<graphics/top_window.ml>>=
<<copyright header2>>
open Common
open Options
open Efuns

  
<<function Top_window.message>>

<<function Top_window.clear_message>>

<<function Top_window.try_map>>

<<function Top_window.set_cursor_on>>

<<function Top_window.set_cursor_off>>

<<function Top_window.cursor_on>>

<<function Top_window.cursor_off>>


<<function Top_window.update_display>>
let update_display () = Common.profile_code "Top_window.update_display" 
  (fun () -> update_display () )

<<function Top_window.clean_display>>

<<function Top_window.resize_window>>

<<function Top_window.find_frame>>

<<constant Top_window.keypressed>>
<<constant Top_window.mouse_x>>
<<constant Top_window.mouse_y>>

<<function Top_window.find_selected_frame>>


<<function Top_window.mouse_set_active>>


<<function Top_window.mini_message>>

<<constant Top_window.handle_key_start_hook>>
<<constant Top_window.handle_key_end_hook>>
  
<<constant Top_window.meta>>
  
<<function Top_window.handle_key>>

  (* We can receive events from different sources. In particular, some of
  them can be received during the painting (scrollbar ...)
  *)
  
<<function Top_window.wrap>>

<<function Top_window.wrap_item>>
        
<<function Top_window.handler>>


<<constant Top_window.buffers_menu>>

<<function Top_window.scroll_to_frame>>


<<constant Top_window.menus>>
<<constant Top_window.file_menu>>
<<constant Top_window.edit_menu>>
<<constant Top_window.help_menu>>

  
  
<<function Top_window.create>>

<<function Top_window.delete_window>>

        
<<constant Top_window.check_abort>>
<<constant Top_window.check_abort_delay>>

  (* This function should be used in loops that could be interrupted by
  the user. It returns "true" if the user pressed C-g, and false
  in other cases. *)
  
<<function Top_window.check_abort>>

@


\section{[[./]]}

\subsection*{[[std_efunsrc.ml]]}



%-------------------------------------------------------------

<<std_efunsrc.ml>>=
<<copyright header2>>
open Utils
open Options

open Efuns
open Action

<<constant Std_efunsrc.grep_hist>>

<<function Std_efunsrc.save_options>>
<<function Std_efunsrc.fondamental_mode>>

<<toplevel Std_efunsrc._1>>
  

  
<<constant Std_efunsrc.global_map>>
<<constant Std_efunsrc.interactives_map>>

open Keymap (* c_xxx *)

<<toplevel Std_efunsrc._2>>
    
<<function Std_efunsrc.init_global_map>>
  
 
<<toplevel Std_efunsrc._4>>
  
<<toplevel Std_efunsrc._5>>
@

%(*open WX_filesel*)

\subsection*{[[main.ml]]}

%let dpy_oo = new WX_display.t !displayname
%let root_oo = new WX_root.t dpy_oo 0
%let display = WX_xterm.create_display root_oo
%  location.loc_colors_names location.loc_fonts_names 
%
%let top_window = Top_window.create location display
%let _ =
%  WX_xterm.setHighlight display 2;
%  Dyneval.init true;
%  Eval.load top_window "Efunsrc";
%  Efuns.init location; (* launch second hooks *)
%  let _ = Interactive.create_bindings location in
%(* open the fisrt buffers *)
%  List.iter (fun name ->
%    let _ = Frame.load_file top_window.window name in ()) 
%  !init_files;
%  List.iter 
%    (fun str -> let top_window = Top_window.create top_window.top_location
%          (Window.display top_window) in
%      let _ = Frame.load_file top_window.window str in ()) !init_frames;
%  Top_window.update_display location;
%
%  
%  if not (Sys.file_exists (Filename.concat Utils.homedir ".efunsrc")) then
%    begin
%      Printf.printf "Saving .efunsrc after install"; print_newline ();
%      Options.save ();
%    end;
%
%  if !check then exit 0;  
%  (* Main loop *)
%  let rec loop () =
%    try
%      WX_types.loop ()
%    with
%      SigInt -> loop ()
%  in
%  loop ()


%-------------------------------------------------------------

% was copyright header2, but better to use header1
<<main.ml>>=
<<copyright header>>
open Options
open Efuns

<<constant Efuns.init_files>>
<<constant Efuns.init_frames>>

<<constants Main options>>
<<constant Main.highlight_color>>

<<function Efuns.init>>

<<exception Main.SigInt>>

<<constants Main.xxx_opt>>
  
<<constant Efuns.usage_str>>
  
<<function Main.main>>

<<toplevel Main._>>

@






\section{[[major_modes/]]}

\subsection*{[[major_modes/dired.ml]]}

<<function Dired.update>>=
let update buf =
  let filename = match buf.buf_filename with
      None -> failwith "Not a directory"
    | Some filename -> filename in
  let s = Utils.load_directory filename in
  let text = buf.buf_text in
  Text.update text s;
  (* pad extension *)
  Dircolors.colorize buf;
  buf.buf_last_saved <- Text.version text
@

<<constant Dired.file_reg>>=
let file_reg = Str.regexp ".* \\([^ ]+\\)$"
@
%$

<<function Dired.get_file_line>>=
let get_file_line frame =
  frame.frm_buffer.buf_filename |> Common.do_option (fun filename ->
    (Globals.location()).loc_dirname <- Filename.dirname filename;
  );
  let buf = frame.frm_buffer in
  let text = buf.buf_text in
  let point = frame.frm_point in
  Text.with_dup_point text point (fun start_point ->
    let before = Text.point_to_bol text point in
    let after = Text.point_to_eol text point in
    Text.bmove text start_point before;
    let line = Text.sub text start_point (before + after) in
    line
  )
@

<<function Dired.select_file>>=
let select_file line =
  if line.[0] = ' ' 
  then
    if Str.string_match file_reg line 0 
    then Str.matched_group 1 line 
    else String.sub line 60 (String.length line - 60)
  else
    failwith "Dired: not a file line"
@

<<function Dired.dirname>>=
let dirname frame =
  match frame.frm_buffer.buf_filename with
    None -> "."
  | Some dirname -> dirname 
@

<<function Dired.fullname>>=
let fullname frame filename = 
  Filename.concat (dirname frame) filename
@

<<function Dired.open_file>>=
let open_file frame =
  let filename = fullname frame (select_file (get_file_line frame)) in
  let buf = Ebuffer.read filename (Keymap.create ()) in
  let frame = Frame.create  frame.frm_window None buf in
  Frame.active frame
@

<<function Dired.remove>>=
let remove frame =
  let line = get_file_line frame in   
  let filename = select_file line in
  Select.select_yes_or_no frame (Printf.sprintf "Remove %s ? (y/n)" filename)
    (fun b -> if b then
          if line.[1] = 'd' then Unix.rmdir filename else
          Unix.unlink filename;
        update frame.frm_buffer) |> ignore
@

<<constant Dired.view_list>>=
let view_list = ref []
@

<<constant Dired.old_view_list>>=
let old_view_list = ref []
@

<<constant Dired.compiled_view_list>>=
let compiled_view_list = ref []
@

<<function Dired.fast_view>>=
let fast_view frame filename =
  if not (!old_view_list == !view_list) then
    begin
      compiled_view_list := List.map 
        (fun (file_reg, appli) ->
          Str.regexp file_reg, appli) !view_list;
      old_view_list := !view_list
    end;
  try
    List.iter (fun (regexp, viewer) ->
        if Str.string_match regexp filename 0 then
          try
            Unix.chdir (dirname frame);
            viewer frame filename;
            raise Exit
          with
            _ -> raise Exit
    ) !compiled_view_list;
    let _ = 
      Select.select_yes_or_no frame (Printf.sprintf "Open %s ? (y/n)" filename)
      (fun b -> if b then
            open_file frame) in
      ()

  with
    Exit -> ()      
@

<<function Dired.open_view>>=
let open_view frame =
  let filename = select_file (get_file_line frame) in
  fast_view frame filename
@

<<function Dired.mkdir>>=
let mkdir frame =
  failwith "Dired.mkdir: TODO"
(*
  Select.select_filename frame "Make directory: "
    (fun str -> 
      let file_perm = try get_var frame.frm_buffer file_perm with _ -> 
            0x1ff land (lnot umask) in
      Unix.mkdir str file_perm;
      update frame.frm_buffer)
*)
@

<<function Dired.install>>=
let install buf = 
  match buf.buf_filename with
    None -> 
      failwith "Dired: Not a directory"
  | Some filename ->
      if not (Utils.is_directory filename) then 
        failwith (Printf.sprintf "Dired: %s not a directory" filename);
      update buf
@

<<constant Dired.mode>>=
let mode = Ebuffer.new_major_mode "Dired" [install]
@

<<constant Dired.map>>=
let map = mode.maj_map
@

<<function Dired.viewer>>=
let viewer commande frame filename =
  Sys.command (Printf.sprintf "(%s %s) &" commande filename) |> ignore
@

<<function Dired.commande>>=
let commande commande frame filename =
  Sys.command (Printf.sprintf commande filename) |> ignore;
  failwith  (Printf.sprintf commande filename)
@

<<function Dired.unzip_and_view>>=
let unzip_and_view frame filename =
  let new_filename = Printf.sprintf "/tmp/efuns-view-%s" (
      Filename.chop_extension filename) in
  let res = Sys.command (
      Printf.sprintf "gzip -cd %s > %s" filename new_filename)
  in
  if res = 0 then fast_view frame new_filename
@

<<toplevel Dired._1>>=
let _ = 
  Keymap.interactive map [NormalMap, XK.xk_Return] "dired_open_file" 
    open_file;
  Keymap.interactive map [NormalMap, Char.code 'g'] "dired_update" 
    (fun frame -> update frame.frm_buffer);  
  Keymap.interactive map [NormalMap, Char.code 'v'] "dired_view_file" 
    open_view;  
  Keymap.interactive map [NormalMap, Char.code '+'] "dired_make_directory" 
    mkdir;  
  Keymap.interactive map [NormalMap, Char.code '-'] "dired_remove_entry" 
    remove;  
  
  view_list := [
    ".*\\(\\.jpg\\|\\..gig\\|\\.xpm\\|\\.ppm\\)",viewer "xv";
    ".*\\(\\.ps\\|\\.PS\\)",viewer "gv";
    ".*\\(\\.dvi\\)",viewer "xdvi";
    ".*\\(\\.gz\\|\\.Z\\|\\.z\\)",unzip_and_view; 
    ".*\\.tgz", commande "xterm -e sh -c \"tar zvtf %s | less\"";
    ".*\\.tar", commande "xterm -e sh -c \"tar vtf %s | less\"";
    ".*\\.tar", commande "xterm -e sh -c \"tar vtf %s | less\"";
    ];
  
  Hook.add_start_hook (fun () ->
    Keymap.add_interactive ((Globals.location()).loc_map) "dired_mode" 
        (fun frame -> 
          Ebuffer.set_major_mode frame.frm_buffer mode);
    Var.set_global Ebuffer.modes_alist 
      ((".*/$",mode) :: (Var.get_global Ebuffer.modes_alist));
  )   
@
%$


%-------------------------------------------------------------

<<major_modes/dired.ml>>=
<<copyright header>>
open Efuns


<<function Dired.update>>

<<constant Dired.file_reg>>
  
<<function Dired.get_file_line>>
    
<<function Dired.select_file>>

<<function Dired.dirname>>
      
<<function Dired.fullname>>
      
<<function Dired.open_file>>
  
<<function Dired.remove>>

<<constant Dired.view_list>>
<<constant Dired.old_view_list>>
<<constant Dired.compiled_view_list>>
  
<<function Dired.fast_view>>
  
<<function Dired.open_view>>
  
<<function Dired.mkdir>>
          
<<function Dired.install>>
      
<<constant Dired.mode>>

<<constant Dired.map>>
  

<<function Dired.viewer>>

<<function Dired.commande>>
  
<<function Dired.unzip_and_view>>
    
<<toplevel Dired._1>>
@


\section{[[minor_modes/]]}

\subsection*{[[minor_modes/minor_mode_sample.ml]]}

%-------------------------------------------------------------

<<minor_modes/minor_mode_sample.ml>>=
<<copyright header2>>
open Efuns
          
<<constant Minor_mode_sample.minor_mode_name>>

<<function Minor_mode_sample.install>>

<<function Minor_mode_sample.minor_mode_fun>>
  
<<constant Minor_mode_sample.mode>>

<<toplevel Minor_mode_sample._1>>

<<toplevel Minor_mode_sample._2>>
    
@


\subsection*{[[minor_modes/abbrevs_mode.ml]]}

<<constant Abbrevs_mode.abbreviations>>=
let abbreviations = define_option ["abbrevs_mode"; "abbrevs"] ""
    (list_option string2_option) []
@

<<constant Abbrevs_mode.abbrevs>>=
let abbrevs = Hashtbl.create 11
@

<<toplevel Abbrevs_mode._1>>=
let _ =
  Utils.hash_add_assoc abbrevs !!abbreviations
@

<<function Abbrevs_mode.install>>=
let install buf =
  try Var.get_local buf abbrev_table |> ignore
  with _ -> Var.set_local buf abbrev_table abbrevs
@

<<constant Abbrevs_mode.mode>>=
let mode = Ebuffer.new_minor_mode "abbrevs" [install]
@

<<constant Abbrevs_mode.abbrevs_chars>>=
let abbrevs_chars = define_option ["abbrevs_mode"; "abbrevs_chars"] ""
    string_option " "
@

<<function Abbrevs_mode.find_matching>>=
let find_matching  frame = 
  self_insert_command frame; 
  Paren_mode.highlight_paren frame
@

<<function Abbrevs_mode.char_expand_abbrev>>=
let char_expand_abbrev frame =
  expand_sabbrev frame; self_insert_command frame
@

<<toplevel Abbrevs_mode._2>>=
let _ = 
  let chars = !!abbrevs_chars in
  for i = 0 to String.length chars - 1 do
    Keymap.add_binding mode.min_map [NormalMap, Char.code chars.[i]]
      char_expand_abbrev
  done
@

<<toplevel Abbrevs_mode._3>>=
let _ = 
  Action.define_action "abbrevs_mode" 
    (fun frame -> 
      let buf = frame.frm_buffer in
      if Ebuffer.modep buf mode 
      then Ebuffer.del_minor_mode buf mode
      else Ebuffer.set_minor_mode buf mode
    )
@


%-------------------------------------------------------------

<<minor_modes/abbrevs_mode.ml>>=
<<copyright header2>>
open Options
open Abbrevs
open Simple
open Efuns

<<constant Abbrevs_mode.abbreviations>>
  
<<constant Abbrevs_mode.abbrevs>>
<<toplevel Abbrevs_mode._1>>
  
<<function Abbrevs_mode.install>>

<<constant Abbrevs_mode.mode>>

<<constant Abbrevs_mode.abbrevs_chars>>
  
<<function Abbrevs_mode.find_matching>>
<<function Abbrevs_mode.char_expand_abbrev>>
  
<<toplevel Abbrevs_mode._2>>

<<toplevel Abbrevs_mode._3>>

@


\subsection*{[[minor_modes/accents_mode.ml]]}

<<function Accents_mode.accent>>=
let accent frame =
  let key = !keypressed in
  let c = previous_char frame in
  try
    let key = 
      if key = XK.xk_grave then
        match c with
        | 'e' -> XK.xk_egrave
        | 'a' -> XK.xk_agrave
        | 'i' -> XK.xk_igrave 
        | 'o' -> XK.xk_ograve 
        | 'u' -> XK.xk_ugrave
        | 'A' -> XK.xk_Agrave
        | 'E' -> XK.xk_Egrave
        | 'I' -> XK.xk_Igrave
        | 'O' -> XK.xk_Ograve
        | 'U' -> XK.xk_Ugrave 
        | _ -> raise Not_found
      else 
      if key = XK.xk_apostrophe then
        match c with
        | 'e' -> XK.xk_eacute
        | 'E' -> XK.xk_Eacute
        
        | 'a' -> XK.xk_aacute
        | 'i' -> XK.xk_iacute
        | 'o' -> XK.xk_oacute
        | 'u' -> XK.xk_uacute
        | 'A' -> XK.xk_Aacute
        | 'I' -> XK.xk_Iacute
        | 'O' -> XK.xk_Oacute
        | 'U' -> XK.xk_Uacute
        
        | _ -> raise Not_found
      else
      if key = XK.xk_semicolon then
        match c with
          'c' -> XK.xk_ccedilla
        | _ -> raise Not_found
      else
      if key = XK.xk_asciicircum then
        match c with
        | 'e' -> XK.xk_ecircumflex
        | 'a' -> XK.xk_acircumflex 
        | 'i' -> XK.xk_icircumflex
        | 'o' -> XK.xk_ocircumflex
        | 'u' -> XK.xk_ucircumflex
        | 'A' -> XK.xk_Acircumflex
        | 'E' -> XK.xk_Ecircumflex
        | 'I' -> XK.xk_Icircumflex
        | 'O' -> XK.xk_Ocircumflex
        | 'U' -> XK.xk_Ucircumflex 
        | _ -> raise Not_found
      else              
      if key = XK.xk_quotedbl then
        match c with
        | 'e' -> XK.xk_ediaeresis
        | 'a' -> XK.xk_adiaeresis 
        | 'i' -> XK.xk_idiaeresis
        | 'o' -> XK.xk_odiaeresis
        | 'u' -> XK.xk_udiaeresis
        | 'A' -> XK.xk_Adiaeresis
        | 'E' -> XK.xk_Ediaeresis
        | 'I' -> XK.xk_Idiaeresis
        | 'O' -> XK.xk_Odiaeresis
        | 'U' -> XK.xk_Udiaeresis 
        | _ -> raise Not_found
      else              
      if key = XK.xk_asciitilde then
        match c with
        | 'n' -> XK.xk_ntilde
        | 'a' -> XK.xk_atilde
        | 'o' -> XK.xk_otilde
        | 'A' -> XK.xk_Atilde
        | 'N' -> XK.xk_Ntilde
        | 'O' -> XK.xk_Otilde 
        | _ -> raise Not_found
      else              
        raise Not_found
    in
    bmove frame.frm_buffer.buf_text frame.frm_point 1;
    insert_at_place frame (Char.chr key)
  with
    Not_found ->
      try
        let c = Char.code c in
        let c = 
          if key = XK.xk_grave then
            if c = XK.xk_egrave then 'e' else
            if c = XK.xk_agrave then 'a' else
            if c = XK.xk_igrave then 'i' else 
            if c = XK.xk_ograve then 'o' else 
            if c = XK.xk_ugrave then 'u' else
            if c = XK.xk_Agrave then 'A' else
            if c = XK.xk_Egrave then 'E' else
            if c = XK.xk_Igrave then 'I' else
            if c = XK.xk_Ograve then 'O' else
            if c = XK.xk_Ugrave then 'U' else 
              raise Not_found
          else 
          if key = XK.xk_apostrophe then
            if c = XK.xk_eacute then 'e' else
            if c = XK.xk_Eacute then 'E' else
            if c = XK.xk_aacute then 'a' else
            if c = XK.xk_iacute then 'i' else
            if c = XK.xk_oacute then 'o' else
            if c = XK.xk_uacute then 'u' else
            if c = XK.xk_Aacute then 'A' else
            if c = XK.xk_Iacute then 'I' else
            if c = XK.xk_Oacute then 'O' else
            if c = XK.xk_Uacute then 'U' else
              raise Not_found
          else
          if key = XK.xk_semicolon then
            if c = XK.xk_ccedilla then 'c' else
              raise Not_found
          else
          if key = XK.xk_asciicircum then
            if c = XK.xk_ecircumflex then 'e' else
            if c = XK.xk_acircumflex then 'a' else 
            if c = XK.xk_icircumflex then 'i' else
            if c = XK.xk_ocircumflex then 'o' else
            if c = XK.xk_ucircumflex then 'u' else
            if c = XK.xk_Acircumflex then 'A' else
            if c = XK.xk_Ecircumflex then 'E' else
            if c = XK.xk_Icircumflex then 'I' else
            if c = XK.xk_Ocircumflex then 'O' else
            if c = XK.xk_Ucircumflex then 'U' else 
              raise Not_found
          else              
          if key = XK.xk_quotedbl then
            if c = XK.xk_ediaeresis then 'e' else
            if c = XK.xk_adiaeresis then 'a' else 
            if c = XK.xk_idiaeresis then 'i' else
            if c = XK.xk_odiaeresis then 'o' else
            if c = XK.xk_udiaeresis then 'u' else
            if c = XK.xk_Adiaeresis then 'A' else
            if c = XK.xk_Ediaeresis then 'E' else
            if c = XK.xk_Idiaeresis then 'I' else
            if c = XK.xk_Odiaeresis then 'O' else
            if c = XK.xk_Udiaeresis then 'U' else 
              raise Not_found
          else              
          if key = XK.xk_asciitilde then
            if c = XK.xk_ntilde then 'n' else
            if c = XK.xk_atilde then 'a' else
            if c = XK.xk_otilde then 'o' else
            if c = XK.xk_Atilde then 'A' else
            if c = XK.xk_Ntilde then 'N' else
            if c = XK.xk_Otilde then 'O' else 
              raise Not_found
          else              
            raise Not_found
        in
        bmove frame.frm_buffer.buf_text frame.frm_point 1;
        insert_at_place frame c;
        insert_char frame (Char.chr key)
      with
        Not_found ->
          insert_char frame (Char.chr key)
@

<<function Accents_mode.install>>=
let install buf =
  List.iter (fun key ->
      buf.buf_syntax_table.(key) <- true)
  [ XK.xk_egrave; XK.xk_agrave; XK.xk_igrave; XK.xk_ograve; XK.xk_ugrave;
    XK.xk_Agrave; XK.xk_Egrave; XK.xk_Igrave; XK.xk_Ograve; XK.xk_Ugrave;
    XK.xk_eacute; XK.xk_aacute; XK.xk_iacute; XK.xk_oacute; XK.xk_uacute;
    XK.xk_Aacute; XK.xk_Eacute; XK.xk_Iacute; XK.xk_Oacute; XK.xk_Uacute;
    XK.xk_ccedilla;
    XK.xk_ecircumflex; XK.xk_acircumflex; XK.xk_icircumflex;
    XK.xk_ocircumflex; XK.xk_ucircumflex; XK.xk_Acircumflex;
    XK.xk_Ecircumflex; XK.xk_Icircumflex; XK.xk_Ocircumflex;
    XK.xk_Ucircumflex;
    XK.xk_ediaeresis; XK.xk_adiaeresis; XK.xk_idiaeresis; XK.xk_odiaeresis;
    XK.xk_udiaeresis; XK.xk_Adiaeresis; XK.xk_Ediaeresis; XK.xk_Idiaeresis;
    XK.xk_Odiaeresis; XK.xk_Udiaeresis;
    XK.xk_ntilde; XK.xk_atilde; XK.xk_otilde;
    XK.xk_Atilde; XK.xk_Ntilde; XK.xk_Otilde; ]
@

<<constant Accents_mode.mode>>=
let mode = Ebuffer.new_minor_mode  "accents" [install]
@

<<toplevel Accents_mode._1>>=
let _ = 
  List.iter
    (fun key -> 
      Keymap.add_binding mode.min_map [NormalMap, key] accent
  )
  [ XK.xk_apostrophe; XK.xk_grave; XK.xk_semicolon; XK.xk_asciicircum;
    XK.xk_quotedbl; XK.xk_asciitilde]
@

<<toplevel Accents_mode._2>>=
let _ = 
  define_buffer_action "accents_mode" 
    (fun buf -> 
      if Ebuffer.modep buf mode then begin
          Ebuffer.del_minor_mode buf mode
        end else
        Ebuffer.set_minor_mode buf mode)
@


%-------------------------------------------------------------

<<minor_modes/accents_mode.ml>>=
<<copyright header2>>
open Simple
open Efuns
open Top_window
  
(* franc;ais strict *)
<<function Accents_mode.accent>>
          
          
<<function Accents_mode.install>>
  
<<constant Accents_mode.mode>>

<<toplevel Accents_mode._1>>

<<toplevel Accents_mode._2>>

@


\subsection*{[[minor_modes/fill_mode.ml]]}

<<constant Fill_mode.minor_mode_name>>=
let minor_mode_name = "fill"
@

<<function Fill_mode.install>>=
let install buf = ()
@

<<constant Fill_mode.fill_line_len>>=
let fill_line_len = define_option ["fill_line_len"] "" int_option 80
@

<<constant Fill_mode.mode>>=
let mode = Ebuffer.new_minor_mode minor_mode_name [install]
@

<<constant Fill_mode.fill_on_char>>=
let fill_on_char = define_option ["fill_on_char"] "" string_option " "
@

<<toplevel Fill_mode._1>>=
let _ =
  let fill_on_char = !!fill_on_char in
  for i = 0 to String.length fill_on_char - 1 do 
      Keymap.add_binding mode.min_map [NormalMap, Char.code fill_on_char.[i]] 
        electric_insert_space
  done
@

<<toplevel Fill_mode._2>>=
let _ = 
  Action.define_buffer_action (minor_mode_name ^ "_mode")
    (fun buf -> 
      if Ebuffer.modep buf mode 
      then Ebuffer.del_minor_mode buf mode
      else Ebuffer.set_minor_mode buf mode
     );
@


%-------------------------------------------------------------

<<minor_modes/fill_mode.ml>>=
<<copyright header2>>
open Options
open Simple
open Efuns
          
<<constant Fill_mode.minor_mode_name>>
  
<<function Fill_mode.install>>

<<constant Fill_mode.fill_line_len>>
  
<<constant Fill_mode.mode>>

<<constant Fill_mode.fill_on_char>>
  
<<toplevel Fill_mode._1>>
  
<<toplevel Fill_mode._2>>
    
@


\subsection*{[[minor_modes/paren_mode.ml]]}



%-------------------------------------------------------------

<<minor_modes/paren_mode.ml>>=
<<copyright header2>>
open Efuns
open Simple

module H = Highlight

<<constant Simple.htmlp>>
<<function Simple.is_paren_end>>
<<function Simple.is_paren_begin>>

<<function Simple.highlight_paren>>


<<constant Paren_mode.mode>>

<<function Paren_mode.find_matching>>
  
<<toplevel Paren_mode._1>>

<<toplevel Paren_mode._2>>
@


\subsection*{[[minor_modes/tab_mode.ml]]}

% what does this do??

<<constant Tab_mode.mode>>=
let mode = Ebuffer.new_minor_mode "tab" []
@

<<function Tab_mode.insert_tab>>=
let insert_tab frame = 
  insert_string frame "\t"
@

<<toplevel Tab_mode._1>>=
let _ = 
  Keymap.add_binding mode.min_map [NormalMap, XK.xk_Tab] insert_tab
@

<<toplevel Tab_mode._2>>=
let _ = 
  Action.define_buffer_action "tab_mode" 
    (fun buf -> 
      if Ebuffer.modep buf mode 
      then Ebuffer.del_minor_mode buf mode
      else Ebuffer.set_minor_mode buf mode
  );
  Action.define_action "insert_tab" insert_tab
@

%-------------------------------------------------------------

<<minor_modes/tab_mode.ml>>=
<<copyright header2>>
open Simple
open Efuns

<<constant Tab_mode.mode>>
  
<<function Tab_mode.insert_tab>>
  
<<toplevel Tab_mode._1>>

<<toplevel Tab_mode._2>>
@



\section{[[prog_modes/]]}

\subsection*{[[prog_modes/makefile_mode.ml]]}

\subsubsection{Colors}

<<constant Makefile_mode.mkfile_vars>>=
let mkfile_vars= Str.regexp "\\(\\$([a-zA-Z0-9_]*)\\)\\|\\([a-zA-Z0-9_]+=\\)"
@
%$

<<constant Makefile_mode.mkfile_target>>=
let mkfile_target= Str.regexp "^.*:"
@

<<constant Makefile_mode.mkfile_rules>>=
let mkfile_rules= Str.regexp "^\t.*$"
@
%$

<<constant Makefile_mode.target_color>>=
let target_color = define_option ["makefile_mode"; "target_color"] ""
    string_option "MediumAquamarine"
@
<<constant Makefile_mode.rules_color>>=
let rules_color = define_option ["makefile_mode";"rules_color"] "" 
  string_option "orange"
@

% font-lock-mode :)
<<function Makefile_mode.makefile_color>>=
let makefile_color buf =
  Simple.color buf mkfile_rules false
    (Text.make_attr (Attr.get_color !!rules_color) 1 0 false);
  Simple.color buf mkfile_target false 
    (Text.make_attr (Attr.get_color !!target_color) 1 0 false);
  Simple.color buf mkfile_vars false 
    (Text.make_attr (Attr.get_color !!Pl_colors.variable_name_color) 1 0 false);
  Simple.color buf mkfile_comments false 
    (Text.make_attr (Attr.get_color !!Pl_colors.comment_color) 1 0 false);
  ()
@

<<function Makefile_mode.install>>=
let install buf =
  makefile_color buf;
  Action.execute_buffer_action "tab_mode" buf
@
<<constant Makefile_mode.mode>>=
let mode = Ebuffer.new_major_mode "Makefile" [makefile_color]
@
% should be install instead no? bug?

\subsubsection{Keys and actions}

% its own configuration!
<<constant Makefile_mode.local_map>>=
let local_map = define_option ["makefile_mode"; "local_map"] ""
    (list_option Simple.binding_option) []
@
<<constant Makefile_mode.interactives_map>>=
let interactives_map = define_option ["makefile_mode"; "interactives_map"] ""
    (list_option string2_option) 
  []
@
% useful? redundant this interactives_map no?


<<toplevel Makefile_mode._2>>=
let _ = 
  Action.define_action "makefile_mode.color_buffer" 
    (fun frame -> makefile_color frame.frm_buffer);
  Action.define_action "makefile_mode" makefile_mode;
  ()
@
%(*  define_action "insert_tab" insert_tab; *)
% why not use define_buffer_action for color_buffer?

<<toplevel Makefile_mode._1>>=
open Keymap (* c_c *)
let _ =
  if !!local_map = [] then
    local_map =:= [
      [c_c; ControlMap, Char.code 'c'], "compile";    
      [ControlMap, Char.code 'l'], "makefile_mode.color_buffer";
     (*  [NormalMap, XK.xk_Tab], "insert_tab"; *)
    ];
  if !!interactives_map = [] then 
        interactives_map =:= [
          "color_buffer", "makefile_mode.color_buffer";
          (*"compile", "makefile_mode.compile";*)
      ]
@
% meh for interactives, ok shorter name, but meh
%less: forced to do C-l to recolor :(

\subsubsection{Major mode}

<<function Makefile_mode.makefile_mode>>=
let makefile_mode frame = 
  Ebuffer.set_major_mode frame.frm_buffer mode
@


<<toplevel Makefile_mode._3>>=
let setup_maps () =
  let map = mode.maj_map in
  !!local_map |> List.iter (fun (keys, action) ->
      try
        Keymap.add_binding map keys (Action.execute_action action)
      with e ->
          Log.printf "Error for action %s" action;
          Log.exn "%s\n" e;
  
  );
  !!interactives_map |> List.iter (fun (name, action) ->
      try
        Keymap.add_interactive map name (Action.execute_action action)
      with e ->
          Log.printf "Error for action %s" action;
          Log.exn "%s\n" e;
          
  );
  ()
@

<<toplevel Makefile_mode._4>>=
let _ = 
  (* Keymap.add_prefix mode.maj_map [c_c];   *)
  Hook.add_start_hook (fun () ->
    setup_maps();
    let alist = Var.get_global Ebuffer.modes_alist in
    Var.set_global Ebuffer.modes_alist ((".*/[Mm]akefile.*",mode):: alist);
    
    Parameter.add_option_parameter target_color;
    Parameter.add_option_parameter rules_color;
  )   
@


%-------------------------------------------------------------

<<prog_modes/makefile_mode.ml>>=
<<copyright header2>>
open Options
open Efuns

<<constant Makefile_mode.mkfile_vars>>
<<constant Makefile_mode.mkfile_target>>
<<constant Makefile_mode.mkfile_rules>>

let mkfile_comments= Str.regexp "^#.*$"

<<constant Makefile_mode.rules_color>>
<<constant Makefile_mode.target_color>>
<<function Makefile_mode.makefile_color>>
 
<<function Makefile_mode.install>>
  
<<constant Makefile_mode.mode>>
  

<<constant Makefile_mode.local_map>>

<<constant Makefile_mode.interactives_map>>

(* let insert_tab frame = ignore (insert_string frame "\t") *)
 
<<toplevel Makefile_mode._1>>

<<function Makefile_mode.makefile_mode>>
        
<<toplevel Makefile_mode._2>>

<<toplevel Makefile_mode._3>>

  
<<toplevel Makefile_mode._4>>
@
%$


\subsection*{[[prog_modes/ocaml_toplevel.ml]]}

<<function Ocaml_toplevel.type_buffer>>=
let type_buffer buf =
  let text = buf.buf_text in
  Text.with_new_point text (fun start_point ->
  Text.with_new_point text (fun end_point ->
    set_position text end_point (size text);
    let lexbuf = lexing text start_point end_point in
    let (str, env) = Type.type_buffer buf.buf_name lexbuf !!ocaml_path in
    (str,env)
  ))
@

<<constant Ocaml_toplevel.compiled_idents>>=
let compiled_idents = Local.create_abstr "compiled_idents"
@

<<function Ocaml_toplevel.all_idents>>=
let all_idents buf =
  try
    let (ids, version) = Local.get buf.buf_vars compiled_idents in
    if Text.version buf.buf_text = version then ids else raise Not_found
  with
    _ -> 
      let _, (str,env) = Utils.do_and_format type_buffer buf in
      let ids = Type.iter_structure str [] GlobalDefined in
      set_local buf compiled_idents (ids, Text.version buf.buf_text);
      ids      
@

<<function Ocaml_toplevel.find_value_type>>=
let find_value_type sign names =
  let rec solv sign names =
    match names with
      [] -> raise Not_found
    | name :: names ->
        let rec find sign =
          match sign with
            [] -> raise Not_found
          | sg :: sign ->
              match sg with
                Tsig_value (ident,vd) 
                when Ident.name ident = name ->
                  vd.val_type
              | Tsig_module (ident,Tmty_signature sign ) 
                when Ident.name ident = name ->
                  solv sign names
              | _ -> find sign
        in
        find sign
  in
  solv sign names
@

<<function Ocaml_toplevel.print_type>>=
let print_type frame = 
  let buf = frame.frm_buffer in
  let point = frame.frm_point in
  let top_window = Window.top frame.frm_window in
  try
    let ids = all_idents buf in
    let text = buf.buf_text in
    let pos = get_position text point in
    List.iter (fun (p,l,t,w) ->
        if l.loc_start-1 <= pos && l.loc_end+1 >= pos then
          Top_window.message top_window 
            (Utils.format_to_string 
              (fun () -> 
                printtyp_path p;
                Format.print_string " : ";
                printtyp_type_expr t
            ) ())
    ) ids
  with
    _ ->
  let name = find_long_word buf point in
  let names = parse_name name in
  let test_name modname names =
    try    
      let ps = Ocaml_env.find_pers_struct !!ocaml_path modname in
      let typ = find_value_type ps.ps_sig names in
      let styp = format_to_string () in
      Format.print_string modname;
      let rec iter list =
        match list with
          [] -> ()
        | name :: tail -> 
            Format.print_string ".";
            Format.print_string name;
            iter tail
      in
      iter names;
      Format.print_string ": ";
      printtyp_type_expr typ;
      Format.print_flush ();
      Top_window.message top_window !styp    
    with
      Env.Error e ->
        let m,s1,s2,s3 =
          match e with    
            Not_an_interface s -> "Not_an_interface",s,"",""
          | Corrupted_interface s -> "Corrupted_interface",s,"",""
          | Illegal_renaming (s1 , s2) ->
              "Illegal_renaming",s1,s2,"" 
          | Inconsistent_import (s1,s2,s3) ->
              "Inconsistent_import",s1,s2,s3
        in
        Top_window.message top_window 
          (Printf.sprintf "Env error: %s %s %s %s" m s1 s2 s3)
  in
  try
    match names with
      modname :: names when modname = String.capitalize modname -> 
        test_name modname names
    | _ -> raise Not_found
  with
    Not_found ->
      let rec iter env =
        match env with
          [] -> failwith "Can not find type"
        | modname :: env ->
            try
              test_name modname names
            with
              Not_found -> iter env
      in
      iter (find_env buf point)
@

<<constant Ocaml_toplevel.back_list>>=
let back_list = ref []
@

<<function Ocaml_toplevel.find_implementation>>=
let find_implementation frame =
  let buf = frame.frm_buffer in
  let text = buf.buf_text in
  let point = frame.frm_point in
  let word = find_long_word buf point in
  let ids = all_idents buf in
  let pos = get_position text point in
  try
    List.iter (fun (pp,l,t,w) ->
        if l.loc_start-1 <= pos && l.loc_end+1 >= pos then
          begin
            List.iter (fun (p,l,t,w) ->
                if p = pp && (w <> Type.Used)then
                  (Text.set_position text frame.frm_point l.loc_start;
                    raise Exit)
            ) ids;  
            match pp with
              Path.Pdot (Path.Pident id,name,pos) when Ident.persistent id ->
              (* Look in another file ... *)
                let ident = Ident.name id in
                let file = ident ^ ".ml" in
                file.[0] <- Char.lowercase file.[0];
                let filename = 
                  try
                    Utils.find_in_path !!ocaml_path file
                  with _ -> failwith (Printf.sprintf "No %s in path" file)
                in 
                let buf = Ebuffer.read filename (Keymap.create ()) in
                let text = buf.buf_text in
                let frame = try
                    Frame.find_buffer_frame buf
                  with Not_found ->
                      Frame.create frame.frm_window None buf
                in
                Frame.active frame;
                let ids = all_idents buf in
                List.iter (fun (p,l,t,w) ->
                    match p with
                      Path.Pident id ->
                        if Ident.name id = name && w = Type.GlobalDefined then
                          (Text.set_position text frame.frm_point l.loc_start;
                            raise Exit)
                    | _ -> ()
                ) ids;
            | _  -> ()
          end
    
    ) ids;
  with
    Exit -> 
      let filename = 
        match buf.buf_filename with
          None -> buf.buf_name
        | Some filename -> filename
      in
      back_list := (filename,Text.get_position text point) :: !back_list
@

<<function Ocaml_toplevel.backward_implementation>>=
let rec backward_implementation frame =
  match !back_list with
    [] -> failwith "No more buffers in history"
  | (filename, pos) :: tail ->
      back_list := tail;
      let buf = Ebuffer.read filename (Keymap.create ()) in
      let frame = Frame.create frame.frm_window None buf in
      Frame.active frame
@

<<function Ocaml_toplevel.mouse_find_implementation>>=
let mouse_find_implementation frame =
  let frame = Top_window.mouse_set_active (Window.top frame.frm_window) in
  find_implementation frame
@

<<constant Ocaml_toplevel.mode>>=
let mode = Ebuffer.new_minor_mode "compiler" []
@

<<constant Ocaml_toplevel.local_map>>=
let local_map = define_option ["ocaml_compiler_mode"; "local_map"] ""
    (list_option binding_option) []
@

<<toplevel Ocaml_toplevel._1>>=
let _ = 
  if !!local_map = [] then 
    local_map =:= [
      [c_c; ControlMap, Char.code 'i'] , "ocaml_mode.find_implementation";
      [c_c; ControlMap, XK.xk_BackSpace], "ocaml_mode.backward_implementation";
      [c_c; ControlMap, Char.code 't'], "ocaml_mode.print_type";
    ];
  Keymap.add_binding mode.min_map [ControlMap, XK.xk_Pointer_Button1]
    mouse_find_implementation
@

<<toplevel Ocaml_toplevel._2>>=
let _ = 
  define_buffer_action "ocaml_compiler_mode" 
    (fun buf -> 
      if Ebuffer.modep buf mode then begin
          Ebuffer.del_minor_mode buf mode
        end else
        Ebuffer.set_minor_mode buf mode);
  define_action "ocaml_compiler_mode.find_implementation" find_implementation;
  define_action "ocaml_compiler_mode.backward_implementation" backward_implementation;
  define_action "ocaml_compiler_mode.print_type" print_type;
@


%-------------------------------------------------------------

<<prog_modes/ocaml_toplevel.ml>>=
<<copyright header efuns>>
open Ocaml_mode
open Options
open Text
open Efuns
open Interactive
open Simple
open Select
open Compil
open Eval
open Complex
open Abbrevs  
open Env
open Types
open Keymap
open Window
open Location
open Compat_comp
open Type
open Ocaml_env
(* pad: that's a lots of open ... *)
  
<<function Ocaml_toplevel.type_buffer>>

<<constant Ocaml_toplevel.compiled_idents>>

<<function Ocaml_toplevel.all_idents>>

<<function Ocaml_toplevel.find_value_type>>
    
<<function Ocaml_toplevel.print_type>>

<<constant Ocaml_toplevel.back_list>>
          
<<function Ocaml_toplevel.find_implementation>>

<<function Ocaml_toplevel.backward_implementation>>
      
<<function Ocaml_toplevel.mouse_find_implementation>>
  
  

<<constant Ocaml_toplevel.mode>>

<<constant Ocaml_toplevel.local_map>>
<<toplevel Ocaml_toplevel._1>>

<<toplevel Ocaml_toplevel._2>>

@

\section{[[ipc/]]}

\subsection*{[[ipc/server.ml]]}

<<constant Server.efuns_property>>=
(*let efuns_property = "_EFUNS_SERVER"  *)
@

%-------------------------------------------------------------

<<ipc/server.ml>>=
<<copyright header>>
open Efuns
open Unix  
  
<<constant Server.efuns_property>>
<<constant Server.user>>
<<constant Server.socket_name>>

<<constant Server.started>>
  
<<type Server.proto>>

 
<<function Server.read_command>>
  
<<function Server.module_accept>>
  
<<function Server.start>>
  
@


\subsection*{[[ipc/efuns_client.ml]]}

<<constant Efuns_client.efuns_property>>=
let efuns_property = "_EFUNS_SERVER"  
@

<<constant Efuns_client.root>>=
(*let root = display.dpy_roots.(0).scr_root*)
@

<<constant Efuns_client.atom>>=
(*let atom = X.internAtom display efuns_property false*)
@


%-------------------------------------------------------------

<<ipc/efuns_client.ml>>=
  
<<constant Efuns_client.pos>>
<<constant Efuns_client.string>>
<<constant Efuns_client.filename>>
  
<<toplevel Efuns_client._1>>
  
<<constant Efuns_client.pos (client/efuns_client.ml)>>
<<constant Efuns_client.filename (client/efuns_client.ml)>>
<<constant Efuns_client.string (client/efuns_client.ml)>>
    
<<constant Efuns_client.filename (client/efuns_client.ml)2>>
    
<<constant Efuns_client.efuns_property>>

<<constant Efuns_client.display>>
<<constant Efuns_client.root>>
<<constant Efuns_client.atom>>
<<constant Efuns_client.socket_name>>
<<toplevel Efuns_client._2>>
<<toplevel Efuns_client._3>>
  
@


\subsection*{[[misc/efuns_filebrowser.ml]]}
% in some sense codemap is a more fancy variant of this efuns_filebrowser,
% a special "speedbar"

<<constant Efuns_filebrowser.argv>>=
let argv = Array.to_list Sys.argv
@

<<constant Efuns_filebrowser.regexps>>=
let regexps = List.map (fun str -> str, 
      Str.regexp (Utils.glob_to_regexp str)) (
    match argv with
      program :: dirname :: strs -> strs
    | _ -> failwith "Usage: efuns_filebrowser dirname [regexps]")
@

<<constant Efuns_filebrowser.dirname>>=
let dirname = ref (if Filename.is_relative Sys.argv.(1) then
      Filename.concat (Sys.getcwd ()) Sys.argv.(1) else Sys.argv.(1))
@

<<constant Efuns_filebrowser.display>>=
let display = new WX_display.t ""
@

<<constant Efuns_filebrowser.root>>=
let root = new WX_root.t display 0
@

<<constant Efuns_filebrowser.top>>=
let top = new WX_appli.t root [MinWidth 10; MinHeight 10; MaxHeight (root#height - 200)]
@

<<constant Efuns_filebrowser.adx>>=
let adx = new WX_adjust.t ()
@

<<constant Efuns_filebrowser.ady>>=
let ady = new WX_adjust.t ()
@

<<constant Efuns_filebrowser.hbar>>=
let hbar = new WX_bar.h top#container []
@

<<constant Efuns_filebrowser.viewport>>=
let viewport = new WX_viewport.t hbar#container adx ady []
@

<<constant Efuns_filebrowser.scrollbar>>=
let scrollbar = new WX_scrollbar.v hbar#container ady []
@

<<constant Efuns_filebrowser.tree>>=
let tree = new WX_tree.t viewport#container []
@

<<function Efuns_filebrowser.load>>=
let load filename =
  Sys.command(Printf.sprintf "efuns_server %s &" filename) |> ignore
@

<<function Efuns_filebrowser.iter_load>>=
let rec iter_load closed dirname basename container =
  try
    let dirname = Filename.concat dirname basename in
    let filenames = Sort.list (<=) (Utils.list_dir dirname) in
    let subdirs = List.fold_left (fun files filename ->
          if filename <> "." && filename <> ".." then
            let fullname = Filename.concat dirname filename in
            let stats = lstat fullname in
            if stats.st_kind = S_DIR then filename::files else
              files
          else files
      ) [] filenames in
    let file_lists = List.fold_left (fun lists (name,regexp) ->
          let newlist = List.rev (List.fold_left (fun files filename ->
                if Str.string_match regexp filename 0 then filename :: files
                else files
              ) [] filenames) in
          let rec iter pos newlist addlist lists =
            match newlist with
            | ele :: tail -> 
                if pos mod 15 = 0 then
                  iter 1 tail [] (((
                        Printf.sprintf "%s[to %s]" name ele), (ele::addlist)) :: lists)
                else
                  iter (pos+1) tail (ele::addlist) lists
            |   [] -> match addlist with [] -> lists | _ -> 
                    (name,addlist) :: lists
          in
          let newlists = iter 1 newlist [] [] in
          match newlists with
            [] -> lists
          | _ -> (List.rev newlists) @ lists
      ) [] regexps in
    (List.map (fun subdir ->
          let label = new WX_label.t container subdir [] in
          let tree  = new WX_tree.t container [] in
          tree#set_desc (iter_load true dirname subdir tree#container);
          branch true label#contained tree#contained
      ) subdirs) @ (
      List.map (fun (name,files) -> 
          let label = new WX_label.t container name [] in
          let tree  = new WX_tree.t container [] in
          tree#set_desc (List.map (fun filename ->
                let label = new WX_button.with_label tree#container filename 
                  [IpadX 0; IpadY 0] 
                  in
                label#set_action (fun () -> 
                    load (Filename.concat dirname filename));                
                leaf 0 label#contained
            ) (List.rev files));
            branch true label#contained tree#contained         
      ) file_lists
    )
  with
    _ -> []
@

<<constant Efuns_filebrowser.file_menu>>=
let file_menu = [|
    "Open", (fun _ -> 
        let info = {
            filter = Filename.concat !dirname  "*";
            current_selection= !dirname;
            predicat = (fun _ -> true);
            action = (fun s -> 
                tree#destroy_desc;
                dirname := s;
                tree#set_desc (
                  iter_load false (Filename.dirname s) (Filename.basename s)
                  tree#container));
            cancel = (fun _ -> ());
          }    in
        let filesel = new WX_filesel.t root info [] in
        filesel#show
        );
    "Quit", (fun _ -> exit 0);
  |]
@

<<toplevel Efuns_filebrowser._1>>=
let _ =
  tree#set_desc (iter_load false (Filename.dirname Sys.argv.(1))
    (Filename.basename Sys.argv.(1))
    tree#container);
  top#container_add hbar#contained;
  hbar#container_add_s [viewport#contained; scrollbar#contained];
  viewport#container_add tree#contained;
  top#setWM_NAME (Printf.sprintf "File Browser: %s" Sys.argv.(1));
  top#add_menu "File" file_menu;
  top#show;
  loop ()
@


%-------------------------------------------------------------

<<misc/efuns_filebrowser.ml>>=
<<copyright header>>
open Xtypes
open WX_types
open WX_tree
open Unix

<<constant Efuns_filebrowser.argv>>
<<constant Efuns_filebrowser.regexps>>

<<constant Efuns_filebrowser.dirname>>
  
<<constant Efuns_filebrowser.display>>
<<constant Efuns_filebrowser.root>>
<<constant Efuns_filebrowser.top>>
<<constant Efuns_filebrowser.adx>>
<<constant Efuns_filebrowser.ady>>
<<constant Efuns_filebrowser.hbar>>
<<constant Efuns_filebrowser.viewport>>
<<constant Efuns_filebrowser.scrollbar>>
<<constant Efuns_filebrowser.tree>>

<<function Efuns_filebrowser.load>>

<<function Efuns_filebrowser.iter_load>>

open WX_filesel
  
<<constant Efuns_filebrowser.file_menu>>
  
<<toplevel Efuns_filebrowser._1>>
@


\subsection*{[[misc/efuns_texbrowser.ml]]}

% outline better?

<<constant Efuns_texbrowser.display>>=
let display = new WX_display.t ""
@

<<constant Efuns_texbrowser.root>>=
let root = new WX_root.t display 0
@

<<constant Efuns_texbrowser.top>>=
let top = new WX_appli.t root [MinWidth 10; MinHeight 10]
@

<<constant Efuns_texbrowser.tree>>=
let tree = new WX_tree.t top#container []
@

<<constant Efuns_texbrowser.regexp>>=
let regexp = Str.regexp "\\(\\input\\|\\section\\|\\subsection\\|\\subsubsection\\|\\chapter\\)[*]?{\\([^}]+\\)}"
@

<<function Efuns_texbrowser.load>>=
let load filename pos all =
  Sys.command (spf "efuns_server %s -pos %d -str \"%s\" &" filename pos all)
   |> ignore
@

<<constant Efuns_texbrowser.filename>>=
let filename = ref 
  (if Array.length Sys.argv = 2 
   then Sys.argv.(1) 
   else failwith "Usage: efuns_texbrowser filename"
  )
@

<<constant Efuns_texbrowser.dirname>>=
let dirname = ref (Filename.dirname !filename)
@

<<constant Efuns_texbrowser.path>>=
let path = ref [ !dirname ]
@

<<function Efuns_texbrowser.iter_load>>=
let rec iter_load closed filename container =
  let label = new WX_button.with_label container filename [] in
  try
    let filename = try
        Utils.find_in_path !path filename
      with Not_found -> 
          Utils.find_in_path !path (filename^".tex")
    in
    label#set_action (fun () -> load filename 0 "");
    let inc = open_in filename in
    let s = Utils.read_string inc in
    close_in inc;
    let rec iter_search pos list = 
      try
        let newpos = Str.search_forward regexp s pos in
        let keyword = Str.matched_group 1 s in
        let all = Str.matched_group 0 s in
        iter_search (newpos+String.length keyword) (
          (all, keyword,Str.matched_group 2 s,newpos)::list)
      with
        _ -> List.rev list
    in
    let list =  iter_search 0 [] in
    if list = [] then leaf 0 label#contained else
    let tree2 = new WX_tree.t container [] in
    tree2#set_desc (List.map (
        fun (all,keyword,name,pos) -> 
          match keyword with
            "input" -> iter_load true name tree2#container
          | _ ->
              let (offset,prefix) =
                match keyword with
                  "section" -> 0, "s:"
                | "subsection" -> 10, "ss:"
                | "subsubsection" -> 20, "sss:"
                | _ -> 30,""
              in
              leaf offset (
                  let button = new WX_button.with_label tree2#container (
                      prefix^name) [] 
                  in
                  button#set_action (fun () -> load filename pos all);
                  button#contained
                  )
      ) list);
    branch closed label#contained tree2#contained
  with
    _ -> 
      leaf 0 label#contained
@

<<constant Efuns_texbrowser.file_menu>>=
let file_menu = [|
    "Open", (fun _ -> 
        let info = {
            filter = Filename.concat !dirname  "*.tex";
            current_selection= !dirname;
            predicat = (fun _ -> true);
            action = (fun s -> 
                tree#destroy_desc;
                filename := s;
                dirname := Filename.dirname s;
                top#setWM_NAME (Printf.sprintf "LaTeX Browser: %s" !filename);
                tree#set_desc [iter_load false s tree#container]);
            cancel = (fun _ -> ());
          }    in
        let filesel = new WX_filesel.t root info [] in
        filesel#show              
        );
    "Quit", (fun _ -> exit 0);
  |]
@

<<toplevel Efuns_texbrowser._1>>=
let _ =
  tree#set_desc [iter_load false Sys.argv.(1) tree#container];
  top#setWM_NAME (Printf.sprintf "LaTeX Browser: %s" !filename);
  top#container_add tree#contained;
  top#add_menu "File" file_menu;
  top#add_button "Reload" (fun _ () ->
      tree#destroy_desc;
      tree#set_desc [iter_load false !filename tree#container];      
  );
  top#add_separator;
  top#show;
  loop ()
@


%-------------------------------------------------------------

<<misc/efuns_texbrowser.ml>>=
<<copyright header>>
open Xtypes
open WX_types
open WX_tree


<<constant Efuns_texbrowser.display>>
<<constant Efuns_texbrowser.root>>
<<constant Efuns_texbrowser.top>>
<<constant Efuns_texbrowser.tree>>

<<constant Efuns_texbrowser.regexp>>

<<function Efuns_texbrowser.load>>

<<constant Efuns_texbrowser.filename>>
  
<<constant Efuns_texbrowser.dirname>>
<<constant Efuns_texbrowser.path>>
  
<<function Efuns_texbrowser.iter_load>>

open WX_filesel
  
<<constant Efuns_texbrowser.file_menu>>

<<toplevel Efuns_texbrowser._1>>
@

\section{[[dynamic/]]}

\subsection*{[[dynamic/eval.ml]]}

<<function Eval.try_load>>=
let try_load top_window f =
  try
    f (); 
    Efuns.init top_window.top_location
  with
  | Dynlink.Error error ->
      Top_window.message top_window (Dynlink.error_message error)
  | e -> 
      Top_window.message top_window (spf "Exception %s" (Printexc.to_string e))
@

<<function Eval.load>>=
let load top_window mod_name =
  try_load top_window (fun () -> load_module mod_name)
@

<<function Eval.load_library>>=
let load_library frame =
  select_lib_filename frame "Load library: " 
    (fun str ->
      let top_window = Window.top frame.frm_window in
      try_load top_window (fun () -> load_file str))
@

<<function Eval.eval_buffer>>=
let eval_buffer frame =
  let top_window = Window.top frame.frm_window in
  let location = top_window.top_location in
  let buf = frame.frm_buffer in
  let text = buf.buf_text in
  let filename = Filename.temp_file "buffer" ".ml" in
  let outc = open_out filename in
  Text.save buf.buf_text outc;
  close_out outc;
  let cmd = "ocamlc -c -I " ^ Version.efuns_lib ^ " " ^ filename in 
  let end_action buf status =
    match status with
      0 -> try_load top_window 
          (fun _ -> 
            let fl =  ((Filename.chop_suffix filename ".ml") ^ ".cmo") 
            in 
            load_file fl;
            Efuns.init top_window.top_location)
    | _ -> 
        set_compilation_buffer frame buf (Filename.dirname filename);
        Top_window.message top_window "Error while compiling buffer"
  in
  System.system "*Eval*" location cmd end_action |> ignore
@


%-------------------------------------------------------------

<<dynamic/eval.ml>>=
<<copyright header2>>
open Efuns
open Text
open Frame
open Simple
open Select
open Search
open Compil

(*
let rec load_module mod_name =
  let filename = (String.uncapitalize mod_name) ^ ".cmo" in
  try
    let filename = Utils.find_in_path !Efuns.load_path filename in
    load_file filename
  with
    Not_found -> failwith ("Can't find file "^filename)

and load_file filename =
  try
    Dynlink.loadfile filename
  with
    Dynlink.Error (Dynlink.Unavailable_unit mod_name) -> 
      load_interface mod_name;
      load_file filename
  | Dynlink.Error (
    Dynlink.Linking_error (_, Dynlink.Undefined_global mod_name)) ->
      load_module mod_name;
      load_file filename

and load_interface mod_name =
  try
    Dynlink.add_interfaces [mod_name] !Efuns.load_path; ()
  with
    Not_found ->
      failwith (Printf.sprintf "No interface for %s" mod_name)
      *)

open Dyneval

<<function Eval.try_load>>

<<function Eval.load>>

<<function Eval.load_library>>

  
<<function Eval.eval_buffer>>
@
