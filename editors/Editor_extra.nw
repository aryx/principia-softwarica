\section{TODO}

%TODO: to lpize 
% (make pdf complains about those files if they are not listed here)
<<graphics/xtypes.ml>>=
@
<<graphics/xdraw.ml>>=
@
<<graphics/xK.ml>>=
@


<<graphics/gtk_cairo2/graphics_efuns.ml>>=
@
<<graphics/gtk_cairo2/cairo_helpers.ml>>=
@
<<graphics/gtk_cairo2/world.ml>>=
@
<<graphics/gtk_cairo2/test_libs.ml>>=
@
<<graphics/gtk_cairo2/minimap.ml>>=
@

<<ppx/ppx_interactive.ml>>=
@

<<commons/str2.ml>>=
@
<<commons/utils.ml>>=
@
<<commons/options.ml>>=
@
<<commons/log.ml>>=
@
<<commons/concur.ml>>=
@

<<features/macros.ml>>=
@
<<features/dircolors.ml>>=
@
<<features/rectangle.ml>>=
@
<<features/message.ml>>=
@
<<minor_modes/minor_modes.ml>>=
@
<<major_modes/major_modes.ml>>=
@

<<text_modes/tex_mode.ml>>=
@
<<text_modes/tex_mode.mll>>=
@
<<text_modes/org_mode.ml>>=
@
<<text_modes/html_mode.ml>>=
@
<<text_modes/html_mode.mll>>=
@

<<prog_modes/pl_colors.ml>>=
@
<<prog_modes/common_lexer.ml>>=
@
<<prog_modes/common_indenter.ml>>=
@
<<prog_modes/bento.ml>>=
@
<<prog_modes/ocaml_mode.ml>>=
@
<<prog_modes/ocaml_lexer.ml>>=
@
<<prog_modes/ocaml_lexer.mll>>=
@
<<prog_modes/lisp_mode.ml>>=
@
<<prog_modes/lisp_lexer.ml>>=
@
<<prog_modes/lisp_lexer.mll>>=
@
<<prog_modes/c_mode.ml>>=
@
<<prog_modes/c_lexer.ml>>=
@
<<prog_modes/c_lexer.mll>>=
@
<<prog_modes/ocaml_merlin.ml>>=
@
<<prog_modes/ocaml_ocp_indent.ml>>=
@

<<major_modes/shell.ml>>=
@
<<major_modes/outline_mode.ml>>=
@
<<major_modes/buffer_menu.ml>>=
@

<<pfff_modes/pfff_modes.ml>>=
@
<<pfff_modes/noweb_mode.ml>>=
@
<<pfff_modes/cpp_mode.ml>>=
@
<<pfff_modes/caml_mode.ml>>=
@
<<pfff_modes/python_mode.ml>>=
@
<<pfff_modes/javascript_mode.ml>>=
@

\section{[[commons/]]}

\subsection{[[commons/store.mli]]}

%-------------------------------------------------------------

<<commons/store.mli>>=

<<signature type [[Store.t]]>>
<<signature function [[Store.new_store]]>>

<<signature type [[Store.var]]>>
<<signature functions [[Store.create_xxx]]>>
(* internal *)
<<signature function [[Store.create]]>>

<<signature function [[Store.get]]>>
<<signature function [[Store.set]]>>

<<signature functions [[Store]]>>
@

\subsection{[[commons/store.ml]]}
%pad: was called local.ml before


%-------------------------------------------------------------

<<commons/store.ml>>=
<<copyright header>>

(* We use strings instead of ints to enable migration of datas between
editors (data must be symbolic) *)
  
<<type [[Store.var]]>>

<<module Store.Vars>>

<<type [[Store.t]]>>
<<function [[Store.new_store]]>>

<<global [[Store.vars_table]]>>

<<function [[Store.create]]>>

<<function [[Store.no_print]]>>
<<function [[Store.no_input]]>>
<<function [[Store.create_abstr]]>>
  
external id : 'a -> 'a = "%identity"

<<function [[Store.create_string]]>>
<<function [[Store.create_int]]>>
<<function [[Store.create_float]]>>
  
<<function [[Store.get]]>>
<<function [[Store.set]]>>
      
<<function [[Store.get_print]]>>
  
<<function [[Store.set_input]]>>
  
<<function [[Store.list]]>>
  
<<constant [[Store.print]]>>
<<constant [[Store.input]]>>
@


\section{[[core/]]}

\subsection{[[core/var.ml]]}

<<core/var.ml>>=
<<copyright header efuns>>
open Efuns
open Globals

<<type [[Var.t]]>>

<<function [[Var.set_global]]>>
<<function [[Var.set_local]]>>
<<function [[Var.get_var]]>>
          
<<function [[Var.get_global]]>>
<<function [[Var.get_local]]>>
  
<<function [[Var.set_minor_var]]>>
<<function [[Var.set_major_var]]>>

let add_global var xs =
  let ys = get_global var in
  set_global var (xs @ ys)

@

\subsection{[[core/parameter_option.ml]]}
%pad: I created this file; The content was in simple.ml before

%-------------------------------------------------------------

<<core/parameter_option.ml>>=
<<copyright header efuns>>
open Options

(* A parameter is an option that can be interactively get or set.
 * See Interactive.get_parameter and set_parameter.
 *
 * alt: use the Options.options global and make all options parameters?
 * no need then for parameters_var below and the redundant Parameter.t
 *)

<<type [[Simple.parameter]]>>
  
<<constant [[Simple.parameters_var]]>>
  
<<function [[Simple.add_parameter]]>>

<<function [[Simple.add_option_parameter]]>>

(* todo: remove useless cache? *)  
<<constant [[Simple.all_params]]>>
<<function [[Simple.all_parameters]]>>

@

\subsection{[[core/attr.ml]]}

<<core/attr.ml>>=
<<copyright header efuns>>
open Efuns

(* see also Text.make_attr *)

<<function [[Window.get_font]]>>
        
<<function [[Window.get_color]]>>

@

\subsection{[[core/hook.ml]]}

<<core/hook.ml>>=
<<copyright header efuns>>

<<constant [[Efuns.start_hooks]]>>
<<function [[Efuns.add_start_hook]]>>

<<function [[Efuns.exec_hooks]]>>

<<function [[Efuns.add_hook]]>>

<<function [[Frame.exec_named_hooks]]>>

<<function [[Ebuffer.exec_named_buf_hooks]]>>

<<function [[Ebuffer.exec_named_buf_hooks_with_abort]]>>

@

\subsection{[[core/action.ml]]}

<<core/action.ml>>=
<<copyright header efuns>>
open Common
open Efuns

<<type [[Action.t]]>>

type name = Efuns.action_name

<<global [[Efuns.actions]]>>

<<function [[Efuns.define_action]]>>

<<function [[Efuns.define_buffer_action]]>>

<<function [[Efuns.get_action]]>>

<<function [[Efuns.execute_action]]>>

<<function [[Efuns.execute_buffer_action]]>>

@

\subsection{[[core/error.ml]]}

<<core/error.ml>>=
open Common

<<function [[Efuns.error]]>>

let error s =
  UCommon.pr2 (spf "error: %s" s);
  flush stderr
@


\subsection{[[core/globals.ml]]}

% (*--------------------    Ressources *)
% <<constant [[Efuns.xdefaults]]>>
% 
% <<constant [[Efuns.x_res]]>>
% <<toplevel [[Efuns._2]]>>
%   
% <<constant [[Efuns.t]]>>


<<core/globals.ml>>=
<<copyright header efuns>>
open Efuns

(* Note that there are also globals in other modules: 
 *  - Action.actions, 
 *  - Hook.start_hooks
 *  - Top_window.in_start_macro, 
 *  - ... 
 *)

<<global [[Efuns.global_editor]]>>
<<function [[Efuns.editor]]>>

<<function [[Efuns.with_lock]]>>

(*************************************************************************)
(*      Initialization      *)
(*************************************************************************)
  
(* Les variables importantes dans le reste du programme. *)
open Options

<<constant [[Efuns.check]]>>

<<constants [[Efuns.debug_xxx]]>>

<<constant [[Efuns.load_path]]>>

<<constant [[Efuns.path]]>>
  
<<constant [[Efuns.efuns_path]]>>
  
<<toplevel [[Efuns]] load path>>

(* used in some major mode *)
<<constant [[Efuns.font]]>>
  

(* for ipc/server too *)
<<global [[Efuns.displayname]]>>

@


\subsection{[[core/efuns.ml]]}


%-------------------------------------------------------------

<<core/efuns.ml>>=
<<copyright header2>>
(* Useful types for Efuns *)

(*************************************************************************)
(* Keymaps and actions *)
(*************************************************************************)

(* actually used only by top_window.ml *)
<<exception [[Efuns.UnboundKey]]>>

<<type [[Efuns.map]]>>
<<type [[Efuns.keySym]]>>
<<type [[Efuns.key]]>>

<<type [[Efuns.action]]>>

<<type [[Efuns.action_name]]>>

<<type [[Efuns.generic_action]]>>

<<type [[Efuns.mod_ident]]>>

<<type [[Efuns.keys]]>>

<<type [[Efuns.binding]]>>

(*************************************************************************)
(* Buffers *)
(*************************************************************************)

<<type [[Efuns.buffer]]>>

<<type [[Efuns.major_mode]]>>

<<type [[Efuns.minor_mode]]>>

(*************************************************************************)
(* Frames *)
(*************************************************************************)
  
<<type [[Efuns.frame]]>>

<<type [[Efuns.status_info]]>>

<<type [[Efuns.status]]>>

<<type [[Efuns.frm_line]]>>

(*************************************************************************)
(* Windows *)
(*************************************************************************)

<<type [[Efuns.top_window]]>>

<<type [[Efuns.window]]>>

<<type [[Efuns.window_up]]>>

<<type [[Efuns.window_down]]>>

(*************************************************************************)
(* The world *)
(*************************************************************************)

<<type [[Efuns.editor]]>>

(*************************************************************************)
(* Regexps *)
(*************************************************************************)

<<type [[Efuns.sens]]>>
<<type [[Efuns.to_regexp]]>>

<<function [[Efuns.string_to_regex]]>>

open Options    
<<constant [[Efuns.regexp_option]]>>

(*************************************************************************)
(* Misc *)
(*************************************************************************)

(* used by frame, so can't be in top_window.ml *)
<<function [[Efuns.backend]]>>

@


\subsection{[[core/text.ml]]}



%(* A FAIRE:
%On doit faire converger ce text vers un text directement affichable par
%WX_text. Pour cela:
%
%Modifier WX_text pour qu'il se satisfasse de l'interface de Text.
%En particulier, il doit n'utiliser que les fonctions suivantes:
%
%Text.representation text line --> string (buffer or copy) * int (position)
%Text.items line -> item array
%  
%Il doit aussi utiliser la structure un peu particuliere de l'arbre utiliser
%ici.
%  
%*)

%-------------------------------------------------------------

<<core/text.ml>>=
<<copyright header2>>
open Options

(*****************************************************************************)
(* Types *)
(*****************************************************************************)

<<type [[Text.position]]>>

<<type [[Text.position2]]>>

<<type [[Text.point]]>>

<<type [[Text.coord]]>>

<<type [[Text.delta]]>>

<<type [[Text.attribute]]>>


<<type [[Text.version]]>>

<<type [[Text.session]]>>


<<type [[Text.line]]>>

<<type [[Text.box]]>>

<<type [[Text.t]]>>
  
<<type [[Text.action]]>>

(*****************************************************************************)
(* Global properties *)
(*****************************************************************************)
  
<<function [[Text.version]]>>
  
<<function [[Text.nbr_lines]]>>
  
<<function [[Text.size]]>>

(*****************************************************************************)
(* Line x Col *)
(*****************************************************************************)
  
<<function [[Text.point_col]]>>

<<function [[Text.find_line_of_pos]]>>

<<function [[Text.point_line]]>>

<<function [[Text.point_coord]]>>

(*****************************************************************************)
(* Helpers *)
(*****************************************************************************)

<<function [[Text.mk_line_with_pos]]>>

<<function [[Text.cancel_repr]]>>

(*****************************************************************************)
(* Attributes *)
(*****************************************************************************)

<<constant [[Text.highlight_bit]]>>

<<function [[Text.make_attr]]>>

<<constant [[Text.direct_attr]]>>
<<constant [[Text.inverse_attr]]>>

<<function [[Text.unset_attrs]]>>
<<function [[Text.set_attrs]]>>

<<function [[Text.get_attr]]>>
<<function [[Text.set_attr]]>>

(*****************************************************************************)
(* Gap *)
(*****************************************************************************)

<<function [[Text.move_gpoint_to]]>>

<<constant [[Text.add_amount]]>>
<<function [[Text.extend_gap]]>>

(*****************************************************************************)
(* Low level insert/delete *)
(*****************************************************************************)

<<function [[Text.low_insert]]>>

<<function [[Text.low_delete]]>>

(*****************************************************************************)
(* Undo *)
(*****************************************************************************)

<<function [[Text.undo]]>>

<<function [[Text.start_session]]>>
  
<<function [[Text.commit_session]]>>

<<function [[Text.with_session]]>>


(*****************************************************************************)
(* Insert/delete public API *)
(*****************************************************************************)

<<function [[Text.insert_res]]>>

<<function [[Text.insert]]>>
  
<<function [[Text.delete_res]]>>

<<function [[Text.delete]]>>

<<function [[Text.insert_at_end]]>>


(*****************************************************************************)
(* Constructor *)
(*****************************************************************************)
  
<<function [[Text.compute_newlines]]>>

<<function [[Text.create]]>>
  
(*****************************************************************************)
(* Points *)
(*****************************************************************************)

<<function [[Text.new_point]]>>

<<function [[Text.dup_point]]>>

<<function [[Text.goto_point]]>>

<<function [[Text.move_point_to]]>>

<<function [[Text.remove_point]]>>

<<function [[Text.with_dup_point]]>>

<<function [[Text.with_new_point]]>>


(*****************************************************************************)
(* IO *)
(*****************************************************************************)

<<function [[Text.read]]>>

<<function [[Text.save]]>>

(*****************************************************************************)
(* Distance, delta *)
(*****************************************************************************)

<<function [[Text.low_distance]]>>

<<function [[Text.distance]]>>

<<function [[Text.compare]]>>

(*****************************************************************************)
(* Text Getters/setters *)
(*****************************************************************************)
  
<<function [[Text.get_char]]>>

(*****************************************************************************)
(* Moving *)
(*****************************************************************************)

<<function [[Text.fmove_res]]>>

<<function [[Text.bmove_res]]>>

<<function [[Text.bmove]]>>

<<function [[Text.fmove]]>>


<<function [[Text.move_res]]>>

<<function [[Text.move]]>>

(*****************************************************************************)
(* Position *)
(*****************************************************************************)
  
<<function [[Text.get_position]]>>

<<function [[Text.set_position]]>>

<<function [[Text.goto_line]]>>

(*****************************************************************************)
(* Sub content  *)
(*****************************************************************************)

let iter text cursor delta f =
  with_dup_point text cursor (fun cursor ->
    for _i = 0 to delta - 1 do
      f cursor;
      fmove text cursor 1
    done
  )

(*
let iter buf debut fin =
  let text = buf.buf_text in
  Text.with_new_point text (fun curseur ->
  Text.with_new_point text (fun final ->
    Text.set_position text curseur debut;
    Text.set_position text final fin;
    while curseur < final do
      let attr = Text.get_attr text curseur in
      Text.set_attr text curseur (attr lor Text.highlight_bit);
      Text.fmove text curseur 1
    done;
*)


(* should be in search/replace, but it's used by blit too *)
<<function [[Text.clean_text]]>>
    

<<function [[Text.blit]]>>
    
<<function [[Text.sub]]>>

<<function [[Text.region]]>>

(*****************************************************************************)
(* Search/replace  *)
(*****************************************************************************)

<<function [[Text.search_forward]]>>

<<function [[Text.replace_matched]]>>
  
<<function [[Text.search_forward_matched]]>>

<<function [[Text.search_forward_groups]]>>

<<function [[Text.search_backward]]>>

<<function [[Text.search_backward_groups]]>>

(*****************************************************************************)
(* Representation  *)
(*****************************************************************************)

<<constant [[Text.repr_string]]>>

<<constant [[Text.repr_size]]>>

<<constant [[Text.dummy_line]]>>
  
<<constant [[Text.tabreprs]]>>

<<type [[Text.charreprs]]>>

<<function [[Text.compute_representation]]>>

(*****************************************************************************)
(* Point_to_xxx  *)
(*****************************************************************************)

<<function [[Text.point_to_eol]]>>

<<function [[Text.point_to_bol]]>>

<<function [[Text.point_to_eof]]>>

<<function [[Text.point_to_bof]]>>

<<function [[Text.point_to_lof]]>>

<<function [[Text.point_to_lol]]>>


<<function [[Text.point_to_line]]>>


(*****************************************************************************)
(* Misc  *)
(*****************************************************************************)

<<function [[Text.to_string]]>>

<<function [[Text.clear]]>>

<<function [[Text.update]]>>

<<function [[Text.lexing]]>>

    
<<function [[Text.readonly]]>>
  
<<function [[Text.toggle_readonly]]>>
  
@

%<<function Text.goto_xy>>=
%(*
%let goto_xy text point x y =
%%  let y =
%    if y < text.text_nlines then y
%    else text.text_nlines - 1
%  in
%  point.pos <- text.text_newlines.(y).position;
%  point.line <- y;
%  fmove text point x |> ignore
%*)
%@

%<<function Text.add>>=
%(*
%let add text point delta =
%  let gpos = text.gpoint.pos in
%  let gap_end = gpos + text.gsize in
%  if point <= gpos && point + delta > gpos then
%    point + delta + text.gsize
%  else
%  if point >= gap_end && point+delta < gap_end then
%    point + delta - text.gsize
%  else
%    point + delta
%*)
%@



%<<function Text.find_xy>>=
%let find_xy text point line pos =
%  let gpos = text.gpoint.pos in
%  let gline = text.gpoint.line in
%  let gap_end = gpos + text.gsize in
%
%  let y,x =
%    if pos >= gap_end then
%      (* go forward *)
%      let rec iter line =
%        if line >= text.text_nlines 
%        then text.text_nlines - 1
%        else
%          if text.text_newlines.(line).position > pos 
%          then line - 1
%          else iter (line + 1)
%      in
%      let line = 
%        if point > gap_end && pos > point 
%        then iter (line+1) 
%        else iter (gline+1) 
%      in
%      if line = gline 
%      then
%        let gchars = gpos - text.text_newlines.(gline).position in
%        line, gchars + pos - gap_end
%      else
%        line, pos - text.text_newlines.(line).position
%    else
%    (* go backward *)
%    let rec iter line =
%      if line > 0 
%      then
%        if text.text_newlines.(line).position > pos 
%        then iter (line - 1)
%        else line
%      else 0
%    in
%    let line = 
%      if point < gpos && pos <= point 
%      then iter line 
%      else iter gline in
%    line, pos - text.text_newlines.(line).position
%  in
%  x,y
%@
% was called find_xy, but confusing with xy used in efuns where
% they are more screen coordinates with ^M and 80col adjustments
% and anyway callsites can be translated to calls to the simpler
% find_line_of_pos.



%(*      
%module TextTree = WX_text.Make(Text)
%open TextTree
%*)
%  
%(* type t = tree tree_desc   *)
%
%(* external id: t -> tree tree_desc = "%identity" *)
%
%(*
%let print msg text =
%  let s = text.text_string in
%  let gpoint = text.gpoint in
%  let gsize  = text.gsize in
%  let len = text.text_size in
%  let gap_end = gpoint + gsize in
%    Printf.printf "%s: <<%s[gap:%d]%s>>" msg (String.sub s 0 gpoint) gsize 
%      (String.sub s gap_end (len - gap_end));
%    print_newline ()
% 
%let print_newlines text =
%  print_string "Newlines :";
%  for i = 0 to text.text_nlines - 1 do
%    Printf.printf " %d" text.text_newlines.(i).position;
%  done;
%  print_newline ()
%*)


%(*
%  let rec iter tree lines =
%    match tree with
%      Parts text ->
%        if lines = text.tree_nlines || lines = -1 then
%          (* Insert in the last part *)
%          iter text.tree_parts.(Array.length text.tree_parts - 1) (-1)
%        else
%        let rec iter2 lines i =
%          let tlines = match text.tree_parts.(i) with
%              Parts t -> t.tree_nlines
%            | Lines t -> t.tree_nlines 
%          in
%          if tlines > lines then
%            iter text.tree_parts.(i) lines
%          else
%            iter2 (lines - tlines) (i+1)
%        in
%        iter2 lines 0;
%        text.tree_modified <- true;
%        text.tree_nlines <- text.tree_nlines + nbr
%    | Lines text ->
%        let newtext = Array.create text.tree_nlines text.tree_parts.(0) in
%        Array.blit text.tree_parts 0 newtext 0 lines;
%        Array.blit t.text_newlines gline newtext lines nbr;
%        Array.blit text.tree_parts lines newtext (lines+nbr) (
%          text.tree_nlines - lines);
%        text.tree_modified <- true;        
%        text.tree_nlines <- text.tree_nlines + nbr
%  in
%  iter (Parts tree) gline
%*)


%type tree_desc =
%      { mutable tree_nlines: int;
%        mutable tree_width: int;
%        mutable tree_height: int;
%(*        mutable tree_parts: 'a array; *)
%(*        mutable tree_up: tree tree_desc; *)
%        mutable tree_pos: int;
%        mutable tree_modified: bool;
%        mutable line_height: int;
%        mutable line_width: int;
%
%        mutable tree_text: text 
%}
%
%let make_text text lines =
%  let nlines = Array.length lines in
%  let tree = {
%      tree_nlines = nlines;
%      tree_width = 0;
%      tree_height = 0;
%(*
%      tree_parts = [| Lines {
%          tree_nlines = nlines;
%          tree_width = 0;
%          tree_height = 0;
%          tree_parts = lines;
%          tree_up = tree;
%          tree_pos = 0;
%          tree_modified = true;
%          line_height = 0;
%          line_width = 0;
%          tree_text = text;      
%        }|];
%      tree_up = tree;
%*)
%      tree_pos = 0;
%      tree_modified = true;
%      line_height = 0;
%      line_width = 0;
%      tree_text = text;
%    }
%  in tree
%
%type t = tree_desc


\subsection{[[core/ebuffer.ml]]}
%pad: I renamed buffer.ml to ebuffer.ml; less conflict with Buffer from stdlib


%<<function Ebuffer.catch>>=
%(*
%let catch format buf f =
%  try
%    f ()
%  with e ->
%    let loc = Globals.location() in
%    let name = "*Messages*" in
%    let m = Printf.sprintf format (Utils.printexn e) in
%    try
%      let buf = Hashtbl.find loc.loc_buffers name in
%      Text.insert_at_end buf.buf_text (m ^ "\n");
%    with Not_found ->
%      create name None (Text.create (m^"\n")) (Keymap.create ())  |>ignore
%*)
%@



%-------------------------------------------------------------

<<core/ebuffer.ml>>=
<<copyright header2>>
open Common
open Efuns

<<type [[Ebuffer.t]]>>

(* this file is called ebuffer.ml because buffer.ml already exists in stdlib *)

<<constant [[Ebuffer.create_buf_hook]]>>
<<constant [[Ebuffer.modes_alist]]>>

<<function [[Ebuffer.create_syntax_table]]>>

<<constant [[Ebuffer.default_syntax_table]]>>

<<function [[Ebuffer.get_name]]>>

<<function [[Ebuffer.new_minor_mode]]>>

<<function [[Ebuffer.new_major_mode]]>>

<<constant [[Ebuffer.fondamental_mode]]>>


  
<<constant [[Ebuffer.tab_size]]>>

<<function [[Ebuffer.create]]>>

<<function [[Ebuffer.kill]]>>

open Options
  
<<constant [[Ebuffer.save_buffer_hooks]]>>
  
<<constant [[Ebuffer.saved_buffer_hooks]]>>

<<function [[Ebuffer.save]]>>
 
<<function [[Ebuffer.read]]>>

<<function [[Ebuffer.find_buffer_opt]]>>

<<constant [[Ebuffer.help_buffer_content]]>>

<<function [[Ebuffer.default]]>>
      
<<function [[Ebuffer.compute_representation]]>>

<<exception [[Ebuffer.BufferAlreadyOpened]]>>

<<function [[Ebuffer.change_name]]>>
  
<<function [[Ebuffer.set_mark]]>>

<<function [[Ebuffer.get_mark]]>>

<<function [[Ebuffer.remove_mark]]>>

<<constant [[Ebuffer.modes_old]]>>
<<constant [[Ebuffer.regexp_alist]]>>

<<function [[Ebuffer.set_major_mode]]>>

<<function [[Ebuffer.set_minor_mode]]>>

<<function [[Ebuffer.del_minor_mode]]>>
  
<<function [[Ebuffer.has_minor_mode]]>>

<<constant [[Ebuffer.suffix_reg]]>>
  
<<function [[Ebuffer.set_buffer_mode]]>>
      
<<function [[Ebuffer.get_binding]]>>

<<function [[Ebuffer.message]]>>


<<function [[Ebuffer.fondamental_mode]]>>

      
<<toplevel [[Ebuffer]] starting hook>>
@


\subsection{[[core/keymap.ml]]}


%<<function Keymap.unbound_key>>=
%let unbound_key buffer _ = raise UnboundKey
%@
%dead?
%<<function Keymap.define_char_binding>>=
%let define_char_binding map char (f : frame -> 'a) =
%  add_binding map [NormalMap,Char.code char] f
%@
%dead?
%dead: let keysym_to_name = []
% (it's in XK now)

%(*
%La gestion des keymaps est inadapte'e a` la modification dynamique.
%En effet, on aurait envie de pouvoir modifier les bindings selon divers
%  crite`res, tels que le buffer (possible), le mode(pas possible).
%*)
% ???

%-------------------------------------------------------------

<<core/keymap.ml>>=
<<copyright header2>>
open Efuns

<<type [[Keymap.t]]>>

<<function [[Keymap.dummy_action]]>>

<<function [[Keymap.create]]>>


<<function [[Keymap.print_key]]>>
            
<<function [[Keymap.print_key_list]]>>
   

<<function [[Keymap.get_binding]]>>
          
<<function [[Keymap.set_binding]]>>

<<function [[Keymap.add_binding]]>>
          
   
<<constant [[Keymap.c_h]]>>
<<constant [[Keymap.c_x]]>>
<<constant [[Keymap.c_c]]>>

<<function [[Keymap.all_bindings]]>>
  

<<function [[Keymap.add_global_key]]>>
<<function [[Keymap.add_local_key]]>>
<<function [[Keymap.add_minor_key]]>>
<<function [[Keymap.add_major_key]]>>

(*****************************************************************************)
(* Keys <-> string *)
(*****************************************************************************)

<<function [[Simple.string_to_modifier]]>>
  
<<constant [[Simple.name_to_keysym]]>>
  
<<function [[Simple.value_to_key]]>>
  
<<function [[Simple.key_to_value]]>>
      
<<constant [[Simple.key_option]]>>

<<constant [[Simple.binding_option]]>>

@


\subsection{[[core/window.ml]]}


%old: function Window.display>>=

%-------------------------------------------------------------

<<core/window.ml>>=
<<copyright header2>>
open Efuns

<<type [[Window.t]]>>

<<function [[Window.create_at_top]]>>

<<function [[Window.create]]>>

<<function [[Window.top]]>>

<<function [[Window.iter]]>>

<<function [[Window.first]]>>

<<function [[Window.last]]>>

<<function [[Window.next]]>>
      
<<function [[Window.prev]]>>
       
@


\subsection{[[core/frame.ml]]}
%pad: I moved some functions from simple.ml here


%<<function Frame.resize>>=
%let resize frame =
%  install frame.frm_window frame
%@


%-------------------------------------------------------------

<<core/frame.ml>>=
<<copyright header2>>
open Common
open Options

open Efuns
open Text (* for the line fields *)

<<type [[Frame.t]]>>

(*****************************************************************************)
(* Helpers *)
(*****************************************************************************)

<<function [[Frame.buf_text_point]]>>

(*****************************************************************************)
(* Status line *)
(*****************************************************************************)

<<constant [[Frame.status_format]]>>

<<function [[Frame.status_print]]>>


<<function [[Frame.status_modified]]>>

<<function [[Frame.status_col]]>>

<<function [[Frame.status_major_mode]]>>

<<function [[Frame.status_line]]>>

<<function [[Frame.status_name]]>>

(*****************************************************************************)
(* Kill *)
(*****************************************************************************)

<<function [[Frame.kill]]>>

(*****************************************************************************)
(* Display *)
(*****************************************************************************)

<<function [[Frame.install]]>>

(*****************************************************************************)
(* Constructor *)
(*****************************************************************************)

<<constant [[Frame.editname]]>>
<<constant [[Frame.dummy_mode]]>>
  
<<function [[Frame.create_without_top]]>>

<<function [[Frame.active]]>>
      
<<function [[Frame.create]]>>

<<function [[Frame.create_inactive]]>>

(*****************************************************************************)
(* Cursor *)
(*****************************************************************************)

<<function [[Frame.point_to_cursor]]>>

<<function [[Frame.cursor_to_point]]>>


(*****************************************************************************)
(* Display *)
(*****************************************************************************)

<<function [[Frame.display_line]]>>

<<function [[Frame.point_to_xy_opt]]>>

<<function [[Frame.set_cursor]]>>

<<function [[Frame.update_table]]>>

<<function [[Frame.display]]>>

(*****************************************************************************)
(* Misc  *)
(*****************************************************************************)

<<exception [[Frame.BufferKilled]]>>
<<function [[Frame.unkill]]>>

<<function [[Frame.move_point]]>>

<<function [[Frame.current_dir]]>>

<<exception [[Frame.FoundFrame]]>>

<<function [[Frame.find_buffer_frame]]>>

<<constant [[Frame.change_buffer_hooks]]>>

<<function [[Frame.load_file]]>>

<<function [[Frame.change_buffer]]>>

<<function [[Frame.save_buffer]]>>

<<function [[Frame.bindings_help]]>>

<<function [[Simple.to_frame]]>>
@


\section{[[features/]]}



\subsection{[[features/move.ml]]}
%pad: I created this file; The content was in simple.ml before

<<function [[Simple.current_word]]>>=
let current_word buf point =
  (beginning_of_word buf point) ^ (end_of_word buf point)
@

%-----------------------------------------------------------------------------

<<features/move.ml>>=
<<copyright header2>>
open Efuns

(*****************************************************************************)
(* Basic navigation *)
(*****************************************************************************)

<<function [[Simple.move_backward]]>>

<<function [[Simple.move_forward]]>>

(*
let move_backward frame =
   Functions.move_backward frame 1; ()

let move_forward frame = 
  Functions.move_forward frame 1; () 
*) 

<<function [[Simple.begin_to_point]]>>

<<function [[Simple.point_to_end]]>>

(*****************************************************************************)
(* Words *)
(*****************************************************************************)

<<function [[Simple.in_next_word]]>>

<<function [[Simple.in_prev_word]]>>


<<function [[Simple.to_begin_of_word]]>>

<<function [[Simple.to_end_of_word]]>>


<<function [[Simple.backward_word]]>>

<<function [[Simple.forward_word]]>>

<<function [[Simple.beginning_of_word]]>>

<<function [[Simple.end_of_word]]>>

<<function [[Simple.current_word]]>>

(*****************************************************************************)
(* Columns *)
(*****************************************************************************)

<<function [[Simple.line_size]]>>

<<function [[Simple.beginning_of_line]]>>

<<function [[Simple.end_of_line]]>>

<<constant [[Simple.temporary_goal_column]]>>

<<function [[Simple.goal_column]]>>

<<function [[Simple.move_to_goal_column]]>>

(*****************************************************************************)
(* Lines *)
(*****************************************************************************)

<<function [[Simple.forward_line]]>>

<<function [[Simple.backward_line]]>>

let forward_line = forward_line
[@@interactive]

let backward_line = backward_line
[@@interactive]

(*****************************************************************************)
(* Paragraphs *)
(*****************************************************************************)

<<function [[Simple.backward_paragraph]]>>

<<function [[Simple.forward_paragraph]]>>

(*****************************************************************************)
(* Position history *)
(*****************************************************************************)

<<constant [[Simple.history_pos_max]]>>

<<function [[Simple.save_current_pos]]>>

<<function [[Simple.goto_last_saved_pos]]>>

(*****************************************************************************)
(* File *)
(*****************************************************************************)

<<function [[Simple.end_of_file]]>>

<<function [[Simple.begin_of_file]]>>

(*****************************************************************************)
(* Mark *)
(*****************************************************************************)

<<function [[Simple.point_at_mark]]>>
@


\subsection{[[features/edit.ml]]}
%pad: I created this file; The content was in simple.ml before


<<features/edit.ml>>=
<<copyright header2>>
open Efuns
open Move

(*****************************************************************************)
(* Basic insertion *)
(*****************************************************************************)

<<function [[Simple.insert_string]]>>
  
<<constant [[Simple.single_char]]>>
<<function [[Simple.insert_char]]>>

<<function [[Simple.insert_return]]>>

<<function [[Simple.insert_at_place]]>>


<<constant [[Simple.overwrite_mode]]>>

  
<<function [[Simple.self_insert_command]]>>
    
<<function [[Simple.char_insert_command]]>>

(*****************************************************************************)
(* Basic deletion *)
(*****************************************************************************)

<<function [[Simple.delete_char]]>>

<<function [[Simple.delete_backspace_char]]>>

(*****************************************************************************)
(* Words *)
(*****************************************************************************)

<<function [[Simple.delete_backward_word]]>>

<<function [[Simple.delete_forward_word]]>>

<<function [[Simple.on_word]]>>
  
<<function [[Simple.transpose_words]]>>

<<function [[Simple.transpose_chars]]>>

(*****************************************************************************)
(* Overwrite *)
(*****************************************************************************)

<<function [[Edit.toggle_overwrite_mode]]>>
 

(*****************************************************************************)
(* Undo *)
(*****************************************************************************)

<<function [[Simple.undo]]>>

@

\subsection{[[features/transform.ml]]}
%pad: I created this file; not a great filename, a bit vague

<<features/transform.ml>>=
<<copyright header2>>
open Efuns
open Common

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)

(*****************************************************************************)
(* Helpers *)
(*****************************************************************************)

let lines str =
  let xs = Str.full_split (Str.regexp "\n") str in
  let rec aux xs =
    match xs with
    | [] -> []
    | Str.Text s1::Str.Delim s2::xs -> (s1 ^ s2)::aux xs
    | Str.Delim s1::xs -> s1::aux xs
    | [Str.Text s1] -> [s1]
    | _ -> failwith (spf "Impossible: wrong Delim/Text sequence for '%s'" str)
  in
  aux xs

let transform_marked_region frame f =
  let (buf, text, point) = Frame.buf_text_point frame in
  let mark =
    match buf.buf_mark with
      | None -> failwith "No mark set"
      | Some mark -> 
        buf.buf_mark <- None;
        mark
  in
  let (a,b) = if mark > point then (point,mark) else (mark,point) in
  let delta = Text.distance text a b in
  let region = Text.sub text a delta in
  let region' = f region in
  
  text |> Text.with_session (fun () ->
    Text.delete text a delta;
    Text.insert text a region';
    Text.remove_point text mark;
  )

(*****************************************************************************)
(* Filling *)
(*****************************************************************************)

<<function [[Simple.simplify]]>>

<<function [[Simple.fill_paragraph]]>>

(*****************************************************************************)
(* Aligning *)
(*****************************************************************************)

let align_char_string char str =
  let xs = lines str in
  let ys = xs |> List.map (fun s -> 
    try 
      s, String.index s char
    with Not_found -> 
      failwith (spf "Character '%c' not found in line %s" char s)
  ) in
  let max = ys |> List.map snd |> Common2.maximum in
  ys |> List.map (fun (s, idx) -> 
    String.sub s 0 idx ^
    String.make (max - idx) ' ' ^
    String.sub s idx (String.length s - idx)
  ) |> String.concat ""

let align_char frame =
  Select.simple_select frame "character to align: " (fun s ->
    let c = 
      if String.length s <> 1
      then failwith "align_char expects a single character"
      else String.get s 0
    in
    transform_marked_region frame (align_char_string c);
  )
[@@interactive]

@

\subsection{[[features/copy_paste.ml]]}
%pad: I created this file; The content was in simple.ml before

<<constant [[Simple.last_kill]]>>=
let last_kill = ref None
@

<<function [[Simple.kill_text]]>>=
let kill_text text point len =
  let point,str = Text.delete_res text point len in
  match !last_kill with
  | Some (oldtext,oldpoint) when oldpoint = point && oldtext == text ->
      kill_ring.(0) <- kill_ring.(0)^str
  | _ ->
      last_kill := Some (text,point);
      kill_string str
@


<<function [[Simple.kill_eol]]>>=
let kill_eol buf point =
  let text = buf.buf_text in
  let eol = Text.point_to_eol text point in
  let len =
    if eol = 0 then 1 else eol
  in
  kill_text text point len
@

<<function [[Simple.kill_bol]]>>=
let kill_bol buf point =
  let text = buf.buf_text in
  let len = Text.point_to_bol text point in
  if len > 0 then
    ( Text.bmove text point len;
      kill_text text point len)
@

%-----------------------------------------------------------------------------

<<features/copy_paste.ml>>=
<<copyright header2>>
open Efuns
open Move

(*****************************************************************************)
(* Kill *)
(*****************************************************************************)

<<constant [[Simple.kill_size]]>>
<<constant [[Simple.kill_max]]>>
<<constant [[Simple.kill_ring]]>>
<<constant [[Simple.last_kill]]>>
<<constant [[Simple.last_insert]]>>

(* alt: 
 * - have a mutable clipboard here in simple.ml (or global.ml)
 *   pro: does not require a frame so can be done in lowlevel API (kill_string)
 * - have the clipboard be part of the backend
 *   pro: clearer that backends in graphics/ need to setup this
 *)
let add_clipboard frame str =
  let top_window = Window.top frame.frm_window in
  let graphic = Efuns.backend top_window in
  graphic.Xdraw.set_clipboard (Some str)

let paste_clipboard frame =
  let (_, text, point) = Frame.buf_text_point frame in
  let top_window = Window.top frame.frm_window in
  let graphic = Efuns.backend top_window in
  let str =
    match graphic.Xdraw.get_clipboard () with
    | None | Some "" -> Message.message frame "Nothing in the clipboard"; ""
    | Some s -> 
      graphic.Xdraw.set_clipboard None;
      s
  in
  let pos, len =  Text.insert_res text point str in
  Text.fmove text point len; 
  last_insert := Some(frame,pos,0,len)
[@@interactive]


<<function [[Simple.kill_string]]>>


<<function [[Simple.kill_text]]>>

<<function [[Simple.kill_end_of_line]]>>

<<function [[Simple.kill_eol]]>>

<<function [[Simple.kill_bol]]>>

<<function [[Simple.insert_killed]]>>

<<function [[Simple.insert_next_killed]]>>


<<function [[Simple.kill_region]]>>

<<function [[Simple.copy_region]]>>



<<function [[Complex.mark_at_point]]>>

let mark_whole_buffer frame =
  Move.end_of_file frame;
  mark_at_point frame;
  Move.begin_of_file frame;  
[@@interactive]
@

\subsection{[[features/scroll.ml]]}
%pad: I created this file; The content was in simple.ml before

<<features/scroll.ml>>=
<<copyright header2>>
open Efuns
open Move


(*****************************************************************************)
(* Screen *)
(*****************************************************************************)
  
<<function [[Simple.forward_screen]]>>

<<function [[Simple.backward_screen]]>>

(*****************************************************************************)
(* Scroll *)
(*****************************************************************************)

<<function [[Simple.scroll_line]]>>

<<function [[Simple.scroll_down]]>>

<<function [[Simple.scroll_up]]>>

<<function [[Simple.scroll_other_up]]>>

<<function [[Simple.scroll_other_down]]>>

<<function [[Simple.recenter]]>>

@

\subsection{[[features/color.ml]]}
%pad: I created this file; The content was in simple.ml before

<<features/color.ml>>=
open Efuns

(*****************************************************************************)
(* Color helpers *)
(*****************************************************************************)

<<function [[Simple.color]]>>

(*****************************************************************************)
(* Per-mode colorization  *)
(*****************************************************************************)

(* should be set by each major mode to point to the right function *)
let color_func = Store.create_abstr "Color.color_func"

(* alt: 
 *  - recolorize after save automatically (which I do for 
 *    most pfff modes via Ebuffer.saved_buffer_hooks)
 *  - per-major-mode interactive M-x color_buffer (but I removed support
 *    for this)
 *)
let get_color_func buf =
  Var.get_var buf color_func


let color_region frame =
  let (buf, _, point) = Frame.buf_text_point frame in
  let mark = Ebuffer.get_mark buf point in
  let (start_point,end_point) =
    if point < mark then (point,mark) else (mark,point) 
  in
   (get_color_func buf) buf start_point end_point
[@@interactive]

let color_buffer_buf buf =
  let text = buf.buf_text in
  (* less: Text.unset_attrs text;   was done in ocaml_mode.mll *)

  Text.with_new_point text (fun start_point ->
  Text.with_new_point text (fun end_point ->
  Text.set_position text end_point (Text.size text);
  (* less: 
   *  let hooks = 
   *    try Var.get_global Pl_colors.color_buf_hook with Not_found ->[] in
   *  Hook.exec_hooks hooks buf;
   *)
  (get_color_func buf) buf start_point end_point;
  ))

(* alt: C-x h and then M-x color_region *)
let color_buffer frame =
  color_buffer_buf frame.frm_buffer
[@@interactive]


@

\subsection{[[features/minibuffer.ml]]}



%-------------------------------------------------------------

<<features/minibuffer.ml>>=
<<copyright header2>>
open Efuns

<<constant [[Minibuffer.charreprs]]>>
<<toplevel [[Minibuffer._1]]>>

<<function [[Minibuffer.buf_create]]>>

<<function [[Minibuffer.kill]]>>

<<function [[Minibuffer.return]]>>

<<function [[Minibuffer.create]]>>

<<function [[Minibuffer.create_return]]>>

<<function [[Minibuffer.update_request]]>>
  
@


\subsection{[[features/highlight.ml]]}
%pad: I created this file; The content was in simple.ml before

%-------------------------------------------------------------

<<features/highlight.ml>>=
<<copyright header efuns>>
open Efuns

<<function [[Simple.unhighlight_region]]>>

<<function [[Simple.highlight_region]]>>

<<constant [[Simple.highlighted]]>>
<<constant [[Simple.highlighted_chars]]>>
let unhighlight_hook = Store.create_abstr "unhighlight_hook"

<<function [[Simple.unhighlight]]>>
  
<<toplevel [[Highlight]] starting hook>>
@


\subsection{[[features/mouse.ml]]}
%pad: I created this file; The content was in simple.ml before

%-------------------------------------------------------------

<<features/mouse.ml>>=
<<copyright header efuns>>
open Efuns
module H = Highlight

<<function [[Simple.highlight]]>>

let unhighlight_hook (text, debut, fin) =
  Text.with_new_point text (fun curseur ->
  Text.with_new_point text (fun final ->
    Text.set_position text curseur debut;
    Text.set_position text final fin;
    let str = Text.region text curseur final in
    Copy_paste.kill_string str;
    (* TODO WX_xterm.set_cutbuffer xterm str; for interop?  *)
  ))


<<function [[Simple.mouse_drag_region]]>>

<<function [[Simple.mouse_yank_at_click]]>>

<<function [[Simple.mouse_save_then_kill]]>>

<<function [[Simple.mouse_set_frame]]>>

<<toplevel [[Mouse]] starting hook>>

@

\subsection{[[features/indent.ml]]}
%pad: I created this file; The content was in simple.ml before

%-------------------------------------------------------------

<<features/indent.ml>>=
<<copyright header efuns>>

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(* Main indent actions.
 *
 * See also prog_modes/common_indenter.ml for the functions to
 * help build indenters. Those indenters will then probably
 * be assigned to indent_func below, which will then allow to
 * use M-x indent_xxx functions to indent files.
 *
 *)

(*****************************************************************************)
(* Variable *)
(*****************************************************************************)

(* pad: I factorized some indent code by using a variable *)
let indent_func = Store.create_abstr "Indent.indent_func"

let get_indent_func buf =
  Var.get_var buf indent_func

(*****************************************************************************)
(* Indent actions *)
(*****************************************************************************)

let indent_phrase frame =
  let (buf, _, point) = Frame.buf_text_point frame in
  (get_indent_func buf) buf point point
[@@interactive]

let indent_region frame =
  let (buf, _, point) = Frame.buf_text_point frame in
  let mark = Ebuffer.get_mark buf point in
  let (start_point,end_point) =
    if point < mark then (point,mark) else (mark,point) 
  in
   (get_indent_func buf) buf start_point end_point
[@@interactive]

(* alt: C-x h and then M-x color_region *)
let indent_buffer frame =
  let (buf, text, _) = Frame.buf_text_point frame in
  Text.with_new_point text (fun start_point ->
  Text.with_new_point text (fun end_point ->
    Text.set_position text end_point (Text.size text);
    (get_indent_func buf) buf start_point end_point;
  ))
[@@interactive]

(*****************************************************************************)
(* Indent helpers *)
(*****************************************************************************)
(* This could go in prog_modes/common_indenter.ml, but this is also
 * used by other indenting strategies like ocaml_ocp_indent.ml
 *)

<<function [[Simple.set_indent]]>>

@

\subsection{[[features/structure.ml]]}
%pad: I created this file; The content was in simple.ml before

%-------------------------------------------------------------

<<features/structure.ml>>=
<<copyright header efuns>>
open Efuns

<<function [[Simple.next_hole]]>>


<<function [[Simple.insert_structure]]>>

<<function [[Simple.install_structures]]>>

@

\subsection{[[features/select.ml]]}


<<function [[Select.select_yes_or_no]]>>=
let select_yes_or_no frame request action =
  let top_window = Window.top frame.frm_window in
  let map = Keymap.create () in
  let yes_reply mini_frame = 
    Minibuffer.kill mini_frame frame;
    top_window.top_second_cursor <- None;
    action true
  in
  let no_reply  mini_frame = 
    Minibuffer.kill mini_frame frame;
    top_window.top_second_cursor <- None;
    action false
  in
  Keymap.add_binding map [NormalMap, Char.code 'y'] yes_reply;
  Keymap.add_binding map [NormalMap, Char.code 'Y'] yes_reply;
  Keymap.add_binding map [NormalMap, Char.code 'n'] no_reply;
  Keymap.add_binding map [NormalMap, Char.code 'N'] no_reply;
  let mini = Minibuffer.create frame map request in
  mini.frm_buffer.buf_map_partial <- false;
  mini
@

<<function [[Select.find_completion_frame]]>>=
let find_completion_frame _frame =
  let buf = Ebuffer.default "*Completions*" in
  Frame.find_buffer_frame buf
@

<<function [[Select.display_completions]]>>=
let display_completions frame list =
  if list =*= [] 
  then Message.message frame "No Completions"
  else
    let rec iter list s =
      match list with
      | [] -> s
      | [f] -> Printf.sprintf "%s\n%s" s f
      | f1::f2::tail  ->
          iter tail (Printf.sprintf "%s\n%-40s%s" s f1 f2)
    in
    let buf = Ebuffer.default "*Completions*" in
    let text = buf.buf_text in
    Text.update text (iter list "Completions :");
    
    let hooks = try Var.get_global completions_buf_hook with Not_found -> [] in
    Hook.exec_hooks hooks buf;

    (try Frame.find_buffer_frame buf
     with Not_found -> Frame.create_inactive (Multi_frames.cut_frame frame) buf
    ) |> ignore
@

<<function [[Text.update]]>>=
let update text str =
  let newlines = compute_newlines str in
  let len = String.length str in
  text.text_points |> List.iter (fun point -> 
    point.pos <- get_position text point
  );
  text.text_string <- Bytes.of_string str;
  text.text_attrs <- (Array.make len direct_attr);
  text.text_size <- len;
  text.gpoint <- { pos = 0; line = 0 };
  text.gsize <- 0;
  text.text_newlines <- newlines;
  text.text_nlines <- Array.length newlines;
  text.text_modified <- text.text_modified + 1 ;
  text.text_clean <- true;
  text.text_history <- [];
  text.text_points |> List.iter (fun point -> 
      let pos = point.pos in
      point.pos <- 0;
      point.line <- 0;
      set_position text point pos
  ) 
  
@

<<function [[Select.remove_completions]]>>=
let remove_completions frame =
  try
    let frame = find_completion_frame frame in
    Multi_frames.remove_frame frame
  with Not_found -> ()
@

<<function [[Select.set_history]]>>=
let set_history map string history =
  let current = ref 0 in
  Keymap.add_binding map [NormalMap, XK.xk_Up] (fun mini_frame ->
    if !current =|= List.length !history 
    then Top_window.mini_message mini_frame "No previous line in history"
    else begin
      let ele = Utils.list_nth !current !history in
      incr current;
      let buf = mini_frame.frm_buffer in
      let text = buf.buf_text in
      Text.clear text;
      string := ele;
      Edit.insert_string mini_frame ele;
    end
  );      
  Keymap.add_binding map [NormalMap, XK.xk_Down] (fun mini_frame ->
    if !current < 1 
    then Top_window.mini_message mini_frame "No other line in history"
    else begin
      decr current;
      let ele = Utils.list_nth !current !history in
      let buf = mini_frame.frm_buffer in
      let text = buf.buf_text in
      Text.clear text;
      string := ele;
      Edit.insert_string mini_frame ele;
    end
  )
@

<<function [[Text.clear]]>>=
let clear text =
  low_delete text 0 (text.text_size - text.gsize) |> ignore;
  text.text_history <- [];
  List.iter (fun p -> p.pos <- 0; p.line <- 0) text.text_points
@



<<constant [[Select.file_hist]]>>=
let file_hist = ref []
@

<<constant [[Select.dont_complete]]>>=
(* todo: could use File_type.is_obj_file to unify the treatment of obj file
 * in C-x C-f and shell
 *)
let dont_complete = define_option ["avoid_filenames"] ""
    (list_option string_option) 
  [ ".*\\.o$"; ".*\\.cm.$";".*\\.cmxa$";".*~";".*\\.a$";"core$";"\\..*"]
@
%$

<<constant [[Select.dont_complete_regexps]]>>=
let dont_complete_regexps = ref ([],Str.regexp "")
@

<<function [[Select.dont_complete_regexp]]>>=
let dont_complete_regexp () =
  let (old,reg) = !dont_complete_regexps in
  if Common.phys_equal old !!dont_complete 
  then reg
  else
    let reg = Str2.regexp_from_list !!dont_complete in
    dont_complete_regexps := (!!dont_complete, reg);
    reg
@

<<function [[Select.avoid_completion]]>>=
let avoid_completion s =
  let bad_regexp = dont_complete_regexp () in
  not (Str.string_match bad_regexp s 0)
@

<<function [[Select.is_userdir]]>>=
let is_userdir string =
  let n = String.length string in
  (n > 1) && (string.[0] =$= '~') &&
  (try
      String.rindex string '/' |> ignore;
      false
   with Not_found -> true
   )
@

<<function [[Select.complete_filename]]>>=
let complete_filename frame good_file filename =
  if is_userdir filename 
  then (* Parse_file.users *) failwith "Select.complete_filename: TODO"
  else
  let filename = Utils.string_to_filename filename in
  let dirname = dirname frame filename in
  let file_list = Utils.file_list dirname in
  let file_list = file_list |> List.map (fun file ->
    let path = Filename.concat dirname file in
    try 
      let stat = Unix.stat path in
      match stat.Unix.st_kind with
      | Unix.S_DIR -> file ^ "/"
      | _ -> file
    with exn -> 
      UCommon.pr2 (spf "complete_filename: exn = %s" (Common.exn_to_s exn));
      file
  )
  in

  match file_list with
  | _a::_b::_ -> 
      begin
        match 
          List.fold_left (fun list ele ->
              if good_file ele then ele :: list else list
          ) [] file_list
        with
          [] -> file_list 
            (* if no completion is OK, return files that should have 
          been avoided *)
        | list -> list
      end
  | _ -> file_list
@

<<function [[Select.select_file]]>>=
let select_file frame request history start action =
  let map = Keymap.create () in
  let string = ref "" in
  Keymap.add_binding map [ControlMap, Char.code 'g'] (fun mini_frame ->
    UCommon.pr2 "HERE";
    remove_completions mini_frame;
    Minibuffer.kill mini_frame frame
  );
  let completion = ref "_*NoCompletion*_" in
  let completions = ref [] in
  Keymap.add_binding map [NormalMap, XK.xk_Tab] (fun mini_frame ->
    let text = mini_frame.frm_buffer.buf_text in
    (*if (!completion <> !string) then  *)
    begin
      string := Text.to_string text;
      completions := complete_filename frame avoid_completion !string;
      let suffix, n = 
        Utils.common_suffix !completions (basename !string) in
      let suffix = 
        let s = !string ^ suffix in
        let len = String.length s in
        if len>0 && s.[len - 1] <> '/' 
        then
          try
            let filename = Utils.string_to_filename s in
            let dirname = dirname frame filename in
            let basename = basename filename in
            let stat = Unix.stat (Filename.concat dirname basename) in
            match stat.Unix.st_kind with
            |  Unix.S_DIR -> suffix ^ "/"
            | _ -> suffix
          with _ -> suffix
        else suffix
      in
      completion := !string;
      Text.insert text mini_frame.frm_point suffix;
      Text.fmove text mini_frame.frm_point (String.length suffix);
      string := Text.to_string text;
       if n>1 
       then
          display_completions frame
            (Utils.completion !completions (basename !string))
    end
(* TODO later, but right now have some bad side effects.
 e.g. if do TAB in one dir, then do M-back to remove a dir, and rerun
 TAB then it does not update the completion buffer with the candidates
 for the new dir, so for now commented!
   else
    (* can be improved, by displaying another part of the completion buffer *)
      display_completions frame
          (Utils.completion !completions (basename !string))
*)
  );
  set_history map string history;
  incremental_mini_buffer frame map request start
    (fun _frame str -> string := str)
    (fun _old_frame str -> 
      history := str :: !history;
      remove_completions frame;
      let str = Utils.string_to_filename str in
      action str
    ) |> ignore;
  Keymap.add_binding map [NormalMap, XK.xk_Prior] (fun frame ->
    let frame = find_completion_frame frame in
    Scroll.backward_screen frame
  );
  Keymap.add_binding map [NormalMap, XK.xk_Next] (fun frame ->
    let frame = find_completion_frame frame in
    Scroll.forward_screen frame
  );
  Keymap.add_binding map [NormalMap, Char.code '~'] (fun frame ->
    let (buf, text, point) = Frame.buf_text_point frame in
    Copy_paste.kill_bol buf point;
    Edit.self_insert_command frame;      
    string := Text.to_string text
  );
  Keymap.add_binding map [NormalMap, Char.code '/'] (fun frame ->
    let (buf, text, point) = Frame.buf_text_point frame in
    if Text.bmove_res text point 1 =|= 1 then
      ( let c = Text.get_char text point in
        Text.fmove text point 1;
        if c =$= '/' then
          Copy_paste.kill_bol buf point);
    Edit.self_insert_command frame;
    string := Text.to_string text            
  );
  ()
@

<<function [[Select.select_filename]]>>=
let select_file_from_pwd frame request action =
  let curdir = Frame.current_dir frame in
  select_file frame request file_hist (Utils.filename_to_string curdir) action
@




<<function [[Select.get_previous_frame]]>>=
let get_previous_frame () = 
  match !prev_buffers with
  | [] -> ""
  | x::_xs -> x
@

<<constant [[Select.buf_hist]]>>=
let buf_hist = ref []
@

<<function [[Select.select_buffer]]>>=
let select_buffer frame request default action =
  Select.select frame (request^"(default :"^ default ^ ") ") buf_hist ""
    (fun _ -> buffer_list ()) 
    (fun s -> s) 
    (fun str ->
      let str = if str = "" then default else str in
      action str)
@

<<function [[Select.select_string]]>>=
let select_string frame request history default action =
  let map = Keymap.create () in
  let string = ref "" in
  set_history map string history;
  Minibuffer.create_return frame map request default
    (fun _ str -> 
      (match !history with
          hd :: _ when hd = str -> ()
        | _ -> if str <> "" then
              history := str :: !history);
      action str
    ) |> ignore
@

<<function [[Select.simple_select]]>>=
let simple_select frame request action =
  let map = Keymap.create () in
  Minibuffer.create_return frame map request "" (fun _ str -> action str) 
   |> ignore
@


%-------------------------------------------------------------

<<features/select.ml>>=
<<copyright header2>>
open Common
open Options
open Efuns

(* small wrappers around Filename but that better handles
 * completion on directories.
 *)
let basename str =
  if str = "" || str =~ ".*/$"
  then ""
  else Filename.basename str

let dirname frame filename =
  let str =
    if Filename.is_relative filename 
    then Filename.concat (Frame.current_dir frame) filename
    else filename
  in
  match str with
  | "" -> Frame.current_dir frame
  | _ when str =~ ".*/$" -> filename
  | _ -> Filename.dirname str


<<function [[Select.select_yes_or_no]]>>

<<function [[Select.find_completion_frame]]>>

let completions_buf_hook = Store.create_abstr "completions_buf_hook"

<<function [[Select.display_completions]]>>

<<function [[Select.remove_completions]]>>

<<function [[Select.set_history]]>>

<<function [[Select.incremental_mini_buffer]]>>

<<function [[Select.select]]>>
  
  (****************************************************
  
               Filename selection
  
  ****************************************************)

<<constant [[Select.file_hist]]>>

<<constant [[Select.dont_complete]]>>
  
<<constant [[Select.dont_complete_regexps]]>>
<<function [[Select.dont_complete_regexp]]>>

<<function [[Select.avoid_completion]]>>

<<function [[Select.is_userdir]]>>

<<function [[Select.complete_filename]]>>

<<function [[Select.select_file]]>>

<<function [[Select.select_filename]]>>


  (****************************************************
  
               Other selection
  
  ****************************************************)

<<function [[Select.select_string]]>>


<<function [[Select.simple_select]]>>
  
  
@


\subsection{[[features/system.ml]]}


%-------------------------------------------------------------

<<features/system.ml>>=
open Common
open Efuns
open Unix

type end_action = (Efuns.buffer -> int -> unit)

(* Takes pwd in parameter. The alternative is to do
 * a Unix.chdir just before the command.
 *)

<<function [[System.open_process]]>>

<<function [[System.system]]>>

<<function [[System.start_command]]>>

<<constant [[System.shell_hist]]>>
<<function [[System.shell_command]]>>
  
@


\subsection{[[features/search.ml]]}

<<toplevel [[Search._1]]>>=
(*let _ = Time.init ()*)
@


<<function [[Search.to_regexp]]>>=
let to_regexp flag str =
  match flag with
  | Regexp ->
      (if !case_fold 
       then Str.regexp_case_fold 
       else Str.regexp
      ) str
  | RegexpString ->
      (if !case_fold 
       then Str.regexp_string_case_fold
       else Str.regexp_string
      ) str
@

<<type [[Search.query]]>>=
type query = NoQuery | Query of frame * string
@


<<function [[Search.no_query]]>>=
let no_query f = f true
@

<<function [[Search.query]]>>=
let query frame request f =
  let top_window = Window.top frame.frm_window in
  top_window.top_second_cursor <- Some frame;
  Select.select_yes_or_no frame request f |> ignore
@

<<constant [[Search.string_history]]>>=
let string_history = ref []
@



<<constant [[Search.library_regexp]]>>=
let library_regexp = Str.regexp ".*\\.cm[oa]"
@

<<function [[Search.library_file]]>>=
let library_file str =
  Str.string_match library_regexp str 0
@

<<function [[Search.select_lib_filename]]>>=
let select_lib_filename frame request action =
  Select.select frame request Select.file_hist (Frame.current_dir frame)
  (Select.complete_filename frame library_file)
  Filename.basename action
@


%-------------------------------------------------------------

<<features/search.ml>>=
<<copyright header2>>
open Efuns
    
<<toplevel [[Search._1]]>>

<<constant [[Search.case_fold]]>>
<<function [[Search.to_regexp]]>>

<<type [[Search.query]]>>

<<function [[Search.replace]]>>


<<function [[Search.no_query]]>>
<<function [[Search.query]]>>

<<constant [[Search.string_history]]>>
<<function [[Search.select_replace]]>>

<<function [[Search.replace_string]]>>

<<function [[Search.query_replace_string]]>>

<<function [[Search.replace_regexp]]>>

<<function [[Search.query_replace_regexp]]>>

<<constant [[Search.library_regexp]]>>
<<function [[Search.library_file]]>>

<<function [[Search.select_lib_filename]]>>

<<constant [[Search.last_search]]>>
<<function [[Search.isearch]]>>


<<constant [[Search.isearch_forward_regexp]]>>
<<constant [[Search.isearch_forward]]>>
<<constant [[Search.isearch_backward]]>>
<<constant [[Search.isearch_backward_regexp]]>>
  
@


\subsection{[[features/interactive.ml]]}
%pad: many of the content was in complexe.ml before 
% (the variable and parameter stuff)


%-------------------------------------------------------------

<<features/interactive.ml>>=
<<copyright header2>>
open Efuns
module Parameter = Parameter_option

(* M-x *)
  
<<function [[Interactive.create_bindings]]>>

<<constant [[Interactive.meta_hist]]>>

<<function [[Interactive.buf_interactives]]>>
  
<<function [[Interactive.exec_interactive]]>>
      
<<function [[Interactive.call_interactive]]>>

(* variables *)

<<constant [[Complex.variable_hist]]>>
<<constant [[Complex.value_hist]]>>
  
<<constant [[Complex.all_vars]]>>
<<function [[Complex.all_variables]]>>
  
<<function [[Complex.set_local_variable]]>>
  
<<function [[Complex.set_global_variable]]>>
  
<<function [[Complex.get_variable]]>>

(* parameters *)
open Options

<<constant [[Complex.parameters_hist]]>>
  
<<function [[Complex.set_parameter]]>>
  
<<function [[Complex.get_parameter]]>>

@


\subsection{[[features/abbrevs.ml]]}

%old:
% <<toplevel [[Abbrevs._1]]>>

%-------------------------------------------------------------

<<features/abbrevs.ml>>=
<<copyright header2>>
(*
Expansion des abbreviations: 
deux fonctions principales: 
- "dabbrev_expand": expansion des mots a partir de mots trouves dans les
     buffers (binding normap "M-/").
- "expand_sabbrev": expansion des mots a partir d'abbreviations trouvees
    dans des tables associees au buffer (variable "abbrev_table") 
    (binding normal: un caractere de fin de mot (espace,newline,..))
*)
open Efuns

<<function [[Abbrevs.escaped]]>>
  
<<constant [[Abbrevs.dabbrev_buf]]>>
<<function [[Abbrevs.dabbrev_expand]]>>

<<constant [[Abbrevs.abbrev_table]]>>
  
<<function [[Abbrevs.expand_sabbrev]]>>

let char_expand_abbrev frm =
  expand_sabbrev frm; 
  Edit.self_insert_command frm
 
@


\subsection{[[features/multi_buffers.ml]]}

<<function [[Multi_buffers.switch_to_other_buffer]]>>=
(* C-M-l *)
let switch_to_other_buffer frame =
  let default = get_previous_frame () in
  set_previous_frame frame;
  Frame.change_buffer frame.frm_window default
@

%-------------------------------------------------------------

<<features/multi_buffers.ml>>=
<<copyright header2>>
open Efuns

<<function [[Simple.buffer_list]]>>

<<constant [[Select.prev_buffers]]>>
<<function [[Select.set_previous_frame]]>>
<<function [[Select.get_previous_frame]]>>

<<function [[Multi_buffers.switch_to_other_buffer]]>>


<<constant [[Select.buf_hist]]>>
<<function [[Select.select_buffer]]>>


<<function [[Simple.next_buffer]]>>

<<function [[Simple.kill_buffer]]>>

<<constant [[Complex.up_buffer]]>>
<<function [[Complex.down_buffer]]>>

<<function [[Complex.up_buffer]]>>
  
<<function [[Complex.left_buffer]]>>

<<function [[Complex.right_buffer]]>>

<<function [[Complex.change_buffer]]>>

(* was in simple.ml or complexe.ml before *)

<<function [[Complex.save_buffers_and_action]]>>

<<function [[Complex.save_some_buffers]]>>

<<function [[Complex.load_buffer]]>>

<<function [[Complex.insert_file]]>>

<<function [[Complex.write_buffer]]>>

<<function [[Complex.save_buffer]]>>

@

\subsection{[[features/multi_frames.ml]]}


%-------------------------------------------------------------

<<features/multi_frames.ml>>=
<<copyright header2>>
open Efuns
  
<<function [[Multi_frames.cut_frame]]>>

<<function [[Multi_frames.remove_frame]]>>

<<function [[Multi_frames.v_cut_frame]]>>

<<function [[Multi_frames.h_cut_frame]]>>

<<function [[Multi_frames.delete_frame]]>>

<<function [[Multi_frames.one_frame]]>>
      
      
<<function [[Multi_frames.next_frame]]>>
@


\subsection{[[features/compil.ml]]}

<<type [[Compil.error]]>>=
type error = {
    (* error location *)    
    err_filename : string;
    err_line : int;
    err_begin : int;
    err_end : int;
    (* error message *)
    err_msg : int;
  }
@

<<constant [[Compil.c_error_regexp]]>>=
let c_error_regexp = define_option ["compil"; "error_regexp"] "" regexp_option
  (string_to_regex "^\\([^:\n]+\\):\\([0-9]+\\):.*$")
@
%$

<<function [[Compil.c_find_error]]>>=
let find_error_gen re text error_point =
  let groups = 
    Text.search_forward_groups text re
      error_point 2 in
  let error =
    {  
      err_msg = Text.get_position text error_point;
      err_filename = groups.(0);
      err_line = (int_of_string groups.(1)) - 1;
      err_begin = 0;
      err_end = 0;
    } in
  Text.fmove text error_point 1;
  error
@



%<<function Compil.set_compilation_buffer>>=
%(*
%let set_compilation_buffer frame comp_buf cdir =
%  (*let error_point = new_point comp_buf.buf_text in*)
%  let window =
%    match !compilation_frame with
%    | None -> 
%        Multi_frames.cut_frame frame
%    | Some (frame,point, _) ->
%        Text.remove_point frame.frm_buffer.buf_text point;  
%        if frame.frm_killed 
%        then Multi_frames.cut_frame frame 
%        else frame.frm_window
%  in
%  let error_point = Text.new_point comp_buf.buf_text in
%  let comp_frame = Frame.create window None comp_buf in
%  compilation_frame := Some (comp_frame, error_point, cdir)
%*)
%@




%-------------------------------------------------------------

<<features/compil.ml>>=
<<copyright header2>>
open Common
open Options
open Efuns

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(*
 * todo:
 *  - handle return on an error!
 *  - factorize code between compil and grep
 *)

(*****************************************************************************)
(* Types and globals *)
(*****************************************************************************)

<<constant [[Compil.compilation_frame]]>>

<<type [[Compil.error]]>>

type find_error_fun = Text.t -> Text.point -> error

(*****************************************************************************)
(* Helpers *)
(*****************************************************************************)

<<constant [[Compil.c_error_regexp]]>>

<<function [[Compil.c_find_error]]>>

(* apparently the Core Filename module has an expand function doing that *)
let expand_tilde s =
  if s =~ "^~/\\(.*\\)$"
  then
    let rest = Common.matched1 s in
    Filename.concat (Sys.getenv "HOME") rest
  else s

(*****************************************************************************)
(* More vars *)
(*****************************************************************************)

<<constant [[Compil.find_error]]>>

let find_error_location_regexp = Store.create_abstr "find_error_loc_regexp"

let find_error_of_buf buf = 
  try Var.get_var buf find_error
  with Not_found | Failure _ -> 
     let re = 
        try Var.get_var buf find_error_location_regexp
        with Not_found | Failure _ -> snd !!c_error_regexp
     in
     find_error_gen re

(*****************************************************************************)
(* M-x next_error *)
(*****************************************************************************)
  
<<function [[Compil.next_error]]>>

(*****************************************************************************)
(* Options *)
(*****************************************************************************)

<<constant [[Compil.compile_find_makefile]]>>
  
<<constant [[Compil.make_command]]>>

(*****************************************************************************)
(* Colors *)
(*****************************************************************************)

let find_error_error_regexp = Store.create_abstr "find_error_err_regexp"

let color_buffer buf =
  Dircolors.colorize_buffer buf;

  let re =
    try Var.get_var buf find_error_location_regexp
    with Not_found | Failure _ -> snd !!c_error_regexp
  in
  Color.color buf re false
    (Text.make_attr (Attr.get_color "green") 1 0 false);

  let re =
    try Var.get_var buf find_error_error_regexp
    with Not_found | Failure _ -> Str.regexp "Error"
  in
  Color.color buf re false
    (Text.make_attr (Attr.get_color "red") 1 0 false);
  ()

(*****************************************************************************)
(* The mode *)
(*****************************************************************************)
  
let mode = Ebuffer.new_major_mode "Compilation"  None

(*****************************************************************************)
(* M-x compile *)
(*****************************************************************************)
  
<<constant [[Compil.make_hist]]>>
<<function [[Compil.compile]]>>

(*****************************************************************************)
(* M-x grep *)
(*****************************************************************************)

<<constant [[Compil.grep_command]]>>
  
<<constant [[Compil.grep_hist]]>>
<<function [[Compil.grep]]>>
@








\subsection{[[features/electric.ml]]}
%pad:I created this file; its content was in simple.ml before

<<features/electric.ml>>=
<<copyright header2>>

<<function [[Simple.previous_char]]>>

<<function [[Simple.hungry_char]]>>

<<function [[Simple.hungry_electric_delete]]>>

<<function [[Simple.electric_insert_space]]>>
@


\subsection{[[features/misc_features.ml]]}
%pad: was originally called simple.ml (was a port of simple.el in Emacs)
% but I spread its content in many files. I also moved the content
% that was in complexe.ml in.

%dead: in mli
% (* attributes *)
% val unset_attr : Efuns.action
%
% val open_display : 'a -> 'b
% val umask : int
% val file_perm : Unix.file_perm Store.var
% val mkdir : Efuns.action

% value_to_key -> <>
<<function [[Simple.string_to_modifier]]>>=
let string_to_modifier s =  
  let mask = ref 0 in
  for i = 0 to String.length s - 1 do
    mask := !mask lor (match s.[i] with
      | 'C' -> Xtypes.controlMask
      | 'A' -> Xtypes.mod1Mask
      | 'M' -> Xtypes.mod1Mask
      | '1' -> Xtypes.mod1Mask
      | _ -> 0
    )
  done;
  !mask
@

<<constant [[Simple.name_to_keysym]]>>=
let name_to_keysym = 
  ("Button1", XK.xk_Pointer_Button1) ::
  ("Button2", XK.xk_Pointer_Button2) ::
  ("Button3", XK.xk_Pointer_Button3) ::
  ("Button4", XK.xk_Pointer_Button4) ::
  ("Button5", XK.xk_Pointer_Button5) ::
  XK.name_to_keysym
@


<<function [[Simple.value_to_key]]>>=
(* form: SC-Button1 *)
let value_to_key v =
  match v with 
    Options.Value s -> 
      let key, mods = 
        try
          let index = String.index s '-' in
          let mods = String.sub s 0 index in
          let key = String.sub s (index+1) (String.length s - index - 1) in
          key, mods
        with _ -> s, ""
      in
      let key = List.assoc key name_to_keysym in
      let mods = string_to_modifier mods in
      let map = 
        if mods land (Xtypes.controlMask lor Xtypes.mod1Mask) = 
                     (Xtypes.controlMask lor Xtypes.mod1Mask)
        then ControlMetaMap else
        if mods land Xtypes.controlMask <> 0 then ControlMap else
        if mods land Xtypes.mod1Mask <> 0 then MetaMap else NormalMap
      in
      map, key
      
  | _ -> raise Not_found
@

<<function [[Simple.key_to_value]]>>=
let key_to_value k = Options.Value (print_key k)
@




<<function [[Simple.line_size]]>>=
let line_size frame =
  (point_to_end frame) + (point_to_end frame)
@



<<function [[Simple.to_frame]]>>=
let to_frame f frame =
  f frame.frm_buffer frame.frm_point
@





<<function [[Simple.set_indent]]>>=
(* Modify the indentation of line of point,
 * untabify the line, and move the point to the indented level.
 *)
let set_indent text curseur offset = 
    Text.bmove text curseur (Text.point_to_bol text curseur);

    let rec iter offset =
      let c = Text.get_char text curseur in
      if offset > 0 then
        (match c with
        | ' ' ->
          Text.fmove text curseur 1; 
          iter (offset - 1)
        | '\t' ->
          Text.delete text curseur 1;
          iter offset
        | _ ->
          Text.insert text curseur (String.make offset ' ');
          Text.fmove text curseur offset
        )
      else
      if c = ' ' || c='\t' then begin
        Text.delete text curseur 1;
        iter 0;
      end            
    in
    iter offset
@

<<toplevel [[Simple._1]]>>=
let _ =
  Hook.add_start_hook (fun () ->
    Var.set_global line_comment "";
    (* this needs to be done early, not in config.ml, because some
     * major modes may want to access it to add stuff in their
     * own local versions (e.g., in caml_mode.ml to recolorize the buffer
     *)
    Var.set_global Ebuffer.saved_buffer_hooks [update_time];
    Var.set_global exit_hooks [];
  )
@

%dead:
%<<function [[Simple.unset_attr]]>>

%-------------------------------------------------------------

<<features/misc_features.ml>>=
<<copyright header2>>
open Efuns

(*****************************************************************************)
(* Vars *)
(*****************************************************************************)

<<constant [[Simple.line_comment]]>>

(*****************************************************************************)
(* Misc *)
(*****************************************************************************)

<<function [[Simple.insert_special_char]]>>

<<constant [[Complex.buf_mtime]]>>

<<function [[Complex.update_time]]>>
      

<<function [[Complex.reload]]>>
      
<<function [[Complex.check_file]]>>

let exit_hooks = Store.create_abstr "exit_hook"    

<<function [[Complex.exit_efuns]]>>


<<function [[Complex.goto_line]]>>

<<function [[Complex.goto_char]]>>


<<function [[Complex.get_pos]]>>

<<function [[Misc.cursor_position]]>>


(*****************************************************************************)
(* Toplevel *)
(*****************************************************************************)

<<toplevel [[Simple._1]]>>
  
@

%  (*
%external id : 'a -> 'a = "%identity"
%let add_string_parameter location name param = 
%  add_parameter location name id id param
%let add_int_parameter location name param = 
%  add_parameter location name int_of_string string_of_int param
%let add_float_parameter location name param = 
%  add_parameter location name float_of_string string_of_float param
%let add_bool_parameter location name param = 
%  add_parameter location name bool_of_string string_of_bool param
%    *)
% ????

 
%(*
%     let move_backward frame =
%   Functions.move_backward frame 1; ()
%
%let move_forward frame = 
%  Functions.move_forward frame 1; () 
%*) 




%<<function Simple.modifier_to_string>>=
%(*
%let modifier_to_string mask = 
%  let s = if mask land shiftMask = 0 then "" else "S" in
%  let s = if mask land controlMask = 0 then s else "C" ^ s in
%  let s = if mask land mod1Mask = 0 then s else "M" ^ s in
%  let s = if mask land mod2Mask = 0 then s else "2" ^ s in
%  let s = if mask land mod3Mask = 0 then s else "3" ^ s in
%  let s = if mask land mod4Mask = 0 then s else "4" ^ s in
%  let s = if mask land mod5Mask = 0 then s else "5" ^ s in
%  s
%*)
%@

%<<function Simple.value_to_keysym>>=
%(*
%let value_to_keysym v =
%  match v with
%    Value v -> List.assoc v name_to_keysym
%  | _ -> raise Not_found
%*)
%@

%<<function Simple.keysym_to_value>>=
%(*
%let keysym_to_value k =
%  Value (List.assoc k XK.keysym_to_name)
%*)
%@

%<<function Simple.format_to>>=
%let format_to frame =
%  let (buf, text, point) = Frame.buf_text_point frame in
%  Format.set_formatter_output_functions 
%    (fun str pos len ->
%      let s = String.sub str pos len in
%      Text.insert text point s;
%      Text.fmove text point len)
%  (fun () -> ())
%@
%

%<<function Simple.format_to_string>>=
%let format_to_string () =
%  let string = ref "" in
%  Format.set_formatter_output_functions 
%    (fun str pos len ->
%      let s = String.sub str pos len in
%      string := !string ^ s)
%  (fun () -> ());
%  string
%@



%<<function Simple.current_word>>=
%(*
%let current_word buf point =
%  let text = buf.buf_text in
%  let syntax = buf.buf_syntax_table in
%  let start = dup_point text point in
%  to_begin_of_word text start syntax;
%  let term = dup_point text point in
%  to_end_of_word text term syntax;
%  let word = Text.region text start term in
%  remove_point text start;
%  remove_point text term;
%  word
%*)
%@


%\subsection{[[features/complexe.ml]]}
%pad: used to be complex.ml, but conflict with stdlib,
% but I've now merged it with misc.ml (which was called simple.ml before).
% This file was probably a port of complex.el in Emacs




<<function [[Complex.reload]]>>=
let reload frame = 
  let (buf, text, _) = Frame.buf_text_point frame in
  match buf.buf_filename with
    None -> ()
  | Some file ->
      let inc = open_in file in
      let s = Utils.read_string inc in
      close_in inc;
      let point = frame.frm_point in
      let pos = Text.get_position text point in
      Text.clear buf.buf_text;
      Text.insert_at_end text s;
      Text.set_position text point pos;
      List.iter (fun f -> f buf) buf.buf_major_mode.maj_hooks;
      List.iter (fun minor_mode -> List.iter
          (fun f -> f buf) minor_mode.min_hooks) buf.buf_minor_modes;
      Frame.status_modified frame false 
@





% <<constant [[Complex.display_hist]]>>=
% let display_hist = ref []
% @

% <<function [[Complex.open_display]]>>=
% let open_display frame =
%   select frame "open_display :" display_hist ""
%     (fun _ -> [])
%   (fun s -> s)
%   (fun name -> 
%       let top_window = Window.top frame.frm_window in
%       let location = top_window.top_location in
%       let dpy_oo = new WX_display.t name in
%       let root_oo = new WX_root.t dpy_oo 0 in
%       let display = WX_xterm.create_display root_oo
%           location.loc_colors_names location.loc_fonts_names
%         in
%       Top_window.create location display |> ignore
%    )
% @





%dead:
% <<function [[Complex.mkdir]]>>=
% let mkdir frame =
%   Select.select_filename frame "Make directory: "
%     (fun str -> 
%       let file_perm = try Var.get_var frame.frm_buffer file_perm with _ -> 
%             0x1ff land (lnot umask) in
%       Unix.mkdir str file_perm)
% @
% just use eshell

%dead:
% <<constant [[Complex.umask]]>>=
% let umask = 
%   let old = Unix.umask 0 in 
%   Unix.umask old |> ignore;
%   old
% @

%dead:
%      Keymap.add_interactive edt.edt_map "make_directory" mkdir;

%-------------------------------------------------------------

%<<features/complexe.ml>>=
%<<copyright header2>>
%open Efuns
%  
%@


\section{[[graphics/]]}

\subsection{[[core/top_window.ml]]}


%<<[[Efuns.frame]] other fields>>=
%mutable frm_repeat_action : int;
%@
%% for undo?
%
%<<[[Top_window.try_map()]] set repeat action>>=
%frame.frm_repeat_action <- 
%  if (f == frame.frm_last_action) 
%  then frame.frm_repeat_action + 1
%  else 0;
%@




<<function [[Top_window.mini_message]]>>=
let mini_message frame msg =
  let top_window = Window.top frame.frm_window in
  message top_window msg
@




<<function [[Top_window.wrap]]>>=
let wrap top_window f () = 
  let edt = Globals.editor() in
  Mutex.lock edt.edt_mutex;  
  clean_display ();    
  clear_message top_window;
  keypressed := XK.xk_Menu;
  let frame = top_window.top_active_frame in
  Hook.exec_hooks (try Var.get_global handle_key_start_hook with _ ->[]) frame;
  begin
    try f top_window 
    with e -> message top_window (Printf.sprintf "Uncaught exception %s" 
                                    (Utils.printexn e))
  end;
  Hook.exec_hooks (try Var.get_global handle_key_end_hook with _ -> []) ();    
  update_display ();
  Mutex.unlock edt.edt_mutex
@



<<constant [[Top_window.buffers_menu]]>>=
let buffers_menu = ref 
  (fun (_top_window : top_window) (_button : (*WX_button.t*) unit) ()
  -> ())
@


<<constant [[Top_window.menus]]>>=
(*
let menus = define_option ["menus"] ""
    (list_option (tuple2_option (string_option, list_option string2_option)))
  []
*)
@

<<function [[Top_window.wrap_item]]>>=
(*
let wrap_item top_window (n,f) =
  n, wrap top_window (fun top_window -> f top_window.top_active_frame)
*)
@

%dead:?
% <<constant [[Top_window.check_abort]]>>=
% let check_abort = ref 0
% @
% 
% <<constant [[Top_window.check_abort_delay]]>>=
% let check_abort_delay = ref 100
% @
% 
% <<function [[Top_window.check_abort]]>>=
% let check_abort frame =
%   incr check_abort; 
%   if !check_abort mod !check_abort_delay = 0 then
%     let top_window = Window.top frame.frm_window in
%     let xterm = top_window.top_term in
%     xterm#check_abort
%   else false
% @
%
% <<constant [[Top_window.check_abort]]>>
% <<constant [[Top_window.check_abort_delay]]>>
% 
%   (* This function should be used in loops that could be interrupted by
%   the user. It returns "true" if the user pressed C-g, and false
%   in other cases. *)
%   
% <<function [[Top_window.check_abort]]>>



%-------------------------------------------------------------

<<core/top_window.ml>>=
<<copyright header2>>
open Common
open Options
open Efuns

<<type [[Top_window.t]]>>

<<function [[Top_window.message]]>>

<<function [[Top_window.clear_message]]>>

<<function [[Top_window.try_map]]>>

<<function [[Top_window.set_cursor_on]]>>

<<function [[Top_window.set_cursor_off]]>>

<<function [[Top_window.cursor_on]]>>

<<function [[Top_window.cursor_off]]>>


<<function [[Top_window.update_display]]>>

<<function [[Top_window.clean_display]]>>

<<function [[Top_window.resize_window]]>>

<<function [[Top_window.find_frame]]>>

<<constant [[Top_window.keypressed]]>>
<<constant [[Top_window.mouse_x]]>>
<<constant [[Top_window.mouse_y]]>>

<<function [[Top_window.find_selected_frame]]>>


<<function [[Top_window.mouse_set_active]]>>


<<function [[Top_window.mini_message]]>>

<<constant [[Top_window.handle_key_start_hook]]>>
<<constant [[Top_window.handle_key_end_hook]]>>
  
<<constant [[Top_window.meta]]>>
  
<<function [[Top_window.handle_key]]>>

let in_start_macro = ref false
let in_call_macro = ref false

(* in reverse order *)
let recorded_keys = ref []

let handle_key_and_macro top_window modifiers keysym =
  if !in_start_macro
  then Stack_.push (modifiers, keysym) recorded_keys;

  let before = !in_start_macro in
  handle_key top_window modifiers keysym;
  let after = !in_start_macro in

  if not before && after
  then recorded_keys := [];

  if !in_call_macro
  then begin
   Common.finalize (fun () ->
   !recorded_keys |> List.rev |> List.iter (fun (modifiers, keysym) ->
     handle_key top_window modifiers keysym
   )) (fun () -> in_call_macro := false)
  end

  (* We can receive events from different sources. In particular, some of
  them can be received during the painting (scrollbar ...)
  *)
  
<<function [[Top_window.wrap]]>>

<<function [[Top_window.wrap_item]]>>
        
<<function [[Top_window.handler]]>>


<<constant [[Top_window.buffers_menu]]>>

<<function [[Top_window.scroll_to_frame]]>>


<<constant [[Top_window.menus]]>>
<<constant [[Top_window.file_menu]]>>
<<constant [[Top_window.edit_menu]]>>
<<constant [[Top_window.help_menu]]>>

  
  
<<function [[Top_window.create]]>>

@


\section{[[./]]}

\subsection{[[config/default_config.ml]]}
%pad: was called std_efunsrc.ml before

%old:
% <<toplevel [[Config._1]]>>
%I now put those define_action() in their respective files, or I do not
% even define them if I don't need them from M-x (even though then I miss
% them in the *bindings* buffer; nothing is perfect)
%old:
% <<toplevel [[Config._2]]>>


%-------------------------------------------------------------

<<config/default_config.ml>>=
<<copyright header2>>
open Efuns
module Parameter = Parameter_option

(* pad: this used to be called config.ml, but this conflict with 
 * compiler-libs config.ml file *)

open Keymap (* for the c_xxx *)
<<constant [[standard_map]]>>

<<constant [[core_map]]>>

<<function [[Config.save_options]]>>

open Options
  
<<constant [[Config.global_map]]>>

<<function [[Config.init_global_map]]>>
  
<<toplevel [[Config]] menu settings>>
  

<<toplevel [[Config]] starting hook>>
@

%(*open WX_filesel*)

\subsection{[[main.ml]]}

%let dpy_oo = new WX_display.t !displayname
%let root_oo = new WX_root.t dpy_oo 0
%let display = WX_xterm.create_display root_oo
%  location.loc_colors_names location.loc_fonts_names 
%
%let top_window = Top_window.create location display
%let _ =
%  WX_xterm.setHighlight display 2;
%  Dyneval.init true;
%  Eval.load top_window "Efunsrc";
%  Efuns.init location; (* launch second hooks *)
%  let _ = Interactive.create_bindings location in
%(* open the fisrt buffers *)
%  List.iter (fun name ->
%    let _ = Frame.load_file top_window.window name in ()) 
%  !init_files;
%  List.iter 
%    (fun str -> let top_window = Top_window.create top_window.top_location
%          (Window.display top_window) in
%      let _ = Frame.load_file top_window.window str in ()) !init_frames;
%  Top_window.update_display location;
%
%  
%  if not (Sys.file_exists (Filename.concat Utils.homedir ".efunsrc")) then
%    begin
%      Printf.printf "Saving .efunsrc after install"; print_newline ();
%      Options.save ();
%    end;
%
%  if !check then exit 0;  
%  (* Main loop *)
%  let rec loop () =
%    try
%      WX_types.loop ()
%    with
%      SigInt -> loop ()
%  in
%  loop ()


%-------------------------------------------------------------

% was copyright header2, but better to use header1
<<main.ml>>=
<<copyright header>>
open Options

<<constant [[Efuns.init_files]]>>

<<constants Main options>>
<<constant [[Main.highlight_color]]>>

<<function [[Efuns.init]]>>

<<exception [[Main.SigInt]]>>

<<constants [[Main.xxx_opt]]>>
  
<<constant [[Efuns.usage_str]]>>
  
<<function [[Main.main]]>>

<<toplevel [[Main]] call [[main()]]>>

@






\section{[[major_modes/]]}

\subsection{[[major_modes/dired.ml]]}

<<function [[Dired.update]]>>=
let update buf =
  let filename = match buf.buf_filename with
      None -> failwith "Not a directory"
    | Some filename -> filename in
  let s = Utils.load_directory filename in
  let text = buf.buf_text in
  Text.update text s;
  (* pad extension *)
  Dircolors.colorize_buffer buf;
  buf.buf_last_saved <- Text.version text
@

<<constant [[Dired.file_reg]]>>=
let file_reg = Str.regexp ".* \\([^ ]+\\)$"
@
%$

<<function [[Dired.get_file_line]]>>=
let get_file_line frame =
  frame.frm_buffer.buf_filename |> Option.iter (fun filename ->
    (Globals.editor()).edt_dirname <- Filename.dirname filename;
  );
  let (_, text, point) = Frame.buf_text_point frame in
  Text.with_dup_point text point (fun start_point ->
    let before = Text.point_to_bol text point in
    let after = Text.point_to_eol text point in
    Text.bmove text start_point before;
    let line = Text.sub text start_point (before + after) in
    line
  )
@

<<function [[Dired.select_file]]>>=
let select_file line =
  if line.[0] = ' ' 
  then
    if Str.string_match file_reg line 0 
    then Str.matched_group 1 line 
    else String.sub line 60 (String.length line - 60)
  else
    failwith "Dired: not a file line"
@

<<function [[Dired.dirname]]>>=
let dirname frame =
  match frame.frm_buffer.buf_filename with
    None -> "."
  | Some dirname -> dirname 
@

<<function [[Dired.fullname]]>>=
let fullname frame filename = 
  Filename.concat (dirname frame) filename
@

<<function [[Dired.open_file]]>>=
let open_file frame =
  let filename = fullname frame (select_file (get_file_line frame)) in
  let buf = Ebuffer.read filename (Keymap.create ()) in
  let frame = Frame.create  frame.frm_window None buf in
  Frame.active frame
[@@interactive "dired_open"]
@

<<function [[Dired.remove]]>>=
let remove frame =
  let line = get_file_line frame in   
  let filename = select_file line in
  Select.select_yes_or_no frame (Printf.sprintf "Remove %s ? (y/n)" filename)
    (fun b -> if b then
          if line.[1] = 'd' then Unix.rmdir filename else
          Unix.unlink filename;
        update frame.frm_buffer) |> ignore
[@@interactive "dired_remove"]
@

<<constant [[Dired.view_list]]>>=
let view_list = ref []
@

<<constant [[Dired.old_view_list]]>>=
let old_view_list = ref []
@

<<constant [[Dired.compiled_view_list]]>>=
let compiled_view_list = ref []
@

<<function [[Dired.fast_view]]>>=
let fast_view frame filename =
  if not (!old_view_list == !view_list) then
    begin
      compiled_view_list := List.map 
        (fun (file_reg, appli) ->
          Str.regexp file_reg, appli) !view_list;
      old_view_list := !view_list
    end;
  try
    List.iter (fun (regexp, viewer) ->
        if Str.string_match regexp filename 0 then
          try
            Unix.chdir (dirname frame);
            viewer frame filename;
            raise Exit
          with
            _ -> raise Exit
    ) !compiled_view_list;
    let _ = 
      Select.select_yes_or_no frame (Printf.sprintf "Open %s ? (y/n)" filename)
      (fun b -> if b then
            open_file frame) in
      ()

  with
    Exit -> ()      
@

<<function [[Dired.open_view]]>>=
let open_view frame =
  let filename = select_file (get_file_line frame) in
  fast_view frame filename
[@@interactive "dired_view"]
@

%dead:
% <<constant [[Complex.file_perm]]>>=
% let file_perm = Store.create "file_perm" string_of_int int_of_string
% @
% create_int?

<<function [[Dired.mkdir]]>>=
let mkdir _frame =
  failwith "Dired.mkdir: TODO"
[@@interactive "dired_mkdir"]
(*
  Select.select_filename frame "Make directory: "
    (fun str -> 
      let file_perm = try get_var frame.frm_buffer file_perm with _ -> 
            0x1ff land (lnot umask) in
      Unix.mkdir str file_perm;
      update frame.frm_buffer)
*)
@

<<function [[Dired.install]]>>=
let install buf = 
  match buf.buf_filename with
    None -> 
      failwith "Dired: Not a directory"
  | Some filename ->
      if not (Utils.is_directory filename) then 
        failwith (Printf.sprintf "Dired: %s not a directory" filename);
      update buf
@

<<constant [[Dired.mode]]>>=
let mode = Ebuffer.new_major_mode "Dired" (Some install)
@

<<function [[Dired.viewer]]>>=
let viewer commande _frame filename =
  Sys.command (Printf.sprintf "(%s %s) &" commande filename) |> ignore
@

<<function [[Dired.commande]]>>=
let commande commande _frame filename =
  Sys.command (Printf.sprintf commande filename) |> ignore;
  failwith  (Printf.sprintf commande filename)
@

<<function [[Dired.unzip_and_view]]>>=
let unzip_and_view frame filename =
  let new_filename = Printf.sprintf "/tmp/efuns-view-%s" (
      Filename.chop_extension filename) in
  let res = Sys.command (
      Printf.sprintf "gzip -cd %s > %s" filename new_filename)
  in
  if res = 0 then fast_view frame new_filename
@

<<toplevel [[Dired._1]]>>=
let _ = 
  Keymap.add_major_key mode [NormalMap, XK.xk_Return] open_file;
  Keymap.add_major_key mode [NormalMap, Char.code 'g'] (fun frame -> update frame.frm_buffer);  
  Keymap.add_major_key mode [NormalMap, Char.code 'v'] open_view;  
  Keymap.add_major_key mode [NormalMap, Char.code '+'] mkdir;  
  Keymap.add_major_key mode [NormalMap, Char.code '-'] remove;  

  view_list := [
    ".*\\(\\.jpg\\|\\..gig\\|\\.xpm\\|\\.ppm\\)",viewer "xv";
    ".*\\(\\.ps\\|\\.PS\\)",viewer "gv";
    ".*\\(\\.dvi\\)",viewer "xdvi";
    ".*\\(\\.gz\\|\\.Z\\|\\.z\\)",unzip_and_view; 
    ".*\\.tgz", commande "xterm -e sh -c \"tar zvtf %s | less\"";
    ".*\\.tar", commande "xterm -e sh -c \"tar vtf %s | less\"";
    ".*\\.tar", commande "xterm -e sh -c \"tar vtf %s | less\"";
    ];
  
  Hook.add_start_hook (fun () ->
    Var.add_global Ebuffer.modes_alist [".*/$",mode];
  )   
@
%$

<<function [[Dired.dired_mode]]>>=
let dired_mode =
  Major_modes.enable_major_mode mode
[@@interactive]
@

%old:
%    Keymap.add_interactive ((Globals.editor()).edt_map) "dired_mode" 
%        (fun frame -> 
%          Ebuffer.set_major_mode frame.frm_buffer mode);



%-------------------------------------------------------------

<<major_modes/dired.ml>>=
<<copyright header>>
open Efuns

<<function [[Dired.update]]>>

<<constant [[Dired.file_reg]]>>
  
<<function [[Dired.get_file_line]]>>
    
<<function [[Dired.select_file]]>>

<<function [[Dired.dirname]]>>
      
<<function [[Dired.fullname]]>>
      
<<function [[Dired.open_file]]>>
  
<<function [[Dired.remove]]>>

<<constant [[Dired.view_list]]>>
<<constant [[Dired.old_view_list]]>>
<<constant [[Dired.compiled_view_list]]>>
  
<<function [[Dired.fast_view]]>>
  
<<function [[Dired.open_view]]>>
  
<<function [[Dired.mkdir]]>>
          
<<function [[Dired.install]]>>
      
<<constant [[Dired.mode]]>>

<<function [[Dired.dired_mode]]>>


<<function [[Dired.viewer]]>>

<<function [[Dired.commande]]>>
  
<<function [[Dired.unzip_and_view]]>>
    
<<toplevel [[Dired._1]]>>
@


\section{[[minor_modes/]]}

\subsection{[[minor_modes/minor_mode_sample.ml]]}

%-------------------------------------------------------------

<<minor_modes/minor_mode_sample.ml>>=
<<copyright header2>>
open Efuns
          
<<constant [[Minor_mode_sample.minor_mode_name]]>>

<<function [[Minor_mode_sample.install]]>>

<<function [[Minor_mode_sample.minor_mode_fun]]>>
  
<<constant [[Minor_mode_sample.mode]]>>

<<toplevel [[Minor_mode_sample._1]]>>

<<toplevel [[Minor_mode_sample._2]]>>
    
@


\subsection{[[minor_modes/abbrevs_mode.ml]]}

<<constant [[Abbrevs_mode.abbreviations]]>>=
let abbreviations = define_option ["abbrevs_mode"; "abbrevs"] ""
    (list_option string2_option) []
@

<<constant [[Abbrevs_mode.abbrevs]]>>=
let abbrevs = Hashtbl.create 11
@

<<toplevel [[Abbrevs_mode._1]]>>=
let _ =
  Utils.hash_add_assoc abbrevs !!abbreviations
@

<<function [[Abbrevs_mode.install]]>>=
let install buf =
  try Var.get_local buf abbrev_table |> ignore
  with _ -> Var.set_local buf abbrev_table abbrevs
@

<<constant [[Abbrevs_mode.mode]]>>=
let mode = Ebuffer.new_minor_mode "abbrevs" [install]
@

<<constant [[Abbrevs_mode.abbrevs_chars]]>>=
let abbrevs_chars = define_option ["abbrevs_mode"; "abbrevs_chars"] ""
    string_option " "
@

<<function [[Abbrevs_mode.find_matching]]>>=
let find_matching  frame = 
  Edit.self_insert_command frame; 
  Paren_mode.highlight_paren frame
@

<<function [[Abbrevs_mode.char_expand_abbrev]]>>=
let char_expand_abbrev frame =
  expand_sabbrev frame; Edit.self_insert_command frame
@

<<toplevel [[Abbrevs_mode._2]]>>=
let _ = 
  let chars = !!abbrevs_chars in
  for i = 0 to String.length chars - 1 do
    Keymap.add_binding mode.min_map [NormalMap, Char.code chars.[i]]
      char_expand_abbrev
  done
@

<<toplevel [[Abbrevs_mode._3]]>>=
let _ = 
  Action.define_action "abbrevs_mode" (Minor_modes.toggle_minor mode)
@


%-------------------------------------------------------------

<<minor_modes/abbrevs_mode.ml>>=
<<copyright header2>>
open Options
open Abbrevs
open Efuns

<<constant [[Abbrevs_mode.abbreviations]]>>
  
<<constant [[Abbrevs_mode.abbrevs]]>>
<<toplevel [[Abbrevs_mode._1]]>>
  
<<function [[Abbrevs_mode.install]]>>

<<constant [[Abbrevs_mode.mode]]>>

<<constant [[Abbrevs_mode.abbrevs_chars]]>>
  
<<function [[Abbrevs_mode.find_matching]]>>
<<function [[Abbrevs_mode.char_expand_abbrev]]>>
  
<<toplevel [[Abbrevs_mode._2]]>>

<<toplevel [[Abbrevs_mode._3]]>>

@


\subsection{[[minor_modes/accents_mode.ml]]}

<<function [[Accents_mode.accent]]>>=
let accent frame =
  let key = !keypressed in
  let c = previous_char frame in
  try
    let key = 
      if key = XK.xk_grave then
        match c with
        | 'e' -> XK.xk_egrave
        | 'a' -> XK.xk_agrave
        | 'i' -> XK.xk_igrave 
        | 'o' -> XK.xk_ograve 
        | 'u' -> XK.xk_ugrave
        | 'A' -> XK.xk_Agrave
        | 'E' -> XK.xk_Egrave
        | 'I' -> XK.xk_Igrave
        | 'O' -> XK.xk_Ograve
        | 'U' -> XK.xk_Ugrave 
        | _ -> raise Not_found
      else 
      if key = XK.xk_apostrophe then
        match c with
        | 'e' -> XK.xk_eacute
        | 'E' -> XK.xk_Eacute
        
        | 'a' -> XK.xk_aacute
        | 'i' -> XK.xk_iacute
        | 'o' -> XK.xk_oacute
        | 'u' -> XK.xk_uacute
        | 'A' -> XK.xk_Aacute
        | 'I' -> XK.xk_Iacute
        | 'O' -> XK.xk_Oacute
        | 'U' -> XK.xk_Uacute
        
        | _ -> raise Not_found
      else
      if key = XK.xk_semicolon then
        match c with
          'c' -> XK.xk_ccedilla
        | _ -> raise Not_found
      else
      if key = XK.xk_asciicircum then
        match c with
        | 'e' -> XK.xk_ecircumflex
        | 'a' -> XK.xk_acircumflex 
        | 'i' -> XK.xk_icircumflex
        | 'o' -> XK.xk_ocircumflex
        | 'u' -> XK.xk_ucircumflex
        | 'A' -> XK.xk_Acircumflex
        | 'E' -> XK.xk_Ecircumflex
        | 'I' -> XK.xk_Icircumflex
        | 'O' -> XK.xk_Ocircumflex
        | 'U' -> XK.xk_Ucircumflex 
        | _ -> raise Not_found
      else              
      if key = XK.xk_quotedbl then
        match c with
        | 'e' -> XK.xk_ediaeresis
        | 'a' -> XK.xk_adiaeresis 
        | 'i' -> XK.xk_idiaeresis
        | 'o' -> XK.xk_odiaeresis
        | 'u' -> XK.xk_udiaeresis
        | 'A' -> XK.xk_Adiaeresis
        | 'E' -> XK.xk_Ediaeresis
        | 'I' -> XK.xk_Idiaeresis
        | 'O' -> XK.xk_Odiaeresis
        | 'U' -> XK.xk_Udiaeresis 
        | _ -> raise Not_found
      else              
      if key = XK.xk_asciitilde then
        match c with
        | 'n' -> XK.xk_ntilde
        | 'a' -> XK.xk_atilde
        | 'o' -> XK.xk_otilde
        | 'A' -> XK.xk_Atilde
        | 'N' -> XK.xk_Ntilde
        | 'O' -> XK.xk_Otilde 
        | _ -> raise Not_found
      else              
        raise Not_found
    in
    bmove frame.frm_buffer.buf_text frame.frm_point 1;
    insert_at_place frame (Char.chr key)
  with
    Not_found ->
      try
        let c = Char.code c in
        let c = 
          if key = XK.xk_grave then
            if c = XK.xk_egrave then 'e' else
            if c = XK.xk_agrave then 'a' else
            if c = XK.xk_igrave then 'i' else 
            if c = XK.xk_ograve then 'o' else 
            if c = XK.xk_ugrave then 'u' else
            if c = XK.xk_Agrave then 'A' else
            if c = XK.xk_Egrave then 'E' else
            if c = XK.xk_Igrave then 'I' else
            if c = XK.xk_Ograve then 'O' else
            if c = XK.xk_Ugrave then 'U' else 
              raise Not_found
          else 
          if key = XK.xk_apostrophe then
            if c = XK.xk_eacute then 'e' else
            if c = XK.xk_Eacute then 'E' else
            if c = XK.xk_aacute then 'a' else
            if c = XK.xk_iacute then 'i' else
            if c = XK.xk_oacute then 'o' else
            if c = XK.xk_uacute then 'u' else
            if c = XK.xk_Aacute then 'A' else
            if c = XK.xk_Iacute then 'I' else
            if c = XK.xk_Oacute then 'O' else
            if c = XK.xk_Uacute then 'U' else
              raise Not_found
          else
          if key = XK.xk_semicolon then
            if c = XK.xk_ccedilla then 'c' else
              raise Not_found
          else
          if key = XK.xk_asciicircum then
            if c = XK.xk_ecircumflex then 'e' else
            if c = XK.xk_acircumflex then 'a' else 
            if c = XK.xk_icircumflex then 'i' else
            if c = XK.xk_ocircumflex then 'o' else
            if c = XK.xk_ucircumflex then 'u' else
            if c = XK.xk_Acircumflex then 'A' else
            if c = XK.xk_Ecircumflex then 'E' else
            if c = XK.xk_Icircumflex then 'I' else
            if c = XK.xk_Ocircumflex then 'O' else
            if c = XK.xk_Ucircumflex then 'U' else 
              raise Not_found
          else              
          if key = XK.xk_quotedbl then
            if c = XK.xk_ediaeresis then 'e' else
            if c = XK.xk_adiaeresis then 'a' else 
            if c = XK.xk_idiaeresis then 'i' else
            if c = XK.xk_odiaeresis then 'o' else
            if c = XK.xk_udiaeresis then 'u' else
            if c = XK.xk_Adiaeresis then 'A' else
            if c = XK.xk_Ediaeresis then 'E' else
            if c = XK.xk_Idiaeresis then 'I' else
            if c = XK.xk_Odiaeresis then 'O' else
            if c = XK.xk_Udiaeresis then 'U' else 
              raise Not_found
          else              
          if key = XK.xk_asciitilde then
            if c = XK.xk_ntilde then 'n' else
            if c = XK.xk_atilde then 'a' else
            if c = XK.xk_otilde then 'o' else
            if c = XK.xk_Atilde then 'A' else
            if c = XK.xk_Ntilde then 'N' else
            if c = XK.xk_Otilde then 'O' else 
              raise Not_found
          else              
            raise Not_found
        in
        bmove frame.frm_buffer.buf_text frame.frm_point 1;
        insert_at_place frame c;
        insert_char frame (Char.chr key)
      with
        Not_found ->
          insert_char frame (Char.chr key)
@

<<function [[Accents_mode.install]]>>=
let install buf =
  List.iter (fun key ->
      buf.buf_syntax_table.(key) <- true)
  [ XK.xk_egrave; XK.xk_agrave; XK.xk_igrave; XK.xk_ograve; XK.xk_ugrave;
    XK.xk_Agrave; XK.xk_Egrave; XK.xk_Igrave; XK.xk_Ograve; XK.xk_Ugrave;
    XK.xk_eacute; XK.xk_aacute; XK.xk_iacute; XK.xk_oacute; XK.xk_uacute;
    XK.xk_Aacute; XK.xk_Eacute; XK.xk_Iacute; XK.xk_Oacute; XK.xk_Uacute;
    XK.xk_ccedilla;
    XK.xk_ecircumflex; XK.xk_acircumflex; XK.xk_icircumflex;
    XK.xk_ocircumflex; XK.xk_ucircumflex; XK.xk_Acircumflex;
    XK.xk_Ecircumflex; XK.xk_Icircumflex; XK.xk_Ocircumflex;
    XK.xk_Ucircumflex;
    XK.xk_ediaeresis; XK.xk_adiaeresis; XK.xk_idiaeresis; XK.xk_odiaeresis;
    XK.xk_udiaeresis; XK.xk_Adiaeresis; XK.xk_Ediaeresis; XK.xk_Idiaeresis;
    XK.xk_Odiaeresis; XK.xk_Udiaeresis;
    XK.xk_ntilde; XK.xk_atilde; XK.xk_otilde;
    XK.xk_Atilde; XK.xk_Ntilde; XK.xk_Otilde; ]
@

<<constant [[Accents_mode.mode]]>>=
let mode = Ebuffer.new_minor_mode  "accents" [install]
@

<<toplevel [[Accents_mode._1]]>>=
let _ = 
  List.iter
    (fun key -> 
      Keymap.add_binding mode.min_map [NormalMap, key] accent
  )
  [ XK.xk_apostrophe; XK.xk_grave; XK.xk_semicolon; XK.xk_asciicircum;
    XK.xk_quotedbl; XK.xk_asciitilde]
@

<<toplevel [[Accents_mode._2]]>>=
let _ = 
  define_action "accents_mode" (Minor_modes.toggle_minor mode)
@


%-------------------------------------------------------------

<<minor_modes/accents_mode.ml>>=
<<copyright header2>>
open Simple
open Efuns
open Top_window
  
(* franc;ais strict *)
<<function [[Accents_mode.accent]]>>
          
          
<<function [[Accents_mode.install]]>>
  
<<constant [[Accents_mode.mode]]>>

<<toplevel [[Accents_mode._1]]>>

<<toplevel [[Accents_mode._2]]>>

@


\subsection{[[minor_modes/fill_mode.ml]]}

<<constant [[Fill_mode.minor_mode_name]]>>=
let minor_mode_name = "fill"
@

<<function [[Fill_mode.install]]>>=
let install _buf = ()
@

<<constant [[Fill_mode.fill_line_len]]>>=
let fill_line_len = define_option ["fill_line_len"] "" int_option 80
@

<<constant [[Fill_mode.mode]]>>=
let mode = Ebuffer.new_minor_mode minor_mode_name [install]
@

<<constant [[Fill_mode.fill_on_char]]>>=
let fill_on_char = define_option ["fill_on_char"] "" string_option " "
@

<<toplevel [[Fill_mode._1]]>>=
let _ =
  let fill_on_char = !!fill_on_char in
  for i = 0 to String.length fill_on_char - 1 do 
      Keymap.add_binding mode.min_map [NormalMap, Char.code fill_on_char.[i]] 
        Electric.electric_insert_space
  done
@

<<toplevel [[Fill_mode._2]]>>=
let _ = 
  Action.define_action (minor_mode_name ^ "_mode") 
    (Minor_modes.toggle_minor mode)
@


%-------------------------------------------------------------

<<minor_modes/fill_mode.ml>>=
<<copyright header2>>
open Options
open Efuns
          
<<constant [[Fill_mode.minor_mode_name]]>>
  
<<function [[Fill_mode.install]]>>

<<constant [[Fill_mode.fill_line_len]]>>
  
<<constant [[Fill_mode.mode]]>>

<<constant [[Fill_mode.fill_on_char]]>>
  
<<toplevel [[Fill_mode._1]]>>
  
<<toplevel [[Fill_mode._2]]>>
    
@


\subsection{[[minor_modes/paren_mode.ml]]}



%-------------------------------------------------------------

<<minor_modes/paren_mode.ml>>=
<<copyright header2>>
open Efuns

module H = Highlight

(*****************************************************************************)
(* Prelude *)
(*****************************************************************************)
(* A simple matching-parenthesis highlighter.
 * 
 * This is really useful when editing code, especially Lisp code :)
 * Note that this minor mode highlights not only matching '(' ')' but also
 * matching '{' '}' and '[' ']'.
 *
 * todo:
 *  - highlight also when hover a parenthesis, not just when you type it.
 *  - should not consider parenthesis inside strings or as characters or
 *    in comments (need to have each major mode define those things then)
 * less:
 *  - let each major mode specifies what is a parenthesis?
 *    ('<'? '[|'?, ...)
 *)

(*****************************************************************************)
(* Helpers *)
(*****************************************************************************)

<<constant [[Simple.htmlp]]>>
<<function [[Simple.is_paren_end]]>>
<<function [[Simple.is_paren_begin]]>>

exception Exit
<<function [[Simple.highlight_paren]]>>

<<function [[Paren_mode.find_matching]]>>

(*****************************************************************************)
(* The mode *)
(*****************************************************************************)

<<constant [[Paren_mode.mode]]>>

<<function [[Paren_mode.paren_mode]]>>

(*****************************************************************************)
(* Setup *)
(*****************************************************************************)
  
<<toplevel [[Paren_mode._1]]>>

@


\subsection{[[minor_modes/tab_mode.ml]]}

% what does this do??

<<constant [[Tab_mode.mode]]>>=
let mode = Ebuffer.new_minor_mode "tab" []
@

<<function [[Tab_mode.insert_tab]]>>=
let insert_tab frame = 
  Edit.insert_string frame "\t"
[@@interactive]
@
%old:
%  Action.define_action "insert_tab" insert_tab

<<toplevel [[Tab_mode._1]]>>=
let _ = 
  Keymap.add_binding mode.min_map [NormalMap, XK.xk_Tab] insert_tab
@

<<toplevel [[Tab_mode._2]]>>=
let _ = 
  Action.define_action "tab_mode" (Minor_modes.toggle_minor mode)
@

%-------------------------------------------------------------

<<minor_modes/tab_mode.ml>>=
<<copyright header2>>
open Efuns

<<constant [[Tab_mode.mode]]>>
  
<<function [[Tab_mode.insert_tab]]>>
  
<<toplevel [[Tab_mode._1]]>>

<<toplevel [[Tab_mode._2]]>>
@



\section{[[prog_modes/]]}

\subsection{[[prog_modes/makefile_mode.ml]]}

\subsubsection{Colors}

<<constant [[Makefile_mode.mkfile_vars]]>>=
let mkfile_vars= Str.regexp "\\(\\$([a-zA-Z0-9_]*)\\)\\|\\([a-zA-Z0-9_]+=\\)"
@
%$

<<constant [[Makefile_mode.mkfile_target]]>>=
let mkfile_target= Str.regexp "^.*:"
@

<<constant [[Makefile_mode.mkfile_rules]]>>=
let mkfile_rules= Str.regexp "^\t.*$"
@
%$

<<constant [[Makefile_mode.target_color]]>>=
let target_color = define_option ["makefile_mode"; "target_color"] ""
    string_option "MediumAquamarine"
@
<<constant [[Makefile_mode.rules_color]]>>=
let rules_color = define_option ["makefile_mode";"rules_color"] "" 
  string_option "orange"
@

% font-lock-mode :)
<<function [[Makefile_mode.makefile_color]]>>=
let makefile_color buf =
  Color.color buf mkfile_rules false
    (Text.make_attr (Attr.get_color !!rules_color) 1 0 false);
  Color.color buf mkfile_target false 
    (Text.make_attr (Attr.get_color !!target_color) 1 0 false);
  Color.color buf mkfile_vars false 
    (Text.make_attr (Attr.get_color !!Pl_colors.variable_name_color) 1 0 false);
  Color.color buf mkfile_comments false 
    (Text.make_attr (Attr.get_color !!Pl_colors.comment_color) 1 0 false);
  ()
@

<<function [[Makefile_mode.install]]>>=
let install buf =
  makefile_color buf;
  Action.execute_buffer_action "tab_mode" buf
@
<<constant [[Makefile_mode.mode]]>>=
let mode = Ebuffer.new_major_mode "Makefile" (Some install)
@
% should be install instead no? bug?

\subsubsection{Keys and actions}

% its own configuration!
<<constant [[Makefile_mode.local_map]]>>=
let local_map = define_option ["makefile_mode"; "local_map"] ""
    (list_option Keymap.binding_option) []
@

%old:
% <<constant [[Makefile_mode.interactives_map]]>>=
% let interactives_map = define_option ["makefile_mode"; "interactives_map"] ""
%     (list_option string2_option) 
%   []
% @



<<toplevel [[Makefile_mode._2]]>>=
let _ = 
  Action.define_action "makefile_mode.color_buffer" 
    (fun frame -> makefile_color frame.frm_buffer);
  ()
@
%(*  define_action "insert_tab" insert_tab; *)
% why not use define_buffer_action for color_buffer?

<<toplevel [[Makefile_mode._1]]>>=
let _ =
  if !!local_map = [] then
    local_map =:= [
      [ControlMap, Char.code 'l'], "makefile_mode.color_buffer";
     (*  [NormalMap, XK.xk_Tab], "insert_tab"; *)
    ]
(* TODO
  if !!interactives_map = [] then 
        interactives_map =:= [
          "color_buffer", "makefile_mode.color_buffer";
      ]
*)
@
% meh for interactives, ok shorter name, but meh
%less: forced to do C-l to recolor :(

\subsubsection{Major mode}

<<function [[Makefile_mode.makefile_mode]]>>=
let makefile_mode = 
  Major_modes.enable_major_mode mode
[@@interactive]
@
%old:  Action.define_action "makefile_mode" makefile_mode;



<<toplevel [[Makefile_mode._3]]>>=
let setup_maps () =
  let map = mode.maj_map in
  !!local_map |> List.iter (fun (keys, action) ->
      try
        Keymap.add_binding map keys (Action.execute_action action)
      with e ->
          Log.printf "Error for action %s" action;
          Log.exn "%s\n" e;
  
  );
  ()
@

<<toplevel [[Makefile_mode._4]]>>=
let _ = 
  (* Keymap.add_prefix mode.maj_map [c_c];   *)
  Hook.add_start_hook (fun () ->
    setup_maps();
    Var.add_global Ebuffer.modes_alist [".*/[Mm]akefile.*", mode];
    
    Parameter.add_option_parameter target_color;
    Parameter.add_option_parameter rules_color;
  )   
@


%-------------------------------------------------------------

<<prog_modes/makefile_mode.ml>>=
<<copyright header2>>
open Options
open Efuns
module Parameter = Parameter_option

<<constant [[Makefile_mode.mkfile_vars]]>>
<<constant [[Makefile_mode.mkfile_target]]>>
<<constant [[Makefile_mode.mkfile_rules]]>>

let mkfile_comments= Str.regexp "^#.*$"

<<constant [[Makefile_mode.rules_color]]>>
<<constant [[Makefile_mode.target_color]]>>
<<function [[Makefile_mode.makefile_color]]>>
 
<<function [[Makefile_mode.install]]>>
  
<<constant [[Makefile_mode.mode]]>>
  

<<constant [[Makefile_mode.local_map]]>>

(* let insert_tab frame = ignore (insert_string frame "\t") *)
 
<<toplevel [[Makefile_mode._1]]>>

<<function [[Makefile_mode.makefile_mode]]>>
        
<<toplevel [[Makefile_mode._2]]>>

<<toplevel [[Makefile_mode._3]]>>

  
<<toplevel [[Makefile_mode._4]]>>
@
%$


\subsection{[[prog_modes/ocaml_toplevel.ml]]}

<<function [[Ocaml_toplevel.type_buffer]]>>=
let type_buffer buf =
  let text = buf.buf_text in
  Text.with_new_point text (fun start_point ->
  Text.with_new_point text (fun end_point ->
    set_position text end_point (size text);
    let lexbuf = lexing text start_point end_point in
    let (str, env) = Type.type_buffer buf.buf_name lexbuf !!ocaml_path in
    (str,env)
  ))
@

<<constant [[Ocaml_toplevel.compiled_idents]]>>=
let compiled_idents = Store.create_abstr "compiled_idents"
@

<<function [[Ocaml_toplevel.all_idents]]>>=
let all_idents buf =
  try
    let (ids, version) = Store.get buf.buf_vars compiled_idents in
    if Text.version buf.buf_text = version then ids else raise Not_found
  with
    _ -> 
      let _, (str,env) = Utils.do_and_format type_buffer buf in
      let ids = Type.iter_structure str [] GlobalDefined in
      set_local buf compiled_idents (ids, Text.version buf.buf_text);
      ids      
@

<<function [[Ocaml_toplevel.find_value_type]]>>=
let find_value_type sign names =
  let rec solv sign names =
    match names with
      [] -> raise Not_found
    | name :: names ->
        let rec find sign =
          match sign with
            [] -> raise Not_found
          | sg :: sign ->
              match sg with
                Tsig_value (ident,vd) 
                when Ident.name ident = name ->
                  vd.val_type
              | Tsig_module (ident,Tmty_signature sign ) 
                when Ident.name ident = name ->
                  solv sign names
              | _ -> find sign
        in
        find sign
  in
  solv sign names
@

<<function [[Ocaml_toplevel.print_type]]>>=
let print_type frame = 
  let buf = frame.frm_buffer in
  let point = frame.frm_point in
  let top_window = Window.top frame.frm_window in
  try
    let ids = all_idents buf in
    let text = buf.buf_text in
    let pos = get_position text point in
    List.iter (fun (p,l,t,w) ->
        if l.loc_start-1 <= pos && l.loc_end+1 >= pos then
          Top_window.message top_window 
            (Utils.format_to_string 
              (fun () -> 
                printtyp_path p;
                Format.print_string " : ";
                printtyp_type_expr t
            ) ())
    ) ids
  with
    _ ->
  let name = find_long_word buf point in
  let names = parse_name name in
  let test_name modname names =
    try    
      let ps = Ocaml_env.find_pers_struct !!ocaml_path modname in
      let typ = find_value_type ps.ps_sig names in
      let styp = format_to_string () in
      Format.print_string modname;
      let rec iter list =
        match list with
          [] -> ()
        | name :: tail -> 
            Format.print_string ".";
            Format.print_string name;
            iter tail
      in
      iter names;
      Format.print_string ": ";
      printtyp_type_expr typ;
      Format.print_flush ();
      Top_window.message top_window !styp    
    with
      Env.Error e ->
        let m,s1,s2,s3 =
          match e with    
            Not_an_interface s -> "Not_an_interface",s,"",""
          | Corrupted_interface s -> "Corrupted_interface",s,"",""
          | Illegal_renaming (s1 , s2) ->
              "Illegal_renaming",s1,s2,"" 
          | Inconsistent_import (s1,s2,s3) ->
              "Inconsistent_import",s1,s2,s3
        in
        Top_window.message top_window 
          (Printf.sprintf "Env error: %s %s %s %s" m s1 s2 s3)
  in
  try
    match names with
      modname :: names when modname = String.capitalize modname -> 
        test_name modname names
    | _ -> raise Not_found
  with
    Not_found ->
      let rec iter env =
        match env with
          [] -> failwith "Can not find type"
        | modname :: env ->
            try
              test_name modname names
            with
              Not_found -> iter env
      in
      iter (find_env buf point)
@

<<constant [[Ocaml_toplevel.back_list]]>>=
let back_list = ref []
@

<<function [[Ocaml_toplevel.find_implementation]]>>=
let find_implementation frame =
  let (buf, text, point) = Frame.buf_text_point frame in
  let word = find_long_word buf point in
  let ids = all_idents buf in
  let pos = get_position text point in
  try
    List.iter (fun (pp,l,t,w) ->
        if l.loc_start-1 <= pos && l.loc_end+1 >= pos then
          begin
            List.iter (fun (p,l,t,w) ->
                if p = pp && (w <> Type.Used)then
                  (Text.set_position text frame.frm_point l.loc_start;
                    raise Exit)
            ) ids;  
            match pp with
              Path.Pdot (Path.Pident id,name,pos) when Ident.persistent id ->
              (* Look in another file ... *)
                let ident = Ident.name id in
                let file = ident ^ ".ml" in
                file.[0] <- Char.lowercase file.[0];
                let filename = 
                  try
                    Utils.find_in_path !!ocaml_path file
                  with _ -> failwith (Printf.sprintf "No %s in path" file)
                in 
                let buf = Ebuffer.read filename (Keymap.create ()) in
                let text = buf.buf_text in
                let frame = try
                    Frame.find_buffer_frame buf
                  with Not_found ->
                      Frame.create frame.frm_window None buf
                in
                Frame.active frame;
                let ids = all_idents buf in
                List.iter (fun (p,l,t,w) ->
                    match p with
                      Path.Pident id ->
                        if Ident.name id = name && w = Type.GlobalDefined then
                          (Text.set_position text frame.frm_point l.loc_start;
                            raise Exit)
                    | _ -> ()
                ) ids;
            | _  -> ()
          end
    
    ) ids;
  with
    Exit -> 
      let filename = 
        match buf.buf_filename with
          None -> buf.buf_name
        | Some filename -> filename
      in
      back_list := (filename,Text.get_position text point) :: !back_list
@

<<function [[Ocaml_toplevel.backward_implementation]]>>=
let rec backward_implementation frame =
  match !back_list with
    [] -> failwith "No more buffers in history"
  | (filename, pos) :: tail ->
      back_list := tail;
      let buf = Ebuffer.read filename (Keymap.create ()) in
      let frame = Frame.create frame.frm_window None buf in
      Frame.active frame
@

<<function [[Ocaml_toplevel.mouse_find_implementation]]>>=
let mouse_find_implementation frame =
  let frame = Top_window.mouse_set_active (Window.top frame.frm_window) in
  find_implementation frame
@

<<constant [[Ocaml_toplevel.mode]]>>=
let mode = Ebuffer.new_minor_mode "compiler" []
@

<<constant [[Ocaml_toplevel.local_map]]>>=
let local_map = define_option ["ocaml_compiler_mode"; "local_map"] ""
    (list_option binding_option) []
@

<<toplevel [[Ocaml_toplevel._1]]>>=
let _ = 
  if !!local_map = [] then 
    local_map =:= [
      [c_c; ControlMap, Char.code 'i'] , "ocaml_mode.find_implementation";
      [c_c; ControlMap, XK.xk_BackSpace], "ocaml_mode.backward_implementation";
      [c_c; ControlMap, Char.code 't'], "ocaml_mode.print_type";
    ];
  Keymap.add_binding mode.min_map [ControlMap, XK.xk_Pointer_Button1]
    mouse_find_implementation
@

<<toplevel [[Ocaml_toplevel._2]]>>=
let _ = 
  define_buffer_action "ocaml_compiler_mode" (Minor_modes.toggle_minor mode);
  define_action "ocaml_compiler_mode.find_implementation" find_implementation;
  define_action "ocaml_compiler_mode.backward_implementation" backward_implementation;
  define_action "ocaml_compiler_mode.print_type" print_type;
@


%-------------------------------------------------------------

<<prog_modes/ocaml_toplevel.ml>>=
<<copyright header efuns>>
open Ocaml_mode
open Options
open Text
open Efuns
open Interactive
open Simple
open Select
open Compil
open Eval
open Complex
open Abbrevs  
open Env
open Types
open Keymap
open Window
open Location
open Compat_comp
open Type
open Ocaml_env
(* pad: that's a lots of open ... *)
  
<<function [[Ocaml_toplevel.type_buffer]]>>

<<constant [[Ocaml_toplevel.compiled_idents]]>>

<<function [[Ocaml_toplevel.all_idents]]>>

<<function [[Ocaml_toplevel.find_value_type]]>>
    
<<function [[Ocaml_toplevel.print_type]]>>

<<constant [[Ocaml_toplevel.back_list]]>>
          
<<function [[Ocaml_toplevel.find_implementation]]>>

<<function [[Ocaml_toplevel.backward_implementation]]>>
      
<<function [[Ocaml_toplevel.mouse_find_implementation]]>>
  
  

<<constant [[Ocaml_toplevel.mode]]>>

<<constant [[Ocaml_toplevel.local_map]]>>
<<toplevel [[Ocaml_toplevel._1]]>>

<<toplevel [[Ocaml_toplevel._2]]>>

@

\section{[[ipc/]]}

\subsection{[[ipc/server.ml]]}

<<constant [[Server.efuns_property]]>>=
(*let efuns_property = "_EFUNS_SERVER"  *)
@

%-------------------------------------------------------------

<<ipc/server.ml>>=
<<copyright header>>
open Common
open Unix
open Efuns
  
<<constant [[Server.efuns_property]]>>
<<constant [[Server.user]]>>
<<constant [[Server.socket_name]]>>

<<constant [[Server.started]]>>
  
<<type [[Server.proto]]>>

 
<<function [[Server.read_command]]>>
  
<<function [[Server.module_accept]]>>
  
<<function [[Server.start]]>>

let server_start _frame =
  start ()
[@@interactive]
  
@


\subsection{[[efuns_client.ml]]}

<<constant [[Efuns_client.efuns_property]]>>=
let _efuns_property = "_EFUNS_SERVER"  
@

<<constant [[Efuns_client.root]]>>=
(*let root = display.dpy_roots.(0).scr_root*)
@

<<constant [[Efuns_client.atom]]>>=
(*let atom = X.internAtom display efuns_property false*)
@


%-------------------------------------------------------------

<<efuns_client.ml>>=
  
<<constant [[Efuns_client.pos]]>>
let line = ref 0
<<constant [[Efuns_client.string]]>>
<<constant [[Efuns_client.filename]]>>
  
<<toplevel [[Efuns_client._1]]>>
  
<<constant [[Efuns_client.pos]]([[(client/efuns_client.ml)]])>>
<<constant [[Efuns_client.filename]]([[(client/efuns_client.ml)]])>>
<<constant [[Efuns_client.string]]([[(client/efuns_client.ml)]])>>
    
<<constant [[Efuns_client.filename]] ([[client/efuns_client.ml]])2>>
    
<<constant [[Efuns_client.efuns_property]]>>

<<constant [[Efuns_client.display]]>>
<<constant [[Efuns_client.root]]>>
<<constant [[Efuns_client.atom]]>>
<<constant [[Efuns_client.socket_name]]>>
<<toplevel [[Efuns_client._2]]>>
<<toplevel [[Efuns_client._3]]>>
  
@


\section{[[misc/]]}


\subsection{[[misc/efuns_filebrowser.ml]]}
% in some sense codemap is a more fancy variant of this efuns_filebrowser,
% a special "speedbar"

<<constant [[Efuns_filebrowser.argv]]>>=
let argv = Array.to_list Sys.argv
@

<<constant [[Efuns_filebrowser.regexps]]>>=
let regexps = List.map (fun str -> str, 
      Str.regexp (Utils.glob_to_regexp str)) (
    match argv with
      program :: dirname :: strs -> strs
    | _ -> failwith "Usage: efuns_filebrowser dirname [regexps]")
@

<<constant [[Efuns_filebrowser.dirname]]>>=
let dirname = ref (if Filename.is_relative Sys.argv.(1) then
      Filename.concat (Sys.getcwd ()) Sys.argv.(1) else Sys.argv.(1))
@

<<constant [[Efuns_filebrowser.display]]>>=
let display = new WX_display.t ""
@

<<constant [[Efuns_filebrowser.root]]>>=
let root = new WX_root.t display 0
@

<<constant [[Efuns_filebrowser.top]]>>=
let top = new WX_appli.t root [MinWidth 10; MinHeight 10; MaxHeight (root#height - 200)]
@

<<constant [[Efuns_filebrowser.adx]]>>=
let adx = new WX_adjust.t ()
@

<<constant [[Efuns_filebrowser.ady]]>>=
let ady = new WX_adjust.t ()
@

<<constant [[Efuns_filebrowser.hbar]]>>=
let hbar = new WX_bar.h top#container []
@

<<constant [[Efuns_filebrowser.viewport]]>>=
let viewport = new WX_viewport.t hbar#container adx ady []
@

<<constant [[Efuns_filebrowser.scrollbar]]>>=
let scrollbar = new WX_scrollbar.v hbar#container ady []
@

<<constant [[Efuns_filebrowser.tree]]>>=
let tree = new WX_tree.t viewport#container []
@

<<function [[Efuns_filebrowser.load]]>>=
let load filename =
  Sys.command(Printf.sprintf "efuns_server %s &" filename) |> ignore
@

<<function [[Efuns_filebrowser.iter_load]]>>=
let rec iter_load closed dirname basename container =
  try
    let dirname = Filename.concat dirname basename in
    let filenames = Sort.list (<=) (Utils.list_dir dirname) in
    let subdirs = List.fold_left (fun files filename ->
          if filename <> "." && filename <> ".." then
            let fullname = Filename.concat dirname filename in
            let stats = lstat fullname in
            if stats.st_kind = S_DIR then filename::files else
              files
          else files
      ) [] filenames in
    let file_lists = List.fold_left (fun lists (name,regexp) ->
          let newlist = List.rev (List.fold_left (fun files filename ->
                if Str.string_match regexp filename 0 then filename :: files
                else files
              ) [] filenames) in
          let rec iter pos newlist addlist lists =
            match newlist with
            | ele :: tail -> 
                if pos mod 15 = 0 then
                  iter 1 tail [] (((
                        Printf.sprintf "%s[to %s]" name ele), (ele::addlist)) :: lists)
                else
                  iter (pos+1) tail (ele::addlist) lists
            |   [] -> match addlist with [] -> lists | _ -> 
                    (name,addlist) :: lists
          in
          let newlists = iter 1 newlist [] [] in
          match newlists with
            [] -> lists
          | _ -> (List.rev newlists) @ lists
      ) [] regexps in
    (List.map (fun subdir ->
          let label = new WX_label.t container subdir [] in
          let tree  = new WX_tree.t container [] in
          tree#set_desc (iter_load true dirname subdir tree#container);
          branch true label#contained tree#contained
      ) subdirs) @ (
      List.map (fun (name,files) -> 
          let label = new WX_label.t container name [] in
          let tree  = new WX_tree.t container [] in
          tree#set_desc (List.map (fun filename ->
                let label = new WX_button.with_label tree#container filename 
                  [IpadX 0; IpadY 0] 
                  in
                label#set_action (fun () -> 
                    load (Filename.concat dirname filename));                
                leaf 0 label#contained
            ) (List.rev files));
            branch true label#contained tree#contained         
      ) file_lists
    )
  with
    _ -> []
@

<<constant [[Efuns_filebrowser.file_menu]]>>=
let file_menu = [|
    "Open", (fun _ -> 
        let info = {
            filter = Filename.concat !dirname  "*";
            current_selection= !dirname;
            predicat = (fun _ -> true);
            action = (fun s -> 
                tree#destroy_desc;
                dirname := s;
                tree#set_desc (
                  iter_load false (Filename.dirname s) (Filename.basename s)
                  tree#container));
            cancel = (fun _ -> ());
          }    in
        let filesel = new WX_filesel.t root info [] in
        filesel#show
        );
    "Quit", (fun _ -> exit 0);
  |]
@

<<toplevel [[Efuns_filebrowser._1]]>>=
let _ =
  tree#set_desc (iter_load false (Filename.dirname Sys.argv.(1))
    (Filename.basename Sys.argv.(1))
    tree#container);
  top#container_add hbar#contained;
  hbar#container_add_s [viewport#contained; scrollbar#contained];
  viewport#container_add tree#contained;
  top#setWM_NAME (Printf.sprintf "File Browser: %s" Sys.argv.(1));
  top#add_menu "File" file_menu;
  top#show;
  loop ()
@


%-------------------------------------------------------------

<<misc/efuns_filebrowser.ml>>=
<<copyright header>>
open Xtypes
open WX_types
open WX_tree
open Unix

<<constant [[Efuns_filebrowser.argv]]>>
<<constant [[Efuns_filebrowser.regexps]]>>

<<constant [[Efuns_filebrowser.dirname]]>>
  
<<constant [[Efuns_filebrowser.display]]>>
<<constant [[Efuns_filebrowser.root]]>>
<<constant [[Efuns_filebrowser.top]]>>
<<constant [[Efuns_filebrowser.adx]]>>
<<constant [[Efuns_filebrowser.ady]]>>
<<constant [[Efuns_filebrowser.hbar]]>>
<<constant [[Efuns_filebrowser.viewport]]>>
<<constant [[Efuns_filebrowser.scrollbar]]>>
<<constant [[Efuns_filebrowser.tree]]>>

<<function [[Efuns_filebrowser.load]]>>

<<function [[Efuns_filebrowser.iter_load]]>>

open WX_filesel
  
<<constant [[Efuns_filebrowser.file_menu]]>>
  
<<toplevel [[Efuns_filebrowser._1]]>>
@


\subsection{[[misc/efuns_texbrowser.ml]]}

% outline better?

<<constant [[Efuns_texbrowser.display]]>>=
let display = new WX_display.t ""
@

<<constant [[Efuns_texbrowser.root]]>>=
let root = new WX_root.t display 0
@

<<constant [[Efuns_texbrowser.top]]>>=
let top = new WX_appli.t root [MinWidth 10; MinHeight 10]
@

<<constant [[Efuns_texbrowser.tree]]>>=
let tree = new WX_tree.t top#container []
@

<<constant [[Efuns_texbrowser.regexp]]>>=
let regexp = Str.regexp "\\(\\input\\|\\section\\|\\subsection\\|\\subsubsection\\|\\chapter\\)[*]?{\\([^}]+\\)}"
@

<<function [[Efuns_texbrowser.load]]>>=
let load filename pos all =
  Sys.command (spf "efuns_server %s -pos %d -str \"%s\" &" filename pos all)
   |> ignore
@

<<constant [[Efuns_texbrowser.filename]]>>=
let filename = ref 
  (if Array.length Sys.argv = 2 
   then Sys.argv.(1) 
   else failwith "Usage: efuns_texbrowser filename"
  )
@

<<constant [[Efuns_texbrowser.dirname]]>>=
let dirname = ref (Filename.dirname !filename)
@

<<constant [[Efuns_texbrowser.path]]>>=
let path = ref [ !dirname ]
@

<<function [[Efuns_texbrowser.iter_load]]>>=
let rec iter_load closed filename container =
  let label = new WX_button.with_label container filename [] in
  try
    let filename = try
        Utils.find_in_path !path filename
      with Not_found -> 
          Utils.find_in_path !path (filename^".tex")
    in
    label#set_action (fun () -> load filename 0 "");
    let inc = open_in filename in
    let s = Utils.read_string inc in
    close_in inc;
    let rec iter_search pos list = 
      try
        let newpos = Str.search_forward regexp s pos in
        let keyword = Str.matched_group 1 s in
        let all = Str.matched_group 0 s in
        iter_search (newpos+String.length keyword) (
          (all, keyword,Str.matched_group 2 s,newpos)::list)
      with
        _ -> List.rev list
    in
    let list =  iter_search 0 [] in
    if list = [] then leaf 0 label#contained else
    let tree2 = new WX_tree.t container [] in
    tree2#set_desc (List.map (
        fun (all,keyword,name,pos) -> 
          match keyword with
            "input" -> iter_load true name tree2#container
          | _ ->
              let (offset,prefix) =
                match keyword with
                  "section" -> 0, "s:"
                | "subsection" -> 10, "ss:"
                | "subsubsection" -> 20, "sss:"
                | _ -> 30,""
              in
              leaf offset (
                  let button = new WX_button.with_label tree2#container (
                      prefix^name) [] 
                  in
                  button#set_action (fun () -> load filename pos all);
                  button#contained
                  )
      ) list);
    branch closed label#contained tree2#contained
  with
    _ -> 
      leaf 0 label#contained
@

<<constant [[Efuns_texbrowser.file_menu]]>>=
let file_menu = [|
    "Open", (fun _ -> 
        let info = {
            filter = Filename.concat !dirname  "*.tex";
            current_selection= !dirname;
            predicat = (fun _ -> true);
            action = (fun s -> 
                tree#destroy_desc;
                filename := s;
                dirname := Filename.dirname s;
                top#setWM_NAME (Printf.sprintf "LaTeX Browser: %s" !filename);
                tree#set_desc [iter_load false s tree#container]);
            cancel = (fun _ -> ());
          }    in
        let filesel = new WX_filesel.t root info [] in
        filesel#show              
        );
    "Quit", (fun _ -> exit 0);
  |]
@

<<toplevel [[Efuns_texbrowser._1]]>>=
let _ =
  tree#set_desc [iter_load false Sys.argv.(1) tree#container];
  top#setWM_NAME (Printf.sprintf "LaTeX Browser: %s" !filename);
  top#container_add tree#contained;
  top#add_menu "File" file_menu;
  top#add_button "Reload" (fun _ () ->
      tree#destroy_desc;
      tree#set_desc [iter_load false !filename tree#container];      
  );
  top#add_separator;
  top#show;
  loop ()
@


%-------------------------------------------------------------

<<misc/efuns_texbrowser.ml>>=
<<copyright header>>
open Xtypes
open WX_types
open WX_tree


<<constant [[Efuns_texbrowser.display]]>>
<<constant [[Efuns_texbrowser.root]]>>
<<constant [[Efuns_texbrowser.top]]>>
<<constant [[Efuns_texbrowser.tree]]>>

<<constant [[Efuns_texbrowser.regexp]]>>

<<function [[Efuns_texbrowser.load]]>>

<<constant [[Efuns_texbrowser.filename]]>>
  
<<constant [[Efuns_texbrowser.dirname]]>>
<<constant [[Efuns_texbrowser.path]]>>
  
<<function [[Efuns_texbrowser.iter_load]]>>

open WX_filesel
  
<<constant [[Efuns_texbrowser.file_menu]]>>

<<toplevel [[Efuns_texbrowser._1]]>>
@

\subsection{[[dynamic/eval.ml]]}

<<function [[Eval.try_load]]>>=
let try_load top_window f =
  try
    f (); 
    Efuns.init top_window.top_location
  with
  | Dynlink.Error error ->
      Top_window.message top_window (Dynlink.error_message error)
  | e -> 
      Top_window.message top_window (spf "Exception %s" (Printexc.to_string e))
@

<<function [[Eval.load]]>>=
let load top_window mod_name =
  try_load top_window (fun () -> load_module mod_name)
@

<<function [[Eval.load_library]]>>=
let load_library frame =
  select_lib_filename frame "Load library: " 
    (fun str ->
      let top_window = Window.top frame.frm_window in
      try_load top_window (fun () -> load_file str))
@

<<function [[Eval.eval_buffer]]>>=
let eval_buffer frame =
  let top_window = Window.top frame.frm_window in
  let location = top_window.top_location in
  let (buf, text, _) = Frame.buf_text_point frame in
  let filename = Filename.temp_file "buffer" ".ml" in
  let outc = open_out filename in
  Text.save buf.buf_text outc;
  close_out outc;
  let cmd = "ocamlc -c -I " ^ Version.efuns_lib ^ " " ^ filename in 
  let end_action buf status =
    match status with
      0 -> try_load top_window 
          (fun _ -> 
            let fl =  ((Filename.chop_suffix filename ".ml") ^ ".cmo") 
            in 
            load_file fl;
            Efuns.init top_window.top_location)
    | _ -> 
        set_compilation_buffer frame buf (Filename.dirname filename);
        Top_window.message top_window "Error while compiling buffer"
  in
  System.system "*Eval*" location cmd end_action |> ignore
@


%-------------------------------------------------------------

<<dynamic/eval.ml>>=
<<copyright header2>>
open Efuns
open Text
open Frame
open Simple
open Select
open Search
open Compil

(*
let rec load_module mod_name =
  let filename = (String.uncapitalize mod_name) ^ ".cmo" in
  try
    let filename = Utils.find_in_path !Efuns.load_path filename in
    load_file filename
  with
    Not_found -> failwith ("Can't find file "^filename)

and load_file filename =
  try
    Dynlink.loadfile filename
  with
    Dynlink.Error (Dynlink.Unavailable_unit mod_name) -> 
      load_interface mod_name;
      load_file filename
  | Dynlink.Error (
    Dynlink.Linking_error (_, Dynlink.Undefined_global mod_name)) ->
      load_module mod_name;
      load_file filename

and load_interface mod_name =
  try
    Dynlink.add_interfaces [mod_name] !Efuns.load_path; ()
  with
    Not_found ->
      failwith (Printf.sprintf "No interface for %s" mod_name)
      *)

open Dyneval

<<function [[Eval.try_load]]>>

<<function [[Eval.load]]>>

<<function [[Eval.load_library]]>>

  
<<function [[Eval.eval_buffer]]>>
@
