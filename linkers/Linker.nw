\documentclass[twocolumn, landscape]{report}

%******************************************************************************
% Prelude
%******************************************************************************
\newif\iffinal
\newif\ifverbose
\finaltrue\verbosefalse % see also other newif in Macros.tex

%------------------------------------------------------------------------------
%history:
%------------------------------------------------------------------------------

%thx to LP, changed for the better a few things:
% - introduced Headtype enum instead of hardcoded integers
% - introduced mylog() and DBG() to factorize the tracing code
% - removed many portable myxxx() wrappers
% - removed some deadcode (C_LBRA, C_LECON, C_SCON, D_OCONST, regused)
% - commented lots of code that was in dead ifdefs or was related to
%   dead alef features like BECOME
% - TODO reorganized the code to better match the chapters
%   by introducing more files: main.c, lib.c, error.c, m.h
% - reorganized code around INITENTRY, -l, -E digit, make default path
%   more obvious

%thx to codemap/codegraph:
% - see subtle dependency to 8c/enam.c through anames

%thx to this manual, better understand linking:
% - that an object is really a module, the simplest/lowest module abstraction
%   with defs and uses to link together (for text and data).
% - that linker and loader are related by executable format and sections;
%   one generates data (the executable) that the other reads (the kernel)
% - disk image of executable and memory image of program are different
%   hence the -TText
% - SEMI mutual dependency between dotext and dodata where need layout
%   data before text but then need text before know where starts data
%   (solved via SB/R12 for 5l)
% - TODO what if have multiple object defining the same global?
%   int x; int x; in different files? what if one also define value?
%   what if both define value? DUPOK?
% - TODO stuff about pool and in general many small mismatches between Asm5
%   and actual ARM capacities
% - TODO dynamic linking? export table? import table?
% - TODO fpic? 

%history LP-ization:
% - skeleton, mostly copy paste of Template.nw skeleton
% - put all content of files in the Extra section, via 'pfff -lpize'
%   which also now split in chunks!
%    * function, global, struct, enum, constant, macro(actually function)
%    * extra, other fields split
% - read Extra section, identify concepts, first TOC
% - distribute parts of the file before
% - understand main(), LP split main, improve TOC
% - understand main functions, LP split, cluster, improve TOC
% - LP split the structures, use datalog for flow to field info
% - SEMI nullify, boolify, typeify,    scheckify
% - aspectify advanced features!
% - SEMI add figures
% - SEMI add explanations

%------------------------------------------------------------------------------
% Packages
%------------------------------------------------------------------------------

\usepackage{../docs/latex/noweb}
 \noweboptions{footnotesizecode,nomargintag}
 %note: allow chunk on different pages, less white space at bottom of pages
 \def\nwendcode{\endtrivlist \endgroup}
 \let\nwdocspar=\par
\usepackage{xspace}
\usepackage{verbatim}
%note: required by noweblatexpad for the \t \l \n in this file
\usepackage{fancyvrb}
\usepackage{url}
\usepackage{hyperref}
 \hypersetup{colorlinks=true}
\usepackage[pageref]{backref}
 \def\backref{{\footnotesize cited page(s)}~}
\usepackage{booktabs} 
 \newcommand{\otoprule}{\midrule[\heavyrulewidth]}
\usepackage{graphicx}

%------------------------------------------------------------------------------
% Macros
%------------------------------------------------------------------------------
\input{../docs/latex/Macros}

%------------------------------------------------------------------------------
% Config
%------------------------------------------------------------------------------
\allcodefalse
% ifallcode is used for:
%  - forward decl, func decl, extern decl, #ifdef, pragmas (stuff in Extra.nw)
%  - STILL? boilerplate error managment ?? sanity check?

%\setcounter{tocdepth}{1}

\addtolength{\topmargin}{-.850in}
\addtolength{\textheight}{1.70in}

\begin{document}
%******************************************************************************
% Title
%******************************************************************************
\title{
{\Huge 
Principia Softwarica: The ARM Linker [[5l]]
}\\
{version 0.1}
}

\author{
Yoann Padioleau\\
\texttt{yoann.padioleau@gmail.com}\\
\\
with code from\\
Rob Pike
}

\maketitle 
%alt: 8l, x86 (32 bits) edition
\l ARMv6 (32 bits) edition\\
\l Rob pike really author also of linker?


\onecolumn
\hrule
\input{../docs/latex/Copyright}
\input{../docs/latex/CopyrightPlan9}
\hrule
\twocolumn

\begingroup
\hypersetup{linkcolor=blue}
% need to s/onecolumn/twocolumn in report.cls :) for \tableofcontents
\tableofcontents
\endgroup

%******************************************************************************
% Body
%******************************************************************************

\chapter{Introduction}

The goal of this book is to present with full details the source code of
a {linker}.

\section{Motivations}

Why a linker? Because we think you are a better programmer if 
you fully understand how things work under the hood, and
the linker is the final piece of any {development toolchain},
the one generating finally the {executable}.
\l often get errors from linker. never explained, maybe boring but important!

There are very few books about linkers,
\n the linker/loader book is mentioned later
as opposed to a myriad of books on compilers or kernels. 
Linkers are usually not even studied during the computer science curriculum. 
This is a pity because they are pretty central.
Indeed, they make the link (no pun intended) between the compiler
and the kernel: the linker generates from {object files} {executables} 
that the kernel will {load}. Without a linker there is no program to execute.
\l linker/loader relation
\l Many blog posts, show interest from people

Here are a few questions we hope this book will answer:
\begin{itemize}
\item What is the format of object files?
What is the format of libraries?

\item What is the format of executables?
What is the format of machine instructions?

\item What is the difference between the ELF and [[a.out]] formats?

\item How object files and libraries get combined and patched together
to form the final executable?

\item What is the difference between a linker and a loader?

\item How source code get linked and finally loaded in memory? 
What is the memory image of a program? 
How it relates to the original source code?

\item What debugging information contains executables? How
source-level debuggers find which C source code corresponds 
to a specific binary instruction?

\end{itemize}
\l what is position independent code? 
\l how dynamic linking works? 
\l endianess? see the inuxi stuff?

%tags used in this file for different recurring themes:
%assembler: relates code in the linker to similar (or absent) code in 5a
%emulator: relates code in the linker to similar (or absent) code in 5i
%sanity: I use "sanity check" in chunknames, to aspectize a bit error checking

\section{The \plan ARM linker, [[5l]]}

We will explain in this book the code of the \plan ARM linker
[[5l]]\footnote{\url{http://plan9.bell-labs.com/magic/man2html/1/8l},
which despite its name covers also [[5l]]}
which is about 7900 lines of code (LOC).
\n make loc, counting only 5l, not ar.c, size.c, etc
\t say appendix also code of ar and say LOC too?
[[5l]] is written entirely in C\footnote{
An OCaml partial port is also shown in Appendix~\ref{chap:5l-ocaml}
}.
%
%dup: (and adapted) from Assembler.nw
Like for most books in \principia, we chose a \plan software because
they are simple, small, elegant, open source, and they form together
a coherent set of software.
The [[5]] comes from the \plan convention to name architecture
with a number or single letter (0 is MIPS, 5 is ARM, 8 is x86, etc),
and the [[l]] means linker.

%dup: (and adapted) from Assembler.nw
Like for the other \principia books covering the
{development toolchain}, we chose the ARM architecture~\cite{arm-refman}
variant, in this case of the \plan linker ([[5l]]),
and not for instance the x86 variant ([[8l]]), for
reasons of simplicity. Indeed RISC machines
are far simpler than CISC machines. Moreover, the availability
under \plan of an ARM emulator, [[5i]], helps to understand
the semantics of the machine instructions generated by [[5l]].

The \plan approach to linking is a bit different than in other
operating systems. The linker is responsible
for generating executables, but also for generating the machine code 
from the object files in \plan. Indeed, the object files generated
by [[5a]] and [[5c]] 
%dup: (and adapted) from Assembler.nw
are ARM-specific, but they do not contain machine code. 
Instead an object file is essentially the {serialized form} of the 
{abstract syntax tree} of an assembly source.
%
The linker [[5l]] generates the actual machine code.
We think though that it is actually a better design because it leads to
less code in total and also to simpler code.
\t why? because anyway linker need deep knowledge of machine code format
\l  because need patch it here and there, so why not put everything in it
\l  so assembler then is simpler 
\t Better for opti too. Things can be done only when know actual size, such as
\l  length of offset. Compiler has not the knowledge for that.
\n probably cos there was only 5c/5l before and responsabilities were shifted
%
The \plan linker does also some deadcode elimination
\l well just for libraries, and it is not really dead code
\l and apparently it's pretty common for a linker to do that
\l also instruction selection? more opti?
\l inter-lib linking-time optimisations!?
which reduces the size of the binaries. 
This is partly to compensate for the lack of
shared libraries in \plan.
\l but shared libraries are evil! dynamic shared libraries?
\l Also there is no dynamic linking by default. Simpler approach again.

\n critique of go/plan9 toolchain,
%  -  http://dtrace.org/blogs/wesolows/2014/12/29/golang-is-trash/

\section{Other linkers}

Here are a few linkers that were considered for this book but
which were ultimately discarded:
\begin{itemize}

\item The GNU Linker [[ld]], part of the [[binutils]] package,
is probably the most used open source linker.
It is using the Binary File Descriptor library (BFD)
to read and write object files using different formats.
It supports many architectures (ARM, x86, etc)
as well as many executable and object file formats (ELF, [[a.out]], etc).
\l also dynamic libraries, ELF
\n BFD =~ libmach
It is fairly big though: 30K LOC for [[ld/]]
and 500K LOC for [[bfd/]].
Even the ARM-specific file [[bfd/elf32-arm.c]] has already 17 000 LOC.

\item Gold is a faster multi-threaded ELF linker originally developed at Google,
which is now part of the [[binutils]] package.
It supports also many architectures (ARM, x86, etc).
\l not using BFD?
It is unfortunately also fairly big: 153K LOC.
Again, even the ARM-specific file [[gold/arm.cc]] has already 13 000 LOC.
\n cplusplus
\l show that useful to see how linker works! cf FB, so much time lost in ld
\l and engineer didnt even think to rewrite ot, was deemed impossible to do
\l barriers!

\item The LLVM Linker [[lld]] aims to remove the current dependency to
the host linker (e.g. [[ld]] under Linux) in the LLVM infrastructure.
Its goal is also to be more modular and extensible than [[ld]].
It supports also many architectures and executable formats.
\n (ARM, x86, etc) (ELF, COFF, etc).
It is smaller than [[ld]] and Gold but still fairly large: 71K LOC.
\n cplusplus

%dup: (and adapted) from Assembler.nw
\item LD86, an x86 16-bit and 32-bit linker, part of
Bruce Evans' C compiler (BCC), is an historical linker
used to compile old versions of Minix and Linux.
\l sure?
%
It is fairly small: 6100 LOC, which is smaller than [[5l]].
But, to be fair, [[5l]] does also machine code generation
which is done instead by AS86 for LD86. [[5a]]+[[5l]] is 12 000 LOC
which is smaller than AS86+LD86 at 18 600 LOC.

\end{itemize}

\l a few other linkers, see the comment in the .tex
%industry:
% - optlink, digital mars, very fast, written in assembly though
%other:
% - http://www.compilers.de/vlink.html, part of vbcc and vasm
%   by Frank Wille, 25 000 LOC but many formats, but not completly OSS I think
%mini:
% - https://github.com/trillek-team/computer-toolkit (for space game)
%   a toy asm, linker, and even a toy C compiler, for TR3200 machine
%education:
%  - subc-2014, sld, 700LOC?
%modern:
%  - lld seems to do advanced opti or going towards advanced opti with notion
%    of Atoms vs Section (see lld/docs/design.rst)

\section{Getting started}
\label{sec:getting-started}

%dup: (and adapted) from Assembler.nw
To play with [[5l]] you will first need to install
the \plan fork used in \principia. See \urlinstall.
Once installed, you can test [[5l]] under \plan with:

\begin{verbatim}
1   $ cd /tests/5l
2   $ 5a hello.s && 5a world.s
3   $ 5l hello.5 world.5 -o hello
4   $ ./hello
5   hello world
6   $
\end{verbatim}
\n minimal example here! no libc.a, just to make sure the minimal stuff works

The command in Line 2 {assembles} the simple [[hello.s]]
and [[world.s]] ARM assembly programs and generates the 
[[hello.5]] and [[world.5]] ARM {object files}.
\l define object file? .5? explained later.
Line 3 then {links} the object files together and generates the final 
ARM binary executable [[hello]].
Line 4, which assumes you are under an ARM machine (e.g. a Raspberry Pi)
{launchs} the program.

Note that it is easy under \plan to {cross compile} from another architecture:
you can use the same commands, [[5a]], [[5l]], etc.
\l because magic /bin, and also because special 5 convention
To play with [[5l]] under an x86 machine you just need
after the linking step to use the ARM emulator [[5i]] instead:

\begin{verbatim}
...
4   $ 5i hello
...
\end{verbatim}

See the \book{Emulator} for more information on [[5i]].
\l actually cool cos can be used as an assembly debugger too


\section{Requirements}

%dup: from Assembler.nw
Because most of this book is made of C source code, 
you will need to have a good knowledge of 
the C programming language~\cite{k-r} to understand it.
%
In fact, for Chapter~\ref{chap:arm-codegen} where we will
see the code which generates machine instructions, 
you will need a very good knowledge of C.
Indeed the code does lots of bit manipulations and uses many C idioms.

There are very few books explaining how a linker works.
We can cite {\em Linkers and Loaders}~\cite{ll}
and one of the chapter of 
{\em Computer Systems: A Programmer's Perspective}~\cite{cs-bryant}.
Thus, we assume most programmers do not know really how a linker works,
which is why, in addition to explaining the code of [[5l]],
we will also explain most of the concepts related to linking
in this book. This is a bit unusual in our \principia serie.
Indeed, we usually assume the reader has read books introducing at least
the concepts and theories underlying the software we present.

Reading the \book{Assembler} is a requirement to understand
this book. Indeed, many data structures introduced
and fully explained in the \book{Assembler} are similar
to data structures used by [[5l]]. This is normal since
the assembler generates what the linker consumes.
Those data structures will be only quickly presented in this book.
The same is true for the object file format which is described at length
in the \book{Assembler}.

%dup: from Machine.nw
It is not necessary to know the ARM architecture to understand 
most of this book. 
%nodup: start deviation
For the machine code generation part though, in Chapter~\ref{chap:arm-codegen},
we highly recommend to print the excellent one page
colorful ARM reference guide
\url{http://re-eject.gbadev.org/files/armref.pdf}.
It will help you to visually understand the binary format of the
instructions. This guide is very helpful
to understand the code doing bit manipulations to generate
different parts of the machine instruction.
%we recommend to read the \book{Emulator} to fully understand
%the semantics of some instructions.

\section{About this document}
#include "../docs/latex/About.nw"

\section{Copyright}

Most of this document is actually source code from Plan9, so
those parts are copyright by Lucent Technologies Inc.
The prose is mine and is licensed under the \license.

\section{Acknowledgments}

We would like to acknowledge of course the author of
[[5l]], Rob Pike, 
who wrote in some sense most of this book.
\t really Pike?







\chapter{Overview}

%trans:
Before showing the source code of [[5l]] in the following chapters, 
%toc:
we first give an overview in this chapter
of the general principles of a linker.
We also describe quickly the format of the object files 
generated by [[5a]] and [[5c]] 
and used as inputs by [[5l]], as
well as the format of the executables generated by [[5l]].
%dup: from Assembler.nw
We also define terms, explain how the code is organized, 
and more generally give the background necessary
to understand the code we will show later.

\section{Linker principles}

\n what
A {\em linker} is a program which takes as input multiple
{object files} and {combine} them to form an {executable}
as shown in Figure~\ref{fig:linker-overview}.
\n combine will be explained later

\begin{figure}[!]\centering
\begin{verbatim}
         +-----------+
         | assembler |
foo.s -->|   (5a)    |--> foo.5 --+
         +-----------+            |   +-----------+
                                  |   |  linker   |
         +-----------+            +-->|   (5l)    |--> 5.out
         | compiler  |            |   +-----------+
bar.c -->|   (5c)    |--> bar.5 --+
         +-----------+

Source files           Object files               Executable
\end{verbatim}
\caption{Linker inputs and output}\label{fig:linker-overview}
\end{figure}


%dup: from Assembler.nw principles
An {\em object file} is really the simplest form of
a {\em module}. It packs code, data, and information
about {exported} and {imported} entities.
Object files are generated by {assemblers} and {compilers}.

An {\em executable} is a file containing machine instructions
as well as data. The code and data are stored in different
parts of the file called {\em sections} as shown in 
Figure~\ref{fig:linker-process}.
The size and location
of those sections are stored at the beginning of the file
in a part called the {\em header}. 
%
There are different kinds of headers
corresponding to different kinds of {\em executable formats}. In this
book we will focus on the [[a.out]] format which is very simple.
Section~\ref{sec:other-executable-formats} will present other
formats (including the popular ELF format used in Linux).

Thanks to the header, a part of the kernel called the {\em loader}
can know where the code and data are stored in the executable
file as well as its entry point. The loader, 
triggered by the [[exec()]] system call,
can then load (copy) in memory the different sections of 
the executable file and start executing its code.
\l actually man/1/8l uses term loader for 5l itself, hmm

\n how
Figure~\ref{fig:linker-process} gives an overview of the linking
process.
%
The linker first {\em concatenates} the code parts of the 
different object files together 
to form the {\em code section} (the code parts [[C1]] to [[C4]]),
also known as the {\em text section}.
\n for 5l it actually transform them too, in machine instruction
It does the same for the data 
to form the {\em data section} ([[D1]] and [[D2]]).
\n for 5l this is the same
%
Then, it links the {\em uses} of {symbols} in those code (or data) parts,
e.g. the call to [[fbar]] in [[C1]],
to their {\em definitions} in possibly other code (or data) parts,
here the definition of [[fbar]] in [[C2]].

\l alt: multics segmentation? where each object can be in own space?

\begin{figure}[!]\centering
\begin{verbatim}
  lib.a------------+
  |                |
  |y.5------------+|
  |+--------------+|
  ||      D3      ||
  |+--------------+|                      +------------+
  ||      C5      ||                      |            |
  |+--------------+|--+                   |  Metadata  |
  |x.5------------+|  |                   |            |
  |+--------------+|  |                   X------------+260
  ||      C4      ||  |                  /|     D2     |
  ||TEXT util     ||  |     Data section| +------------+240
  |+--------------+|  |                  \|     D1     |
  +----------------+  |                   X------------+220
                      |                  /|     C4     |
   bar.5----------+   |   +-----------+ / |            |
   +--------------+   |   |  linker   | | +------------+200
   |      C3      |   +-->|    (5l)   |-+>|     C3     |
   |... CALL util |   |   +-----------+ | |.. CALL 200 |
   +--------------+   |                 | +------------+150
   |      D2      |---+                 / |     C2     |
   +--------------+   |    Code section|  |            |
   |      C2      |   |                 \ +------------+100
   |TEXT fbar     |   |                 | |.. CALL 100 |
   +--------------+   |                 \ |     C1     |
                      |                  \|... JMP 62  |
   foo.5----------+   |                   X------------+32
   +--------------+   |                   |   header   |
   |      D1      |   |                   |  (a.out)   |
   +--------------+   |                   +------------+0
   |... CALL fbar |---+
   |      C1      |
   |... JMP 30    |
   +--------------+

Input object files and                  Output executable
       library
\end{verbatim}
\caption{Linking process overview}\label{fig:linker-process}
\end{figure}
\l actually in ARM it is BL not CALL and B not JMP

\subsection{Symbol resolution}
\n I didn't have subsections in Assembler.nw for its principles but I had a
\n tutorial later with many subsections. Here no tut so subsec in Principles.

Linking the uses of symbols to their definitions
is also called {\em resolving} the references to external symbols.
\l well external and internal too actually
%
The linker can do so because it has access to all the code (and data), and
once all the code (and data) parts are contatenated together, 
the final {addresses} of the different {entities} can be known. 
\l actually can need fixpoing on some archi, hmm
\l actually dynamic linking mean sometimes have still unresolved symbols
So, in Figure~\ref{fig:linker-process} the call to [[fbar]] in [[C1]]
can be transformed in a machine instruction to go to the
address 100 where the code of [[fbar]] resides (assuming [[fbar]]
was the first procedure in [[bar.5]] and so [[C2]]).
\n will see below that actually not 100 but 4196

\subsection{Relocation}

Another important operation done by the linker is called {\em relocation}.
%
Remember from the \book{Assembler} that [[5a]] can resolve
the use of {labels} in jump instructions as both the definitions and uses of
those labels must be in the same file. The instructions generated
for those jumps {assume} though that the code of the program was
loaded at the (virtual) memory address 0. 
\l for the rest of the doc when I say memory address I mean virtual mem address
\l unless relative jump, but ARM can't do that
\l alt: mutlics segmentation? or PIC.
For instance, to jump to
a label [[foo]] which happens to be defined just before the 30th instruction 
in a program [[foo.s]], 
the instruction [[JMP 30]] will be generated in the object file
\l because 5a use virtual PC
as shown in Figure~\ref{fig:linker-process} in [[foo.5]].
%
Once the code of object files are concatenated together and put
after the header, the linker must {\em relocate} 
the jump instructions
\l unless position independent code in which case no need relocation
to take into account the new {\em memory address origin}
where the object code containing the jump will be loaded.
For our previous example, the linker generated
the relocated instruction [[JMP 62]] in 
Figure~\ref{fig:linker-process} as [[C1]] is after the executable
header which uses 32 bytes.
\n will see below that acutally not 62 but
\l again can have fixpoint issue, and relaxation hints (cf wikipedia linker)

\subsection{Disk image versus memory image}
\l linker versus loader

Linkers and loaders are strongly connected, just like assemblers and linkers.
Indeed, one produces what the other consumes.
In fact, early linkers were also called loaders as they
were responsible for linking and loading in memory a program.
\l really? read levine book introduction.
\l also linkage editor, etc.
\l actually man/1/8l use the term loader, hmmm I think they are confused
It is important to note though, that
the {\em disk image} of an executable generated by the linker
does not necessarily matches exactly the {\em memory image}
of the program when loaded in memory by the loader.
An offset in the file does not necessarily correspond to an
offset in memory even though we assumed this was the case
in Figure~\ref{fig:linker-process}.

Under \plan, the header and code section are actually not loaded
at the memory address 0 but instead after
the first {page} at 4096 (4K). Indeed, the first page
in the virtual address space of a program
is reserved by the kernel and marked specially to generate
{faults} when accessed. This helps for instance to
track {null pointer bugs}.
%
So, the instructions [[CALL fbar]] and [[JMP 30]]
in Figure~\ref{fig:linker-process}
would be actually transformed respectively
in the resolved [[CALL 4196]] and relocated [[JMP 4158]] 
instructions with [[5l]] under \plan.
\l say that could actually remove header when loaded in mem and so CALL 4164
\t notion of Text origin? actually header is 4096
\t notion of disk address vs (virtual) memory address

\subsection{Libraries}

One of the main operation of a linker is to concatenate parts
of different files. 
\l actually in 5l less because generate also machine code
In fact, the program [[cat]] can be seen as a very primitive linker.
Instead of using a linker, one could use [[cat]] to concatenate
multiple source programs together and compile/assemble the resulting single
(big) file\footnote{
Assuming the compiler/assembler could from one source file
generate directly an executable.}.
\l see bootstrapping from scratch, I mentioned that
\l MMIXAL actually neglect linker and assume linker = cat :) Same for fbas. 
\l Now that memory is cheap, can do it
%
As programs grow larger, this approach becomes inconvenient though.

Linkers and object files enable {\em separate compilation}
which in the long term saves lots of compilation time.
\l well for 5l/5a maybe less cos heavy part is machine codegen done in 5l
\l other advantages? more language independent? cat foo.c foo.ml would not work
\l but could also use assembly as the common format, cat foo_c.s foo_ml.s
%
Those object files can actually be concatenated together to form
{\em libraries} using a tool called [[ar]] (for archive).
\l which really is kinda cat, and also really kinda tar (tape archive)
The linker can also take as input a set of libraries as shown
in Figure~\ref{fig:linker-process} with [[lib.a]].
%
Those libraries are convenient for the programmer because one
just has to remember the name of one file, e.g. [[libc.a]], instead
of a possible long list of object files.
\l other advantages?

Moreover, the linker can also take care of including only
the object files in the library that matters, that is the object files
containing code or data referenced by the other object files
passed on the command line.
For instance, in Figure~\ref{fig:linker-process} the linker
decided to include in the executable the code of [[x.5]] ([[C4]]), which
is part of [[lib.a]], 
because it contains the definition of a procedure [[util()]] which
is mentioned in the object file [[bar.5]]. 
\l well need fixpoint though, need take care
It did not include the code from [[y.5]] though because such code 
would be anyway {\em dead code} in the executable. 
Such code would waste disk and memory space.
\l well lazy code loading so maybe ok
\l other optimisations? fine grained dead code?

\subsection{Static and dynamic linking}

The linking we described until now is completely {\em static}.
All the symbol references must be known at {\em link-time}
in which case they can be fully resolved to generate an executable.
This requires that all the object files (or libraries)
containing those symbols get passed to the linker on the command line.

Another popular form of linking is called {\em dynamic linking}.
\l actually more popular, but bad
Dynamic linking blurs the line between the responsabilities 
of the linker and loader.
Indeed, with dynamic linking, an executable can still contain
unresolved references to symbols; the loader
at {\em load-time} must, before loading the program in memory,
link additional objects.
\t related to dynlink? can link after being loaded. load after being linked?

\plan opted mainly for static linking and so [[5l]] is mainly
\l mainly is vague, ADYN enough for dynamic linking?
a static linker. 
Static linking is far simpler than dynamic linking and is arguably 
also better in many respects.
\l refs? static linking reloated? dll hell
We will delay the discussions on dynamic linking to 
Section~\ref{sec:dynamic-linking}.
\l can separate. Loader is in kernel.
\l Linker setups things for loader, code section, data section, etc
\l and loader is pretty simple, just load/copy (or actually lazy load/copy).
\l Also compute textsize, datasize, etc and adjust addresses.

\t talk now about issue with mutual reference of SB?

\t dynamic linking and shared libraries are different? I think so.

For more information on linkers and loaders we 
recommend to read {\em Linkers and Loaders}~\cite{ll} which
is entired dedicated to the topic.
\l many post on linkers or executables, show it is a missing part of curriculum:
% - http://eli.thegreenplace.net/2012/08/13/how-statically-linked-programs-run-on-linux/
% - http://dbp-consulting.com/tutorials/debugging/linuxProgramStartup.html
% - http://www.lurklurk.org/linkers/linkers.html
% - ian taylor posts http://www.airs.com/blog/archives/38
%   TOC here: http://lwn.net/Articles/276782/
% - https://github.com/0xAX/linux-insides/blob/master/Misc/linkers.md
%   and http://0xax.gitbooks.io/linux-insides/content/Misc/linkers.html
%   pretty good use of nm, objdump, readelf, etc

%\subsection{Summary}
\l put back essential steps? read object and lib, concatenate, 
%   resolve and relocate, and finally generate. but explained in soft archi?

\l which rougly correspond to different chapters

\section{[[5l]] command line interface}

The command line interface of [[5l]] is pretty simple:
\begin{verbatim}
$ 5l
usage: 5l [-options] objects
$ 5l foo.5 bar.5 lib.a
$ ./5.out
\end{verbatim}

Given the set of {object files} [[foo.5]] and [[bar.5]],
and a {library} [[lib.a]], 
[[5l]] outputs an executable file called [[5.out]].
\n look for _main. But explained later.
%
One can change this default behaviour by using the [[-o <outfile>]] option.

The default {executable format} is [[a.out]], a classic \unix format,
but this can be changed with the [[-H<num>]] option ([[H]] for header)
as explained in Section~\ref{sec:choice-exec-format}.
\l see adv topic for more e.g. ELF.
One can also change the entry point of the program with [[-E<funcname>]] 
which by default is [[_main]] 
as explained in Section~\ref{sec:choice-entry-point}.
\l also have -l which suppress entry point?
Other options related to debugging will be described later
in Appendix~\ref{chap:debugging-appendix}.
\n actually next section introduces a few

%real-world:
Executables generated by C compilers in \unix-like operating systems, 
e.g. [[gcc]] under Linux, are usually called by default [[a.out]].
\l same name than format. confusing?
\l even if ELF format actually
\l why a.out? a? assembly output?
But, under \plan, for the same reason ARM object files use the [[.5]] filename
extension and not [[.o]], ARM executables are called [[5.out]] not [[a.out]].
This is more convenient in an operating system supporting 
multiple architectures at the same time.
That way, one can have in the same directory an ARM executable
[[5.out]] and an x86 executable [[8.out]] without any name conflict.
\l why not lib.5a then? solve conflict via /arm/lib/... /x86/lib/...


Another important option, [[-T<num>]], allows to change the (virtual)
{memory address origin} of the code section ([[T]] for text section).
%dup: from overview/principles
\label{sec:kernel-load-4096}
In \plan the default value for this address is 4128.
Indeed, the loader in the kernel
loads executables after the first page (4096), and includes
the header which is using 32 bytes, so the text section
will start at the memory address 4128. 
The machine code generated for the jumps and calls
must then assume the code will be loaded at 4128.
%
One can also change the memory address origin of the data section
as explained in Section~\ref{sec:choice-exec-format}.
%
Those options are almost never used by programmers, but they
are necessary for producing special executables such as
kernels or boot loaders as we will see in the \book{Kernel}.
Indeed, those binaries will be loaded (by the bootstrapping process
or firmware) at special memory addresses, 
e.g. 0x80000000 for the ARM \plan kernel, 0x7c00 for an x86 bootloader.

Another set of options are used to manage libraries,
which are really files encapsulating a set of object files,
\l like tar, actually ar means archive
and will be introduced later in Chapter~\ref{chap:loading-libraries}.

\l also dynamic related options, -x -u

\l env: $ccroot
%$


\section{[[hello.5]] and [[world.5]]}
\label{sec:hello-world}

%trans:
In this section we adapt the [[helloworld.s]] example of the \book{Assembler}
%toc:
to illustrate the linking process with a concrete example. 
The goal is also to learn how to use the debugging options of [[5l]] as well
as tools such as [[nm]].
\l why? because useful to debug issues, to find where symbols are defined
\l and indeed to better understand indeed linking process

\subsection{The source files}
\label{sec:hello-world-source}

We splitted the original source file [[helloworld.s]] 
in two files [[hello2.s]] and [[world.s]].
We also use the C library functions [[fprint()]]
and [[exits()]] instead of using directly the [[PWRITE]] and [[EXITS]] 
system calls:

<<linkers/5l/tests/hello2.s>>=
TEXT main(SB), $8
        /* fprint(1,&hello) */
        MOVW $1, R0
        MOVW $hello(SB), R1
        MOVW R1, 8(R13)
        BL fprint(SB)
        /* exit(0) */
        MOVW $0, R0
        BL exits(SB)
@
%$
\n call libc via fprint/exits so != Assembler.nw, and use main not _main
\n (cant call print cos pointer func so more complex) 
\t use FP instead of R13? 
\l weird but using only stack and not R0 at all also works

<<linkers/5l/tests/world.s>>=
GLOBL   hello(SB), $12
DATA    hello+0(SB)/8, $"hello wo"
DATA    hello+8(SB)/4, $"rld\n"
@
%$

If you do not understand the code, or the calling
conventions, read the \book{Assembler}.
%
Symbol definitions and uses are now spread over different files:
the [[hello]] global is defined in [[world.s]] but used in [[hello2.s]].
Moreover, the [[fprint()]] and [[exits()]] functions are defined in 
source files of the C library but used in [[hello2.s]].

\subsection{The linking command}

To compile the previous program do:
\begin{verbatim}
$ cd /tests/5l
$ 5a hello2.s -o hello.5
$ 5a world.s
$ 5l hello.5 world.5 /arm/lib/libc.a -o hello
$ ./hello
hello world
\end{verbatim}

The main difference with the commands shown in 
Section~\ref{sec:getting-started} is the use of the C library
compiled for the ARM architecture: [[/arm/lib/libc.a]].
We will see in chapter~\ref{chap:loading-libraries} other
ways to link libraries.

\subsection{Inspecting objects with [[nm]]}

One can use the tool [[nm]] to get the set of symbols defined or
referenced in object files (this set is also called the [[n]]a[[m]]e list):

\begin{verbatim}
$ nm hello.5
 U exits
 U fprint
 U hello
 T main

$ nm world.5
D hello
\end{verbatim}
\n note that if call main in hello2.5, you will not get a U main
\n even though in practice intra-file calls are not resolved by 5a

[[nm]] can also be used on libraries:

\begin{verbatim}
$ nm /arm/lib/libc.a | grep fprint
...
fprint.5: T fprint
...
$ nm /arm/lib/libc.a | grep exits
...
atexit.5:         T exits
...
\end{verbatim}

[[U]] stands for undefined,
[[T]] for text (a defined procedure), and
[[D]] for data (a defined global).
%
From the previous commands we can see that [[hello.5]] has three
undefined symbol references, including [[hello]] which
is a global data defined in [[world.5]]. 
%
The job of the linker is then to link those definitions to their uses.
%
There are other kinds of symbols and so other single letter codes
used by [[nm]]. Those codes as well as the source of
[[nm]] will be described fully later in Appendix~\ref{sec:nm-code}.

\l nm is actually using libmach, crachhdr, etc, generic API for object manip
\t put libmach/5obj.c in this book?
\l nm is actually pretty useful in general, to solve linker issues, nm | grep!

\subsection{Inspecting objects with [[5l -W]]}
\label{sec:dump-objects}

Another way, more complete, to inspect the content of object files is to use
the debugging option [[-W]] of [[5l]]. The effect of the option
is to ``dump''
the instructions of the object files passed on the command line:
\l close to disassembler, but actually easier
\l disassembler is actually in libmach and used by db

\begin{verbatim}
1   $ 5l -W hello.5 world.5 /arm/lib/libc.a
2   ...
3   	ANAME	main                        
4   (1)	TEXT	{main}00000+0(SB),$8        
5   (4)	MOVW	$1,R0                       
6   	ANAME	hello                       
7   (5)	MOVW	${hello}00000+0(SB),R1      
8   (5)	MOVW	R1,8(R13)                   
9   	ANAME	fprint                      
10  (6)	BL	,{fprint}00000+0(SB)            
11  (9)	MOVW	$0,R0                       
12  	ANAME	exits                       
13  (9)	BL	,{exits}00000+0(SB)             
14  (10)	END	,                           
15  ...
16  	ANAME	hello
17  (1)	GLOBL	{hello}00000+0(SB),$12
18  (2)	DATA	{hello}0000c+0(SB)/8,$"hell"
19  (3)	DATA	{hello}0000c+8(SB)/4,$"rld\n"
20  (4)	END	,
21  ...
22      ANAME	_main
23  (8)	TEXT	{_main}00000+0(SB),R1,$80
24      ANAME	setR12
25  (10)MOVW	${setR12}00000+0(SB),R12
26      ANAME	_tos
27  (11)MOVW	R0,{_tos}00000+0(SB)
28  ...
29  (21)BL	,{main}00000+0(SB)
\end{verbatim}
\n this was actually done via kencc/5l
\t why those lineno? seems wrong line number. BUG?
\l remove those comma? 
\t for dollar hello we should remove the (SB)? NO! it will use R12!
\t  but it will do R12 + 00014 no?
\l have a D_ADDR? so cleaner?
\l very close to assembler, indeed object file is just serialized asm source
%pad: I changed the format to use {} and to show the value (here 00000) of syms

The first two fragments show the instructions of [[hello.5]],
from Line 3 to Line 14,
and [[world.5]], from Line 16 to Line 20.
The output is very similar to the assembly sources of
Section~\ref{sec:hello-world-source}. 
%dup: from intro/5l (itself dup from Assembler.nw)
This is normal since under \plan an object file is essentially
the serialized form of the abstract syntax tree of an assembly source.
%
See the \book{Assembler} if you do not
understand the opcodes or pseudo-opcodes such as [[ANAME]].

Symbol references are enclosed in braces, e.g. [[{main}]] Line 4,
followed by the {\em symbol value} in hexadecimal, e.g. [[00000]] Line 4.
The symbol value corresponds normally to the 
resolved memory address of the symbol.
But, almost all those values and addresses are null 
when using [[-W]] because the option dumps instructions
while the object files are read into memory, and so
when the linker has not yet resolved any of those symbols.

Once a global has been declared, e.g. [[hello]] Line 17,
the value of its symbol is then (ab)used to store its size,
here [[0000c]] (12) at Line 18.
%
Later we will see that the symbol value will contain the resolved address
of the global.
\l as an offset to the start of the Data section.

\label{sec:explain-_main}
The last fragment, starting at Line 22,
shows the instructions of a procedure called [[_main]].
%dup: (and adapted) from Assembler.nw
The linker [[5l]] is looking by default for such a procedure
for the {entry point} of the executables it generates
(unless the [[-E]] option is used).
%
The reason for a default called [[_main]], and not [[main]],
even though the entry point of C programs is [[main]],
is because [[_main()]] is a procedure defined in the C library.
This procedure, written in assembly, does some core initialisations
and then calls [[main()]], as shown by the last dumped
instruction Line 29.
%
[[5l]] is usually called to link C programs, and
the C compiler [[5c]] assumes a few core initialisations has
been done before the call to [[main()]], hence the choice
of [[_main]] as the default entry point.

For more information on [[5l -W]] see Appendix~\ref{sec:debugging-loading}.

%real-world:
\t readelf? objdump? 

\subsection{Inspecting executables with [[5l -a]]}

One can also display the generated machine code by using
the debugging option [[-a]] of [[5l]]:

\begin{verbatim}
1   $ 5l -a hello.5 world.5 /arm/lib/libc.a
2 
3  00001020:		(1)	TEXT	{main}01020+0(SB),$8
4  00001020: e52de00c	(1)	MOVW.W	R14,-12(R13)
5  00001024: e3a00001	(4)	MOVW	$1,R0
6  00001028: e59f1884	(5)	MOVW	${hello}00014+0(SB),R1
7  0000102c: e58d1008	(5)	MOVW	R1,8(R13)
8  00001030: eb0000bb	(6)	BL	,{fprint}01324(BRANCH)
9  00001034: e3a00000	(9)	MOVW	$0,R0
10 00001038: eb00009a	(9)	BL	,{exits}012a8(BRANCH)       
11
12 0000103c:		(8)	TEXT	{_main}0103c+0(SB),R1,$80
13 0000103c: e52de054	(8)	MOVW.W R14,-84(R13)
14 00001040: e59fc870	(10) MOVW ${setR12}00ffc+0(SB),R12
15 00001044: e50c0fd0	(11) MOVW R0,{_tos}0002c+0(SB)
16 ...
17 00001068: ebffffec	(21) BL	,{main}01020(BRANCH)
18 ...
19
20 000012a8:		(915) TEXT {exits}012a8+0(SB),R1,$16
21 000012a8: e52de014	(915) MOVW.W	R14,-20(R13)
22 ...
23
24 00001324:		(874) TEXT {fprint}01324+0(SB),R0,$20
25 00001324: e52de018	(874) MOVW.W	R14,-24(R13)
26 ...
27
28 00006b50: e49df03c	(890) MOVW.P	60(R13),R15
\end{verbatim}
\n this was also done via kencc/5l


The first column contains the memory address
in hexadecimal where the code will be loaded (e.g. [[01020]] Line 4).
%
Then comes the 4 bytes in hexadecimal of the generated ARM instruction
(e.g. [[e52de00c]]). Indeed ARM uses fixed-length instructions
of 4 bytes.
%
The third column contains the (global) line number
in parenthesis of the instruction in the original 
source file (assembly or C)\footnote{
See Section~\ref{sec:lineno} for more information about line numbers.
}.
%
Finally, the last column displays the disassembled instruction
\l actually not really disassembled
As opposed to the previous section, the symbol values 
are not null anymore and contain now the resolved memory address
of the symbol, e.g. [[01324]] Line 8 for the [[fprint]] symbol.
%
The output contains also the [[TEXT]] pseudo-instructions to better
see the procedure boundaries, e.g. Line 3 and Line 12. 



The first instruction Line 4 starts at [[01020]] which is equal to 4128.
%dup: from overview/principles and overview/command-line
Indeed, as said previously in Section~\ref{sec:kernel-load-4096},
the kernel loads executables after the first page (4096)
and includes the [[a.out]] header which is using 32 bytes. Thus,
the code starts at the memory address 4128.

Note that even though it looks like there are two instructions
at [[01020]], with Line 3 and Line 4, the first instruction ([[TEXT ...]])
is a pseudo-instruction which got transformed by the linker
in the ARM instruction Line 4 ([[MOVW.M ...]]).
\t lots to explain here, 8 vs 12, MOVW.M which does multiple things.
Indeed, [[TEXT]] is an assembly directive introducing a symbol,
here [[main]], and symbols are {resolved} in 
{concrete addresses} by the linker. The generated machine code
contains only concrete addresses, no symbols (except for
debugging purposes as explained in Chapter~\ref{chap:debugging}).
%
So, the reference to [[main]] Line 17 is resolved to the concrete
address [[01020]].
In the same way, the calls to [[fprint]] and [[exits]]
Line 8 and 10 are fully resolved in respectively
the memory addresses [[01324]] (Line 25)  and [[012a8]] (Line 21).

The symbol value of [[hello]] Line~6 is [[00014]] which
seems incorrect. Indeed, data should be stored after
the code section and so the resolved address of [[hello]] should
be beyond [[06b50]] (the address of the last instruction Line 28).
%dup: section just before
But, the symbol value for data symbols contains the resolved address
of the symbol as {\em an offset to the start of the data section}.
The rational for this decision will be explained later
in Section~\ref{sec:sb-r12}.
Thus, the final address of [[hello]] is [[014 + INITDAT]]
where [[INITDAT]] is the address where starts the data section.
\t so if really disassemble e59f1884? get what? 7014? or BIG-7014?
\l actually see also initialisation of R12 with  very tricky
% MOVW	${setR12}00ffc+0(SB),R12
% which really is   MOVW    0xffc(R12=0), R12

\l 6000 = ? just for including fprint and exits, hmmm

For more information on [[5l -a]], see 
Appendix~\ref{sec:debugging-generated-code}.

\subsection{Inspecting executables with [[nm]]}

[[nm]] can also be used on executables. In that case [[nm]] not only displays
the list of symbols, it also displays their addresses (in hexadecimal)
when loaded
in memory. Here it is used with the [[-n]] option to sort by addresses:

\begin{verbatim}
1 $ nm -n 5.out
2     1020 T main
3     103c T _main
4     ...
5     110c T _div
6     1168 T _mod
7     ...
8     12a8 T exits
9     ...
10    1324 T fprint
11    ...
12    6b58 T etext
13    7000 d onexlock 
14    7000 D bdata    
15    7010 D argv0    
16    7014 D hello    
17    7020 d _exitstr 
18    ...             
19    7940 D edata    
20    7b44 B onex     
21    7c50 B end      
22    7ffc D setR12   
\end{verbatim}
\n this was also done via kencc/nm (actually inm)
\l why etext not 6b54?

We find the same resolved memory addresses we saw in the previous
section with [[5l -a]], e.g. [[1324]] (in hexadecimal) for [[fprint]]
Line 10, or [[12a8]] for [[exits]] Line 8.

We can also now see the addresses of the data symbols.
[[hello]] Line 16 is at the address [[7014]]. The data
section starts at [[7000]] as indicated by the 
{\em special symbol} [[bdata]] (begin data) Line 14. 
So, [[INITDAT]] is [[7000]]
which confirms that the address of [[hello]] is indeed
[[14 + INITDAT]] ([[7014]]) as mentioned in the previous section.
\l but still a lot to explain because generated code is not that too,see setR12

The symbol after [[hello]] is [[_exitstr]] Line 17
at address [[7020]]. This confirms that [[hello]] is using 
12 bytes ([[0x7020]] - [[0x7014]] = [[0xc]] = 12) 
as said in the source of [[world.s]]
in Section~\ref{sec:hello-world-source}.

The linker defines a set of special symbols:
[[etext]] (end text) Line 12,
[[bdata]] (begin data) Line 14,
[[edata]] (end data) Line 19, and finally
[[end]] Line 21.
Those symbols are used only for their addresses and
allows a form of {\em reflection} on the structure
of the executable and its sections as explained
in Section~\ref{sec:special-symbols}.

Another special symbol, [[setR12]] Line 22
plays a complex role in [[5l]]. This symbol is notably
used by [[_main]] as indicated by the output of [[5l -W]]
and [[5l -a]] we saw in the previous sections.
Its role and its relationship with the pseudo-register
[[SB]] will be explained later in Section~\ref{sec:sb-r12}.

\l _existstr 
\l small d means static symbol B means unitialized (BSS)

\l can also use db (or 5i) to inspect executable.




\section{Input object format}

The object file is now the input, as opposed
to the \book{Assembler} where it was the output.
%
The format of ARM object files is fully described
in the \book{Assembler} so we will not repeat
those explanations here.
%
Section~\ref{sec:object-format} contains a figure
summarizing the ARM object file format though, which will be useful
to understand the code of Chapter~\ref{chap:loading-objects}
which loads object files.

Note that Section~\ref{sec:dump-objects} contained the {dump}
of a few of object files and showed that
%dup: from intro/5l, overview, etc, maybe too much?
an object file is essentially
the serialized form of the abstract syntax tree of an assembly source.


\l could take figure in Assembler.nw and add the ANAME and AHISTORY?
\l or put concrete values everywhere?
\l 5l -W also show format a bit

\section{Output executable format, [[a.out]]}

\plan is using the very simple [[a.out]] executable format.
\t ref? rfc?
\l history? why called a.out? ok name of executable but why a? assembler output?
So, [[5l]] by default generates executables in this format.
This can be changed with the [[-H]] option. Other formats
will be described in Section~\ref{sec:other-executable-formats}

The file [[include/exec/a.out.h]] contains a formal
description of the [[a.out]] header:

<<struct Exec>>=
// a.out header
struct	Exec
{
    long	magic;		/* magic number */

    long	text;	 	/* size of text segment */
    long	data;	 	/* size of initialized data */
    long	bss;	  	/* size of uninitialized data */

    long	syms;	 	/* size of symbol table */

    // virtual address in [UTZERO+sizeof(Exec)..UTZERO+sizeof(Exec)+text]
    long	entry;	 	/* entry point */ 

    long	_unused;
    // see a.out.h man page explaining how to compute the line of a PC
    long	pcsz;		/* size of pc/line number table */
};
@
%old: _unused was actually:
%    // used only by 68020, spsize set to 0 for 8l TODO remove at some point!
%    long	spsz;		/* size of pc/sp offset table */

Figure~\ref{fig:executable-format} illustrates the format of
[[a.out]] executables.
%
An [[a.out]] header is made of 8 [[long]]s, which are 32 bytes, used
as follows:
\begin{itemize}
\item The first four bytes contains a magic number identifying the file
as an [[a.out]] executable as well as an ARM executable.
This magic number is recognized
by tools such as [[file]] and by the kernel loader
which will load only files having this magic number {signature}.

\item Then comes the size of the text and data sections. The format
of the ARM machine instructions in the text section will be
described in Chapter~\ref{chap:arm-codegen}.

\item The fourth number contains the size of the [[BSS]] section which
corresponds to {unitialized data}. 
\t BSS means?
The actual values for those data is not defined in the executable, 
as opposed to the data section, but the loader must
still reserve space in memory for those data.
The following C code shows which section will be used
depending on the declaration of a variable:

\begin{verbatim}
int global = 1; // Data section
int another;    // BSS section
\end{verbatim}

\item The symbol table will be discussed in 
Chapter~\ref{chap:debugging}.

\item The entry point is a memory address used by the kernel
loader to start the program. This is usually the address
of the [[_main]] procedure of the C library (unless
the [[-E]] option is used). 
%
So, for the [[hello]] executable of the previous section,
the value of the entry point would be [[0x103c]].
%
The entry point can also be the
address of the [[_mainp]] procedure if profiling
is enabled as explained in Chapter~\ref{chap:profiling}.

\item Finally the line table will be discussed also in 
Chapter~\ref{chap:debugging}.

\end{itemize}



\begin{figure}[!]\centering
\begin{verbatim}
     +--------------+
     |     Line     | ^
     |    table     | |<-------+
     |              | v        |
     +--------------+          |
     |    Symbol    | ^        |
     |    table     | |<------+|
     |              | v       ||   +--------------+ +32
     +--------------+         |+---|  line size   |
     |              | ^       |    +--------------+ +28
     |     Data     | |<-----+|    |              |
     |              | v      ||    +--------------+ +24
     +--------------+        ||    | entry point  |------+
     |              | ^      ||    +--------------+ +20  |
     |     Code     | |      |+----| symbol size  |      |
     |    (Text)    | |      |     +--------------+ +16  |
     |              | |<----+|     |   bss size   |      |
+---->              | |     ||     +--------------+ +12  |
|    |              | v     |+-----|  data size   |      |
|+32 +--------------+       |      +--------------+  +8  |
|    |    Header    |       +------|  text size   |      |
|    |   (a.out)    |              +--------------+  +4  |
|    |              |              |    magic     |      |
|  0 +--------------+              +--------------+   0  |
|                                                        |
+--------------------------------------------------------+
     a.out executable                a.out Header
\end{verbatim}
\caption{[[a.out]] executable format}\label{fig:executable-format}
\end{figure}

\l data just adter code, but when loaded in mem, at round?
\l and then from lineno you can get file/line thx to Hist?

Note that the [[Exec]] structure is actually not used by
the code of [[5l]].
Instead, the function [[asmb()]]
we will see in Section~\ref{sec:gen-executable} outputs
directly the bytes of the header with a serie
of calls to the [[lput()]] (for out[[put]] [[long]])
utility function.

The [[Exec]] structure is used though when {\em reading}
the header of executables.
There are many utilities which need to understand the
format of executables, e.g. the debugger [[db]], the
profiler, and small utilities like [[nm]]. Under \plan, all those
programs use a common library called [[libmach]] which
defines [[Exec]] as well as many other data structures and functions.
Appendix~\ref{chap:linker-related-programs} discusses the
[[libmach]] interface and the code of utilities such as [[nm]],
but the code of [[libmach]] itself will be shown in the
\book{Debugger}.

\t no dynlink notion in a.out? need ELF for that?

%http://jvns.ca/blog/2014/09/06/how-to-read-an-executable/
%http://lowlevelbits.org/parse-mach-o-files/




%\section{Calling conventions}

% memory model when loaded in memory? need that? seems more cc material
% frame format?
%  parameters (including space for first arg even if put in R0)
%  saved PC (from REGLINK when not a leaf procedure)
%  locals
% saved SP? assumer caller saves/restores registers including SP?

% When want to call a procedure, need to save current place,
% so do BL for branch and link where a special register
% holds a value. Then need to save this value in a stack
% (if it's not a leaf procedure).

% autosize = p->to.offset + 4; // locals
% + 4 = saved PC (REGLINK from BL)

% FP vs SP? SP seems not equal directly to R13!


\section{Code organization}

%dup: (and adapted) from Assembler.nw
Table~\ref{tab:code-orga} presents a short description
of the source files used by [[5l]], 
the main entities (structures, functions, globals, etc) the file defines,
and the corresponding chapters in this document in which the code
contained in the file is discussed.
\n sorted by chapters, make more sense than sorted by dir


\begin{table*}[tbh!]
\begin{center}
\begin{tabular}{llllr}
\toprule
{\bf Function} & {\bf Chapters} & {\bf File} & {\bf Entities} & {\bf LOC} \\
\otoprule
Data structures & \ref{chap:core-ds} & [[l.h]] & [[Sym]], [[Section]], [[Instr]], [[Auto]], & 0 \\
% headtype, Buf, ...
and prototypes  & \ref{chap:arm-codegen} &         & [[Optab]], [[Oprang]], [[Operand_class]] & \\
% like a dat.h and fns.h
Globals         & \ref{chap:core-ds}, \ref{chap:main}               & [[globals.c]] & [[hash]], [[firstp]], [[textp]], [[textsize]], [[datsize]], ... & \\
Entry point     & \ref{chap:main}    & [[main.c]] & [[main()]] & \\
%pad: I created this file

\midrule

Object and library & \ref{chap:loading-objects} & [[obj.c]] & [[ldobj()]] & \\
loading            & \ref{chap:loading-libraries} &         & [[loadlib()]] & \\

Resolving          & \ref{chap:resolving} & [[pass.c]] & [[patch()]], [[dodata()]] & 0 \\
and rewriting      &                      & [[noops.c]] & [[noops()]] & \\

Code generation    & \ref{chap:arm-codegen} & [[span.c]] & [[dotext()]], [[oplook()]], [[buildop()]] & \\
                   &                        & [[optab.c]] & [[optab[]]] & \\
                   &                        & [[asm.c]]  & [[asmb()]], [[datblk()]], [[asmout()]]  & \\

\midrule

Elf constants     & \ref{chap:advanced} & [[elf.h]] & [[Ehdr32sz]] & \\       
Elf generation   & \ref{chap:advanced} & [[elf.c]]  & [[elf32()]] & \\
% actually in 8l/

\midrule

Dumpers            & \ref{chap:debugging-appendix} & [[list.c]] & [[prasm()]], [[Pconv()]], [[Dconv()]],  & \\
                   &                               & [[enam.c]] & [[anames[]]] & \\
%5l/enam.c: which is a symlink in 5c/

Utilities          & \ref{chap:libc}        & [[utils.c]] & [[lookup()]], [[errorexit()]] & \\
                   &                        & [[compat.c]] & [[malloc()]] & \\

\otoprule
Total & & & & 7900 \\
\bottomrule
\end{tabular}
\end{center}
\caption{Source files of [[5l]]}
\label{tab:code-orga}
\end{table*}
\n see SRC_VIEWS in the Makefile, and make loc

\n did not factorized in a ll/ this time, but factorized via LP
\n could put include/exec/a.out.h but 5l does not use it
\n same for include/exec/elf.h

Another important file not included in Table~\ref{tab:code-orga}
is [[include/arch/arm/5.out.h]]. It contains the ARM assembly opcodes
definitions used by [[5l]]. It is not included here
because it is already described in the \book{Assembler}.
\l registers too
\n used to depend on 5c/ for one file ../5c/enam.c but now done via symlink



\section{Software architecture}
\label{sec:soft-archi}

%dup: (and adapted) from Assembler.nw
Figure~\ref{fig:controlflow} describes roughly 
the main control flow of [[5l]], while
Figure~\ref{fig:dataflow} describes 
the main data flow of [[5l]].
%
The main steps of the linking process of [[5l]] are:

\begin{enumerate}
\item {\em load} (read) the object files and libraries ([[objfile()]])
and {concatenate} their code and data in different sections
([[ldobj()]])

\item {\em resolve} symbol references and 
{relocate} branching instructions ([[patch()]], ...)

\item {\em generate} the executable with its header and
machine code ([[asmb()]])

\end{enumerate}


\begin{figure}[!]\centering
\begin{verbatim}
                    +---------+      +--------+
                +-->| objfile |----->| ldobj  |    Loading
                |   +---------+      +--------+
                |
                |     +---------+
                |+--->|  patch  |
                ||    +---------+
                ||    +---------+
+------------+  |+--->|  noops  |
|    main    +--++    +---------+
+------------+  ||                                 Resolving
                ||    +---------+
                |+--->| dodata  |
                ||    +---------+
                ||    +---------+
                |+--->| dotext  |
                |     +---------+
                |                     +--------+
                |                 +-->| datblk |
                |   +---------+   |   +--------+
                +-->|  asmb   |---+                Generating
                    +---------+   |   +--------+
                                  +-->| asmout |
                                      +--------+
\end{verbatim}
\caption{Control flow diagram of [[5l]]}\label{fig:controlflow}
\end{figure}
\n there is no loadlib(), it is an advanced  feature
%ocaml: if was more functional we could annotate arrows with types,
% and have more a pipeline than a tree of procedures

\begin{figure}[!]\centering
\begin{verbatim}
object file-\
             > instructions -> sections -> graph -> executable
object file-/                               

                      (use global symbol table)
\end{verbatim}
\caption{Data flow diagram of [[5l]]}\label{fig:dataflow}
\end{figure}
%ocaml: this is what I hope I will get, a transformation pipeline
% not sure I need the graph though


After some basic command line processing and initialisations,
the function [[main()]] first calls [[objfile()]] for
each object files and libraries to link. 
\n also loadlib(), but it is for advanced autamagic lib feature
\n  and only their objects containing symbols we are looking for 
\n  (symbols uses mentioned in object files and so marked as SXREF) fixpoint
\n  so produce smaller binaries
%
[[objfile()]] opens
the object file or library and calls [[ldobj()]] to read
its object code in memory, that is a {\em list of instructions}.
%
Doing so, [[ldobj()]] modifies also the globals [[firstp]], [[textp]],
and [[datap]] containing respectively 
the list of all {instructions}, 
the list of {procedures}, and 
the list of {data} instructions.
Thus, all the code and data in the
object files are concatenated together in the appropriate {\em sections}.
\l also Instr.type field with section name

[[ldobj()]] increments also a global [[pc]] after each code instruction
read. [[pc]] represents the current value of 
the {\em global (virtual) program counter}. Each code instruction
in memory has a field [[Instr.pc]] with the value of [[pc]]
at the moment the instruction was read.
\n imperative style
\t ldobj relocate branching instruction, use global virtual pc instead of local.
\t global because of all the objs, as opposed to Assembler
\t virtual because virtual counter still! incremented by 1
%
Finally, [[ldobj()]] populates also a {\em symbol table} called [[hash]],
which keeps track of different properties of symbols.
One of this property, [[Sym.value]], initially contains
a (virtual) program counter for symbols corresponding to procedures,
and a size for symbols corresponding to globals.
%
This same field will contain at the end the resolved memory
address of the procedure or global.


After loading the object files,
[[main()]] calls a serie of functions ([[patch()]], [[noops()]], etc)
which use the globals [[firstp]], [[textp]], and [[datap]] to
process or rewrite list of instructions.
%
First, [[patch()]] transforms the list of code instructions in a
{\em graph of instructions} where branching instructions have their
field [[Instr.cond]] points to the appropriate target instruction. 
%
To build this graph [[patch()]] is leveraging the symbol table
computed previously
to find the [[pc]] corresponding to a certain procedure symbol,
and {\em index} all [[Instr.pc]] to find the instruction pointer corresponding
to a certain [[pc]].


Once the graph has been built, there is no more need for the notion of
virtual program counter. Every code references (symbols or
absolute jumps) in branching
instructions have been resolved. 
%
This allows in turn to transform safely the {\em virtual instructions} (see
the \book{Assembler}) such as [[RET]], or [[NOP]] 
in real instructions. 
\l actually still not real real, use MOVW
\l or do optimisations? e.g. ANOP
Indeed, [[noops()]] can
replace a virtual instruction by
multiple instructions or even delete the instruction without
any consequence on the other branching instructions (as long
at it maintains carefully the [[Instr.cond]] pointers of certain instructions).
Before the graph of instructions, inserting or
deleting an instruction would have forced to assign a new [[pc]]
to each instruction and to relocate every branching instructions.

Once [[5l]] has a graph of real code instructions and a list of data
instructions, it can start to {\em layout} the code and data.
[[dodata()]] assigns a memory address in [[Sym.value]] to each globals in
[[datap]] as an offset to the start of the data section.
\l e.g. 014 for hello
%
Then, [[dotext()]] does a similar thing for the code instructions.
For those instructions [[Sym.value]] contains the final code address
of the instruction.
\l e.g. 0x1020 for main
\l so work by side effects, imperative style, on list of instructions

At this point, the size of the code section is known and stored
in the global [[textsize]], just like the size of the
data section stored in the global [[datasize]].
[[5l]] can finally generate the executable and its header in
[[asmb()]]. This function use two helpers functions, one
to generate the data section [[datblk()]] and one to
generate the code section [[asmout()]].

\l How does handle mutually recursive object files?
%  for objects passed on the command line it loads every symbols
%  and at first some symbols get their type as SXREF (placeholder) but then
%  when you load the second object it sets it as a STEXT or SDATA.
\l How automatically grab all the necessary libs?
%  magic #pragma and special ANAME code in the .8?

\l Note that the linker loads lazily the objects in a library.
% It loads only what is necessary, that is objects in a lib
% containing symbols that are "looked for" that is symbols that are SXREF.
% (with a special case for _main which is not looked by
%  anything by default and so there is lookup(INITENTRY, 0)->type = SXREF
%  in the main of 8l/5l).

\l linker vs libmach, see appendix



\section{Book structure}

%trans: %dup: (and adapted) from Assembler.nw
We now have enough background to understand the source code of [[5l]].
%toc:
The rest of the book is organized as follows.
%
We will start by describing the core data structures of [[5l]]
in Chapter~\ref{chap:core-ds}. 
%
Then we will use a top-down approach in Chapter~\ref{chap:main} and 
starting from [[main()]] we will present the code of the main 
functions, e.g. [[asmb()]].
%
The following chapters will be used to describe
the main components of the linking pipeline:
Chapter~\ref{chap:loading-objects} will present the code to
load object files,
Chapter~\ref{chap:loading-libraries} the code to load libraries,
Chapter~\ref{chap:resolving} the code to resolve symbols,
and finally Chapter~\ref{chap:arm-codegen} the machine code
generator.
%
In Chapter~\ref{chap:debugging} we will describe the code
responsible for adding debugging support in [[5l]], which
for instance adds line information in the executable. 
One can then know, when debugging a binary program,
to which original line and which source file an
instruction in the binary comes from, or what is the
original name of the procedure containing this instruction.
%
In a similar way Chapter~\ref{chap:profiling} will describe the code
for adding profiling support in [[5l]].
%
Chapter~\ref{chap:advanced} presents other
features of the linker which we did not present 
before to simplify the explanations, for instance
the support for dynamic linking or 
the ARM code generation of  instructions involving floats. 

%toc:
Some appendices present the code of non-functional properties:
the code to help debug [[5l]] itself in Appendix~\ref{chap:debugging-appendix}, the code to manage errors in Appendix~\ref{chap:error}, and
the code to help profile [[5l]] in Appendix~\ref{chap:profiling-appendix}.
%
Appendix~\ref{chap:libc} contains the code of generic
utilities used by [[5l]] but which are not specific to [[5l]].
%
Appendix~\ref{chap:linker-related-programs} describes the code small
programs such as [[nm]] and [[ar]] which are related to the linker.
%
Finally, Appendix~\ref{chap:5l-ocaml} contains
the code of an OCaml port of [[5l]].
\t what for? :)

%\section{Bootstrapping}
% source of 5l use 5l :) 
% cat can be bootstrapping tool! See Principia.nw appendix



%###############################################################################

\chapter{Core Data Structures}
\label{chap:core-ds}

\begin{verse}
\begin{flushright}
  {\it Show me your code and conceal your data structures, and I shall
    continue to be mystified. Show me your data structures, and I
    won't usually need your code; it'll be obvious.\\
    ~\\
    Fred Brooks}
\end{flushright}
\end{verse}

%toc:
In this chapter we will present the core data structures of [[5l]],
which are essentially:
a symbol table keeping track of the memory address and section of symbols, 
the abstract syntax tree (AST) of the instructions contained in object files,
and a set of globals representing lists of instructions.

\section{[[Sym]]bols and [[hash]] table}

%dup: (and adapted) from Assembler
One of the main job of a linker is to {resolve} symbol references
by linking uses of a symbol to its definition.
The {\em symbol table}, which keeps track of those symbols,
is thus a central data structure of [[5l]].
The structure below represents a symbol and its properties. 
It essentially associates a {\em key} to a {\em value}:

<<struct Sym>>=
struct	Sym
{
    // The key
    // ref_own<string>
    char	*name;
    // 0 for global symbols, object file id for local symbols
    short	version; 

    // The generic value, 
    // e.g. virtual pc for a TEXT procedure, size for GLOBL
    long	value; 

    <<[[Sym]] section field>>

    <<[[Sym]] other fields>>
    // Extra
    <<[[Sym]] extra fields>>
};
@
%ocaml: no need special type, just use hashtbl for symbol table
\l rename Symbol?
\l transform value to a union?
\n conflict with include/a.out.h

The key is made of a pair with the name of the symbol and a {\em version}.
\l bad name?
The version is used to differentiate {\em local symbols} 
(a.k.a static symbols)
\n local symbols are advanced feature but too important to delay because
\n  many interfaces like lookup take a version number.
\l local symbols could be resolved in Assembler? kinda but want keep
\l  symbol in executable for debugger and anyway linker need to resolve things
\l  already so why not also resolve local symbols
in different object files using the same name, e.g. [[tmp<>]] 
in [[foo.5]] and [[tmp<>]] in [[bar.5]]. 
See the \book{Assembler} for more information about local symbols.
A version is a unique integer representing an object file,
e.g. 1 for [[foo.5]] and 2 for [[bar.5]], so the two previous
symbols can be designated respectively by [[tmp.1]] and [[tmp.2]].
Global symbols have their version set to 0.

The meaning of [[Sym.value]] depends on the kind of the symbol.
It also depends on the step in the linking pipeline. 
At the beginning [[Sym.value]] contains 
a virtual program counter for [[TEXT]] symbols, and
a size for [[GLOBL]] symbols. 
At the end it contains 
a resolved memory address in the code section for procedures and 
a resolved offset to the start of the data section for globals.

\l The 'type' and 'value' in Sym are? 
% - for ATEXT it will be STEXT and the value will be a virtual pc
% - for AGLOBL it will be SBSS or SDATA, and the value will be its size
% before dodata() the value for a global stores its size. After location.
% before span() the value stores a virtual pc,
%  incremented by 1 between each instruction. After span() it stores the
%  final location at 4 bytes boundaries.
% => maybe use an union! 


%assembler:
% Explain special encart to related to code of 5a, because
% similar but different. Can be nice too relate. But optional for reader.
%assembler: Similar to Sym in Assembler.nw, but a few differences:
% - no 'type' (token_kind) field, no 'macro' field
% - no labels, they were translated in pc values.
% - no symidx field (but was local to outcode())
% - a new 'version' field; N_INTERN was in the Operand.symkind but the linker
%   now manages multiple objects together where can have the same static name
%   multiple times
% - a new 'type' field for the section, the linker has to resolve
%   as opposed to the assembler
% So this is really a symbol table, used for only one thing! good.


%dup: from Assembler
The symbol table itself is represented by a global {hash table}
called [[hash]]. It makes sense to use a global because
the symbol table will be accessed by different components
of the linking pipeline.
\l eg? ldobj, patch
%
One way to implement a hash table in C is to use a big array
of lists, also known as an array of {buckets}:

<<global hash linker>>=
// hash<Sym.name * Sym.version, ref_own<Sym>> (next in bucket = Sym.link)
Sym*	hash[NHASH];
@
\l when load the objects this hashtbl is populated
<<constant NHASH linker>>=
NHASH		= 10007,
@
%assembler: same except NHASH which was 503 in 5a
%ocaml: just use stdlib hashtbl

%dup: from Assembler
One way to implement a list of something in C is to embed in
this something a [[link]] field pointing to the next
element in the list:

<<[[Sym]] extra fields>>=
// list<ref<Sym>> bucket of hashtbl 'hash'
Sym*	link;
@

%dup: from Assembler
The end of the list is represented by the null pointer:

<<constant S>>=
#define	S		((Sym*)nil)
@


%dup: (and adapted) from Assembler
The main interface to the symbol table is the
function [[lookup()]] which internally uses the global [[hash]].
It takes a symbol name and a version, forming a full key,
and returns the [[Sym]] in the symbol table [[hash]] associated with 
this key, or a new symbol if the key was not found:

<<function lookup>>=
Sym*
lookup(char *symb, int v)
{
    Sym *sym;
    long h;
    int len;
    <<[[lookup()]] locals>>

    <<[[lookup()]] compute hash value [[h]] of [[symb]] and [[v]], and [[len]]>>
    
    // sym = hash_lookup((symb, v), h, hash)
    for(sym = hash[h]; sym != S; sym = sym->link)
        if(sym->version == v)
            if(memcmp(sym->name, symb, len) == 0)
                return sym;

    <<[[lookup()]] if symbol name not found>>
}
@
%old: I rename s -> sym and l -> len
\l typedef int version;? and VERSION0 = 0 so clearer to read? a GLOBAL = 0?
%ocaml: use stdlib Hashtbl.find, sad duplicate from 5a/
%assembler: very similar, diff is use of (symb, v) instead of just (symb)

<<[[lookup()]] locals>>=
char *p;
int c;
@
<<[[lookup()]] compute hash value [[h]] of [[symb]] and [[v]], and [[len]]>>=
// h = hashcode(symb, v); 
// len = strlen(symb);
h = v;
for(p=symb; *p; p++) {
    c = *p;
    h = h+h+h + c;
}
len = (p - symb) + 1;
h &= 0xffffff;
h %= NHASH;
@
\l why plus 1 ?? figure? example?

<<[[lookup()]] if symbol name not found>>=
// else
sym = malloc(sizeof(Sym));
sym->name = malloc(len + 1); // +1 again?
memmove(sym->name, symb, len);
sym->version = v;

sym->value = 0;
sym->type = SNONE;
sym->sig = 0;

// add_hash(sym, hash)
sym->link = hash[h];
hash[h] = sym;

<<[[lookup()]] profiling>>
return sym;
@
\l why plus 1 ??

% sym->sig will be described in Safe linking section

\section{[[Section]]}

Another important property of a symbol is in which {\em section}
it will reside:

<<[[Sym]] section field>>=
//enum<Section>
short	type;
@
\l rename section?

<<enum sxxx(arm)>>=
enum Section
{
    SNONE = 0,

    STEXT,
    SDATA,
    SBSS,

    SXREF,
    <<enum sxxx cases>>
};
@
\l see also asmsym()

We can see above enumerations corresponding to the usual
[[Text]], [[Data]], and [[BSS]] sections of a program.
Note that there is no [[SSTACK]] enumeration as we care only 
about the executable file here, not the memory image of a program. 
The stack content and its maximum size is set initially by the kernel, 
not the executable.

[[SXREF]] is used to represent an {\em unknown reference}. When object
files are loaded in [[ldobj()]], symbol references in operands
are looked up in the symbol table. 
\l well N_EXTERN and N_INTERL
If the symbol has not been
defined yet, a new symbol is created with its section set to [[SXREF]]. Once
a [[TEXT]] or [[GLOBL]] directive introduces the symbol, 
its section can be adjusted.
%
At the end of the linking process there should be no more
symbols with [[SXREF]]. This is in fact checked by the
[[undef()]] function we will see in Section~\ref{sec:undef}.
\t lead to famous error message: undefined ref ...

\l those are mostly sections, or subsections (e.g. SDATA1 of SDATA,
\l  and SLEAF/SCONST/STRING of STEXT)



\section{[[Opcode]] and [[Operand]]}

%trans:
An object file contains essentially a list of {instructions} where
each instruction is made of 
an {\em opcode} with possibly 1, 2, or 3 {\em operands}.
%
The [[Opcode]] type, as well as [[Operand_kind]] and a few register
aliases such as [[REGPC]], all used by [[5l]], are defined in
[[include/arch/arm/5.out.h]]. 
Those types are fully described in the \book{Assembler}. 
%
{Dumpers} for those types are described in Appendix~\ref{sec:dumpers}
if you need to refresh your memory: 
\begin{itemize}
\item see [[Aconv()]] for the dumper of [[Opcode]] 
([[A]] because opcodes use the [[A]]$xxx$ syntax, e.g. [[ASUB]]),

\item see [[Dconv]] for the dumper of [[Operand_kind]] 
([[D]] because operand kinds use the [[D]]$xxx$ syntax, e.g. [[D_CONST]]).

\end{itemize}


Remember that the opcodes in object files do not correspond exactly to ARM
opcodes. They are mostly a superset because they also include
opcodes for {\em pseudo-instructions} such as [[ATEXT]] and [[AGLOBL]], as well
as opcodes for {\em virtual instructions} such as [[ARET]] and [[AMOVW]].
\n can put major opcodes here, AADD, ATEXT, AB, etc? done a bit above
\n and also D_REG? done a bit below.
\l and also N_INTERN?

[[include/arch/arm/5.out.h]] does not define an [[Operand]] type though
as the assembler and linker have slightly different needs for
this data structure. 
\l could be factorized, but also different Sym 
%ocaml: could be the same
Here is the [[Operand]] type used by [[5l]]:

<<struct Adr(arm)>>=
struct	Adr
{
    // enum<operand_kind> (D_NONE by default)
    short	type;

    // switch on Adr.type
    union {
        long	offset;
        Ieee*	ieee;
        char*	sval;
    };

    // option<enum<registr>> None = R_NONE
    short	reg; 

    <<[[Adr]] other fields>>
};
@
\n see DConv too
\t rename Operand!
%old: was called Adr
\n ATEXT arguments are also Adr (abuse)
%ocaml: would be better if had ADT so can have better Instruction type instead
% of those opcode, operand, Adr, and unions and all those comments
%note: offset abused for REGREG in which case it's really a int4
% but otherwise it's often used as an offset in D_BRANCH, D_OREG
% because indeed it's an offset to a basis (PC, SB, etc)
%assembler: Similar to Gen in Assembler.nw, but a few differences:
% - ieee was dval, and sval was sval[8]
% - have now a union for sym and autom, probably autom for the N_PARAM and
%   N_LOCAL cases
% - new 'class' field (but seems local to oplook())

[[Operand]] is until now very similar to the [[Operand]] type used by [[5a]]
and  described in the \book{Assembler}.
The kind of the operand is also stored in [[Operand.type]], e.g.
[[D_CONST]], [[D_REG]], [[D_OREG]].
\l talk about offset? and relocations?
\l offset can be based on PC (for D_BRANCH), SB(for N_INTERN, N_EXTERN),
\l  on FP(for N_PARAM), and on SP(for N_LOCAL), 
\l  or can be direct value (for D_CONST)
The [[Operand.reg]] field is also used for operands involving registers.
\l reg Abused for NOPROF and DUPOK? could use a union again?
Operands involving symbols use an [[Operand.sym]] field in [[5a]]
but a slightly different structure is used in [[5l]] as explained later.
%
The kind of the symbol is also stored in a [[Operand.symkind]] field,
e.g. [[N_EXTERN]], [[N_PARAM]], [[N_LOCAL]] (which are
enumerations defined also in [[include/arch/arm/5.out.h]]):

<<[[Adr]] other fields>>=
// enum<sym_kind>
short	symkind;
@
%old: was called 'name' but confusing

\l give a few examples of concrete operands? or refer to assembler book?

Symbols references in the assembly languages of [[5a]] as well as in
object files are all represented as offsets to {\em pseudo-registers}:

\begin{itemize}
\item procedures and globals use the [[SB]] pseudo-register,
for {\em static base}, e.g. [[main(SB)]], [[hello(SB)]]. Their
symbol kind is [[N_EXTERN]] (or [[N_INTERN]] for static symbols
such as [[foo<>(SB)]]).

\item parameters are accessed via the [[FP]] pseudo-register,
for {\em frame pointer}, e.g. [[p+4(FP)]]. Their symbol
kind is [[N_PARAM]].

\item locals use the [[SP]] pseudo-register,
for {\em stack pointer}, e.g. [[v-8(SP)]]. Their symbol
kind is [[N_LOCAL]].
\t SP usually negative no?

\end{itemize}

The symbol name for parameters and locals is actually optional.
What matters is the offset number. The symbol name is mostly
a comment which can be leveraged by tools such as debuggers.
This explains the use of a union below to differentiate
those different kinds of symbol references:

<<[[Adr]] other fields>>=
union {
    Sym*	sym;
    Auto*	autom;
};
@
\l rename autom and Auto
\n autom because auto is a reserved keyword? but nothing to do with automata
\l maybe better to rename local_or_param

Operands involving symbols refering to globals or procedures use the 
[[sym]] field of the union, while operands involving
parameters and local variables, also known as automatic variables,
use the [[autom]] field.
%
The [[Auto]] structure is used to keep track of the parameters
and locals accessed by a procedure:
\t what for? do some magic stuff? autosize?

% for locals or param symbols
<<struct Auto(arm)>>=
struct	Auto
{
    // enum<name_kind> (but N_LOCAL or N_PARAM only?)
    short	type;

    Sym*	asym;
    long	aoffset;

    // Extra
    <<[[Auto]] extra fields>>
};
@
\t rename Var?
\n Adr.sym vs Adr.autom.asym
\l aoffset is a repeat of the offset of the operand?
\t concrete example of value for an operand!!

Those procedure variables are chained together:

<<[[Auto]] extra fields>>=
Auto*	link;
@
\t what for? do some basic checks? like right autosize?

\l talk about curauto and autosize here?
\l  should be set to curauto for the TEXT instructions and its to Adr field

\section{[[Instr]]uction}

The type below connects an opcode with its operands to form
a full instruction:

<<struct Prog(arm)>>=
struct	Prog
{
    //enum<Opcode>
    byte	as;

    // operands
    Adr	from;
    Adr	to;

    <<[[Prog]] other fields>>

    // Extra
    <<[[Prog]] extra fields>>
};
@
\t bad name .... I think Prog is really an Instruction
%ocaml: could reuse type used by assembler, can put specificities
% outside the structure
%assembler: similar to the arguments of outcode():
%  - as (opcode), from (g1), to (g2), reg, scond, and
%    line field was a lineno global
%  - but some new fields: pc, mark
\l could rename cond to pcond and AB to AJMP and could factorize
\l  more code with x86
\n pseudo-opcode like ATEXT have operands too; from abused to store proc names
\l see Pconv percent P in printf

Most opcodes use two operands, transfering or processing data {\em from}
a source operand {\em to} a target operand, e.g. [[MOVW R1, (R2)]].
%
Some opcodes use three operands, e.g. [[ADD R1, R2, R3]]. 
In that case the middle operand is always a register, hence
the more specialized field below representing this middle operand:

<<[[Prog]] other fields>>=
// option<enum<registr>>, None = R_NONE
short	reg;
@
\n very arm specific!
\l This is used also to store TEXT attributes, e.g. DUPOK, NOPROF. 

All ARM instructions have a {\em conditional execution}
(see the \book{Assembler}):

<<[[Prog]] other fields>>=
// enum<instr_cond>
byte	scond;
@
\l also special bits

For debugging purpose, each instruction has also a 
{\em global line number}:

<<[[Prog]] other fields>>=
long	line;
@

\l When object is the result of the assembly generated by 5c the line 
\l is the line in the .c so many ASM instructions have actually the 
\l same line because one C expression can result in many ASM instructions.
\l a global line after #include. 
For more information on line numbers and debugging
see Chapter~\ref{chap:debugging}.

%trans:
Up until now, the [[Instr]] type is very similar to
the type used in the \book{Assembler} to represent
an instruction\footnote{[[5a]] actually uses
a set of parameters to the [[outcode()]] function
to represent an instruction. Each parameter
is identical to one of the field of [[Instr]].}.
%
The following field is new and specific to the linker.
It initially stores the {\em virtual program counter} of the instruction
(if the instruction is a code instruction, e.g. [[ADD]]):

<<[[Prog]] other fields>>=
long	pc;
@
\l The absolute pc of this instruction! 
\l needed for some check pc == p->pc somewhere.

The virtual program counter is incremented after each instruction
is read in [[ldobj()]].
%
Later in the linking process [[Instr.pc]] will be assigned
a {\em real program counter} which will be a multiple of 4 as the ARM
uses fixed-length instructions of 4 bytes.

Finally, the field below is used by different algorithms to
temporarily {\em mark} instructions in the graph of instructions:

<<[[Prog]] other fields>>=
//bitset<enum<mark>>
short	mark;
@
%old: was byte
% some generic tags to help some algoritms (e.g. for LEAF)

The different kinds of marks will be described gradually in
this document:

<<enum mark(arm)>>=
/* mark flags */
enum mark {
    <<enum mark cases>>
};
@
%dead: LABEL
%not-so-useful opti: FOLL
%useful opti: LEAF




%dead:
%<<[[Prog]] other fields>>=
%union
%{
%    long	regused;
%};
%@
% use anonymous union now, so don't need those aliases
%<<constant regused(arm)>>=
%#define	regused	u0.u0regused
%@
%<<constant forwd(arm)>>=
%#define	forwd	u0.u0forwd
%@
% now I just have a forward field, see mkfwd().

\section{List of instructions}
\l and instruction pointer?

%toc:
In this section we will see a set of globals keeping track
of different lists of instructions.

\t FIGURE where see evertything

\subsection{Code instructions, [[firstp/lastp]]}

[[firstp]] points to the first instruction
of the list of all {code instructions} 
(everything except the [[GLOBL]] and [[DATA]] pseudo-instructions):
\l includes TEXT, also does not include AEND and other stuff?

<<global firstp>>=
// list<ref_own<Prog>>, next = Prog.link
Prog*	firstp;
@
\l good name? first_instr better? rename instrp?

%dup: symbol table link
The instructions are linked together with the following field:

<<[[Prog]] extra fields>>=
// list<ref<Prog>> from firstp(/lastp), or datap
Prog*	link;
@

%dup: symbol table S
The end of the list is represented by the null pointer:

<<constant P>>=
#define	P		((Prog*)nil)
@

One can quickly access the end of the list by using the
following global:

<<global lastp>>=
// ref<Prog>, last elt of firstp list
Prog*	lastp;
@
%ocaml: use a queue data structure
\l strong coupling between firstp and lastp that should be encapsulated
\l   in a specific structure (like for datap/edatap)
% option<Prog>? usually there is a sentinel so there is always a lastp


\subsection{Data instructions, [[datap]]}

[[datap]] keeps track of the list of [[DATA]] pseudo-instructions:

<<global datap>>=
// list<ref<Prog>>, next = Prog.link
Prog*	datap = P;
@
\n no need for edatap in arm

[[datap]] points to the last data instruction. 
\l how access first? need first? no need because no order needed for data
Note that [[GLOBL]] instructions are not part of this list.
Instead, the [[GLOBL]] instructions modify the symbol table.

Thanks to [[firstp]] and [[datap]] all the code and
data instructions are separated in different {\em sections}.

\subsection{Procedure instructions, [[textp/etextp]]}

Another pair of globals keeps track of the 
list of procedures (the [[TEXT]] pseudo-instructions):

<<global textp>>=
// list<ref<Prog>>, next = Prog.cond (initially)
Prog*	textp = P;
@
<<global etextp>>=
// ref<Prog>, end of textp list
Prog*	etextp = P;
@

The procedure instructions are chained together initially with
another field of [[Instr]]:

<<[[Prog]] extra fields>>=
// list<ref<Prog>> from textp/etextp
Prog*	cond;
@
\l called pcond I think in x86, could choose same name

Later during the linking process, this field will be used
to build a {\em graph of instruction}. Branching instructions
will have their [[Instr.cond]] field points to the
target instruction.

The instructions in the list [[textp/etextp]]
are a subset of the list of instructionsin [[firstp/lastp]].


\section{Current instructions, [[curtext/curp]]}

During the linking process, we will iterate many times over
the list of all instructions. It is useful for error messages
to store in globals in which procedure we currently are ([[curtext]]) and 
which instruction we are currently processing ([[curp]]):
\n it's an error managment issue but it is too important to be delayed


<<global curtext>>=
//option<ref<Prog>> where Prog.as == ATEXT
Prog*	curtext = P;
@
\l there will be different curxxx, a bit ugly use of globals
\l curauto, curhist, curp

<<global curp>>=
// option<ref<Prog>>
Prog*	curp;
@
\l set only during iteration in asmb, but used in Pconv, diag messages, etc

Many algorithms will set [[curtext]] as follows while iterating
over instructions:

<<adjust curtext when iterate over instructions p>>=
if(p->as == ATEXT)
    curtext = p;
@
%old: I factorized code using this chunk more than what existed before
% by moving some curtext = p outside some if; it's sligtly slower
% but cleaner for LP purpose.

The [[TNAME]] macro (for [[T]]ext name) is used as an argument
to a few error managment functions to display the name of the
current procedure when there is one:

<<constant TNAME(arm)>>=
#define	TNAME (curtext && curtext->from.sym ? curtext->from.sym->name : noname)
@
<<global noname linker>>=
char	*noname		= "<none>";
@
\l firsp not necessarily a TEXT, even though for C programs it should be
\l  as anyway _main will call main (but could have labels that play tricks)



\t BIG figure where see pointers, relation with hash table, instr
\l  operands, etc.  see cond overloay over link

%---------------------------------------------

%\section{[[Exec]]utable}
% actually not used by 5l ...

%\section{[[Optab]] and [[optab]]}?
%hmm maybe better later

%\section{[[Operand_class]]}
%hmm maybe better later

%\section{[[Buf]] and [[buf]]}?
%hmm maybe better in appendix or later

%\section{[[pc]]}?

%\section{[[textsize]], [[datasize]], [[INITDAT]], ...}?








\chapter{Main Functions}
\label{chap:main}

%toc: %dup: (and adapted) from Assembler.nw
We now switch to a top-down approach where we describe
the main functions of [[5l]] starting from [[main()]]
down to [[asmb()]] which generates the executable.
\l well main in some sense is also generating the executable, hmm

\section{[[main()]]}

%trans: %dup: from Assembler.nw
Before showing the code of [[main()]] we first introduce
a few globals set by [[main()]].
%
A common pair of globals in \plan code
are [[thechar]] and [[thestring]] which both represent
the current architecture.
%dup: from intro/5l (and intro/5a)
As said in the introduction, \plan by convention 
represents architectures with a single character: 
[['0']] is MIPS, 
[['5']] is ARM, 
[['8']] is x86, etc.
%
This character is used by [[5l]]
for the filename extension of object files (e.g. [[hello.5]]): 
\l could be used also for 5.out but it is not.
\n actually in 5l thechar is almost not used, just for histfrogp stuff

<<global thechar>>=
char	thechar;
@

%dup: from Assembler
[[thestring]] contains the longer, more readable, version
of the architecture, e.g. [["arm"]] for [[5]].

<<global thestring>>=
char*	thestring;
@

This is used by [[5l]] to find the architecture specific 
library files in [[/arm/lib/]]
as explained in Section~\ref{sec:loading-libraries-semi-auto}.

Another important global is the name of the executable,
which by default is [[5.out]]
%dup: overview/5l
and can be modified with the [[-o]] option:

<<global outfile>>=
char*	outfile;
@
\l why global? could pass around? for error msg?

The file descriptor of the created executable file is
stored in the following global:

<<global cout>>=
fdt	cout = -1;
@
\n cout =~ create(outfile)
\l why need global for that? could be passed around too no?


%dup: (and adapted) from Assembler
We can now present the code of [[main()]], the entry point of [[5l]].
%
The most important thing is the chunk below the [[-- main functions --]]
comment which contains the main flow of [[5l]]. It will be
described soon in Section~\ref{sec:main-flow}:

<<function main(arm)>>=
void
main(int argc, char *argv[])
{
    <<[[main()]] locals(arm)>>

    thechar = '5';
    thestring = "arm";   

    outfile = "5.out";

    <<[[main()]] debug initialization(arm)>>

    ARGBEGIN {
    <<[[main()]] command line processing(arm)>>
    } ARGEND

    USED(argc);
    if(*argv == nil)
        usage();

    <<[[main()]] addlibpath("/{thestring}/lib") or ccroot>>
    <<[[main()]] set HEADTYPE, INITTEXT, INITDAT, etc>>
    <<[[main()]] set INITENTRY>>
    <<[[main()]] initialize globals(arm)>>

    cout = create(outfile, 1, 0775);
    <<[[main()]] sanity check cout>>

    // ------ main functions  ------
    <<[[main()]] cout is ready, LET'S GO(arm)>>

out:
    <<[[main()]] profile report>>
    errorexit();
}
@
%$
%old: set INITENTRY used to be in main flow after setting firstp/lastp
% but better here I think
\l mv initialize globals before? put all initialisations in it? order important?

<<function usage, linker>>=
void
usage(void)
{
    print("usage: %s [-options] objects", argv0);
    errorexit();
}
@
%old: was diag(...) but then output ??none?? which was ugly

<<[[main()]] sanity check cout>>=
if(cout < 0) {
    diag("cannot create %s: %r", outfile);
    errorexit();
}
@

The error managment functions [[diag()]] and [[errorexit()]]
are described in Appendix~\ref{chap:error}.
\l ex of output? 
\l %r is error return code of last syscall I think

\subsection{Arguments processing}

We have mentioned before the [[-o]] option:

<<[[main()]] command line processing(arm)>>=
case 'o':
    outfile = ARGF();
    break;
@

Other command line options will be introduced gradually
in this document. 
An important set of options deals with the executable format 
and are presented below.

\subsection{Executable format choice}
\label{sec:choice-exec-format}

One of the most important option of [[5l]] is
[[-H<num>]] which modifies the global [[HEADTYPE]]
recording the format of the executable:

<<global HEADTYPE>>=
// enum<Headtype>
short	HEADTYPE = -1; /* type of header */
@
%old: was int in ARM and long in x86, but I don't think it matters

<<[[main()]] command line processing(arm)>>=
case 'H':
    a = ARGF();
    if(a)
        HEADTYPE = atolwhex(a);
    /* do something about setting INITTEXT */
    break;
@
\l comment??

The [[atolwhex()]] function, described in Appendix~\ref{sec:atolwhex},
converts a string representing a number into a number. 
[[atolwhex()]] also handles numbers written in hexadecimal, hence the name.
This is not very useful for the [[-H]] option, but it will
be useful for other options such as [[-T]] we will see later.

By default [[5l]] uses the [[a.out]] format
which is the executable format used by \plan:

<<enum headtype(arm)>>=
/*
 *	-H0				      no header
 *	-H2 -T4128 -R4096	  is plan9 format
 *	-H7				      is elf
 */
enum Headtype {
     H_NOTHING = 0,
     H_PLAN9 = 2,
     H_ELF = 7,
};
@
%todo: H_OMACH, H_PE
%old:
% *	-H1 -T0x10005000 -R4  is aif for risc os
% *	-H3 -T0xF0000020 -R4  is NetBSD format
% *	-H4				      is IXP1200 (raw)
% *	-H5 -T0xC0008010 -R1024 	is ipaq
% *	-H6 -R4096			   no header with segments padded to pages

<<constant DEFAULT>>=
#define	H_DEFAULT	H_PLAN9
@
%pad: I added that, before there was some stuff with -9 -B -U
% plan 9, plan B, Unix?


The other executable formats, e.g. ELF, will be described later in 
Section~\ref{sec:other-executable-formats}.


The executable format dictates 
the size of the header as well as 
where the code and data sections will be loaded in memory
by setting the following globals:
%ocaml: has to be some globals? could not be passed to asmb? or in a struct?

<<global HEADR>>=
long	HEADR; 		/* length of header */
@
\n 32 for a.out (0x20)
\l long? really?

<<global INITTEXT>>=
long	INITTEXT = -1; /* text location */
@
\n -T text segment start virtual address (important! e.g. for kernel 0x7c00)

<<global INITRND>>=
long	INITRND = -1; 		/* data round above text location */
@
\n -R text segment rounder at r multiple

<<global INITDAT>>=
long	INITDAT = -1; /* data location */
@
\n -D data segment start
\n normally after end of text, so dynamic



<<[[main()]] set HEADTYPE, INITTEXT, INITDAT, etc>>=
if(HEADTYPE == -1) {
    HEADTYPE = H_DEFAULT;
}
switch(HEADTYPE) {
<<[[main()]] switch HEADTYPE cases(arm)>>
default:
    diag("unknown -H option");
    errorexit();
}
<<[[main()]] sanity check INITXXX>>
DBG("HEADER = -H%d -T0x%lux -D0x%lux -R0x%lux\n",
        HEADTYPE, INITTEXT, INITDAT, INITRND);
@
%old: was -H0x%d but no sense
\l could put HEADTYPE=DEFAULT_HEADTYPE;


<<[[main()]] switch HEADTYPE cases(arm)>>=
case H_PLAN9:
    HEADR = 32L;
    if(INITTEXT == -1)
        INITTEXT = 4096+32; // 1 page + a.out header
    if(INITDAT == -1)
        INITDAT = 0;
    if(INITRND == -1)
        INITRND = 4096; // 1 page
    break;
@
\n 32 = 0x20 hence this note in kernel mkfile:
%# see mem.h, the additional 20 are the size of the a.out header added by LD
%KTZERO_AND_HEADER=0xE0100020

\t DBG explained in debugging-appendix, opportunity to explain -v,
\l and shows output?


[[INITDAT]] is initially set to 0 but it will be modified later
by [[dotext()]] to contain the address of the next memory page
after the code section.
\l different page so can have different bits in kernel

One can also manually set the start of the code and data sections, 
%dup: intro/5l
which is useful when producing special binaries such as kernels
or boot loaders:

<<[[main()]] command line processing(arm)>>=
case 'T':
    a = ARGF();
    if(a)
        INITTEXT = atolwhex(a);
    break;
case 'D':
    a = ARGF();
    if(a)
        INITDAT = atolwhex(a);
    break;
@
\l here useful atolwhex

<<[[main()]] command line processing(arm)>>=
case 'R':
    a = ARGF();
    if(a)
        INITRND = atolwhex(a);
    break;
@


<<[[main()]] sanity check INITXXX>>=
if(INITDAT != 0 && INITRND != 0)
    print("warning: -D0x%lux is ignored because of -R0x%lux\n",
        INITDAT, INITRND);
@
\l less important I think


\subsection{Executable entry point}
\label{sec:choice-entry-point}

The entry point of a program can also be modified
with the [[-E]] option:

<<global INITENTRY>>=
char*	INITENTRY = nil;		/* entry point */
@
<<[[main()]] command line processing(arm)>>=
case 'E':
    a = ARGF();
    if(a)
        INITENTRY = a;
    break;
@
\n -E default _main (or _mainp when -p)

%dup: introl/5l, overview/hello.5
It is set by default to [[_main]] under \plan, 
for reasons explained in Section~\ref{sec:explain-_main}:

<<[[main()]] set INITENTRY>>=
if(INITENTRY == nil) {
    INITENTRY = "_main";
    <<[[main()]] adjust INITENTRY if profiling>>
}
<<[[main()]] if rare condition do nothing, else>>
  lookup(INITENTRY, 0)->type = SXREF;
@
%old: this was done originally after setting firstp below, but
% better put that earlier I think
%old: the code before was more complex IMHO
% <<[[main()]] set INITENTRY>>=
% if(INITENTRY == nil) {
%     INITENTRY = "_main";
%     <<[[main()]] adjust INITENTRY if profiling>>
%     <<[[main()]] adjust INITENTRY if load_libs>>
% } else {
%     <<[[main()]] if digit INITENTRY>>
% }
% @
% <<[[main()]] adjust INITENTRY if load_libs>>=
% if(load_libs)
%     lookup(INITENTRY, 0)->type = SXREF;
% @
% <<[[main()]] if digit INITENTRY>>=
% if(!(*INITENTRY >= '0' && *INITENTRY <= '9'))
%    lookup(INITENTRY, 0)->type = SXREF;
% @
% The SXREF setting is done only when load_libs and only in the then branch.
% But why not do lookup and set to SXREF the entry point all the time?
% Why only when load_libs? and why not for digit INITENTRY?
% Because if use -l we want possibly INITENTRY to be first instruction?
\t real reason? first obj is entry point? but could -E _start no?

Unless some rare conditions we will explained in 
Section~\ref{sec:loading-libraries-magically},
the symbol for the entry point (usually [[_main]])
is looked up. 
\t remember 0 is for version, and global symbol use 0
This will create a new symbol in the symbol table [[hash]]
as the symbol table is empty at the beginning.
Then, by setting its section to [[SXREF]], the symbol for the entry
point is marked as a ``wanted'' symbol.
\l bootstrap!
Hopefully the object files or libraries passed on the command
line to [[5l]] will define this symbol. Otherwise,
because of [[SXREF]], an error message will be displayed
at the very end by, for instance:

\begin{verbatim}
$ 5l no_main.5
??none??: entry not text: _main
??none??: _main: not defined
\end{verbatim}

\l By creating a new entry and setting it to SXREF (default is SNONE) we will
\l force in loadlib() to consider _main as a starting point as we marked
\l it as an undefined (undefined but looked for!).


\subsection{Main flow}
\label{sec:main-flow}

%trans:
We can finally present the main control flow of [[5l]] with
the calls to its main {components}. 
%
The code below follows closely the software architecture
we described in Section~\ref{sec:soft-archi}:

<<[[main()]] cout is ready, LET'S GO(arm)>>=
// first empty instruction
firstp = prg();
lastp = firstp;

// Loading (populates firstp/lastp, datap, textp/etextp, and hash)
while(*argv)
    objfile(*argv++);
<<[[main()]] load implicit libraries>>

// skip first empty instruction
firstp = firstp->link;
if(firstp == P)
    goto out;

// Resolving
<<[[main()]] resolving phases>>

// Generating (writing to cout, finally)
asmb();

// Checking
undef();
@
%old: used to have set INITENTRY here, but better before I think
\l why goto out? then 5l world.5 does not call undef and does not complain
\l  but lack of _main
\l could have a function link() just like have assemble() in Assembler.nw?
\l  use stuff from main? then maybe good, can pass them around, more explicit
%ocaml: all those functions that take no args are ugly, they use too
% many globals, e.g. firstp, lastp, I should really rewrite the code
% to be more functional.

The code 
{\em loads} the object files and libraries passed on the command line
(as well as possibly other ``implicit'' libraries as explained in 
Section~\ref{sec:loading-libraries-magically}),
{\em resolve} symbols, 
{\em generate} the executable, and finally 
{\em check} if there is still some undefined symbols
(e.g. whether [[_main]] has been found).
%
The first line allocates an empty instruction with [[prg()]].
This first instruction is used as a {\em sentinel} which simplifies 
code modifying later [[firstp/lastp]]. 
This first empty instruction is then skipped a few lines later.
%
[[prg()]] uses the global [[zprg]] which is set to represent an empty
instruction:

<<constructor prg>>=
Prog*
prg(void)
{
    Prog *p;

    p = malloc(sizeof(Prog));
    *p = zprg;
    return p;
}
@
\l rename! new_instr?

<<global zprg>>=
Prog	zprg;
@
\n zero prg, to initialize new Prog

<<[[main()]] initialize globals(arm)>>=
<<[[main()]] set zprg(arm)>>
@

<<[[main()]] set zprg(arm)>>=
zprg.as = AGOK;
zprg.scond = COND_ALWAYS; 
zprg.reg = R_NONE;
zprg.from.type = D_NONE;
zprg.from.symkind = N_NONE;
zprg.from.reg = R_NONE;
zprg.to = zprg.from;
@
\t BUGS not defined other fields?
%bug: what about .class? should be set to C_NONE no?
%bug? and optab? should be null no? there is code using p->optab like oplook()

All of the constants above, e.g. [[R_NONE]], are defined
in [[include/arch/arm/5.out.h]].
%
[[AGOK]] (God Only Knows) is an opcode representing an 
{undefined instruction}.
It is recognized by some error managment code in [[5l]]
and used as a form of {defensive programming}.
%ocaml: do not need that I think. typing and exhaustic check is better
% than defensive programming
\l sure it means god Only Knows? 
\l could use AXXX? or ANOP? 
\t actually 5c generates some AGOK, but to continue even when error (meh?)

%toc:
The following sections will each describe one of the
component of [[5l]] mentioned in the main flow above.

\section{Loading the objects and libraries, [[objfile()]]}

[[objfile()]] takes either the name of 
an object file (e.g. [[foo.5]])
or a library (e.g. [[libc.a]])
and reads the object code in it.
%
First, [[objfile()]] opens and reads a few bytes of the file to decide
whether it is an archive or an object file 
\l why not use filename extension to decide?
by checking if those bytes match an archive magic string ([[ARMAG]]).
%
Then it loads the file.
The code below shows only the simple case where the file is an object file:


<<function objfile>>=
// main | loadlib  -> <>
void
objfile(char *file)
{
    fdt f;
    long l;
    char magbuf[SARMAG];
    <<[[objfile()]] other locals>>

    DBG("%5.2f objfile: %s\n", cputime(), file);

    <<[[objfile()]] adjust file if -lxxx filename>>

    f = open(file, 0);
    <<[[objfile()]] sanity check f>>

    l = read(f, magbuf, SARMAG);

    // is it a regular object (and not a library)
    if(l != SARMAG || strncmp(magbuf, ARMAG, SARMAG)){
        /* load it as a regular file */
        l = seek(f, 0L, SEEK__END);
        seek(f, 0L, SEEK__START);

        // the important call!
        ldobj(f, l, file);

        close(f);
        return;
    }

    <<[[objfile()]] when file is a library>>
}
@
\l rename objfile -> ldobj and ldobj -> ldinstrs
\l  as it can actually load a slice of an object, just a procedure
\n portable function! (ldobj is not though)

[[SARMAG]] above stands for Size of ARchive MAGic string.
%
The more complex case where the file is a library will
be described in Chapter~\ref{chap:loading-libraries}.
%
The most important part in the code above is the call
to [[ldboj()]] which loads in memory one object file.
\l or part of a library seeked to right place
Chapter~\ref{chap:loading-objects} will describe [[ldobj()]].

\l essentially modify which globals?
\l  - should modify firstp! and textp, datap, lastp, etc
\l  - will modify libraryp probably, the cool pragma "autolib"
\l    which is why objfile() must be called before loadlib()



<<[[objfile()]] sanity check f>>=
if(f < 0) {
    diag("cannot open %s: %r", file);
    errorexit();
}
@

\section{Resolving symbols, computing addresses}

%trans:
The next step after loading the objects is to resolve
the symbol references in it and to compute the final address
of those symbols.
%
We will delay the explanations about this step to
Chapter~\ref{chap:resolving} where multiple functions
are used to do different passes on the set of instructions.
\l use firstp/lastp, use hash, build graph of instruction, layout

\section{Generating the executable, [[asmb()]]}
\label{sec:gen-executable}
\l asmb? asm binary? meh

%trans:
% first function to actually use cout!

<<function asmb(arm)>>=
void
asmb(void)
{
    <<[[asmb()]] locals>>

    DBG("%5.2f asm\n", cputime());

    // TEXT SECTION
    <<[[asmb()]] TEXT section>>

    // DATA SECTION
    <<[[asmb()]] DATA section>>

    // SYMBOL AND LINE TABLE
    <<[[asmb()]] symbol and line table section>>

    // HEADER
    <<[[asmb()]] header section>>

    cflush();
}
@
% HEADER section at the end, paradoxal, but do SEEK, and because
% the HEADER contain info about other sections such as size, so need
% to know those size first.
% no BSS section because the binary executable will not contain
% anything related to BSS except its size.


<<[[asmb()]] locals>>=
long OFFSET;
@
%old: was a global but can not just be a local in asmb()
% <<global OFFSET(arm)>>=
% long	OFFSET;
% @



\subsection{Header}

% see Exec struct in Overview.

<<[[asmb()]] header section>>=
DBG("%5.2f header\n", cputime());

OFFSET = 0;
seek(cout, OFFSET, SEEK__START);

switch(HEADTYPE) {
// see Exec in a.out.h
case H_PLAN9:
    <<[[asmb()]] if dynamic module magic header adjustment(arm)>>
    else
        lput(0x647);			/* magic */

    lput(textsize);			/* sizes */
    lput(datsize);
    lput(bsssize);
    lput(symsize);			/* nsyms */
    lput(entryvalue());		/* va of entry */
    lput(0L);
    lput(lcsize);
    break;
<<[[asmb()]] switch HEADTYPE (for header generation) cases(arm)>>
}
@
% all those xxxsize are globals, modified by previous phases
% s/0x647/E_MAGIC?


% less: could at least take initentry as a parameter instead of using a global
<<function entryvalue(arm)>>=
long
entryvalue(void)
{
    char *a;
    Sym *s;

    a = INITENTRY; // usually "_main"
    <<[[entryvalue()]] if digit INITENTRY>>

    s = lookup(a, 0);

    switch(s->type) {
    case SNONE:
        return INITTEXT; // no _main, start at beginning of binary then
    case STEXT: case SLEAF:
        return s->value;
    <<[[entryvalue()]] if dynamic module case>>
    default:
        diag("entry not TEXT: %s", s->name);
        return 0;
    }
}
@


\subsection{Text section}

<<[[asmb()]] locals>>=
Prog *p;
Optab *o;
@

% arm specficic
<<global autosize(arm)>>=
long	autosize;
@
% size for the locals? (and params?)
% used a lot by aclass()
%less: could be renamed curautosize

%less: have a <<adjust autosize when iterate over p thing>> ?


% important call, asmout()
<<[[asmb()]] TEXT section>>=
OFFSET = HEADR;
seek(cout, OFFSET, SEEK__START);
pc = INITTEXT;

for(p = firstp; p != P; p = p->link) {
    <<adjust curtext when iterate over instructions p>>
    if(p->as == ATEXT) {
        autosize = p->to.offset + 4; // locals
    }
    <<[[asmb()]] when in TEXT section, sanity check pc>>
    curp = p;

    // generate instruction!
    o = oplook(p);	/* could probably avoid this call */
    asmout(p, o);

    pc += o->size;
}

<<[[asmb()]] before cflush, debug>>
cflush();

<<[[asmb()]] TEXT section, output strings in text segment>>
}
@
% +4? locals + RETURN? see "runtime conventions" section.
%less: "could avoid this call" because could just use p->optab?
% but it actually uses optab ... oplook() memoize things.



<<[[asmb()]] when in TEXT section, sanity check pc>>=
if(p->pc != pc) {
    diag("phase error %lux sb %lux", p->pc, pc);
    if(!debug['a'])
        prasm(curp);
    pc = p->pc;
}
@
% span() and asmb() should compute the same pc values


\subsection{Data section}

% important call, datblk()
<<[[asmb()]] DATA section>>=
curtext = P;
switch(HEADTYPE) {
case H_PLAN9:
    OFFSET = HEADR+textsize;
    seek(cout, OFFSET, SEEK__START);
    break;
<<[[asmb()]] switch HEADTYPE (to position after text) cases(arm)>>
}

<<[[asmb()]] if dynamic module, before datblk()>>

for(t = 0; t < datsize; t += sizeof(buf)-100) {
    if(datsize-t > sizeof(buf)-100)
        datblk(t, sizeof(buf)-100, false);
    else
        datblk(t, datsize-t, false);
}
@
% what the fuss about those 100?? and what is sizeof(buf)?
\t factorize code for those sizeof(buf)-100

<<[[asmb()]] locals>>=
long t, etext;
@

% it's an opti? need that? put later?
<<[[asmb()]] TEXT section, output strings in text segment>>=
/* output strings in text segment */
etext = INITTEXT + textsize;
for(t = pc; t < etext; t += sizeof(buf)-100) {
    if(etext-t > sizeof(buf)-100)
        datblk(t, sizeof(buf)-100, true);
    else
        datblk(t, etext-t, true);
@

\subsection{Symbol and line table section}

% important call: asmlc()?
<<[[asmb()]] symbol and line table section>>=
// modified by asmsym()
symsize = 0;
// modified by asmlc()
lcsize = 0;

if(!debug['s']) {
    switch(HEADTYPE) {
    case H_PLAN9:
        OFFSET = HEADR+textsize+datsize;
        seek(cout, OFFSET, SEEK__START);
        break;
    <<[[asmb()]] switch HEADTYPE (for symbol table generation) cases(arm)>>
    }

    DBG("%5.2f sym\n", cputime());
    asmsym();

    DBG("%5.2f pc\n", cputime());
    asmlc();

    <<[[asmb()]] if dynamic module, call asmdyn()>>

    cflush();
}
else {
    <<[[asmb()]] if dynamic module and no symbol table generation>>
}
@



\section{Checking for unresolved symbols, [[undef()]]}
\label{sec:undef}

% rename check_if_still_undefined_symbols()?
<<function undef>>=
void
undef(void)
{
    int i;
    Sym *s;

    for(i=0; i<NHASH; i++)
        for(s = hash[i]; s != S; s = s->link)
            if(s->type == SXREF)
                diag("%s: not defined", s->name);
}
@







\chapter{Loading Objects}
\label{chap:loading-objects}

%trans:
% seen main flow, but many functions, e.g. ldobj.
% start here linking pipeline

%note: was called parsing, but objects are stored in a binary format so
% "loading" is more appropriate I think

% does reverse operation than object generation in Assembler.nw, and more!

%less: hmmm if C had proper ADT and a Marshall module that would be easier ...
% (but maybe less other-languages friendly)
%less: could factorize code with libmach?
% why not using 5obj.c from libmach/? because 5obj.c is incomplete?
% because it cares just about the symbol table?

\section{Object format}
\label{sec:object-format}
% again ... repeat Assembler.nw section?

% FIGURE but with ANAME and AHISTORY maybe

\section{Buffered input, [[buf]]}

% See buffer managment appendix,
% essentially this buf global! and buf.ibuf  which is is input buffer.

<<[[ldobj()]] locals(arm)>>=
byte *bloc;
byte *bsize;
int r;
@
% and parameter 'int c'
% bloc[xxx] will be what we will read from below in ldobj()

<<[[ldobj()]] bloc and bsize init>>=
bsize = buf.ibuf;
bloc = buf.ibuf;
@


<<[[ldobj()]] read if needed in loop:, adjust bloc and bsize>>=
r = bsize - bloc;
if(r < 100 && r < c) {		/* enough for largest prog */
    bsize = readsome(f, buf.ibuf, bloc, bsize, c);
    if(bsize == 0)
        goto eof;
    bloc = buf.ibuf;
    goto loop;
}
@
% >> >> >> >>
% readsome() is in appendix too

\section{A global and local program counter, [[pc]] and [[ipc]]}

% each instruction read in ldobj() will increment this pc
<<global pc>>=
long	pc = 0;
@

% internal pc? objects are loaded after each other,
% but when had a local D_BRANCH then need now to adjust to a global value
<<[[ldobj()]] locals(arm)>>=
long ipc;
@
% so set to current pc when at the beginning of object


% This is for the N_INTERN; to handle conflicts with different files
% defining the same static entity. This is bumped each time
% a new object file is parsed, so it's safe.
<<global version>>=
int	version = 0;
@

\section{Instructions input, [[ldobj()]]}


\t incode? so opposite of outcode? (but it was not good name either)

<<[[ldobj()]] locals(arm)>>=
// enum<opcode>
short o;
Prog *p;
@
% the instruction p will be allocated

<<[[ldobj()]] locals(arm)>>=
bool skip;
@
% If set to true then generate a NOP actually for the currently
% read instruction. Used for DUPOK for instance.


% f = fd of opened object file
% c = size of object file, 
% pn = filename of object, 
<<function ldobj(arm)>>=
/// main -> objfile -> <>
void
ldobj(fdt f, long c, char *pn)
{
    <<[[ldobj()]] locals(arm)>>

    <<[[ldobj()]] remember set of object filenames>>
    <<[[ldobj()]] bloc and bsize init>>

// can come from AEND
newloop:
    ipc = pc;
    version++;
    skip = false;

    memset(h, 0, sizeof(h));
    histfrogp = 0;

loop:
    if(c <= 0)
        goto eof;

    <<[[ldobj()]] read if needed in loop:, adjust bloc and bsize>>

    o = bloc[0];		/* as */
    <<[[ldobj()]] sanity check opcode in range(arm)>>

    <<[[ldobj()]] if ANAME or ASIGNAME(arm)>>

    p = malloc(sizeof(Prog));
    p->as = o;
    // reading the object binary file, opposite of outcode() in Assembler.nw
    <<[[ldobj()]] read one instruction in p>>
    <<[[ldobj()]] sanity check p>>
    <<[[ldobj()]] debug>>

    switch(o) {
    <<[[ldobj()]] switch opcode cases(arm)>>

    default:
    casedef:
        if(skip)
            nopout(p);

        // putting each object after each other, local offset become global
        if(p->to.type == D_BRANCH)
            p->to.offset += ipc;

        //add_queue(firstp, lastp, p)
        lastp->link = p;
        lastp = p;

        p->pc = pc;
        pc++;
        break;
    }
    goto loop;

eof:
    diag("truncated object file: %s", pn);
}
@
%bugfix: again on gethunk, was doing if(nhunk < ...) instead of while(nhunk...)
% the bug seems only in arm, x86 does the correct while
% but forsyth say anyway a hunk is begger than a Prog so a if would work too

%hmm when exit from this function without an error?
% via AEND! that does have a return!

%todo:how does p->to.offset += ipc; works with library code?
% in objfile it seems we seek to the TEXT procedure we want but
% this procedure may not be the beginning of the object, and
% the D_BRANCH offsets are based on the beginning of the object file no?







<<[[ldobj()]] read one instruction in p>>=
p->scond = bloc[1];
p->reg   = bloc[2];
p->line  = bloc[3] | (bloc[4]<<8) | (bloc[5]<<16) | (bloc[6]<<24);
r = 7;
r += zaddr(bloc+7, &p->from, h);
r += zaddr(bloc+r, &p->to, h);

bloc += r;
c -= r;

p->link = P;
p->cond = P;
@
% >> >> >>


<<[[ldobj()]] sanity check opcode in range(arm)>>=
if(o <= AXXX || o >= ALAST) {
    diag("%s: line %ld: opcode out of range %d", pn, pc-ipc, o);
    print("	probably not a .5 file\n");
    errorexit();
}
@

<<[[ldobj()]] sanity check p>>=
if(p->reg > NREG)
    diag("register out of range %d", p->reg);
@



%\section{[[AGOK]]}
% can happen? I think we can remove it, 5c can't produce such opcodes. Can it?
% another kind of sanity check:
<<[[ldobj()]] switch opcode cases(arm)>>=
case AGOK:
    diag("unknown opcode\n%P", p);
    p->pc = pc;
    pc++;
    break;
@
%x86:     diag("%s: GOK opcode in %s", pn, TNAME);



% for e.g. ATEXT that are DUPOK
<<function nopout>>=
void
nopout(Prog *p)
{
    p->as = ANOP;
    p->from.type = D_NONE;
    p->to.type = D_NONE;
}
@
% why care about .type? because some code is look for
% D_BRANCH, for symbols, and so putting D_NONE ensure those
% code will not be triggred for what was transformed in NOP.





\section{Operand input, [[zaddr()]]}

<<[[zaddr()]] locals>>=
int c; // symidx
int size;
@

% mostly reverse of zaddr() in Assembler.nw 
\t inopd?
% ldobj -> <>
% return number of bytes read to read this Adr
<<function zaddr(arm)>>=
int
zaddr(byte *p, Adr *a, Sym *h[])
{
    <<[[zaddr()]] locals>>

    a->type = p[0];
    a->reg = p[1];
    c = p[2];
    <<[[zaddr()]] sanity check symbol range>>
    a->sym = h[c];
    a->symkind = p[3];

    size = 4;

    <<[[zaddr()]] sanity check register range>>

    switch(a->type) {
    <<[[zaddr()]] cases>>
    default:
        print("unknown type %d\n", a->type);
        p[0] = ALAST+1;
        return 0;	/*  force real diagnostic */

    }
    <<[[zaddr()]] adjust curauto for N_LOCAL or N_PARAM symkind>>

    return size;
}
@


<<[[zaddr()]] cases>>=
case D_NONE:
case D_REG:
case D_PSR:
    break;

case D_REGREG:
    a->offset = p[4];
    size++;
    break;

case D_CONST:
case D_SHIFT:
case D_OREG:
case D_BRANCH:
    a->offset = p[4] | (p[5]<<8) | (p[6]<<16) | (p[7]<<24);
    size += 4;
    break;

case D_SCONST:
    a->sval = malloc(NSNAME);
    memmove(a->sval, p+4, NSNAME);
    size += NSNAME;
    break;
@
%//case D_OCONST: was with D_SHIFT
% >> >> >> >>









<<[[zaddr()]] sanity check symbol range>>=
if(c < 0 || c > NSYM){
    print("sym out of range: %d\n", c);
    p[0] = ALAST+1;
    return 0;
}
@
% not sure those p[0] have any effects

<<[[zaddr()]] sanity check register range>>=
if(a->reg < 0 || a->reg > NREG) {
    print("register out of range %d\n", a->reg);
    p[0] = ALAST+1;
    return 0;	/*  force real diagnostic */
}
@


\section{adjusting [[curauto]]}

% parameters + locals list
<<global curauto>>=
Auto*	curauto;
@
% set for the first time where? bug? should be = nil?


<<[[zaddr()]] locals>>=
int t, l;
Sym *s;
Auto *u;
@
%old: t was i, but t(ype) better than i


<<[[zaddr()]] adjust curauto for N_LOCAL or N_PARAM symkind>>=
s = a->sym;
t = a->symkind;
l = a->offset;

if(s == S || (t != N_LOCAL && t != N_PARAM))
    return size;

for(u=curauto; u; u=u->link)
    if(u->asym == s)
     if(u->type == t) {
        if(u->aoffset > l)
            u->aoffset = l;
        return size;
    }

u = malloc(sizeof(Auto));
u->asym = s;
u->type = t;
u->aoffset = l;

//add_list(u, curauto)
u->link = curauto;
curauto = u;
@


\section{[[ATEXT]]}

% abuse from = symbolname, to = immediate constant size for locals

<<[[ldobj()]] switch opcode cases(arm)>>=
case ATEXT:
    <<[[ldobj()]] case ATEXT, if curtext not null adjustments for curauto>>
    curtext = p;

    skip = false; // needed?

    autosize = (p->to.offset+3L) & ~3L;
    p->to.offset = autosize;
    autosize += 4;

    s = p->from.sym;

    <<[[ldobj()]] sanity check for ATEXT symbol s>>

    s->type = STEXT;
    s->value = pc;

    // like in default case
    //add_queue(firstp, lastp, p)
    lastp->link = p;
    lastp = p;

    p->pc = pc;
    pc++;

    //add_queue(textp, etextp, p)
    if(textp == P) {
        textp = p;
        etextp = p;
    } else {
        etextp->cond = p;
        etextp = p;
    }
    break;
@
%$
% "virtual pc"

<<[[ldobj()]] sanity check for ATEXT symbol s>>=
if(s == S) {
    diag("TEXT must have a name\n%P", p);
    errorexit();
}
if(s->type != SNONE && s->type != SXREF) {
    <<[[ldobj()]] case ATEXT and section not SNONE or SXREF, if DUPOK>>
    diag("redefinition: %s\n%P", s->name, p);
}
@

<<[[ldobj()]] case ATEXT, if curtext not null adjustments for curauto>>=
if(curtext != P) {
    <<[[ldobj()]] case ATEXT, curauto adjustments with curhist>>
    curtext->to.autom = curauto;
    curauto = nil;
}
@

% +4 for ? saved PC? what about saved SP? when RET?
% assumes caller saves/restores SP?


\section{[[AGLOBL]]}

% not added in any list? because bss?

<<[[ldobj()]] switch opcode cases(arm)>>=
case AGLOBL:
    s = p->from.sym;

    <<[[ldobj()]] sanity check for AGLOBL symbol s>>

    s->type = SBSS; // for now SBSS; will be set maybe to SDATA in dodata()
    s->value = 0;
    if(p->to.offset > s->value)
        s->value = p->to.offset;
    break;
@
% what is offset for AGLOBL? It should be the immediate constant size of 
% the global. But how can s->value be different from 0 anyway?
% the test p->to.offset > s->value seems to always return true to me.
% or it's just to sanity check people entering negative size for the globals?

<<[[ldobj()]] sanity check for AGLOBL symbol s>>=
if(s == S) {
    diag("GLOBL must have a name\n%P", p);
    errorexit();
}
if(s->type != SNONE && s->type != SXREF)
    diag("redefinition: %s\n%P", s->name, p);
@
%pad: the second check used to be written differently, but I prefer
% it this way to mimic more what we do for ATEXT

\section{[[ADATA]]}

<<[[ldobj()]] switch opcode cases(arm)>>=
case ADATA:
    <<[[ldobj()]] sanity check for ADATA symbol s>>

    //add_queue(datap, p)
    p->link = datap;
    datap = p;

    break;
@
% no s->type = SDATA? it's done in dodata()

<<[[ldobj()]] sanity check for ADATA symbol s>>=
if(p->from.sym == S) {
    diag("DATA without a sym\n%P", p);
    break;
}
@

\section{[[AEND]]}

<<[[ldobj()]] switch opcode cases(arm)>>=
case AEND:

    <<[[ldobj()]] case AEND, curauto adjustments with curhist>>
    <<[[ldobj()]] case AEND, curauto adjustments>>

    if(c)
        goto newloop;
    return;
@
% when goto newloop? when have stuff behind an AEND?
% for library? aggregate to have AEND between files?

<<[[ldobj()]] case AEND, curauto adjustments>>=
if(curtext != P)
    curtext->to.autom = curauto;
curauto = nil;
curtext = P;
@


\section{Symbol table, [[ANAME]]}
% and [[ASIGNAME]]
% spreaded symbol table


<<[[ldobj()]] locals(arm)>>=
byte *stop;
@

<<[[ldobj()]] locals(arm)>>=
Sym *h[NSYM];
Sym *s;
@

<<[[ldobj()]] locals(arm)>>=
int v;
@

% it's not part of the switch, it's done before!
<<[[ldobj()]] if ANAME or ASIGNAME(arm)>>=
if(o == ANAME || o == ASIGNAME) {
    sig = 0;
    <<[[ldobj()]] if SIGNAME adjust sig>>

    stop = memchr(&bloc[3], '\0', bsize-&bloc[3]);
    <<[[ldobj()]] if stop is nil refill buffer and retry>>

    v = bloc[1];	/* type */
    o = bloc[2];	/* sym */
    bloc += 3;
    c -= 3;

    r = 0;
    if(v == N_INTERN)
        r = version;

    s = lookup((char*)bloc, r);

    c -= &stop[1] - bloc;
    bloc = stop + 1;

    <<[[ldobj()]] if sig not zero>>
    <<[[ldobj()]] when ANAME, debug>>

    h[o] = s;

    if((v == N_EXTERN || v == N_INTERN) && s->type == SNONE)
        s->type = SXREF;

    <<[[ldobj()]] when ANAME opcode, if D_FILE>>
    goto loop;
}
@
% SXREF! so mark the symbol as "we want to find its definition!" for
% objfile() and loadlib() to correctly work!

% buffer managment crap again
<<[[ldobj()]] if stop is nil refill buffer and retry>>=
if(stop == nil){
    bsize = readsome(f, buf.ibuf, bloc, bsize, c);
    if(bsize == 0)
        goto eof;
    bloc = buf.ibuf;
    stop = memchr(&bloc[3], '\0', bsize-&bloc[3]);
    if(stop == nil){
        fprint(2, "%s: name too long\n", pn);
        errorexit();
    }
}
@
% >> >>

\section{Safe linking with [[ASIGNAME]]}
% put in advanced topics? At the same time safe linking is
% an essential feature to me
%note: cool, like in ocamlc! ocaml does that too, to make linking more safe!

%todo: how disable this check? I think you can't, the only
% way is to not generate those ASIGNAME in the first place
% in the compiler by not adding -T to the compiling flags

% ASIGNAME is a pseudo opcode generated by 5c.
% when 2 .c include some .h and reference an object, we
% want that they refer to the same object with the same type!

<<[[Sym]] other fields>>=
// md5sum of the type of the symbol
long	sig;
@

<<[[ldobj()]] locals(arm)>>=
ulong sig;
@

<<[[ldobj()]] if SIGNAME adjust sig>>=
if(o == ASIGNAME){
    sig = bloc[1] | (bloc[2]<<8) | (bloc[3]<<16) | (bloc[4]<<24);
    bloc += 4;
    c -= 4;
}
@
% >> >> >> >>


% s = ? symbol set in ldobj() to be?
<<[[ldobj()]] if sig not zero>>=
if(sig != 0){
    if(s->sig != 0 && s->sig != sig)
        diag("incompatible type signatures %lux(%s) and %lux(%s) for %s", s->sig, filen[s->file], sig, pn, s->name);
    s->sig = sig;
    s->file = files-1;
}
@



% local, but really kinda globals
<<[[ldobj()]] locals(arm)>>=
// growing_array<filename>  (grown for every 16 elements)
static char **filen;
// index of next free entry in filen
static int files = 0;
@

<<[[Sym]] other fields>>=
// idx in filen
ushort	file;
@


<<[[ldobj()]] remember set of object filenames>>=
<<[[ldobj()]] grow filen if not enough space>>
filen[files++] = strdup(pn);
@



% new filen (not a static this time)
<<[[ldobj()]] locals(arm)>>=
char **nfilen;
@

% =~ realloc
<<[[ldobj()]] grow filen if not enough space>>=
if((files&15) == 0){
    nfilen = malloc((files+16)*sizeof(char*));
    memmove(nfilen, filen, files*sizeof(char*));
    free(filen);
    filen = nfilen;
}
@

%\section{File and line information, [[AHISTORY]]}
% see debugging section



\chapter{Loading Libraries}
\label{chap:loading-libraries}

% 5l actually loads only the object files in the librairies containing 
% the functions/data which are mentionned by the main object files
% (starting from _main).
% So it removes lots of code which helps generate small binaries 
% (see helloc which is only 4618 bytes).
% Note that the granularity is the object file; if it was the function/data
% it could remove even more code.

% see 5l -W -v helloc.5 to see the different passes, which symbols
% are needed, which object files in the archive are read, which ANAME
% are processed, etc.

\section{[[ar]] format}

% see ar(5) man page

% from ar.h
<<constant ARMAG>>=
#define	ARMAG	"!<arch>\n"
@
% ARchive MAGic?

<<constant SARMAG>>=
#define	SARMAG	8
@
%size ARMAG

<<constant ARFMAG>>=
#define	ARFMAG	"`\n"
@
% ARchive F? MAGic
% separator between each ar_hdr entries?

<<constant SARNAME>>=
#define SARNAME	16
@
%size ARNAME
% so can't have symbol names of more than 16 characters?

% seems to be the symbol file header and also each file entry header
<<struct ar_hdr>>=
struct	ar_hdr
{
    char	name[SARNAME];

    char	date[12];
    char	uid[6];
    char	gid[6];
    char	mode[8];

    char	size[10]; // use atolwhex() to get the value
    char	fmag[2]; // ARFMAG
};
@
%less: s/char/byte!

% an archive contains:
% MAGIC header "<arch"
% symbol table which is a kind of map from symbol to file entry offset
% file entry header
% object file content
% file entry header
% object file content
% ...

<<constant SAR_HDR>>=
#define	SAR_HDR	(SARNAME+44)
@
% sizeof(struct ar_hdr)


<<global symname linker>>=
char	symname[]	= SYMDEF;
@
% in 5.out.h #define	SYMDEF "__.SYMDEF"
% the first ar_hdr entry is the symbol table.

%todo: What is the format of the symbol table?
% see the strchr(e+5, ...) below, it's weird

%I could not originally see how ldobj() could work
% when you seek to an individual TEXT. Indeed the branch jumps
% are absolute with the 0 basis as the first instruction in the file,
% not the first instruction in the procedure. It's because you
% actually don't seek to individual function. The symbol table
% contains offsets for symbols which are not the offset of their TEXT
% but the offset of their object file entry in the archive file.

\section{Loading libraries manually, [[5l libxxx.a]]}

<<[[objfile()]] other locals>>=
struct ar_hdr arhdr;
long off, esym, cnt;
Sym *s;
char pname[LIBNAMELEN];
char name[LIBNAMELEN];
char *e, *start, *stop;
bool work;
int pass = 1;
@



<<[[objfile()]] when file is a library>>=
DBG("%5.2f ldlib: %s\n", cputime(), file);

l = read(f, &arhdr, SAR_HDR);

<<[[objfile()]] sanity check library header size and content>>

esym = SARMAG + SAR_HDR + atolwhex(arhdr.size);
off = SARMAG + SAR_HDR;

/*
 * just bang the whole symbol file into memory
 */
seek(f, off, 0);
cnt = esym - off;
start = malloc(cnt + 10);
cnt = read(f, start, cnt);
if(cnt <= 0){
    close(f);
    return;
}
stop = &start[cnt];
memset(stop, '\0', 10);

work = true;
while(work) {

    DBG("%5.2f library pass%d: %s\n", cputime(), pass, file);
    pass++;
    work = false;
    for(e = start; e < stop; e = strchr(e+5, 0) + 1) {

        s = lookup(e+5, 0);
        // loading only the object files containing symbols we are looking for
        if(s->type == SXREF || 
           (s->type == SNONE && strcmp(s->name, "main") == 0)) {
            sprint(pname, "%s(%s)", file, s->name);
            DBG("%5.2f library: %s\n", cputime(), pname);
            
            l = e[1] & 0xff;
            l |= (e[2] & 0xff) << 8;
            l |= (e[3] & 0xff) << 16;
            l |= (e[4] & 0xff) << 24;
            // >> >> >> >>
            
            seek(f, l, SEEK__START);
            l = read(f, &arhdr, SAR_HDR);
            <<[[objfile()]] sanity check entry header>>
            l = atolwhex(arhdr.size);

            // loading the object file containing the symbol
            ldobj(f, l, pname);
            
            if(s->type == SXREF) {
                diag("%s: failed to load: %s", file, s->name);
                errorexit();
            }
            work = true; // maybe some new SXREF has been found in ldobj()
           <<[[objfile()]] an SXREF was found hook>>
        }
    }
}
return;

bad:
    diag("%s: bad or out of date archive", file);
out:
    close(f);
@

% >> >> >>

%old:
%        /* need readn to read the dumps (at least) */
%        l = readn(f, &arhdr, SAR_HDR);
% but seems ugly, readn in lib_core/libc/port/readn.c seems to just
% do some repetitive read()

% double loop!  while work, for ;;
% this is where we include all relevant entities(actually object files), 
% and only those!!!
% so 5l can produce small binaries (good because plan9 does not have
% shared libraries).
% Remember that lookup returns a symbol with SNONE when it didn't
% find a symbol (not SXREF).
% This is also why we do the lookup(INITENTRY, 0)->type = SXREF
% in main to force the loading of the object defining _main in libc.a
% which in turn will provoke the loading of more code.

%ugly: I added a special hack regarding "main" because of ocamlc.
% in ocamlc the main() is in libcamrun.a, so in the library, but
% library passed to the command line are not considered magic libs
% where a fixpoint is done for mutually dependent libs (see section
% below), so I had to cheat.

<<[[objfile()]] sanity check library header size and content>>=
if(l != SAR_HDR) {
    diag("%s: short read on archive file symbol header", file);
    goto out;
}
if(strncmp(arhdr.name, symname, strlen(symname))) {
    diag("%s: first entry not symbol header", file);
    goto out;
}
@

<<[[objfile()]] sanity check entry header>>=
if(l != SAR_HDR)
    goto bad;
if(strncmp(arhdr.fmag, ARFMAG, sizeof(arhdr.fmag)))
    goto bad;
@


\section{Loading libraries semi automatically, [[5l -lxxx]]}
\label{sec:loading-libraries-semi-auto}

\subsection{Library search path}

<<global libdir>>=
// growing_array<dirname>
char**	libdir;
@

<<global nlibdir>>=
// index of next free entry in libdir
int	nlibdir	= 0;
@

<<global maxlibdir>>=
// index of last free entry in libdir
static	int	maxlibdir = 0;
@


\subsection{[[5l -L]]}

<<[[main()]] command line processing(arm)>>=
case 'L':
    addlibpath(EARGF(usage()));
    break;
@


% was called 'a', but root is a better name
<<[[main()]] locals(arm)>>=
char *root;
@

<<constant LIBNAMELEN>>=
#define	LIBNAMELEN	300
@

% used locals? move closer the the code that use it then
<<[[main()]] locals(arm)>>=
int c;
char name[LIBNAMELEN];
char *a;
@
% *a still needed now that renamed to root?


<<[[main()]] addlibpath("/{thestring}/lib") or ccroot>>=
<<[[main()]] change root if ccroot>>

// usually /{thestring}/lib/ as root = ""
snprint(name, sizeof(name), "%s/%s/lib", root, thestring);
addlibpath(name);
@

% possible to change default / search path
<<[[main()]] change root if ccroot>>=
root = getenv("ccroot");

if(root != nil && *root != '\0') {
    if(!fileexists(root)) {
        diag("nonexistent $ccroot: %s", root);
        errorexit();
    }
}else
    root = "";
@
%$








<<function addlibpath>>=
void
addlibpath(char *arg)
{
    char **p;

    // growing array libdir
    if(nlibdir >= maxlibdir) {
        if(maxlibdir == 0)
            maxlibdir = 8;
        else
            maxlibdir *= 2;
        p = malloc(maxlibdir*sizeof(*p));
        <<[[addlibpath()]] sanity check p>>
        memmove(p, libdir, nlibdir*sizeof(*p));
        free(libdir);
        libdir = p;
    }

    libdir[nlibdir++] = strdup(arg);
}
@

<<[[addlibpath()]] sanity check p>>=
if(p == nil) {
    diag("out of memory");
    errorexit();
}
@

\subsection{[[5l -lxxx]]}

% actually can also load them manually by specifing the full
% path of the .a with the lib prefix.

% when done manually by -l in command line of ld
<<[[objfile()]] adjust file if -lxxx filename>>=
if(file[0] == '-' && file[1] == 'l') {
    snprint(pname, sizeof(pname), "lib%s.a", file+2);
    e = findlib(pname);
    if(e == nil) {
        diag("cannot find library: %s", file);
        errorexit();
    }
    snprint(name, sizeof(name), "%s/%s", e, pname);
    file = name;
}
@

<<function findlib>>=
char*
findlib(char *file)
{
    int i;
    char name[LIBNAMELEN];

    for(i = 0; i < nlibdir; i++) {
        snprint(name, sizeof(name), "%s/%s", libdir[i], file);
        if(fileexists(name))
            return libdir[i];
    }
    return nil;
}
@



\section{Loading libraries automagically, [[#pragma lib]]}
\label{sec:loading-libraries-magically}

%old:
% <<[[main()]] locals(arm)>>=
% bool load_libs;
% @
% <<[[main()]] initialize globals(arm)>>=
% load_libs = !debug['l'];
% @
% (but actually not a global)
%
% load_libs was new local added by me (but maybe was in x86 originally)
% but it does not help actually.

% -l means no automagic stdlibs
% when -l alone it means no startup lib

<<[[main()]] load implicit libraries>>=
if(!debug['l'])
    loadlib();
@

<<[[main()]] if rare condition, do nothing, else>>=
if(debug['l']) {}
else
@
% useful for kernel!

%\section{Loading the libraries, [[loadlib()]]}
% used to be in Main functions, but it is an advanced feature


% It loads the libraries mentioned in the .5 via the .h and #pragma magic!
% (see later section)
% ldobj() is actually also loading libraries when they are mentioned
% explicitly as in 5l ... libxxx.a or via 5l ... -lxxx

% but this chunk will be explained later.
%    <<[[objfile()]] when file is a library>>
% regarding the automatic libs, see below.


% so loading objects with ldbobj() will modify some of the globals below

% then if(load_libs) loadlib()  in the main flow

<<global library>>=
// array<option<filename>>
char*	library[50];
@
% addlib() modifies this global


<<global libraryp>>=
// index of first free entry in library array
int	libraryp;
@

% the .5 that mentioned a library via a #pragma? for debugging purpose?
<<global libraryobj>>=
char*	libraryobj[50];
@



% SIMPLE VERSION
<<function loadlib simple version>>=
void
loadlib(void)
{
    int i;

    for(i=0; i<libraryp; i++) {
        DBG("%5.2f autolib: %s (from %s)\n", cputime(), library[i], libraryobj[i]);
        objfile(library[i]);
    }
}
@
% simple version because in practice we want to allow mutually 
% dependent libs, see section later





%\section{Mutually dependent libraries}
% in advanced topic?


<<function loadlib>>=
void
loadlib(void)
{
    int i;
    long h;
    Sym *s;
loop:
    <<[[loadlib()]] reset xrefresolv>>
    for(i=0; i<libraryp; i++) {
        DBG("%5.2f autolib: %s (from %s)\n", cputime(), library[i], libraryobj[i]);
        objfile(library[i]);
    }
    <<[[loadlib()]] if xrefresolv>>
}
@

% this allows to have mutually dependent libraries, but I don't think
% it's a good idea, ocaml does not allow it.
%% If people have mutually dependent, they'll have to mention
%% the same lib multiple time on the command line!

% but ironically ocamlc requires to have support for mutually 
% dependent libraries :) indeed under plan9 I pass
% libcamlrun.a which defines main, but depend on ape/libap.a which
% defines an _main which calls a main.

% note that this is only for the libs in librarp, so only
% for the automagic libraries! Not for the libs passed on the
% command line

<<global xrefresolv>>=
bool	xrefresolv;
@

<<[[loadlib()]] reset xrefresolv>>=
xrefresolv = false;
@

<<[[loadlib()]] if xrefresolv>>=
if(xrefresolv)
    for(h=0; h<nelem(hash); h++)
         for(s = hash[h]; s != S; s = s->link)
             if(s->type == SXREF) {
                 DBG("symbol %s still not resolved, looping\n", s->name);//pad
                 goto loop;
             }
@
% still some unresolved symbols, loop

<<[[objfile()]] an SXREF was found hook>>=
xrefresolv = true;
@













% when done automatically

% ldobj(case AHISTORY and local_line == -1 special mark) -> <>
<<function addlib>>=
void
addlib(char *obj)
{
    char fn1[LIBNAMELEN], fn2[LIBNAMELEN], comp[LIBNAMELEN];
    char *p, *name;
    int i;
    bool search;

    if(histfrogp <= 0)
        return;

    name = fn1;
    search = false;
    if(histfrog[0]->name[1] == '/') {
        sprint(name, "");
        i = 1;
    } else if(histfrog[0]->name[1] == '.') {
        sprint(name, ".");
        i = 0;
    } else {
        sprint(name, "");
        i = 0;
        search = true;
    }

    for(; i<histfrogp; i++) {
        snprint(comp, sizeof comp, histfrog[i]->name+1);

        // s/$0/<thechar>/
        for(;;) {
            p = strstr(comp, "$O");
            if(p == nil)
                break;
            memmove(p+1, p+2, strlen(p+2)+1);
            p[0] = thechar;
        }
        // s/$M/<thestring>/
        for(;;) {
            p = strstr(comp, "$M");
            if(p == nil)
                break;
            if(strlen(comp)+strlen(thestring)-2+1 >= sizeof comp) {
                diag("library component too long");
                return;
            }
            memmove(p+strlen(thestring), p+2, strlen(p+2)+1);
            memmove(p, thestring, strlen(thestring));
        }

        if(strlen(fn1) + strlen(comp) + 3 >= sizeof(fn1)) {
            diag("library component too long");
            return;
        }
        if(i > 0 || !search)
            strcat(fn1, "/");
        strcat(fn1, comp);
    }

    cleanname(name);

    if(search){
        p = findlib(name);
        if(p != nil){
            snprint(fn2, sizeof(fn2), "%s/%s", p, name);
            name = fn2;
        }
    }


    for(i=0; i<libraryp; i++)
        if(strcmp(name, library[i]) == 0)
            return;
    if(libraryp == nelem(library)){
        diag("too many autolibs; skipping %s", name);
        return;
    }

    p = malloc(strlen(name) + 1);
    strcpy(p, name);
    library[libraryp] = p;
    p = malloc(strlen(obj) + 1);
    strcpy(p, obj);
    libraryobj[libraryp] = p;
    libraryp++;
}
@




% rare condition not lookup






\chapter{Resolving}
\label{chap:resolving}

% resolve different steps: 
% - virtual program counter
% - code refs, absolute jumps in term of virtual pc (labels)
% - data refs

%trans:
% Ok loading objects and libs has been done. Normally
% have now a linked list of instructions in firstp, with a valid Prog->pc
% (still virtual program counter?)
% and a good symbol table where can see for instance the pc
% for every TEXT symbols.

<<[[main()]] resolving phases>>=
<<[[main()]] if export table or dynamic module(arm)>>

patch();
<<[[main()]] call doprofxxx() if profiling>>
noops();

dodata();
dotext();
@
%pad: I modified the original code, to simplify, to look more symetric
%old:
%   patch();
%   <<[[main()]] call doprofxxx() if profiling>>
%   dodata();
%   follow();
%   if(firstp == P)
%       goto out;
%   noops();
%   span();
% I think follow is optional, and the order can be changed as
% some steps are independent I think. The test for firstp is not useful
% I think if you remove follow.

% dodata() must precede dotext(), e.g.
% for SSTRING one must do dotata() before dotext.

% what we need to resolve?
% - code references
% - data references

% For data(globl) references it's a symbol, so need to assign
% an absolute location to this symbol. If it's a local or parameter
% it's relative so easier.
% For code they can be reduced to branch pc jump. If we use
% pointer to link a src to it's dest, and then far later assign
% a absolute concrete pc to the instructions, then easy.

% !!!! Note that there is a mutual recursive issue!!!!! To layout code
% we need to know where the addresses of the variables, but 
% for that we need to know what is INITDAT but INITDAT is
% after the text so need to layout the text and the size
% of some instructions depends on the location of the data ...
% Solved with the (SB) and R12 trick for the ARM.
% otherwise? need fixpoint?




\section{Building the code instructions graph, [[patch()]]}
\l no pun intended

% needed because better to use pointers to virtual pc because
% we will change the linked list of instructions. remove, strip,
% compact.

% Set Prog->cond for the branch instructions.
% (before transform branch instructions using symbols in regular branch 
% instructions using offsets (like labels))

% curp->cond->pc so can see the actual value of the branch we go too.
% (see DConv)


% who will use this Prog->cond later? follow(), but if don't care
% about unreachable instruction, is patch() useful????

<<[[patch()]] locals>>=
Prog *p, *q;
int a;
long c;
Sym *s;
@
% essentially will add some links with p->cond = q;   for instruction p
% with opcode a == ABxx where q->pc == c where c is the branch offset value.

<<function patch(arm)>>=
void
patch(void)
{
    <<[[patch()]] locals>>

    DBG("%5.2f patch\n", cputime());

    <<[[patch()]] initialisations>>

    // pass 1
    for(p = firstp; p != P; p = p->link) {
        <<adjust curtext when iterate over instructions p>>

        <<[[patch()]] resolve branch instructions using symbols>>

        if(p->to.type == D_BRANCH && p->cond != UP) {
            c = p->to.offset;
            <<[[patch()]] find Prog reference q with pc == c>>
            p->cond = q;
        }
    }

    // pass 2
    for(p = firstp; p != P; p = p->link) {
        <<adjust curtext when iterate over instructions p>>
        if(p->cond != P && p->cond != UP) {
            p->cond = brloop(p->cond);
            if(p->cond != P)
             if(p->to.type == D_BRANCH)
                p->to.offset = p->cond->pc;
        }
    }
}
@
%less: ARET in conditional? but ARET has no args in Assembler.nw
%note: has the p->cond == UP because can have such things
% done for SUNDEF sections

% p->to.offset = p->cond->pc;
% can have changed?? yes because of brloop()
% s/brloop()/? follow_AB?


<<global undefp>>=
//@Scheck: not dead, used by UP
Prog	undefp;
@
% for error recovery? and for dynamic loading stuff?

<<constant UP>>=
#define	UP	(&undefp)
@


\subsection{Resolving branch instructions using symbols}

<<[[patch()]] resolve branch instructions using symbols>>=
a = p->as;
if((a == ABL || a == AB || a == ARET) &&
   p->to.type != D_BRANCH && 
   p->to.sym != S) {
    s = p->to.sym;
    switch(s->type) {
    case STEXT:
        p->to.offset = s->value;
        p->to.type = D_BRANCH;
        break;
    <<[[patch()]] switch section type for branch instruction, cases>>
    }
}
@

<<[[patch()]] switch section type for branch instruction, cases>>=
default:
    diag("undefined: %s\n%P", s->name, p);
    s->type = STEXT;
    s->value = vexit;
    break;
@

<<[[patch()]] locals>>=
long vexit;
@

<<[[patch()]] initialisations>>=
s = lookup("exit", 0);
vexit = s->value;
@


\subsection{Indexing [[pc]], forward links overlay}

<<[[patch()]] initialisations>>=
mkfwd();
@

% Allows to do some big jmps forward in the list of instructions, 
% to be faster than going just through ->link.
% Interesting data structure overlay on top of a simple linked list
% alternatives: 
%  - a hashtbl on Prog.pc? to get a Prog from a specific pc

% FIGURE

<<constant LOG>>=
#define	LOG	5
@

<<[[Prog]] other fields>>=
Prog*	forwd;
@
%old: used to be part of an union with regused, but regused was actually
% unused

% main -> <> patch -> <>
<<function mkfwd>>=
void
mkfwd(void)
{
    long dwn[LOG], cnt[LOG];
    Prog *lst[LOG];
    Prog *p;
    int i;

    for(i=0; i<LOG; i++) {
        if(i == 0)
            cnt[i] = 1; 
        else
            cnt[i] = LOG * cnt[i-1];
        dwn[i] = 1;
        lst[i] = P;
    }

    i = 0;
    for(p = firstp; p != P; p = p->link) {
        <<adjust curtext when iterate over instructions p>>
        i--;
        if(i < 0)
            i = LOG-1;
        p->forwd = P;
        dwn[i]--;
        if(dwn[i] <= 0) {
            dwn[i] = cnt[i];
            if(lst[i] != P)
                lst[i]->forwd = p;
            lst[i] = p;
        }
    }
}
@

\subsection{Finding instruction at virtual [[pc]]}

<<[[patch()]] find Prog reference q with pc == c>>=
for(q = firstp; q != P;) {
    if((q->forwd != P) && (c >= q->forwd->pc)) {
        q = q->forwd; // big jump
    } else {
        if(c == q->pc)
            break; // found it!
        q = q->link; // small jump
    }
}
if(q == P) {
    diag("branch out of range %ld\n%P", c, p);
    p->to.type = D_NONE;
}
@

\subsection{Compacting chains of [[AB]], [[brloop()]]}


% main -> patch -> <>
%  p->cond = brloop(p->cond);
% compact a chain of AB to the end, and "detect" infinite chain loops
<<function brloop(arm)>>=
Prog*
brloop(Prog *p)
{
    Prog *q;
    int c = 0;

    for(; p!=P;) {
        if(p->as != AB)
            return p;
        q = p->cond;
        if(q <= p) {
            c++;
            if(q == p || c > 5000)
                break;
        }
        p = q;
    }
    return P;
}
@
% less: diag infinute loop detected?




\section{Virtual opcodes rewriting, [[noops()]]}

% ARM only. there is a dostkoff in x86 but it's related only to the become
% stuff that I have now deleted for the ARM.

%noops() is for ASM opcodes which have actually no
%machine opcode (e.g. ADIV, ARET) so was using a fake/virtual opcode

<<function noops(arm)>>=
void
noops(void)
{
    Prog *p, *q, *q1;
    int o;

    /*
     * find leaf subroutines
     * strip NOPs
     * expand RET
     */

    DBG("%5.2f noops\n", cputime());

    // pass 1
    curtext = P;
    for(p = firstp; p != P; p = p->link) {
        <<adjust curtext when iterate over instructions p>>
        switch(p->as) {
        <<[[noops()]] first pass switch opcode cases>>
        }
    }

    // pass 2
    curtext = P;
    for(p = firstp; p != P; p = p->link) {
        <<adjust curtext when iterate over instructions p>>
        o = p->as;
        switch(o) {
        <<[[noops()]] second pass switch opcode cases>>
        }
    }
}
@

\t curframe not useful? ->frame not used?

%old: there was lots of stuff about BECOME which I think was
% a feature necessary for the alef compiler, but it
% has been removed from plan9 edition 4 so this code
% was probably dead.

%    int curframe, curbecome, maxbecome;
%
%     * become sizes
%     * frame sizes
%
%     * expand BECOME pseudo
%
%    curframe = 0;
%    curbecome = 0;
%    maxbecome = 0;
%
%        /* find out how much arg space is used in this TEXT */
%        if(p->to.type == D_OREG && p->to.reg == REGSP)
%            if(p->to.offset > curframe)
%                curframe = p->to.offset;
%
%
%            if(curtext && curtext->from.sym) {
%                curtext->from.sym->frame = curframe;
%                curtext->from.sym->become = curbecome;
%                if(curbecome > maxbecome)
%                    maxbecome = curbecome;
%            }
%            curframe = 0;
%            curbecome = 0;
%
%
%        case ARET:
%            /* special form of RET is BECOME */
%            if(p->from.type == D_CONST)
%                if(p->from.offset > curbecome)
%                    curbecome = p->from.offset;
%            break;
%
%    if(curtext && curtext->from.sym) {
%        curtext->from.sym->frame = curframe;
%        curtext->from.sym->become = curbecome;
%        if(curbecome > maxbecome)
%            maxbecome = curbecome;
%    }
%
%    if(debug['b'])
%        print("max become = %d\n", maxbecome);
%    xdefine("ALEFbecome", STEXT, maxbecome);
%
%    curtext = P;
%    for(p = firstp; p != P; p = p->link) {
%        <<adjust curtext when iterate over instructions p>>
%        switch(p->as) {
%        case ABL:
%            if(curtext != P && curtext->from.sym != S && curtext->to.offset >= 0) {
%                o = maxbecome - curtext->from.sym->frame;
%                if(o <= 0)
%                    break;
%                /* calling a become or calling a variable */
%                if(p->to.sym == S || p->to.sym->become) {
%                    curtext->to.offset += o;
%                    if(debug['b']) {
%                        curp = p;
%                        print("%D calling %D increase %d\n",
%                            &curtext->from, &p->to, o);
%                    }
%                }
%            }
%            break;
%        }
%    }
%
%
%            if(p->from.type == D_CONST)
%                goto become;
%
%        become:
%            if(curtext->mark & LEAF) {
%                if(!autosize) {
%                    p->as = AB;
%                    p->from = zprg.from;
%                    break;
%                }
%            }
%            q = prg();
%            q->scond = p->scond;
%            q->line = p->line;
%            q->as = AB;
%            q->from = zprg.from;
%            q->to = p->to;
%            q->cond = p->cond;
%            q->link = p->link;
%            p->link = q;
%
%            // MOVW autosize(SP), LINK
%            p->as = AMOVW;
%            p->scond |= C_PBIT;
%            p->from = zprg.from;
%            p->from.type = D_OREG;
%            p->from.offset = autosize;
%            p->from.reg = REGSP;
%            p->to = zprg.to;
%            p->to.type = D_REG;
%            p->to.reg = REGLINK;
%
%            break;


%old: this was under some ifdef, probably experimental stuff
%#ifdef optimise_time
%                if(autosize) {
%                    q = prg();
%                    q->as = ASUB;
%                    q->line = p->line;
%                    q->from.type = D_CONST;
%                    q->from.offset = autosize;
%                    q->to.type = D_REG;
%                    q->to.reg = REGSP;
%
%                    q->link = p->link;
%                    p->link = q;
%                }
%                break;
%#else
%
%
%#ifdef optimise_time
%                p->as = AADD;
%                p->from.type = D_CONST;
%                p->from.offset = autosize;
%                p->to.type = D_REG;
%                p->to.reg = REGSP;
%
%                q = prg();
%                q->as = AB;
%                q->scond = p->scond;
%                q->line = p->line;
%                q->to.type = D_OREG;
%                q->to.offset = 0;
%                q->to.reg = REGLINK;
%
%                q->link = p->link;
%                p->link = q;
%
%                break;
%#endif
%
%#ifdef optimise_time
%                q = prg();
%                q->scond = p->scond;
%                q->line = p->line;
%                q->as = AB;
%                q->from = zprg.from;
%                q->to = p->to;
%                q->cond = p->cond;
%                q->link = p->link;
%                p->link = q;
%
%                p->as = AADD;
%                p->from = zprg.from;
%                p->from.type = D_CONST;
%                p->from.offset = autosize;
%                p->to = zprg.to;
%                p->to.type = D_REG;
%                p->to.reg = REGSP;
%
%                break;
%#endif

\subsection{Leaf procedure optimisation}
% could be put in Optimisation section?

<<enum sxxx cases>>=
SLEAF, // arm
@
% SLEAF? the special opti ARM has for leaf functions?

% if leaf procedure, no need to save current SP, noone
% will RET back to this procedure. Also
% we can use a special ABL that use a register instead
% of the stack to save the current PC so RET is also
% faster from this leaf.

<<enum mark cases>>=
LEAF		= 1<<2,
@
% >>
% example of mark. useful to see early? (as there are a few
% case STEXT: case SLEAF: below)

<<[[noops()]] first pass switch opcode cases>>=
case ATEXT:
    p->mark |= LEAF;
    break;

case ABL:
    if(curtext != P)
        curtext->mark &= ~LEAF;
    // fallthrough
<<[[noops()]] first pass switch opcode ABL fallthrough>>
@

% assumes can not make jump outside the function ...?
% the assembler checks that?

\subsection{[[ATEXT]] patching}

% if leaf procedure, no need to save REGLINK in the stack!
% hence the autosize = 0 I think

<<[[noops()]] second pass switch opcode cases>>=
case ATEXT:
    autosize = p->to.offset + 4;
    if(autosize <= 4)
      if(curtext->mark & LEAF) {
        p->to.offset = -4;
        autosize = 0;
    }

    if(!autosize && !(curtext->mark & LEAF)) {
        DBG("save suppressed in: %s\n", curtext->from.sym->name);
        curtext->mark |= LEAF;
    }

    if(curtext->mark & LEAF) {
        if(curtext->from.sym)
            curtext->from.sym->type = SLEAF;
        if(!autosize)
            break;
    }

    // MOVW R14, -autosize(SP)
    q1 = prg();
    q1->as = AMOVW;
    q1->scond |= C_WBIT;
    q1->line = p->line;
    q1->from.type = D_REG;
    q1->from.reg = REGLINK;
    q1->to.type = D_OREG;
    q1->to.offset = -autosize;
    q1->to.reg = REGSP;

    q1->link = p->link;
    p->link = q1;
    break;
@
% wbit??

\subsection{[[ARET]] rewriting}

<<[[noops()]] second pass switch opcode cases>>=
case ARET:
    <<[[noops()]] case ARET, call nocache>>
    if((curtext->mark & LEAF) && !autosize) {
        // B (R14)
        p->as = AB;
        p->from = zprg.from;
        p->to.type = D_OREG;
        p->to.offset = 0;
        p->to.reg = REGLINK;
    } else {
        // MOVW autosize(SP), PC
        p->as = AMOVW;
        p->scond |= C_PBIT;
        p->from.type = D_OREG;
        p->from.offset = autosize;
        p->from.reg = REGSP;
        p->to.type = D_REG;
        p->to.reg = REGPC;
    }
    break;
@
% pbit??


\subsection{[[ANOP]] stripping}

<<[[noops()]] first pass swith opcode cases>>=
case ANOP:
    q1 = p->link;
    q->link = q1;		/* q is non-nop */
    q1->mark |= p->mark;
    continue;
@
\l what about jump to ANOP if there was some? well
\l need to adjust their cond field, see below

% now that have also the ->cond for branches, we need
% to take care and update those links as we removed
% some ANOP.

% so also case ABL: before
<<[[noops()]] first pass switch opcode ABL fallthrough>>=
case AB:

case ABEQ:
case ABNE:
case ABHS:
case ABLO:
case ABMI:
case ABPL:
case ABVS:
case ABVC:
case ABHI:
case ABLS:
case ABGE:
case ABLT:
case ABGT:
case ABLE:

case ABCASE:

    q1 = p->cond;
    if(q1 != P) {
        while(q1->as == ANOP) {
            q1 = q1->link;
            p->cond = q1;
        }
    }
    break;
@
% bug? q1 could be null in the loop?
% todo: write test case showing the bug?
% I would rewrite the code as
%   while(q1 != P && q1->as == ANOP) 
%       q1 = q1->link;
%   p->cond = q1;




\section{Laying out data, [[dodata()]]}
% computing datasize (and bsssize)
% != generating DATA

<<global datsize>>=
long	datsize;
@

<<global bsssize>>=
long	bsssize;
@

% The programmer specifies sizes for GLOBL, and their content via DATA,
% but he does not want to care about the precise layout. Here we layout,
% we put all the globals (spreaded in different instructions and different
% object files) next to each other, assigning concrete locations 
% (actually offset to INITDAT) to each GLOBL.
% Note that Sym.value changes "type" going from a size to now a location.

<<function dodata(arm)>>=
void
dodata(void)
{
    int i, t;
    Sym *s;
    Prog *p;
    long orig;
    long v;

    DBG("%5.2f dodata\n", cputime());

    // DATA instructions loop
    for(p = datap; p != P; p = p->link) {
        s = p->from.sym;
        <<[[dodata()]] if ADYNT or AINIT>>
        if(s->type == SBSS)
            s->type = SDATA;
        <<[[dodata()]] sanity check DATA instructions>>
    }

    <<[[dodata()]] if string in text segment>>

    orig = 0;

    /*
     * pass 1
     *  sanity check data values, and align.
     */
    // symbol table loop
    for(i=0; i<NHASH; i++)
     for(s = hash[i]; s != S; s = s->link) {
        t = s->type;
        if(t == SDATA || t == SBSS) {
            v = s->value;
            if(v == 0) { // check
                diag("%s: no size", s->name);
                v = 1;
            }
            while(v & 3) // align
                v++;
            s->value = v; // adjust
            <<[[dodata()]] if small data size>>
        }
    }

    /*
     * pass 2
     *	assign (large) 'data' variables to data segment
     */
    for(i=0; i<NHASH; i++)
     for(s = hash[i]; s != S; s = s->link) {
        t = s->type;
        if(t == SDATA) {
            // s->value used to contain the size of the GLOBL, 
            // now it's its location!
            v = s->value;
            if(v == 0) {
                diag("%s: no size", s->name);
                v = 1;
            }
            s->value = orig;
            orig += v;
        } else {
            <<[[dodata()]] pass2, retag small data>>
        }
    }

    while(orig & 7)
        orig++;

    datsize = orig;

    /*
     * pass 3
     *	everything else to bss segment
     */
    for(i=0; i<NHASH; i++)
     for(s = hash[i]; s != S; s = s->link) {
        if(s->type == SBSS) {
            // s->value used to contain the size of the GLOBL, 
            // now it's its location
            v = s->value;
            s->value = orig;
            orig += v;
        }
    }
    while(orig & 7)
        orig++;

    bsssize = orig-datsize;

    <<[[dodata()]] define special symbols>>
}
@
% now Sym.value for GLOBL is not the size anymore but the offset
% (offset to INITDAT though) changed type!
% note that first iteration is on datap instructions, the other
% loops are on the symbol table.

% could do orig = INITDAT? no, we can't because we don't know yet the size
% of the text ... this is computed in dotext(). 
% But does it have to be mutually recursive? If we there was not the
% SSTRING thing, could we do just dotext() before dodata()?


<<[[dodata()]] sanity check DATA instructions>>=
if(s->type != SDATA)
    diag("initialize non-data (%d): %s\n%P",
        s->type, s->name, p);
v = p->from.offset + p->reg;
if(v > s->value)
    diag("initialize bounds (%ld): %s\n%P",
        s->value, s->name, p);
@
% p->reg for boundaries ('DATA name / con, ximm')

\section{Laying out code, [[dotext()]]}
% computing textsize
% != generating TEXT

% Adjusting pc and code addresses to concrete values, 
% not symbolic pc! so then when generating the code for AB in
% the next chapter we can do p->cond->pc to know where to concretely jump.
% Start of use of INITTEXT! switch from a symbolic pc to a real pc
% where the size of the instructions now matter (hence use of oplook()).

<<global textsize>>=
long	textsize;
@


<<[[span()]] locals>>=
Prog *p;
Optab *o;
long c;
long v;
Sym *s;
int m, i;
@

<<function span(arm)>>=
void
dotext(void)
{
    <<[[span()]] locals>>

    DBG("%5.2f span\n", cputime());

    c = INITTEXT;
    <<[[span()]] initialisation>>

    for(p = firstp; p != P; p = p->link) {
       <<adjust curtext when iterate over instructions p>>

        p->pc = c;
        o = oplook(p);
        m = o->size;

        if(m == 0) {
            if(p->as == ATEXT) {
                autosize = p->to.offset + 4;
                if(p->from.sym != S)
                    p->from.sym->value = c;
                <<[[span()]] detect if large procedure>>
            } else {
                diag("zero-width instruction\n%P", p);
            }
        } else {
            c += m;
            <<[[span()]] pool handling for optab o>>
        }
    }

    <<[[span()]] if string in text segment>>

    c = rnd(c, 8);

    textsize = c - INITTEXT;
    <<[[span()]] define special symbols>>
    if(INITRND)
        INITDAT = rnd(c, INITRND);
    DBG("tsize = %lux\n", textsize);
}
@
%old: was called span()
%less: use orig instead of 'c' so match more dodata()?
% but here it's really a concrete location whereas for dodata()
% it's relative to INITDAT that we actually compute here.

% if assembly was simple, then simple to know the size
% of instructions, 4, but some ASM instructions are virtual,
% they expand in multiple instructions, so have oplook()!
% this is subtle but explained later in next chapter.
% for now imagine oplook as returning something with size 4.


%Is there a mutual recursive problem? oplook call
% aclass() which needs to know offset size, but we don't know
% yet INITDAT and how far it will be from R12 or other stuff.
% so bug? No because R12 will be INITDAT+BIG! this will not change.
% subtle.


%\subsection{Large procedures}
% need that?

<<[[span()]] locals>>=
long    otxt;
@

<<[[span()]] initialisation>>=
otxt = c;
@

<<[[span()]] detect if large procedure>>=
if(c - otxt >= 1L<<17) {
    diag("Procedure %s too large\n", TNAME);
    errorexit();
}
otxt = c;
@
% >>
%TODO: why big procedures are a problem???


%old: there was some special code to handle really large procedures
% but the code looked buggy, so I commented it out for now.

%<<[[span()]] locals>>=
%bool bflag;
%@
%
%<<[[span()]] initialisation>>=
%bflag = false;
%@
%
%
%<<[[span()]] if large procedure set bflag>>=
%/* need passes to resolve branches */
%if(c - otxt >= 1L<<17)
%    bflag = true;
%@
%% >>
%
%
%<<[[span()]] if large procedure>>=
%/*
% * if any procedure is large enough to
% * generate a large SBRA branch, then
% * generate extra passes putting branches
% * around jmps to fix. this is rare.
% */
%while(bflag) {
%    DBG("%5.2f span1\n", cputime());
%    bflag = false;
%    c = INITTEXT;
%    for(p = firstp; p != P; p = p->link) {
%        <<adjust curtext when iterate over instructions p>>
%        p->pc = c;
%        o = oplook(p);
%        m = o->size;
%        if(m == 0) {
%            if(p->as == ATEXT) {
%                autosize = p->to.offset + 4;
%                if(p->from.sym != S)
%                    p->from.sym->value = c;
%            } else {
%                diag("zero-width instruction\n%P", p);
%            }
%        } else {
%             c += m;
%        }
%    }
%}
%@
%bug? does not have the [[span()]] if large procedure set bflag here?

%/* very larg branches
%            if(o->type == 6 && p->cond) {
%                otxt = p->cond->pc - c;
%                if(otxt < 0)
%                    otxt = -otxt;
%                if(otxt >= (1L<<17) - 10) {
%                    q = prg();
%                    q->link = p->link;
%                    p->link = q;
%                    q->as = AB;
%                    q->to.type = D_BRANCH;
%                    q->cond = p->cond;
%                    p->cond = q;
%                    q = prg();
%                    q->link = p->link;
%                    p->link = q;
%                    q->as = AB;
%                    q->to.type = D_BRANCH;
%                    q->cond = q->link->link;
%                    bflag = 1;
%                }
%            }
% */

\section{Defining special symbols [[etext]], [[edata]], [[end]]}
\label{sec:special-symbols}

% reflection on executable structure and its sections.
% the kernel uses etext! edata! those are important special symbols.
% some form of introspection capability.

% At this point we are in dodata() (or span()) in which case the 'value' field
% is now really a location (relative to INITDAT though for SDATA and SBSS).
% This means the xdefine below now have a different meaning: the 3rd
% argument is a location, not a size anymore!

<<[[dodata()]] define special symbols>>=
xdefine("bdata", SDATA, 0L);
xdefine("edata", SDATA, datsize);
xdefine("end", SBSS, datsize+bsssize);
@
% 0L because SDATA/SBSS are relative to INITDAT. There are many code
% later then do the final s->value+INITDAT.

% how 'end' can be in SBSS section? we actually want it initialized ...
% because here it's actually about the layout! 'end' will have a location
% at the end of the SBSS! If do &end in C (or $end in asm) then you'll get
% a pointer to the end of the BSS! reflection power! 'end' has no value
% because it's in the BSS, but its location is its interesting value!


<<[[span()]] define special symbols>>=
xdefine("etext", STEXT, INITTEXT+textsize);
@

%old: 
%<<[[dodata()]] define special symbols>>=
%xdefine("etext", STEXT, 0L);
%@
%and in span():
%setext = lookup("etext", 0);
%if(setext != S) {
%    setext->value = c;
%    textsize = c - INITTEXT;



<<function xdefine(arm)>>=
void
xdefine(char *p, int t, long v)
{
    Sym *s;

    s = lookup(p, 0);
    if(s->type == SNONE || s->type == SXREF) {
        s->type = t;
        s->value = v;
    }
}
@

\section{Mutual recursivity in layout and [[SB/R12]]}
\label{sec:sb-r12}

<<[[dodata()]] define special symbols>>=
xdefine("setR12", SDATA, 0L+BIG);
@
% the value here is a location for DATA, so there is
% an implicit +INITDAT. Has to be, otherwise would have a mutually
% recursive issue between dodata and dotext because dotext
% need the layout of data, but this layout must start after the
% text ...

<<constant BIG>>=
BIG		= (1<<12)-4,
@
% >>
% lib_core/libc/arm/main9.s will do 
%	MOVW	$setR12(SB), R(sb)
% before anything.

% Note again that we cannot override setR12 address with our own data
% because of the use of lots of symbols. It's the same for btext,
% bdata, etc. Here we care actually only about the address, not the
% content at that address.

% why -4? otherwise could not reach the first data? offset
% can be negative or positive so actually can cover 2 pages of
% small data variables!




% In practice the first page of the address space is always reserved
% so it's better to store in R12 a bigger value. R12 will actually
% be set to INITDAT+BIG.






\chapter{Machine Code Generation (ARM)}
\label{chap:arm-codegen}

%dup:
% The code generation is done by 5l, not 5a, surprisingly!

\section{ARM instruction format}

% ref to colorful guide again

\section{[[Optab]] and [[optab]]}
\n could put in core DS but it's really specific to the code generation chapter

<<struct Optab(arm)>>=
struct	Optab
{
    // enum<opcode> from 5.out.h, (the opcode is the representant of a range)
    byte	as;

    // enum<cxxx>, possible operand_kind/class for first operand
    short	a1;
    // enum<cxxx>, possible operand_kind/class for second operand
    short	a2;
    // enum<cxxx>, possible operand_kind/class for third operand
    short	a3;

    // idx for the code generator, see the giant switch in asmout()
    short	type; 

    // size of the corresponding machine code, should be a multiple of 4
    short	size; 

    <<[[Optab]] other fields>>
};
@
% The order of entries is important!!, see optab[] global, see ocmp()!
% It does not matter for cmp() but it matters for ocmp().
% The order for the operand class is also important!
% For instance C_HFAUTO must be before C_LAUTO otherwise
% the careful order of entries in optab will not be taken
% into account.
%ocaml: use a single pattern match so far easier.

%ex of entries:
% Optab	optab[] =
% {
%    { ATEXT,	C_LEXT,	C_NONE,	C_LCON, 	 0, 0, 0 },
%    { ATEXT,	C_LEXT,	C_REG,	C_LCON, 	 0, 0, 0 },
%    ...
%    { AADD,		C_REG,	C_REG,	C_REG,		 1, 4, 0 },
%    { AADD,		C_REG,	C_NONE,	C_REG,		 1, 4, 0 },


% ARM has fixed-length instructions, 4, but 5a/ support
% some fake/virtual opcodes that actually expands to 
% multiple instructions, hence the size field above.
%
% Also because of 12 bits immediate need special tricks, pool(),
% RCON vs LCON, etc. So there are many cases where we generate
% for one Asm5 instruction multiple ARM instructions. 

%\section{[[optab]]}

% This table contains the different valid combinations 
% of operands for the different opcodes. Actually not all opcodes are put,
% only some representative (see also oprange that describes
% the equivalence classes).
% There is a strong coupling with the grammar 5a/a.y to see
% what operands are allowed, e.g. AMOV has gen operand which
% allow many things, but AADD has more restricted operands
% (immediate, shift, or plain register).

% not sure it needs this complexity, things could probably
% be factorized more.

<<global optab (linkers/5l/optab.c)(arm)>>=
Optab	optab[] =
{
    <<[[optab]] entries>>
    { AXXX,		C_NONE,	C_NONE,	C_NONE,		 0, 4, 0 },
};
@
% AXXX at the end? why not ALAST instead?
%old: { ASWI,		C_NONE,	C_NONE,	C_LOREG,	10, 4, 0 },



\section{[[Operand_class]]}
% was in core DS, but I think better here with Optab.

\subsection{Basic classes}

% seems called the class, see aclass(), a more precise operand_kind
% closer to the machine constraint as we will see in next section
<<enum cxxx(arm)>>=
// order of entries matter! coupling with cmp() and ocmp()
enum Operand_class {
    C_NONE		= 0,

    C_REG,
    C_REGREG,
    C_SHIFT,
    C_PSR,

    C_BRANCH,

    <<cxxx(arm) cases>>

    C_GOK, // must be at the end e.g. for xcmp[] decl, or buildop loops
};
@
%old: I renamed Operand_class, consistent with Operand_kind. C vs D.
%diffs with operand_kind:
% - OREG splitted in many xxxOREG and xxxEXT (SB), xxAUTO (FP, SP)
% - D_CONST splitted in many xxxCON
% - S_CONST?
% - a new C_GOK, but could be called C_LAST I think
%
%less: do big categories, xxCON, xxAUTO, xxEXT, xxREG?
%old: there was C_SBRA, C_LBRA but LBRA was unused so I s/C_LBRA/C_BRANCH/
% there was also this in cmp()
%    case C_LBRA:
%        if(b == C_SBRA)
%            return 1;
%        break;
%

%code: order of entries matter! look at code of cmp() to see which
% classes are subclasses and must be after.

\subsection{[[aclass()]]}

<<function aclass(arm)>>=
int
aclass(Adr *a)
{
    Sym *s;
    int t;

    switch(a->type) {
    case D_NONE:
        return C_NONE;

    case D_REG:
        return C_REG;
    case D_REGREG:
        return C_REGREG;
    case D_SHIFT:
        return C_SHIFT;
    case D_PSR:
        return C_PSR;

    case D_BRANCH:
        return C_BRANCH;

    <<[[aclass()]] switch type cases>>
    }
    return C_GOK;
}
@
% I think aclass() assumes the size of the sections
% has been computed so it can know if a symbol reference
% is close and so could be stored in a half-word, or if
% it's far away.

\subsection{Refined classes and [[instoffset]]}

<<global instoffset(arm)>>=
long	instoffset;
@
% instruction offset?
% really needs to be a global? can't be just a local to aclass()?


\subsubsection{[[D_OREG]]}

<<[[aclass()]] switch type cases>>=
case D_OREG:
    switch(a->symkind) {
    <<[[aclass()]] D_OREG case, switch symkind cases>>
    }
    return C_GOK;
@
% OREG usually is a dereference of a register or a symbol reference
% (which is then really an implicit offet to SB)

% H S L ? half, small, large?
<<cxxx(arm) cases>>=
C_HEXT,
<<cxxx(arm) cases, in C_xEXT, float cases>>
C_SEXT,
C_LEXT,
@
% EXT for? external symbol?

%xxx+y(SB)
<<[[aclass()]] D_OREG case, switch symkind cases>>=
case N_EXTERN:
case N_INTERN:
    if(a->sym == nil || a->sym->name == nil) {
        print("null sym external\n");
        print("%D\n", a);
        return C_GOK;
    }
    s = a->sym;
    t = s->type;
    if(t == SNONE || t == SXREF) {
        diag("undefined external: %s in %s", s->name, TNAME);
        s->type = SDATA;
    }
    <<[[aclass()]] when D_OREG and external symbol and dlm>>
    instoffset = s->value + a->offset - BIG;
    t = immaddr(instoffset);
    if(t) {
        <<[[aclass()]] if immfloat for N_EXTERN symbol>>
        return immhalf(instoffset)? C_HEXT : C_SEXT;
    }
    return C_LEXT;
@


<<cxxx(arm) cases>>=
C_HAUTO,	/* halfword insn offset (-0xff to 0xff) */
<<cxxx(arm) cases, in C_xAUTO, float cases>>
C_SAUTO,	/* -0xfff to 0xfff */
C_LAUTO,
@
% the order matters! because of ocmp() and the order of entries in optab
% hence the chynk for float here

<<[[aclass()]] D_OREG case, switch symkind cases>>=
case N_LOCAL:
    instoffset = autosize + a->offset;
    t = immaddr(instoffset);
    if(t){
        <<[[aclass()]] if immfloat for N_LOCAL or N_PARAM symbol>>
        return immhalf(instoffset)? C_HAUTO : C_SAUTO;
    }
    return C_LAUTO;
@

<<[[aclass()]] D_OREG case, switch symkind cases>>=
case N_PARAM:
    instoffset = autosize + a->offset + 4L;
    t = immaddr(instoffset);
    if(t){
        <<[[aclass()]] if immfloat for N_LOCAL or N_PARAM symbol>>
        return immhalf(instoffset)? C_HAUTO : C_SAUTO;
    }
    return C_LAUTO;
@
% +4??

% RO? rotated?
<<cxxx(arm) cases>>=
C_HOREG,
<<cxxx(arm) cases, in C_xOREG, float cases>>
C_SOREG,
C_LOREG,

C_ROREG,
C_SROREG,	/* both S and R */
@

<<[[aclass()]] D_OREG case, switch symkind cases>>=
case D_NONE:
    instoffset = a->offset;
    t = immaddr(instoffset);
    if(t) {
        <<[[aclass()]] if immfloat for D_NONE symbol>>

         /* n.b. that immhalf() will also satisfy immrot */
        if(immhalf(instoffset))	
            return C_HOREG;

        if(immrot(instoffset))
            return C_SROREG;
        return immhalf(instoffset)? C_HOREG : C_SOREG;
    }
    if(immrot(instoffset))
        return C_ROREG;
    return C_LOREG;
@




\subsubsection{[[D_CONST]]}

<<[[aclass()]] switch type cases>>=
case D_CONST:
    switch(a->symkind) {
    <<[[aclass()]] D_CONST case, switch symkind cases>>
    }
    return C_GOK;
@


% Rotated, Negative, Large?
<<cxxx(arm) cases>>=
C_RCON,		/* 0xff rotated */ // 0xff range, possibly rotated
C_NCON,		/* ~RCON */
C_LCON,
@
%TODO: must impose order with other xCON?
%dead: C_SCON,		/* 0xffff */
%in the end NCON is not different from LCON when you look at optab,
% so perhaps it could be removed.
%note that LCON is more "general" than the other, see cmp() later.

<<[[aclass()]] D_CONST case, switch symkind cases>>=
case D_NONE:
    instoffset = a->offset;
    if(a->reg != R_NONE)
        goto aconsize;

    if(immrot(instoffset))
        return C_RCON;
    if(immrot(~instoffset))
        return C_NCON;
    return C_LCON;
@


%todo: D_ADDR?
%\subsubsection{[[D_ADDR]]}
% should not use D_CONST when really you use the address of a symbol



% rotated External const
<<cxxx(arm) cases>>=
C_RECON,
@
%dead: C_LECON
%optab:    { AMOVW,	C_LECON,C_NONE,	C_REG,		34, 8, REGSB,	LFROM },
%cmp:    case C_LECON:
%        if(b == C_RECON)
%            return 1;
%        break;

<<[[aclass()]] D_CONST case, switch symkind cases>>=
case N_EXTERN:
case N_INTERN:
    s = a->sym;
    if(s == S) // no warning?
        break;
    switch(s->type) {
    case STEXT: case SLEAF: case SSTRING:
    case SCONST:
    case SUNDEF:
        instoffset = s->value + a->offset;
        return C_LCON;
    case SNONE: case SXREF:
        diag("undefined external: %s in %s", s->name, TNAME);
        s->type = SDATA;
        // Fall through
    case SDATA: case SBSS: case SDATA1:
        if(!dlm) {
            instoffset = s->value + a->offset - BIG;
            if(immrot(instoffset) && instoffset != 0)
                return C_RECON;
        }
        instoffset = s->value + a->offset + INITDAT;
        return C_LCON;
    }
    diag("unknown section for %s", s->name);
    break;
@
% for LCON have to do the INITDAT!
% really need RECON?

%old: used to be but more messy I think, the +INITDAT is then confusing
%    case SNONE: case SXREF:
%        diag("undefined external: %s in %s", s->name, TNAME);
%        s->type = SDATA;
%        break;
%    }
%    if(!dlm) {
%        instoffset = s->value + a->offset - BIG;
%        if(immrot(instoffset) && instoffset != 0)
%            return C_RECON;
%    }
%    instoffset = s->value + a->offset + INITDAT;
%    return C_LCON;



%todo: need that? when do we get the address of a local or parameter?
% for which code we have those classes used??
<<cxxx(arm) cases>>=
C_RACON,
C_LACON,
@
%RA Rotate Address? and Long Address?

<<[[aclass()]] D_CONST case, switch symkind cases>>=
case N_LOCAL:
    instoffset = autosize + a->offset;
    goto aconsize;
@
<<[[aclass()]] D_CONST case, switch symkind cases>>=
case N_PARAM:
    instoffset = autosize + a->offset + 4L;
    goto aconsize;
@


<<[[aclass()]] D_CONST case, switch symkind cases>>=
aconsize:
    return immrot(instoffset)? C_RACON : C_LACON;
@



%old: dead: this advanced addressing mode of 5a is not that useful
%    case D_OCONST:
%        switch(a->name) {
%        case N_EXTERN:
%        case N_INTERN:
%            s = a->sym;
%            t = s->type;
%            if(t == 0 || t == SXREF) {
%                diag("undefined external: %s in %s",
%                    s->name, TNAME);
%                s->type = SDATA;
%            }
%            instoffset = s->value + a->offset + INITDAT;
%            if(s->type == STEXT || s->type == SLEAF || s->type == SUNDEF)
%                instoffset = s->value + a->offset;
%            return C_LCON;
%        }
%        return C_GOK;



\section{Half, Small, Large, Rot, Neg}
% Those are some kinds of optimisations? a bit but also need that
% because expressivity Asm5 greater than what ARM can actually do sometimes.

% http://alisdair.mcdiarmid.org/arm-immediate-value-encoding/


% The load/store ARM instructions take 2 registers (src_val, dst_address)
% and a 12 bits offset (for a range of 4096, so really a page, maybe 2 if can
% do negative offset with a bit).
% That means that if you do  'MOVW $1, myglobal', naively you'll have to
% encode it as 3 instructions:
%     MOV $1, R1
%     MOV $myglobal, R2
%     STR R1, R2.
% But if myglobal is not that far from address 0 and you have a special
% register reserved that always contain 0 (e.g. R12),
% then you could use the 12bits offset instead of using a register
% and just do
%     MOV $1, R1
%     STR R1, R12+$myglobal
% If you have a special register which always contain the value 1, 
% then you do even better with just do 
%     STR R0, R12+$myglobal! 
% which is 3 times faster (well if the global address is in a cache).
%
% In practice the first page of the address space is always reserved
% so it's better to store in R12 a bigger value. R12 will actually
% be set to INITDAT+BIG.



\subsection{Immediate address}

<<function immaddr(arm)>>=
long
immaddr(long v)
{
    if(v >= 0 && v <= 0xfff)
        return (v & 0xfff) |
            (1<<24) |	/* pre indexing */
            (1<<23);	/* pre indexing, up */
    if(v >= -0xfff && v < 0)
        return (-v & 0xfff) |
            (1<<24);	/* pre indexing */
    return 0;
}
@
% >> >> >>
% rename immsmall?
% why 0xfff? = 4095 so a page.


\subsection{Half immediate address}

<<function immhalf(arm)>>=
int
immhalf(long v)
{
    if(v >= 0 && v <= 0xff)
        return v |
            (1<<24)  |	/* pre indexing */
            (1<<23);	/* pre indexing, up */
    if(v >= -0xff && v < 0)
        return (-v & 0xff)|
            (1<<24);	/* pre indexing */
    return 0;
}
@
% >> >> >>
% seems identical to immhalf no? no now it's 0xff! not 0xfff

\subsection{Small (possibly rotated) immediate values}
% small immediate (rotated) address

% see Machine.nw and the ARM refcard to understand the code below.
% RCON is for small immediate value, or rotated things of small 
% immediate value.
% You have 8 bits for the number (0xff) and 4 bits for the rotate (16)
% hence the code below.

<<function immrot(arm)>>=
long
immrot(ulong v)
{
    int i;

    for(i=0; i<16; i++) {
        if((v & ~0xff) == 0)
            return (i<<8) | v | (1<<25);
        v = (v<<2) | (v>>30);
    }
    return 0;
}
@
% >> >>

% there is code like
%    o1 |= immrot(instoffset);
% the 1<<25 means we are in the  i,r,r  case



\subsection{Pool}
% see 5l -v -a, see WORD generated at the end for constants
% that could not be encoded in one ARM instruction. Asm5 != ARMv6

<<[[Optab]] other fields>>=
// 0 | REGSB | REGSP
short	param;
// bitset<enum<optab_flag>>
short	flag;
@
%old: was char, but ugly
% order is important, see optab[] global

<<enum optab_flag(arm)>>=
enum optab_flag {
    LFROM	= 1<<0,
    LTO		= 1<<1,
    LPOOL	= 1<<2,
    <<enum optab_flag cases>>
};
@
% >> >> >> >> >>



<<[[span()]] pool handling for optab o>>=
switch(o->flag & (LFROM|LTO|LPOOL)) {
case LFROM:
    addpool(p, &p->from);
    break;
case LTO:
    addpool(p, &p->to);
    break;

case LPOOL:
    if ((p->scond&C_SCOND) == COND_ALWAYS)
        flushpool(p, 0);
    break;
}

if(p->as==AMOVW && p->to.type==D_REG && p->to.reg==REGPC && 
   (p->scond&C_SCOND) == COND_ALWAYS)
    flushpool(p, 0);

if(blitrl)
    checkpool(p);
@
% c += m; used to be before if(blitrl)


% arm specific
<<global pool(arm)>>=
static struct {
    ulong	start;
    ulong	size;
} pool;
@


<<function checkpool(arm)>>=
/*
 * when the first reference to the literal pool threatens
 * to go out of range of a 12-bit PC-relative offset,
 * drop the pool now, and branch round it.
 * this happens only in extended basic blocks that exceed 4k.
 */
void
checkpool(Prog *p)
{
    if(pool.size >= 0xffc || immaddr((p->pc+4)+4+pool.size - pool.start+8) == 0)
        flushpool(p, 1);
    else if(p->link == P)
        flushpool(p, 2);
}
@

<<global blitrl(arm)>>=
Prog*	blitrl;
@

<<global elitrl(arm)>>=
Prog*	elitrl;
@


<<function flushpool(arm)>>=
void
flushpool(Prog *p, int skip)
{
    Prog *q;

    if(blitrl) {
        if(skip){
            if(debug['v'] && skip == 1)
                print("note: flush literal pool at %lux: len=%lud ref=%lux\n", p->pc+4, pool.size, pool.start);
            q = prg();
            q->as = AB;
            q->to.type = D_BRANCH;
            q->cond = p->link;
            q->link = blitrl;
            blitrl = q;
        }
        else if(p->pc+pool.size-pool.start < 2048)
            return;
        elitrl->link = p->link;
        p->link = blitrl;
        blitrl = nil;	/* BUG: should refer back to values until out-of-range */
        elitrl = nil;
        pool.size = 0;
        pool.start = 0;
    }
}
@

<<function addpool(arm)>>=
void
addpool(Prog *p, Adr *a)
{
    Prog *q, t;
    int c;

    c = aclass(a);

    t = zprg;
    t.as = AWORD;

    switch(c) {
    case C_SROREG:
    case C_LOREG:
    case C_ROREG:
    case C_FOREG:
    case C_SOREG:
    case C_FAUTO:
    case C_SAUTO:
    case C_LAUTO:
    case C_LACON:
        t.to.type = D_CONST;
        t.to.offset = instoffset;
        break;
    default:
        t.to = *a;
        break;
    }

    for(q = blitrl; q != P; q = q->link)	/* could hash on t.t0.offset */
        if(memcmp(&q->to, &t.to, sizeof(t.to)) == 0) {
            p->cond = q;
            return;
        }

    q = prg();
    *q = t;
    q->pc = pool.size;

    if(blitrl == P) {
        blitrl = q;
        pool.start = p->pc;
    } else
        elitrl->link = q;
    elitrl = q;
    pool.size += 4;

    p->cond = q;
}
@


\section{[[buildop()]] and [[oplook()]]}

<<[[main()]] initialize globals(arm)>>=
buildop();
@

\subsection{[[oprange]]}

% Optab range
<<struct Oprang(arm)>>=
struct	Oprang
{
    //index in sorted optab global
    Optab*	start;
    //index in sorted optab global
    Optab*	stop;
};
@

<<global oprange(arm)>>=
Oprang	oprange[ALAST];
@

% will be the set of entries in the sorted optab
% that talk about a certain opcode

\subsection{[[buildop()]]}

<<function buildop(arm)>>=
void
buildop(void)
{
    int i, n;
    // enum<opcode> representing a range
    int r;

    <<[[buildop()]] initialize xcmp cache>>
    <<[[buildop()]] initializer floating flags>>

    for(n=0; optab[n].as != AXXX; n++) {
        <<[[buildop()]] adjust optab if floating flags>>
    }

    qsort(optab, n, sizeof(optab[0]), ocmp);

    for(i=0; i<n; i++) {
        r = optab[i].as;

        oprange[r].start = optab+i;
        while(optab[i].as == r)
            i++;
        oprange[r].stop = optab+i;
        i--;

        switch(r)
        {
        <<[[buildop()]] switch opcode r for ranges cases>>
        default:
            diag("unknown op in build: %A", r);
            errorexit();
        }
    }
}
@
%old:		case ABX:
%old:		case ABXRET:
% coupling with order of opcode in 5.out.h? no, this just
% describe the equivalence classes for optab, that
% is an entry in optab about AADD is also valid for AAND, etc.
% invariant: the case in the switch must be the entries in optab, not
% more, not less



<<[[buildop()]] switch opcode r for ranges cases>>=
case AXXX:
    break;
@
% no ARET? no because noops should have rewrote it.
% no ADATA/AGLOBL because buildop is used for code (TEXT) generation,
% not for data (DATA) generation.



% buildop -> qsort(..., <>)
<<function ocmp(arm)>>=
int
ocmp(const void *a1, const void *a2)
{
    Optab *p1, *p2;
    int n;

    p1 = (Optab*)a1;
    p2 = (Optab*)a2;

    n = p1->as - p2->as;
    if(n)
        return n;
    <<[[ocmp()]] if floating point flag on p1 or p2>>
    n = p1->a1 - p2->a1;
    if(n)
        return n;
    n = p1->a2 - p2->a2;
    if(n)
        return n;
    n = p1->a3 - p2->a3;

    if(n)
        return n;
    return 0;
}
@
%sort first by opcode, then class of first operand, then second, then thrd.
%note: Is it needed since in oplook() we just
% iterate over all the range for a certain opcode?
% Yes it is needed! The order of the entries in optab matter, because have
% some specific entries first and then a general one

%TODO: which is why perhaps doing some += in the chunk for xxx
% is not good?  
%update: ??

\subsection{[[oplook()]]}

<<[[oplook()]] locals>>=
Optab *o, *e;
// enum<opcode>, to index oprange[]
int r;
// enum<class>
int a1, a2, a3;
@


% leverage the sorted data structure computed by buildop()
% dotext | asmb -> <>
<<function oplook(arm)>>=
Optab*
oplook(Prog *p)
{
    <<[[oplook()]] locals>>
 
    <<[[oplook()]] if use cache, part1>>
    else {
        a1 = aclass(&p->from);
        a3 = aclass(&p->to);
    }
    a2 = (p->reg != R_NONE)? C_REG : C_NONE;
    r = p->as;
    o = oprange[r].start;
    e = oprange[r].stop;
    <<[[oplook()]] sanity check o>>

    <<[[oplook()]] debug>>

    <<[[oplook()]] if use cache, part2>>
    else {
        for(; o<e; o++)
            if(o->a2 == a2)
             if(cmp(o->a1, a1))
              if(cmp(o->a3, a3)) {
                return o;
            }
    }
    <<[[oplook()]] illegal combination error>>
}
@
%pad: I rewrote this code to aspectize optimisations and have
% a simpler version available
% the order to cmp is right? I think so, see the comment about cmp().
% So middle operand must be equal! (but anyway usually a register)
% and rest must be compatible.




% cmp for compatible (not compare).
% 'b' is the actual class of the operand, 'a' is the one mentionned
% in optab which is actually compatible with a few concrete class.
% e.g. an optab entry for C_LCON will also accomodate concrete operand
% with class C_RCON or C_NCON, but if it's mentionned C_RCON in
% the optab, then it will accept only C_RCON concrete operands.
<<function cmp(arm)>>=
bool
cmp(int a, int b)
{

    if(a == b)
        return true;

    switch(a) {
    case C_LCON:
        if(b == C_RCON || b == C_NCON)
            return true;
        break;
    case C_LACON:
        if(b == C_RACON)
            return true;
        break;

    case C_HFEXT:
        return b == C_HEXT || b == C_FEXT;
    case C_FEXT:
    case C_HEXT:
        return b == C_HFEXT;
    case C_SEXT:
        return cmp(C_HFEXT, b);
    case C_LEXT:
        return cmp(C_SEXT, b);

    case C_HFAUTO:
        return b == C_HAUTO || b == C_FAUTO;
    case C_FAUTO:
    case C_HAUTO:
        return b == C_HFAUTO;
    case C_SAUTO:
        return cmp(C_HFAUTO, b);
    case C_LAUTO:
        return cmp(C_SAUTO, b);

    case C_HFOREG:
        return b == C_HOREG || b == C_FOREG;
    case C_FOREG:
    case C_HOREG:
        return b == C_HFOREG;
    case C_SROREG:
        return cmp(C_SOREG, b) || cmp(C_ROREG, b);
    case C_SOREG:
    case C_ROREG:
        return b == C_SROREG || cmp(C_HFOREG, b);
    case C_LOREG:
        return cmp(C_SROREG, b);

    }
    return false;
}
@
% diff with ocmp? subtle. this is compatibility but it does not
% car about the order of the operand classes. ocmp care about
% the order! because it does not return a boolean but a cmp_result.




<<[[oplook()]] sanity check o>>=
if(o == nil) {
    o = oprange[r].stop; /* just generate an error */
}
@

<<[[oplook()]] illegal combination error>>=
diag("illegal combination %A %d %d %d",  p->as, a1, a2, a3);
prasm(p);
if(o == nil)
    o = optab;
return o;
@


\subsection{Caching}
% Memoizing

<<[[Prog]] other fields>>=
// option<index-1-based in optab[]>, 0 means None, i means index optab[i-1]
byte	optab;
@
% cache so second call to oplook() in asmb() is faster I think

<<[[Adr]] other fields>>=
// option<enum<classx>>, 0 means None, i means i-1 is the class you want
short	class;
@
%a more precise Adr.type
%old: was char, but ugly
%usually the class is computed via aclass() and used as an index
% in the optab complex structure. 
% Not sure why it needs to be stored here in Adr too.

<<[[oplook()]] locals>>=
bool usecache = true;
char *c1, *c3;
@

<<[[oplook()]] if use cache, part1>>=
if(usecache) {
    a1 = p->optab;
    if(a1)
        return optab+(a1-1);
    
    a1 = p->from.class;
    if(a1 == C_NONE) {
        a1 = aclass(&p->from) + 1;
        p->from.class = a1;
    }
    a1--;
    
    a3 = p->to.class;
    if(a3 == C_NONE) {
        a3 = aclass(&p->to) + 1;
        p->to.class = a3;
    }
    a3--;
}
@

<<[[oplook()]] if use cache, part2>>=
if(usecache) {
    c1 = xcmp[a1];
    c3 = xcmp[a3];
    for(; o<e; o++)
        if(o->a2 == a2)
         if(c1[o->a1])
          if(c3[o->a3]) {
            p->optab = (o-optab)+1;
            return o;
        }
}
@

% cmp() cache for oplook()
<<global xcmp(arm)>>=
char	xcmp[C_GOK+1][C_GOK+1];
@

<<[[buildop()]] initialize xcmp cache>>=
for(i=0; i<C_GOK; i++)
    for(n=0; n<C_GOK; n++)
        xcmp[i][n] = cmp(n, i);
@
% subtle the order to cmp here, cmp(n,i) not cmp(i,n)



<<[[noops()]] case ARET, call nocache>>=
nocache(p);
@

<<function nocache(arm)>>=
void
nocache(Prog *p)
{
    p->optab = 0;
    p->from.class = 0;
    p->to.class = 0;
}
@
% disable cache for ARET because the instruction has actually changed!
% in noops we overwrite the ancien instruction, with p->as = ABL
% so we must force to recompute optab and aclass.
% not sure it's needed though since optab is used only in oplook()
% which is called only by span() and asmb() which are both called
% long after noops().






%/*
%void
%buildrep(int x, int as)
%{
%    Opcross *p;
%    Optab *e, *s, *o;
%    int a1, a2, a3, n;
%
%    if(C_NONE != 0 || C_REG != 1 || C_GOK >= 32 || x >= nelem(opcross)) {
%        diag("assumptions fail in buildrep");
%        errorexit();
%    }
%    repop[as] = x;
%    p = (opcross + x);
%    s = oprange[as].start;
%    e = oprange[as].stop;
%    for(o=e-1; o>=s; o--) {
%        n = o-optab;
%        for(a2=0; a2<2; a2++) {
%            if(a2) {
%                if(o->a2 == C_NONE)
%                    continue;
%            } else
%                if(o->a2 != C_NONE)
%                    continue;
%            for(a1=0; a1<32; a1++) {
%                if(!xcmp[a1][o->a1])
%                    continue;
%                for(a3=0; a3<32; a3++)
%                    if(xcmp[a3][o->a3])
%                        (*p)[a1][a2][a3] = n;
%            }
%        }
%    }
%    oprange[as].start = 0;
%}
%*/

% there was this in oplook() but I think it could not work
% if buildrep was not called
%    if(o == nil) {
%        a1 = opcross[repop[r]][a1][a2][a3];
%        if(a1) {
%            p->optab = a1+1;
%            return optab+a1;
%        }
%        o = oprange[r].stop; /* just generate an error */
%    }

%extern	uchar	repop[ALAST];
%
%<<global repop(arm)>>=
%uchar	repop[ALAST];
%@
%
%typedef	uchar	Opcross[32][2][32];
%
%extern	Opcross	opcross[8];
%
%<<global opcross(arm)>>=
%Opcross	opcross[8];
%@

\section{Text section, [[asmout()]]}

% main -> asmb -> <> (in a for loop over all instructions)
<<function asmout(arm)>>=
void
asmout(Prog *p, Optab *o)
{
    // ARM 32 bits instructions
    long o1, o2, o3, o4, o5, o6;
    // pc
    long v;
    // misc
    int r, rf, rt, rt2;
    Sym *s;

    <<[[asmout()]] initialisation>>
    o1 = o2 = o3 = o4 = o5 = o6 = 0;

    switch(o->type) {
    <<[[asmout()]] switch on type cases>>
    default:
        diag("unknown asm %d", o->type);
        prasm(p);
        break;
    }

    <<[[asmout()]] debug>>

    v = p->pc;
    switch(o->size) {
    <<[[asmout()]] switch on size cases>>
    }
}
@
%$




<<[[asmout()]] switch on size cases>>=
case 4:
    <<[[asmout()]] when 1 generated instruction, debug>>
    lputl(o1);
    break;
case 8:
    <<[[asmout()]] when 2 generated instructions, debug>>
    lputl(o1);
    lputl(o2);
    break;
case 12:
    <<[[asmout()]] when 3 generated instructions, debug>>
    lputl(o1);
    lputl(o2);
    lputl(o3);
    break;
case 16:
    <<[[asmout()]] when 4 generated instructions, debug>>
    lputl(o1);
    lputl(o2);
    lputl(o3);
    lputl(o4);
    break;
case 20:
    <<[[asmout()]] when 5 generated instructions, debug>>
    lputl(o1);
    lputl(o2);
    lputl(o3);
    lputl(o4);
    lputl(o5);
    break;
case 24:
    <<[[asmout()]] when 6 generated instructions, debug>>
    lputl(o1);
    lputl(o2);
    lputl(o3);
    lputl(o4);
    lputl(o5);
    lputl(o6);
    break;
default:
    <<[[asmout()]] when other size, debug>>
    break;
@



\subsection{[[ATEXT]]}

<<[[buildop()]] switch opcode r for ranges cases>>=
case ATEXT:
    break;
@


<<[[optab]] entries>>=
{ ATEXT,	C_LEXT,	C_NONE,	C_LCON, 	 0, 0, 0 },
{ ATEXT,	C_LEXT,	C_REG,	C_LCON, 	 0, 0, 0 },
@

<<[[asmout()]] switch on type cases>>=
case 0:		/* pseudo ops */
    break;
@
% nothing to be done! TEXT is a pseudo opcode, and noops()
% has patched it with the initial mov to save REGLINK in stack, so we're good
% to go.

\subsection{[[AWORD]]}

% used for limitations of 5a, but also for addpool!
% to deal with the ARM constraints on range of immediate values, addresses.

<<[[buildop()]] switch opcode r for ranges cases>>=
case AWORD:
    break;
@

<<[[optab]] entries>>=
{ AWORD,	C_NONE,	C_NONE,	C_LCON,		11, 4, 0 },
{ AWORD,	C_NONE,	C_NONE,	C_LEXT,		11, 4, 0 },
@
%less: WORD foo;  what does it mean?
% WORD $foo; ok, I get it, and it should be a C_LCON

<<[[asmout()]] switch on type cases>>=
case 11:	/* word */
    switch(aclass(&p->to)) {
    <<[[asmout()]] on WORD case, switch class cases>>
    }
    o1 = instoffset;
    break;
@


\subsection{Arithmetic and logic opcodes}

\subsubsection{Logic, add/sub, comparisons, simple movs}

<<[[buildop()]] switch opcode r for ranges cases>>=
case AADD:
    oprange[AAND] = oprange[r];
    oprange[AEOR] = oprange[r];
    oprange[AORR] = oprange[r];
    oprange[ABIC] = oprange[r];
    oprange[ASUB] = oprange[r];
    oprange[ARSB] = oprange[r];
    oprange[AADC] = oprange[r];
    oprange[ASBC] = oprange[r];
    oprange[ARSC] = oprange[r];
    break;
@

<<[[buildop()]] switch opcode r for ranges cases>>=
case ACMP:
    oprange[ATST] = oprange[r];
    oprange[ATEQ] = oprange[r];
    oprange[ACMN] = oprange[r];
    break;
@

<<[[buildop()]] switch opcode r for ranges cases>>=
case AMVN:
    break;
@

<<[[buildop()]] switch opcode r for ranges cases>>=
case AMOVW:
case AMOVB:
case AMOVBU:
case AMOVH:
case AMOVHU:
    break;
@
% mov put here because many mov are simple and involve
% just setting registers, as in MOV $1, R0


<<[[optab]] entries>>=
{ AADD,		C_REG,	C_REG,	C_REG,		 1, 4, 0 },
{ AADD,		C_REG,	C_NONE,	C_REG,		 1, 4, 0 },

{ AMOVW,	C_REG,	C_NONE,	C_REG,		 1, 4, 0 },
{ AMVN,		C_REG,	C_NONE,	C_REG,		 1, 4, 0 },
{ ACMP,		C_REG,	C_REG,	C_NONE,		 1, 4, 0 },
@



<<[[asmout()]] switch on type cases>>=
case 1:		/* op R,[R],R */
    o1 = oprrr(p->as, p->scond);
    rf = p->from.reg;
    rt = p->to.reg;
    r = p->reg;
    <<[[asmout()]] adjust r and rt>>
    o1 |= rf | (r<<16) | (rt<<12);
    break;
@
% >> >>
% rf(from) -> rm, r -> rn, rt(to) -> rd(dest) ->  in refcard term.

<<function oprrr(arm)>>=
long
oprrr(int a, int sc)
{
    long o;

    o = (sc & C_SCOND) << 28;
    if(sc & C_SBIT)
        o |= 1 << 20;
    if(sc & (C_PBIT|C_WBIT))
        diag(".P/.W on dp instruction");

    switch(a) {
    case AAND:	return o | (0x0<<21);
    case AEOR:	return o | (0x1<<21);
    case ASUB:	return o | (0x2<<21);
    case ARSB:	return o | (0x3<<21);
    case AADD:	return o | (0x4<<21);
    case AADC:	return o | (0x5<<21);
    case ASBC:	return o | (0x6<<21);
    case ARSC:	return o | (0x7<<21);
    case ATST:	return o | (0x8<<21) | (1<<20);
    case ATEQ:	return o | (0x9<<21) | (1<<20);
    case ACMP:	return o | (0xa<<21) | (1<<20);
    case ACMN:	return o | (0xb<<21) | (1<<20);
    case AORR:	return o | (0xc<<21);
    case AMOVW:	return o | (0xd<<21);
    case ABIC:	return o | (0xe<<21);
    case AMVN:	return o | (0xf<<21);

    <<[[oprrr()]] switch cases>>
    }
    diag("bad rrr %d", a);
    prasm(curp);
    return 0;
}
@
% >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >>
% >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >>
% >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >>
% >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >>

% the assembler allows some sugar e.g. ADD X1, X2 is really
% ADD X1, X2, X2, so this code handles this sugar.
<<[[asmout()]] adjust r and rt>>=
if(p->to.type == D_NONE)
    rt = 0;
if(p->as == AMOVW || p->as == AMVN)
    r = 0;
else if(r == R_NONE)
    r = rt;
@





<<[[optab]] entries>>=
{ AADD,		C_RCON,	C_REG,	C_REG,		 2, 4, 0 },
{ AADD,		C_RCON,	C_NONE,	C_REG,		 2, 4, 0 },

{ AMOVW,	C_RCON,	C_NONE,	C_REG,		 2, 4, 0 },
{ AMVN,		C_RCON,	C_NONE,	C_REG,		 2, 4, 0 },
{ ACMP,		C_RCON,	C_REG,	C_NONE,		 2, 4, 0 },
@

<<[[asmout()]] switch on type cases>>=
case 2:		/* op $I,[R],R */
    aclass(&p->from);
    o1 = oprrr(p->as, p->scond);
    o1 |= immrot(instoffset);
    rt = p->to.reg;
    r = p->reg;
    <<[[asmout()]] adjust r and rt>>
    o1 |= (r<<16) | (rt<<12);
    break;
@
%$
%pad: the comment was about movbu, but it was wrong I think

<<[[optab]] entries>>=
{ AADD,		C_SHIFT,C_REG,	C_REG,		 3, 4, 0 },
{ AADD,		C_SHIFT,C_NONE,	C_REG,		 3, 4, 0 },

{ AMVN,		C_SHIFT,C_NONE,	C_REG,		 3, 4, 0 },
{ ACMP,		C_SHIFT,C_REG,	C_NONE,		 3, 4, 0 },
@

<<[[asmout()]] switch on type cases>>=
case 3:		/* op R<<[IR],[R],R */
mov:
    aclass(&p->from);
    o1 = oprrr(p->as, p->scond);
    o1 |= p->from.offset;
    rt = p->to.reg;
    r = p->reg;
    <<[[asmout()]] adjust r and rt>>
    o1 |= (r<<16) | (rt<<12);
    break;
@
% >> >> >>
%pad: add -> op in the comment

% the MOV opcodes with size 4 which are simple, simple load or store
<<[[optab]] entries>>=
{ AMOVW,	C_RECON,C_NONE,	C_REG,		 4, 4, REGSB },
{ AMOVW,	C_RACON,C_NONE,	C_REG,		 4, 4, REGSP },
@

<<[[asmout()]] switch on type cases>>=
case 4:		/* add $I,[R],R */
    aclass(&p->from);
    o1 = oprrr(AADD, p->scond);
    o1 |= immrot(instoffset);
    r = p->from.reg;
    if(r == R_NONE)
        r = o->param;
    o1 |= (r << 16) | (p->to.reg << 12);
    break;
@
%$
% add in comment?




<<[[optab]] entries>>=
{ AADD,		C_NCON,	C_REG,	C_REG,		13, 8, 0 },
{ AADD,		C_NCON,	C_NONE,	C_REG,		13, 8, 0 },
{ AMVN,		C_NCON,	C_NONE,	C_REG,		13, 8, 0 },
{ ACMP,		C_NCON,	C_REG,	C_NONE,		13, 8, 0 },

{ AADD,		C_LCON,	C_REG,	C_REG,		13, 8, 0,	LFROM },
{ AADD,		C_LCON,	C_NONE,	C_REG,		13, 8, 0,	LFROM },
{ AMVN,		C_LCON,	C_NONE,	C_REG,		13, 8, 0,	LFROM },
{ ACMP,		C_LCON,	C_REG,	C_NONE,		13, 8, 0,	LFROM },
@
% the general case for big constants

<<[[asmout()]] switch on type cases>>=
case 13:	/* op $lcon, [R], R */
    o1 = omvl(p, &p->from, REGTMP);
    if(!o1)
        break;
    o2 = oprrr(p->as, p->scond);
    o2 |= REGTMP;
    r = p->reg;
    if(p->as == AMOVW || p->as == AMVN)
        r = 0;
    else if(r == R_NONE)
        r = p->to.reg;
    o2 |= r << 16;
    if(p->to.type != D_NONE)
        o2 |= p->to.reg << 12;
    break;
@
%$

<<function omvl(arm)>>=
long
omvl(Prog *p, Adr *a, int dr)
{	
    long v, o1;
    if(!p->cond) {
        aclass(a);
        v = immrot(~instoffset);
        if(v == 0) {
            diag("missing literal");
            prasm(p);
            return 0;
        }
        o1 = oprrr(AMVN, p->scond&C_SCOND);
        o1 |= v;
        o1 |= dr << 12;
    } else {
        v = p->cond->pc - p->pc - 8;
        o1 = olr(v, REGPC, dr, p->scond&C_SCOND);
    }
    return o1;
}
@
% >> >> >>
%less: can have p->cond because called for basic arith op and also
% for BL ops?


\subsubsection{Bit shift}

<<[[buildop()]] switch opcode r for ranges cases>>=
case ASLL:
    oprange[ASRL] = oprange[r];
    oprange[ASRA] = oprange[r];
    break;
@


<<[[optab]] entries>>=
{ ASLL,		C_RCON,	C_REG,	C_REG,		 8, 4, 0 },
{ ASLL,		C_RCON,	C_NONE,	C_REG,		 8, 4, 0 },
@


<<[[asmout()]] switch on type cases>>=
case 8:		/* sll $c,[R],R -> mov (R<<$c),R */
    aclass(&p->from);
    o1 = oprrr(p->as, p->scond);
    r = p->reg;
    if(r == R_NONE)
        r = p->to.reg;
    o1 |= r | ((instoffset&31) << 7) | (p->to.reg << 12);
    break;
@
%$
% >> >>

% 0xd is AMOV
<<[[oprrr()]] switch cases>>=
case ASLL:	return o | (0xd<<21) | (0<<5);
case ASRL:	return o | (0xd<<21) | (1<<5);
case ASRA:	return o | (0xd<<21) | (2<<5);
@
% >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >>
% >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >>

<<[[optab]] entries>>=
{ ASLL,		C_REG,	C_NONE,	C_REG,		 9, 4, 0 },
{ ASLL,		C_REG,	C_REG,	C_REG,		 9, 4, 0 },
@

<<[[asmout()]] switch on type cases>>=
case 9:		/* sll R,[R],R -> mov (R<<R),R */
    o1 = oprrr(p->as, p->scond);
    r = p->reg;
    if(r == R_NONE)
        r = p->to.reg;
    o1 |= r | ((p->from.reg << 8) | (1<<4)) | (p->to.reg << 12);
    break;
@
% >> >> >> >> 


\subsubsection{Multiplication}

<<[[buildop()]] switch opcode r for ranges cases>>=
case AMUL:
    oprange[AMULU] = oprange[r];
    break;
@

<<[[optab]] entries>>=
{ AMUL,		C_REG,	C_REG,	C_REG,		15, 4, 0 },
{ AMUL,		C_REG,	C_NONE,	C_REG,		15, 4, 0 },
@


<<[[asmout()]] switch on type cases>>=
case 15:	/* mul r,[r,]r */
    o1 = oprrr(p->as, p->scond);
    rf = p->from.reg;
    rt = p->to.reg;
    r = p->reg;
    if(r == R_NONE)
        r = rt;
    if(rt == r) {
        r = rf;
        rf = rt;
    }
    o1 |= (rf<<8) | r | (rt<<16);
    break;
@
% >> >> 
%old code
%    if(0)
%    if(rt == r || rf == REGPC || r == REGPC || rt == REGPC) {
%        diag("bad registers in MUL");
%        prasm(p);
%    }

<<[[oprrr()]] switch cases>>=
case AMULU:
case AMUL:	return o | (0x0<<21) | (0x9<<4);
@
% >> >>


\subsubsection{Long mulitplication}
% could be in advanced topic, like I did in Assembler.nw


<<[[buildop()]] switch opcode r for ranges cases>>=
case AMULL:
    oprange[AMULA] = oprange[r];
    oprange[AMULAL] = oprange[r];
    oprange[AMULLU] = oprange[r];
    oprange[AMULALU] = oprange[r];
    break;
@

<<[[optab]] entries>>=
{ AMULL,	C_REG,	C_REG,	C_REGREG,	17, 4, 0 },
@

<<[[asmout()]] switch on type cases>>=
case 17:
    o1 = oprrr(p->as, p->scond);
    rf = p->from.reg;
    rt = p->to.reg;
    rt2 = p->to.offset;
    r = p->reg;
    o1 |= (rf<<8) | r | (rt<<16) | (rt2<<12);
    break;
@
% >> >> >>

<<[[oprrr()]] switch cases>>=
case AMULA:	return o | (0x1<<21) | (0x9<<4);
case AMULLU:	return o | (0x4<<21) | (0x9<<4);
case AMULL:		return o | (0x6<<21) | (0x9<<4);
case AMULALU:	return o | (0x5<<21) | (0x9<<4);
case AMULAL:	return o | (0x7<<21) | (0x9<<4);
@
% >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >>
% >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >>


\subsubsection{Simple movs}

% have already some simple movs before
% here are a few more

<<[[optab]] entries>>=
{ AMOVW,	C_NCON,	C_NONE,	C_REG,		12, 4, 0 },
{ AMOVW,	C_LCON,	C_NONE,	C_REG,		12, 4, 0,	LFROM },
@

<<[[asmout()]] switch on type cases>>=
case 12:	/* movw $lcon, reg */
    o1 = omvl(p, &p->from, p->to.reg);
    break;
@
%$



<<[[optab]] entries>>=
{ AMOVB,	C_REG,	C_NONE,	C_REG,		14, 8, 0 },
{ AMOVBU,	C_REG,	C_NONE,	C_REG,		58, 4, 0 },
{ AMOVH,	C_REG,	C_NONE,	C_REG,		14, 8, 0 },
{ AMOVHU,	C_REG,	C_NONE,	C_REG,		14, 8, 0 },
@

<<[[asmout()]] switch on type cases>>=
case 14:	/* movb/movbu/movh/movhu R,R */
    o1 = oprrr(ASLL, p->scond);

    if(p->as == AMOVBU || p->as == AMOVHU)
        o2 = oprrr(ASRL, p->scond);
    else
        o2 = oprrr(ASRA, p->scond);

    r = p->to.reg;
    o1 |= (p->from.reg)|(r<<12);
    o2 |= (r)|(r<<12);
    if(p->as == AMOVB || p->as == AMOVBU) {
        o1 |= (24<<7);
        o2 |= (24<<7);
    } else {
        o1 |= (16<<7);
        o2 |= (16<<7);
    }
    break;
@
% >> >> >> >> >> >> >>

<<[[asmout()]] switch on type cases>>=
case 58:	/* movbu R,R */
    o1 = oprrr(AAND, p->scond);
    o1 |= immrot(0xff);
    rt = p->to.reg;
    r = p->from.reg;
    if(p->to.type == D_NONE)
        rt = 0;
    if(r == R_NONE)
        r = rt;
    o1 |= (r<<16) | (rt<<12);
    break;
@
% >> >>



\subsection{Control flow opcodes}

<<[[buildop()]] switch opcode r for ranges cases>>=
case AB:
case ABL:
    break;
case ABEQ:
    oprange[ABNE] = oprange[r];
    oprange[ABHS] = oprange[r];
    oprange[ABLO] = oprange[r];
    oprange[ABMI] = oprange[r];
    oprange[ABPL] = oprange[r];
    oprange[ABVS] = oprange[r];
    oprange[ABVC] = oprange[r];
    oprange[ABHI] = oprange[r];
    oprange[ABLS] = oprange[r];
    oprange[ABGE] = oprange[r];
    oprange[ABLT] = oprange[r];
    oprange[ABGT] = oprange[r];
    oprange[ABLE] = oprange[r];
    break;
@

<<[[optab]] entries>>=
{ AB,		C_NONE,	C_NONE,	C_BRANCH,		 5, 4, 0,	LPOOL },
{ ABL,		C_NONE,	C_NONE,	C_BRANCH,		 5, 4, 0 },
{ ABEQ,		C_NONE,	C_NONE,	C_BRANCH,		 5, 4, 0 },
@


<<[[asmout()]] switch on type cases>>=
case 5:		/* bra s */
    <<[[asmout()]] BRA case, if undefined target>>
    else 
      if(p->cond != P)
        v = (p->cond->pc - pc) - 8;
      else 
        v = -8;
    o1 = opbra(p->as, p->scond);
    o1 |= (v >> 2) & 0xffffff;
    break;
@
% p->cond->pc !! hence the need for patch()! and span()
% and do -pc because it's relative, and do -8 because ARM
% does implicitly a +8 (see Machine.nw)

<<function opbra(arm)>>=
long
opbra(int a, int sc)
{

    if(sc & (C_SBIT|C_PBIT|C_WBIT))
        diag(".S/.P/.W on bra instruction");
    sc &= C_SCOND;
    if(a == ABL)
        return (sc<<28)|(0x5<<25)|(0x1<<24);

    if(sc != 0xe)
        diag(".COND on bcond instruction");

    switch(a) {
    case ABEQ:	return (0x0<<28)|(0x5<<25);
    case ABNE:	return (0x1<<28)|(0x5<<25);
    case ABHS:	return (0x2<<28)|(0x5<<25);
    case ABLO:	return (0x3<<28)|(0x5<<25);
    case ABMI:	return (0x4<<28)|(0x5<<25);
    case ABPL:	return (0x5<<28)|(0x5<<25);
    case ABVS:	return (0x6<<28)|(0x5<<25);
    case ABVC:	return (0x7<<28)|(0x5<<25);
    case ABHI:	return (0x8<<28)|(0x5<<25);
    case ABLS:	return (0x9<<28)|(0x5<<25);
    case ABGE:	return (0xa<<28)|(0x5<<25);
    case ABLT:	return (0xb<<28)|(0x5<<25);
    case ABGT:	return (0xc<<28)|(0x5<<25);
    case ABLE:	return (0xd<<28)|(0x5<<25);
    case AB:	return (0xe<<28)|(0x5<<25);
    }
    diag("bad bra %A", a);
    prasm(curp);
    return 0;
}
@
% 
% >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >>
% >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >>





<<[[optab]] entries>>=
{ AB,		C_NONE,	C_NONE,	C_ROREG,	 6, 4, 0,	LPOOL },
{ ABL,		C_NONE,	C_NONE,	C_ROREG,	 7, 8, 0 },
@
% branch to indirect code!
% if it's a really big offset that is not immrot(), no code generation?

<<[[asmout()]] switch on type cases>>=
case 6:		/* b ,O(R) -> add $O,R,PC */
    aclass(&p->to);
    o1 = oprrr(AADD, p->scond);
    o1 |= immrot(instoffset);
    o1 |= (p->to.reg << 16) | (REGPC << 12);
    break;
@
%$

<<[[asmout()]] switch on type cases>>=
case 7:		/* bl ,O(R) -> mov PC,link; add $O,R,PC */
    aclass(&p->to);
    o1 = oprrr(AADD, p->scond);
    o1 |= immrot(0) | (REGPC << 16) | (REGLINK << 12);

    o2 = oprrr(AADD, p->scond);
    o2 |= immrot(instoffset) | (p->to.reg << 16) | (REGPC << 12);
    break;
@
%$
% could use AMOVW instead of AADD no?


\subsection{Memory opcodes}
% more complicated ... can generate up to 6 ARM instructions

% have seen the simple MOV before, which don't involve
% any dereference, but just a constant and a register
% or even sometimes just two registers.

<<[[optab]] entries>>=
{ AMOVW,	C_REG,	C_NONE,	C_SEXT,		20, 4, REGSB },
{ AMOVW,	C_REG,	C_NONE,	C_SAUTO,	20, 4, REGSP },
{ AMOVW,	C_REG,	C_NONE,	C_SOREG,	20, 4, 0 },
{ AMOVB,	C_REG,	C_NONE,	C_SEXT,		20, 4, REGSB },
{ AMOVB,	C_REG,	C_NONE,	C_SAUTO,	20, 4, REGSP },
{ AMOVB,	C_REG,	C_NONE,	C_SOREG,	20, 4, 0 },
{ AMOVBU,	C_REG,	C_NONE,	C_SEXT,		20, 4, REGSB },
{ AMOVBU,	C_REG,	C_NONE,	C_SAUTO,	20, 4, REGSP },
{ AMOVBU,	C_REG,	C_NONE,	C_SOREG,	20, 4, 0 },

{ AMOVW,	C_SEXT,	C_NONE,	C_REG,		21, 4, REGSB },
{ AMOVW,	C_SAUTO,C_NONE,	C_REG,		21, 4, REGSP },
{ AMOVW,	C_SOREG,C_NONE,	C_REG,		21, 4, 0 },
{ AMOVBU,	C_SEXT,	C_NONE,	C_REG,		21, 4, REGSB },
{ AMOVBU,	C_SAUTO,C_NONE,	C_REG,		21, 4, REGSP },
{ AMOVBU,	C_SOREG,C_NONE,	C_REG,		21, 4, 0 },

{ AMOVB,	C_SEXT,	C_NONE,	C_REG,		22, 12, REGSB },
{ AMOVB,	C_SAUTO,C_NONE,	C_REG,		22, 12, REGSP },
{ AMOVB,	C_SOREG,C_NONE,	C_REG,		22, 12, 0 },
{ AMOVH,	C_SEXT,	C_NONE,	C_REG,		22, 12, REGSB },
{ AMOVH,	C_SAUTO,C_NONE,	C_REG,		22, 12, REGSP },
{ AMOVH,	C_SOREG,C_NONE,	C_REG,		22, 12, 0 },
{ AMOVHU,	C_SEXT,	C_NONE,	C_REG,		22, 12, REGSB },
{ AMOVHU,	C_SAUTO,C_NONE,	C_REG,		22, 12, REGSP },
{ AMOVHU,	C_SOREG,C_NONE,	C_REG,		22, 12, 0 },

{ AMOVH,	C_REG,	C_NONE,	C_SEXT,		23, 12, REGSB },
{ AMOVH,	C_REG,	C_NONE,	C_SAUTO,	23, 12, REGSP },
{ AMOVH,	C_REG,	C_NONE,	C_SOREG,	23, 12, 0 },
{ AMOVHU,	C_REG,	C_NONE,	C_SEXT,		23, 12, REGSB },
{ AMOVHU,	C_REG,	C_NONE,	C_SAUTO,	23, 12, REGSP },
{ AMOVHU,	C_REG,	C_NONE,	C_SOREG,	23, 12, 0 },
@


<<[[asmout()]] switch on type cases>>=
case 20:	/* mov/movb/movbu R,O(R) */
    aclass(&p->to);
    r = p->to.reg;
    if(r == R_NONE)
        r = o->param;
    o1 = osr(p->as, p->from.reg, instoffset, r, p->scond);
    break;
@


<<[[asmout()]] switch on type cases>>=
case 21:	/* mov/movbu O(R),R -> lr */
    aclass(&p->from);
    r = p->from.reg;
    if(r == R_NONE)
        r = o->param;
    o1 = olr(instoffset, r, p->to.reg, p->scond);
    if(p->as != AMOVW)
        o1 |= 1<<22;
    break;
@


<<function olr(arm)>>=
long
olr(long v, int b, int r, int sc)
{
    long o;

    o = (sc & C_SCOND) << 28;
    if(sc & C_SBIT)
        diag(".S on LDR/STR instruction");
    if(!(sc & C_PBIT))
        o |= 1 << 24;
    if(!(sc & C_UBIT))
        o |= 1 << 23;
    if(sc & C_WBIT)
        o |= 1 << 21;
    o |= (0x1<<26) | (1<<20);
    if(v < 0) {
        v = -v;
        o ^= 1 << 23;
    }
    if(v >= (1<<12))
        diag("literal span too large: %ld (R%d)\n%P", v, b, PP);
    o |= v;
    o |= b << 16;
    o |= r << 12;
    return o;
}
@
% >> >> >> >> >> >> >> >> >> >>

<<global PP(arm)>>=
static Prog *PP;
@
% to communicate info to olr for better diagnostic

<<[[asmout()]] initialisation>>=
PP = p;
@






<<[[asmout()]] switch on type cases>>=
case 22:	/* movb/movh/movhu O(R),R -> lr,shl,shr */
    aclass(&p->from);
    r = p->from.reg;
    if(r == R_NONE)
        r = o->param;
    o1 = olr(instoffset, r, p->to.reg, p->scond);

    o2 = oprrr(ASLL, p->scond);
    o3 = oprrr(ASRA, p->scond);
    r = p->to.reg;
    if(p->as == AMOVB) {
        o2 |= (24<<7)|(r)|(r<<12);
        o3 |= (24<<7)|(r)|(r<<12);
    } else {
        o2 |= (16<<7)|(r)|(r<<12);
        if(p->as == AMOVHU)
            o3 = oprrr(ASRL, p->scond);
        o3 |= (16<<7)|(r)|(r<<12);
    }
    break;
@
<<[[asmout()]] switch on type cases>>=
case 23:	/* movh/movhu R,O(R) -> sb,sb */
    aclass(&p->to);
    r = p->to.reg;
    if(r == R_NONE)
        r = o->param;
    o1 = osr(AMOVH, p->from.reg, instoffset, r, p->scond);

    o2 = oprrr(ASRL, p->scond);
    o2 |= (8<<7)|(p->from.reg)|(REGTMP<<12);

    o3 = osr(AMOVH, REGTMP, instoffset+1, r, p->scond);
    break;
@



<<[[optab]] entries>>=
{ AMOVW,	C_REG,	C_NONE,	C_LEXT,		30, 8, REGSB,	LTO },
{ AMOVW,	C_REG,	C_NONE,	C_LAUTO,	30, 8, REGSP,	LTO },
{ AMOVW,	C_REG,	C_NONE,	C_LOREG,	30, 8, 0,	LTO },
{ AMOVB,	C_REG,	C_NONE,	C_LEXT,		30, 8, REGSB,	LTO },
{ AMOVB,	C_REG,	C_NONE,	C_LAUTO,	30, 8, REGSP,	LTO },
{ AMOVB,	C_REG,	C_NONE,	C_LOREG,	30, 8, 0,	LTO },
{ AMOVBU,	C_REG,	C_NONE,	C_LEXT,		30, 8, REGSB,	LTO },
{ AMOVBU,	C_REG,	C_NONE,	C_LAUTO,	30, 8, REGSP,	LTO },
{ AMOVBU,	C_REG,	C_NONE,	C_LOREG,	30, 8, 0,	LTO },
@

<<[[asmout()]] switch on type cases>>=
case 30:	/* mov/movb/movbu R,L(R) */
    o1 = omvl(p, &p->to, REGTMP);
    if(!o1)
        break;
    r = p->to.reg;
    if(r == R_NONE)
        r = o->param;
    o2 = osrr(p->from.reg, REGTMP,r, p->scond);
    if(p->as != AMOVW)
        o2 |= 1<<22;
    break;
@




<<[[optab]] entries>>=
{ AMOVW,	C_LEXT,	C_NONE,	C_REG,		31, 8, REGSB,	LFROM },
{ AMOVW,	C_LAUTO,C_NONE,	C_REG,		31, 8, REGSP,	LFROM },
{ AMOVW,	C_LOREG,C_NONE,	C_REG,		31, 8, 0,	LFROM },
{ AMOVBU,	C_LEXT,	C_NONE,	C_REG,		31, 8, REGSB,	LFROM },
{ AMOVBU,	C_LAUTO,C_NONE,	C_REG,		31, 8, REGSP,	LFROM },
{ AMOVBU,	C_LOREG,C_NONE,	C_REG,		31, 8, 0,	LFROM },

{ AMOVB,	C_LEXT,	C_NONE,	C_REG,		32, 16, REGSB,	LFROM },
{ AMOVB,	C_LAUTO,C_NONE,	C_REG,		32, 16, REGSP,	LFROM },
{ AMOVB,	C_LOREG,C_NONE,	C_REG,		32, 16, 0,	LFROM },
{ AMOVH,	C_LEXT,	C_NONE,	C_REG,		32, 16, REGSB,	LFROM },
{ AMOVH,	C_LAUTO,C_NONE,	C_REG,		32, 16, REGSP,	LFROM },
{ AMOVH,	C_LOREG,C_NONE,	C_REG,		32, 16, 0,	LFROM },
{ AMOVHU,	C_LEXT,	C_NONE,	C_REG,		32, 16, REGSB,	LFROM },
{ AMOVHU,	C_LAUTO,C_NONE,	C_REG,		32, 16, REGSP,	LFROM },
{ AMOVHU,	C_LOREG,C_NONE,	C_REG,		32, 16, 0,	LFROM },
@

<<[[asmout()]] switch on type cases>>=
case 31:	/* mov/movbu L(R),R -> lr[b] */
case 32:	/* movh/movb L(R),R -> lr[b] */
    o1 = omvl(p, &p->from, REGTMP);
    if(!o1)
        break;
    r = p->from.reg;
    if(r == R_NONE)
        r = o->param;
    o2 = olrr(REGTMP,r, p->to.reg, p->scond);
    if(p->as == AMOVBU || p->as == AMOVB)
        o2 |= 1<<22;
    if(o->type == 31)
        break;

    o3 = oprrr(ASLL, p->scond);

    if(p->as == AMOVBU || p->as == AMOVHU)
        o4 = oprrr(ASRL, p->scond);
    else
        o4 = oprrr(ASRA, p->scond);

    r = p->to.reg;
    o3 |= (r)|(r<<12);
    o4 |= (r)|(r<<12);
    if(p->as == AMOVB || p->as == AMOVBU) {
        o3 |= (24<<7);
        o4 |= (24<<7);
    } else {
        o3 |= (16<<7);
        o4 |= (16<<7);
    }
    break;
@


% 24 size ...
<<[[optab]] entries>>=
{ AMOVH,	C_REG,	C_NONE,	C_LEXT,		33, 24, REGSB,	LTO },
{ AMOVH,	C_REG,	C_NONE,	C_LAUTO,	33, 24, REGSP,	LTO },
{ AMOVH,	C_REG,	C_NONE,	C_LOREG,	33, 24, 0,	LTO },
{ AMOVHU,	C_REG,	C_NONE,	C_LEXT,		33, 24, REGSB,	LTO },
{ AMOVHU,	C_REG,	C_NONE,	C_LAUTO,	33, 24, REGSP,	LTO },
{ AMOVHU,	C_REG,	C_NONE,	C_LOREG,	33, 24, 0,	LTO },
@

<<[[asmout()]] switch on type cases>>=
case 33:	/* movh/movhu R,L(R) -> sb, sb */
    o1 = omvl(p, &p->to, REGTMP);
    if(!o1)
        break;
    r = p->to.reg;
    if(r == R_NONE)
        r = o->param;
    o2 = osrr(p->from.reg, REGTMP, r, p->scond);
    o2 |= (1<<22) ;

    o3 = oprrr(ASRL, p->scond);
    o3 |= (8<<7)|(p->from.reg)|(p->from.reg<<12);
    o3 |= (1<<6);	/* ROR 8 */

    o4 = oprrr(AADD, p->scond);
    o4 |= (REGTMP << 12) | (REGTMP << 16);
    o4 |= immrot(1);

    o5 = osrr(p->from.reg, REGTMP,r,p->scond);
    o5 |= (1<<22);

    o6 = oprrr(ASRL, p->scond);
    o6 |= (24<<7)|(p->from.reg)|(p->from.reg<<12);
    o6 |= (1<<6);	/* ROL 8 */

    break;
@




<<[[optab]] entries>>=
{ AMOVW,	C_LACON,C_NONE,	C_REG,		34, 8, REGSP,	LFROM },
@

<<[[asmout()]] switch on type cases>>=
case 34:	/* mov $lacon,R */
    o1 = omvl(p, &p->from, REGTMP);
    if(!o1)
        break;

    o2 = oprrr(AADD, p->scond);
    o2 |= REGTMP;
    r = p->from.reg;
    if(r == R_NONE)
        r = o->param;
    o2 |= r << 16;
    if(p->to.type != D_NONE)
        o2 |= p->to.reg << 12;
    break;
@
%$


<<[[optab]] entries>>=
{ AMOVW,	C_PSR,	C_NONE,	C_REG,		35, 4, 0 },
{ AMOVW,	C_REG,	C_NONE,	C_PSR,		36, 4, 0 },
{ AMOVW,	C_RCON,	C_NONE,	C_PSR,		37, 4, 0 },
@

<<[[asmout()]] switch on type cases>>=
case 35:	/* mov PSR,R */
    o1 = (2<<23) | (0xf<<16) | (0<<0);
    o1 |= (p->scond & C_SCOND) << 28;
    o1 |= (p->from.reg & 1) << 22;
    o1 |= p->to.reg << 12;
    break;
@
<<[[asmout()]] switch on type cases>>=
case 36:	/* mov R,PSR */
    o1 = (2<<23) | (0x29f<<12) | (0<<4);
    if(p->scond & C_FBIT)
        o1 ^= 0x010 << 12;
    o1 |= (p->scond & C_SCOND) << 28;
    o1 |= (p->to.reg & 1) << 22;
    o1 |= p->from.reg << 0;
    break;
@
<<[[asmout()]] switch on type cases>>=
case 37:	/* mov $con,PSR */
    aclass(&p->from);
    o1 = (2<<23) | (0x29f<<12) | (0<<4);
    if(p->scond & C_FBIT)
        o1 ^= 0x010 << 12;
    o1 |= (p->scond & C_SCOND) << 28;
    o1 |= immrot(instoffset);
    o1 |= (p->to.reg & 1) << 22;
    o1 |= p->from.reg << 0;
    break;
@
%$


<<[[optab]] entries>>=
{ AMOVW,	C_SHIFT,C_NONE,	C_REG,		59, 4, 0 },
{ AMOVBU,	C_SHIFT,C_NONE,	C_REG,		59, 4, 0 },

{ AMOVB,	C_SHIFT,C_NONE,	C_REG,		60, 4, 0 },

{ AMOVW,	C_REG,	C_NONE,	C_SHIFT,	61, 4, 0 },
{ AMOVB,	C_REG,	C_NONE,	C_SHIFT,	61, 4, 0 },
{ AMOVBU,	C_REG,	C_NONE,	C_SHIFT,	61, 4, 0 },
@

<<[[asmout()]] switch on type cases>>=
case 59:	/* movw/bu R<<I(R),R -> ldr indexed */
    if(p->from.reg == R_NONE) {
        if(p->as != AMOVW)
            diag("byte MOV from shifter operand");
        goto mov;
    }
    if(p->from.offset&(1<<4))
        diag("bad shift in LDR");
    o1 = olrr(p->from.offset, p->from.reg, p->to.reg, p->scond);
    if(p->as == AMOVBU)
        o1 |= 1<<22;
    break;
@
% >> >> >>


<<[[asmout()]] switch on type cases>>=
case 60:	/* movb R(R),R -> ldrsb indexed */
    if(p->from.reg == R_NONE) {
        diag("byte MOV from shifter operand");
        goto mov;
    }
    if(p->from.offset&(~0xf))
        diag("bad shift in LDRSB");
    o1 = olhrr(p->from.offset, p->from.reg, p->to.reg, p->scond);
    o1 ^= (1<<5)|(1<<6);
    break;
@
% >> >> 

<<[[asmout()]] switch on type cases>>=
case 61:	/* movw/b/bu R,R<<[IR](R) -> str indexed */
    if(p->to.reg == R_NONE)
        diag("MOV to shifter operand");
    o1 = osrr(p->from.reg, p->to.offset, p->to.reg, p->scond);
    if(p->as == AMOVB || p->as == AMOVBU)
        o1 |= 1<<22;
    break;
@
% >> >>





<<[[buildop()]] switch opcode r for ranges cases>>=
case ASWPW:
    oprange[ASWPBU] = oprange[r];
    break;
@

<<[[optab]] entries>>=
{ ASWPW,	C_SOREG,C_REG,	C_REG,		40, 4, 0 },
@


<<[[asmout()]] switch on type cases>>=
case 40:	/* swp oreg,reg,reg */
    aclass(&p->from);
    if(instoffset != 0)
        diag("offset must be zero in SWP");
    o1 = (0x2<<23) | (0x9<<4);
    if(p->as != ASWPW)
        o1 |= 1 << 22;
    o1 |= p->from.reg << 16;
    o1 |= p->reg << 0;
    o1 |= p->to.reg << 12;
    o1 |= (p->scond & C_SCOND) << 28;
    break;
@
% >> >> >> >> >> >> >>

\subsection{Software interrupt opcodes}

<<[[buildop()]] switch opcode r for ranges cases>>=
case ASWI:
case ARFE:
    break;
@


<<[[optab]] entries>>=
{ ASWI,		C_NONE,	C_NONE,	C_NONE,		10, 4, 0 },
{ ASWI,		C_NONE,	C_NONE,	C_LCON,		10, 4, 0 },
{ ASWI,		C_NONE,	C_NONE,	C_LOREG,	10, 4, 0 },
@
%pad: I added the entry for LCON to allow SWI $0 which make more sense to me
% than SWI 0 which was used in 9syscall/mkfile originally
%old: I used to comment the LOREG entry because SWI was not having
% any argument in Assembler.nw, but now it has back an argument so
% I put it back.

<<[[asmout()]] switch on type cases>>=
case 10:	/* swi [$con] */
    o1 = oprrr(p->as, p->scond);
    if(p->to.type != D_NONE) {
        aclass(&p->to);
        o1 |= instoffset & 0xffffff;
    }
    break;
@
%$

<<[[oprrr()]] switch cases>>=
case ASWI:	return o | (0xf<<24);
@
% >> 


<<[[optab]] entries>>=
{ ARFE,		C_NONE,	C_NONE,	C_NONE,		41, 4, 0 },
@
%emulator:
% there is no RFE in Machine.nw because all the system
% code is proxied, and so there is no assembly system code to emulate

<<[[asmout()]] switch on type cases>>=
case 41:	/* rfe -> movm.s.w.u 0(r13),[r15] */
    o1 = 0xe8fd8000;
    break;
@
% .s? .w? .u?
% r13 = REGSP


\section{Data section, [[datblk()]]}

<<constant Dbufslop>>=
#define	Dbufslop	100
@
% ? slop?

%sstring is bool used when call datblk for generating strings in text segment
<<function datblk(arm)>>=
void
datblk(long s, long n, bool sstring)
{
    Prog *p;
    long a, l;
    int i, c;
    <<[[datblk()]] locals>>

    memset(buf.dbuf, 0, n+Dbufslop);

    for(p = datap; p != P; p = p->link) {

        if(sstring != (p->from.sym->type == SSTRING))
            continue;

        curp = p;

        a = p->from.sym->value + p->from.offset;
        l = a - s;
        c = p->reg;
        i = 0;
        if(l < 0) {
            if(l+c <= 0)
                continue;
            while(l < 0) {
                l++;
                i++;
            }
        }
        if(l >= n)
            continue;

        <<[[datblk()]] sanity check multiple initialization>>

        switch(p->to.type) {
        <<[[datblk()]] switch type of destination cases>>
        default:
            diag("unknown mode in initialization%P", p);
            break;
        }
    }
    write(cout, buf.dbuf, n);
}
@

<<[[datblk()]] locals>>=
long j;
@

<<[[datblk()]] sanity check multiple initialization>>=
if(p->as != AINIT && p->as != ADYNT) {
    for(j=l+(c-i)-1; j>=l; j--)
        if(buf.dbuf[j]) {
            print("%P\n", p);
            diag("multiple initialization");
            break;
        }
}
@

<<[[datblk()]] switch type of destination cases>>=
case D_SCONST:
    for(; i<c; i++) {
        buf.dbuf[l] = p->to.sval[i];
        l++;
    }
    break;
@


<<[[datblk()]] locals>>=
Sym *v;
char *cast;
long d;
@

<<[[datblk()]] switch type of destination cases>>=
case D_CONST:
    d = p->to.offset;
    v = p->to.sym;
    if(v) {
        switch(v->type) {
        case SUNDEF:
            ckoff(v, d);
        case STEXT: case SLEAF:
        case SSTRING:
            d += p->to.sym->value;
            break;
        case SDATA:
        case SBSS:
            d += p->to.sym->value + INITDAT;
        }
        <<[[datblk()]] if dynamic module(arm)>>
    }
    cast = (char*)&d;

    switch(c) {
    case 1:
        for(; i<c; i++) {
            buf.dbuf[l] = cast[inuxi1[i]];
            l++;
        }
        break;
    case 2:
        for(; i<c; i++) {
            buf.dbuf[l] = cast[inuxi2[i]];
            l++;
        }
        break;
    case 4:
        for(; i<c; i++) {
            buf.dbuf[l] = cast[inuxi4[i]];
            l++;
        }
        break;

    default:
        diag("bad nuxi %d %d%P", c, i, curp);
        break;
    }
    break;
@




<<function ckoff>>=
void
ckoff(Sym *s, long v)
{
    if(v < 0 || v >= 1<<Roffset)
        diag("relocation offset %ld for %s out of range", v, s->name);
}
@

% >>


\subsection{Endianess, [[nuxiinit()]]}

%"unix" in some systems is represented as "nuxi" because of endianess

<<global inuxi1>>=
char	inuxi1[1];
@

<<global inuxi2>>=
char	inuxi2[2];
@

<<global inuxi4>>=
char	inuxi4[4];
@


<<global fnuxi4>>=
char	fnuxi4[4];
@

<<global fnuxi8>>=
char	fnuxi8[8];
@


<<[[main()]] initialize globals(arm)>>=
nuxiinit(); // ???
@

<<function nuxiinit(arm)>>=
void
nuxiinit(void)
{

    int i, c;

    for(i=0; i<4; i++) {
        c = find1(0x04030201L, i+1);
        if(i < 2)
            inuxi2[i] = c;
        if(i < 1)
            inuxi1[i] = c;
        inuxi4[i] = c;
        fnuxi4[i] = c;

        if(debug['d'] == 0){
            fnuxi8[i] = c;
            fnuxi8[i+4] = c+4;
        }
        else{
            fnuxi8[i] = c+4;		/* ms word first, then ls, even in little endian mode */
            fnuxi8[i+4] = c;
        }
    }

    if(debug['v']) {
        Bprint(&bso, "inuxi = ");
        for(i=0; i<1; i++)
            Bprint(&bso, "%d", inuxi1[i]);
        Bprint(&bso, " ");
        for(i=0; i<2; i++)
            Bprint(&bso, "%d", inuxi2[i]);
        Bprint(&bso, " ");
        for(i=0; i<4; i++)
            Bprint(&bso, "%d", inuxi4[i]);
        Bprint(&bso, "\nfnuxi = ");
        for(i=0; i<4; i++)
            Bprint(&bso, "%d", fnuxi4[i]);
        Bprint(&bso, " ");
        for(i=0; i<8; i++)
            Bprint(&bso, "%d", fnuxi8[i]);
        Bprint(&bso, "\n");
    }
    Bflush(&bso);
}
@




<<function find1>>=
int
find1(long l, int c)
{
    char *p;
    int i;

    p = (char*)&l;
    for(i=0; i<4; i++)
        if(*p++ == c)
            return i;
    return 0;
}
@












\chapter{Debugging Support}
\label{chap:debugging}

% Symbol Tables.
% related to import/export table? I don't think so.

% cooperation of 5a, 5c, and now last piece: 5l.

% But then db has awesome information!
% in db doing $C  dumps the stacktrace with parameters values! and locals!
%  ex:
%  caml_main(argv=...) /home/pad/../main.c called from main+f (/home/pad/...)
%    caml_main.raise_buf/ 0x1
%    caml_main.pos/ 0x0
%    caml_main.trail/ 0x4cf2c
%    ...
%  main(argv=...) /home/pad/.../main.c called from _main+26 (.../main9.s:12)


\section{Executable symbol table, [[asmsym()]]}

% have seen object file symbol table, now executable symbol table.
% but here really just for debugging (or for dyn linking too?)

% nm helloc actually does not show everything,
% the 'f', 'p', and so are not shown by nm apparently.
% try 5l -n -o helloc helloc.5

<<global symsize>>=
long	symsize;
@
% for the a.out.h header


%5l -n ...
%T 000011d0 atexit
%m 0000000c .frame
%a 00000004 i
%p 00000000 f



% main -> asmb -> <>
<<function asmsym(arm)>>=
void
asmsym(void)
{
    Prog *p;
    Auto *a;
    Sym *s;
    int h;

    s = lookup("etext", 0);
    if(s->type == STEXT)
        putsymb(s->name, 'T', s->value, s->version);

    for(h=0; h<NHASH; h++)
        for(s=hash[h]; s!=S; s=s->link)
            switch(s->type) {
            case SDATA:
                putsymb(s->name, 'D', s->value+INITDAT, s->version);
                continue;
            case SBSS:
                putsymb(s->name, 'B', s->value+INITDAT, s->version);
                continue;

            case SCONST:
                putsymb(s->name, 'D', s->value, s->version);
                continue;
            case SSTRING:
                putsymb(s->name, 'T', s->value, s->version);
                continue;

            case SFILE:
                putsymb(s->name, 'f', s->value, s->version);
                continue;
            }

    for(p=textp; p!=P; p=p->cond) {
        s = p->from.sym;
        if(s->type == STEXT || s->type == SLEAF) {
            /* filenames first */
            <<[[asmsym()]] call putsymb for filenames>>
            
            if(s->type == STEXT)
                putsymb(s->name, 'T', s->value, s->version);
            else // SLEAF
                putsymb(s->name, 'L', s->value, s->version);
            
            /* frame, auto and param after */
            putsymb(".frame", 'm', p->to.offset+4, 0);
            for(a=p->to.autom; a; a=a->link)
                if(a->type == N_LOCAL)
                    putsymb(a->asym->name, 'a', -a->aoffset, 0);
                else
                if(a->type == N_PARAM)
                    putsymb(a->asym->name, 'p', a->aoffset, 0);
        }
    }
    if(debug['v'] || debug['n']) {
        Bprint(&bso, "symsize = %lud\n", symsize);
        Bflush(&bso);
    }
}
@




<<function putsymb>>=
void
putsymb(char *s, int t, long v, int ver)
{
    int i, f;

    if(t == 'f')
        s++;

    lput(v);
    if(ver)
        t += 'a' - 'A';
    cput(t+0x80);			/* 0x80 is variable length */

    <<[[putsymb()]] if z or Z>>
    else {
        for(i=0; s[i]; i++)
            cput(s[i]);
        cput('\0');
    }
    symsize += 4 + 1 + i + 1;

    <<[[putsymb()]] debug>>
}
@
%>>


\section{File and line information, [[AHISTORY]]}
\label{sec:lineno}

% say chapter in \book{Assembler}. global line number after
% preprocessing.

% tracing origin??


<<global histfrog>>=
Sym*	histfrog[MAXHIST];
@

<<constant MAXHIST>>=
MAXHIST		= 20,	/* limit of path elements for history symbols */
@

<<global histfrogp>>=
int	histfrogp;
@





% used by what? for debugging? when signature conflict! to print
% current filenames in conflict


% pn? filename of object file, but addlib() really abuse histgrog global
<<[[ldobj()]] switch opcode cases(arm)>>=
case AHISTORY:
    if(p->to.offset == -1) {
        addlib(pn);
        histfrogp = 0;
        goto loop;
    }

    addhist(p->line, D_FILE);		/* 'z' */
    if(p->to.offset)
        addhist(p->to.offset, D_FILE1);	/* 'Z' */
    histfrogp = 0;
    goto loop;
@

<<function addhist>>=
void
addhist(long line, int type)
{
    Auto *u;
    Sym *s;
    int i, j, k;

    s = malloc(sizeof(Sym));
    s->name = malloc(2*(histfrogp+1) + 1);

    u = malloc(sizeof(Auto));
    u->asym = s;
    u->type = type;
    u->aoffset = line;

    u->link = curhist;
    curhist = u;

    j = 1;
    for(i=0; i<histfrogp; i++) {
        k = histfrog[i]->value;
        s->name[j+0] = k>>8;
        s->name[j+1] = k;
        j += 2;
    }
}
@



<<global curhist>>=
Auto*	curhist;
@
% like curauto

% ldobj (case AEND | ATEXT | ??) -> <>
<<function histtoauto>>=
void
histtoauto(void)
{
    Auto *l;

    while(l = curhist) {
        curhist = l->link;
        l->link = curauto;
        curauto = l;
    }
}
@


<<[[ldobj()]] case ATEXT, curauto adjustments with curhist>>=
histtoauto();
@

<<[[ldobj()]] case AEND, curauto adjustments with curhist>>=
histtoauto();
@




<<enum sxxx cases>>=
SFILE,
@

<<global histgen>>=
int	histgen = 0;
@

<<[[ldobj()]] when ANAME opcode, if D_FILE>>=
if(v == D_FILE) {
    if(s->type != SFILE) {
        histgen++;
        s->type = SFILE;
        s->value = histgen;
    }
    if(histfrogp < MAXHIST) {
        histfrog[histfrogp] = s;
        histfrogp++;
    } else
        collapsefrog(s);
}
@


<<function collapsefrog>>=
void
collapsefrog(Sym *s)
{
    int i;

    /*
     * bad encoding of path components only allows
     * MAXHIST components. if there is an overflow,
     * first try to collapse xxx/..
     */
    for(i=1; i<histfrogp; i++)
        if(strcmp(histfrog[i]->name+1, "..") == 0) {
            memmove(histfrog+i-1, histfrog+i+1,
                (histfrogp-i-1)*sizeof(histfrog[0]));
            histfrogp--;
            goto out;
        }

    /*
     * next try to collapse .
     */
    for(i=0; i<histfrogp; i++)
        if(strcmp(histfrog[i]->name+1, ".") == 0) {
            memmove(histfrog+i, histfrog+i+1,
                (histfrogp-i-1)*sizeof(histfrog[0]));
            goto out;
        }

    /*
     * last chance, just truncate from front
     */
    memmove(histfrog+0, histfrog+1,
        (histfrogp-1)*sizeof(histfrog[0]));

out:
    histfrog[histfrogp-1] = s;
}
@




\section{Filenames}

% why they are shoved in to.autom with locals and params? a bit ugly
<<[[asmsym()]] call putsymb for filenames>>=
for(a=p->to.autom; a; a=a->link)
    if(a->type == D_FILE)
        putsymb(a->asym->name, 'z', a->aoffset, 0);
    else
    if(a->type == D_FILE1)
        putsymb(a->asym->name, 'Z', a->aoffset, 0);
@

<<[[putsymb()]] if z or Z>>=
if(t == 'z' || t == 'Z') {
    cput(s[0]);
    for(i=1; s[i] != 0 || s[i+1] != 0; i += 2) {
        cput(s[i]);
        cput(s[i+1]);
    }
    cput(0);
    cput(0);
    i++;
}
@


\section{Line table, [[asmlc()]]}

% lc? line count?
<<global lcsize>>=
long	lcsize;
@


<<constant MINLC(arm)>>=
#define	MINLC	4
@

<<function asmlc>>=
void
asmlc(void)
{
    long oldpc, oldlc;
    Prog *p;
    long v, s;

    oldpc = INITTEXT;
    oldlc = 0;
    for(p = firstp; p != P; p = p->link) {
        if(p->line == oldlc || p->as == ATEXT || p->as == ANOP) {
            <<adjust curtext when iterate over instructions p>>
            if(debug['V'])
                Bprint(&bso, "%6lux %P\n",
                    p->pc, p);
            continue;
        }
        if(debug['V'])
            Bprint(&bso, "\t\t%6ld", lcsize);
        v = (p->pc - oldpc) / MINLC;
        while(v) {
            s = 127;
            if(v < 127)
                s = v;
            cput(s+128);	/* 129-255 +pc */
            if(debug['V'])
                Bprint(&bso, " pc+%ld*%d(%ld)", s, MINLC, s+128);
            v -= s;
            lcsize++;
        }
        s = p->line - oldlc;
        oldlc = p->line;
        oldpc = p->pc + MINLC;
        if(s > 64 || s < -64) {
            cput(0);	/* 0 vv +lc */
            cput(s>>24);
            cput(s>>16);
            cput(s>>8);
            cput(s);
            if(debug['V']) {
                if(s > 0)
                    Bprint(&bso, " lc+%ld(%d,%ld)\n",
                        s, 0, s);
                else
                    Bprint(&bso, " lc%ld(%d,%ld)\n",
                        s, 0, s);
                Bprint(&bso, "%6lux %P\n",
                    p->pc, p);
            }
            lcsize += 5;
            continue;
        }
        if(s > 0) {
            cput(0+s);	/* 1-64 +lc */
            if(debug['V']) {
                Bprint(&bso, " lc+%ld(%ld)\n", s, 0+s);
                Bprint(&bso, "%6lux %P\n",
                    p->pc, p);
            }
        } else {
            cput(64-s);	/* 65-128 -lc */
            if(debug['V']) {
                Bprint(&bso, " lc%ld(%ld)\n", s, 64-s);
                Bprint(&bso, "%6lux %P\n",
                    p->pc, p);
            }
        }
        lcsize++;
    }
    while(lcsize & 1) {
        s = 129;
        cput(s);
        lcsize++;
    }
    if(debug['v'] || debug['V'])
        Bprint(&bso, "lcsize = %ld\n", lcsize);
    Bflush(&bso);
}
@




\chapter{Profiling Support}
\label{chap:profiling}

% surprising again that it's ld's job to add profiling in plan9

% The code below is interesting because it inserts extra object code using
% directly "AST" constructs, so it helps to understand the data structure!!

% see NOPROF of 8.out.h in Assembler_extra.nw

\section{[[5l -p]]}


% where is defined _mainp? lib_core/libc/386/main9p.s
<<[[main()]] adjust INITENTRY if profiling>>=
if(debug['p'])
    INITENTRY = "_mainp";
@

% 5l -p -1
% before dotext() (it matters since doprof generates code)
<<[[main()]] call doprofxxx() if profiling>>=
if(debug['p'])
    if(debug['1'])
        doprof1();
    else
        doprof2();
@

\section{[[__mcount[]]]}

% the idea o the code below is to add __mcount array, one index per function,
% and when call it increments the array at the right place.

% todo: who is using this information then? profreport of what?
% git grep __mcount does not seem to return stuff, maybe obsolete code?

<<function doprof1(arm)>>=
void
doprof1(void)
{
    Sym *s;
    long n;
    Prog *p, *q;

    DBG("%5.2f profile 1\n", cputime());

    s = lookup("__mcount", 0);
    n = 1;
    for(p = firstp->link; p != P; p = p->link) {
        if(p->as == ATEXT) {
            q = prg();
            q->line = p->line;

            // add_list(q, datap)
            q->link = datap;
            datap = q;

            // DATA __mcount +n*4(SB), 4,  $p->syn //$
            q->as = ADATA;
            q->from.type = D_OREG;
            q->from.symkind = N_EXTERN;
            q->from.offset = n*4;
            q->from.sym = s;
            q->reg = 4; // size of this DATA slice
            q->to = p->from;
            q->to.type = D_CONST;

            q = prg();
            q->line = p->line;
            q->pc = p->pc;
            
            q->link = p->link;
            p->link = q;
            p = q;

            // MOVW p->s + n*4+4(SB), R11
            p->as = AMOVW;
            p->from.type = D_OREG;
            p->from.symkind = N_EXTERN;
            p->from.sym = s;
            p->from.offset = n*4 + 4;
            p->to.type = D_REG;
            p->to.reg = REGTMP;

            q = prg();
            q->line = p->line;
            q->pc = p->pc;
            q->link = p->link;
            p->link = q;
            p = q;

            // ADD, $1, R11 //$
            p->as = AADD;
            p->from.type = D_CONST;
            p->from.offset = 1;
            p->to.type = D_REG;
            p->to.reg = REGTMP;

            q = prg();
            q->line = p->line;
            q->pc = p->pc;
            q->link = p->link;
            p->link = q;
            p = q;

            // MOVW R11, 
            p->as = AMOVW;
            p->from.type = D_REG;
            p->from.reg = REGTMP;
            p->to.type = D_OREG;
            p->to.symkind = N_EXTERN;
            p->to.sym = s;
            p->to.offset = n*4 + 4;

            n += 2;
            continue;
        }
    }
    q = prg();
    q->line = 0;
    q->link = datap;
    datap = q;

    q->as = ADATA;
    q->from.type = D_OREG;
    q->from.symkind = N_EXTERN;
    q->from.sym = s;
    q->reg = 4;
    q->to.type = D_CONST;
    q->to.offset = n;

    s->type = SBSS;
    s->value = n*4;
}
@


\section{[[_profin()]]}

% _profin() is defined by lib_core/libc/port/profile.c
% (_tracin() is defined by you)

% todo: why s2 and s4? why not sin, sout? and pin, pout?


<<global brcond(arm)>>=
static int brcond[] = {ABEQ, ABNE, ABHS, ABLO, ABMI, ABPL, ABVS, ABVC, ABHI, ABLS, ABGE, ABLT, ABGT, ABLE};
@

<<function doprof2(arm)>>=
void
doprof2(void)
{
    Sym *s2, *s4;
    Prog *p, *q, *q2;
    Prog *ps2, *ps4;

    DBG("%5.2f profile 2\n", cputime());

    <<[[doprof2()]] if embedded tracing>>
    else{
        s2 = lookup("_profin", 0);
        s4 = lookup("_profout", 0);
    }
    if(s2->type != STEXT || s4->type != STEXT) {
       <<[[doprof2()]] if embedded tracing diag()>>
        else
            diag("_profin/_profout not defined");
        return;
    }

    // finding ps2, ps4 = instruction (Prog) of s2 and s4
    ps2 = P;
    ps4 = P;
    for(p = firstp; p != P; p = p->link) {
        if(p->as == ATEXT) {
            if(p->from.sym == s2) {
                ps2 = p;
                p->reg = 1;
            }
            if(p->from.sym == s4) {
                ps4 = p;
                p->reg = 1;
            }
        }
    }
    for(p = firstp; p != P; p = p->link) {
        if(p->as == ATEXT) {

            <<[[doprof2()]] if NOPROF p(arm)>>

            /*
             * BL	profin
             */
            q = prg();
            q->line = p->line;
            q->pc = p->pc;
            q->link = p->link;

            <<[[doprof2()]] if embedded tracing ATEXT instrumentation(arm)>>
            else
                p->link = q;
            p = q;
            p->as = ABL;
            p->to.type = D_BRANCH;
            p->cond = ps2;
            p->to.sym = s2;

            continue;
        }
        if(p->as == ARET) {
            <<[[doprof2()]] if embedded tracing ARET instrumentation>>
            /*
             * RET
             */
            q = prg();
            q->as = ARET;
            q->from = p->from;
            q->to = p->to;
            q->cond = p->cond;
            q->link = p->link;
            q->reg = p->reg;
            p->link = q;

            if(p->scond != COND_ALWAYS) {
                q = prg();
                q->as = ABL;
                q->from = zprg.from;
                q->to = zprg.to;
                q->to.type = D_BRANCH;
                q->cond = ps4;
                q->to.sym = s4;
                q->link = p->link;
                p->link = q;

                p->as = brcond[p->scond^1];	/* complement */
                p->scond = COND_ALWAYS;
                p->from = zprg.from;
                p->to = zprg.to;
                p->to.type = D_BRANCH;
                p->cond = q->link->link;	/* successor of RET */
                p->to.offset = q->link->link->pc;

                p = q->link->link;
            } else {

                /*
                 * BL	profout
                 */
                p->as = ABL;
                p->from = zprg.from;
                p->to = zprg.to;
                p->to.type = D_BRANCH;
                p->cond = ps4;
                p->to.sym = s4;
                p->scond = COND_ALWAYS;

                p = q;
            }
            continue;
        }
    }
}
@



\section{[[5l -e]], [[_tracin()]]}

% -p -e, -e for embedded tracing

<<[[doprof2()]] if embedded tracing>>=
if(debug['e']){
    s2 = lookup("_tracein", 0);
    s4 = lookup("_traceout", 0);
}
@

<<[[doprof2()]] if embedded tracing diag()>>=
if(debug['e'])
    diag("_tracein/_traceout not defined %d %d", s2->type, s4->type);
@


<<[[doprof2()]] if embedded tracing ATEXT instrumentation(arm)>>=
if(debug['e']){		/* embedded tracing */
    q2 = prg();
    p->link = q2;
    q2->link = q;

    q2->line = p->line;
    q2->pc = p->pc;

    q2->as = AB;
    q2->to.type = D_BRANCH;
    q2->to.sym = p->to.sym;
    q2->cond = q->link;
}
@

<<[[doprof2()]] if embedded tracing ARET instrumentation>>=
/*
 * RET (default)
 */
if(debug['e']){		/* embedded tracing */
    q = prg();
    q->line = p->line;
    q->pc = p->pc;
    q->link = p->link;
    p->link = q;
    p = q;
}
@

\section{Disabling profiling attribute, [[NOPROF]]}

% NOPROF is in 5.out.h (in Assembler_extra.nw)

<<[[doprof2()]] if NOPROF p(arm)>>=
if(p->reg & NOPROF) {
    for(;;) {
        q = p->link;
        if(q == P || q->as == ATEXT)
            break;
        p = q;
    }
    continue;
}
@
%grrr continue, break, grrr


% useful for the tracing instructions themselves ... hmmm






\chapter{Advanced Topics}
\label{chap:advanced}

\section{Optimisations}

\subsection{Opcode rewriting}
% at loading time

% would be better with ocaml pattern matching (but maybe not that shorter)
<<[[ldobj()]] switch opcode cases(arm)>>=
case ASUB:
    if(p->from.type == D_CONST)
     if(p->from.symkind == D_NONE)
      if(p->from.offset < 0) {
        p->from.offset = -p->from.offset;
        p->as = AADD;
    }
    goto casedef;
@
<<[[ldobj()]] switch opcode cases(arm)>>=
case AADD:
    if(p->from.type == D_CONST)
     if(p->from.symkind == D_NONE)
      if(p->from.offset < 0) {
        p->from.offset = -p->from.offset;
        p->as = ASUB;
    }
    goto casedef;
@

% see also before in previous section the Leaf procedure opti,
% a form of opcode rewriting where some TEXT and RET can
% be optimized.

\subsection{Operand rewriting}

% certain operand values immediate values can be in a certain range
% which then can be encoded as a single instruction.

% If they are out of range but a double of 2, then again
% can be encoded as a single instruction.

% otherwise have to decompose.

\subsection{Small data layout}
% improve data cache miss?

<<enum sxxx cases>>=
SDATA1,
@

<<constant MINSIZ>>=
MINSIZ		= 64,
@


<<[[dodata()]] if small data size>>=
/*
 *	assign 'small' variables to data segment
 *	(rational is that data segment is more easily
 *	 addressed through offset on R12)
 */
if(v <= MINSIZ) {
    s->value = orig;
    orig += v;
    s->type = SDATA1;
}
@

<<[[dodata()]] pass2, retag small data>>=
if(t == SDATA1)
    s->type = SDATA;
@





\subsection{Removing useless instructions, [[follow()]]}
% a space optimisation more than speed opti (but can help speed
% a bit maybe because of icache)

%note: right now it's not executed by 5l

% Note that this code does not remove the unused functions
% The size of helloc is very small but mainly because of
% loadlib() and objfile() on demand loading strategy of used
% but not yet defined (SXREF) symbols (and multiple passes
% on library symbol table until fixpoint).

% Here I think it's mostly for unreachable code, and chains of direct jmps.
% Note that useful I think.

% does not remove all unreachable instrs so,
% and does not remove unreachable functions :( maybe more important

%less: print the removed code!! usuful diagnostic no?

%if remove follow() optimisations, can have far simpler linker no?
%just dodata(), and simple asmb()? no need patch(), follow()?
%need patch(), because need to link to pc that will change when
%generate the actual instructions.


<<function follow>>=
void
follow(void)
{

    DBG("%5.2f follow\n", cputime());

    firstp = prg();
    lastp = firstp;

    xfol(textp);

    lastp->link = P;
    firstp = firstp->link;
}
@

<<enum mark cases>>=
FOLL		= 1<<0,
@
% >>
% foll for follow?



% xfol? extended follow?
<<function xfol(arm)>>=
void
xfol(Prog *p)
{
    Prog *q, *r;
    int a, i;

loop:
    if(p == P)
        return;
    <<adjust curtext when iterate over instructions p>>
    a = p->as;

    if(a == AB) {
        q = p->cond;
        if(q != P) {
            p->mark |= FOLL;
            p = q;
            if(!(p->mark & FOLL))
                goto loop;
        }
    }

    if(p->mark & FOLL) {
        <<[[xfol()]] when p is marked, for loop to copy instructions>>
        a = AB;
        q = prg();
        q->as = a;
        q->line = p->line;
        q->to.type = D_BRANCH;
        q->to.offset = p->pc;
        q->cond = p;
        p = q;
    }

    p->mark |= FOLL;
    lastp->link = p;
    lastp = p;

    if(a == AB || (a == ARET && p->scond == COND_ALWAYS) || a == ARFE){
        return;
    }

    if(p->cond != P)
     <<[[xfol()]] if a is not ABL and p has a link>>
    p = p->link;
    goto loop;
}
@



<<[[xfol()]] if a is not ABL and p has a link>>=
if(a != ABL && p->link != P) {
   q = brchain(p->link);

   if(a != ATEXT && a != ABCASE)
    if(q != P && (q->mark & FOLL)) {
       p->as = relinv(a);
       p->link = p->cond;
       p->cond = q;
   }

   // recursive call
   xfol(p->link);

   q = brchain(p->cond);
   if(q == P)
       q = p->cond;
   if(q->mark&FOLL) {
       p->cond = q;
       return;
   }
   p = q;
   goto loop;
}
@

% follows a chain of AB, hmm but needed now that has brloop()?
<<function brchain(arm)>>=
Prog*
brchain(Prog *p)
{
    int i;

    for(i=0; i<20; i++) {
        if(p == P || p->as != AB)
            return p;
        p = p->cond;
    }
    return P;
}
@

<<function relinv(arm)>>=
int
relinv(int a)
{
    switch(a) {
    case ABEQ:	return ABNE;
    case ABNE:	return ABEQ;
    case ABHS:	return ABLO;
    case ABLO:	return ABHS;
    case ABMI:	return ABPL;
    case ABPL:	return ABMI;
    case ABVS:	return ABVC;
    case ABVC:	return ABVS;
    case ABHI:	return ABLS;
    case ABLS:	return ABHI;
    case ABGE:	return ABLT;
    case ABLT:	return ABGE;
    case ABGT:	return ABLE;
    case ABLE:	return ABGT;
    }
    diag("unknown relation: %s", anames[a]);
    return a;
}
@





<<[[xfol()]] when p is marked, for loop to copy instructions>>=
for(i=0, q=p; i<4 && q != lastp; i++, q=q->link) {
    a = q->as;
    if(a == ANOP) {
        i--;
        continue;
    }
    if(a == AB || (a == ARET && q->scond == COND_ALWAYS) || a == ARFE)
        goto copy;
    if(!q->cond || (q->cond->mark & FOLL))
        continue;
    if(a != ABEQ && a != ABNE)
        continue;

// here when a is one of AB, ARET, ARFE, ABEQ, ABNE
copy:
    for(;;) {
        r = prg();
        *r = *p;

        <<[[xfol()]] sanity check one, r should be marked>>

        if(p != q) {
            p = p->link;
            lastp->link = r;
            lastp = r;
            continue;
        }
        lastp->link = r;
        lastp = r;

        if(a == AB || (a == ARET && q->scond == COND_ALWAYS) || a == ARFE)
            return;

        // r->as = relinv(a)
        r->as = ABNE;
        if(a == ABNE)
            r->as = ABEQ;

        r->cond = p->link;
        r->link = p->cond;

        if(!(r->link->mark&FOLL))
            // recursive call
            xfol(r->link);

        <<[[xfol()]] sanity check two, [[r->cond]] should be marked>>

        return;
    }
}
@
%old: had        
% if(q == lastp)
%    break;
% at beginning of the for loop, but I moved it up in the for(;_here_;) instead
% (equivalent)




\ifallcode
<<[[xfol()]] sanity check one, r should be marked>>=
if(!(r->mark&FOLL))
    print("cant happen 1\n");
r->mark |= FOLL;
@

<<[[xfol()]] sanity check two, [[r->cond]] should be marked>>=
if(!(r->cond->mark&FOLL))
    print("cant happen 2\n");
@
\fi



\section{Strings in text segment, [[5l -t]]}

% what for? so cannot be modified? text is marked as writable
%  in Kernel.nw?
% for constant strings? an optimisation?

<<enum sxxx cases>>=
SSTRING, // arm
@

<<[[dodata()]] if string in text segment>>=
if(debug['t']) {
    /*
     * pull out string constants
     */
    for(p = datap; p != P; p = p->link) {
        s = p->from.sym;
        if(p->to.type == D_SCONST)
            s->type = SSTRING;
    }
}
@


% after has layout all the TEXT instrs, can put behind the strings.
<<[[span()]] if string in text segment>>=
if(debug['t']) {
    /* 
     * add strings to text segment
     */
    c = rnd(c, 8);
    for(i=0; i<NHASH; i++)
     for(s = hash[i]; s != S; s = s->link)
      if(s->type == SSTRING) {
          v = s->value;
          while(v & 3)
              v++;
          s->value = c;
          c += v;
      }
}
@




\section{Overriding symbols attribute, [[DUPOK]]}

% case in kernel where override a previous symbol,
% e.g. sysfatal, werrstr

% DUPOK, x.scale & DUPOK

<<[[ldobj()]] case ATEXT and section not SNONE or SXREF, if DUPOK>>=
if(p->reg & DUPOK) {
    skip = true;
    goto casedef;
}
@

\section{Dynamic linking}
\label{sec:dynamic-linking}
\l dynamic loading?

%http://harmful.cat-v.org/software/dynamic-linking/

\subsection{Export table, [[5l -x]]}
% what this is for?

<<global doexp>>=
// do export table, -x
bool	doexp;
@


<<[[main()]] command line processing(arm)>>=
case 'x':	/* produce export table */
    doexp = true;
    if(argv[1] != nil && argv[1][0] != '-' && !isobjfile(argv[1]))
        readundefs(ARGF(), SEXPORT);
    break;
@
%in x86 there is also that
%        a = ARGF();
%        if(strcmp(a, "*") == 0)
%            allexport = true;
%        else

<<function isobjfile>>=
static int
isobjfile(char *f)
{
    int n, v;
    Biobuf *b;
    char buf1[5], buf2[SARMAG];

    b = Bopen(f, OREAD);
    if(b == nil)
        return 0;
    n = Bread(b, buf1, 5);
    if(n == 5 && (buf1[2] == 1 && buf1[3] == '<' || buf1[3] == 1 && buf1[4] == '<'))
        v = 1;	/* good enough for our purposes */
    else{
        Bseek(b, 0, 0);
        n = Bread(b, buf2, SARMAG);
        v = n == SARMAG && strncmp(buf2, ARMAG, SARMAG) == 0;
    }
    Bterm(b);
    return v;
}
@


<<global EXPTAB>>=
char*	EXPTAB;
@


<<[[main()]] if export table or dynamic module(arm)>>=
if(doexp || dlm){
    EXPTAB = "_exporttab";
    zerosig(EXPTAB);
    zerosig("etext");
    zerosig("edata");
    zerosig("end");

    <<[[main()]] if dynamic module(arm)>>
    else
        divsig();

    export();
}
@



<<function zerosig>>=
void
zerosig(char *sp)
{
    Sym *s;

    s = lookup(sp, 0);
    s->sig = 0;
}
@



<<global nimports>>=
int nimports;
@

<<global nexports>>=
int nexports;
@

<<global imports>>=
int	imports;
@

<<global exports>>=
int	exports;
@


<<[[Sym]] other fields>>=
// enum<section> too?
short	subtype;
@
%old: was char


<<function readundefs>>=
void
readundefs(char *f, int t)
{
    int i, n;
    Sym *s;
    Biobuf *b;
    char *l, buf[256], *fields[64];

    if(f == nil)
        return;
    b = Bopen(f, OREAD);
    if(b == nil){
        diag("could not open %s: %r", f);
        errorexit();
    }
    while((l = Brdline(b, '\n')) != nil){
        n = Blinelen(b);
        if(n >= sizeof(buf)){
            diag("%s: line too long", f);
            errorexit();
        }
        memmove(buf, l, n);
        buf[n-1] = '\0';
        n = getfields(buf, fields, nelem(fields), 1, " \t\r\n");
        if(n == nelem(fields)){
            diag("%s: bad format", f);
            errorexit();
        }
        for(i = 0; i < n; i++){
            s = lookup(fields[i], 0);
            s->type = SXREF;
            s->subtype = t;
            if(t == SIMPORT)
                nimports++;
            else
                nexports++;
        }
    }
    Bterm(b);
}
@




<<function export(arm)>>=
void
export(void)
{
    int i, j, n, off, nb, sv, ne;
    Sym *s, *et, *str, **esyms;
    Prog *p;
    char buf[NSNAME], *t;

    n = 0;
    for(i = 0; i < NHASH; i++)
        for(s = hash[i]; s != S; s = s->link)
            if(s->sig != 0 && s->type != SXREF && s->type != SUNDEF && (nexports == 0 || s->subtype == SEXPORT))
                n++;
    esyms = malloc(n*sizeof(Sym*));
    ne = n;
    n = 0;
    for(i = 0; i < NHASH; i++)
        for(s = hash[i]; s != S; s = s->link)
            if(s->sig != 0 && s->type != SXREF && s->type != SUNDEF && (nexports == 0 || s->subtype == SEXPORT))
                esyms[n++] = s;
    for(i = 0; i < ne-1; i++)
        for(j = i+1; j < ne; j++)
            if(strcmp(esyms[i]->name, esyms[j]->name) > 0){
                s = esyms[i];
                esyms[i] = esyms[j];
                esyms[j] = s;
            }

    nb = 0;
    off = 0;
    et = lookup(EXPTAB, 0);
    if(et->type != 0 && et->type != SXREF)
        diag("%s already defined", EXPTAB);
    et->type = SDATA;
    str = lookup(".string", 0);
    if(str->type == 0)
        str->type = SDATA;
    sv = str->value;
    for(i = 0; i < ne; i++){
        s = esyms[i];
        Bprint(&bso, "EXPORT: %s sig=%lux t=%d\n", s->name, s->sig, s->type);

        /* signature */
        p = newdata(et, off, sizeof(long), N_EXTERN);
        off += sizeof(long);
        p->to.offset = s->sig;

        /* address */
        p = newdata(et, off, sizeof(long), N_EXTERN);
        off += sizeof(long);
        p->to.symkind = N_EXTERN;
        p->to.sym = s;

        /* string */
        t = s->name;
        n = strlen(t)+1;
        for(;;){
            buf[nb++] = *t;
            sv++;
            if(nb >= NSNAME){
                p = newdata(str, sv-NSNAME, NSNAME, N_INTERN);
                p->to.type = D_SCONST;
                p->to.sval = malloc(NSNAME);
                memmove(p->to.sval, buf, NSNAME);
                nb = 0;
            }
            if(*t++ == 0)
                break;
        }

        /* name */
        p = newdata(et, off, sizeof(long), N_EXTERN);
        off += sizeof(long);
        p->to.symkind = N_INTERN;
        p->to.sym = str;
        p->to.offset = sv-n;
    }

    if(nb > 0){
        p = newdata(str, sv-nb, nb, N_INTERN);
        p->to.type = D_SCONST;
        p->to.sval = malloc(NSNAME);
        memmove(p->to.sval, buf, nb);
    }

    for(i = 0; i < 3; i++){
        newdata(et, off, sizeof(long), N_EXTERN);
        off += sizeof(long);
    }
    et->value = off;
    if(sv == 0)
        sv = 1;
    str->value = sv;
    exports = ne;
    free(esyms);
}
@




<<function newdata(arm)>>=
static Prog*
newdata(Sym *s, int o, int w, int t)
{
    Prog *p;

    p = prg();
    p->link = datap;
    datap = p;

    p->as = ADATA;
    p->reg = w;
    p->from.type = D_OREG;
    p->from.symkind = t;
    p->from.sym = s;
    p->from.offset = o;
    p->to.type = D_CONST;
    p->to.symkind = D_NONE;

    return p;
}
@



\subsection{Dynamic loading, [[5l -u]]}

% been disabled? can not find man page for dynld anymore, nor dynld.h
% -x, -u
% see dynld(2)

%see also rational for no dyn loading!
%http://sta.li/

<<global dlm>>=
bool dlm;
@

<<enum sxxx cases>>=
SIMPORT,
SEXPORT,
@



<<[[main()]] command line processing(arm)>>=
case 'u':	/* produce dynamically loadable module */
    dlm = true;
    if(argv[1] != nil && argv[1][0] != '-' && !isobjfile(argv[1]))
        readundefs(ARGF(), SIMPORT);
    break;
@
%x86 had this too:
%    // do not load standard libraries
%    debug['l'] = true;


<<[[asmb()]] if dynamic module magic header adjustment(arm)>>=
if(dlm)
    lput(0x80000000|0x647);	/* magic */
@




% import(), pending of export() ?

<<[[main()]] if dynamic module(arm)>>=
if(dlm){
    initdiv();
    import();
    HEADTYPE = H_PLAN9;
    INITTEXT = INITDAT = 0;
    INITRND = 8;
    INITENTRY = EXPTAB;
}
@





<<global dtype(arm)>>=
int	dtype = 4;
@

<<[[dodata()]] if ADYNT or AINIT>>=
if(p->as == ADYNT || p->as == AINIT)
    s->value = dtype;
@




<<function import(arm)>>=
void
import(void)
{
    int i;
    Sym *s;

    for(i = 0; i < NHASH; i++)
        for(s = hash[i]; s != S; s = s->link)
            if(s->sig != 0 && s->type == SXREF && (nimports == 0 || s->subtype == SIMPORT)){
                undefsym(s);
                Bprint(&bso, "IMPORT: %s sig=%lux v=%ld\n", s->name, s->sig, s->value);
            }
}
@

%on x86 additiona check and features, integrate them?
%                if(s->value != 0)
%                    diag("value != 0 on SXREF");
%                undefsym(s);
%                if(debug['X'])
%                    Bprint(&bso, "IMPORT: %s sig=%lux v=%ld\n", s->name, s->sig, s->value);
%                if(debug['S'])
%                    s->sig = 0;


<<enum rxxx>>=
enum rxxx {
    Roffset	= 22,		/* no. bits for offset in relocation address */
    Rindex	= 10,		/* no. bits for index in relocation address */
};
@

<<enum sxxx cases>>=
SUNDEF,
@
% for ??

<<[[patch()]] switch section type for branch instruction, cases>>=
case SUNDEF:
    if(p->as != ABL)
        diag("help: SUNDEF in AB || ARET");
    p->to.offset = 0;
    p->to.type = D_BRANCH;
    p->cond = UP;
    break;
@

<<[[asmout()]] BRA case, if undefined target>>=
if(p->cond == UP) {
    s = p->to.sym;
    if(s->type != SUNDEF)
        diag("bad branch sym type");
    v = (ulong)s->value >> (Roffset-2);
    dynreloc(s, p->pc, 0);
}
@


% import -> undefsym
<<function undefsym>>=
void
undefsym(Sym *s)
{
    int n;

    n = imports;
    if(s->value != 0)
        diag("value != 0 on SXREF");
    if(n >= 1<<Rindex)
        diag("import index %d out of range", n);
    s->value = n<<Roffset;
    s->type = SUNDEF;
    imports++;
}
@
%>> >>



% port to arm?
%<<[[asmb()]] if dynamic module, when iterate from firstp(xxx)>>=
%if(dlm) {
%    if(p->as == ATEXT)
%        reloca = nil;
%    else if(reloca != nil)
%        diag("reloc failure: %P", curp);
%}
%@


% ???
<<[[asmb()]] if dynamic module, before datblk()>>=
if(dlm){
    char buf[8];

    write(cout, buf, INITDAT-textsize);
    textsize = INITDAT;
}
@

<<[[asmb()]] if dynamic module and no symbol table generation>>=
if(dlm){
    seek(cout, HEADR+textsize+datsize, 0);
    asmdyn();
    cflush();
}
@


<<[[entryvalue()]] if dynamic module case>>=
case SDATA:
    if(dlm)
        return s->value+INITDAT;
@





<<struct Reloc>>=
struct Reloc
{
    int n;
    int t;
    byte *m;
    ulong *a;
};
@

<<global rels>>=
Reloc rels;
@



<<[[asmb()]] if dynamic module, call asmdyn()>>=
if(dlm)
    asmdyn();
@

% asmb() -> asmdyn()

<<function asmdyn>>=
void
asmdyn()
{
    int i, n, t, c;
    Sym *s;
    ulong la, ra, *a;
    vlong off;
    byte *m;
    Reloc *r;

    cflush();
    off = seek(cout, 0, 1);
    lput(0);
    t = 0;
    lput(imports);
    t += 4;
    for(i = 0; i < NHASH; i++)
        for(s = hash[i]; s != S; s = s->link)
            if(s->type == SUNDEF){
                lput(s->sig);
                t += 4;
                t += sput(s->name);
            }

    la = 0;
    r = &rels;
    n = r->n;
    m = r->m;
    a = r->a;
    lput(n);
    t += 4;
    for(i = 0; i < n; i++){
        ra = *a-la;
        if(*a < la)
            diag("bad relocation order");
        if(ra < 256)
            c = 0;
        else if(ra < 65536)
            c = 1;
        else
            c = 2;
        cput((c<<6)|*m++);
        t++;
        if(c == 0){
            cput(ra);
            t++;
        }
        else if(c == 1){
            wput(ra);
            t += 2;
        }
        else{
            lput(ra);
            t += 4;
        }
        la = *a++;
    }

    cflush();
    seek(cout, off, 0);
    lput(t);

    DBG("import table entries = %d\n", imports);
    DBG("export table entries = %d\n", exports);
}
@
% >> >>

<<function sput>>=
static int
sput(char *s)
{
    char *p;

    p = s;
    while(*s)
        cput(*s++);
    cput(0);
    return  s-p+1;
}
@



<<global modemap>>=
int modemap[4] = { 0, 1, -1, 2, };
@


<<[[datblk()]] if dynamic module(arm)>>=
if(dlm)
    dynreloc(v, a+INITDAT, 1);
@


<<enum _anon_ (linkers/5l/span.c)(arm)>>=
enum{
    ABSD = 0,
    ABSU = 1,
    RELD = 2,
    RELU = 3,
};
@


<<function dynreloc(arm)>>=
void
dynreloc(Sym *s, long v, int abs)
{
    int i, k, n;
    byte *m;
    ulong *a;
    Reloc *r;

    if(v&3)
        diag("bad relocation address");
    v >>= 2;

    if(s != S && s->type == SUNDEF)
        k = abs ? ABSU : RELU;
    else
        k = abs ? ABSD : RELD;
    /* Bprint(&bso, "R %s a=%ld(%lx) %d\n", s->name, a, a, k); */
    k = modemap[k];
    r = &rels;
    n = r->n;
    if(n >= r->t)
        grow(r);
    m = r->m;
    a = r->a;
    for(i = n; i > 0; i--){
        if(v < a[i-1]){	/* happens occasionally for data */
            m[i] = m[i-1];
            a[i] = a[i-1];
        }
        else
            break;
    }
    m[i] = k;
    a[i] = v;
    r->n++;
}
@
% the align 4 check at the beginning are ARM specific

<<function grow>>=
static void
grow(Reloc *r)
{
    int t;
    byte *m, *nm;
    ulong *a, *na;

    t = r->t;
    r->t += 64;
    m = r->m;
    a = r->a;
    r->m = nm = malloc(r->t * sizeof(byte));
    r->a = na = malloc(r->t * sizeof(ulong));
    memmove(nm, m, t*sizeof(byte));
    memmove(na, a, t*sizeof(ulong));
    free(m);
    free(a);
}
@


\subsection{[[ADYNT]]}
% ???
% mv with dlm?
% seems never produced by 5a/5c
% was for alef?


<<[[ldobj()]] locals(arm)>>=
Sym *di = S;
@

<<enum sxxx cases>>=
SCONST,
@
% SCONST ... hmm confusing with D_SCONST IMHO

<<[[ldobj()]] switch opcode cases(arm)>>=
case ADYNT:
    if(p->to.sym == S) {
        diag("DYNT without a sym\n%P", p);
        break;
    }
    di = p->to.sym;
    p->reg = 4;
    if(di->type == SXREF) {
        if(debug['z'])
            Bprint(&bso, "%P set to %d\n", p, dtype);
        di->type = SCONST;
        di->value = dtype;
        dtype += 4;
    }
    if(p->from.sym == S)
        break;

    p->from.offset = di->value;
    p->from.sym->type = SDATA;
    if(curtext == P) {
        diag("DYNT not in text: %P", p);
        break;
    }
    p->to.sym = curtext->from.sym;
    p->to.type = D_CONST;
    p->link = datap;
    datap = p;
    break;
@



\subsection{[[AINIT]]}
% seems never produced by 5a/5c, like ADYNT, so move?
% seems to be just after a ADYNT, see the error message below


<<[[ldobj()]] switch opcode cases(arm)>>=
case AINIT:
    if(p->from.sym == S) {
        diag("INIT without a sym\n%P", p);
        break;
    }
    if(di == S) {
        diag("INIT without previous DYNT\n%P", p);
        break;
    }
    p->from.offset = di->value;
    p->from.sym->type = SDATA;
    p->link = datap;
    datap = p;
    break;

@

\subsection{Relocatable address, [[C_ADDR]]}

<<cxxx(arm) cases>>=
C_ADDR,		/* relocatable address */
@

<<[[aclass()]] when D_OREG and external symbol and dlm>>=
if(dlm) {
    switch(t) {
    case SUNDEF:
    case STEXT: case SLEAF: case SSTRING:
    case SCONST: 
        instoffset = s->value + a->offset;
        break;
    case SDATA: case SBSS:
    default:
        instoffset = s->value + a->offset + INITDAT;
        break;
    }
    return C_ADDR;
}
@
% I added the case SDATA: case SBSS:
% in default should return exn if not SDATA or SBSS no?

<<[[optab]] entries>>=
{ ATEXT,	C_ADDR,	C_NONE,	C_LCON, 	 0, 0, 0 },
{ ATEXT,	C_ADDR,	C_REG,	C_LCON, 	 0, 0, 0 },
@

<<[[optab]] entries>>=
{ AWORD,	C_NONE,	C_NONE,	C_ADDR,		11, 4, 0 },
@

<<[[asmout()]] on WORD case, switch class cases>>=
case C_LCON:
    if(!dlm)
        break;
    if(p->to.symkind != N_EXTERN && p->to.symkind != N_INTERN)
        break;
    // Fallthrough
case C_ADDR:
    if(p->to.sym->type == SUNDEF)
        ckoff(p->to.sym, p->to.offset);
    dynreloc(p->to.sym, p->pc, 1);
@

% Store
<<[[optab]] entries>>=
{ AMOVW,	C_REG,	C_NONE,	C_ADDR,		64, 8, 0,	LTO },
{ AMOVB,	C_REG,	C_NONE,	C_ADDR,		64, 8, 0,	LTO },
{ AMOVBU,	C_REG,	C_NONE,	C_ADDR,		64, 8, 0,	LTO },
@

<<[[asmout()]] switch on type cases>>=
/* reloc ops */
case 64:	/* mov/movb/movbu R,addr */
    o1 = omvl(p, &p->to, REGTMP);
    if(!o1)
        break;
    o2 = osr(p->as, p->from.reg, 0, REGTMP, p->scond);
    break;
@

% Load
<<[[optab]] entries>>=
{ AMOVW,	C_ADDR,	C_NONE,	C_REG,		65, 8, 0,	LFROM },
{ AMOVBU,	C_ADDR,	C_NONE,	C_REG,		65, 8, 0,	LFROM },
{ AMOVB,	C_ADDR,	C_NONE,	C_REG,		66, 16, 0,	LFROM },
{ AMOVH,	C_ADDR,	C_NONE,	C_REG,		66, 16, 0,	LFROM },
{ AMOVHU,	C_ADDR,	C_NONE,	C_REG,		66, 16, 0,	LFROM },
@


<<[[asmout()]] switch on type cases>>=
case 65:	/* mov/movbu addr,R */
case 66:	/* movh/movhu/movb addr,R */
    o1 = omvl(p, &p->from, REGTMP);
    if(!o1)
        break;
    o2 = olr(0, REGTMP, p->to.reg, p->scond);
    if(p->as == AMOVBU || p->as == AMOVB)
        o2 |= 1<<22;
    if(o->type == 65)
        break;

    o3 = oprrr(ASLL, p->scond);

    if(p->as == AMOVBU || p->as == AMOVHU)
        o4 = oprrr(ASRL, p->scond);
    else
        o4 = oprrr(ASRA, p->scond);

    r = p->to.reg;
    o3 |= (r)|(r<<12);
    o4 |= (r)|(r<<12);
    if(p->as == AMOVB || p->as == AMOVBU) {
        o3 |= (24<<7);
        o4 |= (24<<7);
    } else {
        o3 |= (16<<7);
        o4 |= (16<<7);
    }
    break;
@
% >> >> >> >> >> >> >>

<<[[optab]] entries>>=
{ AMOVH,	C_REG,	C_NONE,	C_ADDR,		67, 24, 0,	LTO },
{ AMOVHU,	C_REG,	C_NONE,	C_ADDR,		67, 24, 0,	LTO },
@

<<[[asmout()]] switch on type cases>>=
case 67:	/* movh/movhu R,addr -> sb, sb */
    o1 = omvl(p, &p->to, REGTMP);
    if(!o1)
        break;
    o2 = osr(p->as, p->from.reg, 0, REGTMP, p->scond);

    o3 = oprrr(ASRL, p->scond);
    o3 |= (8<<7)|(p->from.reg)|(p->from.reg<<12);
    o3 |= (1<<6);	/* ROR 8 */

    o4 = oprrr(AADD, p->scond);
    o4 |= (REGTMP << 12) | (REGTMP << 16);
    o4 |= immrot(1);

    o5 = osr(p->as, p->from.reg, 0, REGTMP, p->scond);

    o6 = oprrr(ASRL, p->scond);
    o6 |= (24<<7)|(p->from.reg)|(p->from.reg<<12);
    o6 |= (1<<6);	/* ROL 8 */
    break;
@
% >> >> >> >> >> >> >> >>




\section{Other executable formats}
\label{sec:other-executable-formats}


%<<[[main()]] switch HEADTYPE cases(arm)>>=
%case 0:	/* no header */
%case 6:	/* no header, padded segments */
%    HEADR = 0L;
%    if(INITTEXT == -1)
%        INITTEXT = 0;
%    if(INITDAT == -1)
%        INITDAT = 0;
%    if(INITRND == -1)
%        INITRND = 4;
%    break;
%case 1:	/* aif for risc os */
%    HEADR = 128L;
%    if(INITTEXT == -1)
%        INITTEXT = 0x10005000 + HEADR;
%    if(INITDAT == -1)
%        INITDAT = 0;
%    if(INITRND == -1)
%        INITRND = 4;
%    break;
%case 3:	/* boot for NetBSD */
%    HEADR = 32L;
%    if(INITTEXT == -1)
%        INITTEXT = 0xF0000020L;
%    if(INITDAT == -1)
%        INITDAT = 0;
%    if(INITRND == -1)
%        INITRND = 4096;
%    break;
%case 4: /* boot for IXP1200 */
%    HEADR = 0L;
%    if(INITTEXT == -1)
%        INITTEXT = 0x0;
%    if(INITDAT == -1)
%        INITDAT = 0;
%    if(INITRND == -1)
%        INITRND = 4;
%    break;
%case 5: /* boot for ipaq */
%    HEADR = 16L;
%    if(INITTEXT == -1)
%        INITTEXT = 0xC0008010;
%    if(INITDAT == -1)
%        INITDAT = 0;
%    if(INITRND == -1)
%        INITRND = 1024;
%    break;

%<<[[asmb()]] switch HEADTYPE (to position after text) cases(arm)>>=
%case 0:
%case 1:
%case 5:
%...
%case 3:
%case 6:	/* no header, padded segments */
%    OFFSET = rnd(HEADR+textsize, 4096);
%    seek(cout, OFFSET, 0);
%    break;


%<<[[asmb()]] switch HEADTYPE (for symbol table generation) cases(arm)>>=
%case 0:
%case 1:
%case 4:
%case 5:
%    debug['s'] = 1;
%    break;
%case 3:
%case 6:	/* no header, padded segments */
%    OFFSET += rnd(datsize, 4096);
%    seek(cout, OFFSET, 0);
%    break;


%<<[[asmb()]] switch HEADTYPE (for header generation) cases(arm)>>=
%case 0:	/* no header */
%case 6:	/* no header, padded segments */
%    break;
%case 1:	/* aif for risc os */
%    lputl(0xe1a00000);		/* NOP - decompress code */
%    lputl(0xe1a00000);		/* NOP - relocation code */
%    lputl(0xeb000000 + 12);		/* BL - zero init code */
%    lputl(0xeb000000 +
%        (entryvalue()
%         - INITTEXT
%         + HEADR
%         - 12
%         - 8) / 4);		/* BL - entry code */
%
%    lputl(0xef000011);		/* SWI - exit code */
%    lputl(textsize+HEADR);		/* text size */
%    lputl(datsize);			/* data size */
%    lputl(0);			/* sym size */
%
%    lputl(bsssize);			/* bss size */
%    lputl(0);			/* sym type */
%    lputl(INITTEXT-HEADR);		/* text addr */
%    lputl(0);			/* workspace - ignored */
%
%    lputl(32);			/* addr mode / data addr flag */
%    lputl(0);			/* data addr */
%    for(t=0; t<2; t++)
%        lputl(0);		/* reserved */
%
%    for(t=0; t<15; t++)
%        lputl(0xe1a00000);	/* NOP - zero init code */
%    lputl(0xe1a0f00e);		/* B (R14) - zero init return */
%    break;
%case 3:	/* boot for NetBSD */
%    lput((143<<16)|0413);		/* magic */
%    lputl(rnd(HEADR+textsize, 4096));
%    lputl(rnd(datsize, 4096));
%    lputl(bsssize);
%    lputl(symsize);			/* nsyms */
%    lputl(entryvalue());		/* va of entry */
%    lputl(0L);
%    lputl(0L);
%    break;
%case 4: /* boot for IXP1200 */
%    break;
%case 5: /* boot for ipaq */
%    lputl(0xe3300000);		/* nop */
%    lputl(0xe3300000);		/* nop */
%    lputl(0xe3300000);		/* nop */
%    lputl(0xe3300000);		/* nop */
%    break;
% >> 

\subsection{Elf}


<<[[main()]] switch HEADTYPE cases(arm)>>=
case H_ELF:	/* elf executable */
    HEADR = rnd(Ehdr32sz+3*Phdr32sz, 16);
    if(INITTEXT == -1)
        INITTEXT = 4096+HEADR;
    if(INITDAT == -1)
        INITDAT = 0;
    if(INITRND == -1)
        INITRND = 4;
    break;
@

<<[[asmb()]] switch HEADTYPE (to position after text) cases(arm)>>=
case H_ELF:
    OFFSET = HEADR+textsize;
    seek(cout, OFFSET, 0);
    break;
@

<<[[asmb()]] switch HEADTYPE (for symbol table generation) cases(arm)>>=
case H_ELF:
    break;
@

<<[[asmb()]] switch HEADTYPE (for header generation) cases(arm)>>=
case H_ELF:
    debug['S'] = 1;			/* symbol table */
    elf32(ARM, ELFDATA2LSB, 0, nil);
    break;
@
% >>


% start text physical address (elf only)
<<global INITTEXTP>>=
long	INITTEXTP = -1; /* text location (physical) */
@

<<[[main()]] last INITXXX adjustments>>=
if (INITTEXTP == -1)
    INITTEXTP = INITTEXT;
@


<<[[main()]] command line processing(arm)>>=
case 'P':
    a = ARGF();
    if(a)
        INITTEXTP = atolwhex(a);
    break;
@
% seems dead?

<<enum _anon_ (linkers/8l/elf.h)>>=
enum {
    Ehdr32sz	= 52,
    Phdr32sz	= 32,
    Shdr32sz	= 40,

    Ehdr64sz	= 64,
    Phdr64sz	= 56,
    Shdr64sz	= 64,
};
@

\subsection{OMach}

\subsection{COFF}

\subsection{PE}
% windows format, see pe.h in golang/src/libmach/



\section{[[5l -E digits]]}
\l remove? used by who? useful feature? for -E0x7c00 ?

<<[[main()]] if rare condition, do nothing, else>>=
if(*INITENTRY >= '0' && *INITENTRY <= '9') {}
else
@

<<[[entryvalue()]] if digit INITENTRY>>=
if(*a >= '0' && *a <= '9')
    return atolwhex(a);
@


\section{Other instructions}

\subsection{Float instructions}

% string connection with the kernel floating port support.
% see bcm/vfp3.c, bcm/fpiarm.c, etc


\subsubsection{Operand kind}

<<[[zaddr()]] cases>>=
case D_FREG:
case D_FPCR:
    break;
@

<<[[zaddr()]] cases>>=
case D_FCONST:
    a->ieee = malloc(sizeof(Ieee));

    a->ieee->l = p[4] | (p[5]<<8) | (p[6]<<16) | (p[7]<<24);
    a->ieee->h = p[8] | (p[9]<<8) | (p[10]<<16) | (p[11]<<24);
    size += 8;
    break;
@
% >> >> >> >> >> >>
% bugfix: there was a bug where it was using NSNAME instead of sizeof(Ieee)
%  but factorizing code with malloc fixed the issue too.


% 8.out.h

% ldobj -> <>
<<function ieeedtof>>=
long
ieeedtof(Ieee *e)
{
    int exp;
    long v;

    if(e->h == 0)
        return 0;
    exp = (e->h>>20) & ((1L<<11)-1L);
    exp -= (1L<<10) - 2L;
    v = (e->h & 0xfffffL) << 3;
    v |= (e->l >> 29) & 0x7L;
    if((e->l >> 28) & 1) {
        v++;
        if(v & 0x800000L) {
            v = (v & 0x7fffffL) >> 1;
            exp++;
        }
    }
    if(exp <= -126 || exp >= 130)
        diag("double fp to single fp overflow");
    v |= ((exp + 126) & 0xffL) << 23;
    v |= e->h & 0x80000000L;
    return v;
}
@

% Dconv -> <>
<<function ieeedtod>>=
double
ieeedtod(Ieee *ieeep)
{
    Ieee e;
    double fr;
    int exp;

    if(ieeep->h & (1L<<31)) {
        e.h = ieeep->h & ~(1L<<31);
        e.l = ieeep->l;
        return -ieeedtod(&e);
    }
    if(ieeep->l == 0 && ieeep->h == 0)
        return 0;
    fr = ieeep->l & ((1L<<16)-1L);
    fr /= 1L<<16;
    fr += (ieeep->l>>16) & ((1L<<16)-1L);
    fr /= 1L<<16;
    fr += (ieeep->h & (1L<<20)-1L) | (1L<<20);
    fr /= 1L<<21;
    exp = (ieeep->h>>20) & ((1L<<11)-1L);
    exp -= (1L<<10) - 2L;
    return ldexp(fr, exp);
}
@




\subsubsection{Class}

<<cxxx(arm) cases>>=
C_FREG,
C_FCON,
C_FCR,
@

<<[[aclass()]] switch type cases>>=
case D_FREG:
    return C_FREG;
case D_FCONST:
    return C_FCON;
case D_FPCR:
    return C_FCR;
@



<<function immfloat(arm)>>=
int
immfloat(long v)
{
    return (v & 0xC03) == 0;/* offset will fit in floating-point load/store */
}
@

<<cxxx(arm) cases, in C_xEXT, float cases>>=
C_FEXT,
C_HFEXT,
@
%bug: must be inside C_xEXT, not after C_LEXT!

<<[[aclass()]] if immfloat for N_EXTERN symbol>>=
if(immfloat(t))
    return immhalf(instoffset)? C_HFEXT : C_FEXT;
@

<<cxxx(arm) cases, in C_xAUTO, float cases>>=
C_FAUTO,	/* float insn offset (0 to 0x3fc, word aligned) */
C_HFAUTO,	/* both H and F */
@
%bug: must be inside C_xAUTO, not after C_LAUTO! see long pb vlong.c :)
% with addpool(), WORD d+4(FP), and illegal combination error.

<<[[aclass()]] if immfloat for N_LOCAL or N_PARAM symbol>>=
if(immfloat(t))
    return immhalf(instoffset)? C_HFAUTO : C_FAUTO;
@

<<cxxx(arm) cases, in C_xOREG, float cases>>=
C_FOREG,
C_HFOREG,
@


<<[[aclass()]] if immfloat for D_NONE symbol>>=
if(immfloat(t))
    return immhalf(instoffset)? C_HFOREG : C_FOREG;
    /* n.b. that it will also satisfy immrot */
@


\subsubsection{XXX}








<<enum optab_flag cases>>=
V4		= 1<<3,	/* arm v4 arch */
VFP		= 1<<4,	/* arm vfpv3 floating point */
@
% >> >>
%http://www.arm.com/products/processors/technologies/vector-floating-point.php

% from 8l(1) "Without this [-f] option, 5l generates arm7500 floating-point
% instructions which are emulated in the kernel."

<<[[ocmp()]] if floating point flag on p1 or p2>>=
n = (p2->flag&V4) - (p1->flag&V4);	/* architecture version */
if(n)
    return n;
n = (p2->flag&VFP) - (p1->flag&VFP);	/* floating point arch */
if(n)
    return n;
@

<<global vfp(arm)>>=
bool vfp;
@

% remove? and remove the relevant opcode also in optab? at least aspectize!
<<global armv4(arm)>>=
bool	armv4;
@

<<[[buildop()]] initializer floating flags>>=
armv4 = !debug['h'];
vfp = debug['f'];
@

<<[[buildop()]] adjust optab if floating flags>>=
if((optab[n].flag & VFP) && !vfp)
    optab[n].as = AXXX;
if((optab[n].flag & V4) && !armv4) {
    optab[n].as = AXXX;
    break;
}
@





<<[[ldobj()]] locals(arm)>>=
Prog *t;
@

<<[[ldobj()]] switch opcode cases(arm)>>=
case AMOVDF:
    if(!vfp || p->from.type != D_FCONST)
        goto casedef;
    p->as = AMOVF;
    /* fall through */
case AMOVF:
    if(skip)
        goto casedef;

    if(p->from.type == D_FCONST && chipfloat(p->from.ieee) < 0) {
        /* size sb 9 max */
        sprint(literal, "$%lux", ieeedtof(p->from.ieee));
        s = lookup(literal, 0);
        if(s->type == 0) {
            s->type = SBSS;
            s->value = 4;
            t = prg();
            t->as = ADATA;
            t->line = p->line;
            t->from.type = D_OREG;
            t->from.sym = s;
            t->from.symkind = N_EXTERN;
            t->reg = 4;
            t->to = p->from;
            t->link = datap;
            datap = t;
        }
        p->from.type = D_OREG;
        p->from.sym = s;
        p->from.symkind = N_EXTERN;
        p->from.offset = 0;
    }
    goto casedef;

case AMOVD:
    if(skip)
        goto casedef;

    if(p->from.type == D_FCONST && chipfloat(p->from.ieee) < 0) {
        /* size sb 18 max */
        sprint(literal, "$%lux.%lux",
            p->from.ieee->l, p->from.ieee->h);
        s = lookup(literal, 0);
        if(s->type == 0) {
            s->type = SBSS;
            s->value = 8;
            t = prg();
            t->as = ADATA;
            t->line = p->line;
            t->from.type = D_OREG;
            t->from.sym = s;
            t->from.symkind = N_EXTERN;
            t->reg = 8;
            t->to = p->from;
            t->link = datap;
            datap = t;
        }
        p->from.type = D_OREG;
        p->from.sym = s;
        p->from.symkind = N_EXTERN;
        p->from.offset = 0;
    }
    goto casedef;
@


<<global chipfloats(arm)>>=
static Ieee chipfloats[] = {
    {0x00000000, 0x00000000}, /* 0 */
    {0x00000000, 0x3ff00000}, /* 1 */
    {0x00000000, 0x40000000}, /* 2 */
    {0x00000000, 0x40080000}, /* 3 */
    {0x00000000, 0x40100000}, /* 4 */
    {0x00000000, 0x40140000}, /* 5 */
    {0x00000000, 0x3fe00000}, /* .5 */
    {0x00000000, 0x40240000}, /* 10 */
};
@
% ???

<<function chipfloat(arm)>>=
int
chipfloat(Ieee *e)
{
    Ieee *p;
    int n;

    if(vfp)
        return -1;
    for(n = sizeof(chipfloats)/sizeof(chipfloats[0]); --n >= 0;){
        p = &chipfloats[n];
        if(p->l == e->l && p->h == e->h)
            return n;
    }
    return -1;
}
@






<<[[noops()]] second pass switch opcode cases>>=
/*
 * 5c code generation for unsigned -> double made the
 * unfortunate assumption that single and double floating
 * point registers are aliased - true for emulated 7500
 * but not for vfp.  Now corrected, but this test is
 * insurance against old 5c compiled code in libraries.
 */
case AMOVWD:
    if((q = p->link) != P && q->as == ACMP)
     if((q = q->link) != P && q->as == AMOVF)
      if((q1 = q->link) != P && q1->as == AADDF)
       if(q1->to.type == D_FREG && q1->to.reg == p->to.reg) {
        q1->as = AADDD;
        q1 = prg();
        q1->scond = q->scond;
        q1->line = q->line;
        q1->as = AMOVFD;
        q1->from = q->to;
        q1->to = q1->from;
        q1->link = q->link;
        q->link = q1;
    }
    break;
@



<<[[datblk()]] locals>>=
long fl;
@

<<[[datblk()]] switch type of destination cases>>=
case D_FCONST:
    switch(c) {
    default:
    case 4:
        fl = ieeedtof(p->to.ieee);
        cast = (char*)&fl;
        for(; i<c; i++) {
            buf.dbuf[l] = cast[fnuxi4[i]];
            l++;
        }
        break;
    case 8:
        cast = (char*)p->to.ieee;
        for(; i<c; i++) {
            buf.dbuf[l] = cast[fnuxi8[i]];
            l++;
        }
        break;
    }
    break;
@

\subsubsection{Common float instructions}


<<[[buildop()]] switch opcode r for ranges cases>>=
case AADDF:
    oprange[AADDD] = oprange[r];
    oprange[ASUBF] = oprange[r];
    oprange[ASUBD] = oprange[r];
    oprange[AMULF] = oprange[r];
    oprange[AMULD] = oprange[r];
    oprange[ADIVF] = oprange[r];
    oprange[ADIVD] = oprange[r];
    oprange[AMOVFD] = oprange[r];
    oprange[AMOVDF] = oprange[r];
    break;
    
case ACMPF:
    oprange[ACMPD] = oprange[r];
    break;

case AMOVF:
    oprange[AMOVD] = oprange[r];
    break;

case AMOVFW:
    oprange[AMOVWF] = oprange[r];
    oprange[AMOVWD] = oprange[r];
    oprange[AMOVDW] = oprange[r];
    break;
@

<<[[optab]] entries>>=
{ AMOVF,	C_FREG,	C_NONE,	C_FEXT,		50, 4, REGSB },
{ AMOVF,	C_FREG,	C_NONE,	C_FAUTO,	50, 4, REGSP },
{ AMOVF,	C_FREG,	C_NONE,	C_FOREG,	50, 4, 0 },

{ AMOVF,	C_FEXT,	C_NONE,	C_FREG,		51, 4, REGSB },
{ AMOVF,	C_FAUTO,C_NONE,	C_FREG,		51, 4, REGSP },
{ AMOVF,	C_FOREG,C_NONE,	C_FREG,		51, 4, 0 },

{ AMOVF,	C_FREG,	C_NONE,	C_LEXT,		52, 12, REGSB,	LTO },
{ AMOVF,	C_FREG,	C_NONE,	C_LAUTO,	52, 12, REGSP,	LTO },
{ AMOVF,	C_FREG,	C_NONE,	C_LOREG,	52, 12, 0,	LTO },

{ AMOVF,	C_LEXT,	C_NONE,	C_FREG,		53, 12, REGSB,	LFROM },
{ AMOVF,	C_LAUTO,C_NONE,	C_FREG,		53, 12, REGSP,	LFROM },
{ AMOVF,	C_LOREG,C_NONE,	C_FREG,		53, 12, 0,	LFROM },

{ AMOVF,	C_FREG,	C_NONE,	C_ADDR,		68, 8, 0,	LTO },
{ AMOVF,	C_ADDR,	C_NONE,	C_FREG,		69, 8, 0,	LFROM },

{ AADDF,	C_FREG,	C_NONE,	C_FREG,		54, 4, 0 },
{ AADDF,	C_FREG,	C_REG,	C_FREG,		54, 4, 0 },
{ AADDF,	C_FCON,	C_NONE,	C_FREG,		54, 4, 0 },
{ AADDF,	C_FCON,	C_REG,	C_FREG,		54, 4, 0 },
{ AMOVF,	C_FCON,	C_NONE,	C_FREG,		54, 4, 0 },
{ AMOVF,	C_FREG, C_NONE, C_FREG,		54, 4, 0 },

{ ACMPF,	C_FREG,	C_REG,	C_NONE,		54, 4, 0 },
{ ACMPF,	C_FCON,	C_REG,	C_NONE,		54, 4, 0 },

{ AMOVFW,	C_FREG,	C_NONE,	C_REG,		55, 4, 0 },
{ AMOVFW,	C_REG,	C_NONE,	C_FREG,		55, 4, 0 },
@



<<function regoff(arm)>>=
long
regoff(Adr *a)
{

    instoffset = 0;
    aclass(a);
    return instoffset;
}
@

<<[[asmout()]] switch on type cases>>=
case 50:	/* floating point store */
    v = regoff(&p->to);
    r = p->to.reg;
    if(r == R_NONE)
        r = o->param;
    o1 = ofsr(p->as, p->from.reg, v, r, p->scond, p);
    break;
@

%STC 6 << 25
<<function ofsr(arm)>>=
long
ofsr(int a, int r, long v, int b, int sc, Prog *p)
{
    long o;

    if(vfp)
        return ovfpmem(a, r, v, b, sc, p);

    o = (sc & C_SCOND) << 28;
    if(sc & C_SBIT)
        diag(".S on FLDR/FSTR instruction");
    if(!(sc & C_PBIT))
        o |= 1 << 24;
    if(sc & C_WBIT)
        o |= 1 << 21;
    o |= (6<<25) | (1<<24) | (1<<23);
    if(v < 0) {
        v = -v;
        o ^= 1 << 23;
    }
    if(v & 3)
        diag("odd offset for floating point op: %ld\n%P", v, p);
    else if(v >= (1<<10))
        diag("literal span too large: %ld\n%P", v, p);
    o |= (v>>2) & 0xFF;
    o |= b << 16;
    o |= r << 12;
    o |= 1 << 8;

    switch(a) {
    default:
        diag("bad fst %A", a);
    case AMOVD:
        o |= 1<<15;
    case AMOVF:
        break;
    }
    return o;
}
@
% >> >> >> >> >> >> >> >> >> >> >>



% LDC, 6 << 25 and 1 << 20
<<[[asmout()]] switch on type cases>>=
case 51:	/* floating point load */
    v = regoff(&p->from);
    r = p->from.reg;
    if(r == R_NONE)
        r = o->param;
    o1 = ofsr(p->as, p->to.reg, v, r, p->scond, p) | (1<<20);
    break;
@
% >>


% ADD ... STC
<<[[asmout()]] switch on type cases>>=
case 52:	/* floating point store, long offset UGLY */
    o1 = omvl(p, &p->to, REGTMP);
    if(!o1)
        break;
    r = p->to.reg;
    if(r == R_NONE)
        r = o->param;
    o2 = oprrr(AADD, p->scond) | (REGTMP << 12) | (REGTMP << 16) | r;
    o3 = ofsr(p->as, p->from.reg, 0, REGTMP, p->scond, p);
    break;
@
% >> >> >>

% ADD ... LTC
<<[[asmout()]] switch on type cases>>=
case 53:	/* floating point load, long offset UGLY */
    o1 = omvl(p, &p->from, REGTMP);
    if(!o1)
        break;
    r = p->from.reg;
    if(r == R_NONE)
        r = o->param;
    o2 = oprrr(AADD, p->scond) | (REGTMP << 12) | (REGTMP << 16) | r;
    o3 = ofsr(p->as, p->to.reg, 0, REGTMP, p->scond, p) | (1<<20);
    break;
@
% >> >> >>


<<[[oprrr()]] switch cases>>=
/* old arm 7500 fp using coprocessor 1 (1<<8) */
case AADDD:	return o | (0xe<<24) | (0x0<<20) | (1<<8) | (1<<7);
case AADDF:	return o | (0xe<<24) | (0x0<<20) | (1<<8);
case AMULD:	return o | (0xe<<24) | (0x1<<20) | (1<<8) | (1<<7);
case AMULF:	return o | (0xe<<24) | (0x1<<20) | (1<<8);
case ASUBD:	return o | (0xe<<24) | (0x2<<20) | (1<<8) | (1<<7);
case ASUBF:	return o | (0xe<<24) | (0x2<<20) | (1<<8);
case ADIVD:	return o | (0xe<<24) | (0x4<<20) | (1<<8) | (1<<7);
case ADIVF:	return o | (0xe<<24) | (0x4<<20) | (1<<8);
/* arguably, ACMPF should expand to RNDF, CMPD */
case ACMPD:
case ACMPF:	return o | (0xe<<24) | (0x9<<20) | (0xF<<12) | (1<<8) | (1<<4);	

case AMOVF:
case AMOVDF:	return o | (0xe<<24) | (0x0<<20) | (1<<15) | (1<<8);
case AMOVD:
case AMOVFD:	return o | (0xe<<24) | (0x0<<20) | (1<<15) | (1<<8) | (1<<7);

case AMOVWF:	return o | (0xe<<24) | (0<<20) | (1<<8) | (1<<4);
case AMOVWD:	return o | (0xe<<24) | (0<<20) | (1<<8) | (1<<4) | (1<<7);
case AMOVFW:	return o | (0xe<<24) | (1<<20) | (1<<8) | (1<<4);
case AMOVDW:	return o | (0xe<<24) | (1<<20) | (1<<8) | (1<<4) | (1<<7);
@
% >> >> >> >> >> >> >> >> >> >> >> >> >>
% >> >> >> >> >> >> >> >> >> >> >> >> >>
% >> >> >> >> >> >> >> >> >> >> >> >> >>
% >> >> >> >> >> >> >> >> >> >> >> >> >>
% >> >> >> >> >> >> >> >> >> >> >> >> >>
% >> >> >> >> >> >> >> >> >> >> >> >> >>
% 0xe << 24 => CDP instr, 1 << 8 => co processor 1




<<[[asmout()]] switch on type cases>>=
case 54:	/* floating point arith */
    o1 = oprrr(p->as, p->scond);
    if(p->from.type == D_FCONST) {
        rf = chipfloat(p->from.ieee);
        if(rf < 0){
            diag("invalid floating-point immediate\n%P", p);
            rf = 0;
        }
        rf |= (1<<3);
    } else
        rf = p->from.reg;
    rt = p->to.reg;
    r = p->reg;
    if(p->to.type == D_NONE)
        rt = 0;	/* CMP[FD] */
    else if(o1 & (1<<15))
        r = 0;	/* monadic */
    else if(r == R_NONE)
        r = rt;
    o1 |= rf | (r<<16) | (rt<<12);
    break;
@
% >> >> >> >> >>

<<[[asmout()]] switch on type cases>>=
case 55:	/* floating point fix and float */
    o1 = oprrr(p->as, p->scond);
    rf = p->from.reg;
    rt = p->to.reg;
    if(p->to.type == D_NONE){
        rt = 0;
        diag("to.type==D_NONE (asm/fp)");
    }
    if(p->from.type == D_REG)
        o1 |= (rf<<12) | (rt<<16);
    else
        o1 |= rf | (rt<<12);
    break;
@
% >> >> >> >>



<<[[asmout()]] switch on type cases>>=
case 68:	/* floating point store -> ADDR */
    o1 = omvl(p, &p->to, REGTMP);
    if(!o1)
        break;
    o2 = ofsr(p->as, p->from.reg, 0, REGTMP, p->scond, p);
    break;
@
<<[[asmout()]] switch on type cases>>=
case 69:	/* floating point load <- ADDR */
    o1 = omvl(p, &p->from, REGTMP);
    if(!o1)
        break;
    o2 = ofsr(p->as, p->to.reg, 0, REGTMP, p->scond, p) | (1<<20);
    break;
@
% >> >> >>

\subsubsection{VFP hardware instructions, [[5l -f]]}



<<function ovfpmem(arm)>>=
long
ovfpmem(int a, int r, long v, int b, int sc, Prog *p)
{
    long o;

    o = (sc & C_SCOND) << 28;
    if(sc & (C_SBIT|C_PBIT|C_WBIT))
        diag(".S/.P/.W on VLDR/VSTR instruction");
    o |= 0xd<<24 | (1<<23);
    if(v < 0) {
        v = -v;
        o ^= 1 << 23;
    }
    if(v & 3)
        diag("odd offset for floating point op: %ld\n%P", v, p);
    else if(v >= (1<<10))
        diag("literal span too large: %ld\n%P", v, p);
    o |= (v>>2) & 0xFF;
    o |= b << 16;
    o |= r << 12;
    switch(a) {
    default:
        diag("bad fst %A", a);
    case AMOVD:
        o |= 0xb<<8;
        break;
    case AMOVF:
        o |= 0xa<<8;
        break;
    }
    return o;
}
@
% >> >> >> >> >> >> >> >> 




<<[[optab]] entries>>=
{ AADDF,	C_FREG,	C_NONE,	C_FREG,		74, 4, 0, VFP },
{ AADDF,	C_FREG,	C_REG,	C_FREG,		74, 4, 0, VFP },
{ AMOVF,	C_FREG, C_NONE, C_FREG,		74, 4, 0, VFP },
{ ACMPF,	C_FREG,	C_REG,	C_NONE,		75, 8, 0, VFP },
{ ACMPF,	C_FCON,	C_REG,	C_NONE,		75, 8, 0, VFP },
{ AMOVFW,	C_FREG,	C_NONE,	C_REG,		76, 8, 0, VFP },
{ AMOVFW,	C_REG,	C_NONE,	C_FREG,		76, 8, 0, VFP },
@
% remember those are ranges!

<<[[asmout()]] switch on type cases>>=
/* VFP ops: */
case 74:	/* vfp floating point arith */
    o1 = opvfprrr(p->as, p->scond);
    rf = p->from.reg;
    if(p->from.type == D_FCONST) {
        diag("invalid floating-point immediate\n%P", p);
        rf = 0;
    }
    rt = p->to.reg;
    r = p->reg;
    if(r == R_NONE)
        r = rt;
    o1 |= rt<<12;
    if(((o1>>20)&0xf) == 0xb)
        o1 |= rf<<0;
    else
        o1 |= r<<16 | rf<<0;
    break;
@
% >> >> >>

<<[[asmout()]] switch on type cases>>=
case 75:	/* vfp floating point compare */
    o1 = opvfprrr(p->as, p->scond);
    rf = p->from.reg;
    if(p->from.type == D_FCONST) {
        if(p->from.ieee->h != 0 || p->from.ieee->l != 0)
            diag("invalid floating-point immediate\n%P", p);
        o1 |= 1<<16;
        rf = 0;
    }
    rt = p->reg;
    o1 |= rt<<12 | rf<<0;
    o2 = 0x0ef1fa10;	/* MRS APSR_nzcv, FPSCR */
    o2 |= (p->scond & C_SCOND) << 28;
    break;
@
% >> >> >> >>

<<[[asmout()]] switch on type cases>>=
case 76:	/* vfp floating point fix and float */
    o1 = opvfprrr(p->as, p->scond);
    rf = p->from.reg;
    rt = p->to.reg;
    if(p->from.type == D_REG) {
        o2 = o1 | rt<<12 | rt<<0;
        o1 = 0x0e000a10;	/* VMOV F,R */
        o1 |= (p->scond & C_SCOND) << 28 | rt<<16 | rf<<12;
    } else {
        o1 |= FREGTMP<<12 | rf<<0;
        o2 = 0x0e100a10;	/* VMOV R,F */
        o2 |= (p->scond & C_SCOND) << 28 | FREGTMP<<16 | rt<<12;
    }
    break;
@
%$
% >> >> >> >> >> >> >> >> >> >>



<<function opvfprrr(arm)>>=
long
opvfprrr(int a, int sc)
{
    long o;

    o = (sc & C_SCOND) << 28;
    if(sc & (C_SBIT|C_PBIT|C_WBIT))
        diag(".S/.P/.W on vfp instruction");
    o |= 0xe<<24;
    switch(a) {
    case AMOVWD:	return o | 0xb<<8 | 0xb<<20 | 1<<6 | 0x8<<16 | 1<<7;
    case AMOVWF:	return o | 0xa<<8 | 0xb<<20 | 1<<6 | 0x8<<16 | 1<<7;
    case AMOVDW:	return o | 0xb<<8 | 0xb<<20 | 1<<6 | 0xD<<16 | 1<<7;
    case AMOVFW:	return o | 0xa<<8 | 0xb<<20 | 1<<6 | 0xD<<16 | 1<<7;
    case AMOVFD:	return o | 0xa<<8 | 0xb<<20 | 1<<6 | 0x7<<16 | 1<<7;
    case AMOVDF:	return o | 0xb<<8 | 0xb<<20 | 1<<6 | 0x7<<16 | 1<<7;
    case AMOVF:	return o | 0xa<<8 | 0xb<<20 | 1<<6 | 0x0<<16 | 0<<7;
    case AMOVD:	return o | 0xb<<8 | 0xb<<20 | 1<<6 | 0x0<<16 | 0<<7;
    case ACMPF:	return o | 0xa<<8 | 0xb<<20 | 1<<6 | 0x4<<16 | 0<<7;
    case ACMPD:	return o | 0xb<<8 | 0xb<<20 | 1<<6 | 0x4<<16 | 0<<7;
    case AADDF:	return o | 0xa<<8 | 0x3<<20;
    case AADDD:	return o | 0xb<<8 | 0x3<<20;
    case ASUBF:	return o | 0xa<<8 | 0x3<<20 | 1<<6;
    case ASUBD:	return o | 0xb<<8 | 0x3<<20 | 1<<6;
    case AMULF:	return o | 0xa<<8 | 0x2<<20;
    case AMULD:	return o | 0xb<<8 | 0x2<<20;
    case ADIVF:	return o | 0xa<<8 | 0x8<<20;
    case ADIVD:	return o | 0xb<<8 | 0x8<<20;
    }
    diag("bad vfp rrr %d", a);
    prasm(curp);
    return 0;
}
@
% >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >>
% >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >>
% >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >>
% >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >>



\subsubsection{Kernel emulation}



<<[[optab]] entries>>=
{ AMOVW,	C_REG,	C_NONE,	C_FCR,		56, 4, 0 },
{ AMOVW,	C_FCR,	C_NONE,	C_REG,		57, 4, 0 },
@

<<[[asmout()]] switch on type cases>>=
/* old arm 7500 fp using coprocessor 1 (1<<8) */
case 56:	/* move to FP[CS]R */
    o1 = ((p->scond & C_SCOND) << 28) | (0xe << 24) | (1<<8) | (1<<4);
    o1 |= ((p->to.reg+1)<<21) | (p->from.reg << 12);
    break;
@
% >> >> >> >> >> >> >>
<<[[asmout()]] switch on type cases>>=
case 57:	/* move from FP[CS]R */
    o1 = ((p->scond & C_SCOND) << 28) | (0xe << 24) | (1<<8) | (1<<4);
    o1 |= ((p->from.reg+1)<<21) | (p->to.reg<<12) | (1<<20);
    break;
@
% >> >> >> >> >> >> >> >



%from bcm/arm.h
%#define CpOFPA		1			/* ancient 7500 FPA */
% => use coprocessor 1

% "without -f 5l generates arm7500 floating-point
% instructions which are emulated in the kernel."

% see bcm/fpiarm.c

<<[[optab]] entries>>=
{ AMOVH,	C_REG,	C_NONE,	C_HEXT,		70, 4, REGSB,	V4 },
{ AMOVH,	C_REG,	C_NONE, C_HAUTO,	70, 4, REGSP,	V4 },
{ AMOVH,	C_REG,	C_NONE,	C_HOREG,	70, 4, 0,		V4 },
{ AMOVHU,	C_REG,	C_NONE,	C_HEXT,		70, 4, REGSB,	V4 },
{ AMOVHU,	C_REG,	C_NONE, C_HAUTO,	70, 4, REGSP,	V4 },
{ AMOVHU,	C_REG,	C_NONE,	C_HOREG,	70, 4, 0,		V4 },

{ AMOVB,	C_HEXT,	C_NONE, C_REG,		71, 4, REGSB,	V4 },
{ AMOVB,	C_HAUTO,C_NONE,	C_REG,		71, 4, REGSP,	V4 },
{ AMOVB,	C_HOREG,C_NONE,	C_REG,		71, 4, 0,		V4 },
{ AMOVH,	C_HEXT,	C_NONE,	C_REG,		71, 4, REGSB,	V4 },
{ AMOVH,	C_HAUTO,C_NONE, C_REG,		71, 4, REGSP,	V4 },
{ AMOVH,	C_HOREG,C_NONE,	C_REG,		71, 4, 0,		V4 },
{ AMOVHU,	C_HEXT,	C_NONE,	C_REG,		71, 4, REGSB,	V4 },
{ AMOVHU,	C_HAUTO,C_NONE, C_REG,		71, 4, REGSP,	V4 },
{ AMOVHU,	C_HOREG,C_NONE,	C_REG,		71, 4, 0,		V4 },

{ AMOVH,	C_REG,	C_NONE,	C_LEXT,		72, 8, REGSB,	LTO|V4 },
{ AMOVH,	C_REG,	C_NONE, C_LAUTO,	72, 8, REGSP,	LTO|V4 },
{ AMOVH,	C_REG,	C_NONE,	C_LOREG,	72, 8, 0,		LTO|V4 },
{ AMOVHU,	C_REG,	C_NONE,	C_LEXT,		72, 8, REGSB,	LTO|V4 },
{ AMOVHU,	C_REG,	C_NONE, C_LAUTO,	72, 8, REGSP,	LTO|V4 },
{ AMOVHU,	C_REG,	C_NONE,	C_LOREG,	72, 8, 0,		LTO|V4 },

{ AMOVB,	C_LEXT,	C_NONE, C_REG,		73, 8, REGSB,	LFROM|V4 },
{ AMOVB,	C_LAUTO,C_NONE,	C_REG,		73, 8, REGSP,	LFROM|V4 },
{ AMOVB,	C_LOREG,C_NONE,	C_REG,		73, 8, 0,		LFROM|V4 },
{ AMOVH,	C_LEXT,	C_NONE,	C_REG,		73, 8, REGSB,	LFROM|V4 },
{ AMOVH,	C_LAUTO,C_NONE, C_REG,		73, 8, REGSP,	LFROM|V4 },
{ AMOVH,	C_LOREG,C_NONE,	C_REG,		73, 8, 0,		LFROM|V4 },
{ AMOVHU,	C_LEXT,	C_NONE,	C_REG,		73, 8, REGSB,	LFROM|V4 },
{ AMOVHU,	C_LAUTO,C_NONE, C_REG,		73, 8, REGSP,	LFROM|V4 },
{ AMOVHU,	C_LOREG,C_NONE,	C_REG,		73, 8, 0,		LFROM|V4 },
@

<<[[asmout()]] switch on type cases>>=
/* ArmV4 ops: */
case 70:	/* movh/movhu R,O(R) -> strh */
    aclass(&p->to);
    r = p->to.reg;
    if(r == R_NONE)
        r = o->param;
    o1 = oshr(p->from.reg, instoffset, r, p->scond);
    break;	
@
<<[[asmout()]] switch on type cases>>=
case 71:	/* movb/movh/movhu O(R),R -> ldrsb/ldrsh/ldrh */
    aclass(&p->from);
    r = p->from.reg;
    if(r == R_NONE)
        r = o->param;
    o1 = olhr(instoffset, r, p->to.reg, p->scond);
    if(p->as == AMOVB)
        o1 ^= (1<<5)|(1<<6);
    else if(p->as == AMOVH)
        o1 ^= (1<<6);
    break;
@
% >> >>  >>

<<[[asmout()]] switch on type cases>>=
case 72:	/* movh/movhu R,L(R) -> strh */
    o1 = omvl(p, &p->to, REGTMP);
    if(!o1)
        break;
    r = p->to.reg;
    if(r == R_NONE)
        r = o->param;
    o2 = oshrr(p->from.reg, REGTMP,r, p->scond);
    break;	
@

<<[[asmout()]] switch on type cases>>=
case 73:	/* movb/movh/movhu L(R),R -> ldrsb/ldrsh/ldrh */
    o1 = omvl(p, &p->from, REGTMP);
    if(!o1)
        break;
    r = p->from.reg;
    if(r == R_NONE)
        r = o->param;
    o2 = olhrr(REGTMP, r, p->to.reg, p->scond);
    if(p->as == AMOVB)
        o2 ^= (1<<5)|(1<<6);
    else if(p->as == AMOVH)
        o2 ^= (1<<6);
    break;
@
% >> >> >>


<<function olhr(arm)>>=
long
olhr(long v, int b, int r, int sc)
{
    long o;

    o = (sc & C_SCOND) << 28;
    if(sc & C_SBIT)
        diag(".S on LDRH/STRH instruction");

    if(!(sc & C_PBIT))
        o |= 1 << 24;
    if(sc & C_WBIT)
        o |= 1 << 21;
    o |= (1<<23) | (1<<20)|(0xb<<4);
    if(v < 0) {
        v = -v;
        o ^= 1 << 23;
    }
    if(v >= (1<<8))
        diag("literal span too large: %ld (R%d)\n%P", v, b, PP);
    o |= (v&0xf)|((v>>4)<<8)|(1<<22);
    o |= b << 16;
    o |= r << 12;
    return o;
}
@
% >> >> >> >> >> >> >> >> >> >> >> >>

<<function osr(arm)>>=
long
osr(int a, int r, long v, int b, int sc)
{
    long o;

    o = olr(v, b, r, sc) ^ (1<<20);
    if(a != AMOVW)
        o |= 1<<22;
    return o;
}
@
% >> >> >> >>

<<function oshr(arm)>>=
long
oshr(int r, long v, int b, int sc)
{
    long o;

    o = olhr(v, b, r, sc) ^ (1<<20);
    return o;
}
@
% >>


<<function osrr(arm)>>=
long
osrr(int r, int i, int b, int sc)
{

    return olr(i, b, r, sc) ^ ((1<<25) | (1<<20));
}
@
% >> >>

<<function oshrr(arm)>>=
long
oshrr(int r, int i, int b, int sc)
{
    return olhr(i, b, r, sc) ^ ((1<<22) | (1<<20));
}
@
% >> >>

<<function olrr(arm)>>=
long
olrr(int i, int b, int r, int sc)
{

    return olr(i, b, r, sc) ^ (1<<25);
}
@
% >>

<<function olhrr(arm)>>=
long
olhrr(int i, int b, int r, int sc)
{
    return olhr(i, b, r, sc) ^ (1<<22);
}
@
% >>



\subsection{Division instructions}

% like for floats, different options

\subsubsection{[[ADIV]] rewriting}

%    /* MOV a,4(SP) */
%    /* MOV b,REGTMP */
%    /* CALL appropriate */
%    /* MOV REGTMP, b */
%    /* ADD $8,SP */
%q1
%    /* SUB $8,SP */

<<[[noops()]] second pass switch opcode cases>>=
case ADIV:
case ADIVU:
case AMOD:
case AMODU:
    <<[[noops()]] second pass, ADIV rewrite, case ADIV and so on, if -M>>
    if(p->from.type != D_REG)
        break;
    if(p->to.type != D_REG)
        break;
    q1 = p;

    q = prg();
    q->link = p->link;
    p->link = q;
    p = q;

    /* MOV a,4(SP) */
    p->as = AMOVW;
    p->line = q1->line;
    p->from.type = D_REG;
    p->from.reg = q1->from.reg;
    p->to.type = D_OREG;
    p->to.reg = REGSP;
    p->to.offset = 4;

    q = prg();
    q->link = p->link;
    p->link = q;
    p = q;

    /* MOV b,REGTMP */
    p->as = AMOVW;
    p->line = q1->line;
    p->from.type = D_REG;
    p->from.reg = q1->reg;
    if(q1->reg == R_NONE)
        p->from.reg = q1->to.reg;
    p->to.type = D_REG;
    p->to.reg = REGTMP;
    p->to.offset = 0;

    q = prg();
    q->link = p->link;
    p->link = q;
    p = q;

    /* CALL appropriate */
    p->as = ABL;
    p->line = q1->line;
    p->to.type = D_BRANCH;
    p->cond = p;
    switch(o) {
    case ADIV:
        p->cond = prog_div;
        p->to.sym = sym_div;
        break;
    case ADIVU:
        p->cond = prog_divu;
        p->to.sym = sym_divu;
        break;
    case AMOD:
        p->cond = prog_mod;
        p->to.sym = sym_mod;
        break;
    case AMODU:
        p->cond = prog_modu;
        p->to.sym = sym_modu;
        break;
    }

    q = prg();
    q->link = p->link;
    p->link = q;
    p = q;

    /* MOV REGTMP, b */
    p->as = AMOVW;
    p->line = q1->line;
    p->from.type = D_REG;
    p->from.reg = REGTMP;
    p->from.offset = 0;
    p->to.type = D_REG;
    p->to.reg = q1->to.reg;

    q = prg();
    q->link = p->link;
    p->link = q;
    p = q;

    /* ADD $8,SP */
    p->as = AADD;
    p->from.type = D_CONST;
    p->from.reg = R_NONE;
    p->from.offset = 8;
    p->reg = R_NONE;
    p->to.type = D_REG;
    p->to.reg = REGSP;

    /* SUB $8,SP */
    q1->as = ASUB;
    q1->from.type = D_CONST;
    q1->from.offset = 8;
    q1->from.reg = R_NONE;
    q1->reg = R_NONE;
    q1->to.type = D_REG;
    q1->to.reg = REGSP;
    break;
@

% for -M, in 8l(1):
% "Generate instructions rather than calls to emulation routines
% for multiply and divide."

<<global prog_div(arm)>>=
Prog*	prog_div;
@

<<global prog_divu(arm)>>=
Prog*	prog_divu;
@

<<global prog_mod(arm)>>=
Prog*	prog_mod;
@

<<global prog_modu(arm)>>=
Prog*	prog_modu;
@


\subsubsection{[[initdiv()]]}

<<global sym_div(arm)>>=
static	Sym*	sym_div;
@

<<global sym_divu(arm)>>=
static	Sym*	sym_divu;
@

<<global sym_mod(arm)>>=
static	Sym*	sym_mod;
@

<<global sym_modu(arm)>>=
static	Sym*	sym_modu;
@


<<constant SIGNINTERN(arm)>>=
#define SIGNINTERN	(1729*325*1729)
@

<<function sigdiv(arm)>>=
static void
sigdiv(char *n)
{
    Sym *s;

    s = lookup(n, 0);
    if(s->type == STEXT){
        if(s->sig == 0)
            s->sig = SIGNINTERN;
    }
    else if(s->type == SNONE || s->type == SXREF)
        s->type = SUNDEF;
}
@

<<function divsig(arm)>>=
void
divsig(void)
{
    sigdiv("_div");
    sigdiv("_divu");
    sigdiv("_mod");
    sigdiv("_modu");
}
@

<<function sdiv(arm)>>=
static void
sdiv(Sym *s)
{
    if(s->type == SNONE || s->type == SXREF){
        /* undefsym(s); */
        s->type = SXREF;
        if(s->sig == 0)
            s->sig = SIGNINTERN;
        s->subtype = SIMPORT;
    }
    else if(s->type != STEXT)
        diag("undefined: %s", s->name);
}
@

<<function initdiv(arm)>>=
void
initdiv(void)
{
    Sym *s2, *s3, *s4, *s5;
    Prog *p;

    if(prog_div != P)
        return;
    sym_div = s2 = lookup("_div", 0);
    sym_divu = s3 = lookup("_divu", 0);
    sym_mod = s4 = lookup("_mod", 0);
    sym_modu = s5 = lookup("_modu", 0);
    if(dlm) {
        sdiv(s2); if(s2->type == SXREF) prog_div = UP;
        sdiv(s3); if(s3->type == SXREF) prog_divu = UP;
        sdiv(s4); if(s4->type == SXREF) prog_mod = UP;
        sdiv(s5); if(s5->type == SXREF) prog_modu = UP;
    }
    for(p = firstp; p != P; p = p->link)
        if(p->as == ATEXT) {
            if(p->from.sym == s2)
                prog_div = p;
            if(p->from.sym == s3)
                prog_divu = p;
            if(p->from.sym == s4)
                prog_mod = p;
            if(p->from.sym == s5)
                prog_modu = p;
        }
    if(prog_div == P) {
        diag("undefined: %s", s2->name);
        prog_div = curtext;
    }
    if(prog_divu == P) {
        diag("undefined: %s", s3->name);
        prog_divu = curtext;
    }
    if(prog_mod == P) {
        diag("undefined: %s", s4->name);
        prog_mod = curtext;
    }
    if(prog_modu == P) {
        diag("undefined: %s", s5->name);
        prog_modu = curtext;
    }
}
@




<<[[noops()]] first pass switch opcode cases>>=
case ADIV:
case ADIVU:
case AMOD:
case AMODU:
    if(prog_div == P)
        initdiv();
    if(curtext != P)
        curtext->mark &= ~LEAF;
    continue;
@
% a bit ugly to do the initdiv here? at the same it's related to
% this notion of NOOP.


\subsubsection{Kernel emulation, [[5l -M]]}
% can access coprocessor from regular programs? so need syscall for float op?
% argh.

<<[[noops()]] second pass, ADIV rewrite, case ADIV and so on, if -M>>=
if(debug['M'])
    break;
@
% if -M then break in noops and so does not rewrite the ADIV
% and so the code below becomes reachable

<<[[buildop()]] switch opcode r for ranges cases>>=
case ADIV:
    oprange[AMOD] = oprange[r];
    oprange[AMODU] = oprange[r];
    oprange[ADIVU] = oprange[r];
    break;
@

<<[[optab]] entries>>=
{ ADIV,		C_REG,	C_REG,	C_REG,		16, 4, 0 },
{ ADIV,		C_REG,	C_NONE,	C_REG,		16, 4, 0 },
@
% hmm but noops should have rewrite them no? not if used
% also 5l -M

<<[[asmout()]] switch on type cases>>=
case 16:	/* div r,[r,]r */
    o1 = 0xf << 28;
    o2 = 0;
    break;
@
% 0xf? SWI? o2 = 0 ?? illegal instruction? so kernel trap?
% >>


\subsection{Multiple registers instructions}

% used by RFE

<<[[buildop()]] switch opcode r for ranges cases>>=
case AMOVM:
    break;
@

<<[[optab]] entries>>=
{ AMOVM,	C_LCON,	C_NONE,	C_SOREG,	38, 4, 0 },
{ AMOVM,	C_SOREG,C_NONE,	C_LCON,		39, 4, 0 },
@

<<[[asmout()]] switch on type cases>>=
case 38:	/* movm $con,oreg -> stm */
    o1 = (0x4 << 25);
    o1 |= p->from.offset & 0xffff;
    o1 |= p->to.reg << 16;
    aclass(&p->to);
    goto movm;
@
%$

<<[[asmout()]] switch on type cases>>=
case 39:	/* movm oreg,$con -> ldm */
    o1 = (0x4 << 25) | (1 << 20);
    o1 |= p->to.offset & 0xffff;
    o1 |= p->from.reg << 16;
    aclass(&p->from);
movm:
    if(instoffset != 0)
        diag("offset must be zero in MOVM");
    o1 |= (p->scond & C_SCOND) << 28;
    if(p->scond & C_PBIT)
        o1 |= 1 << 24;
    if(p->scond & C_UBIT)
        o1 |= 1 << 23;
    if(p->scond & C_SBIT)
        o1 |= 1 << 22;
    if(p->scond & C_WBIT)
        o1 |= 1 << 21;
    break;
@
%$


\section{Compiler-only pseudo opcodes}

<<[[buildop()]] switch opcode r for ranges cases>>=
case ACASE:
case ABCASE:
    break;
@

<<[[optab]] entries>>=
{ ACASE,	C_REG,	C_NONE,	C_NONE,		62, 4, 0 },
{ ABCASE,	C_NONE, C_NONE, C_BRANCH,   63, 4, 0 },
@


<<[[asmout()]] switch on type cases>>=
case 62:	/* case R -> movw	R<<2(PC),PC */
    o1 = olrr(p->from.reg, REGPC, REGPC, p->scond);
    o1 |= 2<<7;
    break;
@
% >>  >>

<<[[asmout()]] switch on type cases>>=
case 63:	/* bcase */
    if(p->cond != P) {
        o1 = p->cond->pc;
        if(dlm)
            dynreloc(S, p->pc, 1);
    }
    break;
@


\section{Position independent code (PIC)}

%PIC, -fpic

% how ugly it is for x86:
% http://ewontfix.com/18/



\chapter{Conclusion}

%dup: (and adapted) from Assembler.nw
You now know how the \plan ARM linker [[5l]] works,
to the smallest details, and more generally how many 
linkers works.

\l next step? kernel/loader. 
\l debugger which uses libmach. profiler.









\appendix

\chapter{Debugging}
\label{chap:debugging-appendix}

%\section{[[debug]]}

% hmm actually it's used not just for debugging but also for generic
% options, e.g. for -l, -p, etc in addition to the main use which is -v
<<global debug>>=
bool	debug[128];
@
% why not 256 like in Assembler.nw?

<<[[main()]] command line processing(arm)>>=
default:
    c = ARGC();
    if(c >= 0 && c < sizeof(debug))
        debug[c]++;
    break;
@



% -A, see diag()

%bso? 
<<global bso>>=
Biobuf	bso;
@


<<[[main()]] debug initialization(arm)>>=
Binit(&bso, 1, OWRITE);
listinit(); // fmtinstall()
@
%x86: memset(debug, false, sizeof(debug));


\section{Fmt}
\label{sec:dumpers}

% dupe with Compiler.nw

% why called listinit??


<<function listinit(arm)>>=
void
listinit(void)
{

    fmtinstall('A', Aconv);
    fmtinstall('C', Cconv);
    fmtinstall('D', Dconv);
    fmtinstall('P', Pconv);
    fmtinstall('S', Sconv);
    fmtinstall('N', Nconv);
}
@

\subsection{Instruction dumper, [[Pconv()]]}

% Pconv, Prog print

<<function prasm(arm)>>=
void
prasm(Prog *p)
{
    print("%P\n", p);
}
@


<<constant STRINGSZ>>=
STRINGSZ	= 200,
@


<<function Pconv(arm)>>=
// Prog -> string
int
Pconv(Fmt *fp)
{
    char str[STRINGSZ], *s;
    Prog *p;
    int a;

    p = va_arg(fp->args, Prog*);
    curp = p;
    a = p->as;

    switch(a) {
    case ASWPW:
    case ASWPBU:
        sprint(str, "(%ld)	%A%C	R%d,%D,%D",
            p->line, a, p->scond, p->reg, &p->from, &p->to);
        break;

    case ADATA:

    case AINIT:
    case ADYNT:
        sprint(str, "(%ld)	%A%C	%D/%d,%D",
            p->line, a, p->scond, &p->from, p->reg, &p->to);
        break;

    default:
        s = str;
        s += sprint(s, "(%ld)", p->line);
        if(p->reg == R_NONE)
            sprint(s, "	%A%C	%D,%D",
                a, p->scond, &p->from, &p->to);
        else
        if(p->from.type != D_FREG)
            sprint(s, "	%A%C	%D,R%d,%D",
                a, p->scond, &p->from, p->reg, &p->to);
        else
            sprint(s, "	%A%C	%D,F%d,%D",
                a, p->scond, &p->from, p->reg, &p->to);
        break;

    }
    return fmtstrcpy(fp, str);
}
@


\subsection{Opcode dumper, [[Aconv()]]}

% Aconv because Axxx


% defined in ../5c/enam.c, coupling with enum as in 5.out.h
% extern	char*	anames[];

<<function Aconv(arm)>>=
// enum<opcode> -> string
int
Aconv(Fmt *fp)
{
    char *s;
    int a;

    a = va_arg(fp->args, int);
    s = "???";
    if(a >= AXXX && a < ALAST)
        s = anames[a];
    return fmtstrcpy(fp, s);
}
@


\subsection{Operand dumper, [[Dconv()]]}

% Dconv Dxxx

<<function Dconv(arm)>>=
// Adr -> string
int
Dconv(Fmt *fp)
{
    char str[STRINGSZ];
    char *op;
    Adr *a;
    long v;

    a = va_arg(fp->args, Adr*);
    switch(a->type) {

    case D_NONE:
        str[0] = '\0';
        if(a->symkind != D_NONE || a->reg != R_NONE || a->sym != S)
            sprint(str, "%N(R%d)(NONE)", a, a->reg);
        break;

    case D_CONST:
        if(a->reg == R_NONE)
            sprint(str, "$%N", a);
        else
            sprint(str, "$%N(R%d)", a, a->reg);
        break;

    case D_SHIFT:
        v = a->offset;
        op = "<<>>->@>" + (((v>>5) & 3) << 1);
        if(v & (1<<4))
            sprint(str, "R%ld%c%cR%ld", v&15, op[0], op[1], (v>>8)&15);
        else
            sprint(str, "R%ld%c%c%ld", v&15, op[0], op[1], (v>>7)&31);
        if(a->reg != R_NONE)
            sprint(str+strlen(str), "(R%d)", a->reg);
        break;

    case D_OREG:
        if(a->reg != R_NONE)
            sprint(str, "%N(R%d)", a, a->reg);
        else
            sprint(str, "%N", a);
        break;

    case D_REG:
        sprint(str, "R%d", a->reg);
        if(a->symkind != D_NONE || a->sym != S)
            sprint(str, "%N(R%d)(REG)", a, a->reg);
        break;

    case D_REGREG:
        sprint(str, "(R%d,R%d)", a->reg, (int)a->offset);
        if(a->symkind != D_NONE || a->sym != S)
            sprint(str, "%N(R%d)(REG)", a, a->reg);
        break;

    case D_FREG:
        sprint(str, "F%d", a->reg);
        if(a->symkind != D_NONE || a->sym != S)
            sprint(str, "%N(R%d)(REG)", a, a->reg);
        break;

    case D_PSR:
        switch(a->reg) {
        case 0:
            sprint(str, "CPSR");
            break;
        case 1:
            sprint(str, "SPSR");
            break;
        default:
            sprint(str, "PSR%d", a->reg);
            break;
        }
        if(a->symkind != D_NONE || a->sym != S)
            sprint(str, "%N(PSR%d)(REG)", a, a->reg);
        break;

    case D_FPCR:
        switch(a->reg){
        case 0:
            sprint(str, "FPSR");
            break;
        case 1:
            sprint(str, "FPCR");
            break;
        default:
            sprint(str, "FCR%d", a->reg);
            break;
        }
        if(a->symkind != D_NONE || a->sym != S)
            sprint(str, "%N(FCR%d)(REG)", a, a->reg);

        break;

    case D_BRANCH:	/* botch */
        if(curp->cond != P) {
            v = curp->cond->pc;
            if(a->sym != S)
                sprint(str, "{%s}%.5lux(BRANCH)", a->sym->name, v);
            else
                sprint(str, "%.5lux(BRANCH)", v);
        } else
            if(a->sym != S)
                sprint(str, "{%s}%ld(APC)", a->sym->name, a->offset);
            else
                sprint(str, "%ld(APC)", a->offset);
        break;

    case D_FCONST:
        sprint(str, "$%e", ieeedtod(a->ieee));
        break;

    case D_SCONST:
        sprint(str, "$\"%S\"", a->sval);
        break;

    default:
        sprint(str, "GOK-type(%d)", a->type);
        break;

    }
    return fmtstrcpy(fp, str);
}
@
%pad: I put braces around symbol name to better indicate they are comments now

%old:
%    case D_OCONST:
%        sprint(str, "$*$%N", a);
%        if(a->reg != R_NONE)
%            sprint(str, "%N(R%d)(CONST)", a, a->reg);
%        break;


%TODO
%\subsection{Operand class dumper, [[??conv()]]}



\subsection{Symbol kind dumper, [[Nconv()]]}

% Nxxx so Nconv
%old: was actually some D_xxx but I renamed them N_xxx


<<function Nconv(arm)>>=
int
Nconv(Fmt *fp)
{
    char str[STRINGSZ];
    Adr *a;
    Sym *s;

    a = va_arg(fp->args, Adr*);
    s = a->sym;

    switch(a->symkind) {
    case N_NONE:
        sprint(str, "%ld", a->offset);
        break;

    case N_EXTERN:
        if(s == S)
            sprint(str, "%ld(SB)", a->offset);
        else
            sprint(str, "{%s}%.5lux+%ld(SB)", s->name, s->value, a->offset);
        break;

    case N_INTERN:
        if(s == S)
            sprint(str, "<>+%ld(SB)", a->offset);
        else
            sprint(str, "{%s<>}%.5lux+%ld(SB)", s->name, s->value, a->offset);
        break;

    case N_LOCAL:
        if(s == S)
            sprint(str, "%ld(SP)", a->offset);
        else
            sprint(str, "{%s}-%ld(SP)", s->name, -a->offset);
        break;

    case N_PARAM:
        if(s == S)
            sprint(str, "%ld(FP)", a->offset);
        else
            sprint(str, "{%s}%ld(FP)", s->name, a->offset);
        break;
    default:
        sprint(str, "GOK-name(%d)", a->symkind);
        break;

    }
    return fmtstrcpy(fp, str);
}
@
%pad: I added the s->value for dumping resolved value of $hello in tutorial
% and put braces around symbol to better show that they are really comment
% now because they are resolved.
% before: $hello+0(SB),R1
% after:  ${hello}00014+0(SB), R1

\subsection{Conditional execution dumper, [[Cconv()]]}


<<global strcond(arm)>>=
char*	strcond[16] =
{
    ".EQ",
    ".NE",
    ".HS",
    ".LO",
    ".MI",
    ".PL",
    ".VS",
    ".VC",
    ".HI",
    ".LS",
    ".GE",
    ".LT",
    ".GT",
    ".LE",
    "",
    ".NV"
};
@

<<function Cconv(arm)>>=
int
Cconv(Fmt *fp)
{
    char s[20];
    int c;

    c = va_arg(fp->args, int);
    strcpy(s, strcond[c & C_SCOND]);
    if(c & C_SBIT)
        strcat(s, ".S");
    if(c & C_PBIT)
        strcat(s, ".P");
    if(c & C_WBIT)
        strcat(s, ".W");
    if(c & C_UBIT)		/* ambiguous with FBIT */
        strcat(s, ".U");
    return fmtstrcpy(fp, s);
}
@


\subsection{???, [[Sconv()]]}

<<function Sconv(arm)>>=
// ?? -> string
int
Sconv(Fmt *fp)
{
    int i, c;
    char str[STRINGSZ], *p, *a;

    a = va_arg(fp->args, char*);
    p = str;
    for(i=0; i<sizeof(long); i++) {
        c = a[i] & 0xff;
        if(c >= 'a' && c <= 'z' ||
           c >= 'A' && c <= 'Z' ||
           c >= '0' && c <= '9' ||
           c == ' ' || c == '%') {
            *p++ = c;
            continue;
        }
        *p++ = '\\';
        switch(c) {
        case 0:
            *p++ = 'z';
            continue;
        case '\\':
        case '"':
            *p++ = c;
            continue;
        case '\n':
            *p++ = 'n';
            continue;
        case '\t':
            *p++ = 't';
            continue;
        }
        *p++ = (c>>6) + '0';
        *p++ = ((c>>3) & 7) + '0';
        *p++ = (c & 7) + '0';
    }
    *p = 0;
    return fmtstrcpy(fp, str);
}
@


\section{Verbose mode, [[5l -v]]}
\l and [[DBG()]]

%old: used to have lots of code like:
% if(debug['v']) {
%    Bprint(&bso, "HEADER = -H0x%ld -T0x%lux -D0x%lux -R0x%lux\n",
%        HEADTYPE, INITTEXT, INITDAT, INITRND);
%    Bflush(&bso);
%}
% (The Bflush was outside the if, but makes more sense like this I think)
% but better to have a DBG() macro for this

<<macro DBG>>=
#define DBG if(debug['v']) mylog
@
%pad: I introduced that

<<function log>>=
void mylog(char *fmt, ...) {

    va_list arg;

    va_start(arg, fmt);
    Bvprint(&bso, fmt, arg);
    va_end(arg);
    Bflush(&bso);
}
@
%pad: I introduced that

\section{Objects loading debugging, [[5l -W]]}
\label{sec:debugging-loading}

<<[[ldobj()]] debug>>=
if(debug['W'])
    print("%P\n", p);
@
% see Pconv before

<<[[ldobj()]] when ANAME, debug>>=
if(debug['W'])
    print("	ANAME	%s\n", s->name);
@

\l -W for? what is the connexion to object loading?

% print object code when loading

% (but need good enam.c! up to date and in sync with 5.out.h)


%ex: of output:


\section{Opcode table debugging, [[5l -t]]}
%pad: I added that

<<[[oplook()]] debug>>=
if(debug['t']) {
    print("oplook %P %A %d %d %d\n",
        p, (int)p->as, a1, a2, a3);
}
@
%old: used to be under a if 0 but pretty useful when debugging issues
%old:    print("		%d %d\n", p->from.type, p->to.type);


\section{Machine code generation debugging, [[5l -a]]}
\label{sec:debugging-generated-code}
\l why -a? assembly? meh

% print final concrete code in assembly language with addresses
% very nice!

%ex of output:
% 00001020: e52de024 (12) MOVW.W R14, -36(R13)
%  with lineno (12) but it's a global_lineno so take care

% if do 5l -a -a two times then get also the o->type and so know
% which case was triggered which is also very useful (remember MOVD
% generation pb with addpool())


<<[[asmout()]] when 1 generated instruction, debug>>=
if(debug['a'])
    Bprint(&bso, " %.8lux: %.8lux\t%P\n", v, o1, p);
@
<<[[asmout()]] when 2 generated instructions, debug>>=
if(debug['a'])
    Bprint(&bso, " %.8lux: %.8lux %.8lux%P\n", v, o1, o2, p);
@
<<[[asmout()]] when 3 generated instructions, debug>>=
if(debug['a'])
    Bprint(&bso, " %.8lux: %.8lux %.8lux %.8lux%P\n", v, o1, o2, o3, p);
@
<<[[asmout()]] when 4 generated instructions, debug>>=
if(debug['a'])
    Bprint(&bso, " %.8lux: %.8lux %.8lux %.8lux %.8lux%P\n",
        v, o1, o2, o3, o4, p);
@
<<[[asmout()]] when 5 generated instructions, debug>>=
if(debug['a'])
    Bprint(&bso, " %.8lux: %.8lux %.8lux %.8lux %.8lux %.8lux%P\n",
        v, o1, o2, o3, o4, o5, p);
@
<<[[asmout()]] when 6 generated instructions, debug>>=
if(debug['a'])
    Bprint(&bso, " %.8lux: %.8lux %.8lux %.8lux %.8lux %.8lux %.8lux%P\n",
        v, o1, o2, o3, o4, o5, o6, p);
@
<<[[asmout()]] when other size, debug>>=
if(debug['a'])
    Bprint(&bso, " %.8lux:\t\t%P\n", v, p);
@


<<[[asmout()]] debug>>=
if(debug['a'] > 1)
    Bprint(&bso, "%2d ", o->type);
@
% when -a -a

<<[[asmb()]] before cflush, debug>>=
if(debug['a']) {
    Bprint(&bso, "\n");
    Bflush(&bso);
}
@



%---------------------------------------------
%\section{[[5l -9 -B -U]]}
% dead I think, -9 for plan9, B for planB? U for Unix?

%<<constant DEFAULT>>=
%#define	DEFAULT	'9'
%@
%
%
%% obsolete?
%<<[[main()]] adjust HEADTYPE if debug flags(arm)>>=
%if(!debug['9'] && !debug['U'] && !debug['B'])
%    debug[DEFAULT] = true;
%
%if(HEADTYPE == -1) {
%    if(debug['U'])
%        HEADTYPE = 0;
%    if(debug['B'])
%        HEADTYPE = 1;
%    if(debug['9'])
%        HEADTYPE = H_PLAN9;
%}
%@

\section{Symbol table debugging, [[5l -n]]}

<<[[putsymb()]] debug>>=
if(debug['n']) {
    <<[[putsymb()]] if z or Z in debug output>>
    if(ver)
        Bprint(&bso, "%c %.8lux %s<%d>\n", t, v, s, ver);
    else
        Bprint(&bso, "%c %.8lux %s\n", t, v, s);
}
@

<<[[putsymb()]] if z or Z in debug output>>=
if(t == 'z' || t == 'Z') {
    Bprint(&bso, "%c %.8lux ", t, v);
    for(i=1; s[i] != 0 || s[i+1] != 0; i+=2) {
        f = ((s[i]&0xff) << 8) | (s[i+1]&0xff);
        Bprint(&bso, "/%x", f);
    }
    Bprint(&bso, "\n");
    return;
}
@
% >> >> >>


\chapter{Error Managment}
\label{chap:error}

<<global nerrors>>=
int	nerrors = 0;
@

<<function errorexit>>=
void
errorexit(void)
{

    if(nerrors) {
        if(cout >= 0)
            remove(outfile);
        exits("error");
    }
    exits(0);
}
@
\l why exits(0) when call errorexit for regular exit? what 5a does?
%assembler: similar


% could use TNAME here too?
<<function diag>>=
void
diag(char *fmt, ...)
{
    char buf[STRINGSZ];
    char *tn;
    va_list arg;

    tn = "??none??";
    if(curtext != P && curtext->from.sym != S)
        tn = curtext->from.sym->name;
    va_start(arg, fmt);
    vseprint(buf, buf+sizeof(buf), fmt, arg);
    va_end(arg);
    print("%s: %s\n", tn, buf);

    nerrors++;
    if(nerrors > 20 && !debug['A']) {
        print("too many errors\n");
        errorexit();
    }
}
@
% ARM does not have the && !debug['A'], but probablt error no?

\section{[[5l -A]]}
% get all errors



\chapter{Profiling}
\label{chap:profiling-appendix}

% 5l -v
% had lots of cputime() too in calls to DBG, so a form of profiling

<<[[main()]] profile report>>=
if(debug['v']) {
    Bprint(&bso, "%5.2f cpu time\n", cputime());
    Bprint(&bso, "%ld symbols\n", nsymbol);
    Bprint(&bso, "%ld memory used\n", thunk);
    Bprint(&bso, "%d sizeof adr\n", sizeof(Adr));
    Bprint(&bso, "%d sizeof prog\n", sizeof(Prog));
    Bflush(&bso);
}
@

<<global nsymbol linker>>=
long	nsymbol;
@
% for statistics
<<[[lookup()]] profiling>>=
nsymbol++;
@

\chapter{Utilities}
\label{chap:libc}

\section{Memory managmnent}
% same in Assembler.nw

<<global hunk>>=
char*	hunk;
@



<<global nhunk>>=
long	nhunk;
@
% = 0??


<<global thunk>>=
long	thunk;
@


<<constant NHUNK linker>>=
NHUNK		= 100000,
@


% not sure why don't use libc malloc and do low-level sbrk ...
% to optimize things? as they do no free?
<<function gethunk>>=
void
gethunk(void)
{
    char *h;
    long nh;

    nh = NHUNK;
    if(thunk >= 5L*NHUNK) {
        nh = 5L*NHUNK;
        if(thunk >= 25L*NHUNK)
            nh = 25L*NHUNK;
    }
    h = sbrk(nh);
    if(h == (char*)-1) {
        diag("out of memory");
        errorexit();
    }
    hunk = h;
    nhunk = nh;
    thunk += nh;
}
@




<<function malloc>>=
/*
 * fake malloc
 */
void*
malloc(ulong n)
{
    void *p;

    // upper_round(n, 8)
    while(n & 7)
        n++;

    while(nhunk < n)
        gethunk();
    p = hunk;
    nhunk -= n;
    hunk += n;
    return p;
}
@




% no free ...  hmmm
<<function free>>=
void
free(void *p)
{
    USED(p);
}
@



% not sure why but if redefine malloc and free then have to
% redefine this func too, otherwise get a link error
<<function setmalloctag>>=
//@Scheck: looks dead, but because we redefine malloc/free we must also redefine that
void setmalloctag(void *v, ulong pc)
{
    USED(v, pc);
}
@


\section{Buffer managmnent}

<<struct Buf>>=
union Buf
{
    struct
    {
        char	obuf[MAXIO];			/* output buffer */
        byte	ibuf[MAXIO];			/* input buffer */
    };
    char	dbuf[1]; // variable size
};
@

<<constant MAXIO>>=
MAXIO		= 8192,
@

<<global buf>>=
union Buf buf;
@


<<function readsome>>=
byte*
readsome(int f, byte *buf, byte *good, byte *stop, int max)
{
    int n;

    n = stop - good;
    memmove(buf, good, stop - good);
    stop = buf + n;
    n = MAXIO - n;
    if(n > max)
        n = max;
    n = read(f, stop, n);
    if(n <= 0)
        return 0;
    return stop + n;
}
@



%<<constant cbuf>>=
%#define	Cbuf	u.obuf
%@
%<<constant xbuf>>=
%#define	Xbuf	u.ibuf
%@
%%simplified! use anonymous union!


<<global cbp>>=
char*	cbp;
@

<<global cbc>>=
int	cbc;
@



<<[[main()]] initialize globals(arm)>>=
cbp = buf.obuf;
cbc = sizeof(buf.obuf);
@



<<function cput(arm)>>=
void
cput(int c)
{
    cbp[0] = c;
    cbp++;
    cbc--;
    if(cbc <= 0)
        cflush();
}
@
% mostly similar to x86, x86 is using a macro though

% in the end print in cout
<<function cflush>>=
void
cflush(void)
{
    int n;

    n = sizeof(buf.obuf) - cbc;
    if(n)
        write(cout, buf.obuf, n);

    cbp = buf.obuf;
    cbc = sizeof(buf.obuf);
}
@




% xxxl means left? little endian?


<<function wputl(arm)>>=
void
wputl(long l)
{

    cbp[0] = l;
    cbp[1] = l>>8;
    cbp += 2;
    cbc -= 2;
    if(cbc <= 0)
        cflush();
}
@
% the x86 version seems more logical, normal?
% what about overflow?? sure cbc >= 2?

<<function wput(arm)>>=
void
wput(long l)
{

    cbp[0] = l>>8;
    cbp[1] = l;
    cbp += 2;
    cbc -= 2;
    if(cbc <= 0)
        cflush();
}
@



<<function lput(arm)>>=
void
lput(long l)
{

    cbp[0] = l>>24;
    cbp[1] = l>>16;
    cbp[2] = l>>8;
    cbp[3] = l;
    cbp += 4;
    cbc -= 4;
    if(cbc <= 0)
        cflush();
}
@



<<function lputl(arm)>>=
void
lputl(long l)
{

    cbp[3] = l>>24;
    cbp[2] = l>>16;
    cbp[1] = l>>8;
    cbp[0] = l;
    cbp += 4;
    cbc -= 4;
    if(cbc <= 0)
        cflush();
}
@


<<function llput>>=
void
llput(vlong v)
{
    lput(v>>32);
    lput(v);
}
@


<<function llputl>>=
void
llputl(vlong v)
{
    lputl(v);
    lputl(v>>32);
}
@




<<function strnput(arm)>>=
void
strnput(char *s, int n)
{
    for(; *s; s++){
        cput(*s);
        n--;
    }
    for(; n > 0; n--)
        cput(0);
}
@
% the x86 version is sligtly different

\section{File managment}

<<function fileexists>>=
int
fileexists(char *s)
{
    byte dirbuf[400];

    /* it's fine if stat result doesn't fit in dirbuf, since even then the file exists */
    return stat(s, dirbuf, sizeof(dirbuf)) >= 0;
}
@


\section{String processing}
\label{sec:atolwhex}

% could be put in libc, with the other atoxxx
% atoxx? why a?  a to long with hexadecimal?
<<function atolwhex>>=
long
atolwhex(char *s)
{
    long n;
    int f;

    n = 0;
    f = 0;
    while(*s == ' ' || *s == '\t')
        s++;
    if(*s == '-' || *s == '+') {
        if(*s++ == '-')
            f = 1;
        while(*s == ' ' || *s == '\t')
            s++;
    }
    if(s[0]=='0' && s[1]){
        if(s[1]=='x' || s[1]=='X'){
            s += 2;
            for(;;){
                if(*s >= '0' && *s <= '9')
                    n = n*16 + *s++ - '0';
                else if(*s >= 'a' && *s <= 'f')
                    n = n*16 + *s++ - 'a' + 10;
                else if(*s >= 'A' && *s <= 'F')
                    n = n*16 + *s++ - 'A' + 10;
                else
                    break;
            }
        } else
            while(*s >= '0' && *s <= '7')
                n = n*8 + *s++ - '0';
    } else
        while(*s >= '0' && *s <= '9')
            n = n*10 + *s++ - '0';
    if(f)
        n = -n;
    return n;
}
@


\section{Mathematic functions}

<<function rnd>>=
long
rnd(long v, long r)
{
    long c;

    if(r <= 0)
        return v;
    v += r - 1;
    c = v % r;
    if(c < 0)
        c += r;
    v -= c;
    return v;
}
@

\chapter{Linker-related Programs}
\label{chap:linker-related-programs}

\section{[[mach.h]]}

% can copy Fhdr here.

% actually linker does not depend on libmach/! because it's writing 
% specific stuff and libmach is mostly about generic reading interface 
% to many specifics
% (and not just 5l)

% FIGURE where see linker which does not use libmach, write vs read

% see libmach to read back this executable!
%FIGURE
% so   .s --5a--> .o (.5) --5l--> .exe (5.out) --libmach--> readable
% (hmm libmach is also reading .o (.5)


\section{[[size]]}
\label{sec:size-code}

% errort (0 is ok)
<<function size>>=
int
size(char *file)
{
    fdt fd;
    Fhdr f;

    if((fd = open(file, OREAD)) < 0){
        fprint(2, "size: ");
        perror(file);
        return 1;
    }
    if(crackhdr(fd, &f)) {
        print("%ldt + %ldd + %ldb = %ld\t%s\n", f.txtsz, f.datsz,
            f.bsssz, f.txtsz+f.datsz+f.bsssz, file);
        close(fd);
        return 0;
    }
    fprint(2, "size: %s not an a.out\n", file);
    close(fd);
    return 1;
}
@

<<function main (linkers/misc/size.c)>>=
void
main(int argc, char *argv[])
{
    char *err;
    int i;

    ARGBEGIN {
    default:
        fprint(2, "usage: size [a.out ...]\n");
        exits("usage");
    } ARGEND;

    err = nil;
    if(argc == 0)
        if(size("8.out"))
            err = "error";
    for(i=0; i<argc; i++)
        if(size(argv[i]))
            err = "error";
    exits(err);
}
@

\section{[[nm]]}
\label{sec:nm-code}

% see nm(1)
% use libmach!

% table with letter -> definition? (but explained in nm(1) it is true)
% or better do it via the code :)

\section{[[ar]]}
\label{sec:ar-code}

% see ar(5) and ar(1)

% ar use libmach/ library itself :) bootstrapping.

\section{[[strip]]}
\label{sec:strip-code}





\chapter{[[5l]] in OCaml}
\label{chap:5l-ocaml}

% yeah!!

% design decisions: 
% - no optimisations, space or speed, which guides many of the
%   other decisions below.
% - object file is marshalled form of ocaml AST. Far simpler!
%   (but less open to other languages; could use JSON but no ADT in JSON)
% - ??
% This decrements size of code, but also size of needed explanations!








\chapter{Extra Code}

\ifallcode
#include "Linker_extra.nw"
#include "Linker_x86.nw"
\fi

%\chapter{Changelog}
%\label{sec:changelog}
% code via make loc = 9700 LOC
% orig Linker.nw = 11 340, just lpized and few comments, 101 pages pdf
% now: ? LOC ? pages, so added ?? LOE (Lines of explanations)

\chapter*{Glossary}
\addcontentsline{toc}{chapter}{Glossary}
\label{sec:glossary}

\begin{verbatim}


\end{verbatim}




\chapter*{Indexes}
\addcontentsline{toc}{chapter}{Index}

%\chapter{References} 
\addcontentsline{toc}{chapter}{References}

\bibliography{../docs/latex/Principia}
\bibliographystyle{plain}

%******************************************************************************
% Postlude
%******************************************************************************

\end{document}
