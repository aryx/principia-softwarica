\documentclass[twocolumn]{report}

%******************************************************************************
% Prelude
%******************************************************************************
\newif\iffinal
\newif\ifverbose
\finaltrue\verbosefalse
% see also other newif in Macros.tex

%------------------------------------------------------------------------------
%history: 
%------------------------------------------------------------------------------

%thx to LP, changed for the better a few things:
% - introduced HEADTYPE instead of hardcoded ints
% - introduced mylog and DBG, cleaned up all those myxxx wrappers

%thx to codemap/codegraph:
% - see subtle dependency to 8c/enam.c through anames

%thx to this manual, better understand ld?:
% - TODO fpic? 
% - TODO dynamic linking?

%history LP-ization:
% - skeleton, mostly copy paste of Template.nw skeleton
% - put all content of files in the Extra section, via 'pfff -lpize'
%   which also now split in chunks!
%    * function, global, struct, enum, constant, macro(actually function)
% - read Extra section, identify concepts, first TOC
% - distribute parts of the file before
% - understand main(), LP split main, improve TOC
% - understand main functions, LP split, cluster, improve TOC
% - TODO LP split the structures, use datalog for flow to field info
% - TODO nullify, boolify, typeify,    scheckify
% - aspecify advanced features!
% - TODO add figures
% - TODO add explanations

%------------------------------------------------------------------------------
% Packages
%------------------------------------------------------------------------------

\usepackage{../docs/latex/noweb}
 \noweboptions{footnotesizecode,nomargintag}
 %note: allow chunk on different pages, less white space at bottom of pages
 \def\nwendcode{\endtrivlist \endgroup}
 \let\nwdocspar=\par
\usepackage{xspace}
\usepackage{verbatim}
%note: required by noweblatexpad for the \t \l \n in this file
\usepackage{fancyvrb}
\usepackage{url}
\iffinal
\usepackage{hyperref}
 \hypersetup{colorlinks=true}
\fi
\usepackage[pageref]{backref}
 \def\backref{{\footnotesize cited page(s)}~}
% not in basicTex
%\usepackage{cleveref} %\cref
% not in basicTex, for multirow TOC!
%\usepackage{multirow}
\usepackage{booktabs} 
 \newcommand{\otoprule}{\midrule[\heavyrulewidth]}
\usepackage{graphicx}
 %\usepackage[margin=0.5in]{geometry}
 %  but eat the bottom when very low
 %\usepackage{fullpage} is deprecated 
 % => do the more manual below:
 \addtolength{\oddsidemargin}{-.850in}
 \addtolength{\evensidemargin}{-.850in}
 \addtolength{\textwidth}{1.70in}
 \addtolength{\topmargin}{-.850in}
 \addtolength{\textheight}{1.70in}
%\usepackage{minitoc}

%------------------------------------------------------------------------------
% Macros
%------------------------------------------------------------------------------
\input{../docs/latex/Macros}

%------------------------------------------------------------------------------
% Config
%------------------------------------------------------------------------------
\allcodefalse
% used for forward decl, pragmas, func decl, extern decl, stats, #ifdef,
% debugging macros

%\setcounter{tocdepth}{1}

%******************************************************************************
% Title
%******************************************************************************

\begin{document}

\title{
{\Huge 
Principia Softwarica: The Plan9 Linker [[5l]]
% and Loader?
}\\
ARM (32 bits) edition\\
{version 0.1}
}
% 8l, x86 (32 bits) edition

\author{
Yoann Padioleau\\
\texttt{yoann.padioleau@gmail.com}
}

\maketitle 
\onecolumn
\hrule
\begin{quote}
    Copyright \copyright{} 2014 Yoann Padioleau \\
    Permission is granted to copy, distribute and/or modify this document,
    except all the source code it contains, under the terms of the GNU Free
    Documentation License, Version 1.3.
\end{quote}
\hrule

%CONFIG: \dominitoc

\iffinal
\begingroup
\hypersetup{linkcolor=blue}
% need to s/onecolumn/twocolumn in report.cls :) for \tableofcontents
\twocolumn
\tableofcontents
\endgroup
\else
\tableofcontents
\fi

%******************************************************************************
% Body
%******************************************************************************

\chapter{Introduction}

\section{Motivations}

The goal of this book is to present in full details the source code of
a linker.
Why? Because I think it makes you a better programmer if
you fully understand how things work under the hood.

% gonna present plan9 linker, small, clean.
% gonna present 5l just like we presented 5a and 5c. ARM simpler
% than x86.

Here are other candidates that were considered but ultimately discarded:
\begin{itemize}
\item GNU ld and the BFD library
\item Gold
\end{itemize}
% Linker and Loader book, introduce his own ld?

%http://eli.thegreenplace.net/2012/08/13/how-statically-linked-programs-run-on-linux/

% plan9 approach to linking is a bit different. The linker actually
% genereate the machine code. The object format is not the ISA.
% Simpler that way. Also allow inter-lib linking-time optimisations!
% Also there is no dynamic linking by default. Simpler approach
% again.

\section{Getting started}

\section{Requirements}

\section{About this document}
#include "../docs/latex/About.nw"

\section{Copyright}

Most of this document is actually source code from Plan9, so
those parts are copyright by Lucent Technologies Inc.
The prose is mine and is licensed under the GNU Free Documentation
License.

\section{Acknowledgments}


\chapter{Overview}

\section{Linker principles}

% and loader? why the use the term loader instead of linker?
% maybe because load the objects and libs and then link them
% (but first it "loads" them)

% principle: link together object files. Resolve external symbols.
% compute textsize, datasize, etc and adjust addresses.
% (actually for plan9 the linker is also generating the
% ISA binary code (what was usually done by the assembler)).

% what about dynamic linking? see Advanced topics chapter.

\section{[[5l]] services}

% command line interface? -o

% important -TText, see Kernel.nw

<<function usage, linker>>=
void
usage(void)
{
    diag("usage: %s [-options] objects", argv0);
    errorexit();
}
@


% env: $ccroot

\section{Example}
% show binary format? hexdump?

% see tests/ with two .c calling each other

\section{Input object format}
% the input this time (as opposed to 5a where it's the output)

% nm foo.5 => ? U? D? T?

% nm is actually using libmach, crachhdr, etc, generic API for object manip

% put libmach/5obj.c?

\section{Output executable format}
% the output,

%http://jvns.ca/blog/2014/09/06/how-to-read-an-executable/

% plan9 is essential a.out.h? 
% but can actually generate different executable (well different headers)

<<enum headtype(arm)>>=
/*
 *	-H0				      no header
 *	-H2 -T4128 -R4096	  is plan9 format
 *	-H7				      is elf
 */
enum headtype {
     H_NOTHING = 0,
     H_PLAN9 = 2,
     H_ELF = 7,
};
@
%old:
% *	-H1 -T0x10005000 -R4  is aif for risc os
% *	-H3 -T0xF0000020 -R4  is NetBSD format
% *	-H4				      is IXP1200 (raw)
% *	-H5 -T0xC0008010 -R1024 	is ipaq
% *	-H6 -R4096			   no header with segments padded to pages

% see libmach to read back this executable!

% so   .s -5a-> .o -5l-> .exe -libmach-> readable
% (hmm libmach is also reading .o (.5)



% include/a.out.h
% used by strip, libmach, but not 5l, should be 32 bytes (0x20)
% see asmb() that generates this far below
<<struct Exec>>=
// a.out header format
struct	Exec
{
    long	magic;		/* magic number */

    long	text;	 	/* size of text segment */
    long	data;	 	/* size of initialized data */
    long	bss;	  	/* size of uninitialized data */

    long	syms;	 	/* size of symbol table */

    // virtual address in [UTZERO+sizeof(Exec)..UTZERO+sizeof(Exec)+text]
    long	entry;	 	/* entry point */ 

    // used only by 68020, spsize set to 0 for 8l TODO remove at some point!
    long	spsz;		/* size of pc/sp offset table */
    // see a.out.h man page explaining how to compute the line of a PC
    long	pcsz;		/* size of pc/line number table */
};
@


% entry: it's actually usually not main but _main (or _mainp) that does
% some core initialization and then call main

\section{Code organization}

\section{Architecture overview}

% depends on 5.out.h all assembly instructions, registers, etc
% depends on 5c/ for one file:
%5c -FTVw -I/home/pad/plan9/include/386 -I/home/pad/plan9/include -. -I. ../5c/enam.c

% linker vs libmach, 
% actually linker does not depend on libmach/! because it's writing 
% specific stuff and libmach is mostly about generic reading interface 
% to many specifics
% (and not just 5l)


%###############################################################################

\chapter{Core Data Structures}

\section{[[Sym]] and [[hash]]}

% linker is all about resolving undefined symbols, and link to the right place
% so symbols are pretty central!

% conflict with include/a.out.h
<<struct Sym>>=
struct	Sym
{
    char	*name;
    short	version; // for static names, each sym has a different version

    //enum<section> ?
    short	type;

    // enum<section> too?
    byte	subtype;

    long	sig;
    long	value; // e.g. pc for a TEXT procedure

    // [[Sym]] other fields
    short	become;
    short	frame;
    ushort	file;

    // Extra

    // hash<Sym.name * Sym.version, ref<Sym>> of hash
    Sym*	link;
};
@



<<constant S>>=
#define	S		((Sym*)nil)
@



% SSTACK? not in exec :) not sure it's section, it's more about
%  type of symbol/entity, a const, file, data, procedure, etc
% see asmsym()
<<enum sxxx(arm)>>=
enum sxxx
{
    STEXT		= 1,

    SDATA,
    SBSS,

    SDATA1,
    SXREF,
    SLEAF, // arm
    SFILE,
    SCONST,

    SSTRING, // arm
    SUNDEF,

    SIMPORT,
    SEXPORT,
};
@
% SLEAF? the special opti ARM has for leaf functions?

<<enum misc(arm)>>=
enum misc {
    LFROM	= 1<<0,
    LTO		= 1<<1,
    LPOOL	= 1<<2,
    V4		= 1<<3,	/* arm v4 arch */
    VFP		= 1<<4,	/* arm vfpv3 floating point */

    C_NONE		= 0,
    C_REG,
    C_REGREG,
    C_SHIFT,
    C_FREG,
    C_PSR,
    C_FCR,

    C_RCON,		/* 0xff rotated */
    C_NCON,		/* ~RCON */
    C_SCON,		/* 0xffff */
    C_LCON,
    C_FCON,

    C_RACON,
    C_LACON,

    C_RECON,
    C_LECON,

    C_SBRA,
    C_LBRA,

    C_HAUTO,	/* halfword insn offset (-0xff to 0xff) */
    C_FAUTO,	/* float insn offset (0 to 0x3fc, word aligned) */
    C_HFAUTO,	/* both H and F */
    C_SAUTO,	/* -0xfff to 0xfff */
    C_LAUTO,

    C_HEXT,
    C_FEXT,
    C_HFEXT,
    C_SEXT,
    C_LEXT,

    C_HOREG,
    C_FOREG,
    C_HFOREG,
    C_SOREG,
    C_ROREG,
    C_SROREG,	/* both S and R */
    C_LOREG,

    C_ADDR,		/* relocatable address */

    C_GOK,

/* mark flags */
    FOLL		= 1<<0,
    LABEL		= 1<<1,
    LEAF		= 1<<2,

    BIG		= (1<<12)-4,

    <<constant STRINGSZ>>
    <<constant NHASH linker>>
    <<constant NHUNK linker>>

    MINSIZ		= 64,
    NENT		= 100,
    <<constant MAXIO>>
    MAXHIST		= 20,	/* limit of path elements for history symbols */
};
@
% >> >> >> >> >> >> >> >> >>


<<constant NHASH linker>>=
NHASH		= 10007,
@

<<global hash linker>>=
// hash<Sym.name * Sym.version, ref<Sym>> (next = Sym.link)
Sym*	hash[NHASH];
@

<<global nsymbol linker>>=
long	nsymbol;
@

% v is for version, but really it's about handling static names
% (we could have a typedef int version;? and VERSION0 = 0 so clearer to read?)
<<function lookup>>=
Sym*
lookup(char *symb, int v)
{
    Sym *s;
    char *p;
    long h;
    int l, c;

    // h = hash(symb, v)
    h = v;
    for(p=symb; c = *p; p++)
        h = h+h+h + c;
    l = (p - symb) + 1;
    h &= 0xffffff;
    h %= NHASH;
    
    // s = lookup(h, hash)
    for(s = hash[h]; s != S; s = s->link)
        if(s->version == v)
            if(memcmp(s->name, symb, l) == 0)
                return s;


    // s =~ malloc(sizeof(Sym)), TODO factorize this code
    while(nhunk < sizeof(Sym))
        gethunk();
    s = (Sym*)hunk;
    nhunk -= sizeof(Sym);
    hunk += sizeof(Sym);

    s->name = malloc(l + 1); // +1 again?
    memmove(s->name, symb, l);

    s->link = hash[h];
    s->type = 0;
    s->version = v;
    s->value = 0;
    s->sig = 0;
    hash[h] = s;
    nsymbol++;
    return s;
}
@



\section{[[Opcode]] and [[Operand_kind]]}
% in 5.out.h: Opcode (enum opcode), Operand_kind (enum operand_kind)
% see Aconv, Rconv, Dconv

% put major opcode here, AXXX, ALAST, etc
% and also R1, ... and also D_EXTERN,

\section{[[Prog]] and [[firstp]], [[textp]], [[datap]], [[curtext]], etc}

% bad name .... I think Prog is really a Instruction ... From and To
% are when do MOV AX, BX,    then AX is the from, BX the to


<<struct Prog(arm)>>=
struct	Prog
{
    //enum<opcode>
    byte	as;

    // operands
    Adr	from;
    Adr	to;

    // enum<register>?
    byte	reg;
    // enum<instr_cond>?
    byte	scond;

    union
    {
        long	u0regused;
        Prog*	u0forwd;
    } u0;

    // [[Prog]] other fields

    long	pc;
    long	line;
    byte	mark;
    byte	optab;

    // [[Prog]] Extra fields

    // list<ref<Prog>> from firstp/lastp, or datap/edatap
    Prog*	link;

    // list<ref<Prog>> from textp/etextp, to follow CALL xxx ???
    Prog*	cond;
};
@
% see Pconv, %P
%less: could rename cond to pcond and AB to AJMP and could factorize
% more code with x86

<<constant regused(arm)>>=
#define	regused	u0.u0regused
@

<<constant forwd(arm)>>=
#define	forwd	u0.u0forwd
@



% list of instructions (ATEXT and its instrs, but not ADATA, AGLOBL, ...)
% good name? first_instr better? also again there is strong
% coupling between firstp and lastp that should be encapsulated
% in a specific structure (like for datap, edatap)
<<global firstp>>=
// list<ref_own?<Prog>>, next = Prog.link
Prog*	firstp;
@


<<global lastp>>=
// ref<Prog>, last elt of firstp list
Prog*	lastp;
@



<<constant P>>=
#define	P		((Prog*)nil)
@




% list of procedures (ATEXT opcode), subset of firstp/lastp
<<global textp>>=
// list<ref<Prog>>, next = Prog.cond
Prog*	textp = P;
@


<<global etextp>>=
// ref<Prog>, end of textp list
Prog*	etextp = P;
@

% list of data (ADATA opcode)
<<global datap>>=
// list<ref<Prog>>, next = Prog.next
Prog*	datap = P;
@







% When iterate over all instrs, if the instr is a ATEXT then store it here.
% It's probably for error message, to say in which procedure we currently are
% most of the code related to curtext is if(p->as == ATEXT) curtext = p;
<<global curtext>>=
Prog*	curtext;
@




<<constant TNAME(arm)>>=
#define	TNAME (curtext && curtext->from.sym ? curtext->from.sym->name : noname)
@

<<global noname linker>>=
char	*noname		= "<none>";
@


<<global undefp>>=
//@Scheck: not dead, used by UP
Prog	undefp;
@



<<constant UP>>=
#define	UP	(&undefp)
@



\section{[[Adr]]}

% operand of instruction, e.g. in MOV AX, BX,  then AX is a form of Adr
% (would be better if had ADT so can have better Instruction type instead
% of those opcode, operand, Adr, and unions and all comments)

% give a few examples? show man page where have all the addressing modes


<<struct Adr(arm)>>=
struct	Adr
{
    //enum<operand_kind> (D_NONE by default)
    char	type;

    union
    {
        long	u0offset;
        char*	u0sval;
        Ieee*	u0ieee;
    } u0;

    union
    {
        Auto*	u1autom;
        Sym*	u1sym;
    } u1;

    // ??
    char	reg;
    char	name;
    char	class;
};
@
%    // TODO: abused for NOPROF function attributes


% the main thing the linker does, to relocate at the right place
% offset can be based on PC (for D_BRANCH), SB(for D_STATIC, D_EXTERN),
% on FP(for D_PARAM), and on SP(for D_AUTO), 
% or can be direct value (for D_CONST)
%see DConv
<<constant offset>>=
#define	offset	u0.u0offset
@

<<constant sval(arm)>>=
#define	sval	u0.u0sval
@

% TODO I thought could have unamed union that then alleviate the need
% for those macros! (just need to adapt graph_code_c to find those fields)

<<constant ieee>>=
#define	ieee	u0.u0ieee
@

<<constant autom>>=
#define	autom	u1.u1autom
@

<<constant sym>>=
#define	sym	u1.u1sym
@



<<struct Autom(arm)>>=
struct	Autom
{
    Sym*	asym;

    long	aoffset;
    short	type;

    // Extra
    Auto*	link;
};
@


\section{[[Optab]] and [[optab]]}


<<struct Optab(arm)>>=
struct	Optab
{
    // enum<as> from 5.out.h
    byte	as;

    char	a1;
    char	a2;
    char	a3;
    char	type;
    char	size;
    char	param;
    char	flag;
};
@

<<struct Oprang(arm)>>=
struct	Oprang
{
    Optab*	start;
    Optab*	stop;
};
@

<<struct Count(arm)>>=
struct	Count
{
    long	count;
    long	outof;
};
@


\chapter{[[main()]]}

% default object suffix, to generate x.out
<<global thechar>>=
char	thechar;
@

% to find library files? /386/lib/...
<<global thestring>>=
char	*thestring;
@


% -o, 
<<global outfile>>=
char*	outfile;
@


<<[[main()]] command line processing(arm)>>=
case 'o':
    outfile = ARGF();
    break;
@

% cout =~ create(outfile)
<<global cout>>=
fdt	cout = -1;
@











<<[[main()]] initialize globals(arm)>>=
histgen = 0;
textp = P;
datap = P;
pc = 0;
dtype = 4;
@

<<function main(arm)>>=
void
main(int argc, char *argv[])
{
    <<[[main()]] locals(arm)>>

    thechar = '5';
    thestring = "arm";   
    outfile = "5.out";

    <<[[main()]] debug initialization(arm)>>

    outfile = 0;
    nerrors = 0;
    curtext = P;

    HEADTYPE = -1;
    INITTEXT = -1;
    INITTEXTP = -1;
    INITDAT = -1;
    INITRND = -1;
    INITENTRY = 0;


    ARGBEGIN {
    <<[[main()]] command line processing(arm)>>
    } ARGEND
    USED(argc);
    if(*argv == nil)
        usage();

    <<[[main()]] addlibpath("/xxx/lib") or ccroot>>

    <<[[main()]] adjust HEADTYPE if debug flags(arm)>>
    switch(HEADTYPE) {
    <<[[main()]] switch HEADTYPE cases(arm)>>
    default:
        diag("unknown -H option");
        errorexit();
    }

    <<[[main()]] last INITXXX adjustments>>

    DBG("HEADER = -H0x%d -T0x%lux -D0x%lux -R0x%lux\n",
            HEADTYPE, INITTEXT, INITDAT, INITRND);

    <<[[main()]] set zprg(arm)>>

    <<[[main()]] initialize globals(arm)>>

    buildop();

    cout = create(outfile, 1, 0775);
    if(cout < 0) {
        diag("cannot create %s: %r", outfile);
        errorexit();
    }
    nuxiinit();

    // ------ main functions  ------
    version = 0;

    cbp = buf.cbuf;
    cbc = sizeof(buf.cbuf);

    <<[[main()]] cout is ready, LET'S GO(arm)>>

out:
    <<[[main()]] profile report>>
    errorexit();
}
@
%$




% -H executable format (header type)
<<global HEADTYPE>>=
long	HEADTYPE = -1; /* type of header */
@
% was int in ARM and long in x86, but I don't think it matters


% -T text segment start virtual address (important! e.g. for kernel 0x7c00)
<<global INITTEXT>>=
long	INITTEXT = -1; /* text location */
@



% -D data segment start
<<global INITDAT>>=
long	INITDAT = -1; /* data location */
@



% -E default _main (or _mainp when -p)
<<global INITENTRY>>=
char*	INITENTRY = nil;		/* entry point */
@



% -R text segment rounder at r multiple
<<global INITRND>>=
long	INITRND = -1; 		/* data round above text location */
@



<<[[main()]] command line processing(arm)>>=
    case 'H':
        a = ARGF();
        if(a)
            HEADTYPE = atolwhex(a);
        /* do something about setting INITTEXT */
        break;
    case 'T':
        a = ARGF();
        if(a)
            INITTEXT = atolwhex(a);
        break;
    case 'D':
        a = ARGF();
        if(a)
            INITDAT = atolwhex(a);
        break;
    case 'E':
        a = ARGF();
        if(a)
            INITENTRY = a;
        break;
    case 'R':
        a = ARGF();
        if(a)
            INITRND = atolwhex(a);
        break;
@



% size of Header, 32 for a.out (0x20)
<<global HEADR>>=
long	HEADR; 		/* length of header */
@



%32 = 0x20, hence this note in kernel mkfile:
%# see mem.h, the additional 20 are the size of the a.out header added by LD
%KTZERO_AND_HEADER=0xE0100020


<<[[main()]] switch HEADTYPE cases(arm)>>=
    case H_PLAN9:
        HEADR = 32L;
        if(INITTEXT == -1)
            INITTEXT = 4096+32;
        if(INITDAT == -1)
            INITDAT = 0;
        if(INITRND == -1)
            INITRND = 4096;
        break;
@

% less important I think
<<[[main()]] last INITXXX adjustments>>=
if (INITTEXTP == -1)
    INITTEXTP = INITTEXT;

if(INITDAT != 0 && INITRND != 0)
    print("warning: -D0x%lux is ignored because of -R0x%lux\n",
        INITDAT, INITRND);
@



\section{XXX}

<<constant LIBNAMELEN>>=
#define	LIBNAMELEN	300
@


% used locals? move closer the the code that use it then
<<[[main()]] locals(arm)>>=
int c;
char name[LIBNAMELEN];
char *a;
@
% *a still needed now that renamed to root?


\chapter{Main functions}


% essentially a malloc(sizeof(Prog), 
% see section on Buffer managment to better understand
<<constructor prg>>=
Prog*
prg(void)
{
    Prog *p;

    //todo: factorize with similar code in lookup but for Sym, 
    // =~ malloc(sizeof(Procg))
    while(nhunk < sizeof(Prog))
        gethunk();
    p = (Prog*)hunk;
    nhunk -= sizeof(Prog);
    hunk += sizeof(Prog);

    *p = zprg;
    return p;
}
@




% empty prg, to initialize new Prog
<<global zprg>>=
Prog	zprg;
@




%GOK? God Only Knows? to be used as a special mark, there is diag()
% in ldobj() about AGOK

<<[[main()]] set zprg(arm)>>=
zprg.as = AGOK;
zprg.scond = 14;
zprg.reg = NREG;
zprg.from.name = D_NONE;
zprg.from.type = D_NONE;
zprg.from.reg = NREG;
zprg.to = zprg.from;
@


% TODO unused for ARM?
<<function copyp>>=
Prog*
copyp(Prog *q)
{
    Prog *p;

    p = prg();
    *p = *q;
    return p;
}
@


% added by me (but maybe was in x86 originally)
<<[[main()]] locals(arm)>>=
bool load_libs;
@

% -l means no automagic stdlibs
<<[[main()]] initialize globals(arm)>>=
load_libs = !debug['l'];
@

% TODO: all those functions that take no args are ugly, they use too much
% globals, e.g. firstp, lastp, I should really rewrite the code
% to be more functional.





<<[[main()]] cout is ready, LET'S GO(arm)>>=
firstp = prg();
lastp = firstp;

<<[[main()]] set INITENTRY>>

while(*argv)
    objfile(*argv++);

if(load_libs)
    loadlib();

firstp = firstp->link;
if(firstp == P)
    goto out;

<<[[main()]] if export table or dynamic module(arm)>>

patch();
<<[[main()]] call doprofxxx() if profiling>>
dodata();
follow();
if(firstp == P)
    goto out;
noops();
span();

// write to cout, finally
asmb();
// sanity check
undef();
@


% when -l alone it means no startup lib
% why firstp = firstp->link? the first prog is a fake?
% and why ->link and not ->cond?


<<[[main()]] set INITENTRY>>=
if(INITENTRY == nil) {
    INITENTRY = "_main";
    <<[[main()]] adjust INITENTRY if profiling>>
    if(load_libs)
        lookup(INITENTRY, 0)->type = SXREF;
} else {
    <<[[main()]] if digit INITENTRY>>
}
@

% _main! not main, because _main is defined in libc and then call your main?
% SXREF means?

\section{Loading the objects, [[objfile()]]}

% essentially modify which globals?
%  - will modify libraryp probably, the cool pragma "autolib"
%    which is why objfile() must be called before loadlib()
%  - ??

<<function objfile>>=
void
objfile(char *file)
{
    fdt f;
    long l;
    char magbuf[SARMAG];
    <<[[objfile()]] other locals>>

    DBG("%5.2f ldobj: %s\n", cputime(), file);

    <<[[objfile()]] adjust file if -lxxx filename>>

    f = open(file, 0);
    if(f < 0) {
        diag("cannot open %s: %r", file);
        errorexit();
    }

    l = read(f, magbuf, SARMAG);

    // not a library
    if(l != SARMAG || strncmp(magbuf, ARMAG, SARMAG)){
        /* load it as a regular file */
        l = seek(f, 0L, SEEK__END);
        seek(f, 0L, SEEK__START);

        // the important call!
        ldobj(f, l, file);

        close(f);
        return;
    }

    <<[[objfile()]] when file is a library>>
}
@






%ldobj(), see later chapter

\section{Loading the libraries, [[loadlib()]]}
% it loads the libraries mentioned in the .obj via the .h and #pragma magic!
% see later section

<<global library>>=
char*	library[50];
@


<<global libraryp>>=
int	libraryp;
@


<<global libraryobj>>=
char*	libraryobj[50];
@



% ???
<<global xrefresolv>>=
bool	xrefresolv;
@


<<function loadlib>>=
void
loadlib(void)
{
    int i;
    long h;
    Sym *s;

loop:
    xrefresolv = false;
    for(i=0; i<libraryp; i++) {
        DBG("%5.2f autolib: %s (from %s)\n", cputime(), library[i], libraryobj[i]);
        objfile(library[i]);
    }
    if(xrefresolv)
        for(h=0; h<nelem(hash); h++)
             for(s = hash[h]; s != S; s = s->link)
                 if(s->type == SXREF)
                     goto loop;
}
@




\section{[[patch()]]}


<<function patch(arm)>>=
void
patch(void)
{
    long c, vexit;
    Prog *p, *q;
    Sym *s;
    int a;

    DBG("%5.2f patch\n", cputime());
    mkfwd();
    s = lookup("exit", 0);
    vexit = s->value;
    for(p = firstp; p != P; p = p->link) {
        a = p->as;
        if(a == ATEXT)
            curtext = p;
        if((a == ABL || a == AB || a == ARET) &&
           p->to.type != D_BRANCH && p->to.sym != S) {
            s = p->to.sym;
            switch(s->type) {
            default:
                diag("undefined: %s\n%P", s->name, p);
                s->type = STEXT;
                s->value = vexit;
                break;
            case STEXT:
                p->to.offset = s->value;
                p->to.type = D_BRANCH;
                break;
            case SUNDEF:
                if(p->as != ABL)
                    diag("help: SUNDEF in AB || ARET");
                p->to.offset = 0;
                p->to.type = D_BRANCH;
                p->cond = UP;
                break;
            }
        }
        if(p->to.type != D_BRANCH || p->cond == UP)
            continue;
        c = p->to.offset;
        for(q = firstp; q != P;) {
            if(q->forwd != P)
            if(c >= q->forwd->pc) {
                q = q->forwd;
                continue;
            }
            if(c == q->pc)
                break;
            q = q->link;
        }
        if(q == P) {
            diag("branch out of range %ld\n%P", c, p);
            p->to.type = D_NONE;
        }
        p->cond = q;
    }

    for(p = firstp; p != P; p = p->link) {
        if(p->as == ATEXT)
            curtext = p;
        if(p->cond != P && p->cond != UP) {
            p->cond = brloop(p->cond);
            if(p->cond != P)
            if(p->to.type == D_BRANCH)
                p->to.offset = p->cond->pc;
        }
    }
}
@



<<function brloop(arm)>>=
Prog*
brloop(Prog *p)
{
    Prog *q;
    int c;

    for(c=0; p!=P;) {
        if(p->as != AB)
            return p;
        q = p->cond;
        if(q <= p) {
            c++;
            if(q == p || c > 5000)
                break;
        }
        p = q;
    }
    return P;
}
@



<<constant LOG>>=
#define	LOG	5
@


<<function mkfwd>>=
void
mkfwd(void)
{
    Prog *p;
    int i;
    long dwn[LOG], cnt[LOG];
    Prog *lst[LOG];

    for(i=0; i<LOG; i++) {
        if(i == 0)
            cnt[i] = 1; else
            cnt[i] = LOG * cnt[i-1];
        dwn[i] = 1;
        lst[i] = P;
    }
    i = 0;
    for(p = firstp; p != P; p = p->link) {
        if(p->as == ATEXT)
            curtext = p;
        i--;
        if(i < 0)
            i = LOG-1;
        p->forwd = P;
        dwn[i]--;
        if(dwn[i] <= 0) {
            dwn[i] = cnt[i];
            if(lst[i] != P)
                lst[i]->forwd = p;
            lst[i] = p;
        }
    }
}
@


\section{[[follow()]]}

<<function follow>>=
void
follow(void)
{

    DBG("%5.2f follow\n", cputime());

    firstp = prg();
    lastp = firstp;

    xfol(textp);

    lastp->link = P;
    firstp = firstp->link;
}
@




<<function xfol(arm)>>=
void
xfol(Prog *p)
{
    Prog *q, *r;
    int a, i;

loop:
    if(p == P)
        return;
    a = p->as;
    if(a == ATEXT)
        curtext = p;
    if(a == AB) {
        q = p->cond;
        if(q != P) {
            p->mark |= FOLL;
            p = q;
            if(!(p->mark & FOLL))
                goto loop;
        }
    }
    if(p->mark & FOLL) {
        for(i=0,q=p; i<4; i++,q=q->link) {
            if(q == lastp)
                break;
            a = q->as;
            if(a == ANOP) {
                i--;
                continue;
            }
            if(a == AB || (a == ARET && q->scond == 14) || a == ARFE)
                goto copy;
            if(!q->cond || (q->cond->mark&FOLL))
                continue;
            if(a != ABEQ && a != ABNE)
                continue;
        copy:
            for(;;) {
                r = prg();
                *r = *p;
                if(!(r->mark&FOLL))
                    print("cant happen 1\n");
                r->mark |= FOLL;
                if(p != q) {
                    p = p->link;
                    lastp->link = r;
                    lastp = r;
                    continue;
                }
                lastp->link = r;
                lastp = r;
                if(a == AB || (a == ARET && q->scond == 14) || a == ARFE)
                    return;
                r->as = ABNE;
                if(a == ABNE)
                    r->as = ABEQ;
                r->cond = p->link;
                r->link = p->cond;
                if(!(r->link->mark&FOLL))
                    xfol(r->link);
                if(!(r->cond->mark&FOLL))
                    print("cant happen 2\n");
                return;
            }
        }
        a = AB;
        q = prg();
        q->as = a;
        q->line = p->line;
        q->to.type = D_BRANCH;
        q->to.offset = p->pc;
        q->cond = p;
        p = q;
    }
    p->mark |= FOLL;
    lastp->link = p;
    lastp = p;
    if(a == AB || (a == ARET && p->scond == 14) || a == ARFE){
        return;
    }
    if(p->cond != P)
    if(a != ABL && p->link != P) {
        q = brchain(p->link);
        if(a != ATEXT && a != ABCASE)
        if(q != P && (q->mark&FOLL)) {
            p->as = relinv(a);
            p->link = p->cond;
            p->cond = q;
        }
        xfol(p->link);
        q = brchain(p->cond);
        if(q == P)
            q = p->cond;
        if(q->mark&FOLL) {
            p->cond = q;
            return;
        }
        p = q;
        goto loop;
    }
    p = p->link;
    goto loop;
}
@




<<function relinv(arm)>>=
int
relinv(int a)
{
    switch(a) {
    case ABEQ:	return ABNE;
    case ABNE:	return ABEQ;
    case ABCS:	return ABCC;
    case ABHS:	return ABLO;
    case ABCC:	return ABCS;
    case ABLO:	return ABHS;
    case ABMI:	return ABPL;
    case ABPL:	return ABMI;
    case ABVS:	return ABVC;
    case ABVC:	return ABVS;
    case ABHI:	return ABLS;
    case ABLS:	return ABHI;
    case ABGE:	return ABLT;
    case ABLT:	return ABGE;
    case ABGT:	return ABLE;
    case ABLE:	return ABGT;
    }
    diag("unknown relation: %s", anames[a]);
    return a;
}
@




<<function brchain(arm)>>=
Prog*
brchain(Prog *p)
{
    int i;

    for(i=0; i<20; i++) {
        if(p == P || p->as != AB)
            return p;
        p = p->cond;
    }
    return P;
}
@


\section{Computing datsize, [[dodata()]]}

<<global datsize>>=
long	datsize;
@




<<global autosize(arm)>>=
long	autosize;
@



<<global bsssize>>=
long	bsssize;
@




<<function dodata(arm)>>=
void
dodata(void)
{
    int i, t;
    Sym *s;
    Prog *p;
    long orig, v;

    DBG("%5.2f dodata\n", cputime());
    for(p = datap; p != P; p = p->link) {
        s = p->from.sym;
        if(p->as == ADYNT || p->as == AINIT)
            s->value = dtype;
        if(s->type == SBSS)
            s->type = SDATA;
        if(s->type != SDATA)
            diag("initialize non-data (%d): %s\n%P",
                s->type, s->name, p);
        v = p->from.offset + p->reg;
        if(v > s->value)
            diag("initialize bounds (%ld): %s\n%P",
                s->value, s->name, p);
    }

    if(debug['t']) {
        /*
         * pull out string constants
         */
        for(p = datap; p != P; p = p->link) {
            s = p->from.sym;
            if(p->to.type == D_SCONST)
                s->type = SSTRING;
        }
    }

    /*
     * pass 1
     *	assign 'small' variables to data segment
     *	(rational is that data segment is more easily
     *	 addressed through offset on R12)
     */
    orig = 0;
    for(i=0; i<NHASH; i++)
    for(s = hash[i]; s != S; s = s->link) {
        t = s->type;
        if(t != SDATA && t != SBSS)
            continue;
        v = s->value;
        if(v == 0) {
            diag("%s: no size", s->name);
            v = 1;
        }
        while(v & 3)
            v++;
        s->value = v;
        if(v > MINSIZ)
            continue;
        s->value = orig;
        orig += v;
        s->type = SDATA1;
    }

    /*
     * pass 2
     *	assign large 'data' variables to data segment
     */
    for(i=0; i<NHASH; i++)
    for(s = hash[i]; s != S; s = s->link) {
        t = s->type;
        if(t != SDATA) {
            if(t == SDATA1)
                s->type = SDATA;
            continue;
        }
        v = s->value;
        s->value = orig;
        orig += v;
    }

    while(orig & 7)
        orig++;
    datsize = orig;

    /*
     * pass 3
     *	everything else to bss segment
     */
    for(i=0; i<NHASH; i++)
    for(s = hash[i]; s != S; s = s->link) {
        if(s->type != SBSS)
            continue;
        v = s->value;
        s->value = orig;
        orig += v;
    }
    while(orig & 7)
        orig++;
    bsssize = orig-datsize;

    xdefine("setR12", SDATA, 0L+BIG);
    xdefine("bdata", SDATA, 0L);
    xdefine("edata", SDATA, datsize);
    xdefine("end", SBSS, datsize+bsssize);
    xdefine("etext", STEXT, 0L);
}
@




<<function xdefine(arm)>>=
void
xdefine(char *p, int t, long v)
{
    Sym *s;

    s = lookup(p, 0);
    if(s->type == 0 || s->type == SXREF) {
        s->type = t;
        s->value = v;
    }
}
@



\section{[[noops()]]}
% arm only, or does it correspond to dostkoff of x86?

<<function noops(arm)>>=
void
noops(void)
{
    Prog *p, *q, *q1;
    int o, curframe, curbecome, maxbecome;

    /*
     * find leaf subroutines
     * become sizes
     * frame sizes
     * strip NOPs
     * expand RET
     * expand BECOME pseudo
     */

    DBG("%5.2f noops\n", cputime());

    curframe = 0;
    curbecome = 0;
    maxbecome = 0;
    curtext = 0;

    q = P;
    for(p = firstp; p != P; p = p->link) {

        /* find out how much arg space is used in this TEXT */
        if(p->to.type == D_OREG && p->to.reg == REGSP)
            if(p->to.offset > curframe)
                curframe = p->to.offset;

        switch(p->as) {
        case ATEXT:
            if(curtext && curtext->from.sym) {
                curtext->from.sym->frame = curframe;
                curtext->from.sym->become = curbecome;
                if(curbecome > maxbecome)
                    maxbecome = curbecome;
            }
            curframe = 0;
            curbecome = 0;

            p->mark |= LEAF;
            curtext = p;
            break;

        case ARET:
            /* special form of RET is BECOME */
            if(p->from.type == D_CONST)
                if(p->from.offset > curbecome)
                    curbecome = p->from.offset;
            break;

        case ADIV:
        case ADIVU:
        case AMOD:
        case AMODU:
            q = p;
            if(prog_div == P)
                initdiv();
            if(curtext != P)
                curtext->mark &= ~LEAF;
            continue;

        case ANOP:
            q1 = p->link;
            q->link = q1;		/* q is non-nop */
            q1->mark |= p->mark;
            continue;

        case ABL:
            if(curtext != P)
                curtext->mark &= ~LEAF;

        case ABCASE:
        case AB:

        case ABEQ:
        case ABNE:
        case ABCS:
        case ABHS:
        case ABCC:
        case ABLO:
        case ABMI:
        case ABPL:
        case ABVS:
        case ABVC:
        case ABHI:
        case ABLS:
        case ABGE:
        case ABLT:
        case ABGT:
        case ABLE:

            q1 = p->cond;
            if(q1 != P) {
                while(q1->as == ANOP) {
                    q1 = q1->link;
                    p->cond = q1;
                }
            }
            break;
        }
        q = p;
    }

    if(curtext && curtext->from.sym) {
        curtext->from.sym->frame = curframe;
        curtext->from.sym->become = curbecome;
        if(curbecome > maxbecome)
            maxbecome = curbecome;
    }

    if(debug['b'])
        print("max become = %d\n", maxbecome);
    xdefine("ALEFbecome", STEXT, maxbecome);

    curtext = 0;
    for(p = firstp; p != P; p = p->link) {
        switch(p->as) {
        case ATEXT:
            curtext = p;
            break;
        case ABL:
            if(curtext != P && curtext->from.sym != S && curtext->to.offset >= 0) {
                o = maxbecome - curtext->from.sym->frame;
                if(o <= 0)
                    break;
                /* calling a become or calling a variable */
                if(p->to.sym == S || p->to.sym->become) {
                    curtext->to.offset += o;
                    if(debug['b']) {
                        curp = p;
                        print("%D calling %D increase %d\n",
                            &curtext->from, &p->to, o);
                    }
                }
            }
            break;
        }
    }

    for(p = firstp; p != P; p = p->link) {
        o = p->as;
        switch(o) {
        case ATEXT:
            curtext = p;
            autosize = p->to.offset + 4;
            if(autosize <= 4)
            if(curtext->mark & LEAF) {
                p->to.offset = -4;
                autosize = 0;
            }

            if(!autosize && !(curtext->mark & LEAF)) {
                DBG("save suppressed in: %s\n", curtext->from.sym->name);
                curtext->mark |= LEAF;
            }

            if(curtext->mark & LEAF) {
                if(curtext->from.sym)
                    curtext->from.sym->type = SLEAF;
#ifdef optimise_time
                if(autosize) {
                    q = prg();
                    q->as = ASUB;
                    q->line = p->line;
                    q->from.type = D_CONST;
                    q->from.offset = autosize;
                    q->to.type = D_REG;
                    q->to.reg = REGSP;

                    q->link = p->link;
                    p->link = q;
                }
                break;
#else
                if(!autosize)
                    break;
#endif
            }

            q1 = prg();
            q1->as = AMOVW;
            q1->scond |= C_WBIT;
            q1->line = p->line;
            q1->from.type = D_REG;
            q1->from.reg = REGLINK;
            q1->to.type = D_OREG;
            q1->to.offset = -autosize;
            q1->to.reg = REGSP;

            q1->link = p->link;
            p->link = q1;
            break;

        case ARET:
            nocache(p);
            if(p->from.type == D_CONST)
                goto become;
            if(curtext->mark & LEAF) {
                if(!autosize) {
                    p->as = AB;
                    p->from = zprg.from;
                    p->to.type = D_OREG;
                    p->to.offset = 0;
                    p->to.reg = REGLINK;
                    break;
                }

#ifdef optimise_time
                p->as = AADD;
                p->from.type = D_CONST;
                p->from.offset = autosize;
                p->to.type = D_REG;
                p->to.reg = REGSP;

                q = prg();
                q->as = AB;
                q->scond = p->scond;
                q->line = p->line;
                q->to.type = D_OREG;
                q->to.offset = 0;
                q->to.reg = REGLINK;

                q->link = p->link;
                p->link = q;

                break;
#endif
            }
            p->as = AMOVW;
            p->scond |= C_PBIT;
            p->from.type = D_OREG;
            p->from.offset = autosize;
            p->from.reg = REGSP;
            p->to.type = D_REG;
            p->to.reg = REGPC;
            break;

        become:
            if(curtext->mark & LEAF) {

                if(!autosize) {
                    p->as = AB;
                    p->from = zprg.from;
                    break;
                }

#ifdef optimise_time
                q = prg();
                q->scond = p->scond;
                q->line = p->line;
                q->as = AB;
                q->from = zprg.from;
                q->to = p->to;
                q->cond = p->cond;
                q->link = p->link;
                p->link = q;

                p->as = AADD;
                p->from = zprg.from;
                p->from.type = D_CONST;
                p->from.offset = autosize;
                p->to = zprg.to;
                p->to.type = D_REG;
                p->to.reg = REGSP;

                break;
#endif
            }
            q = prg();
            q->scond = p->scond;
            q->line = p->line;
            q->as = AB;
            q->from = zprg.from;
            q->to = p->to;
            q->cond = p->cond;
            q->link = p->link;
            p->link = q;

            p->as = AMOVW;
            p->scond |= C_PBIT;
            p->from = zprg.from;
            p->from.type = D_OREG;
            p->from.offset = autosize;
            p->from.reg = REGSP;
            p->to = zprg.to;
            p->to.type = D_REG;
            p->to.reg = REGLINK;

            break;

        /*
         * 5c code generation for unsigned -> double made the
         * unfortunate assumption that single and double floating
         * point registers are aliased - true for emulated 7500
         * but not for vfp.  Now corrected, but this test is
         * insurance against old 5c compiled code in libraries.
         */
        case AMOVWD:
            if((q = p->link) != P && q->as == ACMP)
            if((q = q->link) != P && q->as == AMOVF)
            if((q1 = q->link) != P && q1->as == AADDF)
            if(q1->to.type == D_FREG && q1->to.reg == p->to.reg) {
                q1->as = AADDD;
                q1 = prg();
                q1->scond = q->scond;
                q1->line = q->line;
                q1->as = AMOVFD;
                q1->from = q->to;
                q1->to = q1->from;
                q1->link = q->link;
                q->link = q1;
            }
            break;

        case ADIV:
        case ADIVU:
        case AMOD:
        case AMODU:
            if(debug['M'])
                break;
            if(p->from.type != D_REG)
                break;
            if(p->to.type != D_REG)
                break;
            q1 = p;

            /* MOV a,4(SP) */
            q = prg();
            q->link = p->link;
            p->link = q;
            p = q;

            p->as = AMOVW;
            p->line = q1->line;
            p->from.type = D_REG;
            p->from.reg = q1->from.reg;
            p->to.type = D_OREG;
            p->to.reg = REGSP;
            p->to.offset = 4;

            /* MOV b,REGTMP */
            q = prg();
            q->link = p->link;
            p->link = q;
            p = q;

            p->as = AMOVW;
            p->line = q1->line;
            p->from.type = D_REG;
            p->from.reg = q1->reg;
            if(q1->reg == NREG)
                p->from.reg = q1->to.reg;
            p->to.type = D_REG;
            p->to.reg = REGTMP;
            p->to.offset = 0;

            /* CALL appropriate */
            q = prg();
            q->link = p->link;
            p->link = q;
            p = q;

            p->as = ABL;
            p->line = q1->line;
            p->to.type = D_BRANCH;
            p->cond = p;
            switch(o) {
            case ADIV:
                p->cond = prog_div;
                p->to.sym = sym_div;
                break;
            case ADIVU:
                p->cond = prog_divu;
                p->to.sym = sym_divu;
                break;
            case AMOD:
                p->cond = prog_mod;
                p->to.sym = sym_mod;
                break;
            case AMODU:
                p->cond = prog_modu;
                p->to.sym = sym_modu;
                break;
            }

            /* MOV REGTMP, b */
            q = prg();
            q->link = p->link;
            p->link = q;
            p = q;

            p->as = AMOVW;
            p->line = q1->line;
            p->from.type = D_REG;
            p->from.reg = REGTMP;
            p->from.offset = 0;
            p->to.type = D_REG;
            p->to.reg = q1->to.reg;

            /* ADD $8,SP */
            q = prg();
            q->link = p->link;
            p->link = q;
            p = q;

            p->as = AADD;
            p->from.type = D_CONST;
            p->from.reg = NREG;
            p->from.offset = 8;
            p->reg = NREG;
            p->to.type = D_REG;
            p->to.reg = REGSP;

            /* SUB $8,SP */
            q1->as = ASUB;
            q1->from.type = D_CONST;
            q1->from.offset = 8;
            q1->from.reg = NREG;
            q1->reg = NREG;
            q1->to.type = D_REG;
            q1->to.reg = REGSP;
            break;
        }
    }
}
@


\section{Computing textsize, [[span()]]}

<<global textsize>>=
long	textsize;
@





<<function span(arm)>>=
void
span(void)
{
    Prog *p;
    Sym *setext, *s;
    Optab *o;
    int m, bflag, i;
    long c, otxt, v;

    DBG("%5.2f span\n", cputime());

    bflag = 0;
    c = INITTEXT;
    otxt = c;
    for(p = firstp; p != P; p = p->link) {
        p->pc = c;
        o = oplook(p);
        m = o->size;
        if(m == 0) {
            if(p->as == ATEXT) {
                curtext = p;
                autosize = p->to.offset + 4;
                if(p->from.sym != S)
                    p->from.sym->value = c;
                /* need passes to resolve branches */
                if(c-otxt >= 1L<<17)
                    bflag = 1;
                otxt = c;
                continue;
            }
            diag("zero-width instruction\n%P", p);
            continue;
        }
        switch(o->flag & (LFROM|LTO|LPOOL)) {
        case LFROM:
            addpool(p, &p->from);
            break;
        case LTO:
            addpool(p, &p->to);
            break;
        case LPOOL:
            if ((p->scond&C_SCOND) == 14)
                flushpool(p, 0);
            break;
        }
        if(p->as==AMOVW && p->to.type==D_REG && p->to.reg==REGPC && (p->scond&C_SCOND) == 14)
            flushpool(p, 0);
        c += m;
        if(blitrl)
            checkpool(p);
    }

    /*
     * if any procedure is large enough to
     * generate a large SBRA branch, then
     * generate extra passes putting branches
     * around jmps to fix. this is rare.
     */
    while(bflag) {
        DBG("%5.2f span1\n", cputime());
        bflag = 0;
        c = INITTEXT;
        for(p = firstp; p != P; p = p->link) {
            p->pc = c;
            o = oplook(p);
/* very larg branches
            if(o->type == 6 && p->cond) {
                otxt = p->cond->pc - c;
                if(otxt < 0)
                    otxt = -otxt;
                if(otxt >= (1L<<17) - 10) {
                    q = prg();
                    q->link = p->link;
                    p->link = q;
                    q->as = AB;
                    q->to.type = D_BRANCH;
                    q->cond = p->cond;
                    p->cond = q;
                    q = prg();
                    q->link = p->link;
                    p->link = q;
                    q->as = AB;
                    q->to.type = D_BRANCH;
                    q->cond = q->link->link;
                    bflag = 1;
                }
            }
 */
            m = o->size;
            if(m == 0) {
                if(p->as == ATEXT) {
                    curtext = p;
                    autosize = p->to.offset + 4;
                    if(p->from.sym != S)
                        p->from.sym->value = c;
                    continue;
                }
                diag("zero-width instruction\n%P", p);
                continue;
            }
            c += m;
        }
    }

    if(debug['t']) {
        /* 
         * add strings to text segment
         */
        c = rnd(c, 8);
        for(i=0; i<NHASH; i++)
        for(s = hash[i]; s != S; s = s->link) {
            if(s->type != SSTRING)
                continue;
            v = s->value;
            while(v & 3)
                v++;
            s->value = c;
            c += v;
        }
    }

    c = rnd(c, 8);

    setext = lookup("etext", 0);
    if(setext != S) {
        setext->value = c;
        textsize = c - INITTEXT;
    }
    if(INITRND)
        INITDAT = rnd(c, INITRND);
    DBG("tsize = %lux\n", textsize);
}
@


% arm specific
<<global pool(arm)>>=
static struct {
    ulong	start;
    ulong	size;
} pool;
@


<<function checkpool(arm)>>=
/*
 * when the first reference to the literal pool threatens
 * to go out of range of a 12-bit PC-relative offset,
 * drop the pool now, and branch round it.
 * this happens only in extended basic blocks that exceed 4k.
 */
void
checkpool(Prog *p)
{
    if(pool.size >= 0xffc || immaddr((p->pc+4)+4+pool.size - pool.start+8) == 0)
        flushpool(p, 1);
    else if(p->link == P)
        flushpool(p, 2);
}
@

<<function flushpool(arm)>>=
void
flushpool(Prog *p, int skip)
{
    Prog *q;

    if(blitrl) {
        if(skip){
            if(debug['v'] && skip == 1)
                print("note: flush literal pool at %lux: len=%lud ref=%lux\n", p->pc+4, pool.size, pool.start);
            q = prg();
            q->as = AB;
            q->to.type = D_BRANCH;
            q->cond = p->link;
            q->link = blitrl;
            blitrl = q;
        }
        else if(p->pc+pool.size-pool.start < 2048)
            return;
        elitrl->link = p->link;
        p->link = blitrl;
        blitrl = 0;	/* BUG: should refer back to values until out-of-range */
        elitrl = 0;
        pool.size = 0;
        pool.start = 0;
    }
}
@


<<function aclass(arm)>>=
int
aclass(Adr *a)
{
    Sym *s;
    int t;

    switch(a->type) {
    case D_NONE:
        return C_NONE;

    case D_REG:
        return C_REG;

    case D_REGREG:
        return C_REGREG;

    case D_SHIFT:
        return C_SHIFT;

    case D_FREG:
        return C_FREG;

    case D_FPCR:
        return C_FCR;

    case D_OREG:
        switch(a->name) {
        case D_EXTERN:
        case D_STATIC:
            if(a->sym == 0 || a->sym->name == 0) {
                print("null sym external\n");
                print("%D\n", a);
                return C_GOK;
            }
            s = a->sym;
            t = s->type;
            if(t == 0 || t == SXREF) {
                diag("undefined external: %s in %s",
                    s->name, TNAME);
                s->type = SDATA;
            }
            if(dlm) {
                switch(t) {
                default:
                    instoffset = s->value + a->offset + INITDAT;
                    break;
                case SUNDEF:
                case STEXT:
                case SCONST:
                case SLEAF:
                case SSTRING:
                    instoffset = s->value + a->offset;
                    break;
                }
                return C_ADDR;
            }
            instoffset = s->value + a->offset - BIG;
            t = immaddr(instoffset);
            if(t) {
                if(immhalf(instoffset))
                    return immfloat(t) ? C_HFEXT : C_HEXT;
                if(immfloat(t))
                    return C_FEXT;
                return C_SEXT;
            }
            return C_LEXT;
        case D_AUTO:
            instoffset = autosize + a->offset;
            t = immaddr(instoffset);
            if(t){
                if(immhalf(instoffset))
                    return immfloat(t) ? C_HFAUTO : C_HAUTO;
                if(immfloat(t))
                    return C_FAUTO;
                return C_SAUTO;
            }
            return C_LAUTO;

        case D_PARAM:
            instoffset = autosize + a->offset + 4L;
            t = immaddr(instoffset);
            if(t){
                if(immhalf(instoffset))
                    return immfloat(t) ? C_HFAUTO : C_HAUTO;
                if(immfloat(t))
                    return C_FAUTO;
                return C_SAUTO;
            }
            return C_LAUTO;
        case D_NONE:
            instoffset = a->offset;
            t = immaddr(instoffset);
            if(t) {
                if(immhalf(instoffset))		 /* n.b. that it will also satisfy immrot */
                    return immfloat(t) ? C_HFOREG : C_HOREG;
                if(immfloat(t))
                    return C_FOREG; /* n.b. that it will also satisfy immrot */
                t = immrot(instoffset);
                if(t)
                    return C_SROREG;
                if(immhalf(instoffset))
                    return C_HOREG;
                return C_SOREG;
            }
            t = immrot(instoffset);
            if(t)
                return C_ROREG;
            return C_LOREG;
        }
        return C_GOK;

    case D_PSR:
        return C_PSR;

    case D_OCONST:
        switch(a->name) {
        case D_EXTERN:
        case D_STATIC:
            s = a->sym;
            t = s->type;
            if(t == 0 || t == SXREF) {
                diag("undefined external: %s in %s",
                    s->name, TNAME);
                s->type = SDATA;
            }
            instoffset = s->value + a->offset + INITDAT;
            if(s->type == STEXT || s->type == SLEAF || s->type == SUNDEF)
                instoffset = s->value + a->offset;
            return C_LCON;
        }
        return C_GOK;

    case D_FCONST:
        return C_FCON;

    case D_CONST:
        switch(a->name) {

        case D_NONE:
            instoffset = a->offset;
            if(a->reg != NREG)
                goto aconsize;

            t = immrot(instoffset);
            if(t)
                return C_RCON;
            t = immrot(~instoffset);
            if(t)
                return C_NCON;
            return C_LCON;

        case D_EXTERN:
        case D_STATIC:
            s = a->sym;
            if(s == S)
                break;
            t = s->type;
            switch(t) {
            case 0:
            case SXREF:
                diag("undefined external: %s in %s",
                    s->name, TNAME);
                s->type = SDATA;
                break;
            case SUNDEF:
            case STEXT:
            case SSTRING:
            case SCONST:
            case SLEAF:
                instoffset = s->value + a->offset;
                return C_LCON;
            }
            if(!dlm) {
                instoffset = s->value + a->offset - BIG;
                t = immrot(instoffset);
                if(t && instoffset != 0)
                    return C_RECON;
            }
            instoffset = s->value + a->offset + INITDAT;
            return C_LCON;

        case D_AUTO:
            instoffset = autosize + a->offset;
            goto aconsize;

        case D_PARAM:
            instoffset = autosize + a->offset + 4L;
        aconsize:
            t = immrot(instoffset);
            if(t)
                return C_RACON;
            return C_LACON;
        }
        return C_GOK;

    case D_BRANCH:
        return C_SBRA;
    }
    return C_GOK;
}
@



<<function addpool(arm)>>=
void
addpool(Prog *p, Adr *a)
{
    Prog *q, t;
    int c;

    c = aclass(a);

    t = zprg;
    t.as = AWORD;

    switch(c) {
    default:
        t.to = *a;
        break;

    case C_SROREG:
    case C_LOREG:
    case C_ROREG:
    case C_FOREG:
    case C_SOREG:
    case C_FAUTO:
    case C_SAUTO:
    case C_LAUTO:
    case C_LACON:
        t.to.type = D_CONST;
        t.to.offset = instoffset;
        break;
    }

    for(q = blitrl; q != P; q = q->link)	/* could hash on t.t0.offset */
        if(memcmp(&q->to, &t.to, sizeof(t.to)) == 0) {
            p->cond = q;
            return;
        }

    q = prg();
    *q = t;
    q->pc = pool.size;

    if(blitrl == P) {
        blitrl = q;
        pool.start = p->pc;
    } else
        elitrl->link = q;
    elitrl = q;
    pool.size += 4;

    p->cond = q;
}
@


\section{Generating the executable, [[asmb()]]}
% asmb? asm binary?

% first function to actually use cout!

<<global curp>>=
Prog*	curp;
@




<<function asmb(arm)>>=
void
asmb(void)
{
    Prog *p;
    long t, etext;
    Optab *o;

    DBG("%5.2f asm\n", cputime());

    // TEXT SECTION

    OFFSET = HEADR;
    seek(cout, OFFSET, SEEK__START);
    pc = INITTEXT;

    for(p = firstp; p != P; p = p->link) {
        if(p->as == ATEXT) {
            curtext = p;
            autosize = p->to.offset + 4;
        }
        if(p->pc != pc) {
            diag("phase error %lux sb %lux", p->pc, pc);
            if(!debug['a'])
                prasm(curp);
            pc = p->pc;
        }
        curp = p;

        // generate instruction! ?
        o = oplook(p);	/* could probably avoid this call */
        asmout(p, o);

        pc += o->size;
    }

    if(debug['a'])
        Bprint(&bso, "\n");
    Bflush(&bso);

    cflush();

    /* output strings in text segment */
    etext = INITTEXT + textsize;
    for(t = pc; t < etext; t += sizeof(buf)-100) {
        if(etext-t > sizeof(buf)-100)
            datblk(t, sizeof(buf)-100, 1);
        else
            datblk(t, etext-t, 1);
    }

    // DATA SECTION

    curtext = P;
    switch(HEADTYPE) {
    case H_PLAN9:
        OFFSET = HEADR+textsize;
        seek(cout, OFFSET, SEEK__START);
        break;
    <<[[asmb()]] switch HEADTYPE (to position after text) cases(arm)>>
    }

    <<[[asmb()]] if dynamic module, before datblk()>>

    for(t = 0; t < datsize; t += sizeof(buf)-100) {
        if(datsize-t > sizeof(buf)-100)
            datblk(t, sizeof(buf)-100, 0);
        else
            datblk(t, datsize-t, 0);
    }

    // SYMBOL TABLE

    // modified by asmsym()
    symsize = 0;
    // modified by asmlc()
    lcsize = 0;

    if(!debug['s']) {
        DBG("%5.2f sym\n", cputime());

        switch(HEADTYPE) {
        case H_PLAN9:
            OFFSET = HEADR+textsize+datsize;
            seek(cout, OFFSET, 0);
            break;
        <<[[asmb()]] switch HEADTYPE (for symbol table generation) cases(arm)>>
        }

        asmsym();
        DBG("%5.2f pc\n", cputime());

        asmlc();
        <<[[asmb()]] if dynamic module, call asmdyn()>>

        cflush();
    }
    else {
        <<[[asmb()]] if dynamic module and no symbol table generation>>
    }

    // HEADER

    DBG("%5.2f header\n", cputime());

    OFFSET = 0;
    seek(cout, OFFSET, SEEK__START);

    switch(HEADTYPE) {
    // see Exec in a.out.h

    case H_PLAN9:
        <<[[asmb()]] if dynamic module magic header adjustment(arm)>>
        else
            lput(0x647);			/* magic */
        lput(textsize);			/* sizes */
        lput(datsize);
        lput(bsssize);
        lput(symsize);			/* nsyms */
        lput(entryvalue());		/* va of entry */
        lput(0L);
        lput(lcsize);
        break;

    <<[[asmb()]] switch HEADTYPE (for header generation) cases(arm)>>
    }

    cflush();
}
@

<<function oplook(arm)>>=
Optab*
oplook(Prog *p)
{
    int a1, a2, a3, r;
    char *c1, *c3;
    Optab *o, *e;

    a1 = p->optab;
    if(a1)
        return optab+(a1-1);
    a1 = p->from.class;
    if(a1 == 0) {
        a1 = aclass(&p->from) + 1;
        p->from.class = a1;
    }
    a1--;
    a3 = p->to.class;
    if(a3 == 0) {
        a3 = aclass(&p->to) + 1;
        p->to.class = a3;
    }
    a3--;
    a2 = C_NONE;
    if(p->reg != NREG)
        a2 = C_REG;
    r = p->as;
    o = oprange[r].start;
    if(o == 0) {
        a1 = opcross[repop[r]][a1][a2][a3];
        if(a1) {
            p->optab = a1+1;
            return optab+a1;
        }
        o = oprange[r].stop; /* just generate an error */
    }
    if(0) {
        print("oplook %A %d %d %d\n",
            (int)p->as, a1, a2, a3);
        print("		%d %d\n", p->from.type, p->to.type);
    }
    e = oprange[r].stop;
    c1 = xcmp[a1];
    c3 = xcmp[a3];
    for(; o<e; o++)
        if(o->a2 == a2)
        if(c1[o->a1])
        if(c3[o->a3]) {
            p->optab = (o-optab)+1;
            return o;
        }
    diag("illegal combination %A %d %d %d",
        p->as, a1, a2, a3);
    prasm(p);
    if(o == 0)
        o = optab;
    return o;
}
@





<<function entryvalue(arm)>>=
long
entryvalue(void)
{
    char *a;
    Sym *s;

    a = INITENTRY;

    <<[[entryvalue()]] if digit INITENTRY>>

    s = lookup(a, 0);

    if(s->type == 0)
        return INITTEXT;

    switch(s->type) {
    case STEXT:
    case SLEAF:
        break;
    <<[[entryvalue()]] if dynamic module case>>
    default:
        diag("entry not text: %s", s->name);
    }
    return s->value;
}
@


<<constant Dbufslop>>=
#define	Dbufslop	100
@


<<function datblk(arm)>>=
void
datblk(long s, long n, int str)
{
    Sym *v;
    Prog *p;
    char *cast;
    long a, l, fl, j, d;
    int i, c;

    memset(buf.dbuf, 0, n+Dbufslop);
    for(p = datap; p != P; p = p->link) {
        if(str != (p->from.sym->type == SSTRING))
            continue;
        curp = p;
        a = p->from.sym->value + p->from.offset;
        l = a - s;
        c = p->reg;
        i = 0;
        if(l < 0) {
            if(l+c <= 0)
                continue;
            while(l < 0) {
                l++;
                i++;
            }
        }
        if(l >= n)
            continue;
        if(p->as != AINIT && p->as != ADYNT) {
            for(j=l+(c-i)-1; j>=l; j--)
                if(buf.dbuf[j]) {
                    print("%P\n", p);
                    diag("multiple initialization");
                    break;
                }
        }
        switch(p->to.type) {
        default:
            diag("unknown mode in initialization%P", p);
            break;

        case D_FCONST:
            switch(c) {
            default:
            case 4:
                fl = ieeedtof(p->to.ieee);
                cast = (char*)&fl;
                for(; i<c; i++) {
                    buf.dbuf[l] = cast[fnuxi4[i]];
                    l++;
                }
                break;
            case 8:
                cast = (char*)p->to.ieee;
                for(; i<c; i++) {
                    buf.dbuf[l] = cast[fnuxi8[i]];
                    l++;
                }
                break;
            }
            break;

        case D_SCONST:
            for(; i<c; i++) {
                buf.dbuf[l] = p->to.sval[i];
                l++;
            }
            break;

        case D_CONST:
            d = p->to.offset;
            v = p->to.sym;
            if(v) {
                switch(v->type) {
                case SUNDEF:
                    ckoff(v, d);
                case STEXT:
                case SLEAF:
                case SSTRING:
                    d += p->to.sym->value;
                    break;
                case SDATA:
                case SBSS:
                    d += p->to.sym->value + INITDAT;
                }
                <<[[datblk()]] if dynamic module(arm)>>
            }
            cast = (char*)&d;
            switch(c) {
            default:
                diag("bad nuxi %d %d%P", c, i, curp);
                break;
            case 1:
                for(; i<c; i++) {
                    buf.dbuf[l] = cast[inuxi1[i]];
                    l++;
                }
                break;
            case 2:
                for(; i<c; i++) {
                    buf.dbuf[l] = cast[inuxi2[i]];
                    l++;
                }
                break;
            case 4:
                for(; i<c; i++) {
                    buf.dbuf[l] = cast[inuxi4[i]];
                    l++;
                }
                break;
            }
            break;
        }
    }
    write(cout, buf.dbuf, n);
}
@



<<function ckoff>>=
void
ckoff(Sym *s, long v)
{
    if(v < 0 || v >= 1<<Roffset)
        diag("relocation offset %ld for %s out of range", v, s->name);
}
@

% >>




<<function asmout(arm)>>=
void
asmout(Prog *p, Optab *o)
{
    long o1, o2, o3, o4, o5, o6, v;
    int r, rf, rt, rt2;
    Sym *s;

PP = p;
    o1 = 0;
    o2 = 0;
    o3 = 0;
    o4 = 0;
    o5 = 0;
    o6 = 0;
    switch(o->type) {
    default:
        diag("unknown asm %d", o->type);
        prasm(p);
        break;

    case 0:		/* pseudo ops */
        break;

    case 1:		/* op R,[R],R */
        o1 = oprrr(p->as, p->scond);
        rf = p->from.reg;
        rt = p->to.reg;
        r = p->reg;
        if(p->to.type == D_NONE)
            rt = 0;
        if(p->as == AMOVW || p->as == AMVN)
            r = 0;
        else if(r == NREG)
            r = rt;
        o1 |= rf | (r<<16) | (rt<<12);
        break;

    case 2:		/* movbu $I,[R],R */
        aclass(&p->from);
        o1 = oprrr(p->as, p->scond);
        o1 |= immrot(instoffset);
        rt = p->to.reg;
        r = p->reg;
        if(p->to.type == D_NONE)
            rt = 0;
        if(p->as == AMOVW || p->as == AMVN)
            r = 0;
        else if(r == NREG)
            r = rt;
        o1 |= (r<<16) | (rt<<12);
        break;

    case 3:		/* add R<<[IR],[R],R */
    mov:
        aclass(&p->from);
        o1 = oprrr(p->as, p->scond);
        o1 |= p->from.offset;
        rt = p->to.reg;
        r = p->reg;
        if(p->to.type == D_NONE)
            rt = 0;
        if(p->as == AMOVW || p->as == AMVN)
            r = 0;
        else if(r == NREG)
            r = rt;
        o1 |= (r<<16) | (rt<<12);
        break;

    case 4:		/* add $I,[R],R */
        aclass(&p->from);
        o1 = oprrr(AADD, p->scond);
        o1 |= immrot(instoffset);
        r = p->from.reg;
        if(r == NREG)
            r = o->param;
        o1 |= r << 16;
        o1 |= p->to.reg << 12;
        break;

    case 5:		/* bra s */
        v = -8;
        if(p->cond == UP) {
            s = p->to.sym;
            if(s->type != SUNDEF)
                diag("bad branch sym type");
            v = (ulong)s->value >> (Roffset-2);
            dynreloc(s, p->pc, 0);
        }
        else if(p->cond != P)
            v = (p->cond->pc - pc) - 8;
        o1 = opbra(p->as, p->scond);
        o1 |= (v >> 2) & 0xffffff;
        break;

    case 6:		/* b ,O(R) -> add $O,R,PC */
        aclass(&p->to);
        o1 = oprrr(AADD, p->scond);
        o1 |= immrot(instoffset);
        o1 |= p->to.reg << 16;
        o1 |= REGPC << 12;
        break;

    case 7:		/* bl ,O(R) -> mov PC,link; add $O,R,PC */
        aclass(&p->to);
        o1 = oprrr(AADD, p->scond);
        o1 |= immrot(0);
        o1 |= REGPC << 16;
        o1 |= REGLINK << 12;

        o2 = oprrr(AADD, p->scond);
        o2 |= immrot(instoffset);
        o2 |= p->to.reg << 16;
        o2 |= REGPC << 12;
        break;

    case 8:		/* sll $c,[R],R -> mov (R<<$c),R */
        aclass(&p->from);
        o1 = oprrr(p->as, p->scond);
        r = p->reg;
        if(r == NREG)
            r = p->to.reg;
        o1 |= r;
        o1 |= (instoffset&31) << 7;
        o1 |= p->to.reg << 12;
        break;

    case 9:		/* sll R,[R],R -> mov (R<<R),R */
        o1 = oprrr(p->as, p->scond);
        r = p->reg;
        if(r == NREG)
            r = p->to.reg;
        o1 |= r;
        o1 |= (p->from.reg << 8) | (1<<4);
        o1 |= p->to.reg << 12;
        break;

    case 10:	/* swi [$con] */
        o1 = oprrr(p->as, p->scond);
        if(p->to.type != D_NONE) {
            aclass(&p->to);
            o1 |= instoffset & 0xffffff;
        }
        break;

    case 11:	/* word */
        switch(aclass(&p->to)) {
        case C_LCON:
            if(!dlm)
                break;
            if(p->to.name != D_EXTERN && p->to.name != D_STATIC)
                break;
        case C_ADDR:
            if(p->to.sym->type == SUNDEF)
                ckoff(p->to.sym, p->to.offset);
            dynreloc(p->to.sym, p->pc, 1);
        }
        o1 = instoffset;
        break;

    case 12:	/* movw $lcon, reg */
        o1 = omvl(p, &p->from, p->to.reg);
        break;

    case 13:	/* op $lcon, [R], R */
        o1 = omvl(p, &p->from, REGTMP);
        if(!o1)
            break;
        o2 = oprrr(p->as, p->scond);
        o2 |= REGTMP;
        r = p->reg;
        if(p->as == AMOVW || p->as == AMVN)
            r = 0;
        else if(r == NREG)
            r = p->to.reg;
        o2 |= r << 16;
        if(p->to.type != D_NONE)
            o2 |= p->to.reg << 12;
        break;

    case 14:	/* movb/movbu/movh/movhu R,R */
        o1 = oprrr(ASLL, p->scond);

        if(p->as == AMOVBU || p->as == AMOVHU)
            o2 = oprrr(ASRL, p->scond);
        else
            o2 = oprrr(ASRA, p->scond);

        r = p->to.reg;
        o1 |= (p->from.reg)|(r<<12);
        o2 |= (r)|(r<<12);
        if(p->as == AMOVB || p->as == AMOVBU) {
            o1 |= (24<<7);
            o2 |= (24<<7);
        } else {
            o1 |= (16<<7);
            o2 |= (16<<7);
        }
        break;

    case 15:	/* mul r,[r,]r */
        o1 = oprrr(p->as, p->scond);
        rf = p->from.reg;
        rt = p->to.reg;
        r = p->reg;
        if(r == NREG)
            r = rt;
        if(rt == r) {
            r = rf;
            rf = rt;
        }
        if(0)
        if(rt == r || rf == REGPC || r == REGPC || rt == REGPC) {
            diag("bad registers in MUL");
            prasm(p);
        }
        o1 |= (rf<<8) | r | (rt<<16);
        break;


    case 16:	/* div r,[r,]r */
        o1 = 0xf << 28;
        o2 = 0;
        break;

    case 17:
        o1 = oprrr(p->as, p->scond);
        rf = p->from.reg;
        rt = p->to.reg;
        rt2 = p->to.offset;
        r = p->reg;
        o1 |= (rf<<8) | r | (rt<<16) | (rt2<<12);
        break;

    case 20:	/* mov/movb/movbu R,O(R) */
        aclass(&p->to);
        r = p->to.reg;
        if(r == NREG)
            r = o->param;
        o1 = osr(p->as, p->from.reg, instoffset, r, p->scond);
        break;

    case 21:	/* mov/movbu O(R),R -> lr */
        aclass(&p->from);
        r = p->from.reg;
        if(r == NREG)
            r = o->param;
        o1 = olr(instoffset, r, p->to.reg, p->scond);
        if(p->as != AMOVW)
            o1 |= 1<<22;
        break;

    case 22:	/* movb/movh/movhu O(R),R -> lr,shl,shr */
        aclass(&p->from);
        r = p->from.reg;
        if(r == NREG)
            r = o->param;
        o1 = olr(instoffset, r, p->to.reg, p->scond);

        o2 = oprrr(ASLL, p->scond);
        o3 = oprrr(ASRA, p->scond);
        r = p->to.reg;
        if(p->as == AMOVB) {
            o2 |= (24<<7)|(r)|(r<<12);
            o3 |= (24<<7)|(r)|(r<<12);
        } else {
            o2 |= (16<<7)|(r)|(r<<12);
            if(p->as == AMOVHU)
                o3 = oprrr(ASRL, p->scond);
            o3 |= (16<<7)|(r)|(r<<12);
        }
        break;

    case 23:	/* movh/movhu R,O(R) -> sb,sb */
        aclass(&p->to);
        r = p->to.reg;
        if(r == NREG)
            r = o->param;
        o1 = osr(AMOVH, p->from.reg, instoffset, r, p->scond);

        o2 = oprrr(ASRL, p->scond);
        o2 |= (8<<7)|(p->from.reg)|(REGTMP<<12);

        o3 = osr(AMOVH, REGTMP, instoffset+1, r, p->scond);
        break;

    case 30:	/* mov/movb/movbu R,L(R) */
        o1 = omvl(p, &p->to, REGTMP);
        if(!o1)
            break;
        r = p->to.reg;
        if(r == NREG)
            r = o->param;
        o2 = osrr(p->from.reg, REGTMP,r, p->scond);
        if(p->as != AMOVW)
            o2 |= 1<<22;
        break;

    case 31:	/* mov/movbu L(R),R -> lr[b] */
    case 32:	/* movh/movb L(R),R -> lr[b] */
        o1 = omvl(p, &p->from, REGTMP);
        if(!o1)
            break;
        r = p->from.reg;
        if(r == NREG)
            r = o->param;
        o2 = olrr(REGTMP,r, p->to.reg, p->scond);
        if(p->as == AMOVBU || p->as == AMOVB)
            o2 |= 1<<22;
        if(o->type == 31)
            break;

        o3 = oprrr(ASLL, p->scond);

        if(p->as == AMOVBU || p->as == AMOVHU)
            o4 = oprrr(ASRL, p->scond);
        else
            o4 = oprrr(ASRA, p->scond);

        r = p->to.reg;
        o3 |= (r)|(r<<12);
        o4 |= (r)|(r<<12);
        if(p->as == AMOVB || p->as == AMOVBU) {
            o3 |= (24<<7);
            o4 |= (24<<7);
        } else {
            o3 |= (16<<7);
            o4 |= (16<<7);
        }
        break;

    case 33:	/* movh/movhu R,L(R) -> sb, sb */
        o1 = omvl(p, &p->to, REGTMP);
        if(!o1)
            break;
        r = p->to.reg;
        if(r == NREG)
            r = o->param;
        o2 = osrr(p->from.reg, REGTMP, r, p->scond);
        o2 |= (1<<22) ;

        o3 = oprrr(ASRL, p->scond);
        o3 |= (8<<7)|(p->from.reg)|(p->from.reg<<12);
        o3 |= (1<<6);	/* ROR 8 */

        o4 = oprrr(AADD, p->scond);
        o4 |= (REGTMP << 12) | (REGTMP << 16);
        o4 |= immrot(1);

        o5 = osrr(p->from.reg, REGTMP,r,p->scond);
        o5 |= (1<<22);

        o6 = oprrr(ASRL, p->scond);
        o6 |= (24<<7)|(p->from.reg)|(p->from.reg<<12);
        o6 |= (1<<6);	/* ROL 8 */

        break;
        
    case 34:	/* mov $lacon,R */
        o1 = omvl(p, &p->from, REGTMP);
        if(!o1)
            break;

        o2 = oprrr(AADD, p->scond);
        o2 |= REGTMP;
        r = p->from.reg;
        if(r == NREG)
            r = o->param;
        o2 |= r << 16;
        if(p->to.type != D_NONE)
            o2 |= p->to.reg << 12;
        break;

    case 35:	/* mov PSR,R */
        o1 = (2<<23) | (0xf<<16) | (0<<0);
        o1 |= (p->scond & C_SCOND) << 28;
        o1 |= (p->from.reg & 1) << 22;
        o1 |= p->to.reg << 12;
        break;

    case 36:	/* mov R,PSR */
        o1 = (2<<23) | (0x29f<<12) | (0<<4);
        if(p->scond & C_FBIT)
            o1 ^= 0x010 << 12;
        o1 |= (p->scond & C_SCOND) << 28;
        o1 |= (p->to.reg & 1) << 22;
        o1 |= p->from.reg << 0;
        break;

    case 37:	/* mov $con,PSR */
        aclass(&p->from);
        o1 = (2<<23) | (0x29f<<12) | (0<<4);
        if(p->scond & C_FBIT)
            o1 ^= 0x010 << 12;
        o1 |= (p->scond & C_SCOND) << 28;
        o1 |= immrot(instoffset);
        o1 |= (p->to.reg & 1) << 22;
        o1 |= p->from.reg << 0;
        break;

    case 38:	/* movm $con,oreg -> stm */
        o1 = (0x4 << 25);
        o1 |= p->from.offset & 0xffff;
        o1 |= p->to.reg << 16;
        aclass(&p->to);
        goto movm;

    case 39:	/* movm oreg,$con -> ldm */
        o1 = (0x4 << 25) | (1 << 20);
        o1 |= p->to.offset & 0xffff;
        o1 |= p->from.reg << 16;
        aclass(&p->from);
    movm:
        if(instoffset != 0)
            diag("offset must be zero in MOVM");
        o1 |= (p->scond & C_SCOND) << 28;
        if(p->scond & C_PBIT)
            o1 |= 1 << 24;
        if(p->scond & C_UBIT)
            o1 |= 1 << 23;
        if(p->scond & C_SBIT)
            o1 |= 1 << 22;
        if(p->scond & C_WBIT)
            o1 |= 1 << 21;
        break;

    case 40:	/* swp oreg,reg,reg */
        aclass(&p->from);
        if(instoffset != 0)
            diag("offset must be zero in SWP");
        o1 = (0x2<<23) | (0x9<<4);
        if(p->as != ASWPW)
            o1 |= 1 << 22;
        o1 |= p->from.reg << 16;
        o1 |= p->reg << 0;
        o1 |= p->to.reg << 12;
        o1 |= (p->scond & C_SCOND) << 28;
        break;

    case 41:	/* rfe -> movm.s.w.u 0(r13),[r15] */
        o1 = 0xe8fd8000;
        break;

    case 50:	/* floating point store */
        v = regoff(&p->to);
        r = p->to.reg;
        if(r == NREG)
            r = o->param;
        o1 = ofsr(p->as, p->from.reg, v, r, p->scond, p);
        break;

    case 51:	/* floating point load */
        v = regoff(&p->from);
        r = p->from.reg;
        if(r == NREG)
            r = o->param;
        o1 = ofsr(p->as, p->to.reg, v, r, p->scond, p) | (1<<20);
        break;

    case 52:	/* floating point store, long offset UGLY */
        o1 = omvl(p, &p->to, REGTMP);
        if(!o1)
            break;
        r = p->to.reg;
        if(r == NREG)
            r = o->param;
        o2 = oprrr(AADD, p->scond) | (REGTMP << 12) | (REGTMP << 16) | r;
        o3 = ofsr(p->as, p->from.reg, 0, REGTMP, p->scond, p);
        break;

    case 53:	/* floating point load, long offset UGLY */
        o1 = omvl(p, &p->from, REGTMP);
        if(!o1)
            break;
        r = p->from.reg;
        if(r == NREG)
            r = o->param;
        o2 = oprrr(AADD, p->scond) | (REGTMP << 12) | (REGTMP << 16) | r;
        o3 = ofsr(p->as, p->to.reg, 0, REGTMP, p->scond, p) | (1<<20);
        break;

    case 54:	/* floating point arith */
        o1 = oprrr(p->as, p->scond);
        if(p->from.type == D_FCONST) {
            rf = chipfloat(p->from.ieee);
            if(rf < 0){
                diag("invalid floating-point immediate\n%P", p);
                rf = 0;
            }
            rf |= (1<<3);
        } else
            rf = p->from.reg;
        rt = p->to.reg;
        r = p->reg;
        if(p->to.type == D_NONE)
            rt = 0;	/* CMP[FD] */
        else if(o1 & (1<<15))
            r = 0;	/* monadic */
        else if(r == NREG)
            r = rt;
        o1 |= rf | (r<<16) | (rt<<12);
        break;

    case 55:	/* floating point fix and float */
        o1 = oprrr(p->as, p->scond);
        rf = p->from.reg;
        rt = p->to.reg;
        if(p->to.type == D_NONE){
            rt = 0;
            diag("to.type==D_NONE (asm/fp)");
        }
        if(p->from.type == D_REG)
            o1 |= (rf<<12) | (rt<<16);
        else
            o1 |= rf | (rt<<12);
        break;

    /* old arm 7500 fp using coproc 1 (1<<8) */
    case 56:	/* move to FP[CS]R */
        o1 = ((p->scond & C_SCOND) << 28) | (0xe << 24) | (1<<8) | (1<<4);
        o1 |= ((p->to.reg+1)<<21) | (p->from.reg << 12);
        break;

    case 57:	/* move from FP[CS]R */
        o1 = ((p->scond & C_SCOND) << 28) | (0xe << 24) | (1<<8) | (1<<4);
        o1 |= ((p->from.reg+1)<<21) | (p->to.reg<<12) | (1<<20);
        break;
    case 58:	/* movbu R,R */
        o1 = oprrr(AAND, p->scond);
        o1 |= immrot(0xff);
        rt = p->to.reg;
        r = p->from.reg;
        if(p->to.type == D_NONE)
            rt = 0;
        if(r == NREG)
            r = rt;
        o1 |= (r<<16) | (rt<<12);
        break;

    case 59:	/* movw/bu R<<I(R),R -> ldr indexed */
        if(p->from.reg == NREG) {
            if(p->as != AMOVW)
                diag("byte MOV from shifter operand");
            goto mov;
        }
        if(p->from.offset&(1<<4))
            diag("bad shift in LDR");
        o1 = olrr(p->from.offset, p->from.reg, p->to.reg, p->scond);
        if(p->as == AMOVBU)
            o1 |= 1<<22;
        break;

    case 60:	/* movb R(R),R -> ldrsb indexed */
        if(p->from.reg == NREG) {
            diag("byte MOV from shifter operand");
            goto mov;
        }
        if(p->from.offset&(~0xf))
            diag("bad shift in LDRSB");
        o1 = olhrr(p->from.offset, p->from.reg, p->to.reg, p->scond);
        o1 ^= (1<<5)|(1<<6);
        break;

    case 61:	/* movw/b/bu R,R<<[IR](R) -> str indexed */
        if(p->to.reg == NREG)
            diag("MOV to shifter operand");
        o1 = osrr(p->from.reg, p->to.offset, p->to.reg, p->scond);
        if(p->as == AMOVB || p->as == AMOVBU)
            o1 |= 1<<22;
        break;

    case 62:	/* case R -> movw	R<<2(PC),PC */
        o1 = olrr(p->from.reg, REGPC, REGPC, p->scond);
        o1 |= 2<<7;
        break;

    case 63:	/* bcase */
        if(p->cond != P) {
            o1 = p->cond->pc;
            if(dlm)
                dynreloc(S, p->pc, 1);
        }
        break;

    /* reloc ops */
    case 64:	/* mov/movb/movbu R,addr */
        o1 = omvl(p, &p->to, REGTMP);
        if(!o1)
            break;
        o2 = osr(p->as, p->from.reg, 0, REGTMP, p->scond);
        break;

    case 65:	/* mov/movbu addr,R */
    case 66:	/* movh/movhu/movb addr,R */
        o1 = omvl(p, &p->from, REGTMP);
        if(!o1)
            break;
        o2 = olr(0, REGTMP, p->to.reg, p->scond);
        if(p->as == AMOVBU || p->as == AMOVB)
            o2 |= 1<<22;
        if(o->type == 65)
            break;

        o3 = oprrr(ASLL, p->scond);

        if(p->as == AMOVBU || p->as == AMOVHU)
            o4 = oprrr(ASRL, p->scond);
        else
            o4 = oprrr(ASRA, p->scond);

        r = p->to.reg;
        o3 |= (r)|(r<<12);
        o4 |= (r)|(r<<12);
        if(p->as == AMOVB || p->as == AMOVBU) {
            o3 |= (24<<7);
            o4 |= (24<<7);
        } else {
            o3 |= (16<<7);
            o4 |= (16<<7);
        }
        break;

    case 67:	/* movh/movhu R,addr -> sb, sb */
        o1 = omvl(p, &p->to, REGTMP);
        if(!o1)
            break;
        o2 = osr(p->as, p->from.reg, 0, REGTMP, p->scond);

        o3 = oprrr(ASRL, p->scond);
        o3 |= (8<<7)|(p->from.reg)|(p->from.reg<<12);
        o3 |= (1<<6);	/* ROR 8 */

        o4 = oprrr(AADD, p->scond);
        o4 |= (REGTMP << 12) | (REGTMP << 16);
        o4 |= immrot(1);

        o5 = osr(p->as, p->from.reg, 0, REGTMP, p->scond);

        o6 = oprrr(ASRL, p->scond);
        o6 |= (24<<7)|(p->from.reg)|(p->from.reg<<12);
        o6 |= (1<<6);	/* ROL 8 */
        break;

    case 68:	/* floating point store -> ADDR */
        o1 = omvl(p, &p->to, REGTMP);
        if(!o1)
            break;
        o2 = ofsr(p->as, p->from.reg, 0, REGTMP, p->scond, p);
        break;

    case 69:	/* floating point load <- ADDR */
        o1 = omvl(p, &p->from, REGTMP);
        if(!o1)
            break;
        o2 = ofsr(p->as, p->to.reg, 0, REGTMP, p->scond, p) | (1<<20);
        break;

    /* ArmV4 ops: */
    case 70:	/* movh/movhu R,O(R) -> strh */
        aclass(&p->to);
        r = p->to.reg;
        if(r == NREG)
            r = o->param;
        o1 = oshr(p->from.reg, instoffset, r, p->scond);
        break;	
    case 71:	/* movb/movh/movhu O(R),R -> ldrsb/ldrsh/ldrh */
        aclass(&p->from);
        r = p->from.reg;
        if(r == NREG)
            r = o->param;
        o1 = olhr(instoffset, r, p->to.reg, p->scond);
        if(p->as == AMOVB)
            o1 ^= (1<<5)|(1<<6);
        else if(p->as == AMOVH)
            o1 ^= (1<<6);
        break;
    case 72:	/* movh/movhu R,L(R) -> strh */
        o1 = omvl(p, &p->to, REGTMP);
        if(!o1)
            break;
        r = p->to.reg;
        if(r == NREG)
            r = o->param;
        o2 = oshrr(p->from.reg, REGTMP,r, p->scond);
        break;	
    case 73:	/* movb/movh/movhu L(R),R -> ldrsb/ldrsh/ldrh */
        o1 = omvl(p, &p->from, REGTMP);
        if(!o1)
            break;
        r = p->from.reg;
        if(r == NREG)
            r = o->param;
        o2 = olhrr(REGTMP, r, p->to.reg, p->scond);
        if(p->as == AMOVB)
            o2 ^= (1<<5)|(1<<6);
        else if(p->as == AMOVH)
            o2 ^= (1<<6);
        break;

    /* VFP ops: */
    case 74:	/* vfp floating point arith */
        o1 = opvfprrr(p->as, p->scond);
        rf = p->from.reg;
        if(p->from.type == D_FCONST) {
            diag("invalid floating-point immediate\n%P", p);
            rf = 0;
        }
        rt = p->to.reg;
        r = p->reg;
        if(r == NREG)
            r = rt;
        o1 |= rt<<12;
        if(((o1>>20)&0xf) == 0xb)
            o1 |= rf<<0;
        else
            o1 |= r<<16 | rf<<0;
        break;
    case 75:	/* vfp floating point compare */
        o1 = opvfprrr(p->as, p->scond);
        rf = p->from.reg;
        if(p->from.type == D_FCONST) {
            if(p->from.ieee->h != 0 || p->from.ieee->l != 0)
                diag("invalid floating-point immediate\n%P", p);
            o1 |= 1<<16;
            rf = 0;
        }
        rt = p->reg;
        o1 |= rt<<12 | rf<<0;
        o2 = 0x0ef1fa10;	/* MRS APSR_nzcv, FPSCR */
        o2 |= (p->scond & C_SCOND) << 28;
        break;
    case 76:	/* vfp floating point fix and float */
        o1 = opvfprrr(p->as, p->scond);
        rf = p->from.reg;
        rt = p->to.reg;
        if(p->from.type == D_REG) {
            o2 = o1 | rt<<12 | rt<<0;
            o1 = 0x0e000a10;	/* VMOV F,R */
            o1 |= (p->scond & C_SCOND) << 28 | rt<<16 | rf<<12;
        } else {
            o1 |= FREGTMP<<12 | rf<<0;
            o2 = 0x0e100a10;	/* VMOV R,F */
            o2 |= (p->scond & C_SCOND) << 28 | FREGTMP<<16 | rt<<12;
        }
        break;
    }

    if(debug['a'] > 1)
        Bprint(&bso, "%2d ", o->type);

    v = p->pc;
    switch(o->size) {
    default:
        if(debug['a'])
            Bprint(&bso, " %.8lux:\t\t%P\n", v, p);
        break;
    case 4:
        if(debug['a'])
            Bprint(&bso, " %.8lux: %.8lux\t%P\n", v, o1, p);
        lputl(o1);
        break;
    case 8:
        if(debug['a'])
            Bprint(&bso, " %.8lux: %.8lux %.8lux%P\n", v, o1, o2, p);
        lputl(o1);
        lputl(o2);
        break;
    case 12:
        if(debug['a'])
            Bprint(&bso, " %.8lux: %.8lux %.8lux %.8lux%P\n", v, o1, o2, o3, p);
        lputl(o1);
        lputl(o2);
        lputl(o3);
        break;
    case 16:
        if(debug['a'])
            Bprint(&bso, " %.8lux: %.8lux %.8lux %.8lux %.8lux%P\n",
                v, o1, o2, o3, o4, p);
        lputl(o1);
        lputl(o2);
        lputl(o3);
        lputl(o4);
        break;
    case 20:
        if(debug['a'])
            Bprint(&bso, " %.8lux: %.8lux %.8lux %.8lux %.8lux %.8lux%P\n",
                v, o1, o2, o3, o4, o5, p);
        lputl(o1);
        lputl(o2);
        lputl(o3);
        lputl(o4);
        lputl(o5);
        break;
    case 24:
        if(debug['a'])
            Bprint(&bso, " %.8lux: %.8lux %.8lux %.8lux %.8lux %.8lux %.8lux%P\n",
                v, o1, o2, o3, o4, o5, o6, p);
        lputl(o1);
        lputl(o2);
        lputl(o3);
        lputl(o4);
        lputl(o5);
        lputl(o6);
        break;
    }
}
@
%$

<<function regoff(arm)>>=
long
regoff(Adr *a)
{

    instoffset = 0;
    aclass(a);
    return instoffset;
}
@


<<function immrot(arm)>>=
long
immrot(ulong v)
{
    int i;

    for(i=0; i<16; i++) {
        if((v & ~0xff) == 0)
            return (i<<8) | v | (1<<25);
        v = (v<<2) | (v>>30);
    }
    return 0;
}
@

<<function immaddr(arm)>>=
long
immaddr(long v)
{
    if(v >= 0 && v <= 0xfff)
        return (v & 0xfff) |
            (1<<24) |	/* pre indexing */
            (1<<23);	/* pre indexing, up */
    if(v >= -0xfff && v < 0)
        return (-v & 0xfff) |
            (1<<24);	/* pre indexing */
    return 0;
}
@

<<function immfloat(arm)>>=
int
immfloat(long v)
{
    return (v & 0xC03) == 0;	/* offset will fit in floating-point load/store */
}
@

<<function immhalf(arm)>>=
int
immhalf(long v)
{
    if(v >= 0 && v <= 0xff)
        return v|
            (1<<24)|	/* pre indexing */
            (1<<23);	/* pre indexing, up */
    if(v >= -0xff && v < 0)
        return (-v & 0xff)|
            (1<<24);	/* pre indexing */
    return 0;
}
@




<<function oprrr(arm)>>=
long
oprrr(int a, int sc)
{
    long o;

    o = (sc & C_SCOND) << 28;
    if(sc & C_SBIT)
        o |= 1 << 20;
    if(sc & (C_PBIT|C_WBIT))
        diag(".P/.W on dp instruction");

    switch(a) {
    case AMULU:
    case AMUL:	return o | (0x0<<21) | (0x9<<4);
    case AMULA:	return o | (0x1<<21) | (0x9<<4);
    case AMULLU:	return o | (0x4<<21) | (0x9<<4);
    case AMULL:		return o | (0x6<<21) | (0x9<<4);
    case AMULALU:	return o | (0x5<<21) | (0x9<<4);
    case AMULAL:	return o | (0x7<<21) | (0x9<<4);

    case AAND:	return o | (0x0<<21);
    case AEOR:	return o | (0x1<<21);
    case ASUB:	return o | (0x2<<21);
    case ARSB:	return o | (0x3<<21);
    case AADD:	return o | (0x4<<21);
    case AADC:	return o | (0x5<<21);
    case ASBC:	return o | (0x6<<21);
    case ARSC:	return o | (0x7<<21);
    case ATST:	return o | (0x8<<21) | (1<<20);
    case ATEQ:	return o | (0x9<<21) | (1<<20);
    case ACMP:	return o | (0xa<<21) | (1<<20);
    case ACMN:	return o | (0xb<<21) | (1<<20);
    case AORR:	return o | (0xc<<21);
    case AMOVW:	return o | (0xd<<21);
    case ABIC:	return o | (0xe<<21);
    case AMVN:	return o | (0xf<<21);

    case ASLL:	return o | (0xd<<21) | (0<<5);
    case ASRL:	return o | (0xd<<21) | (1<<5);
    case ASRA:	return o | (0xd<<21) | (2<<5);

    case ASWI:	return o | (0xf<<24);

    /* old arm 7500 fp using coproc 1 (1<<8) */
    case AADDD:	return o | (0xe<<24) | (0x0<<20) | (1<<8) | (1<<7);
    case AADDF:	return o | (0xe<<24) | (0x0<<20) | (1<<8);
    case AMULD:	return o | (0xe<<24) | (0x1<<20) | (1<<8) | (1<<7);
    case AMULF:	return o | (0xe<<24) | (0x1<<20) | (1<<8);
    case ASUBD:	return o | (0xe<<24) | (0x2<<20) | (1<<8) | (1<<7);
    case ASUBF:	return o | (0xe<<24) | (0x2<<20) | (1<<8);
    case ADIVD:	return o | (0xe<<24) | (0x4<<20) | (1<<8) | (1<<7);
    case ADIVF:	return o | (0xe<<24) | (0x4<<20) | (1<<8);
    case ACMPD:
    case ACMPF:	return o | (0xe<<24) | (0x9<<20) | (0xF<<12) | (1<<8) | (1<<4);	/* arguably, ACMPF should expand to RNDF, CMPD */

    case AMOVF:
    case AMOVDF:	return o | (0xe<<24) | (0x0<<20) | (1<<15) | (1<<8);
    case AMOVD:
    case AMOVFD:	return o | (0xe<<24) | (0x0<<20) | (1<<15) | (1<<8) | (1<<7);

    case AMOVWF:	return o | (0xe<<24) | (0<<20) | (1<<8) | (1<<4);
    case AMOVWD:	return o | (0xe<<24) | (0<<20) | (1<<8) | (1<<4) | (1<<7);
    case AMOVFW:	return o | (0xe<<24) | (1<<20) | (1<<8) | (1<<4);
    case AMOVDW:	return o | (0xe<<24) | (1<<20) | (1<<8) | (1<<4) | (1<<7);
    }
    diag("bad rrr %d", a);
    prasm(curp);
    return 0;
}
@

<<function opvfprrr(arm)>>=
long
opvfprrr(int a, int sc)
{
    long o;

    o = (sc & C_SCOND) << 28;
    if(sc & (C_SBIT|C_PBIT|C_WBIT))
        diag(".S/.P/.W on vfp instruction");
    o |= 0xe<<24;
    switch(a) {
    case AMOVWD:	return o | 0xb<<8 | 0xb<<20 | 1<<6 | 0x8<<16 | 1<<7;
    case AMOVWF:	return o | 0xa<<8 | 0xb<<20 | 1<<6 | 0x8<<16 | 1<<7;
    case AMOVDW:	return o | 0xb<<8 | 0xb<<20 | 1<<6 | 0xD<<16 | 1<<7;
    case AMOVFW:	return o | 0xa<<8 | 0xb<<20 | 1<<6 | 0xD<<16 | 1<<7;
    case AMOVFD:	return o | 0xa<<8 | 0xb<<20 | 1<<6 | 0x7<<16 | 1<<7;
    case AMOVDF:	return o | 0xb<<8 | 0xb<<20 | 1<<6 | 0x7<<16 | 1<<7;
    case AMOVF:	return o | 0xa<<8 | 0xb<<20 | 1<<6 | 0x0<<16 | 0<<7;
    case AMOVD:	return o | 0xb<<8 | 0xb<<20 | 1<<6 | 0x0<<16 | 0<<7;
    case ACMPF:	return o | 0xa<<8 | 0xb<<20 | 1<<6 | 0x4<<16 | 0<<7;
    case ACMPD:	return o | 0xb<<8 | 0xb<<20 | 1<<6 | 0x4<<16 | 0<<7;
    case AADDF:	return o | 0xa<<8 | 0x3<<20;
    case AADDD:	return o | 0xb<<8 | 0x3<<20;
    case ASUBF:	return o | 0xa<<8 | 0x3<<20 | 1<<6;
    case ASUBD:	return o | 0xb<<8 | 0x3<<20 | 1<<6;
    case AMULF:	return o | 0xa<<8 | 0x2<<20;
    case AMULD:	return o | 0xb<<8 | 0x2<<20;
    case ADIVF:	return o | 0xa<<8 | 0x8<<20;
    case ADIVD:	return o | 0xb<<8 | 0x8<<20;
    }
    diag("bad vfp rrr %d", a);
    prasm(curp);
    return 0;
}
@

<<function opbra(arm)>>=
long
opbra(int a, int sc)
{

    if(sc & (C_SBIT|C_PBIT|C_WBIT))
        diag(".S/.P/.W on bra instruction");
    sc &= C_SCOND;
    if(a == ABL)
        return (sc<<28)|(0x5<<25)|(0x1<<24);
    if(sc != 0xe)
        diag(".COND on bcond instruction");
    switch(a) {
    case ABEQ:	return (0x0<<28)|(0x5<<25);
    case ABNE:	return (0x1<<28)|(0x5<<25);
    case ABCS:	return (0x2<<28)|(0x5<<25);
    case ABHS:	return (0x2<<28)|(0x5<<25);
    case ABCC:	return (0x3<<28)|(0x5<<25);
    case ABLO:	return (0x3<<28)|(0x5<<25);
    case ABMI:	return (0x4<<28)|(0x5<<25);
    case ABPL:	return (0x5<<28)|(0x5<<25);
    case ABVS:	return (0x6<<28)|(0x5<<25);
    case ABVC:	return (0x7<<28)|(0x5<<25);
    case ABHI:	return (0x8<<28)|(0x5<<25);
    case ABLS:	return (0x9<<28)|(0x5<<25);
    case ABGE:	return (0xa<<28)|(0x5<<25);
    case ABLT:	return (0xb<<28)|(0x5<<25);
    case ABGT:	return (0xc<<28)|(0x5<<25);
    case ABLE:	return (0xd<<28)|(0x5<<25);
    case AB:	return (0xe<<28)|(0x5<<25);
    }
    diag("bad bra %A", a);
    prasm(curp);
    return 0;
}
@
% 

<<function olr(arm)>>=
long
olr(long v, int b, int r, int sc)
{
    long o;

    if(sc & C_SBIT)
        diag(".S on LDR/STR instruction");
    o = (sc & C_SCOND) << 28;
    if(!(sc & C_PBIT))
        o |= 1 << 24;
    if(!(sc & C_UBIT))
        o |= 1 << 23;
    if(sc & C_WBIT)
        o |= 1 << 21;
    o |= (0x1<<26) | (1<<20);
    if(v < 0) {
        v = -v;
        o ^= 1 << 23;
    }
    if(v >= (1<<12))
        diag("literal span too large: %ld (R%d)\n%P", v, b, PP);
    o |= v;
    o |= b << 16;
    o |= r << 12;
    return o;
}
@
% >> >> >> >> >> >> >> >> >> >>

<<function olhr(arm)>>=
long
olhr(long v, int b, int r, int sc)
{
    long o;

    if(sc & C_SBIT)
        diag(".S on LDRH/STRH instruction");
    o = (sc & C_SCOND) << 28;
    if(!(sc & C_PBIT))
        o |= 1 << 24;
    if(sc & C_WBIT)
        o |= 1 << 21;
    o |= (1<<23) | (1<<20)|(0xb<<4);
    if(v < 0) {
        v = -v;
        o ^= 1 << 23;
    }
    if(v >= (1<<8))
        diag("literal span too large: %ld (R%d)\n%P", v, b, PP);
    o |= (v&0xf)|((v>>4)<<8)|(1<<22);
    o |= b << 16;
    o |= r << 12;
    return o;
}
@
% >> >> >> >> >> >> >> >> >> >>

<<function osr(arm)>>=
long
osr(int a, int r, long v, int b, int sc)
{
    long o;

    o = olr(v, b, r, sc) ^ (1<<20);
    if(a != AMOVW)
        o |= 1<<22;
    return o;
}
@

<<function oshr(arm)>>=
long
oshr(int r, long v, int b, int sc)
{
    long o;

    o = olhr(v, b, r, sc) ^ (1<<20);
    return o;
}
@
% >>
<<function osrr(arm)>>=
long
osrr(int r, int i, int b, int sc)
{

    return olr(i, b, r, sc) ^ ((1<<25) | (1<<20));
}
@
% >> >>

<<function oshrr(arm)>>=
long
oshrr(int r, int i, int b, int sc)
{
    return olhr(i, b, r, sc) ^ ((1<<22) | (1<<20));
}
@
% >> >>

<<function olrr(arm)>>=
long
olrr(int i, int b, int r, int sc)
{

    return olr(i, b, r, sc) ^ (1<<25);
}
@
% >>

<<function olhrr(arm)>>=
long
olhrr(int i, int b, int r, int sc)
{
    return olhr(i, b, r, sc) ^ (1<<22);
}
@
% >>

<<function ovfpmem(arm)>>=
long
ovfpmem(int a, int r, long v, int b, int sc, Prog *p)
{
    long o;

    if(sc & (C_SBIT|C_PBIT|C_WBIT))
        diag(".S/.P/.W on VLDR/VSTR instruction");
    o = (sc & C_SCOND) << 28;
    o |= 0xd<<24 | (1<<23);
    if(v < 0) {
        v = -v;
        o ^= 1 << 23;
    }
    if(v & 3)
        diag("odd offset for floating point op: %ld\n%P", v, p);
    else if(v >= (1<<10))
        diag("literal span too large: %ld\n%P", v, p);
    o |= (v>>2) & 0xFF;
    o |= b << 16;
    o |= r << 12;
    switch(a) {
    default:
        diag("bad fst %A", a);
    case AMOVD:
        o |= 0xb<<8;
        break;
    case AMOVF:
        o |= 0xa<<8;
        break;
    }
    return o;
}
@
% >> >> >> >> >> >> >> >> 

<<function ofsr(arm)>>=
long
ofsr(int a, int r, long v, int b, int sc, Prog *p)
{
    long o;

    if(vfp)
        return ovfpmem(a, r, v, b, sc, p);
    if(sc & C_SBIT)
        diag(".S on FLDR/FSTR instruction");
    o = (sc & C_SCOND) << 28;
    if(!(sc & C_PBIT))
        o |= 1 << 24;
    if(sc & C_WBIT)
        o |= 1 << 21;
    o |= (6<<25) | (1<<24) | (1<<23);
    if(v < 0) {
        v = -v;
        o ^= 1 << 23;
    }
    if(v & 3)
        diag("odd offset for floating point op: %ld\n%P", v, p);
    else if(v >= (1<<10))
        diag("literal span too large: %ld\n%P", v, p);
    o |= (v>>2) & 0xFF;
    o |= b << 16;
    o |= r << 12;
    o |= 1 << 8;

    switch(a) {
    default:
        diag("bad fst %A", a);
    case AMOVD:
        o |= 1<<15;
    case AMOVF:
        break;
    }
    return o;
}
@
% >> >> >> >> >> >> >> >> >> >> >>

<<function omvl(arm)>>=
long
omvl(Prog *p, Adr *a, int dr)
{	
    long v, o1;
    if(!p->cond) {
        aclass(a);
        v = immrot(~instoffset);
        if(v == 0) {
            diag("missing literal");
            prasm(p);
            return 0;
        }
        o1 = oprrr(AMVN, p->scond&C_SCOND);
        o1 |= v;
        o1 |= dr << 12;
    } else {
        v = p->cond->pc - p->pc - 8;
        o1 = olr(v, REGPC, dr, p->scond&C_SCOND);
    }
    return o1;
}
@
% >> >> >>

<<global chipfloats(arm)>>=
static Ieee chipfloats[] = {
    {0x00000000, 0x00000000}, /* 0 */
    {0x00000000, 0x3ff00000}, /* 1 */
    {0x00000000, 0x40000000}, /* 2 */
    {0x00000000, 0x40080000}, /* 3 */
    {0x00000000, 0x40100000}, /* 4 */
    {0x00000000, 0x40140000}, /* 5 */
    {0x00000000, 0x3fe00000}, /* .5 */
    {0x00000000, 0x40240000}, /* 10 */
};
@

<<function chipfloat(arm)>>=
int
chipfloat(Ieee *e)
{
    Ieee *p;
    int n;

    if(vfp)
        return -1;
    for(n = sizeof(chipfloats)/sizeof(chipfloats[0]); --n >= 0;){
        p = &chipfloats[n];
        if(p->l == e->l && p->h == e->h)
            return n;
    }
    return -1;
}
@



\section{Checking for unresolved symbols, [[undef()]]}

% rename check_if_still_undefined_symbols()?
<<function undef>>=
void
undef(void)
{
    int i;
    Sym *s;

    for(i=0; i<NHASH; i++)
        for(s = hash[i]; s != S; s = s->link)
            if(s->type == SXREF)
                diag("%s: not defined", s->name);
}
@

% >>






\chapter{Loading Objects}
% was called parsing, but binary format so loading is more appropriate I think

% essentially reverse operation than object generation in Assembler.nw?
% hmmm if C had proper ADT and Marshall module that would be easier ...
% (but maybe less other-languages friendly)
% could factorize code with libmach?

% why not using 8obj.c from libmach/? because 8obj.c is incomplete?
% car just about symbol table?

% each ldobj will add to this pc
<<global pc>>=
long	pc = 0;
@




% This is for the D_STATIC; to handle conflicts with different files
% defining the same static entity. This is bumped each time
% a new object file is parsed, so it's safe.
<<global version>>=
int	version = 0;
@



<<[[ldobj()]] locals(x86)>>=
// enum<as>, the opcode
int o;
Prog *p;
@

% ???
<<[[ldobj()]] locals(x86)>>=
Sym *h[NSYM];
Sym *di;
Sym *s;
long ipc;
bool skip;
@

%???
<<[[ldobj()]] locals(x86)>>=
Prog *t;
byte *stop;
int v;
ulong sig;
@




<<[[ldobj()]] locals(x86)>>=
byte *bloc;
byte *bsize;
int r;
@
% and parameter 'int c'

<<[[ldobj()]] bloc and bsize init(x86)>>=
bsize = buf.xbuf;
bloc = buf.xbuf;
@

<<[[ldobj()]] read if needed in loop:, adjust block and bsize(x86)>>=
r = bsize - bloc;
if(r < 100 && r < c) {		/* enough for largest prog */
    bsize = readsome(f, buf.xbuf, bloc, bsize, c);
    if(bsize == 0)
        goto eof;
    bloc = buf.xbuf;
    goto loop;
}
@
% >> >> >> >>

\section{[[ldobj()]]}

% main() -> objfile() -> ldbobj()
% c = size of .8, pn = filename, f = fd of opened object file
<<function ldobj(x86)>>=
void
ldobj(fdt f, long c, char *pn)
{
    <<[[ldobj()]] locals(x86)>>

    <<[[ldobj()]] grow filen if not enough space(x86)>>
    filen[files++] = strdup(pn);

    <<[[ldobj()]] bloc and bsize init(x86)>>

    di = S;

// can come from AEND
newloop:
    version++;
    memset(h, 0, sizeof(h));
    histfrogp = 0;
    ipc = pc;
    skip = false;

loop:
    if(c <= 0)
        goto eof;

    <<[[ldobj()]] read if needed in loop:, adjust block and bsize(x86)>>

    // get the opcode
    o = bloc[0] | (bloc[1] << 8); // >>

    <<[[ldobj()]] sanity check opcode in range(x86)>>

    <<[[ldobj()]] if ANAME or ASIGNAME(x86)>>

    //TODO: factorize
    while(nhunk < sizeof(Prog))
        gethunk();
    p = (Prog*)hunk;
    nhunk -= sizeof(Prog);
    hunk += sizeof(Prog);

    p->as = o;
    p->line = bloc[2] | (bloc[3] << 8) | (bloc[4] << 16) | (bloc[5] << 24);
    p->back = 2;
    // >> >> >>

    r = zaddr(bloc+6, &p->from, h) + 6;
    r += zaddr(bloc+r, &p->to, h);

    bloc += r;
    c -= r;

    if(debug['W'])
        print("%P\n", p);

    switch(p->as) {
    <<[[ldobj()]] switch as cases(x86)>>

    default:
    casdef:
        if(skip)
            nopout(p);

        if(p->to.type == D_BRANCH)
            p->to.offset += ipc;

        lastp->link = p;
        lastp = p;

        p->pc = pc;
        pc++;
    }
    goto loop;

eof:
    diag("truncated object file: %s", pn);
}
@

% >> >> >> >>


<<function ldobj(arm)>>=
void
ldobj(int f, long c, char *pn)
{
    long ipc;
    Prog *p, *t;
    uchar *bloc, *bsize, *stop;
    Sym *h[NSYM], *s, *di;
    int v, o, r, skip;
    ulong sig;
    static int files;
    static char **filen;
    char **nfilen;

    if((files&15) == 0){
        nfilen = malloc((files+16)*sizeof(char*));
        memmove(nfilen, filen, files*sizeof(char*));
        free(filen);
        filen = nfilen;
    }
    filen[files++] = strdup(pn);

    bsize = buf.xbuf;
    bloc = buf.xbuf;
    di = S;

newloop:
    memset(h, 0, sizeof(h));
    version++;
    histfrogp = 0;
    ipc = pc;
    skip = 0;

loop:
    if(c <= 0)
        goto eof;
    r = bsize - bloc;
    if(r < 100 && r < c) {		/* enough for largest prog */
        bsize = readsome(f, buf.xbuf, bloc, bsize, c);
        if(bsize == 0)
            goto eof;
        bloc = buf.xbuf;
        goto loop;
    }
    o = bloc[0];		/* as */
    if(o <= AXXX || o >= ALAST) {
        diag("%s: line %ld: opcode out of range %d", pn, pc-ipc, o);
        print("	probably not a .5 file\n");
        errorexit();
    }
    if(o == ANAME || o == ASIGNAME) {
        sig = 0;
        if(o == ASIGNAME){
            sig = bloc[1] | (bloc[2]<<8) | (bloc[3]<<16) | (bloc[4]<<24);
            bloc += 4;
            c -= 4;
        }
        stop = memchr(&bloc[3], 0, bsize-&bloc[3]);
        if(stop == 0){
            bsize = readsome(f, buf.xbuf, bloc, bsize, c);
            if(bsize == 0)
                goto eof;
            bloc = buf.xbuf;
            stop = memchr(&bloc[3], 0, bsize-&bloc[3]);
            if(stop == 0){
                fprint(2, "%s: name too long\n", pn);
                errorexit();
            }
        }
        v = bloc[1];	/* type */
        o = bloc[2];	/* sym */
        bloc += 3;
        c -= 3;

        r = 0;
        if(v == D_STATIC)
            r = version;
        s = lookup((char*)bloc, r);
        c -= &stop[1] - bloc;
        bloc = stop + 1;

        if(sig != 0){
            if(s->sig != 0 && s->sig != sig)
                diag("incompatible type signatures %lux(%s) and %lux(%s) for %s", s->sig, filen[s->file], sig, pn, s->name);
            s->sig = sig;
            s->file = files-1;
        }

        if(debug['W'])
            print("	ANAME	%s\n", s->name);
        h[o] = s;
        if((v == D_EXTERN || v == D_STATIC) && s->type == 0)
            s->type = SXREF;
        if(v == D_FILE) {
            if(s->type != SFILE) {
                histgen++;
                s->type = SFILE;
                s->value = histgen;
            }
            if(histfrogp < MAXHIST) {
                histfrog[histfrogp] = s;
                histfrogp++;
            } else
                collapsefrog(s);
        }
        goto loop;
    }

    if(nhunk < sizeof(Prog))
        gethunk();
    p = (Prog*)hunk;
    nhunk -= sizeof(Prog);
    hunk += sizeof(Prog);

    p->as = o;
    p->scond = bloc[1];
    p->reg = bloc[2];
    p->line = bloc[3] | (bloc[4]<<8) | (bloc[5]<<16) | (bloc[6]<<24);

    r = zaddr(bloc+7, &p->from, h) + 7;
    r += zaddr(bloc+r, &p->to, h);
    bloc += r;
    c -= r;

    if(p->reg > NREG)
        diag("register out of range %d", p->reg);

    p->link = P;
    p->cond = P;

    if(debug['W'])
        print("%P\n", p);

    switch(o) {
    case AHISTORY:
        if(p->to.offset == -1) {
            addlib(pn);
            histfrogp = 0;
            goto loop;
        }
        addhist(p->line, D_FILE);		/* 'z' */
        if(p->to.offset)
            addhist(p->to.offset, D_FILE1);	/* 'Z' */
        histfrogp = 0;
        goto loop;

    case AEND:
        histtoauto();
        if(curtext != P)
            curtext->to.autom = curauto;
        curauto = 0;
        curtext = P;
        if(c)
            goto newloop;
        return;

    case AGLOBL:
        s = p->from.sym;
        if(s == S) {
            diag("GLOBL must have a name\n%P", p);
            errorexit();
        }
        if(s->type == 0 || s->type == SXREF) {
            s->type = SBSS;
            s->value = 0;
        }
        if(s->type != SBSS) {
            diag("redefinition: %s\n%P", s->name, p);
            s->type = SBSS;
            s->value = 0;
        }
        if(p->to.offset > s->value)
            s->value = p->to.offset;
        break;

    case ADYNT:
        if(p->to.sym == S) {
            diag("DYNT without a sym\n%P", p);
            break;
        }
        di = p->to.sym;
        p->reg = 4;
        if(di->type == SXREF) {
            if(debug['z'])
                Bprint(&bso, "%P set to %d\n", p, dtype);
            di->type = SCONST;
            di->value = dtype;
            dtype += 4;
        }
        if(p->from.sym == S)
            break;

        p->from.offset = di->value;
        p->from.sym->type = SDATA;
        if(curtext == P) {
            diag("DYNT not in text: %P", p);
            break;
        }
        p->to.sym = curtext->from.sym;
        p->to.type = D_CONST;
        p->link = datap;
        datap = p;
        break;

    case AINIT:
        if(p->from.sym == S) {
            diag("INIT without a sym\n%P", p);
            break;
        }
        if(di == S) {
            diag("INIT without previous DYNT\n%P", p);
            break;
        }
        p->from.offset = di->value;
        p->from.sym->type = SDATA;
        p->link = datap;
        datap = p;
        break;
    
    case ADATA:
        if(p->from.sym == S) {
            diag("DATA without a sym\n%P", p);
            break;
        }
        p->link = datap;
        datap = p;
        break;

    case AGOK:
        diag("unknown opcode\n%P", p);
        p->pc = pc;
        pc++;
        break;

    case ATEXT:
        if(curtext != P) {
            histtoauto();
            curtext->to.autom = curauto;
            curauto = 0;
        }
        skip = 0;
        curtext = p;
        autosize = (p->to.offset+3L) & ~3L;
        p->to.offset = autosize;
        autosize += 4;
        s = p->from.sym;
        if(s == S) {
            diag("TEXT must have a name\n%P", p);
            errorexit();
        }
        if(s->type != 0 && s->type != SXREF) {
            if(p->reg & DUPOK) {
                skip = 1;
                goto casedef;
            }
            diag("redefinition: %s\n%P", s->name, p);
        }
        s->type = STEXT;
        s->value = pc;
        lastp->link = p;
        lastp = p;
        p->pc = pc;
        pc++;
        if(textp == P) {
            textp = p;
            etextp = p;
            goto loop;
        }
        etextp->cond = p;
        etextp = p;
        break;

    case ASUB:
        if(p->from.type == D_CONST)
        if(p->from.name == D_NONE)
        if(p->from.offset < 0) {
            p->from.offset = -p->from.offset;
            p->as = AADD;
        }
        goto casedef;

    case AADD:
        if(p->from.type == D_CONST)
        if(p->from.name == D_NONE)
        if(p->from.offset < 0) {
            p->from.offset = -p->from.offset;
            p->as = ASUB;
        }
        goto casedef;

    case AMOVDF:
        if(!vfp || p->from.type != D_FCONST)
            goto casedef;
        p->as = AMOVF;
        /* fall through */
    case AMOVF:
        if(skip)
            goto casedef;

        if(p->from.type == D_FCONST && chipfloat(p->from.ieee) < 0) {
            /* size sb 9 max */
            sprint(literal, "$%lux", ieeedtof(p->from.ieee));
            s = lookup(literal, 0);
            if(s->type == 0) {
                s->type = SBSS;
                s->value = 4;
                t = prg();
                t->as = ADATA;
                t->line = p->line;
                t->from.type = D_OREG;
                t->from.sym = s;
                t->from.name = D_EXTERN;
                t->reg = 4;
                t->to = p->from;
                t->link = datap;
                datap = t;
            }
            p->from.type = D_OREG;
            p->from.sym = s;
            p->from.name = D_EXTERN;
            p->from.offset = 0;
        }
        goto casedef;

    case AMOVD:
        if(skip)
            goto casedef;

        if(p->from.type == D_FCONST && chipfloat(p->from.ieee) < 0) {
            /* size sb 18 max */
            sprint(literal, "$%lux.%lux",
                p->from.ieee->l, p->from.ieee->h);
            s = lookup(literal, 0);
            if(s->type == 0) {
                s->type = SBSS;
                s->value = 8;
                t = prg();
                t->as = ADATA;
                t->line = p->line;
                t->from.type = D_OREG;
                t->from.sym = s;
                t->from.name = D_EXTERN;
                t->reg = 8;
                t->to = p->from;
                t->link = datap;
                datap = t;
            }
            p->from.type = D_OREG;
            p->from.sym = s;
            p->from.name = D_EXTERN;
            p->from.offset = 0;
        }
        goto casedef;

    default:
    casedef:
        if(skip)
            nopout(p);

        if(p->to.type == D_BRANCH)
            p->to.offset += ipc;
        lastp->link = p;
        lastp = p;
        p->pc = pc;
        pc++;
        break;
    }
    goto loop;

eof:
    diag("truncated object file: %s", pn);
}
@



<<[[ldobj()]] sanity check opcode in range(x86)>>=
if(o <= AXXX || o >= ALAST) {
    if(o < 0)
        goto eof;
    diag("%s: opcode out of range %d", pn, o);
    print("	probably not a .8 file\n");
    errorexit();
}
@
 
<<function nopout>>=
void
nopout(Prog *p)
{
    p->as = ANOP;
    p->from.type = D_NONE;
    p->to.type = D_NONE;
}
@


<<function zaddr(arm)>>=
int
zaddr(uchar *p, Adr *a, Sym *h[])
{
    int i, c;
    int l;
    Sym *s;
    Auto *u;

    c = p[2];
    if(c < 0 || c > NSYM){
        print("sym out of range: %d\n", c);
        p[0] = ALAST+1;
        return 0;
    }
    a->type = p[0];
    a->reg = p[1];
    a->sym = h[c];
    a->name = p[3];
    c = 4;

    if(a->reg < 0 || a->reg > NREG) {
        print("register out of range %d\n", a->reg);
        p[0] = ALAST+1;
        return 0;	/*  force real diagnostic */
    }

    switch(a->type) {
    default:
        print("unknown type %d\n", a->type);
        p[0] = ALAST+1;
        return 0;	/*  force real diagnostic */

    case D_NONE:
    case D_REG:
    case D_FREG:
    case D_PSR:
    case D_FPCR:
        break;

    case D_REGREG:
        a->offset = p[4];
        c++;
        break;

    case D_BRANCH:
    case D_OREG:
    case D_CONST:
    case D_OCONST:
    case D_SHIFT:
        a->offset = p[4] | (p[5]<<8) |
            (p[6]<<16) | (p[7]<<24);
        c += 4;
        break;

    case D_SCONST:
        while(nhunk < NSNAME)
            gethunk();
        a->sval = (char*)hunk;
        nhunk -= NSNAME;
        hunk += NSNAME;

        memmove(a->sval, p+4, NSNAME);
        c += NSNAME;
        break;

    case D_FCONST:
        while(nhunk < sizeof(Ieee))
            gethunk();
        a->ieee = (Ieee*)hunk;
        nhunk -= NSNAME;
        hunk += NSNAME;

        a->ieee->l = p[4] | (p[5]<<8) |
            (p[6]<<16) | (p[7]<<24);
        a->ieee->h = p[8] | (p[9]<<8) |
            (p[10]<<16) | (p[11]<<24);
        c += 8;
        break;
    }
    s = a->sym;
    if(s == S)
        return c;
    i = a->name;
    if(i != D_AUTO && i != D_PARAM)
        return c;

    l = a->offset;
    for(u=curauto; u; u=u->link)
        if(u->asym == s)
        if(u->type == i) {
            if(u->aoffset > l)
                u->aoffset = l;
            return c;
        }

    while(nhunk < sizeof(Auto))
        gethunk();
    u = (Auto*)hunk;
    nhunk -= sizeof(Auto);
    hunk += sizeof(Auto);

    u->link = curauto;
    curauto = u;
    u->asym = s;
    u->aoffset = l;
    u->type = i;
    return c;
}
@


\section{[[ATEXT]]}


<<global curauto>>=
Auto*	curauto;
@



<<[[ldobj()]] switch as cases(x86)>>=
case ATEXT:
    if(curtext != P) {
        histtoauto();
        curtext->to.autom = curauto;
        curauto = 0;
    }
    skip = false;
    curtext = p;
    s = p->from.sym;
    if(s == S) {
        diag("%s: no TEXT symbol: %P", pn, p);
        errorexit();
    }
    if(s->type != 0 && s->type != SXREF) {
        if(p->from.scale & DUPOK) {
            skip = true;
            goto casdef;
        }
        diag("%s: redefinition: %s\n%P", pn, s->name, p);
    }
    s->type = STEXT;
    s->value = pc;

    //add_list(firstp, lastp, p)
    lastp->link = p;
    lastp = p;

    p->pc = pc;
    pc++;

    //add_list(textp, etextp, p)
    if(textp == P) {
        textp = p;
        etextp = p;
    } else {
        etextp->pcond = p;
        etextp = p;
    }

    break;
@


\section{[[ADATA]]}

<<[[ldobj()]] switch as cases(x86)>>=
case ADATA:
data:
    //add_list(datap, edatap, p)
    if(edatap == P)
        datap = p;
    else
        edatap->link = p;
    edatap = p;
    p->link = P;
    break;
@

\section{[[ADYNT]]}
% ???
% mv with dlm?
% seems never produced by 5a/5c

<<[[ldobj()]] switch as cases(x86)>>=
case ADYNT:
    if(p->to.sym == S) {
        diag("DYNT without a sym\n%P", p);
        break;
    }
    di = p->to.sym;
    p->from.scale = 4; // NOSPLIT?
    if(di->type == SXREF) {
        if(debug['z'])
            Bprint(&bso, "%P set to %d\n", p, dtype);
        di->type = SCONST;
        di->value = dtype;
        dtype += 4;
    }
    if(p->from.sym == S)
        break;

    p->from.offset = di->value;
    p->from.sym->type = SDATA;
    if(curtext == P) {
        diag("DYNT not in text: %P", p);
        break;
    }
    p->to.sym = curtext->from.sym;
    p->to.type = D_ADDR;
    p->to.index = D_EXTERN;
    goto data;
@

\section{[[AINIT]]}
% seems never produced by 5a/5c, like ADYNT, so move?

<<[[ldobj()]] switch as cases(x86)>>=
case AINIT:
    if(p->from.sym == S) {
        diag("INIT without a sym\n%P", p);
        break;
    }
    if(di == S) {
        diag("INIT without previous DYNT\n%P", p);
        break;
    }
    p->from.offset = di->value;
    p->from.sym->type = SDATA;
    goto data;
@

\section{[[AGLOBL]]}

% not added in any list? because bss?
<<[[ldobj()]] switch as cases(x86)>>=
case AGLOBL:
    s = p->from.sym;
    if(s->type == 0 || s->type == SXREF) {
        s->type = SBSS;
        s->value = 0;
    }
    if(s->type != SBSS) {
        diag("%s: redefinition: %s in %s",
            pn, s->name, TNAME);
        s->type = SBSS;
        s->value = 0;
    }
    if(p->to.offset > s->value)
        s->value = p->to.offset;
    break;
@

\section{[[ANAME]], [[ASIGNAME]]}

<<global histfrogp>>=
int	histfrogp;
@

<<global histfrog>>=
Sym*	histfrog[MAXHIST];
@


<<global histgen>>=
int	histgen = 0;
@


% used by what? for debugging? when signature conflict! to print
% current filenames in conflict
<<[[ldobj()]] locals(x86)>>=
// array<string>, length used = files, extended every 16
static char **filen;
static int files = 0;
char **nfilen;
@

<<[[ldobj()]] grow filen if not enough space(x86)>>=
if((files&15) == 0){
    nfilen = malloc((files+16)*sizeof(char*));
    memmove(nfilen, filen, files*sizeof(char*));
    free(filen);
    filen = nfilen;
}
@


<<[[ldobj()]] if ANAME or ASIGNAME(x86)>>=
if(o == ANAME || o == ASIGNAME) {
    sig = 0;
    if(o == ASIGNAME) {
        sig = bloc[2] | (bloc[3]<<8) | (bloc[4]<<16) | (bloc[5]<<24);
        // >> >> >>
        bloc += 4;
        c -= 4;
    }
    stop = memchr(&bloc[4], 0, bsize-&bloc[4]);
    if(stop == nil){
        bsize = readsome(f, buf.xbuf, bloc, bsize, c);
        if(bsize == 0)
            goto eof;
        bloc = buf.xbuf;
        stop = memchr(&bloc[4], 0, bsize-&bloc[4]);
        if(stop == nil){
            fprint(2, "%s: name too long\n", pn);
            errorexit();
        }
    }

    v = bloc[2];	/* type */
    o = bloc[3];	/* sym */
    bloc += 4;
    c -= 4;

    r = 0;
    if(v == D_STATIC)
        r = version;
    s = lookup((char*)bloc, r);

    c -= &stop[1] - bloc;
    bloc = stop + 1;

    if(debug['S'] && r == 0)
        sig = 1729;
    if(sig != 0){
        if(s->sig != 0 && s->sig != sig)
            diag("incompatible type signatures %lux(%s) and %lux(%s) for %s", s->sig, filen[s->file], sig, pn, s->name);
        s->sig = sig;
        s->file = files-1;
    }

    if(debug['W'])
        print("	ANAME	%s\n", s->name);

    h[o] = s;
    if((v == D_EXTERN || v == D_STATIC) && s->type == 0)
        s->type = SXREF;
    if(v == D_FILE) {
        if(s->type != SFILE) {
            histgen++;
            s->type = SFILE;
            s->value = histgen;
        }
        if(histfrogp < MAXHIST) {
            histfrog[histfrogp] = s;
            histfrogp++;
        } else
            collapsefrog(s);
    }
    goto loop;
}
@
% >> >> >>

<<function collapsefrog>>=
void
collapsefrog(Sym *s)
{
    int i;

    /*
     * bad encoding of path components only allows
     * MAXHIST components. if there is an overflow,
     * first try to collapse xxx/..
     */
    for(i=1; i<histfrogp; i++)
        if(strcmp(histfrog[i]->name+1, "..") == 0) {
            memmove(histfrog+i-1, histfrog+i+1,
                (histfrogp-i-1)*sizeof(histfrog[0]));
            histfrogp--;
            goto out;
        }

    /*
     * next try to collapse .
     */
    for(i=0; i<histfrogp; i++)
        if(strcmp(histfrog[i]->name+1, ".") == 0) {
            memmove(histfrog+i, histfrog+i+1,
                (histfrogp-i-1)*sizeof(histfrog[0]));
            goto out;
        }

    /*
     * last chance, just truncate from front
     */
    memmove(histfrog+0, histfrog+1,
        (histfrogp-1)*sizeof(histfrog[0]));

out:
    histfrog[histfrogp-1] = s;
}
@



\section{[[AHISTORY]]}

<<[[ldobj()]] switch as cases(x86)>>=
case AHISTORY:
    if(p->to.offset == -1) {
        addlib(pn);
        histfrogp = 0;
        goto loop;
    }
    addhist(p->line, D_FILE);		/* 'z' */
    if(p->to.offset)
        addhist(p->to.offset, D_FILE1);	/* 'Z' */
    histfrogp = 0;
    break;
@

\section{[[AEND]]}

<<[[ldobj()]] switch as cases(x86)>>=
case AEND:
    histtoauto();
    if(curtext != P)
        curtext->to.autom = curauto;
    curauto = 0;
    curtext = P;
    if(c)
        goto newloop;
    return;
@


<<global curhist>>=
Auto*	curhist;
@


% also called by ATEXT
<<function histtoauto>>=
void
histtoauto(void)
{
    Auto *l;

    while(l = curhist) {
        curhist = l->link;
        l->link = curauto;
        curauto = l;
    }
}
@


\section{[[AGOK]]}

<<[[ldobj()]] switch as cases(x86)>>=
case AGOK:
    diag("%s: GOK opcode in %s", pn, TNAME);
    pc++;
    break;
@

\chapter{Loading Libraries}

\section{Library search path}


<<[[main()]] command line processing(arm)>>=
case 'L':
    addlibpath(EARGF(usage()));
    break;
@


% was called a
<<[[main()]] locals(arm)>>=
char *root;
@

<<[[main()]] addlibpath("/xxx/lib") or ccroot>>=
<<[[main()]] change root if ccroot>>

// usually /386/lib/ as root = ""
snprint(name, sizeof(name), "%s/%s/lib", root, thestring);
addlibpath(name);
@

% possible to change default / search path
<<[[main()]] change root if ccroot>>=
root = getenv("ccroot");

if(root != nil && *root != '\0') {
    if(!fileexists(root)) {
        diag("nonexistent $ccroot: %s", root);
        errorexit();
    }
}else
    root = "";
@
%$




<<global libdir>>=
char**	libdir;
@


<<global nlibdir>>=
int	nlibdir	= 0;
@

<<global maxlibdir>>=
static	int	maxlibdir = 0;
@




<<function addlibpath>>=
void
addlibpath(char *arg)
{
    char **p;

    // growing array libdir
    if(nlibdir >= maxlibdir) {
        if(maxlibdir == 0)
            maxlibdir = 8;
        else
            maxlibdir *= 2;
        p = malloc(maxlibdir*sizeof(*p));
        if(p == nil) {
            diag("out of memory");
            errorexit();
        }
        memmove(p, libdir, nlibdir*sizeof(*p));
        free(libdir);
        libdir = p;
    }

    libdir[nlibdir++] = strdup(arg);
}
@


\section{[[ar]] format}

% from ar.h
<<constant ARMAG>>=
#define	ARMAG	"!<arch>\n"
@

<<constant SARMAG>>=
#define	SARMAG	8
@

<<constant ARFMAG>>=
#define	ARFMAG	"`\n"
@

<<constant SARNAME>>=
#define SARNAME	16
@

<<struct ar_hdr>>=
struct	ar_hdr
{
    char	name[SARNAME];
    char	date[12];
    char	uid[6];
    char	gid[6];
    char	mode[8];
    char	size[10];
    char	fmag[2];
};
@

<<constant SAR_HDR>>=
#define	SAR_HDR	(SARNAME+44)
@

\section{Loading libraries}

\subsection{Loading libraries manually [[5l -lxxx]]}

% when done manually by -l in command line of ld
<<[[objfile()]] adjust file if -lxxx filename>>=
if(file[0] == '-' && file[1] == 'l') {
    snprint(pname, sizeof(pname), "lib%s.a", file+2);
    e = findlib(pname);
    if(e == nil) {
        diag("cannot find library: %s", file);
        errorexit();
    }
    snprint(name, sizeof(name), "%s/%s", e, pname);
    file = name;
}
@

<<function findlib>>=
char*
findlib(char *file)
{
    int i;
    char name[LIBNAMELEN];

    for(i = 0; i < nlibdir; i++) {
        snprint(name, sizeof(name), "%s/%s", libdir[i], file);
        if(fileexists(name))
            return libdir[i];
    }
    return nil;
}
@




<<[[objfile()]] other locals>>=
long off, esym, cnt;
bool work;
Sym *s;
char pname[LIBNAMELEN];
char name[LIBNAMELEN];
struct ar_hdr arhdr;
char *e, *start, *stop;
@

<<global symname linker>>=
char	symname[]	= SYMDEF;
@


<<[[objfile()]] when file is a library>>=
    DBG("%5.2f ldlib: %s\n", cputime(), file);
    l = read(f, &arhdr, SAR_HDR);
    if(l != SAR_HDR) {
        diag("%s: short read on archive file symbol header", file);
        goto out;
    }
    if(strncmp(arhdr.name, symname, strlen(symname))) {
        diag("%s: first entry not symbol header", file);
        goto out;
    }

    esym = SARMAG + SAR_HDR + atolwhex(arhdr.size);
    off = SARMAG + SAR_HDR;

    /*
     * just bang the whole symbol file into memory
     */
    seek(f, off, 0);
    cnt = esym - off;
    start = malloc(cnt + 10);
    cnt = read(f, start, cnt);
    if(cnt <= 0){
        close(f);
        return;
    }
    stop = &start[cnt];
    memset(stop, 0, 10);

    work = true;

    while(work) {

        DBG("%5.2f library pass: %s\n", cputime(), file);

        work = false;
        for(e = start; e < stop; e = strchr(e+5, 0) + 1) {
            s = lookup(e+5, 0);
            if(s->type != SXREF)
                continue;
            sprint(pname, "%s(%s)", file, s->name);

            DBG("%5.2f library: %s\n", cputime(), pname);

            l = e[1] & 0xff;
            l |= (e[2] & 0xff) << 8;
            l |= (e[3] & 0xff) << 16;
            l |= (e[4] & 0xff) << 24;
            seek(f, l, 0);
            /* need readn to read the dumps (at least) */
            l = readn(f, &arhdr, SAR_HDR);
            if(l != SAR_HDR)
                goto bad;
            if(strncmp(arhdr.fmag, ARFMAG, sizeof(arhdr.fmag)))
                goto bad;
            l = atolwhex(arhdr.size);
            ldobj(f, l, pname);
            if(s->type == SXREF) {
                diag("%s: failed to load: %s", file, s->name);
                errorexit();
            }
            work = true;
            xrefresolv = true;
        }
    }
    return;

bad:
    diag("%s: bad or out of date archive", file);
out:
    close(f);
@

% >> >> >>

\subsection{Loading libraries automagically [[#pragma lib]]}

% when done automatically

% TODO LP split AHISTORY here


<<function addhist>>=
void
addhist(long line, int type)
{
    Auto *u;
    Sym *s;
    int i, j, k;

    u = malloc(sizeof(Auto));
    s = malloc(sizeof(Sym));
    s->name = malloc(2*(histfrogp+1) + 1);

    u->asym = s;
    u->type = type;
    u->aoffset = line;
    u->link = curhist;
    curhist = u;

    j = 1;
    for(i=0; i<histfrogp; i++) {
        k = histfrog[i]->value;
        s->name[j+0] = k>>8;
        s->name[j+1] = k;
        j += 2;
    }
}
@




<<function addlib>>=
void
addlib(char *obj)
{
    char fn1[LIBNAMELEN], fn2[LIBNAMELEN], comp[LIBNAMELEN], *p, *name;
    int i, search;

    if(histfrogp <= 0)
        return;

    name = fn1;
    search = 0;
    if(histfrog[0]->name[1] == '/') {
        sprint(name, "");
        i = 1;
    } else if(histfrog[0]->name[1] == '.') {
        sprint(name, ".");
        i = 0;
    } else {
        sprint(name, "");
        i = 0;
        search = 1;
    }

    for(; i<histfrogp; i++) {
        snprint(comp, sizeof comp, histfrog[i]->name+1);
        for(;;) {
            p = strstr(comp, "$O");
            if(p == 0)
                break;
            memmove(p+1, p+2, strlen(p+2)+1);
            p[0] = thechar;
        }
        for(;;) {
            p = strstr(comp, "$M");
            if(p == 0)
                break;
            if(strlen(comp)+strlen(thestring)-2+1 >= sizeof comp) {
                diag("library component too long");
                return;
            }
            memmove(p+strlen(thestring), p+2, strlen(p+2)+1);
            memmove(p, thestring, strlen(thestring));
        }
        if(strlen(fn1) + strlen(comp) + 3 >= sizeof(fn1)) {
            diag("library component too long");
            return;
        }
        if(i > 0 || !search)
            strcat(fn1, "/");
        strcat(fn1, comp);
    }

    cleanname(name);

    if(search){
        p = findlib(name);
        if(p != nil){
            snprint(fn2, sizeof(fn2), "%s/%s", p, name);
            name = fn2;
        }
    }


    for(i=0; i<libraryp; i++)
        if(strcmp(name, library[i]) == 0)
            return;
    if(libraryp == nelem(library)){
        diag("too many autolibs; skipping %s", name);
        return;
    }

    p = malloc(strlen(name) + 1);
    strcpy(p, name);
    library[libraryp] = p;
    p = malloc(strlen(obj) + 1);
    strcpy(p, obj);
    libraryobj[libraryp] = p;
    libraryp++;
}
@


\chapter{Checking Signatures}

\chapter{Machine Code Generation (ARM)}

% done by 5l, not 5a, surprisingly!

% why? because allows more optimisations? cross libs? as in llvm?
% also more compact and simple object format? and more cross platform?

\section{[[optab]]}


<<global optab (linkers/5l/optab.c)(arm)>>=
Optab	optab[] =
{
    { ATEXT,	C_LEXT,	C_NONE,	C_LCON, 	 0, 0, 0 },
    { ATEXT,	C_LEXT,	C_REG,	C_LCON, 	 0, 0, 0 },
    { ATEXT,	C_ADDR,	C_NONE,	C_LCON, 	 0, 0, 0 },
    { ATEXT,	C_ADDR,	C_REG,	C_LCON, 	 0, 0, 0 },

    { AADD,		C_REG,	C_REG,	C_REG,		 1, 4, 0 },
    { AADD,		C_REG,	C_NONE,	C_REG,		 1, 4, 0 },
    { AMOVW,	C_REG,	C_NONE,	C_REG,		 1, 4, 0 },
    { AMVN,		C_REG,	C_NONE,	C_REG,		 1, 4, 0 },
    { ACMP,		C_REG,	C_REG,	C_NONE,		 1, 4, 0 },

    { AADD,		C_RCON,	C_REG,	C_REG,		 2, 4, 0 },
    { AADD,		C_RCON,	C_NONE,	C_REG,		 2, 4, 0 },
    { AMOVW,	C_RCON,	C_NONE,	C_REG,		 2, 4, 0 },
    { AMVN,		C_RCON,	C_NONE,	C_REG,		 2, 4, 0 },
    { ACMP,		C_RCON,	C_REG,	C_NONE,		 2, 4, 0 },

    { AADD,		C_SHIFT,C_REG,	C_REG,		 3, 4, 0 },
    { AADD,		C_SHIFT,C_NONE,	C_REG,		 3, 4, 0 },
    { AMVN,		C_SHIFT,C_NONE,	C_REG,		 3, 4, 0 },
    { ACMP,		C_SHIFT,C_REG,	C_NONE,		 3, 4, 0 },

    { AMOVW,	C_RECON,C_NONE,	C_REG,		 4, 4, REGSB },
    { AMOVW,	C_RACON,C_NONE,	C_REG,		 4, 4, REGSP },

    { AB,		C_NONE,	C_NONE,	C_SBRA,		 5, 4, 0,	LPOOL },
    { ABL,		C_NONE,	C_NONE,	C_SBRA,		 5, 4, 0 },
    { ABEQ,		C_NONE,	C_NONE,	C_SBRA,		 5, 4, 0 },

    { AB,		C_NONE,	C_NONE,	C_ROREG,	 6, 4, 0,	LPOOL },
    { ABL,		C_NONE,	C_NONE,	C_ROREG,	 7, 8, 0 },

    { ASLL,		C_RCON,	C_REG,	C_REG,		 8, 4, 0 },
    { ASLL,		C_RCON,	C_NONE,	C_REG,		 8, 4, 0 },

    { ASLL,		C_REG,	C_NONE,	C_REG,		 9, 4, 0 },
    { ASLL,		C_REG,	C_REG,	C_REG,		 9, 4, 0 },

    { ASWI,		C_NONE,	C_NONE,	C_NONE,		10, 4, 0 },
    { ASWI,		C_NONE,	C_NONE,	C_LOREG,	10, 4, 0 },

    { AWORD,	C_NONE,	C_NONE,	C_LCON,		11, 4, 0 },
    { AWORD,	C_NONE,	C_NONE,	C_LEXT,		11, 4, 0 },
    { AWORD,	C_NONE,	C_NONE,	C_ADDR,		11, 4, 0 },

    { AMOVW,	C_NCON,	C_NONE,	C_REG,		12, 4, 0 },
    { AMOVW,	C_LCON,	C_NONE,	C_REG,		12, 4, 0,	LFROM },

    { AADD,		C_NCON,	C_REG,	C_REG,		13, 8, 0 },
    { AADD,		C_NCON,	C_NONE,	C_REG,		13, 8, 0 },
    { AMVN,		C_NCON,	C_NONE,	C_REG,		13, 8, 0 },
    { ACMP,		C_NCON,	C_REG,	C_NONE,		13, 8, 0 },
    { AADD,		C_LCON,	C_REG,	C_REG,		13, 8, 0,	LFROM },
    { AADD,		C_LCON,	C_NONE,	C_REG,		13, 8, 0,	LFROM },
    { AMVN,		C_LCON,	C_NONE,	C_REG,		13, 8, 0,	LFROM },
    { ACMP,		C_LCON,	C_REG,	C_NONE,		13, 8, 0,	LFROM },

    { AMOVB,	C_REG,	C_NONE,	C_REG,		14, 8, 0 },
    { AMOVBU,	C_REG,	C_NONE,	C_REG,		58, 4, 0 },
    { AMOVH,	C_REG,	C_NONE,	C_REG,		14, 8, 0 },
    { AMOVHU,	C_REG,	C_NONE,	C_REG,		14, 8, 0 },

    { AMUL,		C_REG,	C_REG,	C_REG,		15, 4, 0 },
    { AMUL,		C_REG,	C_NONE,	C_REG,		15, 4, 0 },

    { ADIV,		C_REG,	C_REG,	C_REG,		16, 4, 0 },
    { ADIV,		C_REG,	C_NONE,	C_REG,		16, 4, 0 },

    { AMULL,	C_REG,	C_REG,	C_REGREG,	17, 4, 0 },

    { AMOVW,	C_REG,	C_NONE,	C_SEXT,		20, 4, REGSB },
    { AMOVW,	C_REG,	C_NONE,	C_SAUTO,	20, 4, REGSP },
    { AMOVW,	C_REG,	C_NONE,	C_SOREG,	20, 4, 0 },
    { AMOVB,	C_REG,	C_NONE,	C_SEXT,		20, 4, REGSB },
    { AMOVB,	C_REG,	C_NONE,	C_SAUTO,	20, 4, REGSP },
    { AMOVB,	C_REG,	C_NONE,	C_SOREG,	20, 4, 0 },
    { AMOVBU,	C_REG,	C_NONE,	C_SEXT,		20, 4, REGSB },
    { AMOVBU,	C_REG,	C_NONE,	C_SAUTO,	20, 4, REGSP },
    { AMOVBU,	C_REG,	C_NONE,	C_SOREG,	20, 4, 0 },

    { AMOVW,	C_SEXT,	C_NONE,	C_REG,		21, 4, REGSB },
    { AMOVW,	C_SAUTO,C_NONE,	C_REG,		21, 4, REGSP },
    { AMOVW,	C_SOREG,C_NONE,	C_REG,		21, 4, 0 },
    { AMOVBU,	C_SEXT,	C_NONE,	C_REG,		21, 4, REGSB },
    { AMOVBU,	C_SAUTO,C_NONE,	C_REG,		21, 4, REGSP },
    { AMOVBU,	C_SOREG,C_NONE,	C_REG,		21, 4, 0 },

    { AMOVB,	C_SEXT,	C_NONE,	C_REG,		22, 12, REGSB },
    { AMOVB,	C_SAUTO,C_NONE,	C_REG,		22, 12, REGSP },
    { AMOVB,	C_SOREG,C_NONE,	C_REG,		22, 12, 0 },
    { AMOVH,	C_SEXT,	C_NONE,	C_REG,		22, 12, REGSB },
    { AMOVH,	C_SAUTO,C_NONE,	C_REG,		22, 12, REGSP },
    { AMOVH,	C_SOREG,C_NONE,	C_REG,		22, 12, 0 },
    { AMOVHU,	C_SEXT,	C_NONE,	C_REG,		22, 12, REGSB },
    { AMOVHU,	C_SAUTO,C_NONE,	C_REG,		22, 12, REGSP },
    { AMOVHU,	C_SOREG,C_NONE,	C_REG,		22, 12, 0 },

    { AMOVH,	C_REG,	C_NONE,	C_SEXT,		23, 12, REGSB },
    { AMOVH,	C_REG,	C_NONE,	C_SAUTO,	23, 12, REGSP },
    { AMOVH,	C_REG,	C_NONE,	C_SOREG,	23, 12, 0 },
    { AMOVHU,	C_REG,	C_NONE,	C_SEXT,		23, 12, REGSB },
    { AMOVHU,	C_REG,	C_NONE,	C_SAUTO,	23, 12, REGSP },
    { AMOVHU,	C_REG,	C_NONE,	C_SOREG,	23, 12, 0 },

    { AMOVW,	C_REG,	C_NONE,	C_LEXT,		30, 8, REGSB,	LTO },
    { AMOVW,	C_REG,	C_NONE,	C_LAUTO,	30, 8, REGSP,	LTO },
    { AMOVW,	C_REG,	C_NONE,	C_LOREG,	30, 8, 0,	LTO },
    { AMOVW,	C_REG,	C_NONE,	C_ADDR,		64, 8, 0,	LTO },
    { AMOVB,	C_REG,	C_NONE,	C_LEXT,		30, 8, REGSB,	LTO },
    { AMOVB,	C_REG,	C_NONE,	C_LAUTO,	30, 8, REGSP,	LTO },
    { AMOVB,	C_REG,	C_NONE,	C_LOREG,	30, 8, 0,	LTO },
    { AMOVB,	C_REG,	C_NONE,	C_ADDR,		64, 8, 0,	LTO },
    { AMOVBU,	C_REG,	C_NONE,	C_LEXT,		30, 8, REGSB,	LTO },
    { AMOVBU,	C_REG,	C_NONE,	C_LAUTO,	30, 8, REGSP,	LTO },
    { AMOVBU,	C_REG,	C_NONE,	C_LOREG,	30, 8, 0,	LTO },
    { AMOVBU,	C_REG,	C_NONE,	C_ADDR,		64, 8, 0,	LTO },

    { AMOVW,	C_LEXT,	C_NONE,	C_REG,		31, 8, REGSB,	LFROM },
    { AMOVW,	C_LAUTO,C_NONE,	C_REG,		31, 8, REGSP,	LFROM },
    { AMOVW,	C_LOREG,C_NONE,	C_REG,		31, 8, 0,	LFROM },
    { AMOVW,	C_ADDR,	C_NONE,	C_REG,		65, 8, 0,	LFROM },
    { AMOVBU,	C_LEXT,	C_NONE,	C_REG,		31, 8, REGSB,	LFROM },
    { AMOVBU,	C_LAUTO,C_NONE,	C_REG,		31, 8, REGSP,	LFROM },
    { AMOVBU,	C_LOREG,C_NONE,	C_REG,		31, 8, 0,	LFROM },
    { AMOVBU,	C_ADDR,	C_NONE,	C_REG,		65, 8, 0,	LFROM },

    { AMOVB,	C_LEXT,	C_NONE,	C_REG,		32, 16, REGSB,	LFROM },
    { AMOVB,	C_LAUTO,C_NONE,	C_REG,		32, 16, REGSP,	LFROM },
    { AMOVB,	C_LOREG,C_NONE,	C_REG,		32, 16, 0,	LFROM },
    { AMOVB,	C_ADDR,	C_NONE,	C_REG,		66, 16, 0,	LFROM },
    { AMOVH,	C_LEXT,	C_NONE,	C_REG,		32, 16, REGSB,	LFROM },
    { AMOVH,	C_LAUTO,C_NONE,	C_REG,		32, 16, REGSP,	LFROM },
    { AMOVH,	C_LOREG,C_NONE,	C_REG,		32, 16, 0,	LFROM },
    { AMOVH,	C_ADDR,	C_NONE,	C_REG,		66, 16, 0,	LFROM },
    { AMOVHU,	C_LEXT,	C_NONE,	C_REG,		32, 16, REGSB,	LFROM },
    { AMOVHU,	C_LAUTO,C_NONE,	C_REG,		32, 16, REGSP,	LFROM },
    { AMOVHU,	C_LOREG,C_NONE,	C_REG,		32, 16, 0,	LFROM },
    { AMOVHU,	C_ADDR,	C_NONE,	C_REG,		66, 16, 0,	LFROM },

    { AMOVH,	C_REG,	C_NONE,	C_LEXT,		33, 24, REGSB,	LTO },
    { AMOVH,	C_REG,	C_NONE,	C_LAUTO,	33, 24, REGSP,	LTO },
    { AMOVH,	C_REG,	C_NONE,	C_LOREG,	33, 24, 0,	LTO },
    { AMOVH,	C_REG,	C_NONE,	C_ADDR,		67, 24, 0,	LTO },
    { AMOVHU,	C_REG,	C_NONE,	C_LEXT,		33, 24, REGSB,	LTO },
    { AMOVHU,	C_REG,	C_NONE,	C_LAUTO,	33, 24, REGSP,	LTO },
    { AMOVHU,	C_REG,	C_NONE,	C_LOREG,	33, 24, 0,	LTO },
    { AMOVHU,	C_REG,	C_NONE,	C_ADDR,		67, 24, 0,	LTO },

    { AMOVW,	C_LECON,C_NONE,	C_REG,		34, 8, REGSB,	LFROM },
    { AMOVW,	C_LACON,C_NONE,	C_REG,		34, 8, REGSP,	LFROM },

    { AMOVW,	C_PSR,	C_NONE,	C_REG,		35, 4, 0 },
    { AMOVW,	C_REG,	C_NONE,	C_PSR,		36, 4, 0 },
    { AMOVW,	C_RCON,	C_NONE,	C_PSR,		37, 4, 0 },

    { AMOVM,	C_LCON,	C_NONE,	C_SOREG,	38, 4, 0 },
    { AMOVM,	C_SOREG,C_NONE,	C_LCON,		39, 4, 0 },

    { ASWPW,	C_SOREG,C_REG,	C_REG,		40, 4, 0 },

    { ARFE,		C_NONE,	C_NONE,	C_NONE,		41, 4, 0 },

    { AMOVF,	C_FREG,	C_NONE,	C_FEXT,		50, 4, REGSB },
    { AMOVF,	C_FREG,	C_NONE,	C_FAUTO,	50, 4, REGSP },
    { AMOVF,	C_FREG,	C_NONE,	C_FOREG,	50, 4, 0 },

    { AMOVF,	C_FEXT,	C_NONE,	C_FREG,		51, 4, REGSB },
    { AMOVF,	C_FAUTO,C_NONE,	C_FREG,		51, 4, REGSP },
    { AMOVF,	C_FOREG,C_NONE,	C_FREG,		51, 4, 0 },

    { AMOVF,	C_FREG,	C_NONE,	C_LEXT,		52, 12, REGSB,	LTO },
    { AMOVF,	C_FREG,	C_NONE,	C_LAUTO,	52, 12, REGSP,	LTO },
    { AMOVF,	C_FREG,	C_NONE,	C_LOREG,	52, 12, 0,	LTO },

    { AMOVF,	C_LEXT,	C_NONE,	C_FREG,		53, 12, REGSB,	LFROM },
    { AMOVF,	C_LAUTO,C_NONE,	C_FREG,		53, 12, REGSP,	LFROM },
    { AMOVF,	C_LOREG,C_NONE,	C_FREG,		53, 12, 0,	LFROM },

    { AMOVF,	C_FREG,	C_NONE,	C_ADDR,		68, 8, 0,	LTO },
    { AMOVF,	C_ADDR,	C_NONE,	C_FREG,		69, 8, 0,	LFROM },

    { AADDF,	C_FREG,	C_NONE,	C_FREG,		54, 4, 0 },
    { AADDF,	C_FREG,	C_REG,	C_FREG,		54, 4, 0 },
    { AADDF,	C_FCON,	C_NONE,	C_FREG,		54, 4, 0 },
    { AADDF,	C_FCON,	C_REG,	C_FREG,		54, 4, 0 },
    { AMOVF,	C_FCON,	C_NONE,	C_FREG,		54, 4, 0 },
    { AMOVF,	C_FREG, C_NONE, C_FREG,		54, 4, 0 },

    { ACMPF,	C_FREG,	C_REG,	C_NONE,		54, 4, 0 },
    { ACMPF,	C_FCON,	C_REG,	C_NONE,		54, 4, 0 },

    { AMOVFW,	C_FREG,	C_NONE,	C_REG,		55, 4, 0 },
    { AMOVFW,	C_REG,	C_NONE,	C_FREG,		55, 4, 0 },

    { AMOVW,	C_REG,	C_NONE,	C_FCR,		56, 4, 0 },
    { AMOVW,	C_FCR,	C_NONE,	C_REG,		57, 4, 0 },

    { AMOVW,	C_SHIFT,C_NONE,	C_REG,		59, 4, 0 },
    { AMOVBU,	C_SHIFT,C_NONE,	C_REG,		59, 4, 0 },

    { AMOVB,	C_SHIFT,C_NONE,	C_REG,		60, 4, 0 },

    { AMOVW,	C_REG,	C_NONE,	C_SHIFT,	61, 4, 0 },
    { AMOVB,	C_REG,	C_NONE,	C_SHIFT,	61, 4, 0 },
    { AMOVBU,	C_REG,	C_NONE,	C_SHIFT,	61, 4, 0 },

    { ACASE,	C_REG,	C_NONE,	C_NONE,		62, 4, 0 },
    { ABCASE,	C_NONE, C_NONE, C_SBRA,		63, 4, 0 },

    { AADDF,	C_FREG,	C_NONE,	C_FREG,		74, 4, 0, VFP },
    { AADDF,	C_FREG,	C_REG,	C_FREG,		74, 4, 0, VFP },
    { AMOVF,	C_FREG, C_NONE, C_FREG,		74, 4, 0, VFP },
    { ACMPF,	C_FREG,	C_REG,	C_NONE,		75, 8, 0, VFP },
    { ACMPF,	C_FCON,	C_REG,	C_NONE,		75, 8, 0, VFP },
    { AMOVFW,	C_FREG,	C_NONE,	C_REG,		76, 8, 0, VFP },
    { AMOVFW,	C_REG,	C_NONE,	C_FREG,		76, 8, 0, VFP },

    { AMOVH,	C_REG,	C_NONE,	C_HEXT,		70, 4, REGSB,	V4 },
    { AMOVH,	C_REG,	C_NONE, C_HAUTO,	70, 4, REGSP,	V4 },
    { AMOVH,	C_REG,	C_NONE,	C_HOREG,	70, 4, 0,	V4 },
    { AMOVHU,	C_REG,	C_NONE,	C_HEXT,		70, 4, REGSB,	V4 },
    { AMOVHU,	C_REG,	C_NONE, C_HAUTO,	70, 4, REGSP,	V4 },
    { AMOVHU,	C_REG,	C_NONE,	C_HOREG,	70, 4, 0,	V4 },

    { AMOVB,	C_HEXT,	C_NONE, C_REG,		71, 4, REGSB,	V4 },
    { AMOVB,	C_HAUTO,C_NONE,	C_REG,		71, 4, REGSP,	V4 },
    { AMOVB,	C_HOREG,C_NONE,	C_REG,		71, 4, 0,	V4 },
    { AMOVH,	C_HEXT,	C_NONE,	C_REG,		71, 4, REGSB,	V4 },
    { AMOVH,	C_HAUTO,C_NONE, C_REG,		71, 4, REGSP,	V4 },
    { AMOVH,	C_HOREG,C_NONE,	C_REG,		71, 4, 0,	V4 },
    { AMOVHU,	C_HEXT,	C_NONE,	C_REG,		71, 4, REGSB,	V4 },
    { AMOVHU,	C_HAUTO,C_NONE, C_REG,		71, 4, REGSP,	V4 },
    { AMOVHU,	C_HOREG,C_NONE,	C_REG,		71, 4, 0,	V4 },

    { AMOVH,	C_REG,	C_NONE,	C_LEXT,		72, 8, REGSB,	LTO|V4 },
    { AMOVH,	C_REG,	C_NONE, C_LAUTO,	72, 8, REGSP,	LTO|V4 },
    { AMOVH,	C_REG,	C_NONE,	C_LOREG,	72, 8, 0,	LTO|V4 },
    { AMOVHU,	C_REG,	C_NONE,	C_LEXT,		72, 8, REGSB,	LTO|V4 },
    { AMOVHU,	C_REG,	C_NONE, C_LAUTO,	72, 8, REGSP,	LTO|V4 },
    { AMOVHU,	C_REG,	C_NONE,	C_LOREG,	72, 8, 0,	LTO|V4 },

    { AMOVB,	C_LEXT,	C_NONE, C_REG,		73, 8, REGSB,	LFROM|V4 },
    { AMOVB,	C_LAUTO,C_NONE,	C_REG,		73, 8, REGSP,	LFROM|V4 },
    { AMOVB,	C_LOREG,C_NONE,	C_REG,		73, 8, 0,	LFROM|V4 },
    { AMOVH,	C_LEXT,	C_NONE,	C_REG,		73, 8, REGSB,	LFROM|V4 },
    { AMOVH,	C_LAUTO,C_NONE, C_REG,		73, 8, REGSP,	LFROM|V4 },
    { AMOVH,	C_LOREG,C_NONE,	C_REG,		73, 8, 0,	LFROM|V4 },
    { AMOVHU,	C_LEXT,	C_NONE,	C_REG,		73, 8, REGSB,	LFROM|V4 },
    { AMOVHU,	C_LAUTO,C_NONE, C_REG,		73, 8, REGSP,	LFROM|V4 },
    { AMOVHU,	C_LOREG,C_NONE,	C_REG,		73, 8, 0,	LFROM|V4 },

    { AXXX,		C_NONE,	C_NONE,	C_NONE,		 0, 4, 0 },
};
@





\chapter{Debugging Support}
% Symbol Tables.
% related to import/export table? I don't think so

\section{Symbol table}

<<global symsize>>=
long	symsize;
@



% asmb -> <>
<<function asmsym(arm)>>=
void
asmsym(void)
{
    Prog *p;
    Auto *a;
    Sym *s;
    int h;

    s = lookup("etext", 0);
    if(s->type == STEXT)
        putsymb(s->name, 'T', s->value, s->version);

    for(h=0; h<NHASH; h++)
        for(s=hash[h]; s!=S; s=s->link)
            switch(s->type) {
            case SCONST:
                putsymb(s->name, 'D', s->value, s->version);
                continue;

            case SDATA:
                putsymb(s->name, 'D', s->value+INITDAT, s->version);
                continue;

            case SBSS:
                putsymb(s->name, 'B', s->value+INITDAT, s->version);
                continue;

            case SSTRING:
                putsymb(s->name, 'T', s->value, s->version);
                continue;

            case SFILE:
                putsymb(s->name, 'f', s->value, s->version);
                continue;
            }

    for(p=textp; p!=P; p=p->cond) {
        s = p->from.sym;
        if(s->type != STEXT && s->type != SLEAF)
            continue;

        /* filenames first */
        for(a=p->to.autom; a; a=a->link)
            if(a->type == D_FILE)
                putsymb(a->asym->name, 'z', a->aoffset, 0);
            else
            if(a->type == D_FILE1)
                putsymb(a->asym->name, 'Z', a->aoffset, 0);

        if(s->type == STEXT)
            putsymb(s->name, 'T', s->value, s->version);
        else
            putsymb(s->name, 'L', s->value, s->version);

        /* frame, auto and param after */
        putsymb(".frame", 'm', p->to.offset+4, 0);
        for(a=p->to.autom; a; a=a->link)
            if(a->type == D_AUTO)
                putsymb(a->asym->name, 'a', -a->aoffset, 0);
            else
            if(a->type == D_PARAM)
                putsymb(a->asym->name, 'p', a->aoffset, 0);
    }
    if(debug['v'] || debug['n'])
        Bprint(&bso, "symsize = %lud\n", symsize);
    Bflush(&bso);
}
@




<<function putsymb>>=
void
putsymb(char *s, int t, long v, int ver)
{
    int i, f;

    if(t == 'f')
        s++;
    lput(v);
    if(ver)
        t += 'a' - 'A';
    cput(t+0x80);			/* 0x80 is variable length */

    if(t == 'Z' || t == 'z') {
        cput(s[0]);
        for(i=1; s[i] != 0 || s[i+1] != 0; i += 2) {
            cput(s[i]);
            cput(s[i+1]);
        }
        cput(0);
        cput(0);
        i++;
    }
    else {
        for(i=0; s[i]; i++)
            cput(s[i]);
        cput(0);
    }
    symsize += 4 + 1 + i + 1;

    if(debug['n']) {
        if(t == 'z' || t == 'Z') {
            Bprint(&bso, "%c %.8lux ", t, v);
            for(i=1; s[i] != 0 || s[i+1] != 0; i+=2) {
                f = ((s[i]&0xff) << 8) | (s[i+1]&0xff);
                Bprint(&bso, "/%x", f);
            }
            Bprint(&bso, "\n");
            return;
        }
        if(ver)
            Bprint(&bso, "%c %.8lux %s<%d>\n", t, v, s, ver);
        else
            Bprint(&bso, "%c %.8lux %s\n", t, v, s);
    }
}
@
%>>


\section{Line table}

% lc? line count?
<<global lcsize>>=
long	lcsize;
@


<<function asmlc>>=
void
asmlc(void)
{
    long oldpc, oldlc;
    Prog *p;
    long v, s;

    oldpc = INITTEXT;
    oldlc = 0;
    for(p = firstp; p != P; p = p->link) {
        if(p->line == oldlc || p->as == ATEXT || p->as == ANOP) {
            if(p->as == ATEXT)
                curtext = p;
            if(debug['V'])
                Bprint(&bso, "%6lux %P\n",
                    p->pc, p);
            continue;
        }
        if(debug['V'])
            Bprint(&bso, "\t\t%6ld", lcsize);
        v = (p->pc - oldpc) / MINLC;
        while(v) {
            s = 127;
            if(v < 127)
                s = v;
            cput(s+128);	/* 129-255 +pc */
            if(debug['V'])
                Bprint(&bso, " pc+%ld*%d(%ld)", s, MINLC, s+128);
            v -= s;
            lcsize++;
        }
        s = p->line - oldlc;
        oldlc = p->line;
        oldpc = p->pc + MINLC;
        if(s > 64 || s < -64) {
            cput(0);	/* 0 vv +lc */
            cput(s>>24);
            cput(s>>16);
            cput(s>>8);
            cput(s);
            if(debug['V']) {
                if(s > 0)
                    Bprint(&bso, " lc+%ld(%d,%ld)\n",
                        s, 0, s);
                else
                    Bprint(&bso, " lc%ld(%d,%ld)\n",
                        s, 0, s);
                Bprint(&bso, "%6lux %P\n",
                    p->pc, p);
            }
            lcsize += 5;
            continue;
        }
        if(s > 0) {
            cput(0+s);	/* 1-64 +lc */
            if(debug['V']) {
                Bprint(&bso, " lc+%ld(%ld)\n", s, 0+s);
                Bprint(&bso, "%6lux %P\n",
                    p->pc, p);
            }
        } else {
            cput(64-s);	/* 65-128 -lc */
            if(debug['V']) {
                Bprint(&bso, " lc%ld(%ld)\n", s, 64-s);
                Bprint(&bso, "%6lux %P\n",
                    p->pc, p);
            }
        }
        lcsize++;
    }
    while(lcsize & 1) {
        s = 129;
        cput(s);
        lcsize++;
    }
    if(debug['v'] || debug['V'])
        Bprint(&bso, "lcsize = %ld\n", lcsize);
    Bflush(&bso);
}
@




\chapter{Profiling Support}
% surprising again that it's ld's job to add profiling in plan9

% The code below is interesting because it inserts extra object code using
% directly "AST" constructs, so it helps to understand the data structure!!

% see NOPROF of 8.out.h in Assembler_extra.nw


% where is defined _mainp? lib_core/libc/386/main9p.s
<<[[main()]] adjust INITENTRY if profiling>>=
if(debug['p'])
    INITENTRY = "_mainp";
@

% 8l -p -1
% after dostkoff(), before span() (matters?)
<<[[main()]] call doprofxxx() if profiling>>=
if(debug['p'])
    if(debug['1'])
        doprof1();
    else
        doprof2();
@

\section{[[__mcount[]]]}

% the idea o the code below is to add __mcount array, one index per function,
% and when call it increments the array at the right place.

% todo: who is using this information then? profreport of what?
% git grep __mcount does not seem to return stuff, maybe obsolete code?

<<function doprof1(arm)>>=
void
doprof1(void)
{
    Sym *s;
    long n;
    Prog *p, *q;

    DBG("%5.2f profile 1\n", cputime());
    s = lookup("__mcount", 0);
    n = 1;
    for(p = firstp->link; p != P; p = p->link) {
        if(p->as == ATEXT) {
            q = prg();
            q->line = p->line;
            q->link = datap;
            datap = q;
            q->as = ADATA;
            q->from.type = D_OREG;
            q->from.name = D_EXTERN;
            q->from.offset = n*4;
            q->from.sym = s;
            q->reg = 4;
            q->to = p->from;
            q->to.type = D_CONST;

            q = prg();
            q->line = p->line;
            q->pc = p->pc;
            q->link = p->link;
            p->link = q;
            p = q;
            p->as = AMOVW;
            p->from.type = D_OREG;
            p->from.name = D_EXTERN;
            p->from.sym = s;
            p->from.offset = n*4 + 4;
            p->to.type = D_REG;
            p->to.reg = REGTMP;

            q = prg();
            q->line = p->line;
            q->pc = p->pc;
            q->link = p->link;
            p->link = q;
            p = q;
            p->as = AADD;
            p->from.type = D_CONST;
            p->from.offset = 1;
            p->to.type = D_REG;
            p->to.reg = REGTMP;

            q = prg();
            q->line = p->line;
            q->pc = p->pc;
            q->link = p->link;
            p->link = q;
            p = q;
            p->as = AMOVW;
            p->from.type = D_REG;
            p->from.reg = REGTMP;
            p->to.type = D_OREG;
            p->to.name = D_EXTERN;
            p->to.sym = s;
            p->to.offset = n*4 + 4;

            n += 2;
            continue;
        }
    }
    q = prg();
    q->line = 0;
    q->link = datap;
    datap = q;

    q->as = ADATA;
    q->from.type = D_OREG;
    q->from.name = D_EXTERN;
    q->from.sym = s;
    q->reg = 4;
    q->to.type = D_CONST;
    q->to.offset = n;

    s->type = SBSS;
    s->value = n*4;
}
@


\section{[[_profin()]]}

% _profin() is defined by lib_core/libc/port/profile.c
% (_tracin() is defined by you)

% todo: why s2 and s4? why not sin, sout? and pin, pout?


<<global brcond(arm)>>=
static int brcond[] = {ABEQ, ABNE, ABCS, ABCC, ABMI, ABPL, ABVS, ABVC, ABHI, ABLS, ABGE, ABLT, ABGT, ABLE};
@

<<function doprof2(arm)>>=
void
doprof2(void)
{
    Sym *s2, *s4;
    Prog *p, *q, *q2;
    Prog *ps2, *ps4;

    DBG("%5.2f profile 2\n", cputime());

    <<[[doprof2()]] if embedded tracing>>
    else{
        s2 = lookup("_profin", 0);
        s4 = lookup("_profout", 0);
    }
    if(s2->type != STEXT || s4->type != STEXT) {
       <<[[doprof2()]] if embedded tracing diag()>>
        else
            diag("_profin/_profout not defined");
        return;
    }

    // finding ps2, ps4 = instruction (Prog) of s2 and s4
    ps2 = P;
    ps4 = P;
    for(p = firstp; p != P; p = p->link) {
        if(p->as == ATEXT) {
            if(p->from.sym == s2) {
                ps2 = p;
                p->reg = 1;
            }
            if(p->from.sym == s4) {
                ps4 = p;
                p->reg = 1;
            }
        }
    }
    for(p = firstp; p != P; p = p->link) {
        if(p->as == ATEXT) {

            <<[[doprof2()]] if NOPROF p(arm)>>

            /*
             * BL	profin
             */
            q = prg();
            q->line = p->line;
            q->pc = p->pc;
            q->link = p->link;

            <<[[doprof2()]] if embedded tracing ATEXT instrumentation(arm)>>
            else
                p->link = q;
            p = q;
            p->as = ABL;
            p->to.type = D_BRANCH;
            p->cond = ps2;
            p->to.sym = s2;

            continue;
        }
        if(p->as == ARET) {
            <<[[doprof2()]] if embedded tracing ARET instrumentation>>
            /*
             * RET
             */
            q = prg();
            q->as = ARET;
            q->from = p->from;
            q->to = p->to;
            q->cond = p->cond;
            q->link = p->link;
            q->reg = p->reg;
            p->link = q;

            if(p->scond != 14) {
                q = prg();
                q->as = ABL;
                q->from = zprg.from;
                q->to = zprg.to;
                q->to.type = D_BRANCH;
                q->cond = ps4;
                q->to.sym = s4;
                q->link = p->link;
                p->link = q;

                p->as = brcond[p->scond^1];	/* complement */
                p->scond = 14;
                p->from = zprg.from;
                p->to = zprg.to;
                p->to.type = D_BRANCH;
                p->cond = q->link->link;	/* successor of RET */
                p->to.offset = q->link->link->pc;

                p = q->link->link;
            } else {

                /*
                 * BL	profout
                 */
                p->as = ABL;
                p->from = zprg.from;
                p->to = zprg.to;
                p->to.type = D_BRANCH;
                p->cond = ps4;
                p->to.sym = s4;
                p->scond = 14;

                p = q;
            }
            continue;
        }
    }
}
@



\section{[[_tracin()]]}

% -p -e, -e for embedded tracing

<<[[doprof2()]] if embedded tracing>>=
if(debug['e']){
    s2 = lookup("_tracein", 0);
    s4 = lookup("_traceout", 0);
}
@

<<[[doprof2()]] if embedded tracing diag()>>=
if(debug['e'])
    diag("_tracein/_traceout not defined %d %d", s2->type, s4->type);
@


<<[[doprof2()]] if embedded tracing ATEXT instrumentation(arm)>>=
if(debug['e']){		/* embedded tracing */
    q2 = prg();
    p->link = q2;
    q2->link = q;

    q2->line = p->line;
    q2->pc = p->pc;

    q2->as = AB;
    q2->to.type = D_BRANCH;
    q2->to.sym = p->to.sym;
    q2->cond = q->link;
}
@

<<[[doprof2()]] if embedded tracing ARET instrumentation>>=
/*
 * RET (default)
 */
if(debug['e']){		/* embedded tracing */
    q = prg();
    q->line = p->line;
    q->pc = p->pc;
    q->link = p->link;
    p->link = q;
    p = q;
}
@

\section{[[NOPROF]] attribute}

% from Assembler_extra.nw

<<[[doprof2()]] if NOPROF p(arm)>>=
if(p->reg & NOPROF) {
    for(;;) {
        q = p->link;
        if(q == P)
            break;
        if(q->as == ATEXT)
            break;
        p = q;
    }
    continue;
}
@


\chapter{Nuxiinit ???}

%???

<<global inuxi1>>=
char	inuxi1[1];
@

<<global inuxi2>>=
char	inuxi2[2];
@

<<global inuxi4>>=
char	inuxi4[4];
@




<<global fnuxi4>>=
char	fnuxi4[4];
@

<<global fnuxi8>>=
char	fnuxi8[8];
@


<<function nuxiinit(arm)>>=
void
nuxiinit(void)
{

    int i, c;

    for(i=0; i<4; i++) {
        c = find1(0x04030201L, i+1);
        if(i < 2)
            inuxi2[i] = c;
        if(i < 1)
            inuxi1[i] = c;
        inuxi4[i] = c;
        fnuxi4[i] = c;
        if(debug['d'] == 0){
            fnuxi8[i] = c;
            fnuxi8[i+4] = c+4;
        }
        else{
            fnuxi8[i] = c+4;		/* ms word first, then ls, even in little endian mode */
            fnuxi8[i+4] = c;
        }
    }
    if(debug['v']) {
        Bprint(&bso, "inuxi = ");
        for(i=0; i<1; i++)
            Bprint(&bso, "%d", inuxi1[i]);
        Bprint(&bso, " ");
        for(i=0; i<2; i++)
            Bprint(&bso, "%d", inuxi2[i]);
        Bprint(&bso, " ");
        for(i=0; i<4; i++)
            Bprint(&bso, "%d", inuxi4[i]);
        Bprint(&bso, "\nfnuxi = ");
        for(i=0; i<4; i++)
            Bprint(&bso, "%d", fnuxi4[i]);
        Bprint(&bso, " ");
        for(i=0; i<8; i++)
            Bprint(&bso, "%d", fnuxi8[i]);
        Bprint(&bso, "\n");
    }
    Bflush(&bso);
}
@




<<function find1>>=
int
find1(long l, int c)
{
    char *p;
    int i;

    p = (char*)&l;
    for(i=0; i<4; i++)
        if(*p++ == c)
            return i;
    return 0;
}
@



\chapter{[[libmach/]]}

% a bit reverse of linker. linker actually does not use libmach/,
% but the debugger/profiler/emulator do.

% read .o (objects), read .out (binaries)


<<struct Fhdr>>=
/*
 *	Common a.out header describing all architectures
 */
typedef struct Fhdr
{
    char	*name;		/* identifier of executable */
    byte	type;		/* file type - see codes above */
    byte	hdrsz;		/* header size */
    byte	_magic;		/* _MAGIC() magic */
    byte	spare;

    long	magic;		/* magic number */

    uvlong	txtaddr;	/* text address */
    vlong	txtoff;		/* start of text in file */
    uvlong	dataddr;	/* start of data segment */
    vlong	datoff;		/* offset to data seg in file */
    vlong	symoff;		/* offset of symbol table in file */

    uvlong	entry;		/* entry point */

    vlong	sppcoff;	/* offset of sp-pc table in file */
    vlong	lnpcoff;	/* offset of line number-pc table in file */

    long	txtsz;		/* text size */
    long	datsz;		/* size of data seg */
    long	bsssz;		/* size of bss */

    long	symsz;		/* size of symbol table */
    long	sppcsz;		/* size of sp-pc table */
    long	lnpcsz;		/* size of line number-pc table */

} Fhdr;
@

\chapter{Utilities}

\section{[[size]]}

% errort (0 is ok)
<<function size>>=
int
size(char *file)
{
    fdt fd;
    Fhdr f;

    if((fd = open(file, OREAD)) < 0){
        fprint(2, "size: ");
        perror(file);
        return 1;
    }
    if(crackhdr(fd, &f)) {
        print("%ldt + %ldd + %ldb = %ld\t%s\n", f.txtsz, f.datsz,
            f.bsssz, f.txtsz+f.datsz+f.bsssz, file);
        close(fd);
        return 0;
    }
    fprint(2, "size: %s not an a.out\n", file);
    close(fd);
    return 1;
}
@

<<function main (linkers/misc/size.c)>>=
void
main(int argc, char *argv[])
{
    char *err;
    int i;

    ARGBEGIN {
    default:
        fprint(2, "usage: size [a.out ...]\n");
        exits("usage");
    } ARGEND;

    err = nil;
    if(argc == 0)
        if(size("8.out"))
            err = "error";
    for(i=0; i<argc; i++)
        if(size(argv[i]))
            err = "error";
    exits(err);
}
@

\section{[[nm]]}

\section{[[ar]]}

\section{[[strip]]}

\chapter{Advanced Topics}

\section{Overriding symbols, [[DUPOK]]}

% case in kernel where override a previous symbol,
% e.g. sysfatal, werrstr

% DUPOK, x.scale & DUPOK

\section{Export table}

% what this is for?

<<global doexp>>=
// do export table, -x
bool	doexp;
@




<<[[main()]] command line processing(arm)>>=
case 'x':	/* produce export table */
    doexp = true;
    if(argv[1] != nil && argv[1][0] != '-' && !isobjfile(argv[1]))
        readundefs(ARGF(), SEXPORT);
    break;
@
%in x86 there is also that
%        a = ARGF();
%        if(strcmp(a, "*") == 0)
%            allexport = true;
%        else

<<function isobjfile>>=
static int
isobjfile(char *f)
{
    int n, v;
    Biobuf *b;
    char buf1[5], buf2[SARMAG];

    b = Bopen(f, OREAD);
    if(b == nil)
        return 0;
    n = Bread(b, buf1, 5);
    if(n == 5 && (buf1[2] == 1 && buf1[3] == '<' || buf1[3] == 1 && buf1[4] == '<'))
        v = 1;	/* good enough for our purposes */
    else{
        Bseek(b, 0, 0);
        n = Bread(b, buf2, SARMAG);
        v = n == SARMAG && strncmp(buf2, ARMAG, SARMAG) == 0;
    }
    Bterm(b);
    return v;
}
@


<<global EXPTAB>>=
char*	EXPTAB;
@


<<[[main()]] if export table or dynamic module(arm)>>=
if(doexp || dlm){
    EXPTAB = "_exporttab";
    zerosig(EXPTAB);
    zerosig("etext");
    zerosig("edata");
    zerosig("end");

    <<[[main()]] if dynamic module(arm)>>
    else
        divsig();

    export();
}
@



<<function zerosig>>=
void
zerosig(char *sp)
{
    Sym *s;

    s = lookup(sp, 0);
    s->sig = 0;
}
@



<<global nimports>>=
int nimports;
@

<<global nexports>>=
int nexports;
@

<<global imports>>=
int	imports;
@

<<global exports>>=
int	exports;
@




<<function readundefs>>=
void
readundefs(char *f, int t)
{
    int i, n;
    Sym *s;
    Biobuf *b;
    char *l, buf[256], *fields[64];

    if(f == nil)
        return;
    b = Bopen(f, OREAD);
    if(b == nil){
        diag("could not open %s: %r", f);
        errorexit();
    }
    while((l = Brdline(b, '\n')) != nil){
        n = Blinelen(b);
        if(n >= sizeof(buf)){
            diag("%s: line too long", f);
            errorexit();
        }
        memmove(buf, l, n);
        buf[n-1] = '\0';
        n = getfields(buf, fields, nelem(fields), 1, " \t\r\n");
        if(n == nelem(fields)){
            diag("%s: bad format", f);
            errorexit();
        }
        for(i = 0; i < n; i++){
            s = lookup(fields[i], 0);
            s->type = SXREF;
            s->subtype = t;
            if(t == SIMPORT)
                nimports++;
            else
                nexports++;
        }
    }
    Bterm(b);
}
@




<<function export(arm)>>=
void
export(void)
{
    int i, j, n, off, nb, sv, ne;
    Sym *s, *et, *str, **esyms;
    Prog *p;
    char buf[NSNAME], *t;

    n = 0;
    for(i = 0; i < NHASH; i++)
        for(s = hash[i]; s != S; s = s->link)
            if(s->sig != 0 && s->type != SXREF && s->type != SUNDEF && (nexports == 0 || s->subtype == SEXPORT))
                n++;
    esyms = malloc(n*sizeof(Sym*));
    ne = n;
    n = 0;
    for(i = 0; i < NHASH; i++)
        for(s = hash[i]; s != S; s = s->link)
            if(s->sig != 0 && s->type != SXREF && s->type != SUNDEF && (nexports == 0 || s->subtype == SEXPORT))
                esyms[n++] = s;
    for(i = 0; i < ne-1; i++)
        for(j = i+1; j < ne; j++)
            if(strcmp(esyms[i]->name, esyms[j]->name) > 0){
                s = esyms[i];
                esyms[i] = esyms[j];
                esyms[j] = s;
            }

    nb = 0;
    off = 0;
    et = lookup(EXPTAB, 0);
    if(et->type != 0 && et->type != SXREF)
        diag("%s already defined", EXPTAB);
    et->type = SDATA;
    str = lookup(".string", 0);
    if(str->type == 0)
        str->type = SDATA;
    sv = str->value;
    for(i = 0; i < ne; i++){
        s = esyms[i];
        Bprint(&bso, "EXPORT: %s sig=%lux t=%d\n", s->name, s->sig, s->type);

        /* signature */
        p = newdata(et, off, sizeof(long), D_EXTERN);
        off += sizeof(long);
        p->to.offset = s->sig;

        /* address */
        p = newdata(et, off, sizeof(long), D_EXTERN);
        off += sizeof(long);
        p->to.name = D_EXTERN;
        p->to.sym = s;

        /* string */
        t = s->name;
        n = strlen(t)+1;
        for(;;){
            buf[nb++] = *t;
            sv++;
            if(nb >= NSNAME){
                p = newdata(str, sv-NSNAME, NSNAME, D_STATIC);
                p->to.type = D_SCONST;
                p->to.sval = malloc(NSNAME);
                memmove(p->to.sval, buf, NSNAME);
                nb = 0;
            }
            if(*t++ == 0)
                break;
        }

        /* name */
        p = newdata(et, off, sizeof(long), D_EXTERN);
        off += sizeof(long);
        p->to.name = D_STATIC;
        p->to.sym = str;
        p->to.offset = sv-n;
    }

    if(nb > 0){
        p = newdata(str, sv-nb, nb, D_STATIC);
        p->to.type = D_SCONST;
        p->to.sval = malloc(NSNAME);
        memmove(p->to.sval, buf, nb);
    }

    for(i = 0; i < 3; i++){
        newdata(et, off, sizeof(long), D_EXTERN);
        off += sizeof(long);
    }
    et->value = off;
    if(sv == 0)
        sv = 1;
    str->value = sv;
    exports = ne;
    free(esyms);
}
@




<<function newdata(arm)>>=
static Prog*
newdata(Sym *s, int o, int w, int t)
{
    Prog *p;

    p = prg();
    p->link = datap;
    datap = p;
    p->as = ADATA;
    p->reg = w;
    p->from.type = D_OREG;
    p->from.name = t;
    p->from.sym = s;
    p->from.offset = o;
    p->to.type = D_CONST;
    p->to.name = D_NONE;
    return p;
}
@



\section{Dynamic loading}
% been disabled? can not find man page for dynld anymore, nor dynld.h

<<global dlm>>=
bool dlm;
@



<<[[main()]] command line processing(arm)>>=
case 'u':	/* produce dynamically loadable module */
    dlm = true;
    if(argv[1] != nil && argv[1][0] != '-' && !isobjfile(argv[1]))
        readundefs(ARGF(), SIMPORT);
    break;
@
%x86 had this too:
%    // do not load standard libraries
%    debug['l'] = true;


<<[[asmb()]] if dynamic module magic header adjustment(arm)>>=
if(dlm)
    lput(0x80000000|0x647);	/* magic */
@




% import(), pending of export() ?

<<[[main()]] if dynamic module(arm)>>=
if(dlm){
    initdiv();
    import();
    HEADTYPE = H_PLAN9;
    INITTEXT = INITDAT = 0;
    INITRND = 8;
    INITENTRY = EXPTAB;
}
@




<<function import(arm)>>=
void
import(void)
{
    int i;
    Sym *s;

    for(i = 0; i < NHASH; i++)
        for(s = hash[i]; s != S; s = s->link)
            if(s->sig != 0 && s->type == SXREF && (nimports == 0 || s->subtype == SIMPORT)){
                undefsym(s);
                Bprint(&bso, "IMPORT: %s sig=%lux v=%ld\n", s->name, s->sig, s->value);
            }
}
@

%on x86 additiona check and features, integrate them?
%                if(s->value != 0)
%                    diag("value != 0 on SXREF");
%                undefsym(s);
%                if(debug['X'])
%                    Bprint(&bso, "IMPORT: %s sig=%lux v=%ld\n", s->name, s->sig, s->value);
%                if(debug['S'])
%                    s->sig = 0;


<<enum rxxx>>=
enum rxxx {
    Roffset	= 22,		/* no. bits for offset in relocation address */
    Rindex	= 10,		/* no. bits for index in relocation address */
};
@

% import -> undefsym
<<function undefsym>>=
void
undefsym(Sym *s)
{
    int n;

    n = imports;
    if(s->value != 0)
        diag("value != 0 on SXREF");
    if(n >= 1<<Rindex)
        diag("import index %d out of range", n);
    s->value = n<<Roffset;
    s->type = SUNDEF;
    imports++;
}
@
%>> >>



% port to arm?
%<<[[asmb()]] if dynamic module, when iterate from firstp(x86)>>=
%if(dlm) {
%    if(p->as == ATEXT)
%        reloca = nil;
%    else if(reloca != nil)
%        diag("reloc failure: %P", curp);
%}
%@


% ???
<<[[asmb()]] if dynamic module, before datblk()>>=
if(dlm){
    char buf[8];

    write(cout, buf, INITDAT-textsize);
    textsize = INITDAT;
}
@

<<[[asmb()]] if dynamic module and no symbol table generation>>=
if(dlm){
    seek(cout, HEADR+textsize+datsize, 0);
    asmdyn();
    cflush();
}
@


<<[[entryvalue()]] if dynamic module case>>=
case SDATA:
    if(dlm)
        return s->value+INITDAT;
@





<<struct Reloc>>=
struct Reloc
{
    int n;
    int t;
    byte *m;
    ulong *a;
};
@

<<global rels>>=
Reloc rels;
@



<<[[asmb()]] if dynamic module, call asmdyn()>>=
if(dlm)
    asmdyn();
@

% asmb() -> asmdyn()

<<function asmdyn>>=
void
asmdyn()
{
    int i, n, t, c;
    Sym *s;
    ulong la, ra, *a;
    vlong off;
    byte *m;
    Reloc *r;

    cflush();
    off = seek(cout, 0, 1);
    lput(0);
    t = 0;
    lput(imports);
    t += 4;
    for(i = 0; i < NHASH; i++)
        for(s = hash[i]; s != S; s = s->link)
            if(s->type == SUNDEF){
                lput(s->sig);
                t += 4;
                t += sput(s->name);
            }

    la = 0;
    r = &rels;
    n = r->n;
    m = r->m;
    a = r->a;
    lput(n);
    t += 4;
    for(i = 0; i < n; i++){
        ra = *a-la;
        if(*a < la)
            diag("bad relocation order");
        if(ra < 256)
            c = 0;
        else if(ra < 65536)
            c = 1;
        else
            c = 2;
        cput((c<<6)|*m++);
        t++;
        if(c == 0){
            cput(ra);
            t++;
        }
        else if(c == 1){
            wput(ra);
            t += 2;
        }
        else{
            lput(ra);
            t += 4;
        }
        la = *a++;
    }

    cflush();
    seek(cout, off, 0);
    lput(t);

    DBG("import table entries = %d\n", imports);
    DBG("export table entries = %d\n", exports);
}
@
% >> >>



<<global modemap>>=
int modemap[4] = { 0, 1, -1, 2, };
@


<<[[datblk()]] if dynamic module(arm)>>=
if(dlm)
    dynreloc(v, a+INITDAT, 1);
@


<<function dynreloc(arm)>>=
void
dynreloc(Sym *s, long v, int abs)
{
    int i, k, n;
    byte *m;
    ulong *a;
    Reloc *r;

    if(v&3)
        diag("bad relocation address");
    v >>= 2;

    if(s != S && s->type == SUNDEF)
        k = abs ? ABSU : RELU;
    else
        k = abs ? ABSD : RELD;
    /* Bprint(&bso, "R %s a=%ld(%lx) %d\n", s->name, a, a, k); */
    k = modemap[k];
    r = &rels;
    n = r->n;
    if(n >= r->t)
        grow(r);
    m = r->m;
    a = r->a;
    for(i = n; i > 0; i--){
        if(v < a[i-1]){	/* happens occasionally for data */
            m[i] = m[i-1];
            a[i] = a[i-1];
        }
        else
            break;
    }
    m[i] = k;
    a[i] = v;
    r->n++;
}
@
% the align 4 check at the beginning are ARM specific

<<function grow>>=
static void
grow(Reloc *r)
{
    int t;
    byte *m, *nm;
    ulong *a, *na;

    t = r->t;
    r->t += 64;
    m = r->m;
    a = r->a;
    r->m = nm = malloc(r->t*sizeof(byte));
    r->a = na = malloc(r->t*sizeof(ulong));
    memmove(nm, m, t*sizeof(byte));
    memmove(na, a, t*sizeof(ulong));
    free(m);
    free(a);
}
@


\section{Float}

% 8.out.h

<<function ieeedtof>>=
long
ieeedtof(Ieee *e)
{
    int exp;
    long v;

    if(e->h == 0)
        return 0;
    exp = (e->h>>20) & ((1L<<11)-1L);
    exp -= (1L<<10) - 2L;
    v = (e->h & 0xfffffL) << 3;
    v |= (e->l >> 29) & 0x7L;
    if((e->l >> 28) & 1) {
        v++;
        if(v & 0x800000L) {
            v = (v & 0x7fffffL) >> 1;
            exp++;
        }
    }
    if(exp <= -126 || exp >= 130)
        diag("double fp to single fp overflow");
    v |= ((exp + 126) & 0xffL) << 23;
    v |= e->h & 0x80000000L;
    return v;
}
@

<<function ieeedtod>>=
double
ieeedtod(Ieee *ieeep)
{
    Ieee e;
    double fr;
    int exp;

    if(ieeep->h & (1L<<31)) {
        e.h = ieeep->h & ~(1L<<31);
        e.l = ieeep->l;
        return -ieeedtod(&e);
    }
    if(ieeep->l == 0 && ieeep->h == 0)
        return 0;
    fr = ieeep->l & ((1L<<16)-1L);
    fr /= 1L<<16;
    fr += (ieeep->l>>16) & ((1L<<16)-1L);
    fr /= 1L<<16;
    fr += (ieeep->h & (1L<<20)-1L) | (1L<<20);
    fr /= 1L<<21;
    exp = (ieeep->h>>20) & ((1L<<11)-1L);
    exp -= (1L<<10) - 2L;
    return ldexp(fr, exp);
}
@





<<[[ldobj()]] switch as cases(x86)>>=
case AFMOVF:
case AFADDF:
case AFSUBF:
case AFSUBRF:
case AFMULF:
case AFDIVF:
case AFDIVRF:
case AFCOMF:
case AFCOMFP:
    if(skip)
        goto casdef;
    if(p->from.type == D_FCONST) {
        /* size sb 9 max */
        sprint(literal, "$%lux", ieeedtof(&p->from.ieee));
        s = lookup(literal, 0);
        if(s->type == 0) {
            s->type = SBSS;
            s->value = 4;
            t = prg();
            t->as = ADATA;
            t->line = p->line;
            t->from.type = D_EXTERN;
            t->from.sym = s;
            t->from.scale = 4;  // NOSPLIT?
            t->to = p->from;
            if(edatap == P)
                datap = t;
            else
                edatap->link = t;
            edatap = t;
            t->link = P;
        }
        p->from.type = D_EXTERN;
        p->from.sym = s;
        p->from.offset = 0;
    }
    goto casdef;
@
%$

<<[[ldobj()]] switch as cases(x86)>>=
case AFMOVD:
case AFADDD:
case AFSUBD:
case AFSUBRD:
case AFMULD:
case AFDIVD:
case AFDIVRD:
case AFCOMD:
case AFCOMDP:
    if(skip)
        goto casdef;
    if(p->from.type == D_FCONST) {
        /* size sb 18 max */
        sprint(literal, "$%lux.%lux",
            p->from.ieee.l, p->from.ieee.h);
        s = lookup(literal, 0);
        if(s->type == 0) {
            s->type = SBSS;
            s->value = 8;
            t = prg();
            t->as = ADATA;
            t->line = p->line;
            t->from.type = D_EXTERN;
            t->from.sym = s;
            t->from.scale = 8;
            t->to = p->from;
            if(edatap == P)
                datap = t;
            else
                edatap->link = t;
            edatap = t;
            t->link = P;
        }
        p->from.type = D_EXTERN;
        p->from.sym = s;
        p->from.offset = 0;
    }
    goto casdef;
@
%$


\section{Extra executable formats}

<<[[main()]] switch HEADTYPE cases(arm)>>=
case 0:	/* no header */
case 6:	/* no header, padded segments */
    HEADR = 0L;
    if(INITTEXT == -1)
        INITTEXT = 0;
    if(INITDAT == -1)
        INITDAT = 0;
    if(INITRND == -1)
        INITRND = 4;
    break;
case 1:	/* aif for risc os */
    HEADR = 128L;
    if(INITTEXT == -1)
        INITTEXT = 0x10005000 + HEADR;
    if(INITDAT == -1)
        INITDAT = 0;
    if(INITRND == -1)
        INITRND = 4;
    break;
case 3:	/* boot for NetBSD */
    HEADR = 32L;
    if(INITTEXT == -1)
        INITTEXT = 0xF0000020L;
    if(INITDAT == -1)
        INITDAT = 0;
    if(INITRND == -1)
        INITRND = 4096;
    break;
case 4: /* boot for IXP1200 */
    HEADR = 0L;
    if(INITTEXT == -1)
        INITTEXT = 0x0;
    if(INITDAT == -1)
        INITDAT = 0;
    if(INITRND == -1)
        INITRND = 4;
    break;
case 5: /* boot for ipaq */
    HEADR = 16L;
    if(INITTEXT == -1)
        INITTEXT = 0xC0008010;
    if(INITDAT == -1)
        INITDAT = 0;
    if(INITRND == -1)
        INITRND = 1024;
    break;
case 7:	/* elf executable */
    HEADR = rnd(Ehdr32sz+3*Phdr32sz, 16);
    if(INITTEXT == -1)
        INITTEXT = 4096+HEADR;
    if(INITDAT == -1)
        INITDAT = 0;
    if(INITRND == -1)
        INITRND = 4;
    break;
@

<<[[asmb()]] switch HEADTYPE (to position after text) cases(arm)>>=
case 0:
case 1:
case 5:
case 7:
    OFFSET = HEADR+textsize;
    seek(cout, OFFSET, 0);
    break;
case 3:
case 6:	/* no header, padded segments */
    OFFSET = rnd(HEADR+textsize, 4096);
    seek(cout, OFFSET, 0);
    break;
@
<<[[asmb()]] switch HEADTYPE (for symbol table generation) cases(arm)>>=
case 0:
case 1:
case 4:
case 5:
    debug['s'] = 1;
    break;
case 3:
case 6:	/* no header, padded segments */
    OFFSET += rnd(datsize, 4096);
    seek(cout, OFFSET, 0);
    break;
case 7:
    break;
@

<<[[asmb()]] switch HEADTYPE (for header generation) cases(arm)>>=
case 0:	/* no header */
case 6:	/* no header, padded segments */
    break;
case 1:	/* aif for risc os */
    lputl(0xe1a00000);		/* NOP - decompress code */
    lputl(0xe1a00000);		/* NOP - relocation code */
    lputl(0xeb000000 + 12);		/* BL - zero init code */
    lputl(0xeb000000 +
        (entryvalue()
         - INITTEXT
         + HEADR
         - 12
         - 8) / 4);		/* BL - entry code */

    lputl(0xef000011);		/* SWI - exit code */
    lputl(textsize+HEADR);		/* text size */
    lputl(datsize);			/* data size */
    lputl(0);			/* sym size */

    lputl(bsssize);			/* bss size */
    lputl(0);			/* sym type */
    lputl(INITTEXT-HEADR);		/* text addr */
    lputl(0);			/* workspace - ignored */

    lputl(32);			/* addr mode / data addr flag */
    lputl(0);			/* data addr */
    for(t=0; t<2; t++)
        lputl(0);		/* reserved */

    for(t=0; t<15; t++)
        lputl(0xe1a00000);	/* NOP - zero init code */
    lputl(0xe1a0f00e);		/* B (R14) - zero init return */
    break;
case 3:	/* boot for NetBSD */
    lput((143<<16)|0413);		/* magic */
    lputl(rnd(HEADR+textsize, 4096));
    lputl(rnd(datsize, 4096));
    lputl(bsssize);
    lputl(symsize);			/* nsyms */
    lputl(entryvalue());		/* va of entry */
    lputl(0L);
    lputl(0L);
    break;
case 4: /* boot for IXP1200 */
    break;
case 5: /* boot for ipaq */
    lputl(0xe3300000);		/* nop */
    lputl(0xe3300000);		/* nop */
    lputl(0xe3300000);		/* nop */
    lputl(0xe3300000);		/* nop */
    break;
case 7:	/* elf */
    debug['S'] = 1;			/* symbol table */
    elf32(ARM, ELFDATA2LSB, 0, nil);
    break;
@


\subsection{Elf}

% start text physical address (elf only)
<<global INITTEXTP>>=
long	INITTEXTP = -1; /* text location (physical) */
@


<<[[main()]] command line processing(arm)>>=
case 'P':
    a = ARGF();
    if(a)
        INITTEXTP = atolwhex(a);
    break;
@

<<enum _anon_ (linkers/8l/elf.h)>>=
enum {
    Ehdr32sz	= 52,
    Phdr32sz	= 32,
    Shdr32sz	= 40,

    Ehdr64sz	= 64,
    Phdr64sz	= 56,
    Shdr64sz	= 64,
};
@

\subsection{OMach}

%\subsection{PE}
% windows format, see pe.h in golang/src/libmach/

\section{[[8l -E digits]]}

<<[[main()]] if digit INITENTRY>>=
if(!(*INITENTRY >= '0' && *INITENTRY <= '9'))
   lookup(INITENTRY, 0)->type = SXREF;
@
% 0_9 initentry means something special?

<<[[entryvalue()]] if digit INITENTRY>>=
if(*a >= '0' && *a <= '9')
    return atolwhex(a);
@



\chapter{Conclusion}












\appendix

\chapter{Debugging}

\section{[[debug]]}

% hmm actually it's used not just for debugging but also for generic
% options, e.g. for -l, -p, etc in addition to the main use which is -v
<<global debug>>=
bool	debug[128];
@
% why not 256 like in Assembler.nw?


% -A, see diag()

%bso? 
<<global bso>>=
Biobuf	bso;
@




<<[[main()]] debug initialization(arm)>>=
Binit(&bso, 1, OWRITE);
listinit(); // fmtinstall()
@
%x86: memset(debug, false, sizeof(debug));

<<[[main()]] command line processing(arm)>>=
default:
    c = ARGC();
    if(c >= 0 && c < sizeof(debug))
        debug[c]++;
    break;
@

\section{Fmt}
% dupe with Compiler.nw

% why called listinit??

<<function prasm(arm)>>=
void
prasm(Prog *p)
{
    print("%P\n", p);
}
@


<<function listinit(arm)>>=
void
listinit(void)
{

    fmtinstall('A', Aconv);
    fmtinstall('C', Cconv);
    fmtinstall('D', Dconv);
    fmtinstall('P', Pconv);
    fmtinstall('S', Sconv);
    fmtinstall('N', Nconv);
}
@

<<function Nconv(arm)>>=
int
Nconv(Fmt *fp)
{
    char str[STRINGSZ];
    Adr *a;
    Sym *s;

    a = va_arg(fp->args, Adr*);
    s = a->sym;

    switch(a->name) {
    case N_NONE:
        sprint(str, "%ld", a->offset);
        break;

    case D_EXTERN:
        if(s == S)
            sprint(str, "%ld(SB)", a->offset);
        else
            sprint(str, "%s+%ld(SB)", s->name, a->offset);
        break;

    case D_STATIC:
        if(s == S)
            sprint(str, "<>+%ld(SB)", a->offset);
        else
            sprint(str, "%s<>+%ld(SB)", s->name, a->offset);
        break;

    case D_AUTO:
        if(s == S)
            sprint(str, "%ld(SP)", a->offset);
        else
            sprint(str, "%s-%ld(SP)", s->name, -a->offset);
        break;

    case D_PARAM:
        if(s == S)
            sprint(str, "%ld(FP)", a->offset);
        else
            sprint(str, "%s+%ld(FP)", s->name, a->offset);
        break;
    default:
        sprint(str, "GOK-name(%d)", a->name);
        break;

    }
    return fmtstrcpy(fp, str);
}
@




<<global strcond(arm)>>=
char*	strcond[16] =
{
    ".EQ",
    ".NE",
    ".HS",
    ".LO",
    ".MI",
    ".PL",
    ".VS",
    ".VC",
    ".HI",
    ".LS",
    ".GE",
    ".LT",
    ".GT",
    ".LE",
    "",
    ".NV"
};
@

<<function Cconv(arm)>>=
int
Cconv(Fmt *fp)
{
    char s[20];
    int c;

    c = va_arg(fp->args, int);
    strcpy(s, strcond[c & C_SCOND]);
    if(c & C_SBIT)
        strcat(s, ".S");
    if(c & C_PBIT)
        strcat(s, ".P");
    if(c & C_WBIT)
        strcat(s, ".W");
    if(c & C_UBIT)		/* ambiguous with FBIT */
        strcat(s, ".U");
    return fmtstrcpy(fp, s);
}
@





% defined in ../5c/enam.c, coupling with enum as in 5.out.h
% extern	char*	anames[];




<<function Aconv(arm)>>=
// enum<opcode> -> string
int
Aconv(Fmt *fp)
{
    char *s;
    int a;

    a = va_arg(fp->args, int);
    s = "???";
    if(a >= AXXX && a < ALAST)
        s = anames[a];
    return fmtstrcpy(fp, s);
}
@





<<constant STRINGSZ>>=
STRINGSZ	= 200,
@


<<function Pconv(arm)>>=
// Prog -> string
int
Pconv(Fmt *fp)
{
    char str[STRINGSZ], *s;
    Prog *p;
    int a;

    p = va_arg(fp->args, Prog*);
    curp = p;
    a = p->as;

    switch(a) {
    case ASWPW:
    case ASWPBU:
        sprint(str, "(%ld)	%A%C	R%d,%D,%D",
            p->line, a, p->scond, p->reg, &p->from, &p->to);
        break;

    case ADATA:
    case AINIT:
    case ADYNT:
        sprint(str, "(%ld)	%A%C	%D/%d,%D",
            p->line, a, p->scond, &p->from, p->reg, &p->to);
        break;

    default:
        s = str;
        s += sprint(s, "(%ld)", p->line);
        if(p->reg == NREG)
            sprint(s, "	%A%C	%D,%D",
                a, p->scond, &p->from, &p->to);
        else
        if(p->from.type != D_FREG)
            sprint(s, "	%A%C	%D,R%d,%D",
                a, p->scond, &p->from, p->reg, &p->to);
        else
            sprint(s, "	%A%C	%D,F%d,%D",
                a, p->scond, &p->from, p->reg, &p->to);
        break;

    }
    return fmtstrcpy(fp, str);
}
@





<<function Dconv(arm)>>=
// Adr -> string
int
Dconv(Fmt *fp)
{
    char str[STRINGSZ];
    char *op;
    Adr *a;
    long v;

    a = va_arg(fp->args, Adr*);
    switch(a->type) {

    case D_NONE:
        str[0] = 0;
        if(a->name != D_NONE || a->reg != NREG || a->sym != S)
            sprint(str, "%N(R%d)(NONE)", a, a->reg);
        break;

    case D_CONST:
        if(a->reg == NREG)
            sprint(str, "$%N", a);
        else
            sprint(str, "$%N(R%d)", a, a->reg);
        break;

    case D_SHIFT:
        v = a->offset;
        op = "<<>>->@>" + (((v>>5) & 3) << 1);
        if(v & (1<<4))
            sprint(str, "R%ld%c%cR%ld", v&15, op[0], op[1], (v>>8)&15);
        else
            sprint(str, "R%ld%c%c%ld", v&15, op[0], op[1], (v>>7)&31);
        if(a->reg != NREG)
            sprint(str+strlen(str), "(R%d)", a->reg);
        break;

    case D_OCONST:
        sprint(str, "$*$%N", a);
        if(a->reg != NREG)
            sprint(str, "%N(R%d)(CONST)", a, a->reg);
        break;

    case D_OREG:
        if(a->reg != NREG)
            sprint(str, "%N(R%d)", a, a->reg);
        else
            sprint(str, "%N", a);
        break;

    case D_REG:
        sprint(str, "R%d", a->reg);
        if(a->name != D_NONE || a->sym != S)
            sprint(str, "%N(R%d)(REG)", a, a->reg);
        break;

    case D_REGREG:
        sprint(str, "(R%d,R%d)", a->reg, (int)a->offset);
        if(a->name != D_NONE || a->sym != S)
            sprint(str, "%N(R%d)(REG)", a, a->reg);
        break;

    case D_FREG:
        sprint(str, "F%d", a->reg);
        if(a->name != D_NONE || a->sym != S)
            sprint(str, "%N(R%d)(REG)", a, a->reg);
        break;

    case D_PSR:
        switch(a->reg) {
        case 0:
            sprint(str, "CPSR");
            break;
        case 1:
            sprint(str, "SPSR");
            break;
        default:
            sprint(str, "PSR%d", a->reg);
            break;
        }
        if(a->name != D_NONE || a->sym != S)
            sprint(str, "%N(PSR%d)(REG)", a, a->reg);
        break;

    case D_FPCR:
        switch(a->reg){
        case 0:
            sprint(str, "FPSR");
            break;
        case 1:
            sprint(str, "FPCR");
            break;
        default:
            sprint(str, "FCR%d", a->reg);
            break;
        }
        if(a->name != D_NONE || a->sym != S)
            sprint(str, "%N(FCR%d)(REG)", a, a->reg);

        break;

    case D_BRANCH:	/* botch */
        if(curp->cond != P) {
            v = curp->cond->pc;
            if(a->sym != S)
                sprint(str, "%s+%.5lux(BRANCH)", a->sym->name, v);
            else
                sprint(str, "%.5lux(BRANCH)", v);
        } else
            if(a->sym != S)
                sprint(str, "%s+%ld(APC)", a->sym->name, a->offset);
            else
                sprint(str, "%ld(APC)", a->offset);
        break;

    case D_FCONST:
        sprint(str, "$%e", ieeedtod(a->ieee));
        break;

    case D_SCONST:
        sprint(str, "$\"%S\"", a->sval);
        break;

    default:
        sprint(str, "GOK-type(%d)", a->type);
        break;

    }
    return fmtstrcpy(fp, str);
}
@






<<function Sconv(arm)>>=
// ?? -> string
int
Sconv(Fmt *fp)
{
    int i, c;
    char str[STRINGSZ], *p, *a;

    a = va_arg(fp->args, char*);
    p = str;
    for(i=0; i<sizeof(long); i++) {
        c = a[i] & 0xff;
        if(c >= 'a' && c <= 'z' ||
           c >= 'A' && c <= 'Z' ||
           c >= '0' && c <= '9' ||
           c == ' ' || c == '%') {
            *p++ = c;
            continue;
        }
        *p++ = '\\';
        switch(c) {
        case 0:
            *p++ = 'z';
            continue;
        case '\\':
        case '"':
            *p++ = c;
            continue;
        case '\n':
            *p++ = 'n';
            continue;
        case '\t':
            *p++ = 't';
            continue;
        }
        *p++ = (c>>6) + '0';
        *p++ = ((c>>3) & 7) + '0';
        *p++ = (c & 7) + '0';
    }
    *p = 0;
    return fmtstrcpy(fp, str);
}
@


\section{[[5l -v]] and [[DBG()]]}

%used to have lots of code like:
%if(debug['v']) {
%    Bprint(&bso, "HEADER = -H0x%ld -T0x%lux -D0x%lux -R0x%lux\n",
%        HEADTYPE, INITTEXT, INITDAT, INITRND);
%    Bflush(&bso);
%}
% (The Bflush was outside the if, but makes more sense like this I think)
%but better to have a DBG macro for this

<<macro DBG>>=
#define DBG if(debug['v']) mylog
@

<<function log>>=
void mylog(char *fmt, ...) {

    va_list arg;

    va_start(arg, fmt);
    Bvprint(&bso, fmt, arg);
    va_end(arg);
    Bflush(&bso);
}
@

\section{[[5l -a]]}
% print object code in assembly language with addresses?

\section{[[5l -9 -B -9]]}
% dead?

<<constant DEFAULT>>=
#define	DEFAULT	'9'
@


% obsolete?
<<[[main()]] adjust HEADTYPE if debug flags(arm)>>=
if(!debug['9'] && !debug['U'] && !debug['B'])
    debug[DEFAULT] = true;

if(HEADTYPE == -1) {
    if(debug['U'])
        HEADTYPE = 0;
    if(debug['B'])
        HEADTYPE = 1;
    if(debug['9'])
        HEADTYPE = 2;
}
@


\chapter{Profiling}

% had lots of cputime() too in calls to DBG, so a form of profiling

<<[[main()]] profile report>>=
if(debug['v']) {
    Bprint(&bso, "%5.2f cpu time\n", cputime());
    Bprint(&bso, "%ld symbols\n", nsymbol);
    Bprint(&bso, "%ld memory used\n", thunk);
    Bprint(&bso, "%d sizeof adr\n", sizeof(Adr));
    Bprint(&bso, "%d sizeof prog\n", sizeof(Prog));
    Bflush(&bso);
}
@

\chapter{Error Managment}

<<global nerrors>>=
int	nerrors = 0;
@



<<function errorexit>>=
void
errorexit(void)
{

    if(nerrors) {
        if(cout >= 0)
            remove(outfile);
        exits("error");
    }
    exits(0);
}
@



% could use TNAME here too?
<<function diag>>=
void
diag(char *fmt, ...)
{
    char buf[STRINGSZ];
    char *tn;
    va_list arg;

    tn = "??none??";
    if(curtext != P && curtext->from.sym != S)
        tn = curtext->from.sym->name;
    va_start(arg, fmt);
    vseprint(buf, buf+sizeof(buf), fmt, arg);
    va_end(arg);
    print("%s: %s\n", tn, buf);

    nerrors++;
    if(nerrors > 20 && !debug['A']) {
        print("too many errors\n");
        errorexit();
    }
}
@
% ARM does not have the && !debug['A'], but probablt error no?


\chapter{Libc}

\section{Memory managmnent}
% same in Assembler

<<global hunk>>=
char*	hunk;
@



<<global nhunk>>=
long	nhunk;
@
% = 0??


<<global thunk>>=
long	thunk;
@


<<constant NHUNK linker>>=
NHUNK		= 100000,
@


% not sure why don't use libc malloc and do low-level sbrk ...
% to optimize things? as they do no free?
<<function gethunk>>=
void
gethunk(void)
{
    char *h;
    long nh;

    nh = NHUNK;
    if(thunk >= 5L*NHUNK) {
        nh = 5L*NHUNK;
        if(thunk >= 25L*NHUNK)
            nh = 25L*NHUNK;
    }
    h = sbrk(nh);
    if(h == (char*)-1) {
        diag("out of memory");
        errorexit();
    }
    hunk = h;
    nhunk = nh;
    thunk += nh;
}
@




<<function malloc>>=
/*
 * fake malloc
 */
void*
malloc(ulong n)
{
    void *p;

    // upper_round(n, 8)
    while(n & 7)
        n++;

    while(nhunk < n)
        gethunk();
    p = hunk;
    nhunk -= n;
    hunk += n;
    return p;
}
@




% no free ...  hmmm
<<function free>>=
void
free(void *p)
{
    USED(p);
}
@



% not sure why but if redefine malloc and free then have to
% redefine this func too, otherwise get a link error
<<function setmalloctag>>=
//@Scheck: looks dead, but because we redefine malloc/free we must also redefine that
void setmalloctag(void *v, ulong pc)
{
    USED(v, pc);
}
@


\section{Buffer managmnent}

<<function readsome>>=
byte*
readsome(int f, byte *buf, byte *good, byte *stop, int max)
{
    int n;

    n = stop - good;
    memmove(buf, good, stop - good);
    stop = buf + n;
    n = MAXIO - n;
    if(n > max)
        n = max;
    n = read(f, stop, n);
    if(n <= 0)
        return 0;
    return stop + n;
}
@



<<struct Buf>>=
union Buf
{
    struct
    {
        char	obuf[MAXIO];			/* output buffer */
        byte	ibuf[MAXIO];			/* input buffer */
    } u;
    char	dbuf[1];
};
@



<<global buf>>=
union Buf buf;
@



<<constant MAXIO>>=
MAXIO		= 8192,
@


<<constant cbuf>>=
#define	cbuf	u.obuf
@

<<constant xbuf>>=
#define	xbuf	u.ibuf
@


<<global cbc>>=
int	cbc;
@


<<global cbp>>=
char*	cbp;
@



<<function cput(arm)>>=
void
cput(int c)
{
    cbp[0] = c;
    cbp++;
    cbc--;
    if(cbc <= 0)
        cflush();
}
@
% mostly similar to x86, x86 is using a macro though

% in the end print in cout
<<function cflush>>=
void
cflush(void)
{
    int n;

    n = sizeof(buf.cbuf) - cbc;
    if(n)
        write(cout, buf.cbuf, n);
    cbp = buf.cbuf;
    cbc = sizeof(buf.cbuf);
}
@




% xxxl means left? little endian?


<<function wputl(arm)>>=
void
wputl(long l)
{

    cbp[0] = l;
    cbp[1] = l>>8;
    cbp += 2;
    cbc -= 2;
    if(cbc <= 0)
        cflush();
}
@
% the x86 version seems more logical, normal?


<<function wput(arm)>>=
void
wput(long l)
{

    cbp[0] = l>>8;
    cbp[1] = l;
    cbp += 2;
    cbc -= 2;
    if(cbc <= 0)
        cflush();
}
@



<<function lput(arm)>>=
void
lput(long l)
{

    cbp[0] = l>>24;
    cbp[1] = l>>16;
    cbp[2] = l>>8;
    cbp[3] = l;
    cbp += 4;
    cbc -= 4;
    if(cbc <= 0)
        cflush();
}
@



<<function lputl(arm)>>=
void
lputl(long l)
{

    cbp[3] = l>>24;
    cbp[2] = l>>16;
    cbp[1] = l>>8;
    cbp[0] = l;
    cbp += 4;
    cbc -= 4;
    if(cbc <= 0)
        cflush();
}
@


<<function llput>>=
void
llput(vlong v)
{
    lput(v>>32);
    lput(v);
}
@


<<function llputl>>=
void
llputl(vlong v)
{
    lputl(v);
    lputl(v>>32);
}
@




<<function strnput(arm)>>=
void
strnput(char *s, int n)
{
    for(; *s; s++){
        cput(*s);
        n--;
    }
    for(; n > 0; n--)
        cput(0);
}
@
% the x86 version is sligtly different

\section{File managment}

<<function fileexists>>=
int
fileexists(char *s)
{
    byte dirbuf[400];

    /* it's fine if stat result doesn't fit in dirbuf, since even then the file exists */
    return stat(s, dirbuf, sizeof(dirbuf)) >= 0;
}
@


\section{String processing}

% could be put in libc, with the other atoxxx
% atoxx? why a?
<<function atolwhex>>=
long
atolwhex(char *s)
{
    long n;
    int f;

    n = 0;
    f = 0;
    while(*s == ' ' || *s == '\t')
        s++;
    if(*s == '-' || *s == '+') {
        if(*s++ == '-')
            f = 1;
        while(*s == ' ' || *s == '\t')
            s++;
    }
    if(s[0]=='0' && s[1]){
        if(s[1]=='x' || s[1]=='X'){
            s += 2;
            for(;;){
                if(*s >= '0' && *s <= '9')
                    n = n*16 + *s++ - '0';
                else if(*s >= 'a' && *s <= 'f')
                    n = n*16 + *s++ - 'a' + 10;
                else if(*s >= 'A' && *s <= 'F')
                    n = n*16 + *s++ - 'A' + 10;
                else
                    break;
            }
        } else
            while(*s >= '0' && *s <= '7')
                n = n*8 + *s++ - '0';
    } else
        while(*s >= '0' && *s <= '9')
            n = n*10 + *s++ - '0';
    if(f)
        n = -n;
    return n;
}
@


\section{Mathematic functions}

<<function rnd>>=
long
rnd(long v, long r)
{
    long c;

    if(r <= 0)
        return v;
    v += r - 1;
    c = v % r;
    if(c < 0)
        c += r;
    v -= c;
    return v;
}
@


\chapter{Extra Code}

\ifallcode
#include "Linker_extra.nw"
\fi

\chapter{Changelog}
\label{sec:changelog}

\chapter{Glossary}
\label{sec:glossary}

\begin{verbatim}
\end{verbatim}

\chapter*{Indexes}
\addcontentsline{toc}{section}{Index}

%\chapter{References} 
\addcontentsline{toc}{section}{References}

\begin{thebibliography}{99}

\bibitem[1]{wp-literate-programming} Donald Knuth,,
{\em Literate Programming}, 
\url{http://en.wikipedia.org/wiki/Literate\_Program}

\bibitem[2]{noweb} Norman Ramsey,
{\em Noweb}, 
\url{http://www.cs.tufts.edu/~nr/noweb/}

\bibitem[3]{syncweb} Yoann Padioleau,
{\em Syncweb, literate programming meets unison}, 
\url{http://padator.org/software/project-syncweb/readme.txt}

\end{thebibliography}

%******************************************************************************
% Postlude
%******************************************************************************

\end{document}
