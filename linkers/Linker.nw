\documentclass[twocolumn, landscape]{report}

%******************************************************************************
% Prelude
%******************************************************************************
\newif\iffinal
\newif\ifverbose
\finaltrue\verbosefalse % see also other newif in Macros.tex

%------------------------------------------------------------------------------
%history:
%------------------------------------------------------------------------------

%thx to LP, changed for the better a few things:
% - introduced Headtype enum instead of hardcoded integers
% - introduced mylog() and DBG() to factorize the tracing code
% - removed many portable myxxx() wrappers
% - removed some deadcode 
%    * C_LBRA, C_LECON, C_SCON, D_OCONST, regused
%    * commented lots of code that was in dead ifdefs or was related to
%      dead alef features like BECOME
% - reorganized code
%    * around INITENTRY, -l, -E digit, make default path
%    * renames many local variables, more consistent (v = version, etc)
%    * mv Autom out of union, remove union, was confusing
% - TODO reorganized the code to better match the chapters
%    by introducing more files: main.c, lib.c, error.c, m.h

%thx to codemap/codegraph:
% - see subtle dependency to 8c/enam.c through anames

%thx to this manual, better understand linking:
% - that an object is really a module, the simplest/lowest module abstraction
%   with defs and uses to link together (for text and data).
% - that linker and loader are related by executable format and sections;
%   one generates data (the executable) that the other reads (the kernel)
% - disk image of executable and memory image of program are different
%   hence the -TText
% - mutual dependency between dotext and dodata where need layout
%   data before text but then need text before know where starts data
%   (solved via SB/R12 for 5l)
% - architecture constraints on immediate constants and offsets require
%   tricks in the linker such as pooling, SB/R12, BIG, special bootstrap
%   setR12 LCON, etc. (case also for x86?)
% - SEMI what if have multiple object defining the same global?
%   int x; int x; in different files? what if one also define value?
%   what if both define value? DUPOK?
% - TODO dynamic linking? export table? import table?
% - TODO fpic? 

%history LP-ization:
% - skeleton, mostly copy paste of Template.nw skeleton
% - put all content of files in the Extra section, via 'pfff -lpize'
%   which also now split in chunks!
%    * function, global, struct, enum, constant, macro(actually function)
%    * extra, other fields split
% - read Extra section, identify concepts, first TOC
% - distribute parts of the file before
% - understand main(), LP split main, improve TOC
% - understand main functions, LP split, cluster, improve TOC
% - LP split the structures, use datalog for flow to field info
% - SEMI nullify, boolify, typeify,    scheckify
% - aspectify advanced features!
% - SEMI add figures
% - SEMI add explanations

%------------------------------------------------------------------------------
% Packages
%------------------------------------------------------------------------------

\usepackage{../docs/latex/noweb}
 \noweboptions{footnotesizecode,nomargintag}
 %note: allow chunk on different pages, less white space at bottom of pages
 \def\nwendcode{\endtrivlist \endgroup}
 \let\nwdocspar=\par
\usepackage{xspace}
\usepackage{verbatim}
%note: required by noweblatexpad for the \t \l \n in this file
\usepackage{fancyvrb}
\usepackage{url}
\usepackage{hyperref}
 \hypersetup{colorlinks=true}
\usepackage[pageref]{backref}
 \def\backref{{\footnotesize cited page(s)}~}
\usepackage{booktabs} 
 \newcommand{\otoprule}{\midrule[\heavyrulewidth]}
\usepackage{graphicx}

%------------------------------------------------------------------------------
% Macros
%------------------------------------------------------------------------------
\input{../docs/latex/Macros}

%------------------------------------------------------------------------------
% Config
%------------------------------------------------------------------------------
\allcodefalse
% ifallcode is used for:
%  - forward decl, func decl, extern decl, #ifdef, pragmas (stuff in Extra.nw)
%  - STILL? boilerplate error management ?? sanity check?

%\setcounter{tocdepth}{1}

\addtolength{\topmargin}{-.850in}
\addtolength{\textheight}{1.70in}

\begin{document}
%******************************************************************************
% Title
%******************************************************************************
\title{
{\Huge 
Principia Softwarica: The ARM Linker [[5l]]
}\\
{version 0.1}
}

\author{
Yoann Padioleau\\
\texttt{yoann.padioleau@gmail.com}\\
\\
with code from\\
Rob Pike
}

\maketitle 
%alt: 8l, x86 (32 bits) edition
\l ARMv6 (32 bits) edition\\
\l Rob pike really author also of linker?


\onecolumn
\hrule
\input{../docs/latex/Copyright}
\input{../docs/latex/CopyrightPlan9}
\hrule
\twocolumn

\begingroup
\hypersetup{linkcolor=blue}
% need to s/onecolumn/twocolumn in report.cls :) for \tableofcontents
\tableofcontents
\endgroup

%******************************************************************************
% Body
%******************************************************************************

\chapter{Introduction}

The goal of this book is to present with full details the source code of
a {linker}.

\section{Motivations}

Why a linker?
Because we think you are a better programmer if 
you fully understand how things work under the hood, and
the linker is the final piece of any {development toolchain},
the one generating finally the {executable}.
\l often get errors from linker. never explained, maybe boring but important!

There are very few books about linkers,
\n the linker/loader book is mentioned later
as opposed to a myriad of books on compilers or kernels.
Linkers are usually not even studied during the computer science curriculum. 
This is a pity because they are pretty central.
Indeed, they make the link (no pun intended) between the compiler
and the kernel: the linker generates from {object files} {executables} 
that the kernel will {load}. Without a linker there is no program to execute.
\l linker/loader relation
\l Many blog posts, show interest from people
\l compiler rely a lot on linker, to link together modules!
\n even to understand ocamlc, ocamlrun, -custom, important understand linker

Here are a few questions we hope this book will answer:
\begin{itemize}
\item What is the format of object files?

\item What is the format of executables?
What is the format of machine instructions?

%\item What is the difference between the ELF and [[a.out]] formats?

\item What is the format of libraries?

\item How object files and libraries get combined together and patched
to form the final executable?

\item What is the difference between a linker and a loader?

\item What is the memory image of a program? 
How it relates to the executable file? How it relates to
the original source code?

\item What debugging information contains executables? How
source-level debuggers can find which C source code corresponds 
to a specific binary instruction?

\end{itemize}
\l what is position independent code? 
\l how dynamic linking works? 
\l how shared libraries works? 
\l endianess? see the inuxi stuff?
\l how handle arcitecture constraints

%tags used in this file for different recurring themes:
 %assembler: relates code in the linker to similar (or absent) code in 5a
 %emulator: relates code in the linker to similar (or absent) code in 5i
 %sanity: I use "sanity check" in chunknames, to aspectize a bit error checking
 %
 %real-world: to relate to other linkers
 %ocaml: to give a hint on how rewriting C in OCaml could improve things
 %alt: alternative techniques
 %old: for original code I changed/removed to be clearer
 %toc: %trans: %dup: %example:

\t put in conclusion non-trivial adv algo and data structures seen? see comment
%data-structures (beyond list/hashtbl):
% - AST again with enums, tag/union structure
% - Buffer with reading sliding window
% - growing array
% - graph and pointers (from implicit graph in array with ref via pc integer)
% - forward overlay link indexation (and associated faster search)
% - pattern matching array dispatch table (with subtype notions)
%   and associated indexation (range and cmp and caching)
% - reflection via special symbols

%algorithms (beyond search/sort):
% - unserialization/unmarshalling with shared enum and tags so simple dispatch
%   or with header specifying sizes, and sliding input buffer window
% - signature checking (header I_MAGIC, archive ARMAG, names ASIGNAME)
% - binary search (with overlay)
% - DFS? (follow?)

%other?
% - program instrumentation for profiling
% - smaller:
%   * versioning for disambiguation (but gensym would be better term)
%   * def/use link again via symbol table and special marks (SXREF)
%   * lots of bit manipulations
%   * AST rewriting and optimisations
%   * dumpers
% - =~ concatenation, resolution, relocation
% - poolization?
% - endianess?
% - special algos for dynamic linking?

\section{The \plan ARM linker, [[5l]]}

We will explain in this book the code of the \plan ARM linker
[[5l]]\footnote{\url{http://plan9.bell-labs.com/magic/man2html/1/8l},
which despite its name covers also [[5l]]}
which is about 7900 lines of code (LOC).
\n make loc, counting only 5l, not ar.c, size.c, etc
\t say appendix also code of ar and say LOC too?
[[5l]] is written entirely in C\footnote{
An OCaml partial port is also shown in Appendix~\ref{chap:5l-ocaml}.
}.
%
%dup: (and adapted) from Assembler.nw
Like for most books in \principia, we chose a \plan software because
they are simple, small, elegant, open source, and they form together
a coherent set of software.
The [[5]] comes from the \plan convention to name architectures
with a number or single letter (0 is MIPS, 5 is ARM, 8 is x86, etc),
and the [[l]] means linker.

%dup: (and adapted) from Assembler.nw
Like for the other \principia books covering the
{development toolchain}, we chose the ARM architecture~\cite{arm-refman}
variant, in this case of the \plan linker ([[5l]]),
and not for instance the x86 variant ([[8l]]), for
reasons of simplicity. Indeed RISC machines
are far simpler than CISC machines. Moreover, the availability
under \plan of an ARM emulator, [[5i]], helps to understand
the semantics of the machine instructions generated by [[5l]].

The \plan approach to linking is a bit different than in other
operating systems. The \plan linker is responsible
for generating executables, but also for generating the machine code 
from the object files. Indeed, the object files generated
by [[5a]] and [[5c]] 
%dup: (and adapted) from Assembler.nw
are ARM-specific, but they do not contain machine code. 
Instead, under \plan an object file is essentially the {serialized form} of the 
{abstract syntax tree} of an assembly source.
%
The linker [[5l]] generates the actual machine code.
We think though that it is actually a better design because it leads to
less code in total and also to simpler code.
\t why? because anyway linker need deep knowledge of machine code format
\l  because need patch it here and there, so why not put everything in it
\l  so assembler then is simpler 
\t Better for opti too. Things can be done only when know actual size, such as
\l  length of offset. Compiler has not the knowledge for that.
\n probably cos there was only 5c/5l before and responsabilities were shifted
%
The \plan linker does also some deadcode elimination
\l well just for libraries, and it is not really dead code
\l and apparently it's pretty common for a linker to do that
\l also instruction selection? more opti?
\l inter-lib linking-time optimisations!?
which reduces the size of the binaries. 
This is partly to compensate for the lack of
shared libraries in \plan.
\l but shared libraries are evil! dynamic shared libraries?
\l Also there is no dynamic linking by default. Simpler approach again.
\t does also instruction selection? asmout, brloop are opti?

\n critique of go/plan9 toolchain,
%  -  http://dtrace.org/blogs/wesolows/2014/12/29/golang-is-trash/

\section{Other linkers}

Here are a few linkers that were considered for this book but
which were ultimately discarded:
\begin{itemize}

\item The GNU Linker [[ld]], part of the [[binutils]] package,
is probably the most used open source linker.
It is using the Binary File Descriptor library (BFD)
to read and write object files using different formats.
It supports many architectures (ARM, x86, etc)
as well as many executable and object file formats (ELF, [[a.out]], etc).
\l also dynamic libraries, ELF
\n BFD =~ libmach
It is fairly big though: 30K LOC for [[ld/]]
and 500K LOC for [[bfd/]].
Even the ARM-specific file [[bfd/elf32-arm.c]] has already 17 000 LOC.

\item Gold is a faster multi-threaded ELF linker originally developed at Google,
which is now part of the [[binutils]] package.
It supports also many architectures (ARM, x86, etc).
\l not using BFD?
It is unfortunately also fairly big: 153K LOC.
Again, even the ARM-specific file [[gold/arm.cc]] has already 13 000 LOC.
\n cplusplus
\l show that useful to see how linker works! cf FB, so much time lost in ld
\l and engineers didnt even think to rewrite it, though impossible. barriers!

\item The LLVM Linker [[lld]] aims to remove the current dependency to
the host linker (e.g. [[ld]] under Linux) in the LLVM infrastructure.
Its goal is also to be more modular and extensible than [[ld]].
It supports also many architectures and executable formats.
\n (ARM, x86, etc) (ELF, COFF, etc).
It is smaller than [[ld]] and Gold but still fairly large: 71K LOC.
\n cplusplus

%dup: (and adapted) from Assembler.nw
\item LD86, an x86 16-bit and 32-bit linker, part of
Bruce Evans' C compiler (BCC), is an historical linker
used to compile old versions of Minix and Linux.
\l sure?
%
It is fairly small: 6100 LOC, which is smaller than [[5l]].
But, to be fair, [[5l]] does also machine code generation
which is done instead by AS86 for LD86. [[5a]]+[[5l]] is 12 000 LOC
which is smaller than AS86+LD86 at 18 600 LOC.
\l also ARM simpler than x86 (even for linker-related issues?)

\end{itemize}
\l add furl

\l a few other linkers, see the comment in the .tex
%industry:
% - optlink, digital mars, very fast, written in assembly though
%other:
% - http://www.compilers.de/vlink.html, part of vbcc and vasm
%   by Frank Wille, 25 000 LOC but many formats, but not completly OSS I think
%mini:
% - linker and loaders book mention linker project in Perl, 
%   http://linker.iecc.com/code.html but contains helper code, not final code
%education:
% - https://github.com/trillek-team/computer-toolkit (for space game)
%   a toy asm, linker, and even a toy C compiler, for TR3200 machine
%  - subc-2014, sld, 700LOC?
%modern:
%  - lld seems to do advanced opti or going towards advanced opti with notion
%    of Atoms vs Section (see lld/docs/design.rst)

\section{Getting started}
\label{sec:getting-started}

%dup: (and adapted) from Assembler.nw
To play with [[5l]] you will first need to install
the \plan fork used in \principia. See \urlinstall.
Once installed, you can test [[5l]] under \plan with:

\begin{verbatim}
1   $ cd /tests/5l
2   $ 5a hello.s && 5a world.s
3   $ 5l hello.5 world.5 -o hello
4   $ ./hello
5   hello world
6   $
\end{verbatim}
\n minimal example here! no libc.a, just to make sure the minimal stuff works

The command in Line 2 {assembles} the simple [[hello.s]]
and [[world.s]] ARM assembly programs and generates the 
[[hello.5]] and [[world.5]] ARM {object files}.
\l define object file? .5? explained later.
Line 3 then {links} the object files together and generates the final 
ARM binary executable [[hello]].
Line 4, which assumes you are under an ARM machine (e.g. a Raspberry Pi)
{launchs} the program.

Note that it is easy under \plan to {cross compile} from another architecture:
you can use the same commands, [[5a]], [[5l]], etc.
\l because magic /bin, and also because special 5 convention
To play with [[5l]] under an x86 machine you just need
after the linking step to use the ARM emulator [[5i]] instead:

\begin{verbatim}
...
4   $ 5i hello
...
\end{verbatim}

See the \book{Emulator} for more information on [[5i]].
\l actually cool cos can be used as an assembly debugger too


\section{Requirements}

%dup: from Assembler.nw
Because most of this book is made of C source code, 
you will need to have a good knowledge of 
the C programming language~\cite{k-r} to understand it.
%
In fact, for Chapter~\ref{chap:arm-codegen}, where we will
see the code which generates ARM instructions, 
you will need a very good knowledge of C.
Indeed, the code does lots of bit manipulations and uses many C idioms.

There are very few books explaining how a linker works.
We can cite {\em Linkers and Loaders}~\cite{ll}
and one of the chapter of 
{\em Computer Systems: A Programmer's Perspective}~\cite{cs-bryant}.
Thus, we assume most programmers do not know really how a linker works,
which is why, in addition to explaining the code of [[5l]],
we will also explain most of the concepts related to linking
in this book. This is a bit unusual in our \principia serie.
Indeed, we usually assume the reader has read books introducing at least
the concepts and theories underlying the software we present.

Reading the \book{Assembler} is a requirement to understand
this book. Indeed, many data structures introduced
and fully explained in the \book{Assembler} are similar
to data structures used by [[5l]]. This is normal since
the assembler generates what the linker consumes.
Those data structures will be only quickly presented in this book.
The same is true for the object file format described at length
in the \book{Assembler}.

It is not necessary to know the ARM architecture to understand 
most of this book. 
For the machine code generation part though, in Chapter~\ref{chap:arm-codegen},
we highly recommend to print the excellent one page
colorful ARM reference guide
\url{http://re-eject.gbadev.org/files/armref.pdf}.
It will help you to visually understand the binary format of the
instructions. This guide is very helpful
to understand the code which does many bit manipulations to generate
different parts an ARM instruction.
%we recommend to read the \book{Emulator} to fully understand
%the semantics of some instructions.

\section{About this document}
#include "../docs/latex/About.nw"

\section{Copyright}

Most of this document is actually source code from Plan9, so
those parts are copyright by Lucent Technologies Inc.
The prose is mine and is licensed under the \license.

\section{Acknowledgments}

We would like to acknowledge of course the author of
[[5l]], Rob Pike, 
who wrote in some sense most of this book.
\t really Pike?







\chapter{Overview}

%trans:
Before showing the source code of [[5l]] in the following chapters, 
%toc:
we first give an overview in this chapter
of the general principles of a linker.
We also describe quickly the format of the object files 
generated by [[5a]] and [[5c]] 
and used as inputs by [[5l]], as
well as the format of the executables generated by [[5l]].
%dup: from Assembler.nw
We also define terms, explain how the code is organized, 
and more generally give the background necessary
to understand the code we will show later.

\section{Linker principles}

\n what
A {\em linker} is a program which takes as input multiple
{object files} and {combine} them to form an {executable}
as shown in Figure~\ref{fig:linker-overview}.
\n combine will be explained later
\t ethymology of linker? why call that way? combine/concatenate/def-use =~ link

\begin{figure}[!]\centering
\begin{verbatim}
         +-----------+
         | assembler |
foo.s -->|   (5a)    |--> foo.5 --+
         +-----------+            |   +-----------+
                                  |   |  linker   |
         +-----------+            +-->|   (5l)    |--> 5.out
         | compiler  |            |   +-----------+
bar.c -->|   (5c)    |--> bar.5 --+
         +-----------+

Source files           Object files               Executable
\end{verbatim}
\caption{Linker inputs and output}\label{fig:linker-overview}
\end{figure}
\n note that 5c generates directly obj files, does not need 5a


%dup: from Assembler.nw principles
An {\em object file} is really the simplest form of
a {\em module}. It packs code, data, and information
about {exported} and {imported} entities.
Object files are generated by {assemblers} and {compilers}.
\n explain here why need objects? separate compilation mentioned later.

An {\em executable} is a file containing machine instructions
as well as data. The code and data are stored in different
parts of the file called {\em sections} as shown in 
Figure~\ref{fig:linker-process}.
The size and location
of those sections are stored at the beginning of the file
in a part called the {\em header}. 
%
There are different kinds of headers
corresponding to different kinds of {\em executable formats}. In this
book we will focus on the [[a.out]] format which is very simple.
Section~\ref{sec:other-executable-formats} will present other
formats (including the popular ELF format used in Linux).

Thanks to the header, a part of the kernel called the {\em loader}
can know where the code and data are stored in the executable
file as well as its entry point. The loader, 
triggered by the [[exec()]] system call,
can then load (copy) in memory the different sections of 
the executable file and start executing its code.
\l actually man/1/8l uses term loader for 5l itself, hmm

\n how
Figure~\ref{fig:linker-process} gives an overview of the linking
process.
%
The linker first {\em concatenates} the code parts of the 
different object files together 
\l hence linker term?
to form the {\em code section} (the code parts [[C1]] to [[C4]]),
also known as the {\em text section}.
\n for 5l it actually transform them too, in machine instruction
It does the same for the data 
to form the {\em data section} ([[D1]] and [[D2]]).
\n for 5l this is the same
%
Then, it {links} the {\em uses} of {symbols} in those code (or data) parts,
e.g. the call to [[fbar]] in [[C1]],
to their {\em definitions} in possibly other code (or data) parts,
here the definition of [[fbar]] in [[C2]].
\l hence linker term again

%alt: multics segmentation? where each object can be in own space?

\begin{figure}[!]\centering
\begin{verbatim}
  lib.a------------+
  |                |
  |y.5------------+|
  |+--------------+|
  ||      D3      ||
  |+--------------+|                      +------------+
  ||      C5      ||                      |            |
  |+--------------+|--+                   |  Metadata  |
  |x.5------------+|  |                   |            |
  |+--------------+|  |                   X------------+260
  ||      C4      ||  |                  /|     D2     |
  ||TEXT util     ||  |     Data section| +------------+240
  |+--------------+|  |                  \|     D1     |
  +----------------+  |                   X------------+220
                      |                  /|     C4     |
   bar.5----------+   |   +-----------+ / |            |
   +--------------+   |   |  linker   | | +------------+200
   |      C3      |   +-->|    (5l)   |-+>|     C3     |
   |... CALL util |   |   +-----------+ | |.. CALL 200 |
   +--------------+   |                 | +------------+150
   |      D2      |---+                 / |     C2     |
   +--------------+   |    Code section|  |            |
   |      C2      |   |                 \ +------------+100
   |TEXT fbar     |   |                 | |.. CALL 100 |
   +--------------+   |                 \ |     C1     |
                      |                  \|... JMP 62  |
   foo.5----------+   |                   X------------+32
   +--------------+   |                   |   header   |
   |      D1      |   |                   |  (a.out)   |
   +--------------+   |                   +------------+0
   |... CALL fbar |---+
   |      C1      |
   |... JMP 30    |
   +--------------+

Input object files and                  Output executable
       library
\end{verbatim}
\caption{Linking process overview}\label{fig:linker-process}
\end{figure}
\l actually in ARM it is BL not CALL and B not JMP
\l could be nice in final one to have arrow from CALL fbar to CALL 100

\subsection{Separate compilation}
\l and concatenation, separate and concatenate

One of the main operation of a linker is to concatenate parts
of different files together. 
\l actually in 5l less because generate also machine code
In fact, the program [[cat]] can be seen as a very primitive linker.
Instead of using a linker, one could use [[cat]] to concatenate
multiple source programs together and compile/assemble the resulting single
(big) file\footnote{
Assuming the compiler/assembler could from one source file
generate directly an executable.
}.
\l see bootstrapping from scratch, I mentioned that
\l MMIXAL actually neglect linker and assume linker = cat :) Same for fbas. 
\l Now that memory is cheap, can do it
%
As programs grow larger, this approach becomes inconvenient though.
Linkers and object files enable {\em separate compilation}
which in the long term saves lots of compilation time.
\l well for 5l/5a maybe less cos heavy part is machine codegen done in 5l
\l  other advantages? more language independent? cat foo.c foo.ml would not work
\l  but could also use assembly as the common format, cat foo_c.s foo_ml.s


\subsection{Symbol resolution}
\n I didn't have subsections in Assembler.nw for its principles but I had a
\n tutorial later with many subsections. Here no tut so subsec in Principles.

Linking the uses of symbols to their definitions
is also called {\em resolving} the references to external symbols.
\n well for 5l/5a it is external and internal actually
%
The linker can do so because it has access to all the code (and data).
Once all the code (and data) parts are contatenated together, 
the final {addresses} of the different {entities} can be known. 
\l actually can need fixpoing on some archi, and in the end it is tricky
\l actually dynamic linking mean sometimes have still unresolved symbols
So, in Figure~\ref{fig:linker-process} the call to [[fbar]] in [[C1]]
can be transformed in a machine instruction to go to the
address 100 where the code of [[fbar]] resides (assuming [[fbar]]
was the first procedure in [[bar.5]] and so [[C2]]).
\n will see below that actually not 100 but 4196

\subsection{Relocation}

Another important operation done by the linker is called {\em relocation}.
%
Remember from the \book{Assembler} that [[5a]] can resolve
the use of {labels} in jump instructions as both the definitions and uses of
those labels must be in the same file. 
\l in regular linker  same for calls to internal symbols? resolved but need
\l  to be relocated?
\n actually relocation is a kinda special case symbol resolution, could
\n  change 5a to not resolve labels and use fake private symbols for labels.
The instructions generated
for those jumps {assume} though that the code of the program was
loaded at the memory address 0. 
\l for the rest of the doc when I say memory address I mean virtual mem address
\l unless relative jump, but ARM can't do that
%alt: mutlics segmentation? or PIC.
For instance, to jump to
a label [[foo]] which happens to be defined just before the 30th instruction 
in a program [[foo.s]], 
the instruction [[JMP 30]] will be generated in the object file
\l because 5a use virtual PC
as shown in Figure~\ref{fig:linker-process} (see [[foo.5]]).
%
Once the code of object files are concatenated together and put
after the header, the linker must {\em relocate} 
the jump instructions
\l unless position independent code PIC in which case no need relocation
\l  ref to adv topic section?
to take into account the new {\em memory address origin}
where the object code containing the jump will be loaded.
For our previous example, the linker generated
the relocated instruction [[JMP 62]] in 
Figure~\ref{fig:linker-process} as [[C1]] is after the executable
header which uses 32 bytes.
\n will see below that actually not 62 but
\l again can have fixpoint issue, and relaxation hints (cf wikipedia linker)


\subsection{Architecture constraints}

% resolving and relocating changes things! change addresses!
% this in turns change other things on some archi.

% CALL 100 whatif very far away? (well have 24 bits for offsets in
% ARM jmp, so not issue really)

% some archi have constraints on size of immediate, offsets, etc.
% when resolve and find out address of things, maybe can not use
% regular instr. Have to adapt! find tricks! intermediate instrs.
% but then change size of code section, so shift data, so 
% need reresolve!

% works for 5l because: 
% - offset for jmps is really big, so stable size of instr
% - address for globals are offsets to R12 and so stable
% - special case for setR12
% - works for etext???

% on x86 have small jump and far jump, and one faster than other
% but can work only if dest is not far.

% other linkers do pooling? role of linker? who else can do that anyway?

%\subsection{Mutual dependency, fixpoint}
% generic term used in Levine book for that?
\t talk now about issue with mutual dependency reference of SB?


\subsection{Disk image versus memory image}
\label{sec:disk-image-vs-memory-image}
\l linker versus loader

Linkers and loaders are strongly connected, just like assemblers and linkers.
Indeed, one produces what the other consumes.
In fact, early linkers were also called loaders as they
were responsible for linking and loading in memory a program.
\l really? read levine book introduction.
\l also linkage editor, etc.
\n actually man/1/8l uses the term loader, but I think they are confused.
\n  Linkers and Loaders says the same thing than me. 5l is not a loader.
It is important to note though, that
the {\em disk image} of an executable generated by the linker
does not necessarily match exactly the {\em memory image}
of the program when loaded in memory by the loader.
\l for instance BSS is not in disk image (but BSS explained later)
An offset in the file does not necessarily correspond to the same
offset in memory, even though we assumed this was the case
in Figure~\ref{fig:linker-process}.

Under \plan, the header and code section are actually not loaded
at the memory address 0 but instead after
the first {page} at 4096 (4K). Indeed, the first page
in the {virtual address space} of a program
is reserved by the kernel and marked specially to generate
{faults} when accessed. This helps for instance to
track {null pointer bugs}.
%
So, the instructions [[CALL fbar]] and [[JMP 30]]
in Figure~\ref{fig:linker-process}
would be actually transformed respectively
in the resolved [[CALL 4196]] and relocated [[JMP 4158]] 
instructions with [[5l]] under \plan.
\n 4128 because header
\l while still refering to machine code stored at offset X in the executable
\l say that could actually remove header when loaded in mem and so CALL 4164
\t notion of Text origin? actually header is 4096
\t notion of disk address vs (virtual) memory address

\l FIGURE? where see disk image vs memory image? file offset vs memory offset?
\l  and shift lines? see also INITRND, 
\l talk about pages, because different properties for code and data 
\l  (the case with 9?)

\subsection{Libraries}
\n talked here about [[cat]] and separate compil but better in different section

Object files can be concatenated together to form
{\em libraries} using a tool called [[ar]] (for archive).
\l which really is kinda cat, and also really kinda tar (tape archive)
The linker can also take as input a set of libraries as shown
in Figure~\ref{fig:linker-process} with [[lib.a]].
%
Those libraries are convenient for the programmer because one
just has to remember the name of one file, e.g. [[libc.a]], instead
of a possible long list of object files.
\l other advantages?

Moreover, the linker can also take care of including only
the object files in the library that matters, that is the object files
containing code or data referenced by the other object files
passed on the command line.
For instance, in Figure~\ref{fig:linker-process} the linker
decided to include in the executable the code of [[x.5]] ([[C4]]), which
is part of [[lib.a]], 
because it contains the definition of a procedure [[util()]] which
is mentioned in the object file [[bar.5]]. 
\l well need fixpoint though, need take care
It did not include the code from [[y.5]] though because such code 
would be anyway {\em dead code} in the executable. 
Such code would waste disk and memory space.
\l well lazy code loading so maybe ok
\l other optimisations? fine grained dead code?
\l static dection! false positive? dynamic code? relation to -linkall ocaml?

\subsection{Static and dynamic linking}

The linking we described until now is completely {\em static}.
All the symbol references must be known at {\em link-time}
in which case they can be fully resolved to generate an executable.
This requires that all the object files (or libraries)
containing those symbols get passed to the linker on the command line.

Another popular form of linking is called {\em dynamic linking}.
\l actually more popular, but bad
Dynamic linking blurs the line between the responsabilities 
of the linker and loader.
\l dynamic linking vs dynamic loading? do both? or maybe not.
Indeed, with dynamic linking an executable can still contain
unresolved references to external symbols; the loader
at {\em load-time} must, before loading the program in memory,
link additional objects.
\t also can be in the hand of the programmer, dynlink()
\t  can link after being loaded. at {\em run-time}
\t dynamic linking vs dynamic loading? relink and load, or load and reload?
\t dynamic code is important? like living cell organism, self modifiable!
\l  (well but can still modify own source code, call 5a/5c/5l and exec())

\plan opted mainly for static linking and so [[5l]] is mainly
\l mainly is vague, ADYN enough for dynamic linking?
a static linker. 
Static linking is far simpler than dynamic linking and is arguably 
also better in many respects.
\l refs? static linking reloated? dll hell
We will delay the discussions on dynamic linking to 
Section~\ref{sec:dynamic-linking}.
\l can separate. Loader is in kernel.
\l Linker setups things for loader, code section, data section, etc
\l and loader is pretty simple, just load/copy (or actually lazy load/copy).
\l Also compute textsize, datasize, etc and adjust addresses.

\t dynamic linking and shared libraries are different? I think so.

\bigskip
For more information on the principles of linkers and loaders 
\l and dynamic linking?
we recommend to read {\em Linkers and Loaders}~\cite{ll} which
is entired dedicated to the topic.
\l many post on linkers or executables, show it is a missing part of curriculum:
% - http://eli.thegreenplace.net/2012/08/13/how-statically-linked-programs-run-on-linux/
% - http://dbp-consulting.com/tutorials/debugging/linuxProgramStartup.html
% - http://www.lurklurk.org/linkers/linkers.html
% - ian taylor posts http://www.airs.com/blog/archives/38
%   TOC here: http://lwn.net/Articles/276782/
% - https://github.com/0xAX/linux-insides/blob/master/Misc/linkers.md
%   and http://0xax.gitbooks.io/linux-insides/content/Misc/linkers.html
%   pretty good use of nm, objdump, readelf, etc
% - many on format of ELF header (referenced in Adv Topics section)

%\subsection{Summary}
\l put back essential steps? read object and lib, concatenate, 
%   resolve and relocate, and finally generate. but explained in soft archi?
\l which roughly correspond to different chapters

\section{[[5l]] command line interface}

The command line interface of [[5l]] is pretty simple:
\begin{verbatim}
$ 5l
usage: 5l [-options] objects
$ 5l foo.5 bar.5 lib.a
$ ./5.out
\end{verbatim}

Given the set of {object files} [[foo.5]] and [[bar.5]],
and a {library} [[lib.a]], 
[[5l]] outputs an executable file called [[5.out]].
\n look for _main. But explained later.
%
One can change this default behaviour by using the [[-o <outfile>]] option.

The default {executable format} is [[a.out]], a classic \unix format,
\t cite? RFC?
but this can be changed with the [[-H<num>]] option ([[H]] for header)
as explained in Section~\ref{sec:choice-exec-format}.
\l see adv topic for more e.g. ELF.
One can also change the entry point of the program with [[-E<funcname>]] 
which by default is [[_main]] 
as explained in Section~\ref{sec:choice-entry-point}.
\l also have -l which suppress entry point?
Other options related to debugging will be described later
in Appendix~\ref{chap:debugging-appendix}.
\n actually next section introduces a few

%real-world:
Executables generated by C compilers in \unix-like operating systems, 
e.g. [[gcc]] under Linux, are usually called by default [[a.out]].
\l same name than format. confusing?
\l even if ELF format actually
\l why a.out? a? assembler output?
But, under \plan, for the same reason ARM object files use the [[.5]] filename
extension and not [[.o]], ARM executables are called [[5.out]] not [[a.out]].
This is more convenient in an operating system supporting 
multiple architectures at the same time.
That way, one can have in the same directory an ARM executable
[[5.out]] and an x86 executable [[8.out]] without any name conflict.
\l why not lib.5a then? solve conflict via /arm/lib/... /x86/lib/...


Another important linker option, [[-T<num>]], allows to change the
{memory address origin} of the code section ([[T]] for text section).
%dup: from overview/principles
\label{sec:kernel-load-4096}
In \plan the default value for this address is 4128.
Indeed, the loader in the kernel
loads executables after the first page (4096), and includes
the header which is using 32 bytes, so the text section
will start at the memory address 4128. 
The machine code generated for the jumps and calls
must then assume the code will be loaded at 4128.
%
One can also change the memory address origin of the data section
as explained in Section~\ref{sec:choice-exec-format}.
%
Those options are almost never used by programmers, but they
are necessary for producing special executables such as
kernels or boot loaders as we will see in the \book{Kernel}.
Indeed, those binaries will be loaded (by the bootstrapping process
or firmware) at special memory addresses, 
e.g. 0x80000000 for the ARM \plan kernel, 0x7c00 for an x86 bootloader.

Another set of options are used to manage libraries,
which are really files encapsulating a set of object files,
\l like tar, actually ar means archive
and will be introduced later in Chapter~\ref{chap:loading-libraries}.

\l also dynamic related options, -x -u

\l env: $ccroot
%$


\section{[[hello.5]] and [[world.5]]}
\label{sec:hello-world}

%trans:
In this section we adapt the [[helloworld.s]] example of the \book{Assembler}
%toc:
to illustrate the linking process with a concrete example. 
The goal is also to learn how to use the debugging options of [[5l]] as well
as tools such as [[nm]].
\l why? because useful to debug issues, to find where symbols are defined
\l and indeed to better understand indeed linking process

\subsection{The source files}
\label{sec:hello-world-source}

We splitted the original source file [[helloworld.s]] 
in two files [[hello2.s]] and [[world.s]].
We also use the C library functions [[fprint()]]
and [[exits()]] instead of using directly the [[PWRITE]] and [[EXITS]] 
system calls:

<<linkers/5l/tests/hello2.s>>=
TEXT main(SB), $8
        /* fprint(1,&hello) */
        MOVW $1, R0
        MOVW $hello(SB), R1
        MOVW R1, 8(R13)
        BL fprint(SB)
        /* exit(0) */
        MOVW $0, R0
        BL exits(SB)
@
%$
\n call libc via fprint/exits so != Assembler.nw, and use main not _main
\n (cant call print cos pointer func so more complex) 
\l use SP instead of R13? 
\l weird but using only stack and not R0 at all also works


<<linkers/5l/tests/world.s>>=
GLOBL   hello(SB), $12
DATA    hello+0(SB)/8, $"hello wo"
DATA    hello+8(SB)/4, $"rld\n"
@
%$

If you do not understand the code, or the calling
conventions, read the \book{Assembler}.
%
Symbol definitions and uses are now spread over different files:
the [[hello]] global is defined in [[world.s]] but used in [[hello2.s]].
Moreover, the [[fprint()]] and [[exits()]] functions are defined in 
source files of the C library but used in [[hello2.s]].

\subsection{The linking command}

To compile the previous program do:
\begin{verbatim}
$ cd /tests/5l
$ 5a hello2.s -o hello.5
$ 5a world.s
$ 5l hello.5 world.5 /arm/lib/libc.a -o hello
$ ./hello
hello world
\end{verbatim}

The main difference with the commands shown in 
Section~\ref{sec:getting-started} is the use of the C library,
compiled here for the ARM architecture: [[/arm/lib/libc.a]].
We will see in chapter~\ref{chap:loading-libraries} other
ways to link libraries.

\subsection{Inspecting objects with [[nm]]}

One can use the tool [[nm]] to get the set of symbols defined or
referenced in object files (this set is also called the [[n]]a[[m]]e list):

\begin{verbatim}
$ nm hello.5
 U exits
 U fprint
 U hello
 T main

$ nm world.5
D hello
\end{verbatim}
\n note that if call main in hello2.5, you will not get a U main
\n even though in practice intra-file calls are not resolved by 5a

[[nm]] can also be used on libraries:

\begin{verbatim}
$ nm /arm/lib/libc.a | grep fprint
...
fprint.5: T fprint
...
$ nm /arm/lib/libc.a | grep exits
...
atexit.5:         T exits
...
\end{verbatim}

[[U]] stands for undefined,
[[T]] for text (a defined procedure), and
[[D]] for data (a defined global).
%
From the previous commands we can see that [[hello.5]] has three
{undefined symbol} references, including [[hello]] which
is a global data defined in [[world.5]]. 
%
The job of the linker is then to link those definitions to their uses.

There are other kinds of symbols and so other single letter codes
used by [[nm]]. Those codes as well as the source of
[[nm]] will be described fully later in Appendix~\ref{sec:nm-code}.

\l nm is actually using libmach, crachhdr, etc, generic API for object manip
\t put libmach/5obj.c in this book?
\l nm is actually pretty useful in general, to solve linker issues, nm | grep!

\subsection{Dumping objects with [[5l -W]]}
\label{sec:dump-objects}

Another way, more complete, to inspect the content of object files is to use
the debugging option [[-W]] of [[5l]]. The effect of the option
is to ``dump''
the instructions of the object files passed on the command line:
\l close to disassembler, but actually easier
\l disassembler is actually in libmach and used by db

\begin{verbatim}
1   $ 5l -W hello.5 world.5 /arm/lib/libc.a
2   ...
3   	ANAME	main                        
4   (1)	TEXT	{main}00000+0(SB),$8        
5   (4)	MOVW	$1,R0                       
6   	ANAME	hello                       
7   (5)	MOVW	${hello}00000+0(SB),R1      
8   (5)	MOVW	R1,8(R13)                   
9   	ANAME	fprint                      
10  (6)	BL	,{fprint}00000+0(SB)            
11  (9)	MOVW	$0,R0                       
12  	ANAME	exits                       
13  (9)	BL	,{exits}00000+0(SB)             
14  (10)	END	,                           
15  ...
16  	ANAME	hello
17  (1)	GLOBL	{hello}00000+0(SB),$12
18  (2)	DATA	{hello}0000c+0(SB)/8,$"hell"
19  (3)	DATA	{hello}0000c+8(SB)/4,$"rld\n"
20  (4)	END	,
21  ...
22      ANAME	_main
23  (8)	TEXT	{_main}00000+0(SB),R1,$802
4      ANAME	setR12
25  (10)MOVW	${setR12}00000+0(SB),R12
26      ANAME	_tos
27  (11)MOVW	R0,{_tos}00000+0(SB)
28  ...
29  (21)BL	,{main}00000+0(SB)
\end{verbatim}
\n output was copy pasted from the running of kencc/5l, not our 5l
\n for dollar hello we should remove the (SB)? NO! it can use R12!
\n  but it will do R12 plus 00014 no? yes because offset is small.
\l a bit weird just have "hell"
\t why those lineno? seems wrong line number. BUG?
\l remove those comma? 
\l have a D_ADDR? so cleaner?
\l very close to assembler, indeed object file is just serialized asm source
%pad: I changed the format to use {} and to show the value (here 00000) of syms

The first two fragments show the instructions of [[hello.5]],
from Line 3 to Line 14,
and [[world.5]], from Line 16 to Line 20.
The output is very similar to the assembly sources of
Section~\ref{sec:hello-world-source}. 
%dup: from intro/5l (itself dup from Assembler.nw)
This is normal since under \plan an object file is essentially
the serialized form of the abstract syntax tree of an assembly source.
%
See the \book{Assembler} if you do not
understand the {opcodes} or {pseudo-opcodes} such as [[ANAME]].

Symbol references are enclosed in braces, e.g. [[{main}]] Line 4,
followed by the {\em symbol value} in hexadecimal, e.g. [[00000]] Line 4.
The symbol value corresponds normally to the 
resolved memory address of the symbol.
But, almost all those values and addresses are null 
when using [[-W]] because the option dumps instructions
while the object files are read into memory, at the beginning, and so
when the linker has not yet resolved any of those symbols.

Once a global has been declared, e.g. [[hello]] Line 17,
the value of its symbol is then (ab)used to store its size,
here [[0000c]] (12) Line 18.
%
Later we will see that the symbol value will contain the resolved address
of the global.
% as an offset to the start of the Data section       but too many

\label{sec:explain-_main}
The last fragment, starting at Line 22,
shows the instructions of a procedure called [[_main]].
%dup: (and adapted) from Assembler.nw
The linker [[5l]] is looking by default for such a procedure
for the {entry point} of the executables it generates
(unless the [[-E]] option is used), which is why it is included.
\t hmm but dumping option could dump everything of libc.a no? maybe
\t  delay discussion about _main to next section with -a?
\t  just do 5l -W hello.5 world.5 here? anyway can see error msg
\t  with _main which we can link to next section
%
The reason for a default called [[_main]], and not [[main]],
even though the entry point of C programs is [[main]],
is because [[_main()]] is normally a procedure defined in the C library.
This procedure, written in assembly, does some core initialisations
and then calls [[main()]], as shown by the last dumped
instruction Line 29.
%
[[5l]] is usually called to link C programs, and
the C compiler [[5c]] assumes a few core initialisations has
been done before the call to [[main()]], hence the choice
of [[_main]] as the default entry point.
%real-world: 
% actually gcc transforms main in _main, so startup in Linux is ?? 

For more information on [[5l -W]] see Appendix~\ref{sec:debugging-loading}.

%real-world:
\t readelf? objdump? 

\subsection{Debugging machine code generation with [[5l -a]]}
\label{sec:_main-set-r12}

One can also display the generated machine code by using
the debugging option [[-a]] of [[5l]]:

\begin{verbatim}
1   $ 5l -a hello.5 world.5 /arm/lib/libc.a
2 
3  00001020:          (1) TEXT {main}01020+0(SB),$8
4  00001020: e52de00c (1) MOVW.W R14,-12(R13)
5  00001024: e3a00001 (4) MOVW $1,R0
6  00001028: e59f1884 (5) MOVW ${hello}00014+0(SB),R1
7  0000102c: e58d1008 (5) MOVW R1,8(R13)
8  00001030: eb0000bb (6) BL ,{fprint}01324(BRANCH)
9  00001034: e3a00000 (9) MOVW $0,R0
10 00001038: eb00009a (9) BL ,{exits}012a8(BRANCH)       
11
12 0000103c:          (8) TEXT {_main}0103c+0(SB),R1,$80
13 0000103c: e52de054 (8) MOVW.W R14,-84(R13)
14 00001040: e59fc870 (10) MOVW ${setR12}00ffc+0(SB),R12
15 00001044: e50c0fd0 (11) MOVW R0,{_tos}0002c+0(SB)
16 ...
17 00001068: ebffffec (21) BL ,{main}01020(BRANCH)
18 ...
19
20 000012a8:          (915) TEXT {exits}012a8+0(SB),R1,$16
21 000012a8: e52de014 (915) MOVW.W R14,-20(R13)
22 ...
23
24 00001324:          (874) TEXT {fprint}01324+0(SB),R0,$20
25 00001324: e52de018 (874) MOVW.W R14,-24(R13)
26 ...
27
28 00006b50: e49df03c (890) MOVW.P 60(R13),R15
\end{verbatim}
\n this was also done via kencc/5l


The first column contains the memory address
in hexadecimal where the code will be loaded (e.g. [[01020]] Line 4).
%
Then comes the 4 bytes in hexadecimal of the generated ARM instruction
(e.g. [[e52de00c]]). 
Indeed ARM uses fixed-length instructions of 4 bytes.
%
The third column contains the (global) line number
in parenthesis of the instruction in the original 
source file (assembly or C)\footnote{
See Section~\ref{sec:lineno} for more information about line numbers.
}.
%
Finally, the last column displays the disassembled instruction.
\l actually not really disassembled
As opposed to the previous section, the symbol values 
are not null anymore and contain now the resolved memory address
of the symbol, e.g. [[01324]] Line 8 for the [[fprint]] symbol.
%
The output contains also the [[TEXT]] {pseudo-instructions} to better
see the procedure boundaries, e.g. Line 3 and Line 12. 



The first instruction Line 4 starts at [[01020]] which is equal to 4128.
%dup: from overview/principles and overview/command-line
Indeed, as said previously in Section~\ref{sec:kernel-load-4096},
the kernel loads executables after the first page (4096)
and includes the [[a.out]] header which is using 32 bytes. Thus,
the code starts at the memory address 4128.

\l Note also code concatenated in section, no middle DATA of hello here

Note that even though it looks like there are two instructions
at [[01020]], with Line 3 and Line 4, the first instruction ([[TEXT ...]])
is a pseudo-instruction which got transformed by the linker
in the ARM instruction Line 4 ([[MOVW.M ...]]).
\t lots to explain here, 8 vs 12, MOVW.M which does multiple things.
Indeed, [[TEXT]] is an assembly directive introducing a symbol,
here [[main]], and symbols are {resolved} in 
{concrete addresses} by the linker. The generated machine code
contains only concrete addresses, no symbols (except for
debugging purposes as explained in Chapter~\ref{chap:debugging}).
%
So, the reference to [[main]] Line 17 is resolved to the concrete
address [[01020]].
In the same way, the calls to [[fprint]] and [[exits]]
Line 8 and 10 are fully resolved in respectively
the memory addresses [[01324]] (Line 25)  and [[012a8]] (Line 21).

\t discussion about _main? why included? 
\t  say that 5l includes only code in libc.a that are needed. so
\t  make sense exits and fprint, but _main?

The symbol value of [[hello]] Line~6 is [[00014]] which
seems incorrect. Indeed, data should be stored after
the code section and so the resolved address of [[hello]] should
be beyond [[06b50]] (the address of the last instruction Line 28).
%dup: section just before
But, the symbol value for data symbols contains the resolved address
of the symbol as {\em an offset to the start of the data section}.
The rational for this decision will be explained later
in Chapter~\ref{chap:resolving}.
Thus, the final address of [[hello]] is [[014 + INITDAT]]
where [[INITDAT]] is the address where starts the data section.
\t so if really disassemble e59f1884? get what? 7014? or BIG-7014?
\l actually see also initialisation of R12 with  very tricky
% MOVW	${setR12}00ffc+0(SB),R12
% which really is   MOVW    0xffc(R12=0), R12
\t put actual machine code! cos what is shown is not really machine code.
\t  the disassembly is original object instruction.
\t  real machine instruction is  
\t     ADD 14, R12, R1        (Well actually because of BIG it's not that)
\t  or
\t     LDR xxx(R15), R1  with Pool.


\l 6000 = ? just for including fprint and exits, hmmm

For more information on [[5l -a]] see
Appendix~\ref{sec:debugging-generated-code}.

\subsection{Inspecting executables with [[nm]]}
\label{sec:nm-executable}

[[nm]] can also be used on executables. In that case [[nm]] not only displays
the list of symbols, it also displays their addresses (in hexadecimal)
when loaded in memory. 
Here it is used with the [[-n]] option to sort by addresses:

\begin{verbatim}
1 $ nm -n 5.out
2     1020 T main
3     103c T _main
4     ...
5     110c T _div
6     1168 T _mod
7     ...
8     12a8 T exits
9     ...
10    1324 T fprint
11    ...
12    6b58 T etext
13    7000 d onexlock 
14    7000 D bdata    
15    7010 D argv0    
16    7014 D hello    
17    7020 d _exitstr 
18    ...             
19    7940 D edata    
20    7b44 B onex     
21    7c50 B end      
22    7ffc D setR12   
\end{verbatim}
\n this was also done via kencc/nm (actually inm)
\l why etext not 6b54?

We find the same resolved memory addresses we saw in the previous
section with [[5l -a]], e.g. [[12a8]] for [[exits]] Line 8,
or [[1324]] for [[fprint]] Line 10.

We can also now see the addresses of the data symbols.
[[hello]] Line 16 is at the address [[7014]]. The data
section starts at [[7000]] as indicated by the 
{\em special symbol} [[bdata]] (begin data) Line 14. 
So, [[INITDAT]] is [[7000]]
which confirms that the address of [[hello]] is indeed
[[14 + INITDAT]] ([[7014]]) as mentioned in the previous section.
\l but still a lot to explain because generated code is not that too,see setR12

The symbol after [[hello]] is [[_exitstr]] Line 17
at address [[7020]]. This confirms that [[hello]] is using 
12 bytes ([[0x7020]] - [[0x7014]] = [[0xc]] = 12) 
as said in the source of [[world.s]]
in Section~\ref{sec:hello-world-source}.

\t talk about _div, _mod,  because called by fprint
\t  to linker include more functions recursively. 

The linker defines a set of special symbols:
[[etext]] (end text) Line 12,
[[bdata]] (begin data) Line 14,
[[edata]] (end data) Line 19, and finally
[[end]] Line 21.
Those symbols are used only for their addresses and
allow a form of {\em reflection} on the structure
of the executable and its sections as explained
in Section~\ref{sec:special-symbols}.

Another special symbol, [[setR12]] Line 22
plays a complex role in [[5l]]. This symbol is notably
used by [[_main]] as indicated by the output of [[5l -W]]
and [[5l -a]] we saw in the previous sections.
Its role and its relationship with the {pseudo-register}
[[SB]] will be explained later in Chapter~\ref{chap:resolving}.
%~\ref{sec:sb-r12}.

\l _existstr 
\l small d means private symbol B means unitialized (BSS)

\l can also use db (or 5i) to inspect executable.

%trans:?
% how better view of objects and executables? will refine below?


\section{ARM architecture}
% constraints

\t maybe can do this section after understand better code generation

% Object instruction do not match exactly ARM instruction.
% Virtual, pseudo, etc but also:
% constraints on immediate constants, offsets

\subsection{Immediate constant range}

% ADD I, R1, R2

% 12 bits. Clever trick for encoding, but still limited.

% so how do? 
% can use DATA. (but then can have issue as we will see next section)
% REGTMP
%alt: can also use WORD in text, not far. called pooling, but talk below
%alt: could use MUL :) 


\subsection{Offset range}

% different addressing mode in Assembler, indirect, ...
% but in the end can be reduced to indirect with offset.
% xxx(R1)

% 12 bits (a page), and sign.
% But again if big offset how do?
% - reduce offset, and add base, but if big number base :) 
%   in fact for ADD before, use DATA, but $bigcst(SB) can be far away too.
% => WORD!
% called pooling.


% special case SB, hello+whatever(SB), $hello+whatever(SB).
% here? or mv later? at least need give idea on how translate $xxx(SB)
%  and xxx(SB)
% show actual code of 
%  MOVW $hello(SB), R2    ==>   ADD offset1, R12, R2    or LDR offset2(R15),R2
%   (and ADD itself can use REGTMP)
% and
%  MOVW hello(SB), R2     ==>   LDR offset(R12), R2  or LDR offset3(R15),RTMP;
%   LDR RTMP, R2

\subsection{Jump range}

%  BL foo(SB)

% 24 bits, and actually implict +8 (hence later -8 in code).
% because useless loop over yourself and useless jump next (+4)
% so B_arm 0  = jmp + 8


%\subsection{Code pooling}
% big number bootstrap?
% so if address of DATA too far too? :) can boostrap
% with PC and WORD!
% (could also use ADD, MUL, whatever to produce big number)

\section{Input object format}

The object file is now the input, as opposed
to the \book{Assembler} where it was the output.
%
The format of ARM object files is actually fully described
in the \book{Assembler} so we will not repeat
those explanations here.
%
Section~\ref{sec:object-format} contains a figure
summarizing this format though, which will be useful
to understand the code of Chapter~\ref{chap:loading-objects}
which loads object files.

Section~\ref{sec:dump-objects} contains the {dump}
of a few object files and shows, as we said previously, that
%dup: from intro/5l, overview, etc, maybe too much?
an object file is essentially
the serialized form of the abstract syntax tree of an assembly source.


\l could take figure in Assembler.nw and add the ANAME and AHISTORY?
\l or put concrete values everywhere?
\l 5l -W also show format a bit

\section{Output executable format, [[a.out]]}
\label{sec:exec-format}

\plan is using the very simple [[a.out]] executable format.
\t ref? rfc?
\l history? why called a.out? ok name of executable but why a? assembler output?
So, [[5l]] by default generates executables in this format.
This can be changed with the [[-H]] option. Other formats
will be described in Section~\ref{sec:other-executable-formats}

The file [[include/exec/a.out.h]] contains a formal
description of the [[a.out]] header:

<<struct Exec>>=
// a.out header
struct	Exec
{
    long	magic;		/* magic number */

    long	text;	 	/* size of text segment */
    long	data;	 	/* size of initialized data */
    long	bss;	  	/* size of uninitialized data */

    long	syms;	 	/* size of symbol table */

    // virtual address in [UTZERO+sizeof(Exec)..UTZERO+sizeof(Exec)+text]
    long	entry;	 	/* entry point */ 

    long	_unused;
    // see a.out.h man page explaining how to compute the line of a PC
    long	pcsz;		/* size of pc/line number table */
};
@
%old: _unused was actually:
%  // used only by 68020, spsize set to 0 for 8l TODO remove at some point!
%  long	spsz;		/* size of pc/sp offset table */

Figure~\ref{fig:executable-format} illustrates the format of
[[a.out]] executables.
%
An [[a.out]] header is made of 8 [[long]]s (32 bytes) used
as follows:
\begin{itemize}
\item The first four bytes in [[Exec.magic]] contains a 
{\em magic number} identifying the file
as an [[a.out]] executable as well as an ARM executable.
This magic number is recognized
by tools such as [[file]] and by the kernel loader
which will load only files having this magic number {\em signature}.

\item Then comes the size of the text and data sections. The format
of the ARM machine instructions in the text section will be
described in Chapter~\ref{chap:arm-codegen}.

\item [[Exec.bss]] contains the size of the BSS section which
corresponds to {uninitialized data}. 
\t BSS means?
The actual values for those data is not defined in the executable, 
as opposed to the data section, but the loader must
still reserve space in memory for those data.
The following C code shows which section will be used
depending on the declaration style of a variable:

\begin{verbatim}
int global = 1; // Data section
int another;    // BSS section
\end{verbatim}

\item [[Exec.syms]] and the {executable symbol table} will be discussed in 
Chapter~\ref{chap:debugging}.

\item [[Exec.entry]] contains the memory address of the entry point
of the program. This address is used by the kernel
loader to start the program. It is usually the address
of the [[_main]] procedure of the C library (unless
the [[-E]] option is used). 
%
So, for the [[hello]] executable of the previous section,
the value of the entry point is [[0x103c]].
%
The entry point can also be the
address of the [[_mainp]] procedure if profiling
is enabled as explained in Chapter~\ref{chap:profiling}.

\item Finally [[Exec.pcsz]] and the line table will be discussed in 
Chapter~\ref{chap:debugging}.

\end{itemize}



\begin{figure}[!]\centering
\begin{verbatim}
     +--------------+
     |     Line     | ^
     |    table     | |<-------+
     |              | v        |
     +--------------+          |
     |    Symbol    | ^        |
     |    table     | |<------+|
     |              | v       ||   +--------------+ +32
     +--------------+         |+---|  line size   |
     |              | ^       |    +--------------+ +28
     |     Data     | |<-----+|    |              |
     |              | v      ||    +--------------+ +24
     +--------------+        ||    | entry point  |------+
     |              | ^      ||    +--------------+ +20  |
     |     Code     | |      |+----| symbol size  |      |
     |    (Text)    | |      |     +--------------+ +16  |
     |              | |<----+|     |   bss size   |      |
+---->              | |     ||     +--------------+ +12  |
|    |              | v     |+-----|  data size   |      |
|+32 +--------------+       |      +--------------+  +8  |
|    |    Header    |       +------|  text size   |      |
|    |   (a.out)    |              +--------------+  +4  |
|    |              |              |    magic     |      |
|  0 +--------------+              +--------------+   0  |
|                                                        |
+--------------------------------------------------------+
     a.out executable                a.out Header
\end{verbatim}
\caption{[[a.out]] executable format}\label{fig:executable-format}
\end{figure}

\l data just after code, but when loaded in mem, at round?
\l and then from lineno you can get file/line thx to Hist?

Note that the [[Exec]] structure is actually not used by
the code of [[5l]] for {\em writing} the header.
Instead, the function [[asmb()]], which
we will see in Section~\ref{sec:gen-executable}, outputs
directly the bytes of the header with a serie
of calls to the [[lput()]] (for out[[put]] [[long]])
utility function.
%
The [[Exec]] structure is used though in programs which are {\em reading}
the header of executables.
There are many programs which need to understand the
format of executables, e.g. the debugger [[db]], the
profiler, and small utilities like [[nm]]. Under \plan, all those
programs use a common library called [[libmach]] which
defines [[Exec]] as well as many other data structures and functions.
Appendix~\ref{chap:linker-related-programs} discusses the
[[libmach]] interface and the code of utilities such as [[nm]],
but the code of [[libmach]] itself will be shown in the
\book{Debugger}.

\t no dynlink notion in a.out? need ELF for that?





%\section{Calling conventions}

% memory model when loaded in memory? need that? seems more cc material
% frame format?
%  parameters (including space for first arg even if put in R0)
%  saved PC (from REGLINK when not a leaf procedure)
%  locals
% saved SP? assumer caller saves/restores registers including SP?

% When want to call a procedure, need to save current place,
% so do BL for branch and link where a special register
% holds a value. Then need to save this value in a stack
% (if it's not a leaf procedure).

% autosize = p->to.offset + 4; // locals
% + 4 = saved PC (REGLINK from BL)

% FP vs SP? SP seems not equal directly to R13!


\section{Code organization}

%dup: (and adapted) from Assembler.nw
Table~\ref{tab:code-orga} presents a short description
of the source files used by [[5l]], 
the main entities (structures, functions, globals, etc) the file defines,
and the corresponding chapters in this document in which the code
contained in the file is discussed.
\n sorted by chapters, make more sense than sorted by dir


\begin{table*}[tbh!]
\begin{center}
\begin{tabular}{llllr}
\toprule
{\bf Function} & {\bf Chapters} & {\bf File} & {\bf Entities} & {\bf LOC} \\
\otoprule
Data structures & \ref{chap:core-ds} & [[l.h]] & [[Sym]], [[Section]], [[Instr]] & 0 \\
% headtype, Buf, ...
and prototypes  & \ref{chap:arm-codegen} &         & [[Optab]], [[Oprange]], [[Operand_class]] & \\
% like a dat.h and fns.h
Globals         & \ref{chap:core-ds}, \ref{chap:main}               & [[globals.c]] & [[hash]], [[firstp]], [[datap]], [[textsize]], [[datsize]], ... & \\
Entry point     & \ref{chap:main}    & [[main.c]] & [[main()]] & \\
%pad: I created this file

\midrule

Object and library & \ref{chap:loading-objects} & [[obj.c]] & [[ldobj()]] & \\
loading            & \ref{chap:loading-libraries} &         & [[loadlib()]] & \\

Resolving          & \ref{chap:resolving} & [[pass.c]] & [[patch()]], [[dodata()]] & 0 \\
and rewriting      &                      & [[noops.c]] & [[noops()]] & \\

Code generation    & \ref{chap:arm-codegen} & [[span.c]] & [[dotext()]], [[oplook()]], [[buildop()]] & \\
                   &                        & [[optab.c]] & [[optab]] & \\
                   &                        & [[asm.c]]  & [[asmb()]], [[datblk()]], [[asmout()]]  & \\

\midrule

Elf constants     & \ref{chap:advanced} & [[elf.h]] & [[Ehdr32sz]] & \\       
Elf generation   & \ref{chap:advanced} & [[elf.c]]  & [[elf32()]] & \\
% actually in 8l/

\midrule

Dumpers            & \ref{chap:debugging-appendix} & [[list.c]] & [[prasm()]], [[Pconv()]], [[Dconv()]],  & \\
                   &                               & [[enam.c]] & [[anames[]]] & \\
%5l/enam.c: which is a symlink in 5c/

Utilities          & \ref{chap:libc}        & [[utils.c]] & [[lookup()]], [[errorexit()]] & \\
                   &                        & [[compat.c]] & [[malloc()]] & \\

\otoprule
Total & & & & 7900 \\
\bottomrule
\end{tabular}
\end{center}
\caption{Source files of [[5l]]}
\label{tab:code-orga}
\end{table*}
\n see SRC_VIEWS in the Makefile, and make loc

\n did not factorized in a ll/ this time, but factorized via LP
\n could put include/exec/a.out.h but 5l does not use it
\n same for include/exec/elf.h

Another important file not included in Table~\ref{tab:code-orga}
is [[include/arch/arm/5.out.h]]. It contains the
definition of the ARM assembly opcodes used by [[5l]]. 
\l also operand kind, and object file related DS.
It is not included here
because its content is fully described already in the \book{Assembler}.
\l registers too
\n used to depend on 5c/ for one file ../5c/enam.c but now done via symlink



\section{Software architecture}
\label{sec:soft-archi}

%dup: (and adapted) from Assembler.nw
Figure~\ref{fig:controlflow} describes roughly 
the main control flow of [[5l]], while
Figure~\ref{fig:dataflow} describes 
the main data flow of [[5l]].
%
The main steps of the linking process of [[5l]] are:

\begin{enumerate}
\item to {\em load} (read) the object files and libraries (via [[objfile()]])
and {concatenate} their code and data in different sections in memory
(via [[ldobj()]])

\item to {\em resolve} symbol references (via [[patch()]], ...)
\n and {relocate} branching instructions; actually relocate done at load time

\item to {\em generate} the executable with its header and
machine code (via [[asmb()]])

\end{enumerate}


\begin{figure}[!]\centering
\begin{verbatim}
                    +---------+      +--------+
                +-->| objfile |----->| ldobj  |    Loading
                |   +---------+      +--------+
                |
                |     +---------+
                |+--->|  patch  |
                ||    +---------+
                ||    +---------+
+------------+  |+--->|  noops  |
|    main    +--++    +---------+
+------------+  ||                                 Resolving
                ||    +---------+
                |+--->| dodata  |
                ||    +---------+
                ||    +---------+
                |+--->| dotext  |
                |     +---------+
                |                     +--------+
                |                 +-->| datblk |
                |   +---------+   |   +--------+
                +-->|  asmb   |---+                Generating
                    +---------+   |   +--------+
                                  +-->| asmout |
                                      +--------+
\end{verbatim}
\caption{Control flow diagram of [[5l]]}\label{fig:controlflow}
\end{figure}
\n there is no loadlib(), it is an advanced  feature
%ocaml: if was more functional we could annotate arrows with types,
% and have more a pipeline than a tree of procedures

\begin{figure}[!]\centering
\begin{verbatim}
object file-\                /- code graph -\ 
             > instructions -                > executable
object file-/                \- data list  -/               

                  (use global symbol table)
\end{verbatim}
\caption{Data flow diagram of [[5l]]}\label{fig:dataflow}
\end{figure}
%ocaml: this is what I hope I will get, a transformation pipeline
% not sure I need the graph though


After some basic command line processing and initialisations,
the function [[main()]] first calls [[objfile()]] for
each object files and libraries to link. 
\n also loadlib(), but it is for advanced automagic lib feature
\n  and only their objects containing symbols we are looking for 
\n  (symbols uses mentioned in object files and so marked as SXREF) fixpoint
\n  so produce smaller binaries
%
[[objfile()]] opens
the object file or library and calls [[ldobj()]] to read
its object code in memory, which is mostly a {\em list of instructions}.
%
Doing so, [[ldobj()]] modifies also the globals [[firstp]] and [[datap]] 
containing respectively 
\t rename firstp to codep
the list of {code instructions} and {data instructions}.
\n also [[textp]] and the list of {procedures}, but less important now.
Thus, all the code and data in the
object files are concatenated together in the appropriate {\em section}.
\l also Instr.type field with section name

[[ldobj()]] increments also a global [[pc]] after each code instruction
read. [[pc]] represents the current value of 
the {\em virtual program counter}. Each code instruction
in memory has a field [[Instr.pc]] with the value of [[pc]]
at the moment the instruction was read.
\n imperative style
\t ldobj relocate branching instruction, use global virtual pc instead of local.
\t global because of all the objs, as opposed to Assembler
\t virtual because virtual counter still! incremented by 1
%
Finally, [[ldobj()]] populates a {\em symbol table} called [[hash]],
which keeps track of different {properties} of symbols.
%
One of this property, [[Sym.value]], contains initially
a virtual program counter for symbols corresponding to procedures,
and a size for symbols corresponding to globals.
This will be useful to resolve symbol references.
%
This same field will contain at the end the resolved memory
address of the procedure or global.
\t really for Text? once resolved, Instr.pc of TEXT already has
\t  resolved address, no need for its Sym.value to be updated


After loading the object files,
[[main()]] calls a serie of functions ([[patch()]], [[noops()]], etc)
which use the globals [[firstp]], [[datap]], and [[hash]] to
process or rewrite list of instructions.
\n actually does not really use datap, use more hash
%
First, [[patch()]] transforms the list of code instructions in a
{\em graph of instructions} where branching instructions have a
field [[Instr.cond]] pointing to the appropriate target instruction. 
\l FIGURE? too early maybe
%
To build this graph [[patch()]] is leveraging the symbol table [[hash]]
computed previously
to find the virtual program counter corresponding to a certain procedure symbol
(in its [[Sym.value]] field)
and {\em index} all [[Instr.pc]] to find the instruction pointer ([[Instr*]])
corresponding to a certain virtual program counter.


Once the graph has been built, there is no more need for the notion of
virtual program counter. 
Every code references (symbols or absolute jumps) in branching instructions
have been resolved. 
%
This allows in turn to transform safely some {\em virtual instructions} (see
the \book{Assembler}) such as [[RET]], [[DIV]], or [[NOP]] 
in machine instructions. 
\l actually still not real real; for instance still MOVW, and big imm cst
\l or do optimisations? e.g. ANOP
Indeed, [[noops()]] can
replace a virtual instruction by
multiple instructions or even delete the instruction without
any consequence on the other branching instructions (as long
at it maintains carefully the [[Instr.cond]] pointers pointing
to the original instruction).
%
Before the graph of instructions, inserting or
deleting an instruction would have forced to assign a new 
virtual program counter to each instruction and to relocate 
every branching instructions.

Once [[5l]] has the graph of machine code instructions and the set of globals
declarations, it can start to {\em layout} the code and data.
[[dodata()]] assigns 
%dup: overview/tutorial
a memory address in [[Sym.value]] to each  globals in the symbol table
as an offset to the start of the data section.
\t again will explain rational for this decision and why not directly final
\t  adress
\n not 'data definitions in [[datap]]' layout does not need DATA
\l e.g. 014 for hello
%
Then, [[dotext()]] does a similar thing for the code instructions.
For those code instructions [[Instr.pc]] will contain now the final code address
of the instruction (and not a virtual program counter anymore).
\l e.g. 0x1020 for main
\l so work by side effects, imperative style, on list of instructions

At this point, the size of the code and data sections are known
and stored respectively in the globals [[textsize]] and [[datsize]].
%
[[5l]] can finally call [[asmb()]] to generate the executable and 
its header. This function uses two helpers functions: one
to fill the data section [[datblk()]] 
\n this time use the DATA
and one to generate ARM instructions in the code section [[asmout()]].

\l How does handle mutually recursive object files?
%  for objects passed on the command line it loads every symbols
%  and at first some symbols get their type as SXREF (placeholder) but then
%  when you load the second object it sets it as a STEXT or SDATA.
\l How automatically grab all the necessary libs?
%  magic #pragma and special ANAME code in the .8?

\l Note that the linker loads lazily the objects in a library.
% It loads only what is necessary, that is objects in a lib
% containing symbols that are "looked for" that is symbols that are SXREF.
% (with a special case for _main which is not looked by
%  anything by default and so there is lookup(INITENTRY, 0)->type = SXREF
%  in the main of 8l/5l).

\l linker vs libmach, see appendix



\section{Book structure}

%trans: %dup: (and adapted) from Assembler.nw
We now have enough background to understand the source code of [[5l]].
%toc:
The rest of the book is organized as follows.
%
We will start by describing the core data structures of [[5l]]
in Chapter~\ref{chap:core-ds}. 
%
Then we will use a top-down approach in Chapter~\ref{chap:main} and 
starting from [[main()]] we will present the code, or a high-level
view of the code of some of the main functions, e.g. [[asmb()]].
%
The following chapters will describe
the main components of the linking pipeline:
Chapter~\ref{chap:loading-objects} will present the code to
load object files,
Chapter~\ref{chap:loading-libraries} the code to load libraries,
Chapter~\ref{chap:resolving} the code to resolve symbols,
and finally Chapter~\ref{chap:arm-codegen} the ARM machine code
generator.
%
In Chapter~\ref{chap:debugging} we will describe the code
responsible for adding debugging support in [[5l]], which
for instance adds line information in the executable. 
One can then know, when debugging a binary program,
to which original line and which source file an
instruction in the binary comes from, or what is the
original name of the procedure containing this instruction.
%
In a similar way Chapter~\ref{chap:profiling} will describe the code
for adding profiling support in [[5l]].
%
Chapter~\ref{chap:advanced} presents other
features of the linker which we did not present 
before to simplify the explanations, for instance
the support for dynamic linking or 
the ARM code generation of  instructions involving floats. 

%toc:
Some appendices present the code of non-functional properties:
the code to help debug [[5l]] itself in Appendix~\ref{chap:debugging-appendix}, the code to manage errors in Appendix~\ref{chap:error}, and
the code which profiles [[5l]] itself in
Appendix~\ref{chap:profiling-appendix}.
%
Appendix~\ref{chap:libc} contains the code of generic
utility functions used by [[5l]] but which are not specific to [[5l]].
%
Appendix~\ref{chap:linker-related-programs} describes the code of small
programs such as [[nm]] and [[ar]] which are related to the linker.
%
Finally, Appendix~\ref{chap:5l-ocaml} contains
the code of an OCaml port of [[5l]].
\t what for? :)

%\section{Bootstrapping}
% source of 5l use 5l :) 
% [[cat]] can be bootstrapping tool :) See Principia.nw appendix



%###############################################################################

\chapter{Core Data Structures}
\label{chap:core-ds}

\begin{verse}
\begin{flushright}
  {\it Show me your code and conceal your data structures, and I shall
    continue to be mystified. Show me your data structures, and I
    won't usually need your code; it'll be obvious.\\
    ~\\
    Fred Brooks}
\end{flushright}
\end{verse}

%toc:
In this chapter we will present the core data structures of [[5l]],
which are essentially:
a symbol table keeping track of the memory address and section of symbols, 
the abstract syntax tree (AST) of the instructions contained in object files,
and a set of globals pointing to lists of instructions.

\section{[[Sym]]bols and [[hash]] table}

%dup: (and adapted) from Assembler
One of the main job of a linker is to {resolve} symbol references
by linking uses of a symbol to its definition.
The {\em symbol table}, which keeps track of those symbols,
is thus a central data structure of [[5l]].
The structure below represents a symbol and its {properties}. 
It essentially associates a {\em key} to a {\em value}:

<<struct Sym>>=
struct	Sym
{
    // The key
    // ref_own<string>
    char	*name;
    // 0 for global symbols, object file id for private symbols
    short	version; 

    // The generic value, 
    // e.g. virtual pc for a TEXT procedure, size for GLOBL
    long	value; 

    <<[[Sym]] section field>>

    <<[[Sym]] other fields>>
    // Extra
    <<[[Sym]] extra fields>>
};
@
%ocaml: no need special type, just use hashtbl for symbol table
\l rename Symbol?
\l transform value to a union?
\n conflict with include/a.out.h

\label{sec:version}
The key is made of a pair with the name of the symbol and a {\em version}.
\l bad name?
The version is used to differentiate {\em private symbols} 
(a.k.a static symbols)
\n private symbols are advanced feature but too important to delay because
\n  many interfaces like lookup take a version number.
\l private symbols could be resolved in Assembler? kinda but want keep
\l  symbol in executable for debugger and anyway linker need to resolve things
\l  already so why not also resolve private symbols
in different object files using the same name, e.g. [[tmp<>]] 
in [[foo.5]] and [[tmp<>]] in [[bar.5]]. 
%assembler:
\l need that compare to assembler because now combine! so can have conflict
See the \book{Assembler} for more information about private symbols.
A version is a unique integer representing an object file,
e.g. 1 for [[foo.5]] and 2 for [[bar.5]], so the two previous
symbols can be designated respectively by [[tmp.1]] and [[tmp.2]].
Public symbols have their version set to 0.

\t #define VGLOBAL 0

The meaning of [[Sym.value]] depends on the kind of the symbol.
It also depends on the step in the linking pipeline. 
%dup: overview/soft-archi
At the beginning [[Sym.value]] contains 
a virtual program counter for [[TEXT]] symbols, and
a size for [[GLOBL]] symbols. 
At the end it contains 
a resolved memory address in the code section for procedures and 
a resolved offset to the start of the data section for globals.
\t use itemize? table!! with TEXT|GLOBL  and beginning|end!

\l The 'type' and 'value' in Sym are? 
% - for ATEXT it will be STEXT and the value will be a virtual pc
% - for AGLOBL it will be SBSS or SDATA, and the value will be its size
% before dodata() the value for a global stores its size. After location.
% before span() the value stores a virtual pc,
%  incremented by 1 between each instruction. After span() it stores the
%  final location at 4 bytes boundaries.
% => maybe use an union! 


%assembler:
% Explain special encart to related to code of 5a, because
% similar but different. Can be nice too relate. But optional for reader.
%assembler: Similar to Sym in Assembler.nw, but a few differences:
% - no 'type' (token_kind) field, no 'macro' field
% - no labels, they were translated in pc values.
% - no symidx field (but was local to outcode())
% - a new 'version' field; N_INTERN was in the Operand.symkind but the linker
%   now manages multiple objects together where can have the same static name
%   multiple times
% - a new 'type' field for the section, the linker has to resolve
%   as opposed to the assembler
% So this is really a symbol table, used for only one thing! good.


%dup: from Assembler
The symbol table itself is represented by a global {hash table}
called [[hash]]. It makes sense to use a global because
the symbol table will be accessed by different components
of the linking pipeline.
\l eg? ldobj, patch
%
One way to implement a hash table in C is to use a big array
of lists, also known as an array of {buckets}:

<<global hash linker>>=
// hash<Sym.name * Sym.version, ref_own<Sym>> (next = Sym.link in bucket)
Sym*	hash[NHASH];
@
\l when load the objects this hashtbl is populated
<<constant NHASH linker>>=
NHASH		= 10007,
@
%assembler: same except NHASH which was 503 in 5a
%ocaml: just use stdlib hashtbl

%dup: from Assembler
One way to implement a list of something in C is to embed in
this something a [[link]] field pointing to the next
element in the list:

<<[[Sym]] extra fields>>=
// list<ref<Sym>> (from = hash)
Sym*	link;
@

%dup: from Assembler
The end of the list is represented by the null pointer:

<<constant S>>=
#define	S		((Sym*)nil)
@


%dup: (and adapted) from Assembler
The main interface to the symbol table is the
function [[lookup()]] which internally uses the global [[hash]].
It takes a symbol name and a version, forming a full key,
and returns the [[Sym]] in the symbol table [[hash]] associated with 
this key, or a new symbol if the key was not found:

<<function lookup>>=
Sym*
lookup(char *symb, int v)
{
    Sym *sym;
    long h;
    int len;
    <<[[lookup()]] other locals>>

    <<[[lookup()]] compute hash value [[h]] of [[(symb, v)]] and [[len]]>>
    
    // sym = hash_lookup((symb, v), h, hash)
    for(sym = hash[h]; sym != S; sym = sym->link)
        if(sym->version == v)
            if(memcmp(sym->name, symb, len) == 0)
                return sym;

    // else
    <<[[lookup()]] if symbol name not found>>
}
@
%old: I rename s -> sym and l -> len
\l typedef int version;? and VERSION0 = 0 so clearer to read? a GLOBAL = 0?
%ocaml: use stdlib Hashtbl.find, sad duplicate from 5a/
%assembler: very similar, diff is use of (symb, v) instead of just (symb)
% could do the opti of fast-path/slow-path which avoids some memcmp? meh

<<[[lookup()]] other locals>>=
char *p;
int c;
@
<<[[lookup()]] compute hash value [[h]] of [[(symb, v)]] and [[len]]>>=
// h = hashcode(symb, v); 
// len = strlen(symb);
h = v;
for(p=symb; *p; p++) {
    c = *p;
    h = h+h+h + c;
}
len = (p - symb) + 1;
h &= 0xffffff;
h %= NHASH;
@
\l why plus 1 ?? figure? example?

<<[[lookup()]] if symbol name not found>>=
sym = malloc(sizeof(Sym));
sym->name = malloc(len + 1); // +1 again?
memmove(sym->name, symb, len);
sym->version = v;

sym->value = 0;
sym->type = SNONE;
sym->sig = 0;

// add_hash(sym, hash)
sym->link = hash[h];
hash[h] = sym;

<<[[lookup()]] profiling>>
return sym;
@
\t could have a syminit like in 5a
\l why plus 1 again ??

% sym->sig will be described in Safe linking section

\section{[[Section]]}

Another important property of a symbol is in which {\em section}
it will reside:

<<[[Sym]] section field>>=
//enum<Section>
short	type;
@
\l rename section?

<<enum Section(arm)>>=
enum Section
{
    SNONE = 0,

    STEXT,
    SDATA,
    SBSS,

    SXREF,
    <<[[Section]] cases>>
};
@
\l see also asmsym()

We can see enumerations above corresponding to the usual
text, data, and BSS sections of a program.
Note that there is no [[SSTACK]] enumeration as we care only 
about the executable file here, not the memory image of a program. 
The stack content and its maximum size is set initially by the kernel, 
not the executable.

[[SXREF]] is used to represent an {\em unknown reference}. When object
files are loaded in [[ldobj()]], symbol references in operands
are looked up in the symbol table. 
\l well N_EXTERN and N_INTERL
If the symbol has not been
defined yet, a new symbol is created with its section set to [[SXREF]]. Once
a [[TEXT]] or [[GLOBL]] directive introduces the symbol, 
its section can be adjusted.
%
At the end of the linking process there should be no more
symbols with [[SXREF]]. This is in fact checked by the
[[undef()]] function we will see in Section~\ref{sec:undef}.
\t lead to famous error message: undefined ref ...

\l those are mostly sections, or subsections (e.g. SDATA1 of SDATA,
\l  and SLEAF/SCONST/STRING of STEXT)

\n need STEXT vs SDATA? firstp and datap not enough?
\n functions like datblk iterate over symbol table, not datap


\section{[[Opcode]] and [[Operand]]}

%trans:
An object file contains essentially a list of {instructions} where
each instruction is made of 
an {\em opcode} with possibly 1, 2, or 3 {\em operands}.
%
The [[Opcode]] type, [[Operand_kind]] type, and a few register
aliases such as [[REGPC]], all used by [[5l]], are all defined in
[[include/arch/arm/5.out.h]]. 
Those types are fully described in the \book{Assembler}. 
%
{Dumpers} for those types are described in Appendix~\ref{sec:dumpers}
if you need to refresh your memory: 
\begin{itemize}
\item see [[Aconv()]] for the dumper of [[Opcode]] 
([[A]] because opcodes use the [[A]]$xxx$ syntax, e.g. [[ASUB]]),

\item see [[Dconv]] for the dumper of [[Operand_kind]] 
([[D]] because operand kinds use the [[D]]$xxx$ syntax, e.g. [[D_CONST]]).

\end{itemize}


Remember that the opcodes in object files do not correspond exactly to ARM
opcodes. They are mostly a superset because they also include
opcodes for {\em pseudo-instructions} such as [[ATEXT]] and [[AGLOBL]], as well
as opcodes for {\em virtual instructions} such as [[ARET]] and [[AMOVW]].
\n can put major opcodes here, AADD, ATEXT, AB, etc? done a bit above
\n and also D_REG? done a bit below.
\l and also N_INTERN?

[[include/arch/arm/5.out.h]] does not define an [[Operand]] type though
as the assembler and linker have slightly different needs for
this data structure. Here is the [[Operand]] type used by [[5l]]:

<<struct Adr(arm)>>=
struct	Adr
{
    // enum<Operand_kind> (D_NONE by default)
    short	type;

    // switch on Operand.type
    union {
        long	offset;
        Ieee*	ieee;
        char*	sval;
    };

    // option<enum<Register>> None = R_NONE
    short	reg; 

    <<[[Adr]] other fields>>
};
@
\n see DConv too
\n ATEXT arguments are also Adr (abuse)
\t rename Operand! 
%old: was called Adr
%note: offset abused for REGREG in which case it's really a int4
% but otherwise it's often used as an offset in D_BRANCH, D_OREG
% because indeed it's an offset to a basis (PC, SB, etc)
%assembler: Similar to Gen in Assembler.nw, but a few differences:
% - ieee was dval, and sval was sval[8]
% - have autom for TEXT  to keep track of N_PARAM and N_LOCAL for frame symbols
% - new 'class' field (but seems local to oplook())
% - the pointed Sym structure is a bit different
%ocaml: could factorize with Operand of 5a
%ocaml: would be better if had ADT so can have better Instruction type instead
% of those opcode, operand, Adr, and unions and all those comments

%assembler:
[[Operand]] is until now almost identical to the [[Operand]] type 
used by [[5a]] and  described in the \book{Assembler}, except for
the way float operands are represented ([[Ieee*]] versus a [[double]]).
The {\em operand kind} is also stored in [[Operand.type]], e.g.
[[D_CONST]], [[D_REG]], [[D_OREG]].
\l talk about offset? and relocations?
\l offset can be based on PC (for D_BRANCH), SB(for N_INTERN, N_EXTERN),
\l  on FP(for N_PARAM), and on SP(for N_LOCAL), 
\l  or can be direct value (for D_CONST)
[[Operand.reg]] is used again for operands involving registers.
\l reg Abused for NOPROF and DUPOK? could use a union again?
We will see later though additional fields specific to the linker.


Operands involving symbols use an [[Operand.sym]] field and
the {\em symbol kind} is also stored in a [[Operand.symkind]] field,
e.g. [[N_EXTERN]], [[N_PARAM]], [[N_LOCAL]] (which are
enumerations defined also in [[include/arch/arm/5.out.h]]):

<<[[Adr]] other fields>>=
// enum<Sym_kind>
short	symkind;
// option<ref<Sym>> (owner = hash)
Sym*	sym;
@
%old: was called 'name' but confusing, 
%old: sym was part of a union with Auto, but better that way

\l give a few examples of concrete operands? or refer to assembler book?

Symbols references in the assembly language of [[5a]], as well as in
object files, are all represented as ``offsets'' to {\em pseudo-registers}:
\l well for SB and globals it is kinda true

\begin{itemize}
\item procedures and globals use the [[SB]] ({\em static base}) 
pseudo-register, e.g. [[main(SB)]], [[hello(SB)]]. Their
symbol kind is [[N_EXTERN]] (or [[N_INTERN]] for private symbols
such as [[foo<>(SB)]]).

\item parameters are accessed via the [[FP]] ({\em frame pointer})
pseudo-register, e.g. [[p+4(FP)]]. Their symbol kind is [[N_PARAM]].

\item locals use the [[SP]] ({\em stack pointer}) pseudo-register,
e.g. [[v-8(SP)]]. Their symbol kind is [[N_LOCAL]].
\t SP usually negative no?

\end{itemize}

The symbol name for parameters and locals is actually optional.
What matters is the additional offset number for code generation. 
The symbol name is mostly a comment.
But, those symbols are still saved in the 
{executable symbol table} as we will see in Chapter~\ref{chap:debugging},
so they can be leveraged by tools such as debuggers.


\section{[[Instr]]uction}

The type below connects an opcode with its operands to form
a full {\em instruction}:

<<struct Prog(arm)>>=
struct	Prog
{
    //enum<Opcode>
    byte	as;

    // operands
    Adr	from;
    Adr	to;

    <<[[Prog]] other fields>>

    // Extra
    <<[[Prog]] extra fields>>
};
@
\t bad name .... I think Prog is really an Instruction
\t  Prog -> Instr,  p -> i | instr,  also Prog.as -> Instr.opcode?
%ocaml: could reuse type used by assembler, can put specificities
% outside the structure
%assembler: similar to the arguments of outcode():
%  - as (opcode), from (g1), to (g2), reg, scond, and
%    line field was a lineno global
%  - but some new fields: pc, mark
\l could rename cond to pcond and AB to AJMP and could factorize
\l  more code with x86
\n pseudo-opcode like ATEXT have operands too; from abused to store proc names
\l see Pconv percent P in printf

Most opcodes use two operands, transfering or processing data {\em from}
a source operand {\em to} a target operand, e.g. [[MOVW R1, (R2)]].
%
Some opcodes use three operands, e.g. [[ADD R1, R2, R3]]. 
In that case the middle operand is always a register, hence
the more specialized field below representing this middle operand:

<<[[Prog]] other fields>>=
// option<enum<Register>>, None = R_NONE
short	reg;
@
\n very arm specific!
\l This is used also to store TEXT attributes, e.g. DUPOK, NOPROF. 

All ARM instructions have a {\em conditional execution}
(see the \book{Assembler}):

<<[[Prog]] other fields>>=
// enum<Instr_cond>
byte	scond;
@
\l also special bits

For debugging purpose, each instruction has also a 
{\em global line number}:

<<[[Prog]] other fields>>=
long	line;
@

\l When object is the result of the assembly generated by 5c the line 
\l is the line in the .c so many ASM instructions have actually the 
\l same line because one C expression can result in many ASM instructions.
\l a global line after #include. 
For more information on line numbers and debugging
see Chapter~\ref{chap:debugging}.

\bigskip
%trans:
Up until now, [[Instr]] is very similar to
the type used in the \book{Assembler} to represent
an instruction\footnote{[[5a]] actually uses
a set of parameters to the [[outcode()]] function
to represent an instruction. Each parameter
is identical to one of the field of [[Instr]].
}.
%
The following field is new and specific to the linker.
It initially stores the {\em virtual program counter} of the instruction
(if the instruction is a code instruction, e.g. [[ADD]]):

<<[[Prog]] other fields>>=
long	pc;
@
\l The absolute pc of this instruction! 
\l needed for some check pc == p->pc somewhere.
\t type is  long | addr ?

%dup: overview/soft-archi 
The virtual program counter is incremented after each code instruction
is read in [[ldobj()]].
%
Later in the linking process [[Instr.pc]] will be assigned
a {\em real program counter} which will be a multiple of 4 as 
%dup: overview/5l-a
the ARM uses fixed-length instructions of 4 bytes.

\t Instr.cond here!

\label{sec:mark}
Finally, the field below is used by different algorithms to
temporarily {\em mark} instructions in the graph of instructions:

<<[[Prog]] other fields>>=
//bitset<enum<Mark>>
short	mark;
@
%old: was byte
% some generic tags to help some algoritms (e.g. for LEAF)

The different kinds of marks will be described gradually in
this document:

<<enum Mark(arm)>>=
/* mark flags */
enum Mark {
    <<[[Mark]] cases>>
};
@
%dead: LABEL
%not-so-useful opti: FOLL
%useful opti: LEAF
\n present ex of mark such as LEAF early? 
\n there were a few cases STEXT:case SLEAF: but I removed SLEAF so ok


%dead:
%<<[[Prog]] other fields>>=
%union
%{
%    long	regused;
%};
%@
% use anonymous union now, so don't need those aliases
%<<constant regused(arm)>>=
%#define	regused	u0.u0regused
%@
%<<constant forwd(arm)>>=
%#define	forwd	u0.u0forwd
%@
% now I just have a forward field, see mkfwd().

\section{List of instructions}
\l and instruction pointer?

%toc:
In this section we will see a set of globals keeping track
of different lists of instructions.

\t FIGURE where see evertything

\subsection{Code instructions, [[firstp/lastp]]}

[[firstp]] points to the first instruction
of the list of all {code instructions} 
(everything except the [[GLOBL]] and [[DATA]] pseudo-instructions):
\l includes TEXT, also does not include AEND and other stuff?

<<global firstp>>=
// list<ref_own<Prog>> (next = Prog.link)
Prog*	firstp;
@
\l good name? first_instr better? rename instrp?
\t rename codei and lastp -> ecodei

%dup: symbol table link
The instructions are linked together with the following field:

<<[[Prog]] extra fields>>=
// list<ref<Prog>> (from = firstp or datap)
Prog*	link;
@

%dup: symbol table S
The end of the list is represented by the null pointer:

<<constant P>>=
#define	P		((Prog*)nil)
@

One can quickly access the end of the list by using the
following global:

<<global lastp>>=
// ref<Prog>, last elt of firstp list
Prog*	lastp;
@
%ocaml: use a queue data structure, or returns simply a list and List.flatten
%  in ldobj()
\l strong coupling between firstp and lastp that should be encapsulated
\l   in a specific structure (like for datap/edatap)
% option<Prog>? usually there is a sentinel so there is always a lastp


\subsection{Data instructions, [[datap]]}

[[datap]] keeps track of the list of [[DATA]] pseudo-instructions:

<<global datap>>=
// list<ref_own<Prog>> (next = Prog.link)
Prog*	datap = P;
@
\n no need for edatap in arm

[[datap]] points to the last data instruction. 
\l how access first? need first? no need because no order needed for data
Note that [[GLOBL]] instructions are not part of this list.
Instead, the [[GLOBL]] instructions, when read, modify symbols
in the symbol table.

Thanks to [[firstp]] and [[datap]] all the code and
data instructions are separated in different {\em sections}.

\subsection{Procedure declarations, [[textp/etextp]]}
\l used by follow and asmsym, so maybe could be put later?
\l  would be better cos could also introduce Instr.cond differently

Another pair of globals keeps track of the 
list of procedures (the [[TEXT]] pseudo-instructions):
\l what for? asmsym, follow()

<<global textp>>=
// list<ref<Prog>> (next = Prog.cond)
Prog*	textp = P;
@
<<global etextp>>=
// ref<Prog> (end from = textp)
Prog*	etextp = P;
@
\n seems dead but not, used to link textp in right order

The procedure instructions are chained together with
another field of [[Instr]]:

<<[[Prog]] extra fields>>=
// option<ref<Prog>> for branch instructions
// list<ref<Prog>> (from = textp for TEXT instructions)
Prog*	cond;
@
\l called pcond I think in x86, could choose same name
\t mv before!!

Later during the linking process, this field will be used
to build a {\em graph of instruction}. Branching instructions
will have their [[Instr.cond]] field points to the
target instruction.



Note that the instructions in the list [[textp/etextp]]
are a subset of the list of instructions in [[firstp/lastp]].


\section{Current instructions, [[curtext/curp]]}

During the linking process, we will iterate many times over
the list of instructions. It is useful for error messages
to store in globals in which procedure we currently are ([[curtext]]) 
and which instruction we are currently processing ([[curp]]):
\n it's an error management issue but it is too important to be delayed
\n actually curtext used also to link curauto, not just for error reporting


<<global curtext>>=
//option<ref<Prog>> where Prog.as == ATEXT
Prog*	curtext = P;
@
\l there will be different curxxx, a bit ugly use of globals
\l curauto, curhist, curp

<<global curp>>=
// option<ref<Prog>>
Prog*	curp;
@
\l set only during iteration in asmb, but used in Pconv, diag messages, etc

Many algorithms will set [[curtext]] as follows while iterating
over instructions:

<<adjust curtext when iterate over instructions p>>=
if(p->as == ATEXT)
    curtext = p;
@
%old: I factorized code using this chunk more than what existed before
% by moving some curtext = p outside some if; it's sligtly slower
% but cleaner for LP purpose.

The [[TNAME]] macro (for [[T]]ext [[NAME]]) is used as an argument
to a few error management functions to display the name of the
current procedure when there is one:

<<constant TNAME(arm)>>=
#define	TNAME (curtext && curtext->from.sym ? curtext->from.sym->name : noname)
@
<<global noname linker>>=
char	*noname		= "<none>";
@
\l firsp not necessarily a TEXT, even though for C programs it should be
\l  as anyway _main will call main (but could have labels that play tricks)

%trans:
% few more DS, especially codegen, but presented later in Chapter X

\t BIG figure where see pointers, relation with hash table, instr
\l  operands, etc.  see cond overloay over link

%---------------------------------------------

%\section{[[Exec]]utable}
% actually not used by 5l ...

%\section{[[Optab]] and [[optab]]}?
%hmm maybe better later

%\section{[[Operand_class]]}
%hmm maybe better later

%\section{[[Buf]] and [[buf]]}?
%hmm maybe better in appendix or later

%\section{[[pc]]}?

%\section{[[textsize]], [[datasize]], [[INITDAT]], ...}?








\chapter{Main Functions}
\label{chap:main}

%trans: %dup: (and adapted) from Assembler.nw
We now switch to a top-down approach where
%toc:
we describe the main functions of [[5l]], starting from [[main()]]
down to [[asmb()]] which generates the executable.
\l well main in some sense is also generating the executable, hmm

\section{[[main()]]}

%trans: %dup: from Assembler.nw
Before showing the code of [[main()]] we first introduce
a few globals set by [[main()]].
%
A common pair of globals in \plan code
are [[thechar]] and [[thestring]] which both represent
the current architecture.
%dup: from intro/5l (and intro/5a)
As said in the introduction, \plan by convention 
represents architectures with a single character: 
[['0']] is MIPS, 
[['5']] is ARM, 
[['8']] is x86, etc.
%
This character is used by [[5l]]
for the filename extension of object files (e.g. [[hello.5]]): 
\n actually in 5l thechar is almost not used, just for histfrogp stuff
\l could be used also for 5.out but it is not.

<<global thechar>>=
char	thechar;
@

%dup: from Assembler
[[thestring]] contains the longer, more readable, version
of the architecture, e.g. [["arm"]] for [['5']].

<<global thestring>>=
char*	thestring;
@

This is used by [[5l]] to find the architecture-specific 
library files in [[/arm/lib/]]
as explained in Section~\ref{sec:loading-libraries-semi-auto}.

Another important global is the name of the executable,
which by default is [[5.out]]
%dup: overview/5l
and can be modified with the [[-o]] option:

<<global outfile>>=
char*	outfile;
@
\l why global? could pass around? for error msg?

The file descriptor of the created executable file will be
stored in the following global:

<<global cout>>=
fdt	cout = -1;
@
\n cout =~ create(outfile)
\l why need global for that? could be passed around too no? used only by asmb
\l  and asmout


%trans: %dup: (and adapted) from Assembler
We can now present the code of [[main()]], the entry point of [[5l]].
%
The most important part is the chunk below the [[-- main functions --]]
comment which contains the main flow of [[5l]]. It will be
described soon in Section~\ref{sec:main-flow}:

<<function main(arm)>>=
void
main(int argc, char *argv[])
{
    <<[[main()]] locals(arm)>>

    thechar = '5';
    thestring = "arm";   

    outfile = "5.out";

    <<[[main()]] debug initialization(arm)>>

    ARGBEGIN {
    <<[[main()]] command line processing(arm)>>
    } ARGEND

    USED(argc);
    if(*argv == nil)
        usage();

    <<[[main()]] initialize globals(arm)>>

    cout = create(outfile, 1, 0775);
    <<[[main()]] sanity check cout>>

    // ------ main functions  ------
    <<[[main()]] cout is ready, LET'S GO(arm)>>

out:
    <<[[main()]] profile report>>
    errorexit();
}
@
%old: set INITENTRY used to be in main flow after setting firstp/lastp
% but better here I think





<<function usage, linker>>=
void
usage(void)
{
    print("usage: %s [-options] objects", argv0);
    errorexit();
}
@
%old: was diag(...) not print(...) but then output ??none?? which was ugly

<<[[main()]] sanity check cout>>=
if(cout < 0) {
    diag("cannot create %s: %r", outfile);
    errorexit();
}
@

The error management functions [[diag()]] and [[errorexit()]]
are described in Appendix~\ref{chap:error}.
\l ex of output? 
\t Note percentr is error return code of last syscall I think


<<[[main()]] initialize globals(arm)>>=
<<[[main()]] addlibpath("/{thestring}/lib") or ccroot>>
<<[[main()]] set HEADTYPE, INITTEXT, INITDAT, etc>>
<<[[main()]] set INITENTRY>>
@
\l order important? if not then maybe can be introduced later gradually
\t explain? or introduce gradually?

\subsection{Arguments processing}

We have mentioned before the [[-o]] option:

<<[[main()]] command line processing(arm)>>=
case 'o':
    outfile = ARGF();
    break;
@

Other command line options will be introduced gradually in this document. 
%trans:
An important set of options deals with the executable format 
and are presented below.

\subsection{Executable format choice, [[5l -H]]}
\label{sec:choice-exec-format}

One of the most important option of [[5l]] is [[-H<num>]]
\n even though it should be very rarely used
which modifies the global [[HEADTYPE]]
recording the format of the executable:

<<global HEADTYPE>>=
// option<enum<Headtype>>, None = -1
short	HEADTYPE = -1; /* type of header */
@
%old: was int in ARM and long in x86, but I don't think it matters

<<[[main()]] command line processing(arm)>>=
case 'H':
    a = ARGF();
    if(a)
        HEADTYPE = atolwhex(a);
    break;
@
%old:    /* do something about setting INITTEXT */    what was that?

The [[atolwhex()]] function, described in Appendix~\ref{sec:atolwhex},
converts a string representing a number into an integer. 
[[atolwhex()]] also handles numbers written in hexadecimal, hence the name.
This is not very useful for the [[-H]] option, but it will
be useful for other options such as [[-T]] as we will see later.

By default [[5l]] uses the [[a.out]] format
which is the executable format used by \plan:

<<enum headtype(arm)>>=
/*
 *  -H0                     no header
 *  -H2 -T4128 -R4096       is plan9 format
 *  -H7                     is elf
 */
enum Headtype {
     H_NOTHING = 0,
     H_PLAN9 = 2, // a.k.a H_AOUT
     H_ELF = 7,
};
@
\l rename H_AOUT? 
\l reassign them? cos weird to go from 0 to 2 and 2 to 7
%todo: H_OMACH, H_PE
%old:
% *	-H1 -T0x10005000 -R4  is aif for risc os
% *	-H3 -T0xF0000020 -R4  is NetBSD format
% *	-H4				      is IXP1200 (raw)
% *	-H5 -T0xC0008010 -R1024 	is ipaq
% *	-H6 -R4096			   no header with segments padded to pages

%pad: I originally added H_DEFAULT. before there was some stuff with -9 -B -U
%  for probably  plan 9, plan B, Unix, but I removed it since, not that useful
% <<constant DEFAULT>>=
% #define	H_DEFAULT	H_PLAN9
% @
% rename H_DEFAULT_HEADTYPE? and make it part of the enum?

%old: 
% \section{[[5l -9 -B -U]]}
% dead I think, -9 for plan9, B for planB? U for Unix?
% <<constant DEFAULT>>=
% #define	DEFAULT	'9'
% @
% <<[[main()]] adjust HEADTYPE if debug flags(arm)>>=
% if(!debug['9'] && !debug['U'] && !debug['B'])
%     debug[DEFAULT] = true;
% 
% if(HEADTYPE == -1) {
%     if(debug['U'])
%         HEADTYPE = 0;
%     if(debug['B'])
%         HEADTYPE = 1;
%     if(debug['9'])
%         HEADTYPE = H_PLAN9;
% }
% @


The other executable formats, e.g. ELF, will be described later in 
Section~\ref{sec:other-executable-formats}.


The executable format dictates 
the size of the header, 
where the code section will be loaded in memory,
and how the data section will follow the code section,
by setting the following globals:
%ocaml: has to be some globals? could not be passed to asmb? or in a struct?

<<global HEADR>>=
long	HEADR; /* length of header */
@
\n 32 for a.out (0x20)
\l long? really?

<<global INITTEXT>>=
long	INITTEXT = -1; /* text location */
@
\t typedef long addr; ? and put option<Addr> where NONE = -1 ?
\l -1 is None
\n -T text segment start virtual address (important! e.g. for kernel 0x7c00)

<<global INITRND>>=
long	INITRND = -1; /* data round above text location */
@
\n -R text segment rounder at r multiple

<<global INITDAT>>=
long	INITDAT = -1; /* data location */
@
\n -D data segment start
\n normally after end of text, so dynamic



<<[[main()]] set HEADTYPE, INITTEXT, INITDAT, etc>>=
if(HEADTYPE == -1)
    HEADTYPE = H_PLAN9;
switch(HEADTYPE) {
<<[[main()]] switch HEADTYPE cases(arm)>>
default:
    diag("unknown -H option");
    errorexit();
}
<<[[main()]] sanity check INITXXX>>
DBG("HEADER = -H%d -T0x%lux -D0x%lux -R0x%lux\n",
        HEADTYPE, INITTEXT, INITDAT, INITRND);
@
%old: was -H0x%d but no sense
\t explain DBG?

Here are the specifics for the [[a.out]] format under \plan:

<<[[main()]] switch HEADTYPE cases(arm)>>=
case H_PLAN9:
    HEADR = 32L;
    if(INITTEXT == -1)
        INITTEXT = 4096+32; // 1 page + a.out header = 4128
    if(INITDAT == -1)
        INITDAT = 0;
    if(INITRND == -1)
        INITRND = 4096; // 1 page
    break;
@
\n 32 = 0x20 hence this note in kernel mkfile:
%# see mem.h, the additional 20 are the size of the a.out header added by LD
%KTZERO_AND_HEADER=0xE0100020

\t DBG explained in debugging-appendix, opportunity to explain -v,
\l and shows output?


[[INITDAT]] is initially set to 0 but it will be modified later
by [[dotext()]] to contain the address of the next memory {page}
\footnote{The size of the page is specified by [[INITRND]].}
after the code section.
Indeed, the memory pages for the code and data section will have different
properties (see the \book{Kernel}).

One can also manually set the start of the code and data sections, 
%dup: intro/5l
which is useful when producing {special binaries} such as kernels
or boot loaders:

<<[[main()]] command line processing(arm)>>=
case 'T':
    a = ARGF();
    if(a)
        INITTEXT = atolwhex(a);
    break;
case 'D':
    a = ARGF();
    if(a)
        INITDAT = atolwhex(a);
    break;
@
\l here useful atolwhex

<<[[main()]] command line processing(arm)>>=
case 'R':
    a = ARGF();
    if(a)
        INITRND = atolwhex(a);
    break;
@


<<[[main()]] sanity check INITXXX>>=
if(INITDAT != 0 && INITRND != 0)
    print("warning: -D0x%lux is ignored because of -R0x%lux\n",
        INITDAT, INITRND);
@
\l less important I think


\subsection{Executable entry point, [[5l -E]]}
\label{sec:choice-entry-point}

The entry point of a program can also be modified,
with the [[-E]] option:

<<global INITENTRY>>=
char*	INITENTRY = nil;		/* entry point */
@
<<[[main()]] command line processing(arm)>>=
case 'E':
    a = ARGF();
    if(a)
        INITENTRY = a;
    break;
@
\n -E default _main (or _mainp when -p)

%dup: introl/5l, overview/hello.5
It is set by default to [[_main]] under \plan, 
for reasons explained in Section~\ref{sec:explain-_main}:

<<[[main()]] set INITENTRY>>=
if(INITENTRY == nil) {
    INITENTRY = "_main";
    <<[[main()]] adjust INITENTRY if profiling>>
}
<<[[main()]] if rare condition do not set SXREF for INITENTRY, else>>
  lookup(INITENTRY, 0)->type = SXREF;
@
%old: this was done originally after setting firstp below, but
% better put that earlier I think
%old: the code before was more complex IMHO
% <<[[main()]] set INITENTRY>>=
% if(INITENTRY == nil) {
%     INITENTRY = "_main";
%     <<[[main()]] adjust INITENTRY if profiling>>
%     <<[[main()]] adjust INITENTRY if load_libs>>
% } else {
%     <<[[main()]] if digit INITENTRY>>
% }
% @
% <<[[main()]] adjust INITENTRY if load_libs>>=
% if(load_libs)
%     lookup(INITENTRY, 0)->type = SXREF;
% @
% <<[[main()]] if digit INITENTRY>>=
% if(!(*INITENTRY >= '0' && *INITENTRY <= '9'))
%    lookup(INITENTRY, 0)->type = SXREF;
% @
% The SXREF setting is done only when load_libs and only in the then branch.
% But why not do lookup and set to SXREF the entry point all the time?
% Why only when load_libs? and why not for digit INITENTRY?
% Because if use -l we want possibly INITENTRY to be first instruction?
\t real reason? first obj is entry point? but could -E _start no?

Unless some rare conditions we will explained in 
Section~\ref{sec:loading-libraries-magically},
the symbol for the entry point (usually [[_main]])
is looked up\footnote{
Remember from Section~\ref{sec:version}
that the second argument of [[lookup()]] is a version number
and all global symbols use [[0]] for their version.
}.
This will create a new symbol in the symbol table [[hash]]
as the symbol table is empty at the beginning.
\l ref to semantic of lookup
Then, by setting its section to [[SXREF]], the symbol for the entry
point is marked as a ``wanted'' symbol.
\l bootstrap!
Hopefully the object files or libraries passed on the command
line to [[5l]] will define this symbol. Otherwise,
because of [[SXREF]], an error message will be displayed
at the very end such as:

\begin{verbatim}
$ 5l no_main.5
??none??: entry not text: _main
??none??: _main: not defined
\end{verbatim}
\l first error not great, noise

\subsection{Main flow}
\label{sec:main-flow}

%trans:
We can finally present the main control flow of [[5l]] with
the calls to its main {components}. 
%
The code below follows closely the software architecture
we described in Section~\ref{sec:soft-archi}:

<<[[main()]] cout is ready, LET'S GO(arm)>>=
// first empty instruction
firstp = prg();
lastp = firstp;

// Loading (populates firstp, datap, and hash)
while(*argv)
    objfile(*argv++);
<<[[main()]] load implicit libraries>>

// skip first empty instruction
firstp = firstp->link;
if(firstp == P)
    goto out;

// Resolving
<<[[main()]] resolving phase>>

// Generating (writing to cout, finally)
asmb();

// Checking
undef();
@
%old: used to have set INITENTRY here, but better before I think
\l rename chunkname main flow?
\l why goto out? then 5l world.5 does not call undef and does not complain
\l  for lack of _main
\l could have a function link() just like have assemble() in Assembler.nw?
\l  use stuff from main? then maybe good, can pass them around, more explicit
%ocaml: all those functions that take no args are ugly, they use too
% many globals, e.g. firstp, lastp, I should really rewrite the code
% to be more functional.

The code steps are:
\begin{enumerate}
\item to {\em load} the object files and libraries passed on the command line
(as well as possibly other ``implicit'' libraries as explained in 
Section~\ref{sec:loading-libraries-magically}),

\item to {\em resolve} symbols, 

\item to {\em generate} the executable, 

\item to {\em check} finally if there are still some undefined symbols
(e.g. whether [[_main]] has been defined).

\end{enumerate}

The first line above allocates an empty instruction with [[prg()]].
This first instruction is used as a {\em sentinel} which simplifies 
code modifying later [[firstp/lastp]]. 
This first empty instruction is then skipped a few lines later.
%
[[prg()]] uses the global [[zprg]] which is set to represent an empty
instruction:
\l well it is not really empty, it is more undefined or to-be-defined

<<constructor prg>>=
Prog*
prg(void)
{
    Prog *p;

    p = malloc(sizeof(Prog));
    *p = zprg;
    return p;
}
@
\l rename! new_instr?

<<global zprg>>=
Prog	zprg;
@
\n zero prg, to initialize new Prog

<<[[main()]] initialize globals(arm)>>=
<<[[main()]] set zprg(arm)>>
@

<<[[main()]] set zprg(arm)>>=
zprg.as = AGOK;
zprg.scond = COND_ALWAYS; 
zprg.reg = R_NONE;
zprg.from.type = D_NONE;
zprg.from.symkind = N_NONE;
zprg.from.reg = R_NONE;
zprg.to = zprg.from;
@
\t BUGS not defined other fields?
%bug: what about .class? should be set to C_NONE no?
%bug? and optab? should be null no? there is code using p->optab like oplook()

All of the constants above, e.g. [[R_NONE]], are defined
in [[include/arch/arm/5.out.h]].
%
The [[AGOK]] (God Only Knows) opcode
\l sure it means god Only Knows? 
represents an  {\em undefined instruction}.
It is recognized by some error management code in [[5l]] 
(see Section~\ref{sec:AGOK})
and used as a form of {defensive programming}.
%ocaml: do not need that I think. typing and exhaustic check is better
% than defensive programming
\l could use AXXX? or ANOP? 
\t actually 5c generates some AGOK, but to continue even when error (meh?)

\bigskip
%toc:
The following sections will each describe one of the
function mentioned in the main flow above.
\n the main components

\section{Loading the objects and libraries, [[objfile()]]}

[[objfile()]] takes either the name of 
an object file (e.g. [[foo.5]])
or a library (e.g. [[libc.a]])
and reads the object code in it.
\l other way to link libs we will see later, but they call back objfile
%
First, [[objfile()]] opens and reads a few bytes of the file to decide
whether it is an archive or an object file 
\l why not use filename extension to decide?
by checking if those bytes match an {\em archive magic string} ([[ARMAG]]).
%
Then it loads the file.
The code below shows only the simple case where the file is an object file.
The more complex case where the file is a library will
be described later in Chapter~\ref{chap:loading-libraries}.
\l repeat too much the code?
\t sure no ambiguity with regular object files? Axxx

<<function objfile>>=
/// main | loadlib  -> <>
void
objfile(char *file)
{
    fdt f;
    long len;
    char magbuf[SARMAG]; // magic buffer
    <<[[objfile()]] other locals>>

    DBG("%5.2f objfile: %s\n", cputime(), file);

    <<[[objfile()]] adjust file if -lxxx filename>>

    f = open(file, 0);
    <<[[objfile()]] sanity check f>>

    len = read(f, magbuf, SARMAG);

    // is it a regular object? (not a library)
    if(len != SARMAG || strncmp(magbuf, ARMAG, SARMAG)){
        /* load it as a regular file */
        len = seek(f, 0L, SEEK__END); // len = filesize(f);
        seek(f, 0L, SEEK__START);

        // the important call!
        ldobj(f, len, file);

        close(f);
        return;
    }
    // else
    <<[[objfile()]] when file is a library>>
}
@
%old: renamed l -> len
\l rename objfile -> ldobj and ldobj -> ldinstrs, f -> fd?
\l  as it can actually load a slice of an object, just a procedure
\n portable function! (ldobj is not though)
\l explain DBG? used a bit for profiling here.

[[SARMAG]] above stands for [[S]]ize of [[AR]]chive [[MAG]]ic string.
%
The most important part in the code above is the call
to [[ldboj()]] which loads in memory one (opened) object file.
\l or part of a library seeked to right place
Chapter~\ref{chap:loading-objects} will describe [[ldobj()]].

\l essentially modify which globals?
\l  - should modify firstp! and textp, datap, lastp, etc
\l  - will modify libraryp probably, the cool pragma "autolib"
\l    which is why objfile() must be called before loadlib()


<<[[objfile()]] sanity check f>>=
if(f < 0) {
    diag("cannot open %s: %r", file);
    errorexit();
}
@

\section{Resolving symbols, computing addresses}

%trans:
The next step, after loading the objects, is to 
%
resolve the symbol references in those objects and to compute the
final addresses of those symbols.
%
We will delay the explanations about this step to
Chapter~\ref{chap:resolving} where we will see multiple functions
doing multiple passes on the set of instructions
and the symbol table.
\l use firstp/lastp, use hash, build graph of instruction, layout

\section{Generating the executable, [[asmb()]]}
\label{sec:gen-executable}
\l asmb? asm binary? meh

%trans:
After the symbols are resolved, and their memory addresses computed,
%
we can finally generate the executable with [[asmb()]]:

<<function asmb(arm)>>=
/// main -> <>
void
asmb(void)
{
    <<[[asmb()]] locals>>

    DBG("%5.2f asm\n", cputime());

    // Text section
    <<[[asmb()]] Text section>>

    // Data section
    <<[[asmb()]] Data section>>

    // Symbol and Line table sections
    <<[[asmb()]] symbol and line table sections>>

    // Header
    <<[[asmb()]] header section>>

    cflush();
}
@
%ocaml: pass cout as a parameter, and also list of instr, data, hash, etc
\t cflush? shown in appendix, buffer management, cout

[[asmb()]] does not take any argument. It uses the global [[cout]],
which was initialized in [[main()]] with the file descriptor of the 
executable file, to output data in the executable.

Note that the order of operations above may seem incorrect.
The code to generate the header is at the end, which seems paradoxal.
\l even impossible, but SEEK
But, the header specifies the size of the sections,
and so we first need to know thoses sizes
before generating the header, hence the order of operations.
\l actually textsize/datasize are known already, but not symsize

\l no BSS section because the binary executable will not contain
\l  anything related to BSS except its size.

The code in [[asmb()]] uses and modifies the local variable [[OFFSET]]
below to point to different parts of the executable file. It will be passed
to the C function [[seek()]] to move around in the file.

<<[[asmb()]] locals>>=
long OFFSET;
@
%old: was a global but can be just a local in asmb()
% <<global OFFSET(arm)>>=
% long	OFFSET;
% @


%toc: ???
\t toc? or put before when see high-level view of code/

\subsection{Header}
\label{sec:gen-header}

The header generation (done last) assumes the set of globals
containing the size of sections ([[textsize]], [[datsize]], etc) 
have been computed previously:
\l but actually not in asmb() but in dotext() and dodata()
\l but symsize and lcsize are computed in asmb()

<<[[asmb()]] header section>>=
DBG("%5.2f header\n", cputime());

OFFSET = 0;
seek(cout, OFFSET, SEEK__START);

switch(HEADTYPE) {
<<[[asmb()]] switch HEADTYPE (for header generation) cases(arm)>>
}
@

<<[[asmb()]] switch HEADTYPE (for header generation) cases(arm)>>=
// see Exec in a.out.h
case H_PLAN9:
    <<[[asmb()]] if dynamic module magic header adjustment(arm)>>
    else
        lput(0x647);			/* magic */

    lput(textsize);			/* sizes */
    lput(datsize);
    lput(bsssize);
    lput(symsize);			/* nsyms */

    lput(entryvalue());		/* va of entry */
    lput(0L);
    lput(lcsize);
    break;
@
\t s/0x647/E_MAGIC?

If you do not understand the order
of the [[lput()]] above, see Section~\ref{sec:exec-format} 
which describes the format of the [[a.out]] header used by \plan.

The address of the entry point is looked up in the symbol table
in the [[Sym.value]] field of the [[INITENTRY]] symbol:
\l explained in core DS chapter and in soft archi

<<function entryvalue(arm)>>=
long
entryvalue(void)
{
    char *a;
    Sym *s;

    a = INITENTRY; // usually "_main"
    <<[[entryvalue()]] if digit INITENTRY>>

    s = lookup(a, 0);

    switch(s->type) {
    case SNONE:
        return INITTEXT; // no _main, start at beginning of binary then
    case STEXT:
        return s->value;
    <<[[entryvalue()]] if dynamic module case>>
    default:
        diag("entry not TEXT: %s", s->name);
        return 0;
    }
}
@
%old: case SLEAF:
\t rename a and s bad names; s -> sym. a -> ? str?
%ocaml: could at least take initentry as a parameter instead of using a global

\subsection{Text section}
\label{sec:asmb-text-section-overview}

%trans:
The text section generation is of course more complicated.
\l assumes layout code? well redo a bit with pc increment so assume less
%
[[asmb()]] iterates over all the code instructions
and calls [[oplook()]] to get additional information [[o]] about 
the instruction [[p]].
Then it calls the important function [[asmout()]] which
generates actual ARM instructions from [[p]].
[[asmout()]] will also use the global [[cout]] to modify the 
executable file.
\l repeat too much the code?

<<[[asmb()]] Text section>>=
OFFSET = HEADR;
seek(cout, OFFSET, SEEK__START);

pc = INITTEXT;
for(p = firstp; p != P; p = p->link) {
    <<adjust curtext when iterate over instructions p>>
    <<adjust autosize when iterate over instructions p>>
    curp = p;
    <<[[asmb()]] in Text section generation, sanity check pc>>

    o = oplook(p);
    // generate ARM instruction(s)!
    asmout(p, o);

    pc += o->size;
}
<<[[asmb()]] before cflush, debug>>
cflush();

<<[[asmb()]] Text section, output strings in text segment>>
}
@
\t need to be pc? need use the global? I understand for ldobj, but for asmb?
\t  could maybe use local like  realpc ?
%old: o = oplook(p);	/* could probably avoid this call */
% because could just use p->optab cache?
% but ok cos oplook actually uses optab. oplook() memoize things.

[[oplook()]] returns a pointer to an [[Optab]] entry
described in Section~\ref{sec:optab}.

<<[[asmb()]] locals>>=
Prog *p;
Optab *o;
@
\l o is bad name, looks like opcode.

[[oplook()]] essentially looks at the opcode and operands in [[p]] and 
\l pattern match
returns the {kinds} of actual ARM instructions that
will be needed to encode the instruction [[p]].
It also returns the total size of those ARM instructions.
%dup: overview/5l-a and core-ds/instr
Because the ARM uses fixed-length instructions of 4 bytes, 
the total size will be a multiple of 4.

Note that one instruction [[p]] can lead to
the generation of multiple ARM instructions.
%
Indeed, the instructions of the assembly language of [[5a]], 
and so the instructions in the object files, 
do not match exactly ARM instructions.
%
For instance, the {virtual instruction} [[DIV]] has
no counterpart in the ARM and is converted in a serie of ARM 
instructions which ends with the call to the function [[_div()]] 
of the core C library.
\t actually noops has rewritten DIV already
\l same for MOVW, also constraints on immediate constant in ARM but not Asm5
\l  but maybe can delay later
See Chapter~\ref{chap:arm-codegen} for more information about
[[Optab]] and [[oplook()]].
\l and \book{Assembler} for more information about virtiaul instruction?


Note that 
[[OFFSET]] is initialized to [[HEADR]] above while
[[pc]] to [[INITTEXT]].
%dup: overview/principles
Indeed, offsets in the executable and memory addresses
are different concepts, as explained in 
Section~\ref{sec:disk-image-vs-memory-image}.


[[asmb()]] updates also the global [[pc]] above,
but the address resolution of code instructions
(in [[Instr.pc]])
has already been done in [[dotext()]]. This is repeated
here just for sanity checking:
\t hmm but maybe also used for code generation? need that in global? 
\t  as jumps are relative in the ARM!

<<[[asmb()]] in Text section generation, sanity check pc>>=
if(p->pc != pc) {
    diag("phase error %lux sb %lux", p->pc, pc);
    if(!debug['a'])
        prasm(curp);
    pc = p->pc;
}
@
\l actually good to do that, can have bugs where size of things
\l  can have changed (see the mutual dependency issue discussed later)





\subsection{Data section}

%trans:
The data section generation assumes the layout of globals
has already been done  (via [[dodata()]]),
just like the code section generation in the previous
section assumed the layout of code has also been done (via [[dotext()]]).
%dup: overview/tutorial overview/soft-archi, core-ds/sym
The [[Sym.value]] field of all data symbols should now
contain the address of the global
as an offset to the start of the data section, 
\t say here again rational for this vs final address explained in Section X?
\t (INITDAT)? or set actually by asmb?
and [[datsize]] should have been set.


\ifallcode
<<[[asmb()]] locals>>=
long t;
@
\fi

<<[[asmb()]] Data section>>=
curtext = P;
switch(HEADTYPE) {
<<[[asmb()]] switch HEADTYPE (to position after text) cases(arm)>>
}

<<[[asmb()]] if dynamic module, before datblk()>>

for(t = 0; t < datsize; t += sizeof(buf)-100) {
    if(datsize-t > sizeof(buf)-100)
        datblk(t, sizeof(buf)-100, false);
    else
        datblk(t, datsize-t, false);
}
@
\l what the fuss about those 100?? and what is sizeof(buf)?
\t factorize code for those sizeof(buf)-100
\t no use of datap?

<<[[asmb()]] switch HEADTYPE (to position after text) cases(arm)>>=
case H_PLAN9:
    OFFSET = HEADR+textsize;
    seek(cout, OFFSET, SEEK__START);
    break;
@

Note again that the code seeks to [[HEADR+textsize]], which
may not be a page boundary. This is fine
%dup: overview/principles, previous section
since offsets in the executable file are not memory addresses
as explained in Section~\ref{sec:disk-image-vs-memory-image}.

[[datblk()]] will be explained in Section~\ref{sec:datblk}.



\subsection{Symbol and line table sections}

The generation of the symbol and line table sections
will be explained in Chapter~\ref{chap:debugging}


\section{Checking for unresolved symbols, [[undef()]]}
\label{sec:undef}

The final step is making sure there is no more
undefined symbols:

<<function undef>>=
/// main -> <>
void
undef(void)
{
    int i;
    Sym *s;

    for(i=0; i<NHASH; i++)
        for(s = hash[i]; s != S; s = s->link)
            if(s->type == SXREF)
                diag("%s: not defined", s->name);
}
@
\l rename check_if_still_undefined_symbols()?
\l famous not defined error msg!



%trans: ok seen asmb so at least know where we should go, what
% it the goal (textsize, datsize, Sym.value, Instr.pc, etc)




\chapter{Loading Objects}
\label{chap:loading-objects}
\n Was Parsing obj, but objs are stored in binary format so Loading obj better.
\n Confusing with the loader in the kernel? actually man/1/8l uses "loader".
\n  But 5l is actually also loading/copying data from disk in memory,
\n  a bit like the kernel loader, except it is a different file format.

%trans: %dup: (and quite adapted) from Assembler
Now that we have seen the code or a high-level view of
the code of the main functions of [[5l]], we can
start to go deeper and detail the different components of the
linking pipeline.
%toc
We start in this chapter with the {loading} of object files in memory
performed mostly by [[ldobj()]].
\n 'mostly' because also objfile()

%ocaml: use Marshall and List.flatten (but less friendly to other languages) 

\section{Object file format, [[.5]]}
\label{sec:object-format}

%trans:
Before reading the code of [[ldobj()]]
it is good to have in mind the format of object files.
%
This format is summarized in Figure~\ref{fig:object-format-complete}.
See the \book{Assembler} if you need more explanations.

%dup: from Assembler.nw (just added AHISTORY,ANAME, AXXX, AEND)
\begin{figure}[!]\centering
\begin{verbatim}
+--------------+        ^-------------+
|     AEND     |       /|             |
+--------------+      / |             |
|Instruction 5 |     /  |             |
|              |    /   |  Operand 2  |
+--------------+    |   |             |
|Instruction 4 |    |   |             |
|              |    |   |             |       ^-------------+
+--------------+    |   |             |/-----/|             |
|  ANAME ...   |    |   +-------------X       |             |
+--------------+    |   |             |       |             |
|  ANAME ...   |    |   |             |       |Operand value|
+--------------+    |   |  Operand 1  |       |             |
|              |    /   |             |       |             |
|Instruction 3 |   /    |             |       |             |
|              |  /     |             |       |             |
+--------------+ /      +-------------X       +-------------+
|  ANAME ...   |/       |             |\      | Symbol kind |
+--------------X        |    Line     | \     +-------------+
|Instruction 2 |        |             |  \    |Symbol index |
|              |        |             |   \   +-------------+
+--------------X        +-------------+    \  |  Register   |
|Instruction 1 |\       |  Register   |     \ +-------------+
|              | \      +-------------+      \|Operand kind |
+--------------+  \--\  |  Condition  |       v-------------+
| Files/lines  |      \ +-------------+
|   history    |       \| AXXX Opcode |
|  (AHISTORY)  |        v-------------+
+--------------+

    File                  Instruction             Operand
\end{verbatim}
\caption{Format of a [[.5]] object file}
\label{fig:object-format-complete}
\end{figure}

\section{A global and local program counter, [[pc]] and [[ipc]]}
\l could be put later? if aspectize code doing ipc = pc in ldobj?

%trans:? before ldobj see important global

%dup: overview/soft-archi, core-ds/instr
A very important global which will be used by [[ldobj()]] is
the {\em virtual program counter}:
\t actually later it become a real program counter

<<global pc>>=
long	pc = 0;
@

%dup: overview/soft-archi, core-ds/instr
[[ldobj()]] will increment [[pc]] after each code instruction read
as we will see in Section~\ref{sec:opcode-dispatch}.
%
Note that [[pc]] is a {\em global} and so
persists between different calls to [[ldobj()]]. Thus,
all the instructions in the different object files will
have a unique program counter value in [[Instr.pc]].
\l that is the spirit of global concatenation
%
[[ldobj()]] is also using the {\em local} below
to store the value of the program counter at the beginning
of the call:

<<[[ldobj()]] locals(arm)>>=
long ipc;
@
\l internal pc? objects are loaded after each other,

[[ipc]] will be used for {relocating} branching instructions
as we will see in Section~\ref{sec:relocating}.

\section{Object code input, [[ldobj()]]}
\label{sec:ldobj}

%trans:
We can now see the code of [[ldobj()]].
%
The function takes 3 parameters:
[[f]] the file descriptor of the (opened) object file,
[[c]] the size of this object file, and
\l really? can be also size of whole library?
[[pn]] the name of this object file used mostly for error management.
\t rename f -> fd, c -> len, pn -> filename
%
[[ldobj()]] essentially reads instructions from [[f]]
in a loop where each iteration allocates a new instruction
[[p]] with the opcode [[o]] and populates either
[[firstp]] or [[datap]] depending on the opcode.
\l and also [[hash]] for operands, and some opcodes too, and also ANAME

<<[[ldobj()]] locals(arm)>>=
Prog *p;
// enum<Opcode>
short o;
@
\t actually byte would be enough

An important local is [[bloc]] which is a {\em cursor} in an
{\em input buffer} derived from [[f]] as explained soon in 
Section~\ref{sec:ldobj-input-buffer}.
%
It allows the code which parses instructions to access
individual bytes of an instruction in the object file as 
[[bloc[0]]], [[bloc[1]]], etc. 
\l a bit like it was mmap'ed

<<function ldobj(arm)>>=
/// main -> objfile -> <>
void
ldobj(fdt f, long c, char *pn)
{
    <<[[ldobj()]] locals(arm)>>

    <<[[ldobj()]] remember set of object filenames>>
    <<[[ldobj()]] bloc and bsize init>>

// can come from AEND
newloop:
    // new object file
    ipc = pc;
    <<[[ldobj()]] after newloop when new object file, more initializations>>

loop:
    if(c <= 0)
        goto eof;

    <<[[ldobj()]] read if needed in loop:, adjust bloc and bsize>>

    o = bloc[0];		/* as */
    <<[[ldobj()]] sanity check opcode in range(arm)>>

    // dispatch opcode part one
    <<[[ldobj()]] if ANAME or ASIGNAME(arm)>>
    // else

    p = malloc(sizeof(Prog));
    p->as = o;
    <<[[ldobj()]] read one instruction in p>>
    p->link = P;
    p->cond = P;

    <<[[ldobj()]] sanity check p>>
    <<[[ldobj()]] debug>>

    // dispatch opcode part two
    switch(o) {
    <<[[ldobj()]] switch opcode cases(arm)>>
    }
    goto loop;

eof:
    diag("truncated object file: %s", pn);
}
@
%old: I transformed the code to use malloc instead of gethunk()
%bugfix: again on gethunk, was doing if(nhunk < ...) instead of while(nhunk...)
% the bug seems only in arm, x86 does the correct while
% but forsyth say anyway a hunk is bigger than a Prog so a if would work too

%trans:
[[ldobj()]] is a complex and very long function. We splitted it in many
{chunks} to facilitate its comprehension.
%toc:
The rest of this chapter will detail most of those chunks.

Note that the code above looks like a loop which can
finish only in an error. But, one of the chunk
dealing with the [[AEND]] opcode (see Section~\ref{sec:aend}),
hidden in the [[switch]] above,
contains actually a [[return]] which can escape the loop.
%
In fact, [[AEND]] explains also the reason for the two
loop labels [[newloop]] and [[loop]]. Indeed, [[ldobj()]] can
also be used to read a whole library in which case
we want to also iterate over the multiple object files 
contained in one library file, which, as we will see in
Chapter~\ref{chap:loading-libraries},
are separated by the [[AEND]] opcode.

\subsection{Single instruction input}

%trans:
An important chunk of [[ldobj()]] deals with the parsing
of one instruction whose format is described 
in the middle of Figure~\ref{fig:object-format-complete}.
%assembler:
The code below does mostly the reverse operation
of [[outcode()]] in the \book{Assembler}
and {reads} one instruction:


<<[[ldobj()]] read one instruction in p>>=
// mostly opposite of outcode() in 5a
// p->as = bloc[0] has been done already above so continue from bloc[1]
p->scond = bloc[1];
p->reg   = bloc[2];
p->line  = bloc[3] | (bloc[4]<<8) | (bloc[5]<<16) | (bloc[6]<<24);
r = 7;
r += inopd(bloc+r, &p->from, h);
r += inopd(bloc+r, &p->to, h);

bloc += r;
c -= r;
@
% >> >> >>
\l extract func and call incode? so opposite of outcode? 
% (but not good name either)

The code to read an operand uses [[inopd()]] which is shown
in the next section. %clever \ref{sec:inopd}
Its last argument is related to the {\em object file symbol table} and will
be fully explained in Section~\ref{sec:h}.


<<[[ldobj()]] sanity check opcode in range(arm)>>=
if(o <= AXXX || o >= ALAST) {
    diag("%s: line %ld: opcode out of range %d", pn, pc-ipc, o);
    print("	probably not a .5 file\n");
    errorexit();
}
@
\l it is not really a line, it is an estimation of line number
\l  but why not use bloc[3] and so on?

<<[[ldobj()]] sanity check p>>=
if(p->reg > NREG)
    diag("register out of range %d", p->reg);
@


\subsection{Operand input, [[inopd()]]}
\label{sec:inopd}

%assembler:
[[inopd()]] does mostly the reverse of [[outopd()]]
in the \book{Assembler}
%
and {reads} one operand from the object file.
The format of an operand is described 
in the right of Figure~\ref{fig:object-format-complete}.
%
[[inopd()]] returns the number of bytes that were used to read
this operand as operands can have different size:

<<function inopd(arm)>>=
/// main -> objfile -> ldobj -> <>
int
inopd(byte *p, Adr *a, Sym *h[])
{
    int size; // returned
    int symidx;
    <<[[inopd()]] other locals>>

    a->type = p[0];
    a->reg = p[1];
    <<[[inopd()]] sanity check register range>>
    symidx = p[2];
    <<[[inopd()]] sanity check symbol range>>
    a->sym = h[symidx];
    a->symkind = p[3];

    size = 4;

    switch(a->type) {
    <<[[inopd()]] cases>>
    default:
        print("unknown type %d\n", a->type);
        p[0] = ALAST+1;
        return 0;	/*  force real diagnostic */

    }
    <<[[inopd()]] adjust curauto for N_LOCAL or N_PARAM symkind>>

    return size;
}
@
\t rename a, use opd or something  and DO NOT USE p, use blocp or something
\t ALAST subtle because return 0, but maybe should use errorexit instead
\t  and actually will not work if issue was in first operand as there will
\t  be another call to inopd which may work ... by luck.
\l use AGOK instead of ALAST?
%old: was called zaddr() but I renamed to inopd()
%  similar to zaddr -> outopd in Assembler.nw
%  also c -> symidx
%old: I moved the sanity check of register ranger closer to a->reg
\l could do the set to SXREF when global symbol kind here
\l  instead of in code handling ANAME (and its redundant symkind)

The local [[symidx]] contains a {\em symbol index}
in the object file symbol table [[h]] passed as a parameter. 
This index and the table will be explained in Section~\ref{sec:h},
but the important result is that [[Operand.sym]] will point
to a symbol in the symbol table [[hash]].

The operands have variable size depending on the operand kind:

<<[[inopd()]] cases>>=
// 0 byte
case D_NONE:
case D_REG:
case D_PSR:
    break;

// 1 byte
case D_REGREG:
    a->offset = p[4];
    size++;
    break;

// 4 bytes
case D_CONST:
case D_SHIFT:
case D_OREG:
case D_BRANCH:
    a->offset = p[4] | (p[5]<<8) | (p[6]<<16) | (p[7]<<24);
    size += 4;
    break;

// 8 bytes (NSNAME)
case D_SCONST:
    a->sval = malloc(NSNAME);
    memmove(a->sval, p+4, NSNAME);
    size += NSNAME;
    break;
@
%//case D_OCONST: was with D_SHIFT
% >> >> >> >>



<<[[inopd()]] sanity check register range>>=
if(a->reg < 0 || a->reg > NREG) {
    print("register out of range %d\n", a->reg);
    p[0] = ALAST+1;
    return 0;	/*  force real diagnostic */
}
@


\subsection{Buffered input, [[buf]]}
\label{sec:ldobj-input-buffer}

%trans:
We can now explain the code connecting [[bloc]] 
to the file descriptor [[f]].
%
To read object files, [[ldobj()]]
uses a global called [[buf]] of type [[Buf]]
as well as many utility functions forming a sort
of {\em input/output buffer management} library. 
This code is quite generic and independent of [[5l]] and so
most of it is described in Appendix~\ref{sec:buffer-management}.
\l they could use libbio?
%ocaml: use stdlib
%
The most important thing for this chapter is that [[Buf.ibuf]]
contains an array of bytes, the {\em input buffer}, 
filled from time to time by the function [[readsome()]]. 
A few locals of [[ldobj()]] are pointers in this array:

<<[[ldobj()]] locals(arm)>>=
// array<byte> (slice of buf.ibuf)
byte *bloc;
// ref<byte> (end pointer in buf.ibuf)
byte *bsize;
// remaining bytes, bsize - bloc
int r;
@
%old: was char, but I prefer byte

%dup: loading-obj/ldobj
[[bloc]] is a {\em cursor} in the input buffer which is moved around.
%
It allows the code which parses instructions to access
individual bytes of an instruction in the object file as 
[[bloc[0]]], [[bloc[1]]], etc, 
as we have seen in the previous sections.
%alt: could use mmap?
%
It is initialized to the start of the input buffer:

<<[[ldobj()]] bloc and bsize init>>=
bloc = buf.ibuf;
bsize = buf.ibuf;
@

Figure~\ref{fig:input-buffer} represents the evolution of the state
of [[buf.ibuf]] while the input buffer gets filled by [[readsome()]].
%
The code to fill as needed the input buffer is below:

<<[[ldobj()]] read if needed in loop:, adjust bloc and bsize>>=
r = bsize - bloc;
if(r < 100 && r < c) {		/* enough for largest instruction */
    bsize = readsome(f, buf.ibuf, bloc, bsize, c);
    if(bsize == nil)
        goto eof;
    bloc = buf.ibuf; // readsome() does some memmove()
    goto loop;
}
@
%old: comment was "largest prog" but Prog -> Instr so I changed it.
%bug? if filename or string bigger than 100 in ANAME?
% no because the code above is only for for regular opcodes, not ANAME
\l need goto loop? can not just fallthrough?

%dup: (and adapted) from Assembler
\begin{figure}[!]\centering
\begin{verbatim}
0                                                      8192 
+-------------------------------------------------------+
|                                                       |
+-------------------------------------------------------+
^
|                             
bloc, bsize             r = 0 (< 100)

(a) Empty buffer in buf.ibuf

0                                                      8192
+-------------------------------------------------------+
|42|12|253|        ...                               |43|                       
+-------------------------------------------------------+
^<----------------------------------------------------->^
|              r                                        |
bloc                                                  bsize

(b) After first call to readsome(): returned bsize
\end{verbatim}
\caption{Evolution of the input buffer and [[ldobj()]] pointers}
\label{fig:input-buffer}
\end{figure}


The number [[100]] above represents a ``window'' large enough
to read one full instruction from the object file.
%
At some point [[bloc]] will get close to [[bsize]]
and [[readsome()]] will be called again, even if
the input buffer contains still some unprocessed bytes.
%
This simplifies the rest of the code in [[ldobj()]] 
and [[inopd()]] which can
simply access [[bloc[0]]], [[bloc[1]]], etc without
having to worry whether they need to call [[readsome()]] again.

Figure~\ref{fig:input-buffer2} represents the evolution of the state
of [[buf.ibuf]] while the input buffer gets filled another
time by [[readsome()]]. The bytes at the end of the input buffer
are first moved to its beginning and the rest of the buffer is
filled by more data from [[f]].

\begin{figure}[!]\centering
\begin{verbatim}
0                                    8093              8192
+-------------------------------------------------------+
|42|12|253|        ...                |10|   ...     |43|                       
+-------------------------------------------------------+
                                      ^<--------------->^
                                      |                 |
                    ldobj() locals:  bloc   r = 99    bsize
                 readsome() locals:  good     n       stop

(a) before second call to readsome()

0                99                                    8192
+-------------------------------------------------------+
|10|     ...  |43|36| ...                            |57|                       
+-------------------------------------------------------+
^                ^<------------------------------------>^
|                |               n                      |
|               stop                                    |
bloc                                                  bsize

(b) after second call to readsome()
\end{verbatim}
\caption{Evolution of the input buffer and [[readsome()]] pointers}
\label{fig:input-buffer2}
\end{figure}


<<function readsome>>=
byte*
readsome(fdt f, byte *buf, byte *good, byte *stop, int max)
{
    int n;

    n = stop - good;
    memmove(buf, good, n);
    stop = buf + n;
    n = MAXIO - n;
    if(n > max)
        n = max;
    n = read(f, stop, n);
    if(n <= 0)
        return nil;
    return stop + n;
}
@
%old: argument to memmove was stop - good but n better
\n was in appendix, but too close; only issue is MAXIO but can say it is 8192
\l also need handle max, show figure where bsize is not always
\l  at the very end

\subsection{Object file symbol table, [[h]] and [[ANAME]]}
\label{sec:h}
\n better put before Opcode dispatch so understand use of from->sym in ATEXT
\n also closer to other discussions about object file format and readsome()

%trans:
Object files contain mostly instructions. They contain also 
%
an {\em object file symbol table} which is {\em spread}
in the file and where each entry starts with the [[ANAME]] opcode,
as shown in the left of Figure~\ref{fig:object-format-complete}.
The object file symbol table is also a {\em circular} array.
Its entries define symbols which are then referenced in operands
of some following instructions via a {\em symbol index},
as shown in the right of Figure~\ref{fig:object-format-complete}.

An important chunk of [[ldobj()]] deals with those [[ANAME]] entries.
%
The format of each {entry} starts with 
the pseudo-opcode [[ANAME]]
followed by the kind, 
symbol index, and 
the name of the symbol as a possible long string terminated with [['\0']].
\t FIGURE?
\t need kind? well to the SXREF below done only for global symbols.
\t  but could be done in inopd instead?
\t  yes but need for N_INTERN! so bump version and allocate different symbols!
\t  but could be done again in inopd
\t need index? fault-tolerance?
%
See the \book{Assembler} if you need more explanations.

%dup: (and adapted) from Assembler
The local [[h]] below mimics in memory this circular table:

<<[[ldobj()]] locals(arm)>>=
// array<option<ref<Sym>>>
Sym *h[NSYM];
@

[[NSYM]] is a constant defined in [[include/objs/common.out.h]]
which is also used by [[5a]] and so which was described already
in the \book{Assembler}.
\t include/devel/output/common.out.h  -> include/objs/ 
%assembler:
[[h]] was a global in [[5a]] but is a local variable in [[5l]] as
each object file contains its own symbol table.
\l also was Htab (=~ Sym x symkind) vs Sym
%
The table is reset for each new object file processed:

<<[[ldobj()]] after newloop when new object file, more initializations>>=
memset(h, 0, sizeof(h));
@
\l note newloop! because library have multi object files, multi symbol tables

[[h]] is populated by [[ldobj()]] as the object file is read
and new [[ANAME]] entries are found. [[ldobj()]]
also populates the global symbol table [[hash]] via [[lookup()]].
Figure~\ref{fig:object-h-hash} shows the relation
between those data structures.
%
Remember that the first operand of an instruction like 
[[MOVW foo(SB), R1]] is represented in the object file
as 4 elements, as shown in the right of Figure~\ref{fig:object-format-complete},
using 4 bytes: 
the operand kind ([[D_OREG]]), 
a possible register number ([[R_NONE]]),
a symbol index ([[1]]), and
a symbol kind ([[N_EXTERN]]).
%
This operand is summarized as [[idx:1 EXT]]
in Figure~\ref{fig:object-h-hash}.

\begin{figure}[!]\centering
\begin{verbatim}
+--------------------+                                 +---+
|AEND                |                                 |   |
+--------------------+                                 |   |
|                    |                                 |   |
|...                 |                                 |   |
|                    |                  +----------+   +---+
|                    |                  |...       |<--+-  |
+--------------------+                  +----------+   +---+
|AMOVW idx:2 EXT, R3 |                                 |   |
|                    |          +---+   +----------+   +---+
+--------------------+   +---+  |   |<--|"foo", ...|<--+-  |
|ANAME EXT 2 "bar"   | 49|   |  +---+   +----------+   +---+
+--------------------+   +---+                ^        |   |
|AMOVW R2, idx:1 EXT |   |   |                |        |   |
|                    |   |   |                |        |   |
+--------------------+   |...|                |        |   |
|AMOVW idx:1 EXT, R1 |   |   | +--------------+        |   |
|                    |   |   | |                       |   |
+--------------------+   |   | |                       |   |
|ANAME EXT 1 "foo"   |   +---+ |                       +---+
+--------------------+  2|  -+-+-+                     |   |
|AADD R1, R2, R3     |   +---+ | |      +----------+   +---+
|                    |  1|  -+-+ +----->|"bar", ...|<--+-  |
+--------------------+   +---+          +----------+   +---+
|AHISTORY ...        |  0|   |                         |   |
+--------------------+   +---+                         +---+
                                          Symbols
      Object file          h                           hash
\end{verbatim}
\caption{Object file and values of [[h]] and [[hash]] in memory}
\label{fig:object-h-hash}
\end{figure}

We can now see the local variables
and the code of [[ldobj()]] dealing with [[ANAME]]
(and also partially with [[ASIGNAME]] which will be explained 
in section~\ref{sec:ASIGNAME}):

<<[[ldobj()]] locals(arm)>>=
// enum<Sym_kind>
int k;
int symidx;
int v;
// ref<byte> (in Buf.ibuf)
byte *stop;
@
%pad: I introduced symidx, and renamed v -> k, and keep v for version


<<[[ldobj()]] if ANAME or ASIGNAME(arm)>>=
if(o == ANAME || o == ASIGNAME) {
    <<[[ldobj()]] if SIGNAME adjust sig>>

    stop = memchr(&bloc[3], '\0', bsize-&bloc[3]);
    <<[[ldobj()]] if stop is nil refill buffer and retry>>

    k = bloc[1];	/* type */
    symidx = bloc[2];	/* sym */

    bloc += 3;
    c -= 3;

    v = 0; // global version by default
    <<[[ldobj()]] when ANAME opcode, if private symbol adjust version>>

    // this will possibly create new symbols
    s = lookup((char*)bloc, v);

    c -= &stop[1] - bloc;
    bloc = stop + 1;

    <<[[ldobj()]] if sig not zero>>
    <<[[ldobj()]] when ANAME, debug>>

    h[symidx] = s;

    if((k == N_EXTERN || k == N_INTERN) && s->type == SNONE)
        s->type = SXREF;

    <<[[ldobj()]] when ANAME opcode, if D_FILE>>
    goto loop;
}
@
%ocaml: Marshall, oh my god we save so much code by using marshall
%old: was abusing o to store symidx, r to store version, v to store name
% I introduced instead symidx, v, n;
\n it's not part of the switch, it's done before!
\t what about symbol uses for params and locals with same name than globals?
\t  5a accepts that? conflict?

[[ldobj()]] first extracts the string from the 
[[ANAME]] entry and calls [[lookup()]] on it.
%
This creates a new entry in the symbol table [[hash]],
unless this symbol is a global symbol ([[v == 0]]) which was defined
in another object file loaded before, or if the same symbol
was introduced before in the same object file due to the circular
nature of the object file symbol table.
%
[[ldobj()]] then updates [[h]] so further references
of the symbol index in operands of instructions coming after
will be transformed in pointers (in [[Operand.sym]]) to the right
symbol entry in [[hash]]. Indeed, see the instruction
[[a->sym = h[symidx]]] of [[inopd()]] in Section~\ref{sec:inopd}.
%
We can now also understand the sanity check of the symbol 
index in [[inopd()]]:

<<[[inopd()]] sanity check symbol range>>=
if(symidx < 0 || symidx > NSYM){
    print("sym out of range: %d\n", symidx);
    p[0] = ALAST+1;
    return 0;
}
@
\t use errorexit, not this ALAST trick and return 0

Note also that [[ldobj()]] sets the symbol section to [[SXREF]]
for symbols refering to procedures or globals (e.g. [[foo(SB)]]
but also [[tmp<>(SB)]]) if the symbol was just created.
This symbol is now marked as ``wanted''.
\l for objfile() and loadlib() to correctly work! checked by undef
\t explain partially also why need redundant symkind in ANAME, because
\t  job done here (but could be done instead in inopd() I think)

The reading of an [[ANAME]] entry requires to have the full
string (ending with [['\0']]) in the input buffer:

% buffer management crap again
<<[[ldobj()]] if stop is nil refill buffer and retry>>=
if(stop == nil){
    bsize = readsome(f, buf.ibuf, bloc, bsize, c);
    if(bsize == nil)
        goto eof;
    bloc = buf.ibuf;
    stop = memchr(&bloc[3], '\0', bsize-&bloc[3]);
    if(stop == nil){
        fprint(2, "%s: name too long\n", pn);
        errorexit();
    }
}
@
% >> >>

\subsection{Private symbols and version}

As mentionned in Section~\ref{sec:version}, {private symbols}
in different object files using the same name, e.g. [[tmp<>]] 
in [[foo.5]] and [[tmp<>]] in [[bar.5]], can be differentiated
thanks to a {\em version} number stored in a global:

<<global version>>=
int	version = 0;
@

This version is a unique integer representing an object file
by simply incrementing it each time a new object file is parsed:

<<[[ldobj()]] after newloop when new object file, more initializations>>=
version++;
@

Every reference to a private symbol in an object file then uses
the version corresponding to this object file:

<<[[ldobj()]] when ANAME opcode, if private symbol adjust version>>=
if(k == N_INTERN)
    v = version;
@




\section{Opcode dispatch}
\label{sec:opcode-dispatch}

%trans:
Once an instruction [[p]] with its opcode and operands have been read, 
%
[[ldobj()]] looks at the opcode and modifies different
globals in a [[switch]] on the opcode value.
%toc:
The following sections describe the different cases of this
[[switch]] which are mostly concerned with {pseudo-instructions}.

\subsection{[[A]]$xxx$}
\label{sec:axxx}

The default case corresponds to regular instructions, e.g. [[AMUL]].
%that is non pseudo-instructions:
\n note that ASUB is handled specially to look for opti opportunity
\n  but go back to casedef is optimisation pattern does not match

\label{sec:relocating}
<<[[ldobj()]] switch opcode cases(arm)>>=
default:
casedef:
    <<[[ldobj()]] in switch opcode default case, if skip>>

    // relocation
    if(p->to.type == D_BRANCH)
        p->to.offset += ipc;

    //add_queue(firstp, lastp, p)
    lastp->link = p;
    lastp = p;

    p->pc = pc;
    pc++;
    break;
@
\l how does p->to.offset plus egal ipc; works with library code?
% in objfile it seems we seek to the TEXT procedure we want but
% this procedure may not be the beginning of the object, and
% the D_BRANCH offsets are based on the beginning of the object file no?

The code above modifies many of the globals we mentioned before
and illustrates many of the concepts we introduced before:

\begin{itemize}

\item branching instructions are {relocated} thanks to the local
program counter [[ipc]] which contains the new 
{memory address origin} of the object file containing the instruction
\l well in term of virtual pc still

%dup: overview/soft-archi core-ds/list-instrs
\item the global [[firstp]] (via [[lastp]]) is updated to contain the
new code instruction

%dup: overview/soft-archi core-ds/instr load-obj/global-pc
\item each instruction gets its [[Instr.pc]] field set to the
value of the program counter at the moment the instruction is read
%dup: ... too many
%(and will contain later the final code address of the instruction)

%dup: overview/soft-archi core-ds/instr load-obj/global-pc
\item finally the virtual program counter [[pc]] is incremented after
a code instruction is read

\end{itemize}
\n same order than in code



\subsection{[[ATEXT]] and [[autosize]]}

Remember from the \book{Assembler} that
pseudo-instructions use the same format than regular instructions
in the object file.
\n actually everywhere, also in memory, a bit abuse
%
So, for the [[TEXT]] pseudo-instruction, e.g. [[TEXT foo(SB), $8]], %$
the name of the procedure is stored in the first operand 
([[Instr.from]])
while the size for its {local variables} is stored in the second operand 
([[Instr.to]]).
In fact, [[Instr.from.sym]] is a pointer to a symbol in the
symbol table [[hash]] (see the code of [[inopd()]] in Section~\ref{sec:inopd})
where [[Sym.name]] contains the procedure's name:
\l symbol table only for global or procedures, not for locals/params anymore

<<[[ldobj()]] locals(arm)>>=
Sym *s;
@
\t rename sym?

<<[[ldobj()]] switch opcode cases(arm)>>=
case ATEXT:
    <<[[ldobj()]] case ATEXT, if curtext not null adjustments for curauto>>
    curtext = p;
    <<[[ldobj()]] in switch opcode ATEXT case, reset skip>>
    <<[[ldobj()]] in switch opcode ATEXT case, set autosize>>

    s = p->from.sym;
    <<[[ldobj()]] sanity check for ATEXT symbol s>>
    s->type = STEXT;
    s->value = pc;

    // like in default case
    //add_queue(firstp, lastp, p)
    lastp->link = p;
    lastp = p;

    p->pc = pc;
    pc++;

    //add_queue(textp, etextp, p)
    if(textp == P) {
        textp = p;
        etextp = p;
    } else {
        etextp->cond = p;
        etextp = p;
    }
    break;
@
%$
\l see curtext

The code is similar to the default case we have seen in 
the previous section.
In addition, the list of procedures in [[textp]] is updated
and the section and value {properties} of the procedure symbol
are modified. In particular, 
%dup: overview/soft-archi core-ds/symbol
[[Sym.value]] contains now
the virtual program counter of the procedure,
%
which will be useful for resolving branching instructions involving
the procedure's name later in Chapter~\ref{chap:resolving}.
\l later Sym.value will be final address
\l Sym.value = Instr.pc here
%
%Note that the code above also increments [[pc]] because as we will see
%in Section~\ref{sec:atext-patching} the [[TEXT]] pseudo-instruction
%can acually be transformed in a real ARM instruction.
%We would not want a branch to the procedure's symbol to be the same
% than a branch to  ...
\t maybe need increment pc independently of this special instruction



<<[[ldobj()]] sanity check for ATEXT symbol s>>=
if(s == S) {
    diag("TEXT must have a name\n%P", p);
    errorexit();
}
if(!(s->type == SNONE || s->type == SXREF)) {
    <<[[ldobj()]] case ATEXT and section not SNONE or SXREF, if DUPOK>>
    diag("redefinition: %s\n%P", s->name, p);
}
@
%old: s->type != SNONE && s->type != SXREF

%\subsection{adjusting [[autosize]]}

The size for the local variables of the current procedure
is also stored in a global:

<<global autosize(arm)>>=
long	autosize;
@
\t rename stacksize? curstacksize?
% arm specific? not in x86?
% used a lot by aclass(), for what?

Local variables, also known as {\em automatic variables},
are hold in the {\em stack} of the process.
%
The size for those locals is specified in the procedure
declaration, e.g. 8 in [[TEXT foo(sb), $8]], %$
which will be enough to contain 2 locals using 4 bytes each.
%
In fact, [[5l]] first {rounds} the size at a 4 byte boundary
and then increments it by 4:

<<[[ldobj()]] in switch opcode ATEXT case, set autosize>>=
p->to.offset = rnd(p->to.offset, 4);
autosize = p->to.offset;
autosize += 4;
@
%old:
% autosize = (p->to.offset+3L) & ~3L;
% p->to.offset = autosize;

The reason for the 4 increment is to allocate space in the stack
to {save} the {\em return address} stored in the
{\em link register} [[R14]] (aliased as [[REGLINK]]).
See the \book{Assembler} to refresh your memory
about the {branch and link} instruction and the \plan{}
{calling conventions}.
\t ref to talk more about that in ATEXT patching and RET?

Many algorithms will update [[autosize]] as follows while iterating
over all the instructions, just like they do with [[curtext]]:

<<adjust autosize when iterate over instructions p>>=
if(p->as == ATEXT) {
    autosize = p->to.offset + 4;
}
@



\subsection{[[AGLOBL]]}

%trans:
The code dealing with globals is simpler than the one dealing with procedures.
%
Remember that 
for the [[GLOBL]] pseudo-instruction, e.g. [[GLOBL hello(SB), $12]], %$
the symbol of the global is stored in the first operand  ([[Instr.from]])
while its optional size is stored in the second operand ([[Instr.to]]):

<<[[ldobj()]] switch opcode cases(arm)>>=
case AGLOBL:
    s = p->from.sym;
    <<[[ldobj()]] sanity check for AGLOBL symbol s>>
    s->type = SBSS; // for now; will be set maybe to SDATA in dodata()
    s->value = (p->to.offset > 0) ? p->to.offset : 0;
    break;
@
%old: 
%    s->value = 0;
%    if(p->to.offset > s->value)
%        s->value = p->to.offset;
\l sanity check people entering negative size for the globals? can happen?
\l could be even more succint?

No list of instructions is modified. The only effect of a [[GLOBL]]
{declaration} is the modification of a symbol in the symbol table. 
It is the [[DATA]] pseudo-instructions which populate the data section
as we will see in the next section.
%dup: overview/tutorial overview/soft-archi core-ds/sym main/gen/data
Note that for now [[Sym.value]] contains the size of the global.
%Later it will contain the resolved memory address of the global
%(as an offset to the start of the data section).

<<[[ldobj()]] sanity check for AGLOBL symbol s>>=
if(s == S) {
    diag("GLOBL must have a name\n%P", p);
    errorexit();
}
if(!(s->type == SNONE || s->type == SXREF))
    diag("redefinition: %s\n%P", s->name, p);
@
%pad: the second check used to be written differently, but I prefer
% it this way to mimic more what we do for ATEXT
%old:
%		if(s->type == 0 || s->type == SXREF) {
%			s->type = SBSS;
%			s->value = 0;
%		}
%		if(s->type != SBSS) {
%			diag("redefinition: %s\n%P", s->name, p);
%			s->type = SBSS;
%			s->value = 0;
%		}

\subsection{[[ADATA]]}

The code dealing with [[DATA]] pseudo-instructions is trivial.
It just populates [[datap]]:

<<[[ldobj()]] switch opcode cases(arm)>>=
case ADATA:
    <<[[ldobj()]] sanity check for ADATA symbol s>>

    //add_list(datap, p)
    p->link = datap;
    datap = p;

    break;
@

Note that we could set the section of the symbol to [[SDATA]]
here with code like [[s->type = SDATA;]]. But this would
complicate the code to detect redefinition of symbols
in the previous section. Indeed, [[DATA]] pseudo-instructions
can precede a [[GLOBL]] declaration.
This is why the modification of the section to [[SDATA]]
is done in [[dodata()]] later instead.


<<[[ldobj()]] sanity check for ADATA symbol s>>=
if(p->from.sym == S) {
    diag("DATA without a sym\n%P", p);
    break;
}
@

\subsection{[[AEND]]}
\label{sec:aend}

[[AEND]] is a pseudo-opcode inserted as the end of each object file
by the assembler or compiler.
%dup: (and adapted a little) from Assembler
It is a {\em special marker} convenient to have 
when dealing with {libraries}. Indeed, libraries are little
more than object files concatenated together, as we will
see in Chapter~\ref{chap:loading-libraries},
and [[AEND]] marks represent object {boundaries}.

<<[[ldobj()]] switch opcode cases(arm)>>=
case AEND:
    <<[[ldobj()]] case AEND, curauto adjustments with curhist>>
    <<[[ldobj()]] case AEND, curauto adjustments>>
    curtext = P;

    if(c)
        goto newloop;
    return;
@

The important instruction above is [[return]] which
allows to exit from [[ldobj()]] without any error.
%
\l when goto newloop? when have stuff behind an AEND?
\l for library? aggregate to have AEND between files?
\l see next chapter.
\t but seems like objfile call ldobj with len for just object file
\t  so not sure why need newloop.

\l really need AEND? anyway header of .ar have size of objects so ...
\l  or it is useful for redundancy, fault-tolerance?

\subsection{[[AGOK]]}
\label{sec:AGOK}

[[AGOK]] (God Only Knows) is a pseudo-opcode used
to initialize new instructions in [[5l]]. It is also used
for the same reason in [[5c]].
\n in 5a? there is no Instr, just outcode
It should always be overriden at some point by a real opcode, 
hence the warning code below:
\l defensive programming? it continues? no errorexit?

%sanity:
<<[[ldobj()]] switch opcode cases(arm)>>=
case AGOK:
    diag("unknown opcode\n%P", p);
    p->pc = pc;
    pc++;
    break;
@
%x86:     diag("%s: GOK opcode in %s", pn, TNAME);
%ocaml: do not use, initialize instructions directly with right opcode
\l could use AXXX? or ALAST?




\section{Safe linking}
\label{sec:ASIGNAME}
\n in adv topic? safe linking is an essential feature IMHO!
%ocaml: cool, like in ocamlc! ocaml does that too, to make linking more safe!

An interesting feature of object files and [[5l]], 
not present in traditional linkers,
\l the linux kernel has something related to that
is the possibility 
(1) to attach {\em signatures} to symbols in object files, and 
(2) to check for {\em signature compatibility} when the same symbol
is mentioned multiple times in different object files.
%
This makes linking far {safer}.

\subsection{Motivations}

Imagine the following scenario: a file [[foo.c]]
defines a function [[foo()]] taking two integer parameters
and not returning anything.
The function is exported in a header file [[foo.h]].
Another file [[bar.c]] is including the header and
calls [[foo()]] with two integers. Both files
are compiled resulting in the object files [[foo.5]] and [[bar.5]] which
can be linked together.
%
Later on, an additional
parameter is added to [[foo()]] in [[foo.h]] and [[foo.c]]
and [[foo.c]] is recompiled leading to a new [[foo.5]] object file.
%
At this point, without signatures, there is nothing that prevents
the new [[foo.5]] and 
the old [[bar.5]] 
to be linked together to form an executable.
%
Traditional linkers will happily link those object
files resulting in an executable
which, at run-time, will not have the right behavior
([[bar.5]] contains a call to [[foo()]] with not enough parameters).


Of course, many projects use a [[Makefile]] where accurate
file dependencies can alleviate the issue.
%
One can specify manually for instance that [[bar.5]] depends also
on [[foo.h]]. Then, any modification of [[foo.h]] will trigger automatically
the regeneration of [[bar.5]].
%
Dependencies can also be automatically generated by tools like [[gcc -MM]].
%
Still, it is easy to make mistakes and miss some dependencies,
or to forget to use {shared headers},
in which case there is no tool to detect the possible linking
of incompatible object files (except by running the executable
and get occasionally a segmentation fault).

\subsection{[[ASIGNAME]] and [[5c -T]]}

When two C files reference the same entity,
we want to enforce that those two references have the same {\em type}.
\l enforced by compiler via shared header, at least compatible type.
\l actually not really enforced by compiler, can do wrong extern declaration
\l  if not using shared header
%
[[ASIGNAME]] is a pseudo-opcode generated by [[5c]] 
when using the [[-T]] option ([[T]] for type)
which attaches a {\em signature} to a symbol. It is an alternate to
[[ANAME]] with additional 4 bytes after the [[ASIGNAME]] opcode,
and before the symbol kind, to store a signature
as a [[ulong]]:

<<[[ldobj()]] locals(arm)>>=
ulong sig;
@
<<[[ldobj()]] if SIGNAME adjust sig>>=
sig = 0;
if(o == ASIGNAME){
    sig = bloc[1] | (bloc[2]<<8) | (bloc[3]<<16) | (bloc[4]<<24);
    bloc += 4;
    c -= 4;
}
@
% >> >> >> >>

This signature is stored as another symbol property:

<<[[Sym]] other fields>>=
// for instance last 32 bits of md5sum of the type of the symbol
ulong	sig;
@
%old: was long, but not consistent with ulong sig; local in ldobj

<<[[ldobj()]] if sig not zero>>=
if(sig != 0){
    <<[[ldobj()]] signature compatibility check>>
    s->sig = sig;
    <<[[ldobj()]] remember file introducing the symbol>>
}
@


In practice, signatures are {derived} from the type
of an entity by the compiler. 
%
For instance, in our scenario above,
the signature of [[foo()]] in the object file could
be the result of the last 32-bits of the {\em md5sum} of the string
representing the type, e.g. [[md5sum("void(int,int)") == 0x4a2489a1]].
%
This signature would be attached to the symbol [[foo]] in
[[foo.5]] and [[bar.5]].
%
Later on, when an integer parameter
is added, the signature of [[foo]] in [[foo.5]] would become
[[md5sum("void(int,int,int)") == 0x74100cff]].
%
The linking of the new [[foo.5]] and old [[bar.5]] would then
be detected and prevented by the code below:


<<[[ldobj()]] signature compatibility check>>=
if(s->sig != 0 && s->sig != sig)
    diag("incompatible type signatures %lux(%s) and %lux(%s) for %s", 
         s->sig, filen[s->file], 
         sig, pn, 
         s->name);
@
\n but must have every object file use ASIGNAME. If one use ANAME no check.

The actual algoritm used by [[5c]] to compute the signature
is actually not the md5sum. See the \book{Compiler}
to learn more about how signatures are generated.
\l by default 5c generates ANAME instead of ASIGNAME

\subsection{Error management}

To give good error messages like:

\begin{verbatim}
$ 5l foo.5 misc.5 bar.5 /arm/lib/libc.a 
bar: incompatible type signatures bde91c57(foo.5) and adb3322b(bar.5)
  for foo
\end{verbatim}
%pad: I split on two lines

\noindent one needs to remember in the symbol which file introduced
the symbol the first time. 
[[Sym.file]] below contains an {\em index}
in the private array [[filen]] representing the file:

<<[[Sym]] other fields>>=
// index in filen[]
ushort	file;
@
%bug?  ushort? so can link 65536 files maximum
%ocaml: just use string directly, it will be shared for free!

<<[[ldobj()]] locals(arm)>>=
// growing_array<option<string>>  (grown for every 16 elements)
static char **filen;
// index of next free entry in filen
static int files = 0;
@

<<[[ldobj()]] remember set of object filenames>>=
<<[[ldobj()]] grow filen if not enough space>>
filen[files++] = strdup(pn);
@

<<[[ldobj()]] remember file introducing the symbol>>=
s->file = files-1;
@

[[filen]] is actually a {\em growing array}:

<<[[ldobj()]] locals(arm)>>=
char **nfilen; // new filen
@
<<[[ldobj()]] grow filen if not enough space>>=
if((files&15) == 0){
    nfilen = malloc((files+16)*sizeof(char*));
    memmove(nfilen, filen, files*sizeof(char*));
    free(filen);
    filen = nfilen;
}
@
\n =~ realloc

Thanks to [[Sym.file]] and [[filen]], the two conflicting files
can be displayed by the (repeated) code below:
\begin{verbatim}
diag("incompatible type signatures %lux(%s) and %lux(%s) for %s", 
    s->sig, filen[s->file], 
    sig, pn, 
    s->name);
\end{verbatim}



%\section{File and line information, [[AHISTORY]]}
% see debugging section







\chapter{Loading Libraries}
\label{chap:loading-libraries}

%trans:
% next in linking pileline is loading library. Actually also
% performed partly by ldobj(). library is set of objects
% so call ldobj too.

% 5l actually loads only the object files in the librairies containing 
% the functions/data which are mentionned by the main object files
% (starting from _main).
% So it removes lots of code which helps generate small binaries 
% (see helloc which is only 4618 bytes).
% Note that the granularity is the object file; if it was the function/data
% it could remove even more code.

% see 5l -W -v helloc.5 to see the different passes, which symbols
% are needed, which object files in the archive are read, which ANAME
% are processed, etc.

\section{Archive library format, [[.a]]}

% see ar(5) man page

% from ar.h
<<constant ARMAG>>=
#define	ARMAG	"!<arch>\n"
@
% ARchive MAGic?

<<constant SARMAG>>=
#define	SARMAG	8
@
%size ARMAG

<<constant ARFMAG>>=
#define	ARFMAG	"`\n"
@
% ARchive F? MAGic
% separator between each ar_hdr entries?

<<constant SARNAME>>=
#define SARNAME	16
@
%size ARNAME
% so can't have symbol names of more than 16 characters?

% seems to be the symbol file header and also each file entry header
<<struct ar_hdr>>=
struct	ar_hdr
{
    char	name[SARNAME];

    char	date[12];
    char	uid[6];
    char	gid[6];
    char	mode[8];

    char	size[10]; // use atolwhex() to get the value
    char	fmag[2]; // ARFMAG
};
@
%less: s/char/byte!

% an archive contains:
% MAGIC header "<arch"
% symbol table which is a kind of map from symbol to file entry offset
% file entry header
% object file content
% file entry header
% object file content
% ...

<<constant SAR_HDR>>=
#define	SAR_HDR	(SARNAME+44)
@
% sizeof(struct ar_hdr)


<<global symname linker>>=
char	symname[]	= SYMDEF;
@
% in 5.out.h #define	SYMDEF "__.SYMDEF"
% the first ar_hdr entry is the symbol table.

%todo: What is the format of the symbol table?
% see the strchr(e+5, ...) below, it's weird

%I could not originally see how ldobj() could work
% when you seek to an individual TEXT. Indeed the branch jumps
% are absolute with the 0 basis as the first instruction in the file,
% not the first instruction in the procedure. It's because you
% actually don't seek to individual function. The symbol table
% contains offsets for symbols which are not the offset of their TEXT
% but the offset of their object file entry in the archive file.

% AEND boundary mark

\section{Loading libraries manually, [[5l libxxx.a]]}

<<[[objfile()]] other locals>>=
struct ar_hdr arhdr;
long off, esym, cnt;
Sym *s;
char pname[LIBNAMELEN];
char name[LIBNAMELEN];
char *e, *start, *stop;
bool work;
int pass = 1;
@



<<[[objfile()]] when file is a library>>=
DBG("%5.2f ldlib: %s\n", cputime(), file);

len = read(f, &arhdr, SAR_HDR);

<<[[objfile()]] sanity check library header size and content>>

esym = SARMAG + SAR_HDR + atolwhex(arhdr.size);
off = SARMAG + SAR_HDR;

/*
 * just bang the whole symbol file into memory
 */
seek(f, off, 0);
cnt = esym - off;
start = malloc(cnt + 10);
cnt = read(f, start, cnt);
if(cnt <= 0){
    close(f);
    return;
}
stop = &start[cnt];
memset(stop, '\0', 10);

work = true;
while(work) {

    DBG("%5.2f library pass%d: %s\n", cputime(), pass, file);
    pass++;
    work = false;
    for(e = start; e < stop; e = strchr(e+5, 0) + 1) {

        s = lookup(e+5, 0);
        // loading only the object files containing symbols we are looking for
        if(s->type == SXREF || 
           (s->type == SNONE && strcmp(s->name, "main") == 0)) {
            sprint(pname, "%s(%s)", file, s->name);
            DBG("%5.2f library: %s\n", cputime(), pname);
            
            len = e[1] & 0xff;
            len |= (e[2] & 0xff) << 8;
            len |= (e[3] & 0xff) << 16;
            len |= (e[4] & 0xff) << 24;
            // >> >> >> >>
            
            seek(f, len, SEEK__START);
            len = read(f, &arhdr, SAR_HDR);
            <<[[objfile()]] sanity check entry header>>
            len = atolwhex(arhdr.size);

            // loading the object file containing the symbol
            ldobj(f, len, pname);
            
            if(s->type == SXREF) {
                diag("%s: failed to load: %s", file, s->name);
                errorexit();
            }
            work = true; // maybe some new SXREF has been found in ldobj()
           <<[[objfile()]] an SXREF was found hook>>
        }
    }
}
return;

bad:
    diag("%s: bad or out of date archive", file);
out:
    close(f);
@

% >> >> >>

%old:
%        /* need readn to read the dumps (at least) */
%        l = readn(f, &arhdr, SAR_HDR);
% but seems ugly, readn in lib_core/libc/port/readn.c seems to just
% do some repetitive read()

% double loop!  while work, for ;;
% this is where we include all relevant entities(actually object files), 
% and only those!!!
% so 5l can produce small binaries (good because plan9 does not have
% shared libraries).
% Remember that lookup returns a symbol with SNONE when it didn't
% find a symbol (not SXREF).
% This is also why we do the lookup(INITENTRY, 0)->type = SXREF
% in main to force the loading of the object defining _main in libc.a
% which in turn will provoke the loading of more code.

%ugly: I added a special hack regarding "main" because of ocamlc.
% in ocamlc the main() is in libcamrun.a, so in the library, but
% library passed to the command line are not considered magic libs
% where a fixpoint is done for mutually dependent libs (see section
% below), so I had to cheat.

<<[[objfile()]] sanity check library header size and content>>=
if(len != SAR_HDR) {
    diag("%s: short read on archive file symbol header", file);
    goto out;
}
if(strncmp(arhdr.name, symname, strlen(symname))) {
    diag("%s: first entry not symbol header", file);
    goto out;
}
@

<<[[objfile()]] sanity check entry header>>=
if(len != SAR_HDR)
    goto bad;
if(strncmp(arhdr.fmag, ARFMAG, sizeof(arhdr.fmag)))
    goto bad;
@


\section{Loading libraries semi automatically, [[5l -lxxx]]}
\label{sec:loading-libraries-semi-auto}

\subsection{Library search path}

<<global libdir>>=
// growing_array<dirname>
char**	libdir;
@

<<global nlibdir>>=
// index of next free entry in libdir
int	nlibdir	= 0;
@

<<global maxlibdir>>=
// index of last free entry in libdir
static	int	maxlibdir = 0;
@


\subsection{[[5l -L]]}

<<[[main()]] command line processing(arm)>>=
case 'L':
    addlibpath(EARGF(usage()));
    break;
@


% was called 'a', but root is a better name
<<[[main()]] locals(arm)>>=
char *root;
@

<<constant LIBNAMELEN>>=
#define	LIBNAMELEN	300
@

% used locals? move closer the the code that use it then
<<[[main()]] locals(arm)>>=
int c;
char name[LIBNAMELEN];
char *a;
@
% *a still needed now that renamed to root?


<<[[main()]] addlibpath("/{thestring}/lib") or ccroot>>=
<<[[main()]] change root if ccroot>>

// usually /{thestring}/lib/ as root = ""
snprint(name, sizeof(name), "%s/%s/lib", root, thestring);
addlibpath(name);
@

% possible to change default / search path
<<[[main()]] change root if ccroot>>=
root = getenv("ccroot");

if(root != nil && *root != '\0') {
    if(!fileexists(root)) {
        diag("nonexistent $ccroot: %s", root);
        errorexit();
    }
}else
    root = "";
@
%$








<<function addlibpath>>=
void
addlibpath(char *arg)
{
    char **p;

    // growing array libdir
    if(nlibdir >= maxlibdir) {
        if(maxlibdir == 0)
            maxlibdir = 8;
        else
            maxlibdir *= 2;
        p = malloc(maxlibdir*sizeof(*p));
        <<[[addlibpath()]] sanity check p>>
        memmove(p, libdir, nlibdir*sizeof(*p));
        free(libdir);
        libdir = p;
    }

    libdir[nlibdir++] = strdup(arg);
}
@

<<[[addlibpath()]] sanity check p>>=
if(p == nil) {
    diag("out of memory");
    errorexit();
}
@

\subsection{[[5l -lxxx]]}

% actually can also load them manually by specifing the full
% path of the .a with the lib prefix.

% when done manually by -l in command line of ld
<<[[objfile()]] adjust file if -lxxx filename>>=
if(file[0] == '-' && file[1] == 'l') {
    snprint(pname, sizeof(pname), "lib%s.a", file+2);
    e = findlib(pname);
    if(e == nil) {
        diag("cannot find library: %s", file);
        errorexit();
    }
    snprint(name, sizeof(name), "%s/%s", e, pname);
    file = name;
}
@

<<function findlib>>=
char*
findlib(char *file)
{
    int i;
    char name[LIBNAMELEN];

    for(i = 0; i < nlibdir; i++) {
        snprint(name, sizeof(name), "%s/%s", libdir[i], file);
        if(fileexists(name))
            return libdir[i];
    }
    return nil;
}
@



\section{Loading libraries automagically, [[#pragma lib "libxxx.a"]]}
\label{sec:loading-libraries-magically}

%old:
% <<[[main()]] locals(arm)>>=
% bool load_libs;
% @
% <<[[main()]] initialize globals(arm)>>=
% load_libs = !debug['l'];
% @
% (but actually not a global)
%
% load_libs was new local added by me (but maybe was in x86 originally)
% but it does not help actually.

% -l means no automagic stdlibs
% when -l alone it means no startup lib

<<[[main()]] load implicit libraries>>=
if(!debug['l'])
    loadlib();
@

<<[[main()]] if rare condition do not set SXREF for INITENTRY, else>>=
if(debug['l']) {}
else
@
% useful for kernel!

\l By creating a new entry and setting it to SXREF (default is SNONE) we will
\l force in loadlib() to consider _main as a starting point as we marked
\l it as an undefined (undefined but looked for!).



%\section{Loading the libraries, [[loadlib()]]}
% used to be in Main functions, but it is an advanced feature


% It loads the libraries mentioned in the .5 via the .h and #pragma magic!
% (see later section)
% ldobj() is actually also loading libraries when they are mentioned
% explicitly as in 5l ... libxxx.a or via 5l ... -lxxx

% but this chunk will be explained later.
%    <<[[objfile()]] when file is a library>>
% regarding the automatic libs, see below.


% so loading objects with ldbobj() will modify some of the globals below

% then if(load_libs) loadlib()  in the main flow

<<global library>>=
// array<option<filename>>
char*	library[50];
@
% addlib() modifies this global


<<global libraryp>>=
// index of first free entry in library array
int	libraryp;
@

% the .5 that mentioned a library via a #pragma? for debugging purpose?
<<global libraryobj>>=
char*	libraryobj[50];
@



% SIMPLE VERSION
<<function loadlib simple version>>=
void
loadlib(void)
{
    int i;

    for(i=0; i<libraryp; i++) {
        DBG("%5.2f autolib: %s (from %s)\n", cputime(), library[i], libraryobj[i]);
        objfile(library[i]);
    }
}
@
% simple version because in practice we want to allow mutually 
% dependent libs, see section later





%\section{Mutually dependent libraries}
% in advanced topic?


<<function loadlib>>=
void
loadlib(void)
{
    int i;
    long h;
    Sym *s;
loop:
    <<[[loadlib()]] reset xrefresolv>>
    for(i=0; i<libraryp; i++) {
        DBG("%5.2f autolib: %s (from %s)\n", cputime(), library[i], libraryobj[i]);
        objfile(library[i]);
    }
    <<[[loadlib()]] if xrefresolv>>
}
@

% this allows to have mutually dependent libraries, but I don't think
% it's a good idea, ocaml does not allow it.
%% If people have mutually dependent, they'll have to mention
%% the same lib multiple time on the command line!

% but ironically ocamlc requires to have support for mutually 
% dependent libraries :) indeed under plan9 I pass
% libcamlrun.a which defines main, but depend on ape/libap.a which
% defines an _main which calls a main.

% note that this is only for the libs in librarp, so only
% for the automagic libraries! Not for the libs passed on the
% command line

<<global xrefresolv>>=
bool	xrefresolv;
@

<<[[loadlib()]] reset xrefresolv>>=
xrefresolv = false;
@

<<[[loadlib()]] if xrefresolv>>=
if(xrefresolv)
    for(h=0; h<nelem(hash); h++)
         for(s = hash[h]; s != S; s = s->link)
             if(s->type == SXREF) {
                 DBG("symbol %s still not resolved, looping\n", s->name);//pad
                 goto loop;
             }
@
% still some unresolved symbols, loop

<<[[objfile()]] an SXREF was found hook>>=
xrefresolv = true;
@













% when done automatically

<<function addlib>>=
/// ldobj(case AHISTORY and local_line == -1 special mark) -> <>
void
addlib(char *obj)
{
    char fn1[LIBNAMELEN], fn2[LIBNAMELEN], comp[LIBNAMELEN];
    char *p, *name;
    int i;
    bool search;

    if(histfrogp <= 0)
        return;

    name = fn1;
    search = false;
    if(histfrog[0]->name[1] == '/') {
        sprint(name, "");
        i = 1;
    } else if(histfrog[0]->name[1] == '.') {
        sprint(name, ".");
        i = 0;
    } else {
        sprint(name, "");
        i = 0;
        search = true;
    }

    for(; i<histfrogp; i++) {
        snprint(comp, sizeof comp, histfrog[i]->name+1);

        // s/$0/<thechar>/
        for(;;) {
            p = strstr(comp, "$O");
            if(p == nil)
                break;
            memmove(p+1, p+2, strlen(p+2)+1);
            p[0] = thechar;
        }
        // s/$M/<thestring>/
        for(;;) {
            p = strstr(comp, "$M");
            if(p == nil)
                break;
            if(strlen(comp)+strlen(thestring)-2+1 >= sizeof comp) {
                diag("library component too long");
                return;
            }
            memmove(p+strlen(thestring), p+2, strlen(p+2)+1);
            memmove(p, thestring, strlen(thestring));
        }

        if(strlen(fn1) + strlen(comp) + 3 >= sizeof(fn1)) {
            diag("library component too long");
            return;
        }
        if(i > 0 || !search)
            strcat(fn1, "/");
        strcat(fn1, comp);
    }

    cleanname(name);

    if(search){
        p = findlib(name);
        if(p != nil){
            snprint(fn2, sizeof(fn2), "%s/%s", p, name);
            name = fn2;
        }
    }


    for(i=0; i<libraryp; i++)
        if(strcmp(name, library[i]) == 0)
            return;
    if(libraryp == nelem(library)){
        diag("too many autolibs; skipping %s", name);
        return;
    }

    p = malloc(strlen(name) + 1);
    strcpy(p, name);
    library[libraryp] = p;
    p = malloc(strlen(obj) + 1);
    strcpy(p, obj);
    libraryobj[libraryp] = p;
    libraryp++;
}
@




% rare condition not lookup






\chapter{Resolving}
\label{chap:resolving}

%trans:
Once the object files and libraries have been loaded, 
the next step in the linking pipeline is to
%
{resolve} the symbol references in the instructions of those object files.
Here is the responsible code:

<<[[main()]] resolving phase>>=
<<[[main()]] if export table or dynamic module(arm)>>

patch();
<<[[main()]] call doprofxxx() if profiling>>
noops();

dodata();
dotext();
@
%pad: I modified the original code, to simplify, to look more symetric
%old:
%   patch();
%   <<[[main()]] call doprofxxx() if profiling>>
%   dodata();
%   follow();
%   if(firstp == P)
%       goto out;
%   noops();
%   span();
% so:
% - span() -> dotext()
% - I think follow() is optional, and the order can be changed as
%   some steps are independent I think. 
% - the test for firstp is not useful I think if you remove follow.

%toc: %dup: overview/soft-archi
[[patch()]] builds a graph of code instructions,
[[noops()]] rewrites virtual instructions in machine instructions,
\n well still not completely real though
[[dodata()]] {layout} data by assigning a memory address to each
\n actually offset
globals, and finally
[[dotext()]] does a similar thing for the code, assigning a 
{real code address} to each instruction.

%toc:
In the first section of this chapter we will discuss the different
issues in symbol resolution. We will also explain the need for
the 4 functions above and the rational for the order of their calls.
Then, the following sections will each explain one of the 4 functions
above.
\l then final discussions xdefine, SB/R12

\section{Issues in symbol resolution}

The linker has mainly two kinds of references to resolve: 
\begin{itemize}
\item {\em code references} in branching instructions,
e.g. [[BL foo(SB)]], which ultimately should be transformed
in an ARM instruction with, as an operand, a concrete address in
the {code section}, e.g. [[BL 0x1020]]
\l actually ARM use relative jumps
\l can jump to a data?
\n there is also code ref in memory instructions
\n   [[MOVW $foo(SB), R1]] %$

\item {\em data references} in memory instructions, 
e.g. [[MOVW hello(SB), R1]], which ultimately should
be transformed in an ARM instruction with, as an operand,
a concrete address in the {data section}, e.g. [[LDR 0x7014(R0), R1]].
\footnote{Remember from the \book{Assembler} that [[MOVW]] is 
actually a {virtual instruction} which unifies the two
separate ARM instructions [[LDR]] (load register) and [[STR]] (store register).
}
\n actually not  0x7014 but 0x14(R12), and actually not even than because of BIG
\n actually has also memory reference in DATA instruction? ximm can have addr

\end{itemize}

Note that some branching instructions have been
{partially resolved} at this point.
\l D_BRANCH
%
Indeed, 
branching to a {label} (e.g. [[B loop]]), or 
{relative jumps} using the pseudo-register [[PC]] (e.g. [[B 2(PC)]]),
have already been resolved and converted by the assembler [[5a]] in
{\em absolute jumps} (e.g. [[B 13]]). See the \book{Assembler}.
%alt: alt to convert to absolute virtual jump? keep label in .obj?
% how do relative jumps? assume programmer knows size of instrs?
%
Those absolute jumps
have even been {relocated} by the linker to a new memory address
origin in Section~\ref{sec:relocating} (e.g. [[B 113]]).

Resolving and converting the remaining branching instructions 
(e.g. [[BL foo(SB)]])
\l D_OREG
to absolute jumps is very easy thanks to the symbol table and
the [[Sym.value]] field of procedure symbols.
%trans:
There are still some remaining issues though that makes
the resolving step non-trivial as we will see in the following
sections.

\subsection{Virtual program counter versus real code address}

%trans:
The first issue is that
%
the value in the absolute jump instructions we mentioned before refers to a 
{\em virtual program counter} which is not a {\em real code address}\footnote{
Note that a {\em real} code address under \plan is actually a {\em virtual}
memory address. But, the use of virtual in this context would be confusing,
which is why we will keep to use the term ``real code address''.
}.

%dup: overview/soft-archi core-ds/instr loading/pc-ipc loading/axxx
Indeed, the virtual program counter starts at 0
and is incremented by 1 in [[ldobj()]] after each
code instruction read. 
%dup: overview/disk-image-mem-image overview/5l overview/5l-a main/-H
Real code addresses on the other hand start at [[INITTEXT]] (4128 under \plan),
%dup: overview/5l-a core-ds/instr main/asmb/text-sec 
and because the ARM uses fixed-length instructions 
of 4 bytes, are always a multiple of 4.
\l note though that ARM wants relative jumps ...


Unfortunately, going from a virtual program counter to
a real code address can not be done simply by 
multiplying by~4 and adding [[INITTEXT]].
%dup: main/asmb/text-section-gen-oplook
Indeed, as said in Section~\ref{sec:asmb-text-section-overview},
the instructions in object files do not match exactly 
ARM instructions.
%
This means that one instruction in the object file
may lead to the generation of multiple ARM instructions in
the executable, or no instruction at all sometimes.
%
Even though the assembly language of [[5a]] tries to mimic
closely the ARM instruction set, there is still a mismatch
for a few reasons explained below:

\begin{itemize}
\item {\em virtual instructions} such as 
%dup: main/asmb/text-sec 
[[DIV]] have no counterpart in the ARM. 
[[DIV]] and [[MOD]] are converted by [[5l]]
in a serie of ARM 
instructions which ends with the call to
respectively [[_div()]] and [[_mod()]] of the core C library
(see Section~\ref{sec:div-mod}) which implement
in software the division and modulo algorithms (using [[ADD]],
[[MUL]], [[SUB]], etc).
\n but then could have done expansion in ldobj()? maybe, but then
\n  need relocate branching instr
\n ARET? well always one instr, but its MOVW could have different size
\n  also profiling generate lots of instr
\n ANOP? well could generate fake instr without side effect? can we?
\n AMOVW? ok, constraint anyway for STR/LDR
%real-world: pb specific to 5l?

\item the {\em pseudo-instruction} [[TEXT]] leads to the generation of
0, 1, or many ARM instructions depending on the situation. 
Indeed, if the procedure 
%is a {\em non-leaf} function (see Section~\ref{sec:leaf}) or 
use some locals, it
will need an extra ARM instruction to 
%save the {\em link register}
decrement the {\em stack pointer} (see Section~\ref{sec:atext-patching}).
\l both can be done in one instruction, magic
Moreover, if profiling is enabled, a few more ARM instructions will be added
for the {instrumentation} of the procedure to gather statistics
(see Chapter~\ref{chap:profiling}).
\n again, could have done expansion in ldobj(), but still need relocate then
%
The same is true for [[RET]].
%real-world: pb specific to 5l?

\label{sec:constraints-immediate-and-offset}
\item {\em constraints} on immediate constants and offsets
imposed by the ARM are relaxed by [[5a]] and the object file.
%dup: overview/5l-a core-ds/instr main/asmb/text-sec resolve/issue/
As said before, the ARM uses fixed-length instructions of 4 bytes,
%
so for instructions involving immediate constants 
(e.g. [[ADD $10256, R1, R2]]) %$
or offsets (e.g. [[MOVW 54000(R0), R2]]), 
%dup: (and adapted) from Assembler in parsing/immediage-constant 
the range of those numbers is quite limited.
%Indeed, a few of the 32 bits of an instruction are already used to encode
%the opcode and a few more to encode the other operands.
For arithmetic instructions, only 12 bits of the ARM instruction
are available to encode the constant.
%Even though the ARM uses a clever trick to represent numbers
%using those 12 bits (see Section~\ref{sec:clever-trick-numbers}),
%the set of numbers which can be represented is still limited.
%
This is why even a regular instruction such as [[ADD]] may lead
to the generation of multiple ARM instructions.
Indeed, if the instruction uses a big number, this number
\l actually not necessaraly big, just one that is not immrot()
must first be loaded in a temporary register with an extra instruction
(see Section~\ref{sec:pool-and-reg-tmp}).
\t but how? same pb for loading it no? refer to Overview!
%real-world: specific 5l? how other assembler do? 
% error message at assembly time?

\end{itemize}

%trans:
Because of all of this, it is not trivial to convert a
virtual program counter reference in a branching instruction
to a real code address.
%
The solution adopted by [[5l]] operates in three steps:

\label{sec:dotext-big-picture}
\begin{enumerate}
\item the function [[patch()]] builds
a {\em graph of code instructions} by transforming the use
of a virtual program counter {reference} 
%in a branching instruction 
to a real {pointer} ([[Instr*]]).
%
This pointer will be stored in the [[Instr.cond]] field
of the branching instruction
and will point to the target instruction
having the specified virtual program counter in his [[Instr.pc]].

\item the function [[dotext()]]
sets [[pc]] to INITTEXT and
iterates over all the code instructions. 
For each instruction, [[dotext()]] computes the actual number
of ARM instructions which are needed for this
instruction (via [[oplook()]]), 
sets [[Instr.pc]] to [[pc]] which both represent now
{\em real program counters}, 
and increment [[pc]] accordingly (e.g. by 4 if only one ARM instruction
was necessary).
\t need use same global pc for that? could not use local? need pc as global?
\t  actually it is using the local c, but could be instead realpc?

\item the code generator [[asmout()]] when involved with a branching
instruction [[p]] can find the target code address
by simply looking at [[p->cond->pc]].
\l and compute a relative jump by [[p->pc - p->cond->pc - 8]]

\end{enumerate}

\l FIGURE illustrating process? item 1 and 2 combine to make possible 3

%real-world: pb specific to 5a/5l? no virtual-instr in other assembler?
% but also issue of size of instr no? and need relocate labels
% which are complicated because of varying size of instr (and fixpoint?)?
% alternative techniques to graph of code instruction?
%alt: other technique? what I will use for 5l in ocaml?

Thanks to the graph of code instructions, it is also easy
after [[patch()]] to call [[noops()]] to rewrite virtual
instructions in machine instructions.
\n and actually still not completely real, TEXT gets converted in MOVW
\n but could be part of oplook() and could be done in asmout() instead
%dup: overview/soft-archi
Indeed, [[noops()]] can replace a virtual instruction by
multiple machine instructions chained together
or even delete the instruction without
any consequence on the other branching instructions (as long
at it maintains carefully the [[Instr.cond]] pointers pointing
to the original instruction).
%dup: overview/soft-archi
Before the graph of instructions, inserting or
deleting an instruction would have forced to assign a new 
virtual program counter to all the following instructions and to relocate 
every branching instructions.

Thanks to the graph, it is also possible to perform some
optimisations before code generation,
such as dead code elimination,
as we will see in Section~\ref{sec:optimisations}.
\l actually double thanks to graph cos use graph to traverse and
\l  thx to graph dont have to relocate every other stuff after
\l can change "blocks" in graph. remove, strip,compact.


\subsection{Data address and code size mutual dependency}
\n was 'code instruction size' but too long title in TOC

%trans:
The second issue which makes the resolving step non-trivial is
%
the {mutual dependency} between the layout of code and data.
\l define layout somewhere?
Indeed, to generate code one needs to resolve memory instructions involving
globals which means one must know the address of those globals.
\n note that I use generate here, but it is also true for layout
%
This suggests to layout first data and then the code.
%
But, because those globals are in the data section, which is after the code
section, one needs first to know at least the {size of the code section} to
start to layout data. 
%
This suggests to layout first the code and then the data, 
hence the mutual dependency.


Of course, we just need the size of the code section to layout data,
%alt: could also put data first in executable, would be simpler
so we could first layout the code using {fake addresses} for the globals
referenced in memory instructions. We would get a size
\n actually no, estimation only as explained soon
for the code section which we could use as the starting
point of the data section, to layout data. 
Finally, we would layout the code a second time using 
real addresses for the globals this time, to generate the real code.


One difficulty is that the size of the code section computed
during the first layout would be only an {estimation}.
\t specific to ARM? then add ARM somewhere
Indeed, some instructions involving globals may have different size
\l well abuse of lang, some instr lead to generation of multiple ARM instr
depending on the address of the global.
\t refer to overview! address become offset.
Offsets in ARM instructions
have a limited range, as mentioned 
in the previous section. %clever \ref{sec:sec:constraints-immediate-and-offset}
%
This means some memory instructions may require the use of an extra
instruction if the address of the global happens to be large.
\t but how bootstrapped? WORD and LDR
Using fake addresses during the first layout would be imprecise.
%alt: put safe gap after estimation? anyway has INITRND. and fixpoint? 
% how ensure termination of fixpoint?

The solution adopted by [[5l]] to solve the mutual dependency
problem operates in four steps: 

\label{sec:dodata-big-picture}
\begin{enumerate}
\item the layout of data is done first, via [[dodata()]],
by iterating over all the globals.
\n using hash, not datap
%dup: overview/5l-a overview-soft-archi
But, each globals is assigned a memory address (in [[Sym.value]])
as {\em an offset to the start of the data section},
not an absolute address.
%
Note that the old value in [[Sym.value]] contained the size
of the global which is used to layout globals one after the other.

\item [[dotext()]] then layouts code by iterating over all the instructions.
But, it assumes the {\em reserved register} [[R12]] will, at {\em run-time},
when the executable is executed,
contain [[INITDAT]], the address of the start of the data section.
\n actually not exactly that because BIG opti
It also assumes that operands involving globals such as
[[MOVW hello(SB), R1]] can be transformed later (in [[asmout()]])
as an {\em indirect with offset} operand
(see the \book{Assembler}).
This operand can then use [[R12]] as the {\em base} and 
the [[Sym.value]] of the global (computed previously)
as the {\em offset}, e.g.  [[LDR 14(R12), R1]].
\t actually not all are like that, can use also Pool if LCON
%
In the same way instructions involving global addresses such as
[[MOVW $hello(SB), R1]] %$ 
can be transformed as [[ADD $14, R12, R1]]. %$
\t but what if offset too large? and so can not express address
\t  as offset, then will use absolute address and Pool, 
%
That way, [[dotext()]] can compute accurately the size of the
instruction.
\t but anyway, it's not gonna change, still not fake address! 
\t second layout would be the same

\item one of the first instruction of the program must
initialize [[R12]] with the value of [[INITDAT]].
%
\l could stop here? and explain later subtelity of bootstrap need.
This value is recorded in the executable as a special symbol,
[[setR12]], using a form of reflection explained in Section~\ref{sec:sb-r12}.
\n actually opti so not that
%
In practice, the function [[_main()]] from the core
C library is the first function executed by
the program (see Section~\ref{sec:choice-entry-point}).
This is why one of its first instruction is:
[[MOVW $setR12(SB), R12]].%$
%

\item the instruction [[MOVW $setR12(SB), R12]] %$
itself uses the address of a global but it must not be transformed
as [[ADD 0, R12, R12]] like other similar instructions.
Indeed, the whole point of the instruction is to initialize [[R12]],
and so it can not rely on [[R12]].
%which could be
%small or large depending on the program. So, this instruction
%may have different size depending on the address
%which brings us back to the original problem. 
To {\em bootstrap},
this address is recognized in a special way in the code
generator in [[asmout()]] and leads to the generation
of an instruction which uses the absolute address of [[setR12]],
e.g. [[MOV 0x7014, R12]].
%of a fixed number
%of instructions, whatever the value of the address.
\t  special case to use LCON not RECON!! subtle, ref to code in aclass?
\l see also section X where see code of _main?

\end{enumerate}
%alt: fixpoint?

\t what about memory reference to code section other than branch?
\t  ref to etext? ref to $foo(SB)? %$
\t  this is why get a xdefine("etext", STEXT, 0L)? but then pb
\t  fixpoint?

All of this explains the order of the calls we saw
at the beginning of this chapter:

\begin{verbatim}
patch();
noops();

dodata();
dotext();
\end{verbatim}
\n actually dodata() could be before patch I think.
\l also for SSTRING one must do dotata() before dotext.
\l other reasons?

\bigskip
%trans:
Now that we have a better picture of how things work
together to resolve symbols, we
can go through the code of each of the functions above,
starting with [[patch()]].


\section{Building the code instructions graph, [[patch()]]}

%trans:
As explained before, 
%dup: resolving/issue/virtualpc
the goal of [[patch()]] is to set the [[Instr.cond]] field
\l introduced in \ref{sec:instr-cond}
of branching instructions to point to the right target instruction.
\n so later in asmout can get real pc with p->cond->pc (also useful for follow)
%
Essentially [[patch()]] will iterate over all the code instructions
[[p]] and for branch instructions it will {look for}
the target instruction [[q]] with the virtual program counter 
[[q->pc]] equal to the absolute jump value [[p->to.offset]]:

<<function patch(arm)>>=
/// main -> <>
void
patch(void)
{
    Prog *p;
    Prog *q;
    long c; // not ulong?
    <<[[patch()]] other locals>>

    DBG("%5.2f patch\n", cputime());

    <<[[patch()]] initialisations>>

    // pass 1
    for(p = firstp; p != P; p = p->link) {
        <<adjust curtext when iterate over instructions p>>

        <<[[patch()]] resolve branch instructions using symbols>>

        if(p->to.type == D_BRANCH && p->cond != UP) {
            c = p->to.offset; // target pc
            <<[[patch()]] find Prog reference [[q]] with [[q->pc == c]]>>
            p->cond = q;
        }
    }
    // pass 2
    <<[[patch()]] optimisation pass>>
}
@
\t use pc instead of c? can be a local

The extra condition [[p->cond != UP]] above is not very
important and can be ignored for now.
It will be explained in Section~\ref{sec:UP}.
\n because of SUNDEF
Normally, before the call to [[patch()]], 
[[Instr.cond]] should be a null pointer\footnote{
See the instruction [[p->cond = P;]] in [[ldobj()]] Section~\ref{sec:ldobj}.
}
which is different than [[UP]].


%trans:
[[patch()]] is a complex function. We splitted it in a few
{chunks} to facilitate its comprehension.
%
To find [[q]], [[patch()]] needs to first initialize some
data structures that makes the search more efficient.
%
It also needs to (partially) resolve branching instructions using
symbols and convert them to absolute jumps.
That way all branching instructions become uniforms.
%toc:
The following sections will explain those different steps.


\subsection{Resolving branch instructions using symbols}

Converting the use of symbols in branching instruction
(e.g. [[B foo(SB)]]) to absolute jumps (e.g. [[B 113]])
is trivial thanks to the [[Sym.value]] of procedure symbols
which contains the virtual program counter of the procedure:
\l a bit too much explanations?

<<[[patch()]] other locals>>=
Sym *s;
// enum<Opcode>
int a;
@

<<[[patch()]] resolve branch instructions using symbols>>=
a = p->as;
if((a == ABL || a == AB) &&
   p->to.type != D_BRANCH &&  // must be D_OREG then
   p->to.sym != S) {
    s = p->to.sym;
    switch(s->type) {
    case STEXT:
        p->to.offset = s->value;
        p->to.type = D_BRANCH;
        break;
    <<[[patch()]] switch section type for branch instruction, cases>>
    }
}
@
%old: had  || a == ARET   but I cant see how can have this and a p->to.sym
%bug: ARET? ARET has no args in Assembler.nw. cos of SUNDEF? I don't think so.
\n can do B foo(SB)? why not if have no arguments, could. Tail call!

If the procedure can not be found, an error is reported:

<<[[patch()]] switch section type for branch instruction, cases>>=
// SNONE, SXREF, etc
default:
    diag("undefined: %s\n%P", s->name, p);
    s->type = STEXT;
    s->value = 0;
    break;
@
\n see also SUNDEF case
%old: s->value = vexit;

To avoid reporting multiple times the same error,
the symbol of the undefined procedure is modified to become a (fake)
defined procedure.
That way, if another instruction later calls the same procedure,
[[5l]] will not report an error.
%
Note that there is no risk of generating a wrong executable though
as the call to [[diag()]] will prevent such a thing 
(see Appendix~\ref{chap:error}).
\n also first intr just change s, not p, so
\n does not change p->to.type so still D_OREG so will not generate  any code

%old:
%  s->value = vexit;
%  ...
%  <<[[patch()]] other locals>>=
%  long vexit;
%  @
%  <<[[patch()]] initialisations>>=
%  s = lookup("exit", 0);
%  vexit = s->value;
%  @
%% exit? part of C library? no, but will be pc = 0 if not.
%but seems uselessly complicated. Anyway no executable will be generated



\subsection{Finding instruction at [[pc]]}
\label{sec:find-q}
\n better to present how use DS first I think, hence the order

The naive way to find the instruction [[q]] with a certain [[pc]]
is a linear search over all the instructions, by 
following [[Instr.link]].
%
To optimize the search, [[patch()]] relies on another pointer, 
[[Instr.forwd]] which will point not to the next instruction,
but to a few more instructions forward (hence the name),
as shown in Figure~\ref{fig:forward-pointer}.
\n well a few can be actually a lot when LOG=5

<<[[Prog]] other fields>>=
Prog*	forwd;
@
%old: used to be part of an union with regused, but regused was actually
% unused
%alt: 
% - an array instead of a list (but then noops() harder)
% - a hashtbl on Prog.pc? to get a Prog from a specific pc


\begin{figure}[!]\centering
\begin{verbatim}
        +-------+
        |PC = 0 |------------+
        +---+---+ forwd      |
            |link            |
        +---v---+            |
+-------|PC = 1 |            |
| forwd +---+---+            |
|           |link            |
|       +---v---+            |
|       |PC = 2 |            |
|       +---+---+            |
|           |link            |
+------>+---v---+            |
+-------|PC = 3 |            |
| forwd +---+---+            |
|           |link            |
|       +---v---+<-----------+
|       |PC = 4 |------------+
|       +---+---+ forwd      |
|           |link            |
+------>+---v---+            |
+-------|PC = 5 |            |
| forwd +---+---+            |
|           |link            |
|       +---v---+            |
|       |PC = 6 |            |
|       +---+---+            |
|           |link            |
+------>+---v---+            |
+-------|PC = 7 |            |
| forwd +---+---+            |
|           |link            |
|       +---v---+<-----------+
|       |PC = 8 |
|       +---+---+
|           |link
+------>+---v---+
        |PC = 9 |
        +-------+
\end{verbatim}
\caption{Forward pointers}\label{fig:forward-pointer}
\end{figure}

That way one can make bigger jumps sometimes:

<<[[patch()]] find Prog reference [[q]] with [[q->pc == c]]>>=
for(q = firstp; q != P;) {
    if((q->forwd != P) && (c >= q->forwd->pc)) {
        q = q->forwd; // big jump
    } else {
        if(c == q->pc)
            break; // found it!
        q = q->link; // small jump
    }
}
if(q == P) {
    diag("branch out of range %ld\n%P", c, p);
    p->to.type = D_NONE;
}
@

By carefully setting [[Instr.forwd]], the search can become
a {\em binary search}.
%
Indeed, to find for instance the instruction with [[PC==7]]
in Figure~\ref{fig:forward-pointer}, shortened to $p_7$,
one needs only 3 steps: starting from $p_0$ one can go
directly to $p_4$ with [[forwd]], then $p_5$ with [[link]]
and finally $p_7$ with another [[forwd]].
A linear search with only [[link]] would require 7 steps.

\subsection{Indexing [[pc]], forward links overlay}

The [[Instr.forwd]] fields are set by [[mkfwd()]]:

<<[[patch()]] initialisations>>=
mkfwd();
@

[[mkfwd()]] essentially builds a {\em binary search tree} on
top of a {linked list}.
%
It relies on the constant [[LOG]] which controls at the same time
the lengths of the forward arcs and the depth of the search tree:

<<constant LOG>>=
#define	LOG	5
@

To illustrate [[mkfwd()]] though, we will use [[LOG=2]],
which leads to Figure~\ref{fig:forward-pointer}
when [[mkfwd()]] is applied to a list of 10 instructions.

<<function mkfwd>>=
/// main -> patch -> <>
void
mkfwd(void)
{
    long cnt[LOG]; // (length of arc)/LOG at a certain level (constant)
    long dwn[LOG]; // remaining elements to skip at a level (goes down)
    Prog *lst[LOG]; // past instruction saved at a level
    Prog *p;
    int i; // level

    <<[[mkfwd()]] initializes cnt, dwn, lst>>

    i = 0;
    for(p = firstp; p != P; p = p->link) {
        <<adjust curtext when iterate over instructions p>>
        p->forwd = P;

        <<[[mkfwd()]] in for loop, add forward links from past p in lst to p>>
    }
}
@

%trans:
The code of [[mkfwd()]] is very subtle which is why we splitted it
in multiple chunks.
%
It iterates over all the instructions [[p]] and at certain {\em frequencies}
adds a forward link from a past instruction saved in [[lst[i]]]
to the current instruction [[p]]. 
It does so for different {\em levels} [[i]].
%
The frequency divided by [[LOG]]
for a certain level [[i]] is stored in [[cnt[i]]]
initialized by the following code:

<<[[mkfwd()]] initializes cnt, dwn, lst>>=
for(i=0; i<LOG; i++) {
    if(i == 0)
        cnt[i] = 1; 
    else
        cnt[i] = LOG * cnt[i-1];
    dwn[i] = 1;
    lst[i] = P;
}
@

Here are the initial values of [[cnt]] for different [[LOG]]:
\begin{verbatim}
// LOG = 2
cnt[] = {1, 2}; // so frequency level0 = 2 (LOG * 1), level1 = 4 (LOG * 2)
// LOG = 3
cnt[] = {1, 3, 9};
// LOG = 4
cnt[] = {1, 4, 16, 64};
// LOG = 5
cnt[] = {1, 5, 25, 125, 625};
\end{verbatim}

We can finally see the body of the loop of [[mkfwd()]]:

<<[[mkfwd()]] in for loop, add forward links from past p in lst to p>>=
// first loop, the levels
i--;
if(i < 0)
    i = LOG-1;

// second loop, the frequency at a certain level
dwn[i]--;
if(dwn[i] <= 0) {
    dwn[i] = cnt[i];

    if(lst[i] != P)
        lst[i]->forwd = p; // link from past p to p
    lst[i] = p;
}
@

The idea is to first loop over the different levels [[i]],
and then loop over the frequency at a certain level [[i]].
%
So, for [[LOG=2]], [[mkfwd()]] will add forward links
of length 4 (every $2 * 2$ instructions), and 
of length 2 (every $2 * 1$ instructions), as illustrated 
in Figure~\ref{fig:forward-pointer}.

Here is a simple trace of [[mkfwd()]] for [[LOG=2]]
which could help understand the algorithm.
%with the data in Figure~\ref{fig:forward-pointer}.
It shows the value of the different variables at the {\em end}
of each iteration of the [[for]] loop:

\begin{verbatim}
// does not change
LOG = 2
cnt[] = { 1, 2 }; 

// before for loop
i = 0  dwn[] = { 1, 1 } lst[] = {P, P};


// end of each iteration
p=p0 i=1 dwn[]={1,2} lst[]={P, p0} // save p0
p=p1 i=0 dwn[]={1,2} lst[]={p1,p0} // save p1
p=p2 i=1 dwn[]={1,1} lst[]={p1,p0} // decrement dwn[1]
p=p3 i=0 dwn[]={1,1} lst[]={p3,p0} // + p1 -> p3 forwd link
p=p4 i=1 dwn[]={1,2} lst[]={p3,p4} // + p0 -> p4 forwd link
p=p5 i=0 dwn[]={1,2} lst[]={p5,p4} // + p3 -> p5 forwd link
p=p6 i=1 dwn[]={1,1} lst[]={p5,p4}
p=p7 i=0 dwn[]={1,1} lst[]={p7,p4} // + p5 -> p7 forwd link
p=p8 i=1 dwn[]={1,2} lst[]={p7,p8} // + p4 -> p8 forwd link
p=p9 i=0 dwn[]={1,1} lst[]={p9,p8} // + p7 -> p9 forwd link
\end{verbatim}

For [[LOG=5]], [[mkfwd()]] will add forward links
of lengths 3125 ($5 * 625 = 5^5$), 
625 ($5^4$), 
125 ($5^3$), 
25 ($5^2$), and 
5 ($5^1$).



\section{Virtual opcodes rewriting, [[noops()]]}
\n ARM only. there is a dostkoff() in x86 but it's related only to the become
\n  stuff that I have now deleted for the ARM.

%trans:
As explained before, 
%dup: overview/soft-archi ... resolving/issue/virtualpc
[[noops()]] rewrites pseudo and virtual instructions 
which do not have a corresponding 
ARM opcode ([[no]] [[op]]), e.g. [[ARET]],
to machine instructions which have one.
%
It works in two passes over the list of code instructions.
The first pass mostly {\em marks} certain instructions in
[[Instr.mark]] (see Section~\ref{sec:mark}). 
%
This pass can also rely on [[q]] which stores the previous instruction to [[p]].
%
The second pass possibly uses the mark to transform
virtual instructions:
\l actually ANOP stripping done in first pass

<<function noops(arm)>>=
/// main -> <>
void
noops(void)
{
    Prog *p, *q, *q1;
    // enum<Opcode>
    int o;

    /*
     * find leaf subroutines
     * strip NOPs
     * expand RET
     */

    DBG("%5.2f noops\n", cputime());

    // pass 1, mark or delete
    curtext = P;
    q = P;
    for(p = firstp; p != P; p = p->link) {
        <<adjust curtext when iterate over instructions p>>

        switch(p->as) {
        <<[[noops()]] first pass switch opcode cases>>
        }
        q = p;
    }

    // pass 2, transform
    curtext = P;
    for(p = firstp; p != P; p = p->link) {
        <<adjust curtext when iterate over instructions p>>

        o = p->as;
        switch(o) {
        <<[[noops()]] second pass switch opcode cases>>
        }
    }
}
@
\l could be more symetric and use o = p->as;  also in first pass?
%bugfix: I forgot the 'q = p;' after some refactoring, but need it!
%old: there was lots of stuff about BECOME which I think was
% a feature necessary for the alef compiler, but it
% has been removed from plan9 edition 4 so this code
% was probably dead.
%
%    int curframe, curbecome, maxbecome;
%
%     * become sizes
%     * frame sizes
%     * expand BECOME pseudo
%
%    curframe = 0;
%    curbecome = 0;
%    maxbecome = 0;
%
%        /* find out how much arg space is used in this TEXT */
%        if(p->to.type == D_OREG && p->to.reg == REGSP)
%            if(p->to.offset > curframe)
%                curframe = p->to.offset;
%
%
%            if(curtext && curtext->from.sym) {
%                curtext->from.sym->frame = curframe;
%                curtext->from.sym->become = curbecome;
%                if(curbecome > maxbecome)
%                    maxbecome = curbecome;
%            }
%            curframe = 0;
%            curbecome = 0;
%
%
%        case ARET:
%            /* special form of RET is BECOME */
%            if(p->from.type == D_CONST)
%                if(p->from.offset > curbecome)
%                    curbecome = p->from.offset;
%            break;
%
%    if(curtext && curtext->from.sym) {
%        curtext->from.sym->frame = curframe;
%        curtext->from.sym->become = curbecome;
%        if(curbecome > maxbecome)
%            maxbecome = curbecome;
%    }
%
%    if(debug['b'])
%        print("max become = %d\n", maxbecome);
%    xdefine("ALEFbecome", STEXT, maxbecome);
%
%    curtext = P;
%    for(p = firstp; p != P; p = p->link) {
%        <<adjust curtext when iterate over instructions p>>
%        switch(p->as) {
%        case ABL:
%            if(curtext != P && curtext->from.sym != S && curtext->to.offset >= 0) {
%                o = maxbecome - curtext->from.sym->frame;
%                if(o <= 0)
%                    break;
%                /* calling a become or calling a variable */
%                if(p->to.sym == S || p->to.sym->become) {
%                    curtext->to.offset += o;
%                    if(debug['b']) {
%                        curp = p;
%                        print("%D calling %D increase %d\n",
%                            &curtext->from, &p->to, o);
%                    }
%                }
%            }
%            break;
%        }
%    }
%
%            if(p->from.type == D_CONST)
%                goto become;
%
%        become:
%            if(curtext->mark & LEAF) {
%                if(!autosize) {
%                    p->as = AB;
%                    p->from = zprg.from;
%                    break;
%                }
%            }
%            q = prg();
%            q->scond = p->scond;
%            q->line = p->line;
%            q->as = AB;
%            q->from = zprg.from;
%            q->to = p->to;
%            q->cond = p->cond;
%            q->link = p->link;
%            p->link = q;
%
%            // MOVW autosize(SP), LINK
%            p->as = AMOVW;
%            p->scond |= C_PBIT;
%            p->from = zprg.from;
%            p->from.type = D_OREG;
%            p->from.offset = autosize;
%            p->from.reg = REGSP;
%            p->to = zprg.to;
%            p->to.type = D_REG;
%            p->to.reg = REGLINK;
%
%            break;

%old: this was under some ifdef, probably experimental stuff
%#ifdef optimise_time
%                if(autosize) {
%                    q = prg();
%                    q->as = ASUB;
%                    q->line = p->line;
%                    q->from.type = D_CONST;
%                    q->from.offset = autosize;
%                    q->to.type = D_REG;
%                    q->to.reg = REGSP;
%
%                    q->link = p->link;
%                    p->link = q;
%                }
%                break;
%#else
%
%#ifdef optimise_time
%                p->as = AADD;
%                p->from.type = D_CONST;
%                p->from.offset = autosize;
%                p->to.type = D_REG;
%                p->to.reg = REGSP;
%
%                q = prg();
%                q->as = AB;
%                q->scond = p->scond;
%                q->line = p->line;
%                q->to.type = D_OREG;
%                q->to.offset = 0;
%                q->to.reg = REGLINK;
%
%                q->link = p->link;
%                p->link = q;
%
%                break;
%#endif
%
%#ifdef optimise_time
%                q = prg();
%                q->scond = p->scond;
%                q->line = p->line;
%                q->as = AB;
%                q->from = zprg.from;
%                q->to = p->to;
%                q->cond = p->cond;
%                q->link = p->link;
%                p->link = q;
%
%                p->as = AADD;
%                p->from = zprg.from;
%                p->from.type = D_CONST;
%                p->from.offset = autosize;
%                p->to = zprg.to;
%                p->to.type = D_REG;
%                p->to.reg = REGSP;
%
%                break;
%#endif


%toc:
The following sections will detail those passes.

\subsection{Leaf procedure optimisation}
\label{sec:leaf}
\n could be in Opti section? but talked in Assembler and have many implications

An important concept related to the ARM architecture is 
whether a procedure is a leaf (see the \book{Assembler}). 
Such procedures will be marked in the first pass of [[noops()]]:

<<[[Mark]] cases>>=
LEAF		= 1<<2,
@
% >>

A {\em leaf} is a procedure which does not call other procedures.
Such a procedure is thus a leaf in the {\em call tree}:

<<[[noops()]] first pass switch opcode cases>>=
case ATEXT:
    p->mark |= LEAF;
    break;

case ABL:
    if(curtext != P)
        curtext->mark &= ~LEAF;
    // fallthrough
<<[[noops()]] first pass switch opcode ABL fallthrough>>
@

Depending on whether a procedure is a leaf, 
the code for [[ATEXT]] and [[ARET]] can be optimized
to not use memory at all and just use the 
{\em link register} [[R14]], 
%toc:
as we will see in the following sections.

%old:
% <<[[Section]] cases>>=
% SLEAF, // arm
% @
% but used only for symbol table, so I removed and use mark instead.


\subsection{[[ATEXT]] patching}
\label{sec:atext-patching}

If a procedure is a leaf, there is no need to save [[R14]]
in the stack. Indeed, such a procedure will 
not contain any [[BL]] instruction, and so will
not overwrite [[R14]].
%
[[5l]] does this optimisation though only if the procedure
does not declare also any locals (e.g. [[ATEXT foo(SB), $0]]).%$
\t why?

Otherwise, if the procedure is not a leaf, or use some locals,
then an extra word ([[+4]] bytes) is reserved in the stack
to save the return address to the caller stored in [[R14]].

<<[[noops()]] second pass switch opcode cases>>=
case ATEXT:
    if(p->to.offset <= 0) {
      if(curtext->mark & LEAF) {
        // to compensate further + 4 to get autosize == 0.
        p->to.offset = -4;
      }
    }
    autosize = p->to.offset + 4;

    <<[[noops()]] in second pass, if size local was -4 and not a leaf>>

    if((curtext->mark & LEAF) && (autosize == 0))
      break;
    // else

    // MOVW.W R14, -autosize(R13)
    q1 = prg();
    q1->as = AMOVW;
    q1->scond |= C_WBIT;
    q1->line = p->line; // origin tracking
    q1->from.type = D_REG;
    q1->from.reg = REGLINK;
    q1->to.type = D_OREG;
    q1->to.reg = REGSP;
    q1->to.offset = -autosize;

    // insert_after(p, q1)
    q1->link = p->link;
    p->link = q1;
    break;
@
\n forgot Instr.pc ? does not matter anymore, graph already built.
%old:
%    autosize = p->to.offset + 4;
%    if(autosize <= 4)
%      if(curtext->mark & LEAF) {
%        p->to.offset = -4;
%        autosize = 0;
%    }
%
%    if(!autosize && !(curtext->mark & LEAF)) {
%        DBG("save suppressed in: %s\n", curtext->from.sym->name);
%        curtext->mark |= LEAF;
%    }
%
%    if(curtext->mark & LEAF) {
%        if(curtext->from.sym)
%            curtext->from.sym->type = SLEAF;
%        if(!autosize)
%            break;
%    }
% - removed the code about SLEAF
% - use autosize == 0, more readable than !autosize, anyway it's not a bool!
% - reorg order of assignments, simpler I think

The single instruction [[MOVW.W R14, -autosize(R13)]],
which uses the {\em special bit} [[.W]] (see the \book{Assembler}),
is equivalent to the sequence:
\begin{verbatim}
MOVW R14, -autosize(R13)
SUB autosize, R13, R13
\end{verbatim}
\l really?

Note that the [[ATEXT]] instruction in [[p]] is kept.
It is not replaced by a new instruction [[q1]] but instead
[[q1]] is added after [[p]].
That way, further iterations over the list of instructions
can still rely on [[curtext]].


In some situations, even if the procedure is not a leaf, 
one would like to not save [[R14]] in the stack.
\t why? getcallerpc is a leaf.
In that case, the programmer needs to declare his procedure with
[[-4]] for the size of its locals (e.g. [[TEXT foo(SB), $-4]]). %$

<<[[noops()]] in second pass, if size local was -4 and not a leaf>>=
if((autosize == 0) && !(curtext->mark & LEAF)) {
    DBG("save suppressed in: %s\n", curtext->from.sym->name);
    curtext->mark |= LEAF;
}
@

\subsection{[[ARET]] rewriting}
\label{sec:ARET-rewrite}

[[ARET]] is complementary to [[ATEXT]].
Its transformation is pretty straightforward:

<<[[noops()]] second pass switch opcode cases>>=
case ARET:
    <<[[noops()]] case ARET, call nocache>>
    if((curtext->mark & LEAF) && (autosize == 0)) {
        // B 0(R14)
        p->as = AB;
        p->from = zprg.from;
        p->to.type = D_OREG;
        p->to.offset = 0;
        p->to.reg = REGLINK;
    } else {
        // MOVW.P autosize(R13), R15
        p->as = AMOVW;
        p->scond |= C_PBIT;
        p->from.type = D_OREG;
        p->from.offset = autosize;
        p->from.reg = REGSP;
        p->to.type = D_REG;
        p->to.reg = REGPC;
    }
    break;
@

The single instruction [[MOVW.P autosize(R13), R15]],
which uses the {special bit} [[.P]] (see the \book{Assembler}),
is equivalent to the sequence:
\begin{verbatim}
ADD autosize, R13, R13
MOVW -autosize(R13), R15
\end{verbatim}
\l really?

Note that this time the instruction [[p]] is overwritten;
[[RET]] really disappears.


Figure~\ref{fig:text-ret} summarizes the possible
translations for [[ATEXT]] and [[ARET]] on a simple
program with 3 procedures [[foo]], [[bar]], and
[[leaf]] where [[leaf]] is the only leaf procedure.
%
The numbers in the middle column, e.g. [[5000]],
represent the code addresses of the generated code in
the executable.
%
Figure~\ref{fig:text-ret-stack} shows
the stack after [[foo]] has called [[bar]] which
has called [[leaf]].

\begin{figure}[!]\centering
\begin{verbatim}
TEXT foo(SB), $4      5000: MOVW R14, $-8(R13)  
...                   5004: SUB $8, R13, R13
                            ...
BL bar(SB)        ==> 5020: BL 6000
...                         ...
RET                   5040: ADD $8, R13, R13                       
                      5044: MOVW $-8(R13), R15


TEXT bar(SB), $8      6000: MOVW R14, $-12(R13)
...                   6004: SUB $12, R13, R13
                            ...
BL leaf(SB)       ==> 6052: BL 7000
...                         ...
RET                   6080: ADD $12, R13, R13
                      6084: MOVW $-12(R13), R15


TEXT leaf(SB), $0     7000: /* nothing */
...               ==>       ...
RET                   7028: B (R14)
\end{verbatim}
\caption{[[TEXT]] and [[RET]] translations}\label{fig:text-ret}
\end{figure}
\l actually not BL 6000, BL uses relative number, but what is saved
\l  in the stack is an absolute address!

\begin{figure}[!]\centering
\begin{verbatim}
                |       |
----------- +20 +-------+ <----------------+ old value of R13
 foo            | ???   |  foo local
            +16 +-------+  
 frame          | 4054  |  return address of foo (in main)
----------- +12 +-------+ <----------------+ old value of R13
                | ???   |  bar first local
 bar         +8 +-------+  
                | ???   |  bar second local
 frame       +4 +-------+  
                | 5024  |  return address of bar (in foo)
-----------   0 +-------+ <----------------+ R13

R14 = 6056  = return address of leaf (in bar)
\end{verbatim}
\caption{Stack before [[B (R14)]] in [[leaf()]]}\label{fig:text-ret-stack}
\end{figure}



\subsection{[[ANOP]] stripping}

%trans:
Another virtual instruction rewritten by [[noops()]] is [[ANOP]].
%
The semantic of [[ANOP]] is to do nothing (nope),
which is why it can be removed from the graph of instructions:
\l there is a NOP in the ARM?

<<[[noops()]] first pass switch opcode cases>>=
case ANOP:
    q1 = p->link;
    q->link = q1;		// q is a non-ANOP before p
    q1->mark |= p->mark;
    continue;           // no  q = p; so q remains a non-ANOP
@
%old: /* q is non-nop */
%bug? q could be null, or assume never generate ANOP without anything before?
\l rely on q = p; done in for loop in noops, see code before

The compiler [[5c]] occasionally generates code using [[ANOP]]
(see the \book{Compiler}).
\t what for? USED, SET, other? need wait for Compiler.nw
[[5l]] does too as we will see in Section~\ref{sec:dupok-nop}.

Note that some instructions could have this deleted [[ANOP]] instruction
[[p]] as their branching target in [[Instr.cond]].
In that case their [[Instr.cond]] field must be updated:

% so also case ABL: before
<<[[noops()]] first pass switch opcode ABL fallthrough>>=
case AB:
case ABEQ: case ABNE:
case ABHS: case ABLO:
case ABMI: case ABPL:
case ABVS: case ABVC:
case ABHI: case ABLS:
case ABGE: case ABLT:
case ABGT: case ABLE:
case ABCASE:
    q1 = p->cond;
    if(q1 != P) {
        while(q1->as == ANOP) {
            q1 = q1->link;
        }
        p->cond = q1;
    }
    break;
@
%old: p->cond = q1;  was inside while but better outside
%bug? q1 could be null in the loop?
%todo: write test case showing the bug?
% I would rewrite the code as
%   while(q1 != P && q1->as == ANOP) 
%       q1 = q1->link;
%   p->cond = q1;


\bigskip
There are other virtual instructions rewritten by [[noops()]]
beside [[TEXT]], [[RET]], and [[NOP]]. Those are the most
important one though.
Chapter~\ref{chap:advanced} will present the transformation of
the remaining virtual instructions: [[DIV]], [[MOD]], and [[MOVWD]].
\l other?
\l other virtual instr transformed but later in asmout()?


\section{Laying out data, [[dodata()]]}

%trans:
As explained before,
%dup: overview/soft-archi main/asmb/data-sect resolving/issue
the goal of [[dodata()]] is to {layout} globals by
essentially modifying the [[Sym.value]] field of those globals.
%
This field was originally storing the size of the global
and will contain, after [[dodata()]], 
an offset to the start of the data section.
%
[[dodata()]] also computes two important globals storing
the size of the data and BSS sections:

<<global datsize>>=
long	datsize;
@

<<global bsssize>>=
long	bsssize;
@

Those globals are then used to generate the [[a.out]] header
in [[asmout()]], as shown in Section~\ref{sec:gen-header}.


The programmer {declares} globals and
specifies their {\em size} with [[GLOBL]],
e.g. [[GLOBL foo(SB), $4]]. %$
%
He can also specify their {\em content} with [[DATA]],
e.g. [[DATA foo(SB)/4, "hey\n"]], in which case the global
will be part of the data section ([[SDATA]]) 
instead of the BSS section ([[SBSS]]).
%
But, he does not care about the precise layout of those globals
in their respective sections.
%
[[dodata()]] gathers all the global declarations, spread in different
object files, and places them next to each other in memory.
\l layout = placing
It also {\em aligns} those globals at word boundaries
to satisfy architecture constraints on memory addressing.
\t constraint = ? for optimize too? or would also not work?
\l will also have alignment then in executable for data section globals.

The code is pretty straightforward once all the motivations
and the big picture have been presented 
(see Section~\ref{sec:dodata-big-picture}):

<<function dodata(arm)>>=
/// main -> <>
void
dodata(void)
{
    Prog *p;
    Sym *s;
    // offset to start of data section
    long orig;
    // size of data
    long v;
    //enum<Section>
    int t;
    int i;

    DBG("%5.2f dodata\n", cputime());

    // DATA instructions loop
    for(p = datap; p != P; p = p->link) {
        s = p->from.sym;
        <<[[dodata()]] if ADYNT or AINIT>>
        if(s->type == SBSS)
            s->type = SDATA;
        <<[[dodata()]] sanity check DATA instructions>>
    }

    <<[[dodata()]] if string in text segment>>

    orig = 0;

    /*
     * pass 1
     *  sanity check data values, and align.
     */
    // symbol table loop
    for(i=0; i<NHASH; i++)
     for(s = hash[i]; s != S; s = s->link) {
        t = s->type;
        if(t == SDATA || t == SBSS) {
            v = s->value; // size of global for now
            <<[[dodata()]] sanity check GLOBL instructions, size of data v>>
            v = rnd(v, 4); // align
            s->value = v;   // adjust
            <<[[dodata()]] in pass 1, if small data size, adjust orig>>
        }
    }

    /*
     * pass 2
     *	assign (large) 'data' variables to data segment
     */
    for(i=0; i<NHASH; i++)
     for(s = hash[i]; s != S; s = s->link) {
        t = s->type;
        if(t == SDATA) {
            v = s->value;
            // s->value used to contain the size of the GLOBL.
            // Now it contains its location (as an offset to INITDAT)
            s->value = orig;
            orig += v;
        } else {
            <<[[dodata()]] in pass 2, retag small data>>
        }
    }
    orig = rnd(orig, 8);

    datsize = orig;

    /*
     * pass 3
     *	everything else to bss segment
     */
    for(i=0; i<NHASH; i++)
     for(s = hash[i]; s != S; s = s->link) {
        if(s->type == SBSS) {
            v = s->value;
            s->value = orig;
            orig += v;
        }
    }
    orig = rnd(orig, 8);

    bsssize = orig-datsize;

    <<[[dodata()]] define special symbols>>
}
@
\l do not use v? was used for version previously
\t why not use offset instead of orig?
\n first iteration is on datap instructions, the other are on the symbol table.
%old:
%            while(v & 3) // align
%                v++;
%    while(orig & 7) // align
%        orig++;
%    while(orig & 7) // align
%        orig++;
%   better use rnd()
%old: was doing <<[[dodata()]] sanity check size of data v>>
% in pass2 for SDATA but not for BSS. I think more consistent not do it
% anywhere, any redundant with check done in pass1.

Note that we are just laying out globals here. We use mostly
the [[GLOBL]] declarations which are stored in the symbol table
[[hash]].
%
The use of the [[DATA]] instructions and [[datap]]
to generate the data section in the executable is done in [[datblk()]]
(see Section~\ref{sec:datblk}), not in [[dodata()]].

\t what matters is do before dotext() though! because oplook! instoffset, etc.

\l could do orig = INITDAT? no, we can't because we don't know yet the size
\l   of the text ... this is computed in dotext().

\n Order of globals in executable = order in hash table = hard to predict.


<<[[dodata()]] sanity check GLOBL instructions, size of data v>>=
if(v == 0) { // check
    diag("%s: no size", s->name);
    v = 1;
}
@

<<[[dodata()]] sanity check DATA instructions>>=
if(s->type != SDATA)
    diag("initialize non-data (%d): %s\n%P",
        s->type, s->name, p);

v = p->from.offset + p->reg;
if(v > s->value)
    diag("initialize bounds (%ld): %s\n%P",
        s->value, s->name, p);
@

Remember that [[Instr.reg]] is (ab)used to store
the size of the [[DATA]] {slice}, e.g. 4
in [[DATA foo+8(SB)/4, "hey!"]].



\section{Laying out code, [[dotext()]]}

%trans:
We are now ready to see the last function of the 
resolving phase: [[dotext()]].
%dup: (and adapted) from resolving/dodata
As explained before,
%dup: overview/soft-archi main/asmb/text resolving/issue/pc
the goal of [[dotext()]] is to {layout} code by
essentially modifying the [[Instr.pc]] of all code instructions.
%
This field was originally storing a virtual program counter
and will contain, after [[dotext()]], a real program counter.
%
[[dotext()]] also computes the important global below which stores
the size of the text section:

<<global textsize>>=
long	textsize;
@

This global is also used to generate the [[a.out]] header
in [[asmout()]], as shown in Section~\ref{sec:gen-header}.
%
[[dotext()]] also computes [[INITDAT]] which will be used
to initialize [[R12]] at run-time.
\t and in code generation when computing absolute address sometimes!

%dup: (and adapted) resolving/dodata
The code of [[dotext()]] is pretty straightforward once all the motivations
and the big picture have been presented 
(see Section~\ref{sec:dotext-big-picture}):

<<function span(arm)>>=
/// main -> <>
void
dotext(void)
{
    Prog *p;
    Optab *o;
    // real code address
    long c; // ulong?
    // size of instruction
    int m;
    <<[[dotext()]] other locals>>

    DBG("%5.2f span\n", cputime());

    c = INITTEXT;
    <<[[dotext()]] initialisation>>

    for(p = firstp; p != P; p = p->link) {
       <<adjust curtext when iterate over instructions p>>
       <<adjust autosize when iterate over instructions p>>

        // real program counter transition
        p->pc = c;

        o = oplook(p);
        m = o->size;
        c += m;

        if(m == 0) {
            if(p->as == ATEXT) {
                if(p->from.sym != S)
                    p->from.sym->value = c;
                <<[[dotext()]] detect if large procedure>>
            } else {
                diag("zero-width instruction\n%P", p);
            }
        } else {
            <<[[dotext()]] pool handling for optab o>>
        }
    }

    <<[[dotext()]] if string in text segment>>

    c = rnd(c, 8);

    textsize = c - INITTEXT;
    <<[[dotext()]] refine special symbols>>
    if(INITRND)
        INITDAT = rnd(c, INITRND);
    DBG("tsize = %lux\n", textsize);
}
@
\t use orig instead of 'c' so match more dodata()? or better, use realpc!
\t need to modify Sym.value? used later?
\l oplook call aclass() which needs to know offset size, 
%old:
%  - was called span()
%  - the c+=m was in second else branch, but I put before
%  - the autosize adjustment was done later but actually bug?
%    anyway if was ATEXT then no aclass() call anyway
%  - the curtext adjustment was done later too
% but here it's really a concrete location whereas for dodata()
% it's relative to INITDAT that we actually compute here.


[[dotext()]] relies on modifications done by the previous functions
of the resolving phase:
\begin{itemize}
\item [[noops()]], so [[oplook()]] does not have to deal
with virtual instructions (except [[MOVW]])

\item [[patch()]], which is needed for [[noops()]] to work
\l also later for p->cond->pc but for asmout, not dotext

\item [[dodata()]], so all globals have an assigned address
(as an offset to [[R12]]) and so [[oplook()]] can predict
the size of instructions involving globals
\n aclass()

\end{itemize}

%dup: (and adapted) resolving/dodata
Note again that we are just laying out code here. We do not
generate code. The generation of the code section of
the executable is done in [[asmb()]] 
and [[asmout()]] (see Section~\ref{sec:asmout}),
not in [[dotext()]].


%\subsection{Large procedures}

<<[[dotext()]] other locals>>=
long    otxt;
@
<<[[dotext()]] initialisation>>=
otxt = c;
@
\l could do just long otxt = INITTEXT;

<<[[dotext()]] detect if large procedure>>=
if(c - otxt >= 1L<<17) {
    diag("Procedure %s too large\n", TNAME);
    errorexit();
}
otxt = c;
@
% >>
\t why large procedure special? because of limitations of ARM? why 17??
%old: there was some special code to handle really large procedures
% but the code looked buggy, so I commented it out for now.
% it was mentioning SBRA which I removed

%<<[[dotext()]] locals>>=
%bool bflag;
%@
%<<[[dotext()]] initialisation>>=
%bflag = false;
%@
%<<[[dotext()]] if large procedure set bflag>>=
%/* need passes to resolve branches */
%if(c - otxt >= 1L<<17)
%    bflag = true;
%@
%
%<<[[dotext()]] if large procedure>>=
%/*
% * if any procedure is large enough to
% * generate a large SBRA branch, then
% * generate extra passes putting branches
% * around jmps to fix. this is rare.
% */
%while(bflag) {
%    DBG("%5.2f span1\n", cputime());
%    bflag = false;
%    c = INITTEXT;
%    for(p = firstp; p != P; p = p->link) {
%        <<adjust curtext when iterate over instructions p>>
%        p->pc = c;
%        o = oplook(p);
%        m = o->size;
%        if(m == 0) {
%            if(p->as == ATEXT) {
%                autosize = p->to.offset + 4;
%                if(p->from.sym != S)
%                    p->from.sym->value = c;
%            } else {
%                diag("zero-width instruction\n%P", p);
%            }
%        } else {
%             c += m;
%        }
%    }
%}
%@
%bug? does not have the [[dotext()]] if large procedure set bflag here?

%/* very larg branches
%            if(o->type == 6 && p->cond) {
%                otxt = p->cond->pc - c;
%                if(otxt < 0)
%                    otxt = -otxt;
%                if(otxt >= (1L<<17) - 10) {
%                    q = prg();
%                    q->link = p->link;
%                    p->link = q;
%                    q->as = AB;
%                    q->to.type = D_BRANCH;
%                    q->cond = p->cond;
%                    p->cond = q;
%                    q = prg();
%                    q->link = p->link;
%                    p->link = q;
%                    q->as = AB;
%                    q->to.type = D_BRANCH;
%                    q->cond = q->link->link;
%                    bflag = 1;
%                }
%            }
% */



\section{Defining special symbols [[etext]], [[edata]], [[end]]}
\label{sec:special-symbols}

%dup: overview/hello-world/nm-exec
The linker defines a few {\em special symbols}
which allow a form of {\em reflection} on the executable structure
and its sections.
%
Those symbols and their meanings
are listed in Figure~\ref{fig:special-symbols}
which describes the memory layout of the [[hello]] executable
we saw in Section~\ref{sec:hello-world}.

\begin{figure}[!]\centering
\begin{verbatim}
                     |              |
                     |    HEAP      |
                     |              |
            ^ 0x7c50 +--------------+<---- end
            |        |     BSS      |
    bsssize |        |              |
            v 0x7940 +--------------+<---- edata (end data)
            ^        |              |
    datsize |        |     Data     |
            |        |              |
INITDAT --> v 0x7000 +--------------+<---- bdata (begin data)
                     |  (padding)   |
              0x6b58 +--------------+<---- etext (end text)
                     |              |
                     |     Code     |
                     |    (Text)    |
                     |              |
                     |              |
              0x1020 +--------------+
                     |    header    |
              0x1000 +--------------+
                     | (first page  |
                     |  unmapped)   |
                     |              |
                   0 +--------------+
                  Memory layout of hello     special symbols
                        executable
\end{verbatim}
\caption{Memory layout of [[hello]] and special symbols}
\label{fig:special-symbols}
\end{figure}
\n also some padding before and after BSS, but very small, just 8

Those symbols are introduced by [[5l]] with [[xdefine()]]:

<<[[dodata()]] define special symbols>>=
xdefine("bdata", SDATA, 0L);
xdefine("edata", SDATA, datsize);
xdefine("end",   SBSS, datsize+bsssize);
@

<<function xdefine(arm)>>=
void
xdefine(char *p, int t, long v)
{
    Sym *s;

    s = lookup(p, 0);
    if(s->type == SNONE || s->type == SXREF) {
        s->type = t;
        s->value = v;
    }
}
@
\t should maybe diag if symbol already there no?

Note that the [[Sym.value]] for the [[bdata]] symbol
is [[0]], not [[INITDAT]]. Indeed, just like for 
globals, special data symbols have their addresses
represented as an offset to the start of the data section.
%
Moreover, [[INITDAT]] has not yet been computed in [[dodata()]].
But, it is important to layout those special symbols in [[dodata()]],
before [[dotext()]], just like globals, as they may also be
referenced in instructions.
\l There are many code later then do the final s->value _plus_ INITDAT.

Special symbols are similar to globals
but they do not take any space in the data or BSS section.
In fact, the first global of the data section will have the same
address than [[bdata]].
%
They are used only for their addresses in instructions
such as [[MOVW $etext(SB), R1]]. %$
The \plan kernel uses the addresses of those symbols
to move itself in memory during the boot procedure (see the \book{Kernel}).
\l show code?
The [[sbrk()]] system call, which is used by [[malloc()]], uses [[end]]
to know where the heap starts (see the \book{Core library}).
\l If do &end in C (or dollar end in asm) then you'll get pointer to end of BSS

\l (part of symbol table (for debugging))

[[etext]] is also initialized in [[dodata()]] so it can be referenced
in instructions:

<<[[dodata()]] define special symbols>>=
xdefine("etext", STEXT, 0L);
@

% I wrote that, but it's buggy if keep previous xdefine as xdefine
%  set only if symbol was undefined
%<<[[dotext()]] define special symbols>>=
%xdefine("etext", STEXT, INITTEXT+textsize);
%@

But its final value can be set only in [[dotext()]]:

<<[[dotext()]] refine special symbols>>=
lookup("etext", 0)->value = INITTEXT+textsize;
@
%old: in span():
% setext = lookup("etext", 0);
% if(setext != S) {
%    setext->value = c;
%    textsize = c - INITTEXT;

Note that for code symbols, [[Sym.value]] contains a real
code address, not an offset.

\t fixpoint issue? not for dollar etext because anyway will be LCON
\t  but for etext(SB) then yes could have pb if final address
\t  become a LCON




\section{Mutual recursivity in layout and [[SB/R12]]}
\label{sec:sb-r12}

The last special symbol [[5l]] defines is [[setR12]]
which we mentioned before:

<<[[dodata()]] define special symbols setR12 IF unoptimized>>=
xdefine("setR12", SDATA, 0L);
@

It is the last piece of the process we outlined in
Section~\ref{sec:dodata-big-picture} to solve the
mutual dependency issue between the layout of code and data.
%
Note that the [[Sym.value]] of [[setR12]], just like for [[bdata]],
is [[0]], not [[INITDAT]].
But, 
The address of [[setR12]] when used in an instruction,
e.g. [[MOVW $setR12(SB), R12]], %$
is recognized in a special way by the code generator
and will be converted in an instruction which loads
its {\em absolute address}, which will be [[INITDAT]].
\t ref to section that explains full thing?
%
Just like for [[etext]] and [[edata]], the use of
the special symbol [[setR12]] allows a form of reflection
which is needed to communicate the value of [[INITDAT]]
to the program.
%alt: could generate instr after _main? simpler?

% >>
% lib_core/libc/arm/main9.s will do 
%	MOVW	$setR12(SB), R(sb)
% before anything.

Section~\ref{sec:BIG} will present an optimisation around [[setR12]]
which will actually change its value.












\chapter{Machine Code Generation}
\label{chap:arm-codegen}

%trans:
The final step of the linking pipeline is to generate code.
% have seen asmb(), in Section X, generate header, code
% section, data section. But was using oplook, asmout,
% so can now see missing pieces, individual instr generation.
%toc:
% oplook, asmout
%But First recall ARM instr format, and additional DS.

%dup: The code generation is done by 5l, not 5a, surprisingly!
%real-world:?

\section{ARM instruction format}

% ref to colorful guide again
% mainly 4 categories, 6 formats: arith, arith with immediate,
%  memory with offsets, branch immediate, branch


% immediate value, 8+4 bits

% memory address and offsets, register + 12 bits (1 page)

% => constraints on size of things so need find tricks.
% first Class will say if satisfy constraint.
% If not then pool. 
% Other?

\section{Additional data structures}

\subsection{[[Optab]] and [[optab]]}
\label{sec:optab}
\n could put in core DS but it's really specific to the code generation chapter

<<struct Optab(arm)>>=
struct	Optab
{
    // enum<Opcode> from 5.out.h, (the opcode is the representant of a range)
    byte	as;

    // enum<Cxxx>, possible operand_kind/class for first operand
    short	a1;
    // enum<Cxxx>, possible operand_kind/class for second operand
    short	a2;
    // enum<Cxxx>, possible operand_kind/class for third operand
    short	a3;

    // idx for the code generator, see the giant switch in asmout()
    short	type; 

    // size of the corresponding machine code (should be a multiple of 4)
    short	size; 

    <<[[Optab]] other fields>>
};
@
% The order of entries is important!!, see optab[] global, see ocmp()!
% It does not matter for cmp() but it matters for ocmp().
% The order for the operand class is also important!
% For instance C_HFAUTO must be before C_LAUTO otherwise
% the careful order of entries in optab will not be taken
% into account.
%ocaml: use a single pattern match so far easier.

%ex of entries:
% Optab	optab[] =
% {
%    ...
%    { AADD,		C_REG,	C_REG,	C_REG,		 1, 4, 0 },
%    { AADD,		C_REG,	C_NONE,	C_REG,		 1, 4, 0 },


% ARM has fixed-length instructions, 4, but 5a/ support
% some fake/virtual opcodes that actually expands to 
% multiple instructions, hence the size field above.
% Also because of 12 bits immediate need special tricks, pool(),
% RCON vs LCON, etc. So there are many cases where we generate
% for one Asm5 instruction multiple ARM instructions. 

%\section{[[optab]]}

% This table contains the different valid combinations 
% of operands for the different opcodes. Actually not all opcodes are put,
% only some representative (see also oprange that describes
% the equivalence classes).
% There is a strong coupling with the grammar 5a/a.y to see
% what operands are allowed, e.g. AMOV has gen operand which
% allow many things, but AADD has more restricted operands
% (immediate, shift, or plain register).

% not sure it needs this complexity, things could probably
% be factorized more.

<<global optab (linkers/5l/optab.c)(arm)>>=
Optab	optab[] =
{
    <<[[optab]] entries>>
    { AXXX,		C_NONE,	C_NONE,	C_NONE,		 0, 4, 0 },
};
@
% AXXX at the end? why not ALAST instead?
%old: { ASWI,		C_NONE,	C_NONE,	C_LOREG,	10, 4, 0 },


\subsection{[[Oprange]]}

% one form of general pattern, for instr.

% Optab range
<<struct Oprange(arm)>>=
struct	Oprange
{
    //index in sorted optab global
    Optab*	start;
    //index in sorted optab global
    Optab*	stop;
};
@
%old: was Oprang

<<global oprange(arm)>>=
Oprange	oprange[ALAST];
@

% will be the set of entries in the sorted optab
% that talk about a certain opcode

\subsection{[[Operand_class]]}
% was in core DS, but I think better here with Optab.

\subsubsection{Basic classes}

% seems called the class, see aclass(), a more precise operand_kind
% closer to the machine constraint as we will see in next section
<<enum Operand_class(arm)>>=
// order of entries matter! coupling with cmp() and ocmp()
enum Operand_class {
    C_NONE		= 0,

    C_REG,
    C_REGREG,
    C_SHIFT,
    C_PSR,

    C_BRANCH,

    <<[[Operand_class]] cases>>

    C_GOK, // must be at the end e.g. for xcmp[] decl, or buildop loops
};
@
%old: I renamed Operand_class, consistent with Operand_kind. C vs D.
%diffs with operand_kind:
% - OREG splitted in many xxxOREG and xxxEXT (SB), xxAUTO (FP, SP)
% - D_CONST splitted in many xxxCON
% - S_CONST?
% - a new C_GOK, but could be called C_LAST I think
%
%less: do big categories, xxCON, xxAUTO, xxEXT, xxREG?
%old: there was C_SBRA, C_LBRA but LBRA was unused so I s/C_LBRA/C_BRANCH/
% there was also this in cmp()
%    case C_LBRA:
%        if(b == C_SBRA)
%            return 1;
%        break;
%

%code: order of entries matter! look at code of cmp() to see which
% classes are subclasses and must be after.

\subsubsection{[[aclass()]]}

<<function aclass(arm)>>=
int
aclass(Adr *a)
{
    Sym *s;
    int t;

    switch(a->type) {
    case D_NONE:
        return C_NONE;

    case D_REG:
        return C_REG;
    case D_REGREG:
        return C_REGREG;
    case D_SHIFT:
        return C_SHIFT;
    case D_PSR:
        return C_PSR;

    case D_BRANCH:
        return C_BRANCH;

    <<[[aclass()]] switch type cases>>
    }
    return C_GOK;
}
@
% I think aclass() assumes the size of the sections
% has been computed so it can know if a symbol reference
% is close and so could be stored in a half-word, or if
% it's far away.

\subsubsection{Refined classes and [[instoffset]]}

% another form of pattern, for operand this time.

<<global instoffset(arm)>>=
long	instoffset;
@
% instruction offset?
% really needs to be a global? can't be just a local to aclass()?

% seems to be used both for immediate constant and offset


% other kind of range than OpRange, range of possible values
% of operands. with inheritance notion! Quite subtle.



\paragraph{[[D_OREG]]}
% offsets constraints
% ex of instr: MOVW OFF(R13), R2


<<[[aclass()]] switch type cases>>=
case D_OREG:
    switch(a->symkind) {
    <<[[aclass()]] D_OREG case, switch symkind cases>>
    }
    return C_GOK;
@
% OREG usually is a dereference of a register or a symbol reference
% (which is then really an implicit offet to SB)

% H S L ? half, small, large?
<<[[Operand_class]] cases>>=
C_HEXT,
<<[[Operand_class]] cases, in C_xEXT, float cases>>
C_SEXT,
C_LEXT,
@
% EXT for? external symbol?

%xxx+y(SB)
<<[[aclass()]] D_OREG case, switch symkind cases>>=
case N_EXTERN:
case N_INTERN:
    if(a->sym == nil || a->sym->name == nil) {
        print("null sym external\n");
        print("%D\n", a);
        return C_GOK;
    }
    s = a->sym;
    t = s->type;
    if(t == SNONE || t == SXREF) {
        diag("undefined external: %s in %s", s->name, TNAME);
        s->type = SDATA;
    }
    <<[[aclass()]] when D_OREG and external symbol and dlm>>
    instoffset = s->value + a->offset - BIG;
    t = immaddr(instoffset);
    if(t) {
        <<[[aclass()]] if immfloat for N_EXTERN symbol>>
        return immhalf(instoffset)? C_HEXT : C_SEXT;
    }
    return C_LEXT;
@


<<[[Operand_class]] cases>>=
C_HAUTO,	/* halfword insn offset (-0xff to 0xff) */
<<[[Operand_class]] cases, in C_xAUTO, float cases>>
C_SAUTO,	/* -0xfff to 0xfff */
C_LAUTO,
@
% the order matters! because of ocmp() and the order of entries in optab
% hence the chynk for float here

<<[[aclass()]] D_OREG case, switch symkind cases>>=
case N_LOCAL:
    instoffset = autosize + a->offset;
    t = immaddr(instoffset);
    if(t){
        <<[[aclass()]] if immfloat for N_LOCAL or N_PARAM symbol>>
        return immhalf(instoffset)? C_HAUTO : C_SAUTO;
    }
    return C_LAUTO;
@

<<[[aclass()]] D_OREG case, switch symkind cases>>=
case N_PARAM:
    instoffset = autosize + a->offset + 4L;
    t = immaddr(instoffset);
    if(t){
        <<[[aclass()]] if immfloat for N_LOCAL or N_PARAM symbol>>
        return immhalf(instoffset)? C_HAUTO : C_SAUTO;
    }
    return C_LAUTO;
@
% +4??

% RO? rotated?
<<[[Operand_class]] cases>>=
C_HOREG,
<<[[Operand_class]] cases, in C_xOREG, float cases>>
C_SOREG,
C_LOREG,

C_ROREG,
C_SROREG,	/* both S and R */
@

<<[[aclass()]] D_OREG case, switch symkind cases>>=
case D_NONE:
    instoffset = a->offset;
    t = immaddr(instoffset);
    if(t) {
        <<[[aclass()]] if immfloat for D_NONE symbol>>

         /* n.b. that immhalf() will also satisfy immrot */
        if(immhalf(instoffset))	
            return C_HOREG;

        if(immrot(instoffset))
            return C_SROREG;
        return immhalf(instoffset)? C_HOREG : C_SOREG;
    }
    if(immrot(instoffset))
        return C_ROREG;
    return C_LOREG;
@




\paragraph{[[D_CONST]]}
% immediate constants constraints
% ex of instr: ADD I, R1, R2

<<[[aclass()]] switch type cases>>=
case D_CONST:
    switch(a->symkind) {
    <<[[aclass()]] D_CONST case, switch symkind cases>>
    }
    return C_GOK;
@


% Rotated, Negative, Large?
<<[[Operand_class]] cases>>=
C_RCON,		/* 0xff rotated */ // 0xff range, possibly rotated
C_NCON,		/* ~RCON */
C_LCON,
@
%TODO: must impose order with other xCON?
%dead: C_SCON,		/* 0xffff */
%in the end NCON is not different from LCON when you look at optab,
% so perhaps it could be removed.
%note that LCON is more "general" than the other, see cmp() later.

<<[[aclass()]] D_CONST case, switch symkind cases>>=
case D_NONE:
    instoffset = a->offset;
    if(a->reg != R_NONE) // when?
        goto aconsize;

    if(immrot(instoffset))
        return C_RCON;
    if(immrot(~instoffset))
        return C_NCON;
    return C_LCON;
@



\paragraph{[[D_ADDR]]}

%todo: D_ADDR?
%\subsubsection{[[D_ADDR]]}
% should not use D_CONST when really you use the address of a symbol


% rotated External const
<<[[Operand_class]] cases>>=
C_RECON,
@
%dead: C_LECON
%optab:    { AMOVW,	C_LECON,C_NONE,	C_REG,		34, 8, REGSB,	LFROM },
%cmp:    case C_LECON:
%        if(b == C_RECON)
%            return 1;
%        break;

<<[[aclass()]] D_CONST case, switch symkind cases>>=
case N_EXTERN:
case N_INTERN:
    s = a->sym;
    if(s == S) // no warning?
        break;
    switch(s->type) {
    case STEXT: case SSTRING:
    case SCONST:
    case SUNDEF:
        instoffset = s->value + a->offset;
        return C_LCON; // etext is stable
    case SNONE: case SXREF:
        diag("undefined external: %s in %s", s->name, TNAME);
        s->type = SDATA;
        // Fall through
    case SDATA: case SBSS: case SDATA1:
        if(!dlm) {
            instoffset = s->value + a->offset - BIG;
            if(immrot(instoffset) && instoffset != 0) // VERY IMPORTANT != 0
                return C_RECON;
        }
        // else
        instoffset = s->value + a->offset + INITDAT;
        return C_LCON;
    }
    diag("unknown section for %s", s->name);
    break;
@
%pad: I added the final diag() because of the way I wrote the code
%old: used to be but more messy because of return and break
%    case SNONE: case SXREF:
%        diag("undefined external: %s in %s", s->name, TNAME);
%        s->type = SDATA;
%        break;
%    }
%    if(!dlm) {
%        instoffset = s->value + a->offset - BIG;
%        if(immrot(instoffset) && instoffset != 0)
%            return C_RECON;
%    }
%    instoffset = s->value + a->offset + INITDAT;
%    return C_LCON;
%old: case SLEAF: 

% for LCON have to do the INITDAT!
% really need RECON?
% what about setR12? how bootstrap? can match C_RECON?
% no cos of the special case != 0!! because setR12 is BIG, so
% BIG-BIG = 0 so use LCON for that




%todo: need that? when do we get the address of a local or parameter?
% for which code we have those classes used??
<<[[Operand_class]] cases>>=
C_RACON,
C_LACON,
@
%RA Rotate Address? and Long Address?

<<[[aclass()]] D_CONST case, switch symkind cases>>=
case N_LOCAL:
    instoffset = autosize + a->offset;
    goto aconsize;
@
<<[[aclass()]] D_CONST case, switch symkind cases>>=
case N_PARAM:
    instoffset = autosize + a->offset + 4L;
    goto aconsize;
@


<<[[aclass()]] D_CONST case, switch symkind cases>>=
aconsize:
    return immrot(instoffset)? C_RACON : C_LACON;
@



%old: dead: this advanced addressing mode of 5a is not that useful
%    case D_OCONST:
%        switch(a->name) {
%        case N_EXTERN:
%        case N_INTERN:
%            s = a->sym;
%            t = s->type;
%            if(t == 0 || t == SXREF) {
%                diag("undefined external: %s in %s",
%                    s->name, TNAME);
%                s->type = SDATA;
%            }
%            instoffset = s->value + a->offset + INITDAT;
%            if(s->type == STEXT || s->type == SLEAF || s->type == SUNDEF)
%                instoffset = s->value + a->offset;
%            return C_LCON;
%        }
%        return C_GOK;



\subsection{Pool}
\label{sec:pool-and-reg-tmp}


% was in Resolving/issue/virtual-pc
%where the first instruction would load the big number from 
%
%% LDR $pool1, RTMP
%% ADD RTMP, R1, R2
%% DATA pool1+0/4 $10256
%
%somewhere in
%a reserved register 
%\l REGTMP
%and where the second instruction would then 
%substitutes the big number
%
% from the original
%instruction in the following instruction.
%\l actually two code and one data?


% see 5l -v -a, see WORD generated at the end for constants
% that could not be encoded in one ARM instruction. Asm5 != ARMv6

<<[[Optab]] other fields>>=
// 0 | REGSB | REGSP
short	param;
// bitset<enum<Optab_flag>>
short	flag;
@
%old: was char, but ugly
% order is important, see optab[] global

<<enum Optab_flag(arm)>>=
enum Optab_flag {
    LFROM	= 1<<0,
    LTO		= 1<<1,
    LPOOL	= 1<<2,
    <<[[Optab_flag]] cases>>
};
@
% >> >> >> >> >>



<<[[dotext()]] pool handling for optab o>>=
switch(o->flag & (LFROM|LTO|LPOOL)) {
case LFROM:
    addpool(p, &p->from);
    break;
case LTO:
    addpool(p, &p->to);
    break;

case LPOOL:
    if ((p->scond&C_SCOND) == COND_ALWAYS)
        flushpool(p, 0);
    break;
}

if(p->as==AMOVW && p->to.type==D_REG && p->to.reg==REGPC && 
   (p->scond&C_SCOND) == COND_ALWAYS)
    flushpool(p, 0);

if(blitrl)
    checkpool(p);
@
% c += m; used to be before if(blitrl)


% arm specific
<<global pool(arm)>>=
static struct {
    ulong	start;
    ulong	size;
} pool;
@


<<function checkpool(arm)>>=
/*
 * when the first reference to the literal pool threatens
 * to go out of range of a 12-bit PC-relative offset,
 * drop the pool now, and branch round it.
 * this happens only in extended basic blocks that exceed 4k.
 */
void
checkpool(Prog *p)
{
    if(pool.size >= 0xffc || immaddr((p->pc+4)+4+pool.size - pool.start+8) == 0)
        flushpool(p, 1);
    else if(p->link == P)
        flushpool(p, 2);
}
@

<<global blitrl(arm)>>=
Prog*	blitrl;
@

<<global elitrl(arm)>>=
Prog*	elitrl;
@


<<function flushpool(arm)>>=
void
flushpool(Prog *p, bool skip)
{
    Prog *q;

    if(blitrl) {
        if(skip){
            if(debug['v'] && skip)
                print("note: flush literal pool at %lux: len=%lud ref=%lux\n", p->pc+4, pool.size, pool.start);
            q = prg();
            q->as = AB;
            q->to.type = D_BRANCH;
            q->cond = p->link;
            q->link = blitrl;
            blitrl = q;
        }
        else if(p->pc+pool.size-pool.start < 2048)
            return;
        elitrl->link = p->link;
        p->link = blitrl;
        blitrl = nil;	/* BUG: should refer back to values until out-of-range */
        elitrl = nil;
        pool.size = 0;
        pool.start = 0;
    }
}
@

<<function addpool(arm)>>=
void
addpool(Prog *p, Adr *a)
{
    Prog *q, t;
    int c;

    c = aclass(a);

    t = zprg;
    t.as = AWORD;

    switch(c) {
    case C_SROREG:
    case C_LOREG:
    case C_ROREG:
    case C_FOREG:
    case C_SOREG:
    case C_FAUTO:
    case C_SAUTO:
    case C_LAUTO:
    case C_LACON:
        t.to.type = D_CONST;
        t.to.offset = instoffset;
        break;
    default:
        t.to = *a;
        break;
    }

    for(q = blitrl; q != P; q = q->link)	/* could hash on t.t0.offset */
        if(memcmp(&q->to, &t.to, sizeof(t.to)) == 0) {
            p->cond = q;
            return;
        }

    q = prg();
    *q = t;
    q->pc = pool.size;

    if(blitrl == P) {
        blitrl = q;
        pool.start = p->pc;
    } else
        elitrl->link = q;
    elitrl = q;
    pool.size += 4;

    p->cond = q;
}
@




\section{Half, Small, Large, Rot, Neg}
\label{sec:clever-trick-numbers}

% Those are some kinds of optimisations? a bit but also need that
% because expressivity Asm5 greater than what ARM can actually do sometimes.

% http://alisdair.mcdiarmid.org/arm-immediate-value-encoding/


% The load/store ARM instructions take 2 registers (src_val, dst_address)
% and a 12 bits offset (for a range of 4096, so really a page, maybe 2 if can
% do negative offset with a bit).
% That means that if you do  'MOVW $1, myglobal', naively you'll have to
% encode it as 3 instructions:
%     MOV $1, R1
%     MOV $myglobal, R2
%     STR R1, R2.
% But if myglobal is not that far from address 0 and you have a special
% register reserved that always contain 0 (e.g. R12),
% then you could use the 12bits offset instead of using a register
% and just do
%     MOV $1, R1
%     STR R1, R12+$myglobal
% If you have a special register which always contain the value 1, 
% then you do even better with just do 
%     STR R0, R12+$myglobal! 
% which is 3 times faster (well if the global address is in a cache).
%
% In practice the first page of the address space is always reserved
% so it's better to store in R12 a bigger value. R12 will actually
% be set to INITDAT+BIG.



\subsection{Immediate address, [[immaddr()]]}

<<function immaddr(arm)>>=
long
immaddr(long v)
{
    if(v >= 0 && v <= 0xfff)
        return (v & 0xfff) |
            (1<<24) |	/* pre indexing */
            (1<<23);	/* pre indexing, up */

    if(v < 0 && v >= -0xfff)
        return (-v & 0xfff) |
            (1<<24);	/* pre indexing */
    return 0;
}
@
%old? why need v & 0xfff? redundant no?
% >> >> >>
% rename immsmall?
% why 0xfff? = Because immediate offset range is 12 bits
% (with sign)

% bit P and big U?

\subsection{Half immediate address, [[immhalf()]]}

<<function immhalf(arm)>>=
int
immhalf(long v)
{
    if(v >= 0 && v <= 0xff)
        return v |
            (1<<24)  |	/* pre indexing */
            (1<<23);	/* pre indexing, up */
    if(v >= -0xff && v < 0)
        return (-v & 0xff)|
            (1<<24);	/* pre indexing */
    return 0;
}
@
% >> >> >>
% seems identical to immhalf no? no now it's 0xff! not 0xfff

\subsection{immediate values (possibly rotated), [[immrot()]]}
% immediate (rotated) address

% see Machine.nw and the ARM refcard to understand the code below.
% RCON is for small immediate value, or rotated things of small 
% immediate value.
% You have 8 bits for the number (0xff) and 4 bits for the rotate (16)
% hence the code below.

% http://alisdair.mcdiarmid.org/arm-immediate-value-encoding/

<<function immrot(arm)>>=
long
immrot(ulong v)
{
    int i;

    for(i=0; i<16; i++) {
        if((v & ~0xff) == 0)
            return (i<<8) | v | (1<<25);
        v = (v<<2) | (v>>30);
    }
    return 0;
}
@
% >> >>

% there is code like
%    o1 |= immrot(instoffset);
% the 1<<25 means we are in the  i,r,r  case



\section{[[buildop()]] and [[oplook()]]}

<<[[main()]] initialize globals(arm)>>=
buildop();
@

\subsection{[[buildop()]]}

<<function buildop(arm)>>=
/// main (init) -> <>
void
buildop(void)
{
    int i, n;
    // enum<Opcode> representing a range
    int r;

    <<[[buildop()]] initialize xcmp cache>>
    <<[[buildop()]] initializer floating flags>>

    for(n=0; optab[n].as != AXXX; n++) {
        <<[[buildop()]] adjust optab if floating flags>>
    }

    qsort(optab, n, sizeof(optab[0]), ocmp);

    for(i=0; i<n; i++) {
        r = optab[i].as;

        oprange[r].start = optab+i;
        while(optab[i].as == r)
            i++;
        oprange[r].stop = optab+i;
        i--;

        switch(r)
        {
        <<[[buildop()]] switch opcode r for ranges cases>>
        default:
            diag("unknown op in build: %A", r);
            errorexit();
        }
    }
}
@
%old:		case ABX:
%old:		case ABXRET:
% coupling with order of opcode in 5.out.h? no, this just
% describe the equivalence classes for optab, that
% is an entry in optab about AADD is also valid for AAND, etc.
% invariant: the case in the switch must be the entries in optab, not
% more, not less



<<[[buildop()]] switch opcode r for ranges cases>>=
case AXXX:
    break;
@
% no ARET? no because noops should have rewrote it.
% no ADATA/AGLOBL because buildop is used for code (TEXT) generation,
% not for data (DATA) generation.



<<function ocmp(arm)>>=
/// main -> buildop -> qsort(..., <>)
int
ocmp(const void *a1, const void *a2)
{
    Optab *p1, *p2;
    int n;

    p1 = (Optab*)a1;
    p2 = (Optab*)a2;

    n = p1->as - p2->as;
    if(n)
        return n;
    <<[[ocmp()]] if floating point flag on p1 or p2>>
    n = p1->a1 - p2->a1;
    if(n)
        return n;
    n = p1->a2 - p2->a2;
    if(n)
        return n;
    n = p1->a3 - p2->a3;

    if(n)
        return n;
    return 0;
}
@
%sort first by opcode, then class of first operand, then second, then thrd.
%note: Is it needed since in oplook() we just
% iterate over all the range for a certain opcode?
% Yes it is needed! The order of the entries in optab matter, because have
% some specific entries first and then a general one

%TODO: which is why perhaps doing some += in the chunk for xxx
% is not good?  
%update: ??

\subsection{[[oplook()]]}

<<[[oplook()]] locals>>=
Optab *o, *e;
// enum<Opcode>, to index oprange[]
int r;
// enum<Class>
int a1, a2, a3;
@


% leverage the sorted data structure computed by buildop()
<<function oplook(arm)>>=
/// main -> (dotext | asmb) -> <>
Optab*
oplook(Prog *p)
{
    <<[[oplook()]] locals>>
 
    <<[[oplook()]] if use cache, part1>>
    else {
        a1 = aclass(&p->from);
        a3 = aclass(&p->to);
    }
    a2 = (p->reg != R_NONE)? C_REG : C_NONE;
    r = p->as;
    o = oprange[r].start;
    e = oprange[r].stop;
    <<[[oplook()]] sanity check o>>

    <<[[oplook()]] debug>>

    <<[[oplook()]] if use cache, part2>>
    else {
        for(; o<e; o++)
            if(o->a2 == a2)
             if(cmp(o->a1, a1))
              if(cmp(o->a3, a3)) {
                return o;
            }
    }
    <<[[oplook()]] illegal combination error>>
}
@
%pad: I rewrote this code to aspectize optimisations and have
% a simpler version available
% the order to cmp is right? I think so, see the comment about cmp().
% So middle operand must be equal! (but anyway usually a register)
% and rest must be compatible.




% cmp for compatible (not compare).
% 'b' is the actual class of the operand, 'a' is the one mentionned
% in optab which is actually compatible with a few concrete class.
% e.g. an optab entry for C_LCON will also accomodate concrete operand
% with class C_RCON or C_NCON, but if it's mentionned C_RCON in
% the optab, then it will accept only C_RCON concrete operands.
<<function cmp(arm)>>=
bool
cmp(int a, int b)
{

    if(a == b)
        return true;

    switch(a) {
    case C_LCON:
        if(b == C_RCON || b == C_NCON)
            return true;
        break;
    case C_LACON:
        if(b == C_RACON)
            return true;
        break;

    case C_HFEXT:
        return b == C_HEXT || b == C_FEXT;
    case C_FEXT:
    case C_HEXT:
        return b == C_HFEXT;
    case C_SEXT:
        return cmp(C_HFEXT, b);
    case C_LEXT:
        return cmp(C_SEXT, b);

    case C_HFAUTO:
        return b == C_HAUTO || b == C_FAUTO;
    case C_FAUTO:
    case C_HAUTO:
        return b == C_HFAUTO;
    case C_SAUTO:
        return cmp(C_HFAUTO, b);
    case C_LAUTO:
        return cmp(C_SAUTO, b);

    case C_HFOREG:
        return b == C_HOREG || b == C_FOREG;
    case C_FOREG:
    case C_HOREG:
        return b == C_HFOREG;
    case C_SROREG:
        return cmp(C_SOREG, b) || cmp(C_ROREG, b);
    case C_SOREG:
    case C_ROREG:
        return b == C_SROREG || cmp(C_HFOREG, b);
    case C_LOREG:
        return cmp(C_SROREG, b);

    }
    return false;
}
@
% diff with ocmp? subtle. this is compatibility but it does not
% car about the order of the operand classes. ocmp care about
% the order! because it does not return a boolean but a cmp_result.




<<[[oplook()]] sanity check o>>=
if(o == nil) {
    o = oprange[r].stop; /* just generate an error */
}
@

<<[[oplook()]] illegal combination error>>=
diag("illegal combination %A %d %d %d",  p->as, a1, a2, a3);
prasm(p);
if(o == nil)
    o = optab;
return o;
@


\subsection{Caching}
% Memoizing

<<[[Prog]] other fields>>=
// option<index-1-based in optab[]>, 0 means None, i means index optab[i-1]
byte	optab;
@
% cache so second call to oplook() in asmb() is faster I think

<<[[Adr]] other fields>>=
// option<enum<Classx>>, 0 means None, i means i-1 is the class you want
short	class;
@
%a more precise Adr.type
%old: was char, but ugly
%usually the class is computed via aclass() and used as an index
% in the optab complex structure. 
% Not sure why it needs to be stored here in Adr too.

<<[[oplook()]] locals>>=
bool usecache = true;
char *c1, *c3;
@

<<[[oplook()]] if use cache, part1>>=
if(usecache) {
    a1 = p->optab;
    if(a1)
        return optab+(a1-1);
    
    a1 = p->from.class;
    if(a1 == C_NONE) {
        a1 = aclass(&p->from) + 1;
        p->from.class = a1;
    }
    a1--;
    
    a3 = p->to.class;
    if(a3 == C_NONE) {
        a3 = aclass(&p->to) + 1;
        p->to.class = a3;
    }
    a3--;
}
@

<<[[oplook()]] if use cache, part2>>=
if(usecache) {
    c1 = xcmp[a1];
    c3 = xcmp[a3];
    for(; o<e; o++)
        if(o->a2 == a2)
         if(c1[o->a1])
          if(c3[o->a3]) {
            p->optab = (o-optab)+1;
            return o;
        }
}
@

% cmp() cache for oplook()
<<global xcmp(arm)>>=
char	xcmp[C_GOK+1][C_GOK+1];
@

<<[[buildop()]] initialize xcmp cache>>=
for(i=0; i<C_GOK; i++)
    for(n=0; n<C_GOK; n++)
        xcmp[i][n] = cmp(n, i);
@
% subtle the order to cmp here, cmp(n,i) not cmp(i,n)



<<[[noops()]] case ARET, call nocache>>=
nocache(p);
@

<<function nocache(arm)>>=
void
nocache(Prog *p)
{
    p->optab = 0;
    p->from.class = 0;
    p->to.class = 0;
}
@
% disable cache for ARET because the instruction has actually changed!
% in noops we overwrite the ancien instruction, with p->as = ABL
% so we must force to recompute optab and aclass.
% not sure it's needed though since optab is used only in oplook()
% which is called only by span() and asmb() which are both called
% long after noops().






%/*
%void
%buildrep(int x, int as)
%{
%    Opcross *p;
%    Optab *e, *s, *o;
%    int a1, a2, a3, n;
%
%    if(C_NONE != 0 || C_REG != 1 || C_GOK >= 32 || x >= nelem(opcross)) {
%        diag("assumptions fail in buildrep");
%        errorexit();
%    }
%    repop[as] = x;
%    p = (opcross + x);
%    s = oprange[as].start;
%    e = oprange[as].stop;
%    for(o=e-1; o>=s; o--) {
%        n = o-optab;
%        for(a2=0; a2<2; a2++) {
%            if(a2) {
%                if(o->a2 == C_NONE)
%                    continue;
%            } else
%                if(o->a2 != C_NONE)
%                    continue;
%            for(a1=0; a1<32; a1++) {
%                if(!xcmp[a1][o->a1])
%                    continue;
%                for(a3=0; a3<32; a3++)
%                    if(xcmp[a3][o->a3])
%                        (*p)[a1][a2][a3] = n;
%            }
%        }
%    }
%    oprange[as].start = 0;
%}
%*/

% there was this in oplook() but I think it could not work
% if buildrep was not called
%    if(o == nil) {
%        a1 = opcross[repop[r]][a1][a2][a3];
%        if(a1) {
%            p->optab = a1+1;
%            return optab+a1;
%        }
%        o = oprange[r].stop; /* just generate an error */
%    }

%extern	uchar	repop[ALAST];
%
%<<global repop(arm)>>=
%uchar	repop[ALAST];
%@
%
%typedef	uchar	Opcross[32][2][32];
%
%extern	Opcross	opcross[8];
%
%<<global opcross(arm)>>=
%Opcross	opcross[8];
%@

\section{Text section, [[asmout()]]}
\label{sec:asmout}

<<function asmout(arm)>>=
/// main -> asmb -> <> (in a for loop over all instructions)
void
asmout(Prog *p, Optab *o)
{
    // ARM 32 bits instructions
    long o1, o2, o3, o4, o5, o6;
    // pc
    long v;
    // misc
    int r, rf, rt, rt2;
    Sym *s;

    <<[[asmout()]] initialisation>>
    o1 = o2 = o3 = o4 = o5 = o6 = 0;

    switch(o->type) {
    <<[[asmout()]] switch on type cases>>
    default:
        diag("unknown asm %d", o->type);
        prasm(p);
        break;
    }

    <<[[asmout()]] debug>>

    v = p->pc;
    switch(o->size) {
    <<[[asmout()]] switch on size cases>>
    }
}
@
%$




<<[[asmout()]] switch on size cases>>=
case 4:
    <<[[asmout()]] when 1 generated instruction, debug>>
    lputl(o1);
    break;
case 8:
    <<[[asmout()]] when 2 generated instructions, debug>>
    lputl(o1);
    lputl(o2);
    break;
case 12:
    <<[[asmout()]] when 3 generated instructions, debug>>
    lputl(o1);
    lputl(o2);
    lputl(o3);
    break;
case 16:
    <<[[asmout()]] when 4 generated instructions, debug>>
    lputl(o1);
    lputl(o2);
    lputl(o3);
    lputl(o4);
    break;
case 20:
    <<[[asmout()]] when 5 generated instructions, debug>>
    lputl(o1);
    lputl(o2);
    lputl(o3);
    lputl(o4);
    lputl(o5);
    break;
case 24:
    <<[[asmout()]] when 6 generated instructions, debug>>
    lputl(o1);
    lputl(o2);
    lputl(o3);
    lputl(o4);
    lputl(o5);
    lputl(o6);
    break;
default:
    <<[[asmout()]] when other size, debug>>
    break;
@



\subsection{[[ATEXT]]}

<<[[buildop()]] switch opcode r for ranges cases>>=
case ATEXT:
    break;
@


<<[[optab]] entries>>=
{ ATEXT,	C_LEXT,	C_NONE,	C_LCON, 	 0, 0, 0 },
{ ATEXT,	C_LEXT,	C_REG,	C_LCON, 	 0, 0, 0 },
@

<<[[asmout()]] switch on type cases>>=
case 0:		/* pseudo ops */
    break;
@
% nothing to be done! TEXT is a pseudo opcode, and noops()
% has patched it with the initial mov to save REGLINK in stack, so we're good
% to go.
% We kept it instead of sometimes replacing it when we could so have
% still curtext.

\subsection{[[AWORD]]}

% used for limitations of 5a, but also for addpool!
% to deal with the ARM constraints on range of immediate values, addresses.

<<[[buildop()]] switch opcode r for ranges cases>>=
case AWORD:
    break;
@

<<[[optab]] entries>>=
{ AWORD,	C_NONE,	C_NONE,	C_LCON,		11, 4, 0 },
{ AWORD,	C_NONE,	C_NONE,	C_LEXT,		11, 4, 0 },
@
% remember LCON inherits everything, so might be a RCON or NCON
%  but does not matter, instoffset the same and equal to x->to.offset!
%less: WORD foo;  what does it mean?
% WORD $foo; ok, I get it, and it should be a C_LCON

<<[[asmout()]] switch on type cases>>=
case 11:	/* word */
    switch(aclass(&p->to)) {
    <<[[asmout()]] on WORD case, switch class cases>>
    }
    o1 = instoffset;
    break;
@


\subsection{Arithmetic and logic opcodes}

<<[[buildop()]] switch opcode r for ranges cases>>=
case AADD:
    oprange[AAND] = oprange[r];
    oprange[AEOR] = oprange[r];
    oprange[AORR] = oprange[r];

    oprange[ABIC] = oprange[r];
    oprange[ASUB] = oprange[r];
    oprange[ARSB] = oprange[r];
    oprange[AADC] = oprange[r];
    oprange[ASBC] = oprange[r];
    oprange[ARSC] = oprange[r];
    break;
@

<<[[buildop()]] switch opcode r for ranges cases>>=
case ACMP:
    oprange[ATST] = oprange[r];
    oprange[ATEQ] = oprange[r];
    oprange[ACMN] = oprange[r];
    break;
@

<<[[buildop()]] switch opcode r for ranges cases>>=
case AMVN:
    break;
@

<<[[buildop()]] switch opcode r for ranges cases>>=
case AMOVW:
case AMOVB:
case AMOVBU:
case AMOVH:
case AMOVHU:
    break;
@
% mov put here because many mov are simple and involve
% just setting registers, as in MOV $1, R0



%Logic, add/sub, comparisons, simple movs

%toc:
% divide by shape of operands more than kinds of operation,
% so different sections than in Assembler.

\subsubsection{Registers only}

<<[[optab]] entries>>=
{ AADD,		C_REG,	C_REG,	C_REG,		 1, 4, 0 },
{ AADD,		C_REG,	C_NONE,	C_REG,		 1, 4, 0 },

{ AMOVW,	C_REG,	C_NONE,	C_REG,		 1, 4, 0 },
{ AMVN,		C_REG,	C_NONE,	C_REG,		 1, 4, 0 },
{ ACMP,		C_REG,	C_REG,	C_NONE,		 1, 4, 0 },
@



<<[[asmout()]] switch on type cases>>=
case 1:		/* op R,[R],R */
    o1 = oprrr(p->as, p->scond);
    rf = p->from.reg;
    rt = p->to.reg;
    r = p->reg;
    <<[[asmout()]] adjust r and rt>>
    o1 |= rf | (r<<16) | (rt<<12);
    break;
@
% >> >>
% rf(from) -> rm, r -> rn, rt(to) -> rd(dest) ->  in refcard term.

% the assembler allows some sugar e.g. ADD X1, X2 is really
% ADD X1, X2, X2, so this code handles this sugar.
<<[[asmout()]] adjust r and rt>>=
if(p->to.type == D_NONE)
    rt = 0;
if(p->as == AMOVW || p->as == AMVN)
    r = 0;
else if(r == R_NONE) // ADD FROM, TO ==> ADD FROM, TO, TO
    r = rt;
@
% hence the MOV X, R0, Y  where R0 is weird.

<<function oprrr(arm)>>=
long
oprrr(int a, int sc)
{
    long o;

    o = (sc & C_SCOND) << 28;
    if(sc & C_SBIT)
        o |= 1 << 20;
    if(sc & (C_PBIT|C_WBIT))
        diag(".P/.W on dp instruction");

    switch(a) {
    case AAND:	return o | (0x0<<21);
    case AEOR:	return o | (0x1<<21);
    case ASUB:	return o | (0x2<<21);
    case ARSB:	return o | (0x3<<21);
    case AADD:	return o | (0x4<<21);
    case AADC:	return o | (0x5<<21);
    case ASBC:	return o | (0x6<<21);
    case ARSC:	return o | (0x7<<21);
    case ATST:	return o | (0x8<<21) | (1<<20);
    case ATEQ:	return o | (0x9<<21) | (1<<20);
    case ACMP:	return o | (0xa<<21) | (1<<20);
    case ACMN:	return o | (0xb<<21) | (1<<20);
    case AORR:	return o | (0xc<<21);
    case AMOVW:	return o | (0xd<<21);
    case ABIC:	return o | (0xe<<21);
    case AMVN:	return o | (0xf<<21);

    <<[[oprrr()]] switch cases>>
    }
    diag("bad rrr %d", a);
    prasm(curp);
    return 0;
}
@
% >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >>
% >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >>
% >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >>
% >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >>



\subsubsection{Simple immediate constant}

<<[[optab]] entries>>=
{ AADD,		C_RCON,	C_REG,	C_REG,		 2, 4, 0 },
{ AADD,		C_RCON,	C_NONE,	C_REG,		 2, 4, 0 },

{ AMOVW,	C_RCON,	C_NONE,	C_REG,		 2, 4, 0 },
{ AMVN,		C_RCON,	C_NONE,	C_REG,		 2, 4, 0 },
{ ACMP,		C_RCON,	C_REG,	C_NONE,		 2, 4, 0 },
@

<<[[asmout()]] switch on type cases>>=
case 2:		/* op $I,[R],R */
    aclass(&p->from);
    o1 = oprrr(p->as, p->scond);
    o1 |= immrot(instoffset);
    rt = p->to.reg;
    r = p->reg;
    <<[[asmout()]] adjust r and rt>>
    o1 |= (r<<16) | (rt<<12);
    break;
@
%$
%pad: the comment was about movbu, but it was wrong I think


\subsubsection{Long immediate constant and pool}
\label{sec:add-regtmp}


<<[[optab]] entries>>=
{ AMOVW,	C_NCON,	C_NONE,	C_REG,		12, 4, 0 },
{ AMOVW,	C_LCON,	C_NONE,	C_REG,		12, 4, 0,	LFROM },
@

% used also for $setR12(SB)? 
% this instr take 4 bytes, but it is using a Pool! but omvl does not
% look it is using the Pool ... how it works?

<<[[asmout()]] switch on type cases>>=
case 12:	/* movw $lcon, reg */
    o1 = omvl(p, &p->from, p->to.reg);
    break;
@
%$

<<[[optab]] entries>>=
{ AADD,		C_NCON,	C_REG,	C_REG,		13, 8, 0 },
{ AADD,		C_NCON,	C_NONE,	C_REG,		13, 8, 0 },
{ AMVN,		C_NCON,	C_NONE,	C_REG,		13, 8, 0 },
{ ACMP,		C_NCON,	C_REG,	C_NONE,		13, 8, 0 },

{ AADD,		C_LCON,	C_REG,	C_REG,		13, 8, 0,	LFROM },
{ AADD,		C_LCON,	C_NONE,	C_REG,		13, 8, 0,	LFROM },
{ AMVN,		C_LCON,	C_NONE,	C_REG,		13, 8, 0,	LFROM },
{ ACMP,		C_LCON,	C_REG,	C_NONE,		13, 8, 0,	LFROM },
@
% the general case for big constants

% have already some simple movs before
% here are a few more






<<[[asmout()]] switch on type cases>>=
case 13:	/* op $lcon, [R], R */
    o1 = omvl(p, &p->from, REGTMP);
    if(!o1)
        break;
    o2 = oprrr(p->as, p->scond);
    o2 |= REGTMP;
    r = p->reg;
    if(p->as == AMOVW || p->as == AMVN)
        r = 0;
    else if(r == R_NONE)
        r = p->to.reg;
    o2 |= r << 16;
    if(p->to.type != D_NONE)
        o2 |= p->to.reg << 12;
    break;
@
%$

<<function omvl(arm)>>=
long
omvl(Prog *p, Adr *a, int dr)
{	
    long v, o1;
    if(!p->cond) {
        aclass(a);
        v = immrot(~instoffset);
        if(v == 0) {
            diag("missing literal");
            prasm(p);
            return 0;
        }
        o1 = oprrr(AMVN, p->scond&C_SCOND);
        o1 |= v;
        o1 |= dr << 12;
    } else {
        v = p->cond->pc - p->pc - 8;
        o1 = olr(v, REGPC, dr, p->scond&C_SCOND);
    }
    return o1;
}
@
% >> >> >>
%less: can have p->cond because called for basic arith op and also
% for BL ops?


\subsubsection{Registers-only subword MOVs}

<<[[optab]] entries>>=
{ AMOVB,	C_REG,	C_NONE,	C_REG,		14, 8, 0 },
{ AMOVBU,	C_REG,	C_NONE,	C_REG,		58, 4, 0 },
{ AMOVH,	C_REG,	C_NONE,	C_REG,		14, 8, 0 },
{ AMOVHU,	C_REG,	C_NONE,	C_REG,		14, 8, 0 },
@

<<[[asmout()]] switch on type cases>>=
case 14:	/* movb/movbu/movh/movhu R,R */
    o1 = oprrr(ASLL, p->scond);

    if(p->as == AMOVBU || p->as == AMOVHU)
        o2 = oprrr(ASRL, p->scond);
    else
        o2 = oprrr(ASRA, p->scond);

    r = p->to.reg;
    o1 |= (p->from.reg)|(r<<12);
    o2 |= (r)|(r<<12);
    if(p->as == AMOVB || p->as == AMOVBU) {
        o1 |= (24<<7);
        o2 |= (24<<7);
    } else {
        o1 |= (16<<7);
        o2 |= (16<<7);
    }
    break;
@
% >> >> >> >> >> >> >>

<<[[asmout()]] switch on type cases>>=
case 58:	/* movbu R,R */
    o1 = oprrr(AAND, p->scond);
    o1 |= immrot(0xff);
    rt = p->to.reg;
    r = p->from.reg;
    if(p->to.type == D_NONE)
        rt = 0;
    if(r == R_NONE)
        r = rt;
    o1 |= (r<<16) | (rt<<12);
    break;
@
% >> >>



\subsubsection{Bit-shifted register}

<<[[optab]] entries>>=
{ AADD,		C_SHIFT,C_REG,	C_REG,		 3, 4, 0 },
{ AADD,		C_SHIFT,C_NONE,	C_REG,		 3, 4, 0 },

{ AMVN,		C_SHIFT,C_NONE,	C_REG,		 3, 4, 0 },
{ ACMP,		C_SHIFT,C_REG,	C_NONE,		 3, 4, 0 },
@

<<[[asmout()]] switch on type cases>>=
case 3:		/* op R<<[IR],[R],R */
mov:
    aclass(&p->from);
    o1 = oprrr(p->as, p->scond);
    o1 |= p->from.offset;
    rt = p->to.reg;
    r = p->reg;
    <<[[asmout()]] adjust r and rt>>
    o1 |= (r<<16) | (rt<<12);
    break;
@
% >> >> >>
%pad: add -> op in the comment


\subsubsection{Bit-shift opcodes}

<<[[buildop()]] switch opcode r for ranges cases>>=
case ASLL:
    oprange[ASRL] = oprange[r];
    oprange[ASRA] = oprange[r];
    break;
@


<<[[optab]] entries>>=
{ ASLL,		C_RCON,	C_REG,	C_REG,		 8, 4, 0 },
{ ASLL,		C_RCON,	C_NONE,	C_REG,		 8, 4, 0 },
@


<<[[asmout()]] switch on type cases>>=
case 8:		/* sll $c,[R],R -> mov (R<<$c),R */
    aclass(&p->from);
    o1 = oprrr(p->as, p->scond);
    r = p->reg;
    if(r == R_NONE)
        r = p->to.reg;
    o1 |= r | ((instoffset&31) << 7) | (p->to.reg << 12);
    break;
@
%$
% >> >>

% 0xd is AMOV
<<[[oprrr()]] switch cases>>=
case ASLL:	return o | (0xd<<21) | (0<<5);
case ASRL:	return o | (0xd<<21) | (1<<5);
case ASRA:	return o | (0xd<<21) | (2<<5);
@
% >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >>
% >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >>

<<[[optab]] entries>>=
{ ASLL,		C_REG,	C_NONE,	C_REG,		 9, 4, 0 },
{ ASLL,		C_REG,	C_REG,	C_REG,		 9, 4, 0 },
@

<<[[asmout()]] switch on type cases>>=
case 9:		/* sll R,[R],R -> mov (R<<R),R */
    o1 = oprrr(p->as, p->scond);
    r = p->reg;
    if(r == R_NONE)
        r = p->to.reg;
    o1 |= r | ((p->from.reg << 8) | (1<<4)) | (p->to.reg << 12);
    break;
@
% >> >> >> >> 


\subsubsection{Multiplication}

<<[[buildop()]] switch opcode r for ranges cases>>=
case AMUL:
    oprange[AMULU] = oprange[r];
    break;
@

<<[[optab]] entries>>=
{ AMUL,		C_REG,	C_REG,	C_REG,		15, 4, 0 },
{ AMUL,		C_REG,	C_NONE,	C_REG,		15, 4, 0 },
@


<<[[asmout()]] switch on type cases>>=
case 15:	/* mul r,[r,]r */
    o1 = oprrr(p->as, p->scond);
    rf = p->from.reg;
    rt = p->to.reg;
    r = p->reg;
    if(r == R_NONE)
        r = rt;
    if(rt == r) {
        r = rf;
        rf = rt;
    }
    o1 |= (rf<<8) | r | (rt<<16);
    break;
@
% >> >> 
%old code
%    if(0)
%    if(rt == r || rf == REGPC || r == REGPC || rt == REGPC) {
%        diag("bad registers in MUL");
%        prasm(p);
%    }

<<[[oprrr()]] switch cases>>=
case AMULU:
case AMUL:	return o | (0x0<<21) | (0x9<<4);
@
% >> >>


\subsubsection{Long mulitplication}
% could be in advanced topic, like I did in Assembler.nw


<<[[buildop()]] switch opcode r for ranges cases>>=
case AMULL:
    oprange[AMULA] = oprange[r];
    oprange[AMULAL] = oprange[r];
    oprange[AMULLU] = oprange[r];
    oprange[AMULALU] = oprange[r];
    break;
@

<<[[optab]] entries>>=
{ AMULL,	C_REG,	C_REG,	C_REGREG,	17, 4, 0 },
@

<<[[asmout()]] switch on type cases>>=
case 17:
    o1 = oprrr(p->as, p->scond);
    rf = p->from.reg;
    rt = p->to.reg;
    rt2 = p->to.offset;
    r = p->reg;
    o1 |= (rf<<8) | r | (rt<<16) | (rt2<<12);
    break;
@
% >> >> >>

<<[[oprrr()]] switch cases>>=
case AMULA:	return o | (0x1<<21) | (0x9<<4);
case AMULLU:	return o | (0x4<<21) | (0x9<<4);
case AMULL:		return o | (0x6<<21) | (0x9<<4);
case AMULALU:	return o | (0x5<<21) | (0x9<<4);
case AMULAL:	return o | (0x7<<21) | (0x9<<4);
@
% >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >>
% >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >>




\subsection{Control flow opcodes}

<<[[buildop()]] switch opcode r for ranges cases>>=
case AB:
case ABL:
    break;
case ABEQ:
    oprange[ABNE] = oprange[r];
    oprange[ABHS] = oprange[r];
    oprange[ABLO] = oprange[r];
    oprange[ABMI] = oprange[r];
    oprange[ABPL] = oprange[r];
    oprange[ABVS] = oprange[r];
    oprange[ABVC] = oprange[r];
    oprange[ABHI] = oprange[r];
    oprange[ABLS] = oprange[r];
    oprange[ABGE] = oprange[r];
    oprange[ABLT] = oprange[r];
    oprange[ABGT] = oprange[r];
    oprange[ABLE] = oprange[r];
    break;
@

<<[[optab]] entries>>=
{ AB,		C_NONE,	C_NONE,	C_BRANCH,		 5, 4, 0,	LPOOL },
{ ABL,		C_NONE,	C_NONE,	C_BRANCH,		 5, 4, 0 },
{ ABEQ,		C_NONE,	C_NONE,	C_BRANCH,		 5, 4, 0 },
@


<<[[asmout()]] switch on type cases>>=
case 5:		/* bra s */
    <<[[asmout()]] BRA case, if undefined target>>
    else 
      if(p->cond != P)
        v = (p->cond->pc - pc) - 8;
      else 
        v = -8; // warning?
    o1 = opbra(p->as, p->scond);
    o1 |= (v >> 2) & 0xffffff;
    break;
@
% p->cond->pc !! hence the need for patch()! and span()
% and do -pc because it's relative, and do -8 because ARM
% does implicitly a +8 (see Machine.nw)

% can overflow? branch somewhere too far?

% why - 8? because stupid jump to stay where you are,
% and stupid go next as anyway it's next, (well would be a NOP at least)
% so B 0 actually jump 2 instrs. To loop forever need B - 8 ARM.
% This is why you need an assembler :)

<<function opbra(arm)>>=
long
opbra(int a, int sc)
{

    if(sc & (C_SBIT|C_PBIT|C_WBIT))
        diag(".S/.P/.W on bra instruction");
    sc &= C_SCOND;
    if(a == ABL)
        return (sc<<28)|(0x5<<25)|(0x1<<24);

    if(sc != 0xe)
        diag(".COND on bcond instruction");

    switch(a) {
    case ABEQ:	return (0x0<<28)|(0x5<<25);
    case ABNE:	return (0x1<<28)|(0x5<<25);
    case ABHS:	return (0x2<<28)|(0x5<<25);
    case ABLO:	return (0x3<<28)|(0x5<<25);
    case ABMI:	return (0x4<<28)|(0x5<<25);
    case ABPL:	return (0x5<<28)|(0x5<<25);
    case ABVS:	return (0x6<<28)|(0x5<<25);
    case ABVC:	return (0x7<<28)|(0x5<<25);
    case ABHI:	return (0x8<<28)|(0x5<<25);
    case ABLS:	return (0x9<<28)|(0x5<<25);
    case ABGE:	return (0xa<<28)|(0x5<<25);
    case ABLT:	return (0xb<<28)|(0x5<<25);
    case ABGT:	return (0xc<<28)|(0x5<<25);
    case ABLE:	return (0xd<<28)|(0x5<<25);
    case AB:	return (0xe<<28)|(0x5<<25);
    }
    diag("bad bra %A", a);
    prasm(curp);
    return 0;
}
@
% 
% >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >>
% >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >>





<<[[optab]] entries>>=
{ AB,		C_NONE,	C_NONE,	C_ROREG,	 6, 4, 0,	LPOOL },
{ ABL,		C_NONE,	C_NONE,	C_ROREG,	 7, 8, 0 },
@
% branch to indirect code!
% if it's a really big offset that is not immrot(), no code generation?

<<[[asmout()]] switch on type cases>>=
case 6:		/* b ,O(R) -> add $O,R,PC */
    aclass(&p->to);
    o1 = oprrr(AADD, p->scond);
    o1 |= immrot(instoffset);
    o1 |= (p->to.reg << 16) | (REGPC << 12);
    break;
@
%$

<<[[asmout()]] switch on type cases>>=
case 7:		/* bl ,O(R) -> mov PC,link; add $O,R,PC */
    aclass(&p->to);
    o1 = oprrr(AADD, p->scond);
    o1 |= immrot(0) | (REGPC << 16) | (REGLINK << 12);

    o2 = oprrr(AADD, p->scond);
    o2 |= immrot(instoffset) | (p->to.reg << 16) | (REGPC << 12);
    break;
@
%$
% could use AMOVW instead of AADD no?


\subsection{Memory opcodes}
% more complicated ... can generate up to 6 ARM instructions

\subsubsection{XXX}

% have seen the simple MOV before, which don't involve
% any dereference, but just a constant and a register
% or even sometimes just two registers.

<<[[optab]] entries>>=
{ AMOVW,	C_REG,	C_NONE,	C_SEXT,		20, 4, REGSB },
{ AMOVW,	C_REG,	C_NONE,	C_SAUTO,	20, 4, REGSP },
{ AMOVW,	C_REG,	C_NONE,	C_SOREG,	20, 4, 0 },
{ AMOVB,	C_REG,	C_NONE,	C_SEXT,		20, 4, REGSB },
{ AMOVB,	C_REG,	C_NONE,	C_SAUTO,	20, 4, REGSP },
{ AMOVB,	C_REG,	C_NONE,	C_SOREG,	20, 4, 0 },
{ AMOVBU,	C_REG,	C_NONE,	C_SEXT,		20, 4, REGSB },
{ AMOVBU,	C_REG,	C_NONE,	C_SAUTO,	20, 4, REGSP },
{ AMOVBU,	C_REG,	C_NONE,	C_SOREG,	20, 4, 0 },

{ AMOVW,	C_SEXT,	C_NONE,	C_REG,		21, 4, REGSB },
{ AMOVW,	C_SAUTO,C_NONE,	C_REG,		21, 4, REGSP },
{ AMOVW,	C_SOREG,C_NONE,	C_REG,		21, 4, 0 },
{ AMOVBU,	C_SEXT,	C_NONE,	C_REG,		21, 4, REGSB },
{ AMOVBU,	C_SAUTO,C_NONE,	C_REG,		21, 4, REGSP },
{ AMOVBU,	C_SOREG,C_NONE,	C_REG,		21, 4, 0 },

{ AMOVB,	C_SEXT,	C_NONE,	C_REG,		22, 12, REGSB },
{ AMOVB,	C_SAUTO,C_NONE,	C_REG,		22, 12, REGSP },
{ AMOVB,	C_SOREG,C_NONE,	C_REG,		22, 12, 0 },
{ AMOVH,	C_SEXT,	C_NONE,	C_REG,		22, 12, REGSB },
{ AMOVH,	C_SAUTO,C_NONE,	C_REG,		22, 12, REGSP },
{ AMOVH,	C_SOREG,C_NONE,	C_REG,		22, 12, 0 },
{ AMOVHU,	C_SEXT,	C_NONE,	C_REG,		22, 12, REGSB },
{ AMOVHU,	C_SAUTO,C_NONE,	C_REG,		22, 12, REGSP },
{ AMOVHU,	C_SOREG,C_NONE,	C_REG,		22, 12, 0 },

{ AMOVH,	C_REG,	C_NONE,	C_SEXT,		23, 12, REGSB },
{ AMOVH,	C_REG,	C_NONE,	C_SAUTO,	23, 12, REGSP },
{ AMOVH,	C_REG,	C_NONE,	C_SOREG,	23, 12, 0 },
{ AMOVHU,	C_REG,	C_NONE,	C_SEXT,		23, 12, REGSB },
{ AMOVHU,	C_REG,	C_NONE,	C_SAUTO,	23, 12, REGSP },
{ AMOVHU,	C_REG,	C_NONE,	C_SOREG,	23, 12, 0 },
@


<<[[asmout()]] switch on type cases>>=
case 20:	/* mov/movb/movbu R,O(R) */
    aclass(&p->to);
    r = p->to.reg;
    if(r == R_NONE)
        r = o->param;
    o1 = osr(p->as, p->from.reg, instoffset, r, p->scond);
    break;
@


<<[[asmout()]] switch on type cases>>=
case 21:	/* mov/movbu O(R),R -> lr */
    aclass(&p->from);
    r = p->from.reg;
    if(r == R_NONE)
        r = o->param;
    o1 = olr(instoffset, r, p->to.reg, p->scond);
    if(p->as != AMOVW)
        o1 |= 1<<22;
    break;
@


<<function olr(arm)>>=
long
olr(long v, int b, int r, int sc)
{
    long o;

    o = (sc & C_SCOND) << 28;
    if(sc & C_SBIT)
        diag(".S on LDR/STR instruction");
    if(!(sc & C_PBIT))
        o |= 1 << 24;
    if(!(sc & C_UBIT))
        o |= 1 << 23;
    if(sc & C_WBIT)
        o |= 1 << 21;
    o |= (0x1<<26) | (1<<20);
    if(v < 0) {
        v = -v;
        o ^= 1 << 23;
    }
    if(v >= (1<<12))
        diag("literal span too large: %ld (R%d)\n%P", v, b, PP);
    o |= v;
    o |= b << 16;
    o |= r << 12;
    return o;
}
@
% >> >> >> >> >> >> >> >> >> >>

<<global PP(arm)>>=
static Prog *PP;
@
% to communicate info to olr for better diagnostic

<<[[asmout()]] initialisation>>=
PP = p;
@






<<[[asmout()]] switch on type cases>>=
case 22:	/* movb/movh/movhu O(R),R -> lr,shl,shr */
    aclass(&p->from);
    r = p->from.reg;
    if(r == R_NONE)
        r = o->param;
    o1 = olr(instoffset, r, p->to.reg, p->scond);

    o2 = oprrr(ASLL, p->scond);
    o3 = oprrr(ASRA, p->scond);
    r = p->to.reg;
    if(p->as == AMOVB) {
        o2 |= (24<<7)|(r)|(r<<12);
        o3 |= (24<<7)|(r)|(r<<12);
    } else {
        o2 |= (16<<7)|(r)|(r<<12);
        if(p->as == AMOVHU)
            o3 = oprrr(ASRL, p->scond);
        o3 |= (16<<7)|(r)|(r<<12);
    }
    break;
@
<<[[asmout()]] switch on type cases>>=
case 23:	/* movh/movhu R,O(R) -> sb,sb */
    aclass(&p->to);
    r = p->to.reg;
    if(r == R_NONE)
        r = o->param;
    o1 = osr(AMOVH, p->from.reg, instoffset, r, p->scond);

    o2 = oprrr(ASRL, p->scond);
    o2 |= (8<<7)|(p->from.reg)|(REGTMP<<12);

    o3 = osr(AMOVH, REGTMP, instoffset+1, r, p->scond);
    break;
@



<<[[optab]] entries>>=
{ AMOVW,	C_REG,	C_NONE,	C_LEXT,		30, 8, REGSB,	LTO },
{ AMOVW,	C_REG,	C_NONE,	C_LAUTO,	30, 8, REGSP,	LTO },
{ AMOVW,	C_REG,	C_NONE,	C_LOREG,	30, 8, 0,	LTO },
{ AMOVB,	C_REG,	C_NONE,	C_LEXT,		30, 8, REGSB,	LTO },
{ AMOVB,	C_REG,	C_NONE,	C_LAUTO,	30, 8, REGSP,	LTO },
{ AMOVB,	C_REG,	C_NONE,	C_LOREG,	30, 8, 0,	LTO },
{ AMOVBU,	C_REG,	C_NONE,	C_LEXT,		30, 8, REGSB,	LTO },
{ AMOVBU,	C_REG,	C_NONE,	C_LAUTO,	30, 8, REGSP,	LTO },
{ AMOVBU,	C_REG,	C_NONE,	C_LOREG,	30, 8, 0,	LTO },
@

<<[[asmout()]] switch on type cases>>=
case 30:	/* mov/movb/movbu R,L(R) */
    o1 = omvl(p, &p->to, REGTMP);
    if(!o1)
        break;
    r = p->to.reg;
    if(r == R_NONE)
        r = o->param;
    o2 = osrr(p->from.reg, REGTMP,r, p->scond);
    if(p->as != AMOVW)
        o2 |= 1<<22;
    break;
@




<<[[optab]] entries>>=
{ AMOVW,	C_LEXT,	C_NONE,	C_REG,		31, 8, REGSB,	LFROM },
{ AMOVW,	C_LAUTO,C_NONE,	C_REG,		31, 8, REGSP,	LFROM },
{ AMOVW,	C_LOREG,C_NONE,	C_REG,		31, 8, 0,	LFROM },
{ AMOVBU,	C_LEXT,	C_NONE,	C_REG,		31, 8, REGSB,	LFROM },
{ AMOVBU,	C_LAUTO,C_NONE,	C_REG,		31, 8, REGSP,	LFROM },
{ AMOVBU,	C_LOREG,C_NONE,	C_REG,		31, 8, 0,	LFROM },

{ AMOVB,	C_LEXT,	C_NONE,	C_REG,		32, 16, REGSB,	LFROM },
{ AMOVB,	C_LAUTO,C_NONE,	C_REG,		32, 16, REGSP,	LFROM },
{ AMOVB,	C_LOREG,C_NONE,	C_REG,		32, 16, 0,	LFROM },
{ AMOVH,	C_LEXT,	C_NONE,	C_REG,		32, 16, REGSB,	LFROM },
{ AMOVH,	C_LAUTO,C_NONE,	C_REG,		32, 16, REGSP,	LFROM },
{ AMOVH,	C_LOREG,C_NONE,	C_REG,		32, 16, 0,	LFROM },
{ AMOVHU,	C_LEXT,	C_NONE,	C_REG,		32, 16, REGSB,	LFROM },
{ AMOVHU,	C_LAUTO,C_NONE,	C_REG,		32, 16, REGSP,	LFROM },
{ AMOVHU,	C_LOREG,C_NONE,	C_REG,		32, 16, 0,	LFROM },
@

<<[[asmout()]] switch on type cases>>=
case 31:	/* mov/movbu L(R),R -> lr[b] */
case 32:	/* movh/movb L(R),R -> lr[b] */
    o1 = omvl(p, &p->from, REGTMP);
    if(!o1)
        break;
    r = p->from.reg;
    if(r == R_NONE)
        r = o->param;
    o2 = olrr(REGTMP,r, p->to.reg, p->scond);
    if(p->as == AMOVBU || p->as == AMOVB)
        o2 |= 1<<22;
    if(o->type == 31)
        break;

    o3 = oprrr(ASLL, p->scond);

    if(p->as == AMOVBU || p->as == AMOVHU)
        o4 = oprrr(ASRL, p->scond);
    else
        o4 = oprrr(ASRA, p->scond);

    r = p->to.reg;
    o3 |= (r)|(r<<12);
    o4 |= (r)|(r<<12);
    if(p->as == AMOVB || p->as == AMOVBU) {
        o3 |= (24<<7);
        o4 |= (24<<7);
    } else {
        o3 |= (16<<7);
        o4 |= (16<<7);
    }
    break;
@


% 24 size ...
<<[[optab]] entries>>=
{ AMOVH,	C_REG,	C_NONE,	C_LEXT,		33, 24, REGSB,	LTO },
{ AMOVH,	C_REG,	C_NONE,	C_LAUTO,	33, 24, REGSP,	LTO },
{ AMOVH,	C_REG,	C_NONE,	C_LOREG,	33, 24, 0,	LTO },
{ AMOVHU,	C_REG,	C_NONE,	C_LEXT,		33, 24, REGSB,	LTO },
{ AMOVHU,	C_REG,	C_NONE,	C_LAUTO,	33, 24, REGSP,	LTO },
{ AMOVHU,	C_REG,	C_NONE,	C_LOREG,	33, 24, 0,	LTO },
@

<<[[asmout()]] switch on type cases>>=
case 33:	/* movh/movhu R,L(R) -> sb, sb */
    o1 = omvl(p, &p->to, REGTMP);
    if(!o1)
        break;
    r = p->to.reg;
    if(r == R_NONE)
        r = o->param;
    o2 = osrr(p->from.reg, REGTMP, r, p->scond);
    o2 |= (1<<22) ;

    o3 = oprrr(ASRL, p->scond);
    o3 |= (8<<7)|(p->from.reg)|(p->from.reg<<12);
    o3 |= (1<<6);	/* ROR 8 */

    o4 = oprrr(AADD, p->scond);
    o4 |= (REGTMP << 12) | (REGTMP << 16);
    o4 |= immrot(1);

    o5 = osrr(p->from.reg, REGTMP,r,p->scond);
    o5 |= (1<<22);

    o6 = oprrr(ASRL, p->scond);
    o6 |= (24<<7)|(p->from.reg)|(p->from.reg<<12);
    o6 |= (1<<6);	/* ROL 8 */

    break;
@




<<[[optab]] entries>>=
{ AMOVW,	C_LACON,C_NONE,	C_REG,		34, 8, REGSP,	LFROM },
@

<<[[asmout()]] switch on type cases>>=
case 34:	/* mov $lacon,R */
    o1 = omvl(p, &p->from, REGTMP);
    if(!o1)
        break;

    o2 = oprrr(AADD, p->scond);
    o2 |= REGTMP;
    r = p->from.reg;
    if(r == R_NONE)
        r = o->param;
    o2 |= r << 16;
    if(p->to.type != D_NONE)
        o2 |= p->to.reg << 12;
    break;
@
%$


<<[[optab]] entries>>=
{ AMOVW,	C_PSR,	C_NONE,	C_REG,		35, 4, 0 },
{ AMOVW,	C_REG,	C_NONE,	C_PSR,		36, 4, 0 },
{ AMOVW,	C_RCON,	C_NONE,	C_PSR,		37, 4, 0 },
@

<<[[asmout()]] switch on type cases>>=
case 35:	/* mov PSR,R */
    o1 = (2<<23) | (0xf<<16) | (0<<0);
    o1 |= (p->scond & C_SCOND) << 28;
    o1 |= (p->from.reg & 1) << 22;
    o1 |= p->to.reg << 12;
    break;
@
<<[[asmout()]] switch on type cases>>=
case 36:	/* mov R,PSR */
    o1 = (2<<23) | (0x29f<<12) | (0<<4);
    if(p->scond & C_FBIT)
        o1 ^= 0x010 << 12;
    o1 |= (p->scond & C_SCOND) << 28;
    o1 |= (p->to.reg & 1) << 22;
    o1 |= p->from.reg << 0;
    break;
@
<<[[asmout()]] switch on type cases>>=
case 37:	/* mov $con,PSR */
    aclass(&p->from);
    o1 = (2<<23) | (0x29f<<12) | (0<<4);
    if(p->scond & C_FBIT)
        o1 ^= 0x010 << 12;
    o1 |= (p->scond & C_SCOND) << 28;
    o1 |= immrot(instoffset);
    o1 |= (p->to.reg & 1) << 22;
    o1 |= p->from.reg << 0;
    break;
@
%$


<<[[optab]] entries>>=
{ AMOVW,	C_SHIFT,C_NONE,	C_REG,		59, 4, 0 },
{ AMOVBU,	C_SHIFT,C_NONE,	C_REG,		59, 4, 0 },

{ AMOVB,	C_SHIFT,C_NONE,	C_REG,		60, 4, 0 },

{ AMOVW,	C_REG,	C_NONE,	C_SHIFT,	61, 4, 0 },
{ AMOVB,	C_REG,	C_NONE,	C_SHIFT,	61, 4, 0 },
{ AMOVBU,	C_REG,	C_NONE,	C_SHIFT,	61, 4, 0 },
@

<<[[asmout()]] switch on type cases>>=
case 59:	/* movw/bu R<<I(R),R -> ldr indexed */
    if(p->from.reg == R_NONE) {
        if(p->as != AMOVW)
            diag("byte MOV from shifter operand");
        goto mov;
    }
    if(p->from.offset&(1<<4))
        diag("bad shift in LDR");
    o1 = olrr(p->from.offset, p->from.reg, p->to.reg, p->scond);
    if(p->as == AMOVBU)
        o1 |= 1<<22;
    break;
@
% >> >> >>


<<[[asmout()]] switch on type cases>>=
case 60:	/* movb R(R),R -> ldrsb indexed */
    if(p->from.reg == R_NONE) {
        diag("byte MOV from shifter operand");
        goto mov;
    }
    if(p->from.offset&(~0xf))
        diag("bad shift in LDRSB");
    o1 = olhrr(p->from.offset, p->from.reg, p->to.reg, p->scond);
    o1 ^= (1<<5)|(1<<6);
    break;
@
% >> >> 

<<[[asmout()]] switch on type cases>>=
case 61:	/* movw/b/bu R,R<<[IR](R) -> str indexed */
    if(p->to.reg == R_NONE)
        diag("MOV to shifter operand");
    o1 = osrr(p->from.reg, p->to.offset, p->to.reg, p->scond);
    if(p->as == AMOVB || p->as == AMOVBU)
        o1 |= 1<<22;
    break;
@
% >> >>





<<[[buildop()]] switch opcode r for ranges cases>>=
case ASWPW:
    oprange[ASWPBU] = oprange[r];
    break;
@

<<[[optab]] entries>>=
{ ASWPW,	C_SOREG,C_REG,	C_REG,		40, 4, 0 },
@


<<[[asmout()]] switch on type cases>>=
case 40:	/* swp oreg,reg,reg */
    aclass(&p->from);
    if(instoffset != 0)
        diag("offset must be zero in SWP");
    o1 = (0x2<<23) | (0x9<<4);
    if(p->as != ASWPW)
        o1 |= 1 << 22;
    o1 |= p->from.reg << 16;
    o1 |= p->reg << 0;
    o1 |= p->to.reg << 12;
    o1 |= (p->scond & C_SCOND) << 28;
    break;
@
% >> >> >> >> >> >> >>

\subsubsection{Symbol addresses}

% the MOV opcodes with size 4 which are simple, simple load or store
<<[[optab]] entries>>=
{ AMOVW,	C_RECON,C_NONE,	C_REG,		 4, 4, REGSB },
{ AMOVW,	C_RACON,C_NONE,	C_REG,		 4, 4, REGSP },
@

<<[[asmout()]] switch on type cases>>=
case 4:		/* add $I,[R],R */
    aclass(&p->from);
    o1 = oprrr(AADD, p->scond);
    o1 |= immrot(instoffset);
    r = p->from.reg;
    if(r == R_NONE)
        r = o->param;
    o1 |= (r << 16) | (p->to.reg << 12);
    break;
@
%$
% add in comment?

% otherwise C_LCON path, which use pool and load pointer from pool.

\subsection{Software interrupt opcodes}

<<[[buildop()]] switch opcode r for ranges cases>>=
case ASWI:
case ARFE:
    break;
@


<<[[optab]] entries>>=
{ ASWI,		C_NONE,	C_NONE,	C_NONE,		10, 4, 0 },
{ ASWI,		C_NONE,	C_NONE,	C_LCON,		10, 4, 0 },
{ ASWI,		C_NONE,	C_NONE,	C_LOREG,	10, 4, 0 },
@
%pad: I added the entry for LCON to allow SWI $0 which make more sense to me
% than SWI 0 which was used in 9syscall/mkfile originally
%old: I used to comment the LOREG entry because SWI was not having
% any argument in Assembler.nw, but now it has back an argument so
% I put it back.

<<[[asmout()]] switch on type cases>>=
case 10:	/* swi [$con] */
    o1 = oprrr(p->as, p->scond);
    if(p->to.type != D_NONE) {
        aclass(&p->to);
        o1 |= instoffset & 0xffffff;
    }
    break;
@
%$

<<[[oprrr()]] switch cases>>=
case ASWI:	return o | (0xf<<24);
@
% >> 


<<[[optab]] entries>>=
{ ARFE,		C_NONE,	C_NONE,	C_NONE,		41, 4, 0 },
@
%emulator:
% there is no RFE in Machine.nw because all the system
% code is proxied, and so there is no assembly system code to emulate

<<[[asmout()]] switch on type cases>>=
case 41:	/* rfe -> movm.s.w.u 0(r13),[r15] */
    o1 = 0xe8fd8000;
    break;
@
% .s? .w? .u?
% r13 = REGSP


\section{Data section, [[datblk()]]}
\label{sec:datblk}

<<constant Dbufslop>>=
#define	Dbufslop	100
@
% ? slop?

% use buf.dbuf, from union Buf. See appendix.

%sstring is bool used when call datblk for generating strings in text segment
<<function datblk(arm)>>=
void
datblk(long s, long n, bool sstring)
{
    Prog *p;
    long a, l;
    int i, c;
    <<[[datblk()]] other locals>>

    memset(buf.dbuf, 0, n+Dbufslop);

    for(p = datap; p != P; p = p->link) {

        if(sstring != (p->from.sym->type == SSTRING))
            continue;

        curp = p;

        a = p->from.sym->value + p->from.offset;
        l = a - s;
        c = p->reg;
        i = 0;
        if(l < 0) {
            if(l+c <= 0)
                continue;
            while(l < 0) {
                l++;
                i++;
            }
        }
        if(l >= n)
            continue;

        <<[[datblk()]] sanity check multiple initialization>>

        switch(p->to.type) {
        <<[[datblk()]] switch type of destination cases>>
        default:
            diag("unknown mode in initialization%P", p);
            break;
        }
    }
    write(cout, buf.dbuf, n);
}
@

<<[[datblk()]] other locals>>=
long j;
@

<<[[datblk()]] sanity check multiple initialization>>=
if(p->as != AINIT && p->as != ADYNT) {
    for(j=l+(c-i)-1; j>=l; j--)
        if(buf.dbuf[j]) {
            print("%P\n", p);
            diag("multiple initialization");
            break;
        }
}
@

<<[[datblk()]] switch type of destination cases>>=
case D_SCONST:
    for(; i<c; i++) {
        buf.dbuf[l] = p->to.sval[i];
        l++;
    }
    break;
@


<<[[datblk()]] other locals>>=
Sym *v;
char *cast;
long d;
@

<<[[datblk()]] switch type of destination cases>>=
case D_CONST:
    d = p->to.offset;
    v = p->to.sym;
    if(v) {
        switch(v->type) {
        case SUNDEF:
            ckoff(v, d);
        case STEXT: case SSTRING:
            d += p->to.sym->value;
            break;
        case SDATA:
        case SBSS:
            d += p->to.sym->value + INITDAT;
        }
        <<[[datblk()]] if dynamic module(arm)>>
    }
    cast = (char*)&d;

    switch(c) {
    case 1:
        for(; i<c; i++) {
            buf.dbuf[l] = cast[inuxi1[i]];
            l++;
        }
        break;
    case 2:
        for(; i<c; i++) {
            buf.dbuf[l] = cast[inuxi2[i]];
            l++;
        }
        break;
    case 4:
        for(; i<c; i++) {
            buf.dbuf[l] = cast[inuxi4[i]];
            l++;
        }
        break;

    default:
        diag("bad nuxi %d %d%P", c, i, curp);
        break;
    }
    break;
@
%old: case SLEAF: 



<<function ckoff>>=
void
ckoff(Sym *s, long v)
{
    if(v < 0 || v >= 1<<Roffset)
        diag("relocation offset %ld for %s out of range", v, s->name);
}
@

% >>


\subsection{Endianess, [[nuxiinit()]]}

%"unix" in some systems is represented as "nuxi" because of endianess

<<global inuxi1>>=
char	inuxi1[1];
@

<<global inuxi2>>=
char	inuxi2[2];
@

<<global inuxi4>>=
char	inuxi4[4];
@


<<global fnuxi4>>=
char	fnuxi4[4];
@

<<global fnuxi8>>=
char	fnuxi8[8];
@


<<[[main()]] initialize globals(arm)>>=
nuxiinit(); // ???
@

<<function nuxiinit(arm)>>=
void
nuxiinit(void)
{

    int i, c;

    for(i=0; i<4; i++) {
        c = find1(0x04030201L, i+1);
        if(i < 2)
            inuxi2[i] = c;
        if(i < 1)
            inuxi1[i] = c;
        inuxi4[i] = c;
        fnuxi4[i] = c;

        if(debug['d'] == 0){
            fnuxi8[i] = c;
            fnuxi8[i+4] = c+4;
        }
        else{
            fnuxi8[i] = c+4;		/* ms word first, then ls, even in little endian mode */
            fnuxi8[i+4] = c;
        }
    }

    if(debug['v']) {
        Bprint(&bso, "inuxi = ");
        for(i=0; i<1; i++)
            Bprint(&bso, "%d", inuxi1[i]);
        Bprint(&bso, " ");
        for(i=0; i<2; i++)
            Bprint(&bso, "%d", inuxi2[i]);
        Bprint(&bso, " ");
        for(i=0; i<4; i++)
            Bprint(&bso, "%d", inuxi4[i]);
        Bprint(&bso, "\nfnuxi = ");
        for(i=0; i<4; i++)
            Bprint(&bso, "%d", fnuxi4[i]);
        Bprint(&bso, " ");
        for(i=0; i<8; i++)
            Bprint(&bso, "%d", fnuxi8[i]);
        Bprint(&bso, "\n");
    }
    Bflush(&bso);
}
@




<<function find1>>=
int
find1(long l, int c)
{
    char *p;
    int i;

    p = (char*)&l;
    for(i=0; i<4; i++)
        if(*p++ == c)
            return i;
    return 0;
}
@












\chapter{Debugging Support}
\label{chap:debugging}

% Symbol Tables.
% related to import/export table? I don't think so.

% cooperation of 5a, 5c, and now last piece: 5l.

% But then db has awesome information!
% in db doing $C  dumps the stacktrace with parameters values! and locals!
%  ex:
%  caml_main(argv=...) /home/pad/../main.c called from main+f (/home/pad/...)
%    caml_main.raise_buf/ 0x1
%    caml_main.pos/ 0x0
%    caml_main.trail/ 0x4cf2c
%    ...
%  main(argv=...) /home/pad/.../main.c called from _main+26 (.../main9.s:12)


<<[[asmb()]] symbol and line table sections>>=
// modified by asmsym()
symsize = 0;
// modified by asmlc()
lcsize = 0;

if(!debug['s']) {
    switch(HEADTYPE) {
    case H_PLAN9:
        OFFSET = HEADR+textsize+datsize;
        seek(cout, OFFSET, SEEK__START);
        break;
    <<[[asmb()]] switch HEADTYPE (for symbol table generation) cases(arm)>>
    }

    DBG("%5.2f sym\n", cputime());
    asmsym();

    DBG("%5.2f pc\n", cputime());
    asmlc();

    <<[[asmb()]] if dynamic module, call asmdyn()>>

    cflush();
}
else {
    <<[[asmb()]] if dynamic module and no symbol table generation>>
}
@
% say -s = strip? say see strip in appendix?



\section{Executable symbol table, [[asmsym()]]}

% have seen object file symbol table, and also symbol table of 5l in memory,
% now executable symbol table.
% but here really just for debugging (or for dyn linking too?)

<<global symsize>>=
long	symsize;
@
% for the a.out.h header



% FIGURE? with format?


<<function asmsym(arm)>>=
/// main -> asmb -> <>
void
asmsym(void)
{
    Prog *p;
    Auto *a;
    Sym *s;
    int h;

    s = lookup("etext", 0);
    if(s->type == STEXT)
        putsymb(s->name, 'T', s->value, s->version);

    for(h=0; h<NHASH; h++)
        for(s=hash[h]; s!=S; s=s->link)
            switch(s->type) {
            case SDATA:
                putsymb(s->name, 'D', s->value+INITDAT, s->version);
                continue;
            case SBSS:
                putsymb(s->name, 'B', s->value+INITDAT, s->version);
                continue;

            case SCONST:
                putsymb(s->name, 'D', s->value, s->version);
                continue;
            case SSTRING:
                putsymb(s->name, 'T', s->value, s->version);
                continue;

            case SFILE:
                putsymb(s->name, 'f', s->value, s->version);
                continue;
            }

    for(p=textp; p!=P; p=p->cond) {
        s = p->from.sym;
        if(s->type == STEXT) {
            /* filenames first */
            <<[[asmsym()]] call putsymb for filenames>>
            
            if(p->mark & LEAF)
                putsymb(s->name, 'L', s->value, s->version);
            else
                putsymb(s->name, 'T', s->value, s->version);

            <<[[asmsym()]] frame symbols>>
        }
    }
    if(debug['v'] || debug['n']) {
        Bprint(&bso, "symsize = %lud\n", symsize);
        Bflush(&bso);
    }
}
@
%old: 
% || s->type == SLEAF
%            if(s->type == STEXT)
%                putsymb(s->name, 'T', s->value, s->version);
%            else // SLEAF
%                putsymb(s->name, 'L', s->value, s->version);



<<function putsymb>>=
void
putsymb(char *s, int t, long v, int ver)
{
    int i, f;

    if(t == 'f')
        s++;

    lput(v);
    if(ver)
        t += 'a' - 'A';
    cput(t+0x80);			/* 0x80 is variable length */

    <<[[putsymb()]] if z or Z>>
    else {
        for(i=0; s[i]; i++)
            cput(s[i]);
        cput('\0');
    }
    symsize += 4 + 1 + i + 1;

    <<[[putsymb()]] debug>>
}
@
%>>

\section{Stack variables symbols}
\l frame?

%trans:
% few other things done by ldobj(), regarding stack variables,
% which will be used later? by what? resolving? generation?

% nm helloc actually does not show everything,
% the 'f', 'p', and so are not shown by nm apparently.
% try 5l -n -o helloc helloc.5

%5l -n ...
%T 000011d0 atexit
%m 0000000c .frame
%a 00000004 i
%p 00000000 f

\subsection{[[Auto]]}

Operands involving parameters and local variables, 
which are really variables both stored in the {\em stack},
also known as {\em automatic variables}.
% Text keep track all of them in
use the [[autom]] field.

<<[[Adr]] other fields>>=
// list<ref_own<Auto> (next = Auto.link), only used by TEXT instruction
Auto*	autom;
@
%old:
%   union {
%       // ref<Sym> of hash
%       Sym*	sym;
%       // list<ref_own<Auto> (next = Auto.link)
%       Auto*	autom;
%   };
% but really stupid opti that makes code harder to read and
% less identical to Operand type of 5a
\l rename autom and Auto
\n autom because auto is a reserved keyword? but nothing to do with automata
\l maybe better to rename local_or_param




The [[Auto]] structure is used to keep track of all the parameters
and locals accessed by a procedure:

<<struct Auto(arm)>>=
struct	Auto
{
    // enum<Sym_kind> (N_LOCAL or N_PARAM only)
    short	type;

    // <ref<Sym>
    Sym*	asym;
    long	aoffset;

    // Extra
    <<[[Auto]] extra fields>>
};
@
\t rename Var?
\l aoffset is a repeat of the offset of the operand?

Those stack variables are chained together:

<<[[Auto]] extra fields>>=
// list<ref_own<Auto> (head = curauto = Instr.to.autom of TEXT instruction)
Auto*	link;
@


\subsection{[[curauto]]}

% another global for set of stack variables

% parameters + locals list
<<global curauto>>=
// list<ref<Auto>> (next = Auto.link)
Auto*	curauto;
@
% set for the first time where? bug? should be = nil?



% put example of instruction.
% put example of multiple instruction with same parameter.

<<[[inopd()]] other locals>>=
int t, l;
Sym *s;
Auto *u;
@
%old: t was i, but t(ype) better than i


<<[[inopd()]] adjust curauto for N_LOCAL or N_PARAM symkind>>=
s = a->sym;
t = a->symkind;
l = a->offset;

// a parameter or local with a symbol, e.g. p+0(FP)
if(s != S && (t == N_LOCAL || t == N_PARAM)) {

    for(u=curauto; u; u=u->link)
        if(u->asym == s)
         if(u->type == t) {
            if(u->aoffset > l)
                u->aoffset = l; // diag()? inconcistent offset?
            return size;
        }
    // else
    
    u = malloc(sizeof(Auto));
    u->asym = s;
    u->type = t;
    u->aoffset = l;
    
    //add_list(u, curauto)
    u->link = curauto;
    curauto = u;
}
@
%old: was
% if(s == S || (t != N_LOCAL && t != N_PARAM))
%    return size;
% but anyway has return size after




<<[[ldobj()]] case AEND, curauto adjustments>>=
if(curtext != P)
    curtext->to.autom = curauto;
curauto = nil;
@

<<[[ldobj()]] case ATEXT, if curtext not null adjustments for curauto>>=
if(curtext != P) {
    <<[[ldobj()]] case ATEXT, curauto adjustments with curhist>>
    curtext->to.autom = curauto;
    curauto = nil;
}
@


\subsection{Frame symbols}

<<[[asmsym()]] frame symbols>>=
/* frame, auto and param after */
putsymb(".frame", 'm', p->to.offset+4, 0);
for(a=p->to.autom; a; a=a->link)
    if(a->type == N_LOCAL)
        putsymb(a->asym->name, 'a', -a->aoffset, 0);
    else
    if(a->type == N_PARAM)
        putsymb(a->asym->name, 'p', a->aoffset, 0);
@


\section{File and line information in objects, [[AHISTORY]]}
\label{sec:lineno}

% say chapter in \book{Assembler}. global line number after
% preprocessing.

% tracing origin??


<<global histfrog>>=
Sym*	histfrog[MAXHIST];
@

<<constant MAXHIST>>=
MAXHIST		= 20,	/* limit of path elements for history symbols */
@

<<global histfrogp>>=
int	histfrogp;
@





% used by what? for debugging? when signature conflict! to print
% current filenames in conflict


<<[[ldobj()]] after newloop when new object file, more initializations>>=
histfrogp = 0;
@


% pn? filename of object file, but addlib() really abuse histgrog global
<<[[ldobj()]] switch opcode cases(arm)>>=
case AHISTORY:
    if(p->to.offset == -1) {
        addlib(pn);
        histfrogp = 0;
        goto loop;
    }

    addhist(p->line, D_FILE);		/* 'z' */
    if(p->to.offset)
        addhist(p->to.offset, D_FILE1);	/* 'Z' */
    histfrogp = 0;
    goto loop;
@

<<function addhist>>=
void
addhist(long line, int type)
{
    Auto *u;
    Sym *s;
    int i, j, k;

    s = malloc(sizeof(Sym));
    s->name = malloc(2*(histfrogp+1) + 1);

    u = malloc(sizeof(Auto));
    u->asym = s;
    u->type = type;
    u->aoffset = line;

    u->link = curhist;
    curhist = u;

    j = 1;
    for(i=0; i<histfrogp; i++) {
        k = histfrog[i]->value;
        s->name[j+0] = k>>8;
        s->name[j+1] = k;
        j += 2;
    }
}
@



<<global curhist>>=
Auto*	curhist;
@
% like curauto

<<function histtoauto>>=
/// ldobj (case AEND | ATEXT | ??) -> <>
void
histtoauto(void)
{
    Auto *l;

    while(l = curhist) {
        curhist = l->link;
        l->link = curauto;
        curauto = l;
    }
}
@


<<[[ldobj()]] case ATEXT, curauto adjustments with curhist>>=
histtoauto();
@

<<[[ldobj()]] case AEND, curauto adjustments with curhist>>=
histtoauto();
@




<<[[Section]] cases>>=
SFILE,
@

<<global histgen>>=
int	histgen = 0;
@

<<[[ldobj()]] when ANAME opcode, if D_FILE>>=
if(v == D_FILE) {
    if(s->type != SFILE) {
        histgen++;
        s->type = SFILE;
        s->value = histgen;
    }
    if(histfrogp < MAXHIST) {
        histfrog[histfrogp] = s;
        histfrogp++;
    } else
        collapsefrog(s);
}
@


<<function collapsefrog>>=
void
collapsefrog(Sym *s)
{
    int i;

    /*
     * bad encoding of path components only allows
     * MAXHIST components. if there is an overflow,
     * first try to collapse xxx/..
     */
    for(i=1; i<histfrogp; i++)
        if(strcmp(histfrog[i]->name+1, "..") == 0) {
            memmove(histfrog+i-1, histfrog+i+1,
                (histfrogp-i-1)*sizeof(histfrog[0]));
            histfrogp--;
            goto out;
        }

    /*
     * next try to collapse .
     */
    for(i=0; i<histfrogp; i++)
        if(strcmp(histfrog[i]->name+1, ".") == 0) {
            memmove(histfrog+i, histfrog+i+1,
                (histfrogp-i-1)*sizeof(histfrog[0]));
            goto out;
        }

    /*
     * last chance, just truncate from front
     */
    memmove(histfrog+0, histfrog+1,
        (histfrogp-1)*sizeof(histfrog[0]));

out:
    histfrog[histfrogp-1] = s;
}
@



\section{File and line information in executables}

\subsection{Filename symbols}

% why they are shoved in to.autom with locals and params? a bit ugly
<<[[asmsym()]] call putsymb for filenames>>=
for(a=p->to.autom; a; a=a->link)
    if(a->type == D_FILE)
        putsymb(a->asym->name, 'z', a->aoffset, 0);
    else
    if(a->type == D_FILE1)
        putsymb(a->asym->name, 'Z', a->aoffset, 0);
@

<<[[putsymb()]] if z or Z>>=
if(t == 'z' || t == 'Z') {
    cput(s[0]);
    for(i=1; s[i] != 0 || s[i+1] != 0; i += 2) {
        cput(s[i]);
        cput(s[i+1]);
    }
    cput(0);
    cput(0);
    i++;
}
@


\subsection{Line table, [[asmlc()]]}

% lc? line count?
<<global lcsize>>=
long	lcsize;
@


<<constant MINLC(arm)>>=
#define	MINLC	4
@

<<function asmlc>>=
void
asmlc(void)
{
    long oldpc, oldlc;
    Prog *p;
    long v, s;

    oldpc = INITTEXT;
    oldlc = 0;
    for(p = firstp; p != P; p = p->link) {
        if(p->line == oldlc || p->as == ATEXT || p->as == ANOP) {
            <<adjust curtext when iterate over instructions p>>
            if(debug['V'])
                Bprint(&bso, "%6lux %P\n",
                    p->pc, p);
            continue;
        }
        if(debug['V'])
            Bprint(&bso, "\t\t%6ld", lcsize);
        v = (p->pc - oldpc) / MINLC;
        while(v) {
            s = 127;
            if(v < 127)
                s = v;
            cput(s+128);	/* 129-255 +pc */
            if(debug['V'])
                Bprint(&bso, " pc+%ld*%d(%ld)", s, MINLC, s+128);
            v -= s;
            lcsize++;
        }
        s = p->line - oldlc;
        oldlc = p->line;
        oldpc = p->pc + MINLC;
        if(s > 64 || s < -64) {
            cput(0);	/* 0 vv +lc */
            cput(s>>24);
            cput(s>>16);
            cput(s>>8);
            cput(s);
            if(debug['V']) {
                if(s > 0)
                    Bprint(&bso, " lc+%ld(%d,%ld)\n",
                        s, 0, s);
                else
                    Bprint(&bso, " lc%ld(%d,%ld)\n",
                        s, 0, s);
                Bprint(&bso, "%6lux %P\n",
                    p->pc, p);
            }
            lcsize += 5;
            continue;
        }
        if(s > 0) {
            cput(0+s);	/* 1-64 +lc */
            if(debug['V']) {
                Bprint(&bso, " lc+%ld(%ld)\n", s, 0+s);
                Bprint(&bso, "%6lux %P\n",
                    p->pc, p);
            }
        } else {
            cput(64-s);	/* 65-128 -lc */
            if(debug['V']) {
                Bprint(&bso, " lc%ld(%ld)\n", s, 64-s);
                Bprint(&bso, "%6lux %P\n",
                    p->pc, p);
            }
        }
        lcsize++;
    }
    while(lcsize & 1) {
        s = 129;
        cput(s);
        lcsize++;
    }
    if(debug['v'] || debug['V'])
        Bprint(&bso, "lcsize = %ld\n", lcsize);
    Bflush(&bso);
}
@




\chapter{Profiling Support}
\label{chap:profiling}

% surprising again that it's ld's job to add profiling in plan9.
% Thx to TEXT and RET virtual, super easy!

% The code below is interesting because it inserts extra object code using
% directly "AST" constructs, so it helps to understand the data structure!!

% see NOPROF of 8.out.h in Assembler_extra.nw

\section{[[5l -p]] and [[_mainp]]}


% where is defined _mainp? lib_core/libc/386/main9p.s
<<[[main()]] adjust INITENTRY if profiling>>=
if(debug['p'])
    INITENTRY = "_mainp";
@

% 5l -p -1
% before dotext() (it matters since doprof generates code)
% before noops()?
<<[[main()]] call doprofxxx() if profiling>>=
if(debug['p'])
    if(debug['1'])
        doprof1();
    else
        doprof2();
@

\subsection{[[__mcount[]]]}

% the idea o the code below is to add __mcount array, one index per function,
% and when call it increments the array at the right place.

% todo: who is using this information then? profreport of what?
% git grep __mcount does not seem to return stuff, maybe obsolete code?

<<function doprof1(arm)>>=
void
doprof1(void)
{
    Sym *s;
    long n;
    Prog *p, *q;

    DBG("%5.2f profile 1\n", cputime());

    s = lookup("__mcount", 0);
    n = 1;
    for(p = firstp->link; p != P; p = p->link) {
        if(p->as == ATEXT) {
            q = prg();
            q->line = p->line;

            // add_list(q, datap)
            q->link = datap;
            datap = q;

            // DATA __mcount +n*4(SB), 4,  $p->syn //$
            q->as = ADATA;
            q->from.type = D_OREG;
            q->from.symkind = N_EXTERN;
            q->from.offset = n*4;
            q->from.sym = s;
            q->reg = 4; // size of this DATA slice
            q->to = p->from;
            q->to.type = D_CONST;

            q = prg();
            q->line = p->line;
            q->pc = p->pc;
            
            q->link = p->link;
            p->link = q;
            p = q;

            // MOVW p->s + n*4+4(SB), R11
            p->as = AMOVW;
            p->from.type = D_OREG;
            p->from.symkind = N_EXTERN;
            p->from.sym = s;
            p->from.offset = n*4 + 4;
            p->to.type = D_REG;
            p->to.reg = REGTMP;

            q = prg();
            q->line = p->line;
            q->pc = p->pc;
            q->link = p->link;
            p->link = q;
            p = q;

            // ADD, $1, R11 //$
            p->as = AADD;
            p->from.type = D_CONST;
            p->from.offset = 1;
            p->to.type = D_REG;
            p->to.reg = REGTMP;

            q = prg();
            q->line = p->line;
            q->pc = p->pc;
            q->link = p->link;
            p->link = q;
            p = q;

            // MOVW R11, 
            p->as = AMOVW;
            p->from.type = D_REG;
            p->from.reg = REGTMP;
            p->to.type = D_OREG;
            p->to.symkind = N_EXTERN;
            p->to.sym = s;
            p->to.offset = n*4 + 4;

            n += 2;
            continue;
        }
    }
    q = prg();
    q->line = 0;
    q->link = datap;
    datap = q;

    q->as = ADATA;
    q->from.type = D_OREG;
    q->from.symkind = N_EXTERN;
    q->from.sym = s;
    q->reg = 4;
    q->to.type = D_CONST;
    q->to.offset = n;

    s->type = SBSS;
    s->value = n*4;
}
@
\l could use textp

\subsection{[[_profin()]]}

% _profin() is defined by lib_core/libc/port/profile.c
% (_tracin() is defined by you)

% todo: why s2 and s4? why not sin, sout? and pin, pout?


<<global brcond(arm)>>=
static int brcond[] = {ABEQ, ABNE, ABHS, ABLO, ABMI, ABPL, ABVS, ABVC, ABHI, ABLS, ABGE, ABLT, ABGT, ABLE};
@

<<function doprof2(arm)>>=
void
doprof2(void)
{
    Sym *s2, *s4;
    Prog *p, *q, *q2;
    Prog *ps2, *ps4;

    DBG("%5.2f profile 2\n", cputime());

    <<[[doprof2()]] if embedded tracing>>
    else{
        s2 = lookup("_profin", 0);
        s4 = lookup("_profout", 0);
    }
    if(s2->type != STEXT || s4->type != STEXT) {
       <<[[doprof2()]] if embedded tracing diag()>>
        else
            diag("_profin/_profout not defined");
        return;
    }

    // finding ps2, ps4 = instruction (Prog) of s2 and s4
    ps2 = P;
    ps4 = P;
    for(p = firstp; p != P; p = p->link) {
        if(p->as == ATEXT) {
            if(p->from.sym == s2) {
                ps2 = p;
                p->reg = 1;
            }
            if(p->from.sym == s4) {
                ps4 = p;
                p->reg = 1;
            }
        }
    }
    for(p = firstp; p != P; p = p->link) {
        if(p->as == ATEXT) {

            <<[[doprof2()]] if NOPROF p(arm)>>

            /*
             * BL	profin
             */
            q = prg();
            q->line = p->line;
            q->pc = p->pc;
            q->link = p->link;

            <<[[doprof2()]] if embedded tracing ATEXT instrumentation(arm)>>
            else
                p->link = q;
            p = q;
            p->as = ABL;
            p->to.type = D_BRANCH;
            p->cond = ps2;
            p->to.sym = s2;

            continue;
        }
        if(p->as == ARET) {
            <<[[doprof2()]] if embedded tracing ARET instrumentation>>
            /*
             * RET
             */
            q = prg();
            q->as = ARET;
            q->from = p->from;
            q->to = p->to;
            q->cond = p->cond;
            q->link = p->link;
            q->reg = p->reg;
            p->link = q;

            if(p->scond != COND_ALWAYS) {
                q = prg();
                q->as = ABL;
                q->from = zprg.from;
                q->to = zprg.to;
                q->to.type = D_BRANCH;
                q->cond = ps4;
                q->to.sym = s4;
                q->link = p->link;
                p->link = q;

                p->as = brcond[p->scond^1];	/* complement */
                p->scond = COND_ALWAYS;
                p->from = zprg.from;
                p->to = zprg.to;
                p->to.type = D_BRANCH;
                p->cond = q->link->link;	/* successor of RET */
                p->to.offset = q->link->link->pc;

                p = q->link->link;
            } else {

                /*
                 * BL	profout
                 */
                p->as = ABL;
                p->from = zprg.from;
                p->to = zprg.to;
                p->to.type = D_BRANCH;
                p->cond = ps4;
                p->to.sym = s4;
                p->scond = COND_ALWAYS;

                p = q;
            }
            continue;
        }
    }
}
@



\section{[[5l -e]], [[_tracin()]]}

% -p -e, -e for embedded tracing

<<[[doprof2()]] if embedded tracing>>=
if(debug['e']){
    s2 = lookup("_tracein", 0);
    s4 = lookup("_traceout", 0);
}
@

<<[[doprof2()]] if embedded tracing diag()>>=
if(debug['e'])
    diag("_tracein/_traceout not defined %d %d", s2->type, s4->type);
@


<<[[doprof2()]] if embedded tracing ATEXT instrumentation(arm)>>=
if(debug['e']){		/* embedded tracing */
    q2 = prg();
    p->link = q2;
    q2->link = q;

    q2->line = p->line;
    q2->pc = p->pc;

    q2->as = AB;
    q2->to.type = D_BRANCH;
    q2->to.sym = p->to.sym;
    q2->cond = q->link;
}
@

<<[[doprof2()]] if embedded tracing ARET instrumentation>>=
/*
 * RET (default)
 */
if(debug['e']){		/* embedded tracing */
    q = prg();
    q->line = p->line;
    q->pc = p->pc;
    q->link = p->link;
    p->link = q;
    p = q;
}
@

\section{Disabling profiling attribute, [[NOPROF]]}

% NOPROF is in 5.out.h (in Assembler_extra.nw)

<<[[doprof2()]] if NOPROF p(arm)>>=
if(p->reg & NOPROF) {
    for(;;) {
        q = p->link;
        if(q == P || q->as == ATEXT)
            break;
        p = q;
    }
    continue;
}
@
%grrr continue, break, grrr


% useful for the tracing instructions themselves ... hmmm







\chapter{Advanced Topics}
\label{chap:advanced}

%dup: (and adapted) from Assembler
% seen major stuff, major code.

%toc:


\section{Dynamic linking}
\label{sec:dynamic-linking}
\l dynamic loading?
\t dynamic linking vs dynamic loading?

%http://harmful.cat-v.org/software/dynamic-linking/


\subsection{Export table, [[5l -x]]}
% what this is for?

<<global doexp>>=
// do export table, -x
bool	doexp;
@


<<[[main()]] command line processing(arm)>>=
case 'x':	/* produce export table */
    doexp = true;
    if(argv[1] != nil && argv[1][0] != '-' && !isobjfile(argv[1]))
        readundefs(ARGF(), SEXPORT);
    break;
@
%in x86 there is also that
%        a = ARGF();
%        if(strcmp(a, "*") == 0)
%            allexport = true;
%        else

<<function isobjfile>>=
static int
isobjfile(char *f)
{
    int n, v;
    Biobuf *b;
    char buf1[5], buf2[SARMAG];

    b = Bopen(f, OREAD);
    if(b == nil)
        return 0;
    n = Bread(b, buf1, 5);
    if(n == 5 && (buf1[2] == 1 && buf1[3] == '<' || buf1[3] == 1 && buf1[4] == '<'))
        v = 1;	/* good enough for our purposes */
    else{
        Bseek(b, 0, 0);
        n = Bread(b, buf2, SARMAG);
        v = n == SARMAG && strncmp(buf2, ARMAG, SARMAG) == 0;
    }
    Bterm(b);
    return v;
}
@


<<global EXPTAB>>=
char*	EXPTAB;
@


<<[[main()]] if export table or dynamic module(arm)>>=
if(doexp || dlm){
    EXPTAB = "_exporttab";
    zerosig(EXPTAB);
    zerosig("etext");
    zerosig("edata");
    zerosig("end");

    <<[[main()]] if dynamic module(arm)>>
    else
        divsig();

    export();
}
@



<<function zerosig>>=
void
zerosig(char *sp)
{
    Sym *s;

    s = lookup(sp, 0);
    s->sig = 0;
}
@



<<global nimports>>=
int nimports;
@

<<global nexports>>=
int nexports;
@

<<global imports>>=
int	imports;
@

<<global exports>>=
int	exports;
@


<<[[Sym]] other fields>>=
// enum<Section> too?
short	subtype;
@
%old: was char


<<function readundefs>>=
void
readundefs(char *f, int t)
{
    int i, n;
    Sym *s;
    Biobuf *b;
    char *l, buf[256], *fields[64];

    if(f == nil)
        return;
    b = Bopen(f, OREAD);
    if(b == nil){
        diag("could not open %s: %r", f);
        errorexit();
    }
    while((l = Brdline(b, '\n')) != nil){
        n = Blinelen(b);
        if(n >= sizeof(buf)){
            diag("%s: line too long", f);
            errorexit();
        }
        memmove(buf, l, n);
        buf[n-1] = '\0';
        n = getfields(buf, fields, nelem(fields), 1, " \t\r\n");
        if(n == nelem(fields)){
            diag("%s: bad format", f);
            errorexit();
        }
        for(i = 0; i < n; i++){
            s = lookup(fields[i], 0);
            s->type = SXREF;
            s->subtype = t;
            if(t == SIMPORT)
                nimports++;
            else
                nexports++;
        }
    }
    Bterm(b);
}
@




<<function export(arm)>>=
void
export(void)
{
    int i, j, n, off, nb, sv, ne;
    Sym *s, *et, *str, **esyms;
    Prog *p;
    char buf[NSNAME], *t;

    n = 0;
    for(i = 0; i < NHASH; i++)
        for(s = hash[i]; s != S; s = s->link)
            if(s->sig != 0 && s->type != SXREF && s->type != SUNDEF && (nexports == 0 || s->subtype == SEXPORT))
                n++;
    esyms = malloc(n*sizeof(Sym*));
    ne = n;
    n = 0;
    for(i = 0; i < NHASH; i++)
        for(s = hash[i]; s != S; s = s->link)
            if(s->sig != 0 && s->type != SXREF && s->type != SUNDEF && (nexports == 0 || s->subtype == SEXPORT))
                esyms[n++] = s;
    for(i = 0; i < ne-1; i++)
        for(j = i+1; j < ne; j++)
            if(strcmp(esyms[i]->name, esyms[j]->name) > 0){
                s = esyms[i];
                esyms[i] = esyms[j];
                esyms[j] = s;
            }

    nb = 0;
    off = 0;
    et = lookup(EXPTAB, 0);
    if(et->type != 0 && et->type != SXREF)
        diag("%s already defined", EXPTAB);
    et->type = SDATA;
    str = lookup(".string", 0);
    if(str->type == 0)
        str->type = SDATA;
    sv = str->value;
    for(i = 0; i < ne; i++){
        s = esyms[i];
        Bprint(&bso, "EXPORT: %s sig=%lux t=%d\n", s->name, s->sig, s->type);

        /* signature */
        p = newdata(et, off, sizeof(long), N_EXTERN);
        off += sizeof(long);
        p->to.offset = s->sig;

        /* address */
        p = newdata(et, off, sizeof(long), N_EXTERN);
        off += sizeof(long);
        p->to.symkind = N_EXTERN;
        p->to.sym = s;

        /* string */
        t = s->name;
        n = strlen(t)+1;
        for(;;){
            buf[nb++] = *t;
            sv++;
            if(nb >= NSNAME){
                p = newdata(str, sv-NSNAME, NSNAME, N_INTERN);
                p->to.type = D_SCONST;
                p->to.sval = malloc(NSNAME);
                memmove(p->to.sval, buf, NSNAME);
                nb = 0;
            }
            if(*t++ == 0)
                break;
        }

        /* name */
        p = newdata(et, off, sizeof(long), N_EXTERN);
        off += sizeof(long);
        p->to.symkind = N_INTERN;
        p->to.sym = str;
        p->to.offset = sv-n;
    }

    if(nb > 0){
        p = newdata(str, sv-nb, nb, N_INTERN);
        p->to.type = D_SCONST;
        p->to.sval = malloc(NSNAME);
        memmove(p->to.sval, buf, nb);
    }

    for(i = 0; i < 3; i++){
        newdata(et, off, sizeof(long), N_EXTERN);
        off += sizeof(long);
    }
    et->value = off;
    if(sv == 0)
        sv = 1;
    str->value = sv;
    exports = ne;
    free(esyms);
}
@




<<function newdata(arm)>>=
static Prog*
newdata(Sym *s, int o, int w, int t)
{
    Prog *p;

    p = prg();
    p->link = datap;
    datap = p;

    p->as = ADATA;
    p->reg = w;
    p->from.type = D_OREG;
    p->from.symkind = t;
    p->from.sym = s;
    p->from.offset = o;
    p->to.type = D_CONST;
    p->to.symkind = D_NONE;

    return p;
}
@



\subsection{Dynamic loading, [[5l -u]]}

% been disabled? can not find man page for dynld anymore, nor dynld.h
% -x, -u
% see dynld(2)

%see also rational for no dyn loading!
%http://sta.li/

<<global dlm>>=
bool dlm;
@

<<[[Section]] cases>>=
SIMPORT,
SEXPORT,
@



<<[[main()]] command line processing(arm)>>=
case 'u':	/* produce dynamically loadable module */
    dlm = true;
    if(argv[1] != nil && argv[1][0] != '-' && !isobjfile(argv[1]))
        readundefs(ARGF(), SIMPORT);
    break;
@
%x86 had this too:
%    // do not load standard libraries
%    debug['l'] = true;


<<[[asmb()]] if dynamic module magic header adjustment(arm)>>=
if(dlm)
    lput(0x80000000|0x647);	/* magic */
@




% import(), pending of export() ?

<<[[main()]] if dynamic module(arm)>>=
if(dlm){
    initdiv();
    import();
    HEADTYPE = H_PLAN9;
    INITTEXT = INITDAT = 0;
    INITRND = 8;
    INITENTRY = EXPTAB;
}
@









<<function import(arm)>>=
void
import(void)
{
    int i;
    Sym *s;

    for(i = 0; i < NHASH; i++)
        for(s = hash[i]; s != S; s = s->link)
            if(s->sig != 0 && s->type == SXREF && (nimports == 0 || s->subtype == SIMPORT)){
                undefsym(s);
                Bprint(&bso, "IMPORT: %s sig=%lux v=%ld\n", s->name, s->sig, s->value);
            }
}
@

%on x86 additiona check and features, integrate them?
%                if(s->value != 0)
%                    diag("value != 0 on SXREF");
%                undefsym(s);
%                if(debug['X'])
%                    Bprint(&bso, "IMPORT: %s sig=%lux v=%ld\n", s->name, s->sig, s->value);
%                if(debug['S'])
%                    s->sig = 0;


<<enum rxxx>>=
enum rxxx {
    Roffset	= 22,		/* no. bits for offset in relocation address */
    Rindex	= 10,		/* no. bits for index in relocation address */
};
@


\subsection{[[SUNDEF]]}

<<[[Section]] cases>>=
SUNDEF,
@
% for ??


<<global undefp>>=
//@Scheck: not dead, used by UP
Prog	undefp;
@
% for error recovery? and for dynamic loading stuff?

\label{sec:UP}
<<constant UP>>=
#define	UP	(&undefp)
@
% who does = UP?


<<[[patch()]] switch section type for branch instruction, cases>>=
case SUNDEF:
    if(p->as != ABL)
        diag("help: SUNDEF in AB || ARET");
    p->to.offset = 0;
    p->to.type = D_BRANCH;
    p->cond = UP;
    break;
@

<<[[asmout()]] BRA case, if undefined target>>=
if(p->cond == UP) {
    s = p->to.sym;
    if(s->type != SUNDEF)
        diag("bad branch sym type");
    v = (ulong)s->value >> (Roffset-2);
    dynreloc(s, p->pc, 0);
}
@


% import -> undefsym
<<function undefsym>>=
void
undefsym(Sym *s)
{
    int n;

    n = imports;
    if(s->value != 0)
        diag("value != 0 on SXREF");
    if(n >= 1<<Rindex)
        diag("import index %d out of range", n);
    s->value = n<<Roffset;
    s->type = SUNDEF;
    imports++;
}
@
%>> >>

\subsection{XXX}


% port to arm?
%<<[[asmb()]] if dynamic module, when iterate from firstp(xxx)>>=
%if(dlm) {
%    if(p->as == ATEXT)
%        reloca = nil;
%    else if(reloca != nil)
%        diag("reloc failure: %P", curp);
%}
%@


% ???
<<[[asmb()]] if dynamic module, before datblk()>>=
if(dlm){
    char buf[8];

    write(cout, buf, INITDAT-textsize);
    textsize = INITDAT;
}
@

<<[[asmb()]] if dynamic module and no symbol table generation>>=
if(dlm){
    seek(cout, HEADR+textsize+datsize, 0);
    asmdyn();
    cflush();
}
@


<<[[entryvalue()]] if dynamic module case>>=
case SDATA:
    if(dlm)
        return s->value+INITDAT;
@





<<struct Reloc>>=
struct Reloc
{
    int n;
    int t;
    byte *m;
    ulong *a;
};
@

<<global rels>>=
Reloc rels;
@



<<[[asmb()]] if dynamic module, call asmdyn()>>=
if(dlm)
    asmdyn();
@

% asmb() -> asmdyn()

<<function asmdyn>>=
void
asmdyn()
{
    int i, n, t, c;
    Sym *s;
    ulong la, ra, *a;
    vlong off;
    byte *m;
    Reloc *r;

    cflush();
    off = seek(cout, 0, 1);
    lput(0);
    t = 0;
    lput(imports);
    t += 4;
    for(i = 0; i < NHASH; i++)
        for(s = hash[i]; s != S; s = s->link)
            if(s->type == SUNDEF){
                lput(s->sig);
                t += 4;
                t += sput(s->name);
            }

    la = 0;
    r = &rels;
    n = r->n;
    m = r->m;
    a = r->a;
    lput(n);
    t += 4;
    for(i = 0; i < n; i++){
        ra = *a-la;
        if(*a < la)
            diag("bad relocation order");
        if(ra < 256)
            c = 0;
        else if(ra < 65536)
            c = 1;
        else
            c = 2;
        cput((c<<6)|*m++);
        t++;
        if(c == 0){
            cput(ra);
            t++;
        }
        else if(c == 1){
            wput(ra);
            t += 2;
        }
        else{
            lput(ra);
            t += 4;
        }
        la = *a++;
    }

    cflush();
    seek(cout, off, 0);
    lput(t);

    DBG("import table entries = %d\n", imports);
    DBG("export table entries = %d\n", exports);
}
@
% >> >>

<<function sput>>=
static int
sput(char *s)
{
    char *p;

    p = s;
    while(*s)
        cput(*s++);
    cput(0);
    return  s-p+1;
}
@



<<global modemap>>=
int modemap[4] = { 0, 1, -1, 2, };
@


<<[[datblk()]] if dynamic module(arm)>>=
if(dlm)
    dynreloc(v, a+INITDAT, 1);
@


<<enum _anon_ (linkers/5l/span.c)(arm)>>=
enum{
    ABSD = 0,
    ABSU = 1,
    RELD = 2,
    RELU = 3,
};
@


<<function dynreloc(arm)>>=
void
dynreloc(Sym *s, long v, int abs)
{
    int i, k, n;
    byte *m;
    ulong *a;
    Reloc *r;

    if(v&3)
        diag("bad relocation address");
    v >>= 2;

    if(s != S && s->type == SUNDEF)
        k = abs ? ABSU : RELU;
    else
        k = abs ? ABSD : RELD;
    /* Bprint(&bso, "R %s a=%ld(%lx) %d\n", s->name, a, a, k); */
    k = modemap[k];
    r = &rels;
    n = r->n;
    if(n >= r->t)
        grow(r);
    m = r->m;
    a = r->a;
    for(i = n; i > 0; i--){
        if(v < a[i-1]){	/* happens occasionally for data */
            m[i] = m[i-1];
            a[i] = a[i-1];
        }
        else
            break;
    }
    m[i] = k;
    a[i] = v;
    r->n++;
}
@
% the align 4 check at the beginning are ARM specific

<<function grow>>=
static void
grow(Reloc *r)
{
    int t;
    byte *m, *nm;
    ulong *a, *na;

    t = r->t;
    r->t += 64;
    m = r->m;
    a = r->a;
    r->m = nm = malloc(r->t * sizeof(byte));
    r->a = na = malloc(r->t * sizeof(ulong));
    memmove(nm, m, t*sizeof(byte));
    memmove(na, a, t*sizeof(ulong));
    free(m);
    free(a);
}
@



\subsection{Relocatable address, [[C_ADDR]]}

<<[[Operand_class]] cases>>=
C_ADDR,		/* relocatable address */
@

<<[[aclass()]] when D_OREG and external symbol and dlm>>=
if(dlm) {
    switch(t) {
    case STEXT: case SSTRING:
    case SUNDEF:
    case SCONST: 
        instoffset = s->value + a->offset;
        break;
    case SDATA: case SBSS:
    default:
        instoffset = s->value + a->offset + INITDAT;
        break;
    }
    return C_ADDR;
}
@
%old: case SLEAF: 
%pad: I added the case SDATA: case SBSS:
% in default should return exn if not SDATA or SBSS no?

<<[[optab]] entries>>=
{ ATEXT,	C_ADDR,	C_NONE,	C_LCON, 	 0, 0, 0 },
{ ATEXT,	C_ADDR,	C_REG,	C_LCON, 	 0, 0, 0 },
@
% size 0 so catched in dotext()

<<[[optab]] entries>>=
{ AWORD,	C_NONE,	C_NONE,	C_ADDR,		11, 4, 0 },
@

<<[[asmout()]] on WORD case, switch class cases>>=
case C_LCON:
    if(!dlm)
        break;
    if(p->to.symkind != N_EXTERN && p->to.symkind != N_INTERN)
        break;
    // Fallthrough
case C_ADDR:
    if(p->to.sym->type == SUNDEF)
        ckoff(p->to.sym, p->to.offset);
    dynreloc(p->to.sym, p->pc, 1);
@

% Store
<<[[optab]] entries>>=
{ AMOVW,	C_REG,	C_NONE,	C_ADDR,		64, 8, 0,	LTO },
{ AMOVB,	C_REG,	C_NONE,	C_ADDR,		64, 8, 0,	LTO },
{ AMOVBU,	C_REG,	C_NONE,	C_ADDR,		64, 8, 0,	LTO },
@

<<[[asmout()]] switch on type cases>>=
/* reloc ops */
case 64:	/* mov/movb/movbu R,addr */
    o1 = omvl(p, &p->to, REGTMP);
    if(!o1)
        break;
    o2 = osr(p->as, p->from.reg, 0, REGTMP, p->scond);
    break;
@

% Load
<<[[optab]] entries>>=
{ AMOVW,	C_ADDR,	C_NONE,	C_REG,		65, 8, 0,	LFROM },
{ AMOVBU,	C_ADDR,	C_NONE,	C_REG,		65, 8, 0,	LFROM },
{ AMOVB,	C_ADDR,	C_NONE,	C_REG,		66, 16, 0,	LFROM },
{ AMOVH,	C_ADDR,	C_NONE,	C_REG,		66, 16, 0,	LFROM },
{ AMOVHU,	C_ADDR,	C_NONE,	C_REG,		66, 16, 0,	LFROM },
@


<<[[asmout()]] switch on type cases>>=
case 65:	/* mov/movbu addr,R */
case 66:	/* movh/movhu/movb addr,R */
    o1 = omvl(p, &p->from, REGTMP);
    if(!o1)
        break;
    o2 = olr(0, REGTMP, p->to.reg, p->scond);
    if(p->as == AMOVBU || p->as == AMOVB)
        o2 |= 1<<22;
    if(o->type == 65)
        break;

    o3 = oprrr(ASLL, p->scond);

    if(p->as == AMOVBU || p->as == AMOVHU)
        o4 = oprrr(ASRL, p->scond);
    else
        o4 = oprrr(ASRA, p->scond);

    r = p->to.reg;
    o3 |= (r)|(r<<12);
    o4 |= (r)|(r<<12);
    if(p->as == AMOVB || p->as == AMOVBU) {
        o3 |= (24<<7);
        o4 |= (24<<7);
    } else {
        o3 |= (16<<7);
        o4 |= (16<<7);
    }
    break;
@
% >> >> >> >> >> >> >>

<<[[optab]] entries>>=
{ AMOVH,	C_REG,	C_NONE,	C_ADDR,		67, 24, 0,	LTO },
{ AMOVHU,	C_REG,	C_NONE,	C_ADDR,		67, 24, 0,	LTO },
@

<<[[asmout()]] switch on type cases>>=
case 67:	/* movh/movhu R,addr -> sb, sb */
    o1 = omvl(p, &p->to, REGTMP);
    if(!o1)
        break;
    o2 = osr(p->as, p->from.reg, 0, REGTMP, p->scond);

    o3 = oprrr(ASRL, p->scond);
    o3 |= (8<<7)|(p->from.reg)|(p->from.reg<<12);
    o3 |= (1<<6);	/* ROR 8 */

    o4 = oprrr(AADD, p->scond);
    o4 |= (REGTMP << 12) | (REGTMP << 16);
    o4 |= immrot(1);

    o5 = osr(p->as, p->from.reg, 0, REGTMP, p->scond);

    o6 = oprrr(ASRL, p->scond);
    o6 |= (24<<7)|(p->from.reg)|(p->from.reg<<12);
    o6 |= (1<<6);	/* ROL 8 */
    break;
@
% >> >> >> >> >> >> >> >>


\section{Dynamic typing}

\subsection{[[ADYNT]]}
% asm.pdf says it was for alef, so maybe can remove?
%  useful also for dynamic loading?
%  seems more related to dynamic typing

% mv with dlm?
% seems never produced by 5a/5c


<<global dtype(arm)>>=
int	dtype = 4;
@
<<[[dodata()]] if ADYNT or AINIT>>=
if(p->as == ADYNT || p->as == AINIT)
    s->value = dtype;
@




<<[[ldobj()]] locals(arm)>>=
Sym *di = S;
@

<<[[Section]] cases>>=
SCONST,
@
% SCONST ... hmm confusing with D_SCONST IMHO

<<[[ldobj()]] switch opcode cases(arm)>>=
case ADYNT:
    if(p->to.sym == S) {
        diag("DYNT without a sym\n%P", p);
        break;
    }
    di = p->to.sym;
    p->reg = 4;
    if(di->type == SXREF) {
        if(debug['z'])
            Bprint(&bso, "%P set to %d\n", p, dtype);
        di->type = SCONST;
        di->value = dtype;
        dtype += 4;
    }
    if(p->from.sym == S)
        break;

    p->from.offset = di->value;
    p->from.sym->type = SDATA;
    if(curtext == P) {
        diag("DYNT not in text: %P", p);
        break;
    }
    p->to.sym = curtext->from.sym;
    p->to.type = D_CONST;
    p->link = datap;
    datap = p;
    break;
@



\subsection{[[AINIT]]}
% seems never produced by 5a/5c, like ADYNT, so move?
% seems to be just after a ADYNT, see the error message below


<<[[ldobj()]] switch opcode cases(arm)>>=
case AINIT:
    if(p->from.sym == S) {
        diag("INIT without a sym\n%P", p);
        break;
    }
    if(di == S) {
        diag("INIT without previous DYNT\n%P", p);
        break;
    }
    p->from.offset = di->value;
    p->from.sym->type = SDATA;
    p->link = datap;
    datap = p;
    break;

@

\section{Position independent code (PIC)}

%PIC, -fpic

% how ugly it is for x86:
% http://ewontfix.com/18/



\section{Optimisations}
\label{sec:optimisations}

\subsection{Opcode rewriting}
% at loading time

% would be better with ocaml pattern matching (but maybe not that shorter)
<<[[ldobj()]] switch opcode cases(arm)>>=
case ASUB:
    if(p->from.type == D_CONST)
     if(p->from.symkind == D_NONE)
      if(p->from.offset < 0) {
        p->from.offset = -p->from.offset;
        p->as = AADD;
    }
    goto casedef;
@
<<[[ldobj()]] switch opcode cases(arm)>>=
case AADD:
    if(p->from.type == D_CONST)
     if(p->from.symkind == D_NONE)
      if(p->from.offset < 0) {
        p->from.offset = -p->from.offset;
        p->as = ASUB;
    }
    goto casedef;
@

% see also before in previous section the Leaf procedure opti,
% a form of opcode rewriting where some TEXT and RET can
% be optimized.

\subsection{Operand rewriting}

% certain operand values immediate values can be in a certain range
% which then can be encoded as a single instruction.

% If they are out of range but a double of 2, then again
% can be encoded as a single instruction.

% otherwise have to decompose.



% then introduce BIG optimisation below, or put in
% adv topic chapter with small data segment?

\label{sec:BIG}
<<[[dodata()]] define special symbols>>=
xdefine("setR12", SDATA, 0L+BIG);
@

<<constant BIG>>=
//BIG		= (1<<12)-4,
BIG		= 0,
@

% having BIG set to a page is good because STR/LDR
% accept immediate offset of 12 bits and a sign, so can encode
% easily [-4096,+4096] range.
% So good for hello(SB) but not so good for $hello(SB).
% Indeed, resulting offset will be negatif because do  Sym.value of
% hello which should be close to 0, minus BIG, which should
% be a negatif number. But RECON matchs only when can immrot(instoffset)
% and can do then ADD v, R12, Rwhatever, but when v is negatif
% and big number, not so easy to satisfy immrot(). In that case
% get a LCON.

% why -4? otherwise could not reach the first data? offset
% can be negative or positive so actually can cover 2 pages of
% small data variables!


\subsection{Small data first}
% improve data cache miss?

<<[[Section]] cases>>=
SDATA1,
@

<<constant MINSIZ>>=
MINSIZ		= 64,
@


<<[[dodata()]] in pass 1, if small data size, adjust orig>>=
/*
 *	assign 'small' variables to data segment
 *	(rational is that data segment is more easily
 *	 addressed through offset on R12)
 */
if(v <= MINSIZ) {
    s->value = orig;
    orig += v;
    s->type = SDATA1;
}
@

<<[[dodata()]] in pass 2, retag small data>>=
if(t == SDATA1)
    s->type = SDATA;
@




\subsection{Compacting chains of [[AB]], [[brloop()]]}

% when need that? because of 5c generate a big sloppy code
% for loops?
% try 5c -S on simple programs using ifs.



<<[[patch()]] optimisation pass>>=
for(p = firstp; p != P; p = p->link) {
    <<adjust curtext when iterate over instructions p>>

    if(p->cond != P && p->cond != UP) {
        p->cond = brloop(p->cond);
        if(p->cond != P)
         if(p->to.type == D_BRANCH)
            p->to.offset = p->cond->pc;
    }
}
@

% p->to.offset = p->cond->pc;
% can have changed?? yes because of brloop()
% s/brloop()/? follow_AB?



%  p->cond = brloop(p->cond);
% compact a chain of AB to the end, and "detect" infinite chain loops
<<function brloop(arm)>>=
/// main -> patch -> <>
Prog*
brloop(Prog *p)
{
    Prog *q;
    int c = 0;

    for(; p!=P;) {
        if(p->as != AB)
            return p;
        q = p->cond;
        if(q <= p) {
            c++;
            if(q == p || c > 5000)
                break;
        }
        p = q;
    }
    return P;
}
@
% less: diag infinite loop detected??





\subsection{Removing useless instructions, [[follow()]]}
\label{sec:opti-follow}

% a space optimisation more than speed opti (but can help speed
% a bit maybe because of icache)

%note: right now it's not executed by 5l

% Note that this code does not remove the unused functions
% The size of helloc is very small but mainly because of
% loadlib() and objfile() on demand loading strategy of used
% but not yet defined (SXREF) symbols (and multiple passes
% on library symbol table until fixpoint).

% Here I think it's mostly for unreachable code, and chains of direct jmps.
% Note that useful I think.

% does not remove all unreachable instrs so,
% and does not remove unreachable functions :( maybe more important

%less: print the removed code!! usuful diagnostic no?

%if remove follow() optimisations, can have far simpler linker no?
%just dodata(), and simple asmb()? no need patch(), follow()?
%need patch(), because need to link to pc that will change when
%generate the actual instructions.


<<function follow>>=
void
follow(void)
{

    DBG("%5.2f follow\n", cputime());

    firstp = prg();
    lastp = firstp;

    xfol(textp);

    lastp->link = P;
    firstp = firstp->link;
}
@

<<[[Mark]] cases>>=
FOLL		= 1<<0,
@
% >>
% foll for follow?



% xfol? extended follow?
<<function xfol(arm)>>=
void
xfol(Prog *p)
{
    Prog *q, *r;
    int a, i;

loop:
    if(p == P)
        return;
    <<adjust curtext when iterate over instructions p>>
    a = p->as;

    if(a == AB) {
        q = p->cond;
        if(q != P) {
            p->mark |= FOLL;
            p = q;
            if(!(p->mark & FOLL))
                goto loop;
        }
    }

    if(p->mark & FOLL) {
        <<[[xfol()]] when p is marked, for loop to copy instructions>>
        a = AB;
        q = prg();
        q->as = a;
        q->line = p->line;
        q->to.type = D_BRANCH;
        q->to.offset = p->pc;
        q->cond = p;
        p = q;
    }

    p->mark |= FOLL;
    lastp->link = p;
    lastp = p;

    if(a == AB || (a == ARET && p->scond == COND_ALWAYS) || a == ARFE){
        return;
    }

    if(p->cond != P)
     <<[[xfol()]] if a is not ABL and p has a link>>
    p = p->link;
    goto loop;
}
@



<<[[xfol()]] if a is not ABL and p has a link>>=
if(a != ABL && p->link != P) {
   q = brchain(p->link);

   if(a != ATEXT && a != ABCASE)
    if(q != P && (q->mark & FOLL)) {
       p->as = relinv(a);
       p->link = p->cond;
       p->cond = q;
   }

   // recursive call
   xfol(p->link);

   q = brchain(p->cond);
   if(q == P)
       q = p->cond;
   if(q->mark&FOLL) {
       p->cond = q;
       return;
   }
   p = q;
   goto loop;
}
@

% follows a chain of AB, hmm but needed now that has brloop()?
<<function brchain(arm)>>=
Prog*
brchain(Prog *p)
{
    int i;

    for(i=0; i<20; i++) {
        if(p == P || p->as != AB)
            return p;
        p = p->cond;
    }
    return P;
}
@

<<function relinv(arm)>>=
int
relinv(int a)
{
    switch(a) {
    case ABEQ:	return ABNE;
    case ABNE:	return ABEQ;
    case ABHS:	return ABLO;
    case ABLO:	return ABHS;
    case ABMI:	return ABPL;
    case ABPL:	return ABMI;
    case ABVS:	return ABVC;
    case ABVC:	return ABVS;
    case ABHI:	return ABLS;
    case ABLS:	return ABHI;
    case ABGE:	return ABLT;
    case ABLT:	return ABGE;
    case ABGT:	return ABLE;
    case ABLE:	return ABGT;
    }
    diag("unknown relation: %s", anames[a]);
    return a;
}
@





<<[[xfol()]] when p is marked, for loop to copy instructions>>=
for(i=0, q=p; i<4 && q != lastp; i++, q=q->link) {
    a = q->as;
    if(a == ANOP) {
        i--;
        continue;
    }
    if(a == AB || (a == ARET && q->scond == COND_ALWAYS) || a == ARFE)
        goto copy;
    if(!q->cond || (q->cond->mark & FOLL))
        continue;
    if(a != ABEQ && a != ABNE)
        continue;

// here when a is one of AB, ARET, ARFE, ABEQ, ABNE
copy:
    for(;;) {
        r = prg();
        *r = *p;

        <<[[xfol()]] sanity check one, r should be marked>>

        if(p != q) {
            p = p->link;
            lastp->link = r;
            lastp = r;
            continue;
        }
        lastp->link = r;
        lastp = r;

        if(a == AB || (a == ARET && q->scond == COND_ALWAYS) || a == ARFE)
            return;

        // r->as = relinv(a)
        r->as = ABNE;
        if(a == ABNE)
            r->as = ABEQ;

        r->cond = p->link;
        r->link = p->cond;

        if(!(r->link->mark & FOLL))
            // recursive call
            xfol(r->link);

        <<[[xfol()]] sanity check two, [[r->cond]] should be marked>>

        return;
    }
}
@
%old: had        
% if(q == lastp)
%    break;
% at beginning of the for loop, but I moved it up in the for(;_here_;) instead
% (equivalent)




\ifallcode
<<[[xfol()]] sanity check one, r should be marked>>=
if(!(r->mark & FOLL))
    print("cant happen 1\n");
r->mark |= FOLL;
@

<<[[xfol()]] sanity check two, [[r->cond]] should be marked>>=
if(!(r->cond->mark & FOLL))
    print("cant happen 2\n");
@
\fi



\section{Overriding symbol attribute, [[DUPOK]]}
\label{sec:dupok-nop}

% case in kernel where override a previous symbol,
% e.g. sysfatal, werrstr

% DUPOK, x.scale & DUPOK


<<[[ldobj()]] locals(arm)>>=
bool skip;
@
<<[[ldobj()]] after newloop when new object file, more initializations>>=
skip = false;
@
% If set to true then generate a NOP actually for the currently
% read instruction. Used for DUPOK for instance.



<<[[ldobj()]] case ATEXT and section not SNONE or SXREF, if DUPOK>>=
if(p->reg & DUPOK) {
    skip = true;
    goto casedef;
}
@
% skip all until next TEXT


<<[[ldobj()]] in switch opcode default case, if skip>>=
if(skip)
    nopout(p);
@

<<[[ldobj()]] in switch opcode ATEXT case, reset skip>>=
skip = false; // needed?
@



% for e.g. ATEXT that are DUPOK
<<function nopout>>=
void
nopout(Prog *p)
{
    p->as = ANOP;
    p->from.type = D_NONE;
    p->to.type = D_NONE;
}
@
% why care about .type? because some code is look for
% D_BRANCH, for symbols, and so putting D_NONE ensure those
% code will not be triggred for what was transformed in NOP.




\section{Other executable formats}
\label{sec:other-executable-formats}


%<<[[main()]] switch HEADTYPE cases(arm)>>=
%case 0:	/* no header */
%case 6:	/* no header, padded segments */
%    HEADR = 0L;
%    if(INITTEXT == -1)
%        INITTEXT = 0;
%    if(INITDAT == -1)
%        INITDAT = 0;
%    if(INITRND == -1)
%        INITRND = 4;
%    break;
%case 1:	/* aif for risc os */
%    HEADR = 128L;
%    if(INITTEXT == -1)
%        INITTEXT = 0x10005000 + HEADR;
%    if(INITDAT == -1)
%        INITDAT = 0;
%    if(INITRND == -1)
%        INITRND = 4;
%    break;
%case 3:	/* boot for NetBSD */
%    HEADR = 32L;
%    if(INITTEXT == -1)
%        INITTEXT = 0xF0000020L;
%    if(INITDAT == -1)
%        INITDAT = 0;
%    if(INITRND == -1)
%        INITRND = 4096;
%    break;
%case 4: /* boot for IXP1200 */
%    HEADR = 0L;
%    if(INITTEXT == -1)
%        INITTEXT = 0x0;
%    if(INITDAT == -1)
%        INITDAT = 0;
%    if(INITRND == -1)
%        INITRND = 4;
%    break;
%case 5: /* boot for ipaq */
%    HEADR = 16L;
%    if(INITTEXT == -1)
%        INITTEXT = 0xC0008010;
%    if(INITDAT == -1)
%        INITDAT = 0;
%    if(INITRND == -1)
%        INITRND = 1024;
%    break;

%<<[[asmb()]] switch HEADTYPE (to position after text) cases(arm)>>=
%case 0:
%case 1:
%case 5:
%...
%case 3:
%case 6:	/* no header, padded segments */
%    OFFSET = rnd(HEADR+textsize, 4096);
%    seek(cout, OFFSET, 0);
%    break;


%<<[[asmb()]] switch HEADTYPE (for symbol table generation) cases(arm)>>=
%case 0:
%case 1:
%case 4:
%case 5:
%    debug['s'] = 1;
%    break;
%case 3:
%case 6:	/* no header, padded segments */
%    OFFSET += rnd(datsize, 4096);
%    seek(cout, OFFSET, 0);
%    break;


%<<[[asmb()]] switch HEADTYPE (for header generation) cases(arm)>>=
%case 0:	/* no header */
%case 6:	/* no header, padded segments */
%    break;
%case 1:	/* aif for risc os */
%    lputl(0xe1a00000);		/* NOP - decompress code */
%    lputl(0xe1a00000);		/* NOP - relocation code */
%    lputl(0xeb000000 + 12);		/* BL - zero init code */
%    lputl(0xeb000000 +
%        (entryvalue()
%         - INITTEXT
%         + HEADR
%         - 12
%         - 8) / 4);		/* BL - entry code */
%
%    lputl(0xef000011);		/* SWI - exit code */
%    lputl(textsize+HEADR);		/* text size */
%    lputl(datsize);			/* data size */
%    lputl(0);			/* sym size */
%
%    lputl(bsssize);			/* bss size */
%    lputl(0);			/* sym type */
%    lputl(INITTEXT-HEADR);		/* text addr */
%    lputl(0);			/* workspace - ignored */
%
%    lputl(32);			/* addr mode / data addr flag */
%    lputl(0);			/* data addr */
%    for(t=0; t<2; t++)
%        lputl(0);		/* reserved */
%
%    for(t=0; t<15; t++)
%        lputl(0xe1a00000);	/* NOP - zero init code */
%    lputl(0xe1a0f00e);		/* B (R14) - zero init return */
%    break;
%case 3:	/* boot for NetBSD */
%    lput((143<<16)|0413);		/* magic */
%    lputl(rnd(HEADR+textsize, 4096));
%    lputl(rnd(datsize, 4096));
%    lputl(bsssize);
%    lputl(symsize);			/* nsyms */
%    lputl(entryvalue());		/* va of entry */
%    lputl(0L);
%    lputl(0L);
%    break;
%case 4: /* boot for IXP1200 */
%    break;
%case 5: /* boot for ipaq */
%    lputl(0xe3300000);		/* nop */
%    lputl(0xe3300000);		/* nop */
%    lputl(0xe3300000);		/* nop */
%    lputl(0xe3300000);		/* nop */
%    break;
% >> 

\subsection{Elf, Linux}

% ELF dissection:
% - https://github.com/mewrev/dissection
% - very nice diagram a la xkcd
%   https://code.google.com/p/corkami/wiki/ELF101
% - http://jvns.ca/blog/2014/09/06/how-to-read-an-executable/


<<[[main()]] switch HEADTYPE cases(arm)>>=
case H_ELF:	/* elf executable */
    HEADR = rnd(Ehdr32sz+3*Phdr32sz, 16);
    if(INITTEXT == -1)
        INITTEXT = 4096+HEADR;
    if(INITDAT == -1)
        INITDAT = 0;
    if(INITRND == -1)
        INITRND = 4;
    break;
@

<<[[asmb()]] switch HEADTYPE (to position after text) cases(arm)>>=
case H_ELF:
    OFFSET = HEADR+textsize;
    seek(cout, OFFSET, 0);
    break;
@

<<[[asmb()]] switch HEADTYPE (for symbol table generation) cases(arm)>>=
case H_ELF:
    break;
@

<<[[asmb()]] switch HEADTYPE (for header generation) cases(arm)>>=
case H_ELF:
    debug['S'] = 1;			/* symbol table */
    elf32(ARM, ELFDATA2LSB, 0, nil);
    break;
@
% >>


% start text physical address (elf only)
<<global INITTEXTP>>=
long	INITTEXTP = -1; /* text location (physical) */
@

<<[[main()]] last INITXXX adjustments>>=
if (INITTEXTP == -1)
    INITTEXTP = INITTEXT;
@


<<[[main()]] command line processing(arm)>>=
case 'P':
    a = ARGF();
    if(a)
        INITTEXTP = atolwhex(a);
    break;
@
% seems dead?

<<enum _anon_ (linkers/8l/elf.h)>>=
enum {
    Ehdr32sz	= 52,
    Phdr32sz	= 32,
    Shdr32sz	= 40,

    Ehdr64sz	= 64,
    Phdr64sz	= 56,
    Shdr64sz	= 64,
};
@

\subsection{OMach, MacOS X}

%https://www.objc.io/issues/6-build-tools/mach-o-executables/
%http://lowlevelbits.org/parse-mach-o-files/

\subsection{PE, Microsoft Windows}
% windows format, see pe.h in golang/src/libmach/
% exe and dll (.so)

%\subsection{COFF}
% ?


\section{Other instructions}

\subsection{Float instructions}

% string connection with the kernel floating port support.
% see bcm/vfp3.c, bcm/fpiarm.c, etc


\subsubsection{Operand kind}

<<[[inopd()]] cases>>=
case D_FREG:
case D_FPCR:
    break;
@

<<[[inopd()]] cases>>=
case D_FCONST:
    a->ieee = malloc(sizeof(Ieee));

    a->ieee->l = p[4] | (p[5]<<8) | (p[6]<<16) | (p[7]<<24);
    a->ieee->h = p[8] | (p[9]<<8) | (p[10]<<16) | (p[11]<<24);
    size += 8;
    break;
@
% >> >> >> >> >> >>
% bugfix: there was a bug where it was using NSNAME instead of sizeof(Ieee)
%  but factorizing code with malloc fixed the issue too.


% 8.out.h

<<function ieeedtof>>=
/// main -> objfile -> ldobj -> <>
long
ieeedtof(Ieee *e)
{
    int exp;
    long v;

    if(e->h == 0)
        return 0;
    exp = (e->h>>20) & ((1L<<11)-1L);
    exp -= (1L<<10) - 2L;
    v = (e->h & 0xfffffL) << 3;
    v |= (e->l >> 29) & 0x7L;
    if((e->l >> 28) & 1) {
        v++;
        if(v & 0x800000L) {
            v = (v & 0x7fffffL) >> 1;
            exp++;
        }
    }
    if(exp <= -126 || exp >= 130)
        diag("double fp to single fp overflow");
    v |= ((exp + 126) & 0xffL) << 23;
    v |= e->h & 0x80000000L;
    return v;
}
@

<<function ieeedtod>>=
/// Dconv -> <>
double
ieeedtod(Ieee *ieeep)
{
    Ieee e;
    double fr;
    int exp;

    if(ieeep->h & (1L<<31)) {
        e.h = ieeep->h & ~(1L<<31);
        e.l = ieeep->l;
        return -ieeedtod(&e);
    }
    if(ieeep->l == 0 && ieeep->h == 0)
        return 0;
    fr = ieeep->l & ((1L<<16)-1L);
    fr /= 1L<<16;
    fr += (ieeep->l>>16) & ((1L<<16)-1L);
    fr /= 1L<<16;
    fr += (ieeep->h & (1L<<20)-1L) | (1L<<20);
    fr /= 1L<<21;
    exp = (ieeep->h>>20) & ((1L<<11)-1L);
    exp -= (1L<<10) - 2L;
    return ldexp(fr, exp);
}
@




\subsubsection{Operand class}

<<[[Operand_class]] cases>>=
C_FREG,
C_FCON,
C_FCR,
@

<<[[aclass()]] switch type cases>>=
case D_FREG:
    return C_FREG;
case D_FCONST:
    return C_FCON;
case D_FPCR:
    return C_FCR;
@



<<function immfloat(arm)>>=
int
immfloat(long v)
{
    return (v & 0xC03) == 0;/* offset will fit in floating-point load/store */
}
@

<<[[Operand_class]] cases, in C_xEXT, float cases>>=
C_FEXT,
C_HFEXT,
@
%bug: must be inside C_xEXT, not after C_LEXT!

<<[[aclass()]] if immfloat for N_EXTERN symbol>>=
if(immfloat(t))
    return immhalf(instoffset)? C_HFEXT : C_FEXT;
@

<<[[Operand_class]] cases, in C_xAUTO, float cases>>=
C_FAUTO,	/* float insn offset (0 to 0x3fc, word aligned) */
C_HFAUTO,	/* both H and F */
@
%bug: must be inside C_xAUTO, not after C_LAUTO! see long pb vlong.c :)
% with addpool(), WORD d+4(FP), and illegal combination error.

<<[[aclass()]] if immfloat for N_LOCAL or N_PARAM symbol>>=
if(immfloat(t))
    return immhalf(instoffset)? C_HFAUTO : C_FAUTO;
@

<<[[Operand_class]] cases, in C_xOREG, float cases>>=
C_FOREG,
C_HFOREG,
@


<<[[aclass()]] if immfloat for D_NONE symbol>>=
if(immfloat(t))
    return immhalf(instoffset)? C_HFOREG : C_FOREG;
    /* n.b. that it will also satisfy immrot */
@


\subsubsection{XXX}




<<[[Optab_flag]] cases>>=
V4		= 1<<3,	/* arm v4 arch */
VFP		= 1<<4,	/* arm vfpv3 floating point */
@
% >> >>
%http://www.arm.com/products/processors/technologies/vector-floating-point.php

% from 8l(1) "Without this [-f] option, 5l generates arm7500 floating-point
% instructions which are emulated in the kernel."

<<[[ocmp()]] if floating point flag on p1 or p2>>=
n = (p2->flag&V4) - (p1->flag&V4);	/* architecture version */
if(n)
    return n;
n = (p2->flag&VFP) - (p1->flag&VFP);	/* floating point arch */
if(n)
    return n;
@

<<global vfp(arm)>>=
bool vfp;
@

% remove? and remove the relevant opcode also in optab? at least aspectize!
<<global armv4(arm)>>=
bool	armv4;
@

<<[[buildop()]] initializer floating flags>>=
armv4 = !debug['h'];
vfp = debug['f'];
@

<<[[buildop()]] adjust optab if floating flags>>=
if((optab[n].flag & VFP) && !vfp)
    optab[n].as = AXXX;
if((optab[n].flag & V4) && !armv4) {
    optab[n].as = AXXX;
    break;
}
@





<<[[ldobj()]] locals(arm)>>=
Prog *t;
@

<<[[ldobj()]] switch opcode cases(arm)>>=
case AMOVDF:
    if(!vfp || p->from.type != D_FCONST)
        goto casedef;
    p->as = AMOVF;
    /* fall through */
case AMOVF:
    if(skip)
        goto casedef;

    if(p->from.type == D_FCONST && chipfloat(p->from.ieee) < 0) {
        /* size sb 9 max */
        sprint(literal, "$%lux", ieeedtof(p->from.ieee));
        s = lookup(literal, 0);
        if(s->type == 0) {
            s->type = SBSS;
            s->value = 4;
            t = prg();
            t->as = ADATA;
            t->line = p->line;
            t->from.type = D_OREG;
            t->from.sym = s;
            t->from.symkind = N_EXTERN;
            t->reg = 4;
            t->to = p->from;
            t->link = datap;
            datap = t;
        }
        p->from.type = D_OREG;
        p->from.sym = s;
        p->from.symkind = N_EXTERN;
        p->from.offset = 0;
    }
    goto casedef;

case AMOVD:
    if(skip)
        goto casedef;

    if(p->from.type == D_FCONST && chipfloat(p->from.ieee) < 0) {
        /* size sb 18 max */
        sprint(literal, "$%lux.%lux",
            p->from.ieee->l, p->from.ieee->h);
        s = lookup(literal, 0);
        if(s->type == 0) {
            s->type = SBSS;
            s->value = 8;
            t = prg();
            t->as = ADATA;
            t->line = p->line;
            t->from.type = D_OREG;
            t->from.sym = s;
            t->from.symkind = N_EXTERN;
            t->reg = 8;
            t->to = p->from;
            t->link = datap;
            datap = t;
        }
        p->from.type = D_OREG;
        p->from.sym = s;
        p->from.symkind = N_EXTERN;
        p->from.offset = 0;
    }
    goto casedef;
@


<<global chipfloats(arm)>>=
static Ieee chipfloats[] = {
    {0x00000000, 0x00000000}, /* 0 */
    {0x00000000, 0x3ff00000}, /* 1 */
    {0x00000000, 0x40000000}, /* 2 */
    {0x00000000, 0x40080000}, /* 3 */
    {0x00000000, 0x40100000}, /* 4 */
    {0x00000000, 0x40140000}, /* 5 */
    {0x00000000, 0x3fe00000}, /* .5 */
    {0x00000000, 0x40240000}, /* 10 */
};
@
% ???

<<function chipfloat(arm)>>=
int
chipfloat(Ieee *e)
{
    Ieee *p;
    int n;

    if(vfp)
        return -1;
    for(n = sizeof(chipfloats)/sizeof(chipfloats[0]); --n >= 0;){
        p = &chipfloats[n];
        if(p->l == e->l && p->h == e->h)
            return n;
    }
    return -1;
}
@






<<[[noops()]] second pass switch opcode cases>>=
/*
 * 5c code generation for unsigned -> double made the
 * unfortunate assumption that single and double floating
 * point registers are aliased - true for emulated 7500
 * but not for vfp.  Now corrected, but this test is
 * insurance against old 5c compiled code in libraries.
 */
case AMOVWD:
    if((q = p->link) != P && q->as == ACMP)
     if((q = q->link) != P && q->as == AMOVF)
      if((q1 = q->link) != P && q1->as == AADDF)
       if(q1->to.type == D_FREG && q1->to.reg == p->to.reg) {
        q1->as = AADDD;
        q1 = prg();
        q1->scond = q->scond;
        q1->line = q->line;
        q1->as = AMOVFD;
        q1->from = q->to;
        q1->to = q1->from;
        q1->link = q->link;
        q->link = q1;
    }
    break;
@



<<[[datblk()]] other locals>>=
long fl;
@

<<[[datblk()]] switch type of destination cases>>=
case D_FCONST:
    switch(c) {
    default:
    case 4:
        fl = ieeedtof(p->to.ieee);
        cast = (char*)&fl;
        for(; i<c; i++) {
            buf.dbuf[l] = cast[fnuxi4[i]];
            l++;
        }
        break;
    case 8:
        cast = (char*)p->to.ieee;
        for(; i<c; i++) {
            buf.dbuf[l] = cast[fnuxi8[i]];
            l++;
        }
        break;
    }
    break;
@

\subsubsection{Common float instructions}


<<[[buildop()]] switch opcode r for ranges cases>>=
case AADDF:
    oprange[AADDD] = oprange[r];
    oprange[ASUBF] = oprange[r];
    oprange[ASUBD] = oprange[r];
    oprange[AMULF] = oprange[r];
    oprange[AMULD] = oprange[r];
    oprange[ADIVF] = oprange[r];
    oprange[ADIVD] = oprange[r];
    oprange[AMOVFD] = oprange[r];
    oprange[AMOVDF] = oprange[r];
    break;
    
case ACMPF:
    oprange[ACMPD] = oprange[r];
    break;

case AMOVF:
    oprange[AMOVD] = oprange[r];
    break;

case AMOVFW:
    oprange[AMOVWF] = oprange[r];
    oprange[AMOVWD] = oprange[r];
    oprange[AMOVDW] = oprange[r];
    break;
@

<<[[optab]] entries>>=
{ AMOVF,	C_FREG,	C_NONE,	C_FEXT,		50, 4, REGSB },
{ AMOVF,	C_FREG,	C_NONE,	C_FAUTO,	50, 4, REGSP },
{ AMOVF,	C_FREG,	C_NONE,	C_FOREG,	50, 4, 0 },

{ AMOVF,	C_FEXT,	C_NONE,	C_FREG,		51, 4, REGSB },
{ AMOVF,	C_FAUTO,C_NONE,	C_FREG,		51, 4, REGSP },
{ AMOVF,	C_FOREG,C_NONE,	C_FREG,		51, 4, 0 },

{ AMOVF,	C_FREG,	C_NONE,	C_LEXT,		52, 12, REGSB,	LTO },
{ AMOVF,	C_FREG,	C_NONE,	C_LAUTO,	52, 12, REGSP,	LTO },
{ AMOVF,	C_FREG,	C_NONE,	C_LOREG,	52, 12, 0,	LTO },

{ AMOVF,	C_LEXT,	C_NONE,	C_FREG,		53, 12, REGSB,	LFROM },
{ AMOVF,	C_LAUTO,C_NONE,	C_FREG,		53, 12, REGSP,	LFROM },
{ AMOVF,	C_LOREG,C_NONE,	C_FREG,		53, 12, 0,	LFROM },

{ AMOVF,	C_FREG,	C_NONE,	C_ADDR,		68, 8, 0,	LTO },
{ AMOVF,	C_ADDR,	C_NONE,	C_FREG,		69, 8, 0,	LFROM },

{ AADDF,	C_FREG,	C_NONE,	C_FREG,		54, 4, 0 },
{ AADDF,	C_FREG,	C_REG,	C_FREG,		54, 4, 0 },
{ AADDF,	C_FCON,	C_NONE,	C_FREG,		54, 4, 0 },
{ AADDF,	C_FCON,	C_REG,	C_FREG,		54, 4, 0 },
{ AMOVF,	C_FCON,	C_NONE,	C_FREG,		54, 4, 0 },
{ AMOVF,	C_FREG, C_NONE, C_FREG,		54, 4, 0 },

{ ACMPF,	C_FREG,	C_REG,	C_NONE,		54, 4, 0 },
{ ACMPF,	C_FCON,	C_REG,	C_NONE,		54, 4, 0 },

{ AMOVFW,	C_FREG,	C_NONE,	C_REG,		55, 4, 0 },
{ AMOVFW,	C_REG,	C_NONE,	C_FREG,		55, 4, 0 },
@



<<function regoff(arm)>>=
long
regoff(Adr *a)
{

    instoffset = 0;
    aclass(a);
    return instoffset;
}
@

<<[[asmout()]] switch on type cases>>=
case 50:	/* floating point store */
    v = regoff(&p->to);
    r = p->to.reg;
    if(r == R_NONE)
        r = o->param;
    o1 = ofsr(p->as, p->from.reg, v, r, p->scond, p);
    break;
@

%STC 6 << 25
<<function ofsr(arm)>>=
long
ofsr(int a, int r, long v, int b, int sc, Prog *p)
{
    long o;

    if(vfp)
        return ovfpmem(a, r, v, b, sc, p);

    o = (sc & C_SCOND) << 28;
    if(sc & C_SBIT)
        diag(".S on FLDR/FSTR instruction");
    if(!(sc & C_PBIT))
        o |= 1 << 24;
    if(sc & C_WBIT)
        o |= 1 << 21;
    o |= (6<<25) | (1<<24) | (1<<23);
    if(v < 0) {
        v = -v;
        o ^= 1 << 23;
    }
    if(v & 3)
        diag("odd offset for floating point op: %ld\n%P", v, p);
    else if(v >= (1<<10))
        diag("literal span too large: %ld\n%P", v, p);
    o |= (v>>2) & 0xFF;
    o |= b << 16;
    o |= r << 12;
    o |= 1 << 8;

    switch(a) {
    default:
        diag("bad fst %A", a);
    case AMOVD:
        o |= 1<<15;
    case AMOVF:
        break;
    }
    return o;
}
@
% >> >> >> >> >> >> >> >> >> >> >>



% LDC, 6 << 25 and 1 << 20
<<[[asmout()]] switch on type cases>>=
case 51:	/* floating point load */
    v = regoff(&p->from);
    r = p->from.reg;
    if(r == R_NONE)
        r = o->param;
    o1 = ofsr(p->as, p->to.reg, v, r, p->scond, p) | (1<<20);
    break;
@
% >>


% ADD ... STC
<<[[asmout()]] switch on type cases>>=
case 52:	/* floating point store, long offset UGLY */
    o1 = omvl(p, &p->to, REGTMP);
    if(!o1)
        break;
    r = p->to.reg;
    if(r == R_NONE)
        r = o->param;
    o2 = oprrr(AADD, p->scond) | (REGTMP << 12) | (REGTMP << 16) | r;
    o3 = ofsr(p->as, p->from.reg, 0, REGTMP, p->scond, p);
    break;
@
% >> >> >>

% ADD ... LTC
<<[[asmout()]] switch on type cases>>=
case 53:	/* floating point load, long offset UGLY */
    o1 = omvl(p, &p->from, REGTMP);
    if(!o1)
        break;
    r = p->from.reg;
    if(r == R_NONE)
        r = o->param;
    o2 = oprrr(AADD, p->scond) | (REGTMP << 12) | (REGTMP << 16) | r;
    o3 = ofsr(p->as, p->to.reg, 0, REGTMP, p->scond, p) | (1<<20);
    break;
@
% >> >> >>


<<[[oprrr()]] switch cases>>=
/* old arm 7500 fp using coprocessor 1 (1<<8) */
case AADDD:	return o | (0xe<<24) | (0x0<<20) | (1<<8) | (1<<7);
case AADDF:	return o | (0xe<<24) | (0x0<<20) | (1<<8);
case AMULD:	return o | (0xe<<24) | (0x1<<20) | (1<<8) | (1<<7);
case AMULF:	return o | (0xe<<24) | (0x1<<20) | (1<<8);
case ASUBD:	return o | (0xe<<24) | (0x2<<20) | (1<<8) | (1<<7);
case ASUBF:	return o | (0xe<<24) | (0x2<<20) | (1<<8);
case ADIVD:	return o | (0xe<<24) | (0x4<<20) | (1<<8) | (1<<7);
case ADIVF:	return o | (0xe<<24) | (0x4<<20) | (1<<8);
/* arguably, ACMPF should expand to RNDF, CMPD */
case ACMPD:
case ACMPF:	return o | (0xe<<24) | (0x9<<20) | (0xF<<12) | (1<<8) | (1<<4);	

case AMOVF:
case AMOVDF:	return o | (0xe<<24) | (0x0<<20) | (1<<15) | (1<<8);
case AMOVD:
case AMOVFD:	return o | (0xe<<24) | (0x0<<20) | (1<<15) | (1<<8) | (1<<7);

case AMOVWF:	return o | (0xe<<24) | (0<<20) | (1<<8) | (1<<4);
case AMOVWD:	return o | (0xe<<24) | (0<<20) | (1<<8) | (1<<4) | (1<<7);
case AMOVFW:	return o | (0xe<<24) | (1<<20) | (1<<8) | (1<<4);
case AMOVDW:	return o | (0xe<<24) | (1<<20) | (1<<8) | (1<<4) | (1<<7);
@
% >> >> >> >> >> >> >> >> >> >> >> >> >>
% >> >> >> >> >> >> >> >> >> >> >> >> >>
% >> >> >> >> >> >> >> >> >> >> >> >> >>
% >> >> >> >> >> >> >> >> >> >> >> >> >>
% >> >> >> >> >> >> >> >> >> >> >> >> >>
% >> >> >> >> >> >> >> >> >> >> >> >> >>
% 0xe << 24 => CDP instr, 1 << 8 => co processor 1




<<[[asmout()]] switch on type cases>>=
case 54:	/* floating point arith */
    o1 = oprrr(p->as, p->scond);
    if(p->from.type == D_FCONST) {
        rf = chipfloat(p->from.ieee);
        if(rf < 0){
            diag("invalid floating-point immediate\n%P", p);
            rf = 0;
        }
        rf |= (1<<3);
    } else
        rf = p->from.reg;
    rt = p->to.reg;
    r = p->reg;
    if(p->to.type == D_NONE)
        rt = 0;	/* CMP[FD] */
    else if(o1 & (1<<15))
        r = 0;	/* monadic */
    else if(r == R_NONE)
        r = rt;
    o1 |= rf | (r<<16) | (rt<<12);
    break;
@
% >> >> >> >> >>

<<[[asmout()]] switch on type cases>>=
case 55:	/* floating point fix and float */
    o1 = oprrr(p->as, p->scond);
    rf = p->from.reg;
    rt = p->to.reg;
    if(p->to.type == D_NONE){
        rt = 0;
        diag("to.type==D_NONE (asm/fp)");
    }
    if(p->from.type == D_REG)
        o1 |= (rf<<12) | (rt<<16);
    else
        o1 |= rf | (rt<<12);
    break;
@
% >> >> >> >>



<<[[asmout()]] switch on type cases>>=
case 68:	/* floating point store -> ADDR */
    o1 = omvl(p, &p->to, REGTMP);
    if(!o1)
        break;
    o2 = ofsr(p->as, p->from.reg, 0, REGTMP, p->scond, p);
    break;
@
<<[[asmout()]] switch on type cases>>=
case 69:	/* floating point load <- ADDR */
    o1 = omvl(p, &p->from, REGTMP);
    if(!o1)
        break;
    o2 = ofsr(p->as, p->to.reg, 0, REGTMP, p->scond, p) | (1<<20);
    break;
@
% >> >> >>

\subsubsection{VFP hardware instructions, [[5l -f]]}



<<function ovfpmem(arm)>>=
long
ovfpmem(int a, int r, long v, int b, int sc, Prog *p)
{
    long o;

    o = (sc & C_SCOND) << 28;
    if(sc & (C_SBIT|C_PBIT|C_WBIT))
        diag(".S/.P/.W on VLDR/VSTR instruction");
    o |= 0xd<<24 | (1<<23);
    if(v < 0) {
        v = -v;
        o ^= 1 << 23;
    }
    if(v & 3)
        diag("odd offset for floating point op: %ld\n%P", v, p);
    else if(v >= (1<<10))
        diag("literal span too large: %ld\n%P", v, p);
    o |= (v>>2) & 0xFF;
    o |= b << 16;
    o |= r << 12;
    switch(a) {
    default:
        diag("bad fst %A", a);
    case AMOVD:
        o |= 0xb<<8;
        break;
    case AMOVF:
        o |= 0xa<<8;
        break;
    }
    return o;
}
@
% >> >> >> >> >> >> >> >> 




<<[[optab]] entries>>=
{ AADDF,	C_FREG,	C_NONE,	C_FREG,		74, 4, 0, VFP },
{ AADDF,	C_FREG,	C_REG,	C_FREG,		74, 4, 0, VFP },
{ AMOVF,	C_FREG, C_NONE, C_FREG,		74, 4, 0, VFP },
{ ACMPF,	C_FREG,	C_REG,	C_NONE,		75, 8, 0, VFP },
{ ACMPF,	C_FCON,	C_REG,	C_NONE,		75, 8, 0, VFP },
{ AMOVFW,	C_FREG,	C_NONE,	C_REG,		76, 8, 0, VFP },
{ AMOVFW,	C_REG,	C_NONE,	C_FREG,		76, 8, 0, VFP },
@
% remember those are ranges!

<<[[asmout()]] switch on type cases>>=
/* VFP ops: */
case 74:	/* vfp floating point arith */
    o1 = opvfprrr(p->as, p->scond);
    rf = p->from.reg;
    if(p->from.type == D_FCONST) {
        diag("invalid floating-point immediate\n%P", p);
        rf = 0;
    }
    rt = p->to.reg;
    r = p->reg;
    if(r == R_NONE)
        r = rt;
    o1 |= rt<<12;
    if(((o1>>20)&0xf) == 0xb)
        o1 |= rf<<0;
    else
        o1 |= r<<16 | rf<<0;
    break;
@
% >> >> >>

<<[[asmout()]] switch on type cases>>=
case 75:	/* vfp floating point compare */
    o1 = opvfprrr(p->as, p->scond);
    rf = p->from.reg;
    if(p->from.type == D_FCONST) {
        if(p->from.ieee->h != 0 || p->from.ieee->l != 0)
            diag("invalid floating-point immediate\n%P", p);
        o1 |= 1<<16;
        rf = 0;
    }
    rt = p->reg;
    o1 |= rt<<12 | rf<<0;
    o2 = 0x0ef1fa10;	/* MRS APSR_nzcv, FPSCR */
    o2 |= (p->scond & C_SCOND) << 28;
    break;
@
% >> >> >> >>

<<[[asmout()]] switch on type cases>>=
case 76:	/* vfp floating point fix and float */
    o1 = opvfprrr(p->as, p->scond);
    rf = p->from.reg;
    rt = p->to.reg;
    if(p->from.type == D_REG) {
        o2 = o1 | rt<<12 | rt<<0;
        o1 = 0x0e000a10;	/* VMOV F,R */
        o1 |= (p->scond & C_SCOND) << 28 | rt<<16 | rf<<12;
    } else {
        o1 |= FREGTMP<<12 | rf<<0;
        o2 = 0x0e100a10;	/* VMOV R,F */
        o2 |= (p->scond & C_SCOND) << 28 | FREGTMP<<16 | rt<<12;
    }
    break;
@
%$
% >> >> >> >> >> >> >> >> >> >>



<<function opvfprrr(arm)>>=
long
opvfprrr(int a, int sc)
{
    long o;

    o = (sc & C_SCOND) << 28;
    if(sc & (C_SBIT|C_PBIT|C_WBIT))
        diag(".S/.P/.W on vfp instruction");
    o |= 0xe<<24;
    switch(a) {
    case AMOVWD:	return o | 0xb<<8 | 0xb<<20 | 1<<6 | 0x8<<16 | 1<<7;
    case AMOVWF:	return o | 0xa<<8 | 0xb<<20 | 1<<6 | 0x8<<16 | 1<<7;
    case AMOVDW:	return o | 0xb<<8 | 0xb<<20 | 1<<6 | 0xD<<16 | 1<<7;
    case AMOVFW:	return o | 0xa<<8 | 0xb<<20 | 1<<6 | 0xD<<16 | 1<<7;
    case AMOVFD:	return o | 0xa<<8 | 0xb<<20 | 1<<6 | 0x7<<16 | 1<<7;
    case AMOVDF:	return o | 0xb<<8 | 0xb<<20 | 1<<6 | 0x7<<16 | 1<<7;
    case AMOVF:	return o | 0xa<<8 | 0xb<<20 | 1<<6 | 0x0<<16 | 0<<7;
    case AMOVD:	return o | 0xb<<8 | 0xb<<20 | 1<<6 | 0x0<<16 | 0<<7;
    case ACMPF:	return o | 0xa<<8 | 0xb<<20 | 1<<6 | 0x4<<16 | 0<<7;
    case ACMPD:	return o | 0xb<<8 | 0xb<<20 | 1<<6 | 0x4<<16 | 0<<7;
    case AADDF:	return o | 0xa<<8 | 0x3<<20;
    case AADDD:	return o | 0xb<<8 | 0x3<<20;
    case ASUBF:	return o | 0xa<<8 | 0x3<<20 | 1<<6;
    case ASUBD:	return o | 0xb<<8 | 0x3<<20 | 1<<6;
    case AMULF:	return o | 0xa<<8 | 0x2<<20;
    case AMULD:	return o | 0xb<<8 | 0x2<<20;
    case ADIVF:	return o | 0xa<<8 | 0x8<<20;
    case ADIVD:	return o | 0xb<<8 | 0x8<<20;
    }
    diag("bad vfp rrr %d", a);
    prasm(curp);
    return 0;
}
@
% >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >>
% >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >>
% >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >>
% >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >>



\subsubsection{Kernel emulation}



<<[[optab]] entries>>=
{ AMOVW,	C_REG,	C_NONE,	C_FCR,		56, 4, 0 },
{ AMOVW,	C_FCR,	C_NONE,	C_REG,		57, 4, 0 },
@

<<[[asmout()]] switch on type cases>>=
/* old arm 7500 fp using coprocessor 1 (1<<8) */
case 56:	/* move to FP[CS]R */
    o1 = ((p->scond & C_SCOND) << 28) | (0xe << 24) | (1<<8) | (1<<4);
    o1 |= ((p->to.reg+1)<<21) | (p->from.reg << 12);
    break;
@
% >> >> >> >> >> >> >>
<<[[asmout()]] switch on type cases>>=
case 57:	/* move from FP[CS]R */
    o1 = ((p->scond & C_SCOND) << 28) | (0xe << 24) | (1<<8) | (1<<4);
    o1 |= ((p->from.reg+1)<<21) | (p->to.reg<<12) | (1<<20);
    break;
@
% >> >> >> >> >> >> >> >



%from bcm/arm.h
%#define CpOFPA		1			/* ancient 7500 FPA */
% => use coprocessor 1

% "without -f 5l generates arm7500 floating-point
% instructions which are emulated in the kernel."

% see bcm/fpiarm.c

<<[[optab]] entries>>=
{ AMOVH,	C_REG,	C_NONE,	C_HEXT,		70, 4, REGSB,	V4 },
{ AMOVH,	C_REG,	C_NONE, C_HAUTO,	70, 4, REGSP,	V4 },
{ AMOVH,	C_REG,	C_NONE,	C_HOREG,	70, 4, 0,		V4 },
{ AMOVHU,	C_REG,	C_NONE,	C_HEXT,		70, 4, REGSB,	V4 },
{ AMOVHU,	C_REG,	C_NONE, C_HAUTO,	70, 4, REGSP,	V4 },
{ AMOVHU,	C_REG,	C_NONE,	C_HOREG,	70, 4, 0,		V4 },

{ AMOVB,	C_HEXT,	C_NONE, C_REG,		71, 4, REGSB,	V4 },
{ AMOVB,	C_HAUTO,C_NONE,	C_REG,		71, 4, REGSP,	V4 },
{ AMOVB,	C_HOREG,C_NONE,	C_REG,		71, 4, 0,		V4 },
{ AMOVH,	C_HEXT,	C_NONE,	C_REG,		71, 4, REGSB,	V4 },
{ AMOVH,	C_HAUTO,C_NONE, C_REG,		71, 4, REGSP,	V4 },
{ AMOVH,	C_HOREG,C_NONE,	C_REG,		71, 4, 0,		V4 },
{ AMOVHU,	C_HEXT,	C_NONE,	C_REG,		71, 4, REGSB,	V4 },
{ AMOVHU,	C_HAUTO,C_NONE, C_REG,		71, 4, REGSP,	V4 },
{ AMOVHU,	C_HOREG,C_NONE,	C_REG,		71, 4, 0,		V4 },

{ AMOVH,	C_REG,	C_NONE,	C_LEXT,		72, 8, REGSB,	LTO|V4 },
{ AMOVH,	C_REG,	C_NONE, C_LAUTO,	72, 8, REGSP,	LTO|V4 },
{ AMOVH,	C_REG,	C_NONE,	C_LOREG,	72, 8, 0,		LTO|V4 },
{ AMOVHU,	C_REG,	C_NONE,	C_LEXT,		72, 8, REGSB,	LTO|V4 },
{ AMOVHU,	C_REG,	C_NONE, C_LAUTO,	72, 8, REGSP,	LTO|V4 },
{ AMOVHU,	C_REG,	C_NONE,	C_LOREG,	72, 8, 0,		LTO|V4 },

{ AMOVB,	C_LEXT,	C_NONE, C_REG,		73, 8, REGSB,	LFROM|V4 },
{ AMOVB,	C_LAUTO,C_NONE,	C_REG,		73, 8, REGSP,	LFROM|V4 },
{ AMOVB,	C_LOREG,C_NONE,	C_REG,		73, 8, 0,		LFROM|V4 },
{ AMOVH,	C_LEXT,	C_NONE,	C_REG,		73, 8, REGSB,	LFROM|V4 },
{ AMOVH,	C_LAUTO,C_NONE, C_REG,		73, 8, REGSP,	LFROM|V4 },
{ AMOVH,	C_LOREG,C_NONE,	C_REG,		73, 8, 0,		LFROM|V4 },
{ AMOVHU,	C_LEXT,	C_NONE,	C_REG,		73, 8, REGSB,	LFROM|V4 },
{ AMOVHU,	C_LAUTO,C_NONE, C_REG,		73, 8, REGSP,	LFROM|V4 },
{ AMOVHU,	C_LOREG,C_NONE,	C_REG,		73, 8, 0,		LFROM|V4 },
@

<<[[asmout()]] switch on type cases>>=
/* ArmV4 ops: */
case 70:	/* movh/movhu R,O(R) -> strh */
    aclass(&p->to);
    r = p->to.reg;
    if(r == R_NONE)
        r = o->param;
    o1 = oshr(p->from.reg, instoffset, r, p->scond);
    break;	
@
<<[[asmout()]] switch on type cases>>=
case 71:	/* movb/movh/movhu O(R),R -> ldrsb/ldrsh/ldrh */
    aclass(&p->from);
    r = p->from.reg;
    if(r == R_NONE)
        r = o->param;
    o1 = olhr(instoffset, r, p->to.reg, p->scond);
    if(p->as == AMOVB)
        o1 ^= (1<<5)|(1<<6);
    else if(p->as == AMOVH)
        o1 ^= (1<<6);
    break;
@
% >> >>  >>

<<[[asmout()]] switch on type cases>>=
case 72:	/* movh/movhu R,L(R) -> strh */
    o1 = omvl(p, &p->to, REGTMP);
    if(!o1)
        break;
    r = p->to.reg;
    if(r == R_NONE)
        r = o->param;
    o2 = oshrr(p->from.reg, REGTMP,r, p->scond);
    break;	
@

<<[[asmout()]] switch on type cases>>=
case 73:	/* movb/movh/movhu L(R),R -> ldrsb/ldrsh/ldrh */
    o1 = omvl(p, &p->from, REGTMP);
    if(!o1)
        break;
    r = p->from.reg;
    if(r == R_NONE)
        r = o->param;
    o2 = olhrr(REGTMP, r, p->to.reg, p->scond);
    if(p->as == AMOVB)
        o2 ^= (1<<5)|(1<<6);
    else if(p->as == AMOVH)
        o2 ^= (1<<6);
    break;
@
% >> >> >>


<<function olhr(arm)>>=
long
olhr(long v, int b, int r, int sc)
{
    long o;

    o = (sc & C_SCOND) << 28;
    if(sc & C_SBIT)
        diag(".S on LDRH/STRH instruction");

    if(!(sc & C_PBIT))
        o |= 1 << 24;
    if(sc & C_WBIT)
        o |= 1 << 21;
    o |= (1<<23) | (1<<20)|(0xb<<4);
    if(v < 0) {
        v = -v;
        o ^= 1 << 23;
    }
    if(v >= (1<<8))
        diag("literal span too large: %ld (R%d)\n%P", v, b, PP);
    o |= (v&0xf)|((v>>4)<<8)|(1<<22);
    o |= b << 16;
    o |= r << 12;
    return o;
}
@
% >> >> >> >> >> >> >> >> >> >> >> >>

<<function osr(arm)>>=
long
osr(int a, int r, long v, int b, int sc)
{
    long o;

    o = olr(v, b, r, sc) ^ (1<<20);
    if(a != AMOVW)
        o |= 1<<22;
    return o;
}
@
% >> >> >> >>

<<function oshr(arm)>>=
long
oshr(int r, long v, int b, int sc)
{
    long o;

    o = olhr(v, b, r, sc) ^ (1<<20);
    return o;
}
@
% >>


<<function osrr(arm)>>=
long
osrr(int r, int i, int b, int sc)
{

    return olr(i, b, r, sc) ^ ((1<<25) | (1<<20));
}
@
% >> >>

<<function oshrr(arm)>>=
long
oshrr(int r, int i, int b, int sc)
{
    return olhr(i, b, r, sc) ^ ((1<<22) | (1<<20));
}
@
% >> >>

<<function olrr(arm)>>=
long
olrr(int i, int b, int r, int sc)
{

    return olr(i, b, r, sc) ^ (1<<25);
}
@
% >>

<<function olhrr(arm)>>=
long
olhrr(int i, int b, int r, int sc)
{
    return olhr(i, b, r, sc) ^ (1<<22);
}
@
% >>



\subsection{Division instructions}
\label{sec:div-mod}

% like for floats, different options

\subsubsection{[[ADIV]] rewriting}

%    /* MOV a,4(SP) */
%    /* MOV b,REGTMP */
%    /* CALL appropriate */
%    /* MOV REGTMP, b */
%    /* ADD $8,SP */
%q1
%    /* SUB $8,SP */

<<[[noops()]] second pass switch opcode cases>>=
case ADIV:
case ADIVU:
case AMOD:
case AMODU:
    <<[[noops()]] second pass, ADIV rewrite, case ADIV and so on, if -M>>
    if(p->from.type != D_REG)
        break;
    if(p->to.type != D_REG)
        break;
    // else
    q1 = p;

    q = prg();
    q->link = p->link;
    p->link = q;
    p = q;

    /* MOV a,4(SP) */
    p->as = AMOVW;
    p->line = q1->line;
    p->from.type = D_REG;
    p->from.reg = q1->from.reg;
    p->to.type = D_OREG;
    p->to.reg = REGSP;
    p->to.offset = 4;

    q = prg();
    q->link = p->link;
    p->link = q;
    p = q;

    /* MOV b,REGTMP */
    p->as = AMOVW;
    p->line = q1->line;
    p->from.type = D_REG;
    p->from.reg = q1->reg;
    if(q1->reg == R_NONE)
        p->from.reg = q1->to.reg;
    p->to.type = D_REG;
    p->to.reg = REGTMP;
    p->to.offset = 0;

    q = prg();
    q->link = p->link;
    p->link = q;
    p = q;

    /* CALL appropriate */
    p->as = ABL;
    p->line = q1->line;
    p->to.type = D_BRANCH;
    p->cond = p;
    switch(o) {
    case ADIV:
        p->cond = prog_div;
        p->to.sym = sym_div;
        break;
    case ADIVU:
        p->cond = prog_divu;
        p->to.sym = sym_divu;
        break;
    case AMOD:
        p->cond = prog_mod;
        p->to.sym = sym_mod;
        break;
    case AMODU:
        p->cond = prog_modu;
        p->to.sym = sym_modu;
        break;
    }

    q = prg();
    q->link = p->link;
    p->link = q;
    p = q;

    /* MOV REGTMP, b */
    p->as = AMOVW;
    p->line = q1->line;
    p->from.type = D_REG;
    p->from.reg = REGTMP;
    p->from.offset = 0;
    p->to.type = D_REG;
    p->to.reg = q1->to.reg;

    q = prg();
    q->link = p->link;
    p->link = q;
    p = q;

    /* ADD $8,SP */
    p->as = AADD;
    p->from.type = D_CONST;
    p->from.reg = R_NONE;
    p->from.offset = 8;
    p->reg = R_NONE;
    p->to.type = D_REG;
    p->to.reg = REGSP;

    /* SUB $8,SP */
    q1->as = ASUB;
    q1->from.type = D_CONST;
    q1->from.offset = 8;
    q1->from.reg = R_NONE;
    q1->reg = R_NONE;
    q1->to.type = D_REG;
    q1->to.reg = REGSP;
    break;
@

% for -M, in 8l(1):
% "Generate instructions rather than calls to emulation routines
% for multiply and divide."

<<global prog_div(arm)>>=
Prog*	prog_div;
@

<<global prog_divu(arm)>>=
Prog*	prog_divu;
@

<<global prog_mod(arm)>>=
Prog*	prog_mod;
@

<<global prog_modu(arm)>>=
Prog*	prog_modu;
@


\subsubsection{[[initdiv()]]}

<<global sym_div(arm)>>=
static	Sym*	sym_div;
@

<<global sym_divu(arm)>>=
static	Sym*	sym_divu;
@

<<global sym_mod(arm)>>=
static	Sym*	sym_mod;
@

<<global sym_modu(arm)>>=
static	Sym*	sym_modu;
@


<<constant SIGNINTERN(arm)>>=
#define SIGNINTERN	(1729*325*1729)
@

<<function sigdiv(arm)>>=
static void
sigdiv(char *n)
{
    Sym *s;

    s = lookup(n, 0);
    if(s->type == STEXT){
        if(s->sig == 0)
            s->sig = SIGNINTERN;
    }
    else if(s->type == SNONE || s->type == SXREF)
        s->type = SUNDEF;
}
@

<<function divsig(arm)>>=
void
divsig(void)
{
    sigdiv("_div");
    sigdiv("_divu");
    sigdiv("_mod");
    sigdiv("_modu");
}
@

<<function sdiv(arm)>>=
static void
sdiv(Sym *s)
{
    if(s->type == SNONE || s->type == SXREF){
        /* undefsym(s); */
        s->type = SXREF;
        if(s->sig == 0)
            s->sig = SIGNINTERN;
        s->subtype = SIMPORT;
    }
    else if(s->type != STEXT)
        diag("undefined: %s", s->name);
}
@

<<function initdiv(arm)>>=
void
initdiv(void)
{
    Sym *s2, *s3, *s4, *s5;
    Prog *p;

    if(prog_div != P)
        return;
    sym_div = s2 = lookup("_div", 0);
    sym_divu = s3 = lookup("_divu", 0);
    sym_mod = s4 = lookup("_mod", 0);
    sym_modu = s5 = lookup("_modu", 0);
    if(dlm) {
        sdiv(s2); if(s2->type == SXREF) prog_div = UP;
        sdiv(s3); if(s3->type == SXREF) prog_divu = UP;
        sdiv(s4); if(s4->type == SXREF) prog_mod = UP;
        sdiv(s5); if(s5->type == SXREF) prog_modu = UP;
    }
    for(p = firstp; p != P; p = p->link)
        if(p->as == ATEXT) {
            if(p->from.sym == s2)
                prog_div = p;
            if(p->from.sym == s3)
                prog_divu = p;
            if(p->from.sym == s4)
                prog_mod = p;
            if(p->from.sym == s5)
                prog_modu = p;
        }
    if(prog_div == P) {
        diag("undefined: %s", s2->name);
        prog_div = curtext;
    }
    if(prog_divu == P) {
        diag("undefined: %s", s3->name);
        prog_divu = curtext;
    }
    if(prog_mod == P) {
        diag("undefined: %s", s4->name);
        prog_mod = curtext;
    }
    if(prog_modu == P) {
        diag("undefined: %s", s5->name);
        prog_modu = curtext;
    }
}
@




<<[[noops()]] first pass switch opcode cases>>=
case ADIV:
case ADIVU:
case AMOD:
case AMODU:
    if(prog_div == P)
        initdiv();
    if(curtext != P)
        curtext->mark &= ~LEAF;
    continue; // no q = p;
@
% a bit ugly to do the initdiv here? at the same it's related to
% this notion of NOOP.


\subsubsection{Kernel emulation, [[5l -M]]}
% can access coprocessor from regular programs? so need syscall for float op?
% argh.

<<[[noops()]] second pass, ADIV rewrite, case ADIV and so on, if -M>>=
if(debug['M'])
    break;
@
% if -M then break in noops and so does not rewrite the ADIV
% and so the code below becomes reachable

<<[[buildop()]] switch opcode r for ranges cases>>=
case ADIV:
    oprange[AMOD] = oprange[r];
    oprange[AMODU] = oprange[r];
    oprange[ADIVU] = oprange[r];
    break;
@

<<[[optab]] entries>>=
{ ADIV,		C_REG,	C_REG,	C_REG,		16, 4, 0 },
{ ADIV,		C_REG,	C_NONE,	C_REG,		16, 4, 0 },
@
% hmm but noops should have rewrite them no? not if used
% also 5l -M

<<[[asmout()]] switch on type cases>>=
case 16:	/* div r,[r,]r */
    o1 = 0xf << 28;
    o2 = 0;
    break;
@
% 0xf? SWI? o2 = 0 ?? illegal instruction? so kernel trap?
% >>
% anyway will not use o2 ... since size is 4

\subsection{Multiple registers instructions}

% used by RFE

<<[[buildop()]] switch opcode r for ranges cases>>=
case AMOVM:
    break;
@

<<[[optab]] entries>>=
{ AMOVM,	C_LCON,	C_NONE,	C_SOREG,	38, 4, 0 },
{ AMOVM,	C_SOREG,C_NONE,	C_LCON,		39, 4, 0 },
@

<<[[asmout()]] switch on type cases>>=
case 38:	/* movm $con,oreg -> stm */
    o1 = (0x4 << 25);
    o1 |= p->from.offset & 0xffff;
    o1 |= p->to.reg << 16;
    aclass(&p->to);
    goto movm;
@
%$

<<[[asmout()]] switch on type cases>>=
case 39:	/* movm oreg,$con -> ldm */
    o1 = (0x4 << 25) | (1 << 20);
    o1 |= p->to.offset & 0xffff;
    o1 |= p->from.reg << 16;
    aclass(&p->from);
movm:
    if(instoffset != 0)
        diag("offset must be zero in MOVM");
    o1 |= (p->scond & C_SCOND) << 28;
    if(p->scond & C_PBIT)
        o1 |= 1 << 24;
    if(p->scond & C_UBIT)
        o1 |= 1 << 23;
    if(p->scond & C_SBIT)
        o1 |= 1 << 22;
    if(p->scond & C_WBIT)
        o1 |= 1 << 21;
    break;
@
%$


\section{Compiler-only pseudo opcodes}

<<[[buildop()]] switch opcode r for ranges cases>>=
case ACASE:
case ABCASE:
    break;
@

<<[[optab]] entries>>=
{ ACASE,	C_REG,	C_NONE,	C_NONE,		62, 4, 0 },
{ ABCASE,	C_NONE, C_NONE, C_BRANCH,   63, 4, 0 },
@


<<[[asmout()]] switch on type cases>>=
case 62:	/* case R -> movw	R<<2(PC),PC */
    o1 = olrr(p->from.reg, REGPC, REGPC, p->scond);
    o1 |= 2<<7;
    break;
@
% >>  >>

<<[[asmout()]] switch on type cases>>=
case 63:	/* bcase */
    if(p->cond != P) {
        o1 = p->cond->pc;
        if(dlm)
            dynreloc(S, p->pc, 1);
    }
    break;
@


\section{[[5l -E digits]]}
\l remove? used by who? useful feature? for -E0x7c00 ?

<<[[main()]] if rare condition do not set SXREF for INITENTRY, else>>=
if(*INITENTRY >= '0' && *INITENTRY <= '9') {}
else
@

<<[[entryvalue()]] if digit INITENTRY>>=
if(*a >= '0' && *a <= '9')
    return atolwhex(a);
@


\section{Strings in text segment, [[5l -t]]}

% what for? so cannot be modified? text is marked as writable
%  in Kernel.nw?
% for constant strings? 
% an optimisation?

% Section

<<[[Section]] cases>>=
SSTRING, // arm
@


<<[[dodata()]] if string in text segment>>=
if(debug['t']) {
    /*
     * pull out string constants
     */
    for(p = datap; p != P; p = p->link) {
        s = p->from.sym;
        if(p->to.type == D_SCONST)
            s->type = SSTRING;
    }
}
@

% Layout


<<[[dotext()]] other locals>>=
Sym *s;
long v;
int i;
@

% after has layout all the TEXT instrs, can put behind the strings.
<<[[dotext()]] if string in text segment>>=
if(debug['t']) {
    /* 
     * add strings to text segment
     */
    c = rnd(c, 8);
    for(i=0; i<NHASH; i++)
     for(s = hash[i]; s != S; s = s->link)
      if(s->type == SSTRING) {
          v = s->value;
          v = rnd(v, 4);
          s->value = c;
          c += v;
      }
}
@
%old:
%          while(v & 3)
%              v++;

% Code generation

<<[[asmb()]] locals>>=
long etext;
@

% it's an opti? need that? put later?
<<[[asmb()]] Text section, output strings in text segment>>=
/* output strings in text segment */
etext = INITTEXT + textsize;
for(t = pc; t < etext; t += sizeof(buf)-100) {
    if(etext-t > sizeof(buf)-100)
        datblk(t, sizeof(buf)-100, true);
    else
        datblk(t, etext-t, true);
@




\chapter{Conclusion}

%dup: (and adapted) from Assembler.nw
You now know how the \plan ARM linker [[5l]] works,
to the smallest details, and more generally how many 
linkers works.

\l next step? kernel/loader. 
\l debugger which uses libmach. profiler.









\appendix

\chapter{Debugging}
\label{chap:debugging-appendix}

%\section{[[debug]]}

% hmm actually it's used not just for debugging but also for generic
% options, e.g. for -l, -p, etc in addition to the main use which is -v
<<global debug>>=
bool	debug[128];
@
% why not 256 like in Assembler.nw?

<<[[main()]] command line processing(arm)>>=
default:
    c = ARGC();
    if(c >= 0 && c < sizeof(debug))
        debug[c]++;
    break;
@



% -A, see diag()

%bso? 
<<global bso>>=
Biobuf	bso;
@


<<[[main()]] debug initialization(arm)>>=
Binit(&bso, 1, OWRITE);
listinit(); // fmtinstall()
@
%x86: memset(debug, false, sizeof(debug));


\section{Fmt}
\label{sec:dumpers}

% dupe with Compiler.nw

% why called listinit??


<<function listinit(arm)>>=
void
listinit(void)
{

    fmtinstall('A', Aconv);
    fmtinstall('C', Cconv);
    fmtinstall('D', Dconv);
    fmtinstall('P', Pconv);
    fmtinstall('S', Sconv);
    fmtinstall('N', Nconv);
}
@

\subsection{Instruction dumper, [[Pconv()]]}

% Pconv, Prog print

<<function prasm(arm)>>=
void
prasm(Prog *p)
{
    print("%P\n", p);
}
@


<<constant STRINGSZ>>=
STRINGSZ	= 200,
@


<<function Pconv(arm)>>=
// Prog -> string
int
Pconv(Fmt *fp)
{
    char str[STRINGSZ], *s;
    Prog *p;
    int a;

    p = va_arg(fp->args, Prog*);
    curp = p;
    a = p->as;

    switch(a) {
    case ASWPW:
    case ASWPBU:
        sprint(str, "(%ld)	%A%C	R%d,%D,%D",
            p->line, a, p->scond, p->reg, &p->from, &p->to);
        break;

    case ADATA:

    case AINIT:
    case ADYNT:
        sprint(str, "(%ld)	%A%C	%D/%d,%D",
            p->line, a, p->scond, &p->from, p->reg, &p->to);
        break;

    default:
        s = str;
        s += sprint(s, "(%ld)", p->line);
        if(p->reg == R_NONE)
            sprint(s, "	%A%C	%D,%D",
                a, p->scond, &p->from, &p->to);
        else
        if(p->from.type != D_FREG)
            sprint(s, "	%A%C	%D,R%d,%D",
                a, p->scond, &p->from, p->reg, &p->to);
        else
            sprint(s, "	%A%C	%D,F%d,%D",
                a, p->scond, &p->from, p->reg, &p->to);
        break;

    }
    return fmtstrcpy(fp, str);
}
@


\subsection{Opcode dumper, [[Aconv()]]}

% Aconv because Axxx


% defined in ../5c/enam.c, coupling with enum as in 5.out.h
% extern	char*	anames[];

<<function Aconv(arm)>>=
// enum<Opcode> -> string
int
Aconv(Fmt *fp)
{
    char *s;
    int a;

    a = va_arg(fp->args, int);
    s = "???";
    if(a >= AXXX && a < ALAST)
        s = anames[a];
    return fmtstrcpy(fp, s);
}
@


\subsection{Operand dumper, [[Dconv()]]}

% Dconv Dxxx

<<function Dconv(arm)>>=
// Adr -> string
int
Dconv(Fmt *fp)
{
    char str[STRINGSZ];
    char *op;
    Adr *a;
    long v;

    a = va_arg(fp->args, Adr*);
    switch(a->type) {

    case D_NONE:
        str[0] = '\0';
        if(a->symkind != D_NONE || a->reg != R_NONE || a->sym != S)
            sprint(str, "%N(R%d)(NONE)", a, a->reg);
        break;

    case D_CONST:
        if(a->reg == R_NONE)
            sprint(str, "$%N", a);
        else
            sprint(str, "$%N(R%d)", a, a->reg);
        break;

    case D_SHIFT:
        v = a->offset;
        op = "<<>>->@>" + (((v>>5) & 3) << 1);
        if(v & (1<<4))
            sprint(str, "R%ld%c%cR%ld", v&15, op[0], op[1], (v>>8)&15);
        else
            sprint(str, "R%ld%c%c%ld", v&15, op[0], op[1], (v>>7)&31);
        if(a->reg != R_NONE)
            sprint(str+strlen(str), "(R%d)", a->reg);
        break;

    case D_OREG:
        if(a->reg != R_NONE)
            sprint(str, "%N(R%d)", a, a->reg);
        else
            sprint(str, "%N", a);
        break;

    case D_REG:
        sprint(str, "R%d", a->reg);
        if(a->symkind != D_NONE || a->sym != S)
            sprint(str, "%N(R%d)(REG)", a, a->reg);
        break;

    case D_REGREG:
        sprint(str, "(R%d,R%d)", a->reg, (int)a->offset);
        if(a->symkind != D_NONE || a->sym != S)
            sprint(str, "%N(R%d)(REG)", a, a->reg);
        break;

    case D_FREG:
        sprint(str, "F%d", a->reg);
        if(a->symkind != D_NONE || a->sym != S)
            sprint(str, "%N(R%d)(REG)", a, a->reg);
        break;

    case D_PSR:
        switch(a->reg) {
        case 0:
            sprint(str, "CPSR");
            break;
        case 1:
            sprint(str, "SPSR");
            break;
        default:
            sprint(str, "PSR%d", a->reg);
            break;
        }
        if(a->symkind != D_NONE || a->sym != S)
            sprint(str, "%N(PSR%d)(REG)", a, a->reg);
        break;

    case D_FPCR:
        switch(a->reg){
        case 0:
            sprint(str, "FPSR");
            break;
        case 1:
            sprint(str, "FPCR");
            break;
        default:
            sprint(str, "FCR%d", a->reg);
            break;
        }
        if(a->symkind != D_NONE || a->sym != S)
            sprint(str, "%N(FCR%d)(REG)", a, a->reg);

        break;

    case D_BRANCH:	/* botch */
        if(curp->cond != P) {
            v = curp->cond->pc;
            if(a->sym != S)
                sprint(str, "{%s}%.5lux(BRANCH)", a->sym->name, v);
            else
                sprint(str, "%.5lux(BRANCH)", v);
        } else
            if(a->sym != S)
                sprint(str, "{%s}%ld(APC)", a->sym->name, a->offset);
            else
                sprint(str, "%ld(APC)", a->offset);
        break;

    case D_FCONST:
        sprint(str, "$%e", ieeedtod(a->ieee));
        break;

    case D_SCONST:
        sprint(str, "$\"%S\"", a->sval);
        break;

    default:
        sprint(str, "GOK-type(%d)", a->type);
        break;

    }
    return fmtstrcpy(fp, str);
}
@
%pad: I put braces around symbol name to better indicate they are comments now

%old:
%    case D_OCONST:
%        sprint(str, "$*$%N", a);
%        if(a->reg != R_NONE)
%            sprint(str, "%N(R%d)(CONST)", a, a->reg);
%        break;


%TODO
%\subsection{Operand class dumper, [[??conv()]]}



\subsection{Symbol kind dumper, [[Nconv()]]}

% Nxxx so Nconv
%old: was actually some D_xxx but I renamed them N_xxx


<<function Nconv(arm)>>=
int
Nconv(Fmt *fp)
{
    char str[STRINGSZ];
    Adr *a;
    Sym *s;

    a = va_arg(fp->args, Adr*);
    s = a->sym;

    switch(a->symkind) {
    case N_NONE:
        sprint(str, "%ld", a->offset);
        break;

    case N_EXTERN:
        if(s == S)
            sprint(str, "%ld(SB)", a->offset);
        else
            sprint(str, "{%s}%.5lux+%ld(SB)", s->name, s->value, a->offset);
        break;

    case N_INTERN:
        if(s == S)
            sprint(str, "<>+%ld(SB)", a->offset);
        else
            sprint(str, "{%s<>}%.5lux+%ld(SB)", s->name, s->value, a->offset);
        break;

    case N_LOCAL:
        if(s == S)
            sprint(str, "%ld(SP)", a->offset);
        else
            sprint(str, "{%s}-%ld(SP)", s->name, -a->offset);
        break;

    case N_PARAM:
        if(s == S)
            sprint(str, "%ld(FP)", a->offset);
        else
            sprint(str, "{%s}%ld(FP)", s->name, a->offset);
        break;
    default:
        sprint(str, "GOK-name(%d)", a->symkind);
        break;

    }
    return fmtstrcpy(fp, str);
}
@
%pad: I added the s->value for dumping resolved value of $hello in tutorial
% and put braces around symbol to better show that they are really comment
% now because they are resolved.
% before: $hello+0(SB),R1
% after:  ${hello}00014+0(SB), R1

\subsection{Conditional execution dumper, [[Cconv()]]}


<<global strcond(arm)>>=
char*	strcond[16] =
{
    ".EQ",
    ".NE",
    ".HS",
    ".LO",
    ".MI",
    ".PL",
    ".VS",
    ".VC",
    ".HI",
    ".LS",
    ".GE",
    ".LT",
    ".GT",
    ".LE",
    "",
    ".NV"
};
@

<<function Cconv(arm)>>=
int
Cconv(Fmt *fp)
{
    char s[20];
    int c;

    c = va_arg(fp->args, int);
    strcpy(s, strcond[c & C_SCOND]);
    if(c & C_SBIT)
        strcat(s, ".S");
    if(c & C_PBIT)
        strcat(s, ".P");
    if(c & C_WBIT)
        strcat(s, ".W");
    if(c & C_UBIT)		/* ambiguous with FBIT */
        strcat(s, ".U");
    return fmtstrcpy(fp, s);
}
@


\subsection{???, [[Sconv()]]}

<<function Sconv(arm)>>=
// ?? -> string
int
Sconv(Fmt *fp)
{
    int i, c;
    char str[STRINGSZ], *p, *a;

    a = va_arg(fp->args, char*);
    p = str;
    for(i=0; i<sizeof(long); i++) {
        c = a[i] & 0xff;
        if(c >= 'a' && c <= 'z' ||
           c >= 'A' && c <= 'Z' ||
           c >= '0' && c <= '9' ||
           c == ' ' || c == '%') {
            *p++ = c;
            continue;
        }
        *p++ = '\\';
        switch(c) {
        case 0:
            *p++ = 'z';
            continue;
        case '\\':
        case '"':
            *p++ = c;
            continue;
        case '\n':
            *p++ = 'n';
            continue;
        case '\t':
            *p++ = 't';
            continue;
        }
        *p++ = (c>>6) + '0';
        *p++ = ((c>>3) & 7) + '0';
        *p++ = (c & 7) + '0';
    }
    *p = 0;
    return fmtstrcpy(fp, str);
}
@


\section{Verbose mode, [[5l -v]]}
\l and [[DBG()]]

%old: used to have lots of code like:
% if(debug['v']) {
%    Bprint(&bso, "HEADER = -H0x%ld -T0x%lux -D0x%lux -R0x%lux\n",
%        HEADTYPE, INITTEXT, INITDAT, INITRND);
%    Bflush(&bso);
%}
% (The Bflush was outside the if, but makes more sense like this I think)
% but better to have a DBG() macro for this

<<macro DBG>>=
#define DBG if(debug['v']) mylog
@
%pad: I introduced that

<<function log>>=
void mylog(char *fmt, ...) {

    va_list arg;

    va_start(arg, fmt);
    Bvprint(&bso, fmt, arg);
    va_end(arg);
    Bflush(&bso);
}
@
%pad: I introduced that

\section{Objects loading debugging, [[5l -W]]}
\label{sec:debugging-loading}

<<[[ldobj()]] debug>>=
if(debug['W'])
    print("%P\n", p);
@
% see Pconv before

<<[[ldobj()]] when ANAME, debug>>=
if(debug['W'])
    print("	ANAME	%s\n", s->name);
@

\l -W for? what is the connexion to object loading?

% print object code when loading

% (but need good enam.c! up to date and in sync with 5.out.h)


%ex: of output:


\section{Opcode table debugging, [[5l -t]]}
%pad: I added that

<<[[oplook()]] debug>>=
if(debug['t']) {
    print("oplook %P %A %d %d %d\n",
        p, (int)p->as, a1, a2, a3);
}
@
%old: used to be under a if 0 but pretty useful when debugging issues
%old:    print("		%d %d\n", p->from.type, p->to.type);


\section{Machine code generation debugging, [[5l -a]]}
\label{sec:debugging-generated-code}
\l why -a? assembly? meh

% print final concrete code in assembly language with addresses
% very nice!

%ex of output:
% 00001020: e52de024 (12) MOVW.W R14, -36(R13)
%  with lineno (12) but it's a global_lineno so take care

% if do 5l -a -a two times then get also the o->type and so know
% which case was triggered which is also very useful (remember MOVD
% generation pb with addpool())


<<[[asmout()]] when 1 generated instruction, debug>>=
if(debug['a'])
    Bprint(&bso, " %.8lux: %.8lux\t%P\n", v, o1, p);
@
<<[[asmout()]] when 2 generated instructions, debug>>=
if(debug['a'])
    Bprint(&bso, " %.8lux: %.8lux %.8lux%P\n", v, o1, o2, p);
@
<<[[asmout()]] when 3 generated instructions, debug>>=
if(debug['a'])
    Bprint(&bso, " %.8lux: %.8lux %.8lux %.8lux%P\n", v, o1, o2, o3, p);
@
<<[[asmout()]] when 4 generated instructions, debug>>=
if(debug['a'])
    Bprint(&bso, " %.8lux: %.8lux %.8lux %.8lux %.8lux%P\n",
        v, o1, o2, o3, o4, p);
@
<<[[asmout()]] when 5 generated instructions, debug>>=
if(debug['a'])
    Bprint(&bso, " %.8lux: %.8lux %.8lux %.8lux %.8lux %.8lux%P\n",
        v, o1, o2, o3, o4, o5, p);
@
<<[[asmout()]] when 6 generated instructions, debug>>=
if(debug['a'])
    Bprint(&bso, " %.8lux: %.8lux %.8lux %.8lux %.8lux %.8lux %.8lux%P\n",
        v, o1, o2, o3, o4, o5, o6, p);
@
<<[[asmout()]] when other size, debug>>=
if(debug['a'])
    Bprint(&bso, " %.8lux:\t\t%P\n", v, p);
@


<<[[asmout()]] debug>>=
if(debug['a'] > 1)
    Bprint(&bso, "%2d ", o->type);
@
% when -a -a

<<[[asmb()]] before cflush, debug>>=
if(debug['a']) {
    Bprint(&bso, "\n");
    Bflush(&bso);
}
@




\section{Symbol table debugging, [[5l -n]]}

<<[[putsymb()]] debug>>=
if(debug['n']) {
    <<[[putsymb()]] if z or Z in debug output>>
    if(ver)
        Bprint(&bso, "%c %.8lux %s<%d>\n", t, v, s, ver);
    else
        Bprint(&bso, "%c %.8lux %s\n", t, v, s);
}
@

<<[[putsymb()]] if z or Z in debug output>>=
if(t == 'z' || t == 'Z') {
    Bprint(&bso, "%c %.8lux ", t, v);
    for(i=1; s[i] != 0 || s[i+1] != 0; i+=2) {
        f = ((s[i]&0xff) << 8) | (s[i+1]&0xff);
        Bprint(&bso, "/%x", f);
    }
    Bprint(&bso, "\n");
    return;
}
@
% >> >> >>


\chapter{Error Management}
\label{chap:error}

<<global nerrors>>=
int	nerrors = 0;
@

<<function errorexit>>=
void
errorexit(void)
{

    if(nerrors) {
        if(cout >= 0)
            remove(outfile);
        exits("error");
    }
    exits(0);
}
@
\l why exits(0) when call errorexit for regular exit? what 5a does?
%assembler: similar


% could use TNAME here too?
<<function diag>>=
void
diag(char *fmt, ...)
{
    char buf[STRINGSZ];
    char *tn;
    va_list arg;

    tn = "??none??";
    if(curtext != P && curtext->from.sym != S)
        tn = curtext->from.sym->name;
    va_start(arg, fmt);
    vseprint(buf, buf+sizeof(buf), fmt, arg);
    va_end(arg);
    print("%s: %s\n", tn, buf);

    nerrors++;
    if(nerrors > 20 && !debug['A']) {
        print("too many errors\n");
        errorexit();
    }
}
@
% ARM does not have the && !debug['A'], but probablt error no?

% note that call to diag increment nerror and so prevent
% any executable generation (but allow error recovery and continue)

\t percent r is error return code of last syscall I think, so common to have
\t  it in fmt

\section{[[5l -A]]}
% get all errors



\chapter{Profiling}
\label{chap:profiling-appendix}

% 5l -v
% had lots of cputime() too in calls to DBG, so a form of profiling

<<[[main()]] profile report>>=
if(debug['v']) {
    Bprint(&bso, "%5.2f cpu time\n", cputime());
    Bprint(&bso, "%ld symbols\n", nsymbol);
    Bprint(&bso, "%ld memory used\n", thunk);
    Bprint(&bso, "%d sizeof adr\n", sizeof(Adr));
    Bprint(&bso, "%d sizeof prog\n", sizeof(Prog));
    Bflush(&bso);
}
@

<<global nsymbol linker>>=
long	nsymbol;
@
% for statistics
<<[[lookup()]] profiling>>=
nsymbol++;
@

\chapter{Utilities}
\label{chap:libc}

\section{Memory management}
% same in Assembler.nw

<<global hunk>>=
char*	hunk;
@



<<global nhunk>>=
long	nhunk;
@
% = 0??


<<global thunk>>=
long	thunk;
@


<<constant NHUNK linker>>=
NHUNK		= 100000,
@


% not sure why don't use libc malloc and do low-level sbrk ...
% to optimize things? as they do no free?
<<function gethunk>>=
void
gethunk(void)
{
    char *h;
    long nh;

    nh = NHUNK;
    if(thunk >= 5L*NHUNK) {
        nh = 5L*NHUNK;
        if(thunk >= 25L*NHUNK)
            nh = 25L*NHUNK;
    }
    h = sbrk(nh);
    if(h == (char*)-1) {
        diag("out of memory");
        errorexit();
    }
    hunk = h;
    nhunk = nh;
    thunk += nh;
}
@




<<function malloc>>=
/*
 * fake malloc
 */
void*
malloc(ulong n)
{
    void *p;

    // upper_round(n, 8)
    while(n & 7)
        n++;

    while(nhunk < n)
        gethunk();
    p = hunk;
    nhunk -= n;
    hunk += n;
    return p;
}
@




% no free ...  hmmm
<<function free>>=
void
free(void *p)
{
    USED(p);
}
@



% not sure why but if redefine malloc and free then have to
% redefine this func too, otherwise get a link error
<<function setmalloctag>>=
//@Scheck: looks dead, but because we redefine malloc/free we must also redefine that
void setmalloctag(void *v, ulong pc)
{
    USED(v, pc);
}
@


\section{Buffer management}
\label{sec:buffer-management}

<<struct Buf>>=
union Buf
{
    struct
    {
        char	obuf[MAXIO];			/* output buffer */
        byte	ibuf[MAXIO];			/* input buffer */
    };
    char	dbuf[1]; // variable size
};
@
<<constant MAXIO>>=
MAXIO		= 8192,
@

<<global buf>>=
union Buf buf;
@


% see readsome() also but not as generic as rest below
% and needed to undertand ldobj so put before


%<<constant cbuf>>=
%#define	Cbuf	u.obuf
%@
%<<constant xbuf>>=
%#define	Xbuf	u.ibuf
%@
%%simplified! use anonymous union!


<<global cbp>>=
char*	cbp;
@

<<global cbc>>=
int	cbc;
@



<<[[main()]] initialize globals(arm)>>=
cbp = buf.obuf;
cbc = sizeof(buf.obuf);
@



<<function cput(arm)>>=
void
cput(int c)
{
    cbp[0] = c;
    cbp++;
    cbc--;
    if(cbc <= 0)
        cflush();
}
@
% mostly similar to x86, x86 is using a macro though

% in the end print in cout
<<function cflush>>=
void
cflush(void)
{
    int n;

    n = sizeof(buf.obuf) - cbc;
    if(n)
        write(cout, buf.obuf, n);

    cbp = buf.obuf;
    cbc = sizeof(buf.obuf);
}
@




% xxxl means left? little endian?


<<function wputl(arm)>>=
void
wputl(long l)
{

    cbp[0] = l;
    cbp[1] = l>>8;
    cbp += 2;
    cbc -= 2;
    if(cbc <= 0)
        cflush();
}
@
% the x86 version seems more logical, normal?
% what about overflow?? sure cbc >= 2?

<<function wput(arm)>>=
void
wput(long l)
{

    cbp[0] = l>>8;
    cbp[1] = l;
    cbp += 2;
    cbc -= 2;
    if(cbc <= 0)
        cflush();
}
@



<<function lput(arm)>>=
void
lput(long l)
{

    cbp[0] = l>>24;
    cbp[1] = l>>16;
    cbp[2] = l>>8;
    cbp[3] = l;
    cbp += 4;
    cbc -= 4;
    if(cbc <= 0)
        cflush();
}
@



<<function lputl(arm)>>=
void
lputl(long l)
{

    cbp[3] = l>>24;
    cbp[2] = l>>16;
    cbp[1] = l>>8;
    cbp[0] = l;
    cbp += 4;
    cbc -= 4;
    if(cbc <= 0)
        cflush();
}
@


<<function llput>>=
void
llput(vlong v)
{
    lput(v>>32);
    lput(v);
}
@


<<function llputl>>=
void
llputl(vlong v)
{
    lputl(v);
    lputl(v>>32);
}
@




<<function strnput(arm)>>=
void
strnput(char *s, int n)
{
    for(; *s; s++){
        cput(*s);
        n--;
    }
    for(; n > 0; n--)
        cput(0);
}
@
% the x86 version is sligtly different

\section{File management}

<<function fileexists>>=
int
fileexists(char *s)
{
    byte dirbuf[400];

    /* it's fine if stat result doesn't fit in dirbuf, since even then the file exists */
    return stat(s, dirbuf, sizeof(dirbuf)) >= 0;
}
@


\section{String processing}
\label{sec:atolwhex}

% could be put in libc, with the other atoxxx
% atoxx? why a?  a to long with hexadecimal?
<<function atolwhex>>=
long
atolwhex(char *s)
{
    long n;
    int f;

    n = 0;
    f = 0;
    while(*s == ' ' || *s == '\t')
        s++;
    if(*s == '-' || *s == '+') {
        if(*s++ == '-')
            f = 1;
        while(*s == ' ' || *s == '\t')
            s++;
    }
    if(s[0]=='0' && s[1]){
        if(s[1]=='x' || s[1]=='X'){
            s += 2;
            for(;;){
                if(*s >= '0' && *s <= '9')
                    n = n*16 + *s++ - '0';
                else if(*s >= 'a' && *s <= 'f')
                    n = n*16 + *s++ - 'a' + 10;
                else if(*s >= 'A' && *s <= 'F')
                    n = n*16 + *s++ - 'A' + 10;
                else
                    break;
            }
        } else
            while(*s >= '0' && *s <= '7')
                n = n*8 + *s++ - '0';
    } else
        while(*s >= '0' && *s <= '9')
            n = n*10 + *s++ - '0';
    if(f)
        n = -n;
    return n;
}
@


\section{Mathematic functions}

% rnd, exemple:  rnd(16, 8) = 16. rnd(17, 8) = 24

\t maybe show code of alternatives?
%alt: code like that too
%   while(orig & 7) // align
%     orig++;
% or
%   autosize = (p->to.offset+3L) & ~3L;
% which is optimal when rnd at power of 2?

<<function rnd>>=
long
rnd(long v, long r)
{
    long c;

    <<[[rnd()]] if r is null or negative>>
    v += r - 1;
    c = v % r;
    <<[[rnd()]] if v was negative>>
    v -= c;
    return v;
}
@


<<[[rnd()]] if r is null or negative>>=
if(r <= 0)
    return v;
@
<<[[rnd()]] if v was negative>>=
if(c < 0)
    c += r;
@

\chapter{Linker-related Programs}
\label{chap:linker-related-programs}

\section{[[include/mach.h]]}

% can copy Fhdr here.

% actually linker does not depend on libmach/! because it's writing 
% specific stuff and libmach is mostly about generic reading interface 
% to many specifics
% (and not just 5l)

% FIGURE where see linker which does not use libmach, write vs read

% see libmach to read back this executable!
%FIGURE
% so   .s --5a--> .o (.5) --5l--> .exe (5.out) --libmach--> readable
% (hmm libmach is also reading .o (.5)

\l could factorize code between ldobj and libmach?
% why not using 5obj.c from libmach/? because 5obj.c is incomplete?
% because it cares just about the symbol table?


\section{[[size]]}
\label{sec:size-code}

% errort (0 is ok)
<<function size>>=
int
size(char *file)
{
    fdt fd;
    Fhdr f;

    if((fd = open(file, OREAD)) < 0){
        fprint(2, "size: ");
        perror(file);
        return 1;
    }
    if(crackhdr(fd, &f)) {
        print("%ldt + %ldd + %ldb = %ld\t%s\n", f.txtsz, f.datsz,
            f.bsssz, f.txtsz+f.datsz+f.bsssz, file);
        close(fd);
        return 0;
    }
    fprint(2, "size: %s not an a.out\n", file);
    close(fd);
    return 1;
}
@

<<function main (linkers/misc/size.c)>>=
void
main(int argc, char *argv[])
{
    char *err;
    int i;

    ARGBEGIN {
    default:
        fprint(2, "usage: size [a.out ...]\n");
        exits("usage");
    } ARGEND;

    err = nil;
    if(argc == 0)
        if(size("8.out"))
            err = "error";
    for(i=0; i<argc; i++)
        if(size(argv[i]))
            err = "error";
    exits(err);
}
@

\section{[[strip]]}
\label{sec:strip-code}

% see also 5a -s and relevant code in chapter Debugger.


\section{[[nm]]}
\label{sec:nm-code}

% rely on no-strip!

% see nm(1)
% use libmach!

% table with letter -> definition? (but explained in nm(1) it is true)
% or better do it via the code :)

\section{[[ar]]}
\label{sec:ar-code}

% see ar(5) and ar(1)

% ar use libmach/ library itself :) bootstrapping.

\chapter{[[5l]] in OCaml}
\label{chap:5l-ocaml}

% yeah!!

% design decisions: 
% - no optimisations, space or speed, which guides many of the
%   other decisions below.
% - object file is marshalled form of ocaml AST. Far simpler!
%   (but less open to other languages; could use JSON but no ADT in JSON)
% - ??
% This decrements size of code, but also size of needed explanations!








\chapter{Extra Code}

\ifallcode
#include "Linker_extra.nw"
#include "Linker_x86.nw"
\fi

%\chapter{Changelog}
%\label{sec:changelog}
% code via make loc = 9700 LOC
% orig Linker.nw = 11 340, just lpized and few comments, 101 pages pdf
% now: ? LOC ? pages, so added ?? LOE (Lines of explanations)

\chapter*{Glossary}
\addcontentsline{toc}{chapter}{Glossary}
\label{sec:glossary}

\begin{verbatim}
LDR = LoaD Register
STR = STore Register
ARM = Acorn RISC Machine
RISC = Reduced Instruction Set Computer
PC = Program Counter
SB = Static Base register
SP = Stack Pointer
\end{verbatim}



\chapter*{Indexes}
\addcontentsline{toc}{chapter}{Index}

%\chapter{References} 
\addcontentsline{toc}{chapter}{References}

\bibliography{../docs/latex/Principia}
\bibliographystyle{plain}

%******************************************************************************
% Postlude
%******************************************************************************

\end{document}
