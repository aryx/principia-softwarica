\documentclass[twocolumn]{report}

%******************************************************************************
% Prelude
%******************************************************************************
\newif\iffinal
\newif\ifverbose
\finaltrue\verbosefalse % see also other newif in Macros.tex

%------------------------------------------------------------------------------
%history:
%------------------------------------------------------------------------------

%thx to LP, changed for the better a few things:
% - introduced HEADTYPE instead of hardcoded integers
% - introduced mylog() and DBG(), factorize tracing code
% - removed many portable myxxx() wrappers
% - removed some deadcode (C_LBRA, C_LECON, C_SCON, D_OCONST, regused)

%thx to codemap/codegraph:
% - see subtle dependency to 8c/enam.c through anames

%thx to this manual, better understand linking:
% - that an object is really a module, the simplest/lowest module abstraction
%   with defs and uses to link together (for text and data).
% - TODO fpic? 
% - TODO dynamic linking? export table? import table?

%history LP-ization:
% - skeleton, mostly copy paste of Template.nw skeleton
% - put all content of files in the Extra section, via 'pfff -lpize'
%   which also now split in chunks!
%    * function, global, struct, enum, constant, macro(actually function)
% - read Extra section, identify concepts, first TOC
% - distribute parts of the file before
% - understand main(), LP split main, improve TOC
% - understand main functions, LP split, cluster, improve TOC
% - LP split the structures, use datalog for flow to field info
% - SEMI nullify, boolify, typeify,    scheckify
% - aspecify advanced features!
% - TODO add figures
% - TODO add explanations

%------------------------------------------------------------------------------
% Packages
%------------------------------------------------------------------------------

\usepackage{../docs/latex/noweb}
 \noweboptions{footnotesizecode,nomargintag}
 %note: allow chunk on different pages, less white space at bottom of pages
 \def\nwendcode{\endtrivlist \endgroup}
 \let\nwdocspar=\par
\usepackage{xspace}
\usepackage{verbatim}
%note: required by noweblatexpad for the \t \l \n in this file
\usepackage{fancyvrb}
\usepackage{url}
\iffinal
\usepackage{hyperref}
 \hypersetup{colorlinks=true}
\fi
\usepackage[pageref]{backref}
 \def\backref{{\footnotesize cited page(s)}~}
% not in basicTex
%\usepackage{cleveref} %\cref
% not in basicTex, for multirow TOC!
%\usepackage{multirow}
\usepackage{booktabs} 
 \newcommand{\otoprule}{\midrule[\heavyrulewidth]}
\usepackage{graphicx}
 %\usepackage[margin=0.5in]{geometry}
 %  but eat the bottom when very low
 %\usepackage{fullpage} is deprecated 
 % => do the more manual below:
 \addtolength{\oddsidemargin}{-.850in}
 \addtolength{\evensidemargin}{-.850in}
 \addtolength{\textwidth}{1.70in}
 \addtolength{\topmargin}{-.850in}
 \addtolength{\textheight}{1.70in}
%\usepackage{minitoc}

%------------------------------------------------------------------------------
% Macros
%------------------------------------------------------------------------------
\input{../docs/latex/Macros}

%------------------------------------------------------------------------------
% Config
%------------------------------------------------------------------------------
\allcodefalse
% used for forward decl, pragmas, func decl, extern decl, stats, #ifdef,
% debugging macros

%\setcounter{tocdepth}{1}

%******************************************************************************
% Title
%******************************************************************************

\begin{document}

\title{
{\Huge 
Principia Softwarica: The Plan9 Linker [[5l]]
}\\
ARM (32 bits) edition\\
{version 0.1}
}
%alt: 8l, x86 (32 bits) edition
% Linker and Loader?

\author{
Yoann Padioleau\\
\texttt{yoann.padioleau@gmail.com}
}

\maketitle 
\onecolumn
\hrule
\begin{quote}
    Copyright \copyright{} 2014 Yoann Padioleau \\
    Permission is granted to copy, distribute and/or modify this document,
    except all the source code it contains, under the terms of the GNU Free
    Documentation License, Version 1.3.
\end{quote}
\hrule

%CONFIG: \dominitoc

\iffinal
\begingroup
\hypersetup{linkcolor=blue}
% need to s/onecolumn/twocolumn in report.cls :) for \tableofcontents
\twocolumn
\tableofcontents
\endgroup
\else
\tableofcontents
\fi

%******************************************************************************
% Body
%******************************************************************************

\chapter{Introduction}

\section{Motivations}

The goal of this book is to present in full details the source code of
a linker.
Why? Because I think it makes you a better programmer if
you fully understand how things work under the hood.

% gonna present plan9 linker: small, clean.
% gonna present 5l just like we presented 5a and 5c. ARM simpler
% than x86.

Here are other candidates that were considered but ultimately discarded:
\begin{itemize}
\item GNU ld and the BFD library
\item Gold
\end{itemize}
% dev86?
% Linker and Loader book, introduce his own ld? http://www.iecc.com/linker

% http://eli.thegreenplace.net/2012/08/13/how-statically-linked-programs-run-on-linux/
% http://dbp-consulting.com/tutorials/debugging/linuxProgramStartup.html
% http://www.lurklurk.org/linkers/linkers.html
% http://www.iecc.com/linker

% plan9 approach to linking is a bit different. The linker actually
% generates also the machine code. The object format is not the ISA.
% Simpler that way. This may also allows inter-lib linking-time optimisations!
% Also there is no dynamic linking by default. Simpler approach
% again.

% recent critique of go/plan9 toolchain:
% http://dtrace.org/blogs/wesolows/2014/12/29/golang-is-trash/

\section{Getting started}

\section{Requirements}

\section{About this document}
#include "../docs/latex/About.nw"

\section{Copyright}

Most of this document is actually source code from Plan9, so
those parts are copyright by Lucent Technologies Inc.
The prose is mine and is licensed under the GNU Free Documentation
License.

\section{Acknowledgments}


\chapter{Overview}

\section{Linker principles}

% principle: link together object files. Resolve external symbols references.
% Link defs to uses. An object is really the simplest/lowest module abstraction.
% Also compute textsize, datasize, etc and adjust addresses.

%figure: like a train, some wagons, and inside some unresolved references
% and after linking see all the wagons really after each other and
% the links resolved.
% Also agglomerate the code, and the data of the different modules together,
% and pack them.

% why the term loader instead of linker?
% maybe because load the objects and libs and then link them
% (but first it "loads" them)

% For plan9 the linker is also generating the
% ISA binary code (what was usually done by the assembler)).

% what about dynamic linking? see Advanced topics chapter.

% full book on the subject

\section{[[5l]] services}

% command line interface? -o
% also important -TText, see Kernel.nw

<<function usage, linker>>=
void
usage(void)
{
    diag("usage: %s [-options] objects", argv0);
    errorexit();
}
@
% also can give libraries, which are really a file encapsulating
% a set of objects (like tar). Archive.

% env: $ccroot

\section{[[hello.5]], [[world.5]]}
% show binary format? hexdump?

% two modules where one call the other or use a definition defined
% in another object. 

\section{Input object format}
% the object file is the input this time 
% (as opposed to 5a where it's the output)

% nm foo.5 => ? U? D? T?

% nm is actually using libmach, crachhdr, etc, generic API for object 
% manipulation.

% put libmach/5obj.c?

% put copy paste of Object format section here? of Assembler?

% Figure!


\section{Output executable format}
% the output

%http://jvns.ca/blog/2014/09/06/how-to-read-an-executable/

% plan9 is using the very simple a.out.h format.
% but 5l can also generate different executable formats (well different
% headers).

% see libmach to read back this executable!

% so   .s --5a--> .o (.5) --5l--> .exe (5.out) --libmach--> readable
% (hmm libmach is also reading .o (.5)

% include/a.out.h
% used by strip, libmach, but not really 5l.
% should be 32 bytes (0x20)
% see asmb() that generates this far below
<<struct Exec>>=
// a.out header format
struct	Exec
{
    long	magic;		/* magic number */

    long	text;	 	/* size of text segment */
    long	data;	 	/* size of initialized data */
    long	bss;	  	/* size of uninitialized data */

    long	syms;	 	/* size of symbol table */

    // virtual address in [UTZERO+sizeof(Exec)..UTZERO+sizeof(Exec)+text]
    long	entry;	 	/* entry point */ 

    long	_unused;
    // see a.out.h man page explaining how to compute the line of a PC
    long	pcsz;		/* size of pc/line number table */
};
@
% _unused was actually:
%    // used only by 68020, spsize set to 0 for 8l TODO remove at some point!
%    long	spsz;		/* size of pc/sp offset table */


% entry: it's usually not main but _main (or _mainp) which does
% some core initializations and then call main


\section{Runtime conventions}

% frame format?
%  parameters
%  saved PC (from REGLINK when not a leaf procedure)
%  locals
%
% saved SP? assumer caller saves/restores registers including SP?

% When want to call a procedure, need to save current place,
% so do BL for branch and link where a special register
% holds a value. Then need to save this value in a stack
% (if it's not a leaf procedure).

%        autosize = p->to.offset + 4; // locals
% + 4 = saved PC (REGLINK from BL)

% FP vs SP?


\section{Code organization}

%5l/l.h: data structures and prototypes (like a dat.h and fns.h)

%5l/globals.c: globals
%5l/utils.c:
%5l/compat.c:
%5l/list.c: dumpers

%5l/pass.c:
%5l/span.c:

%5l/noop.c: when an ASM opcode has actually no machine opcode (e.g. ADIV)

%5l/asm.c: ARM machine code generation
%5l/optab.c:

%5l/obj.c: main()

\section{Software architecture}

% depends on include/arm/5.out.h for all assembly opcodes, registers, etc
% (used to depend on 5c/ for one file ../5c/enam.c but now done via symlink)

%linker vs libmach:
% actually linker does not depend on libmach/! because it's writing 
% specific stuff and libmach is mostly about generic reading interface 
% to many specifics
% (and not just 5l)


%###############################################################################

\chapter{Core Data Structures}

\section{[[Sym]] and [[hash]]}

% linker is a lot about resolving undefined symbols; linking definition to uses
% at the right place, so symbols are pretty central!

<<struct Sym>>=
struct	Sym
{
    char	*name;
    short	version; // for static names, each sym has a different version

    //enum<section>
    short	type;
    // generic value, e.g. virtual pc for a TEXT procedure, size for GLOBL
    long	value; 

    <<[[Sym]] other fields>>
    // Extra
    <<[[Sym]] extra fields>>
};
@
% Similar to Sym in Assembler.nw, but a few differences:
% - no 'type' (token_kind) field, no 'macro' field
% - no symidx field (but was local to outcode())
% - a new 'version' field; D_STATIC was in the Operand.symkind but the linker
%   now manages multiple objects together where can have the same static name
%   multiple times
% - a new 'type' field for the section, the linker has to resolve
%   as opposed to the assembler
%less: transform value to a union?
%note: conflict with include/a.out.h

% The 'type' and 'value' in Sym are? 
% - for ATEXT it will be STEXT and the value will be a virtual pc
% - for AGLOBL it will be SBSS or SDATA, and the value will be its size
% The value "type" changes during the execution. For instance before dodata() 
% the value for a global stores its size. After it stores its location.
% Similarly for procedures, before span() the value stores a virtual pc,
% incremented by 1 between each instruction. After span() it stores the
% final location at 4 bytes boundaries.
% => maybe use an union! 


<<constant NHASH linker>>=
NHASH		= 10007,
@

<<global hash linker>>=
// hash<Sym.name * Sym.version, ref<Sym>> (next = Sym.link)
Sym*	hash[NHASH];
@
% when load the objects this hashtbl is populated

<<[[Sym]] extra fields>>=
// hash<Sym.name * Sym.version, ref<Sym>> of hash
Sym*	link;
@

<<constant S>>=
#define	S		((Sym*)nil)
@





<<enum sxxx(arm)>>=
enum section
{
    SNONE = 0,

    STEXT,
    SDATA,
    SBSS,

    SXREF,
    <<enum sxxx cases>>
};
@
% SSTACK? no! not in exec :) 
% see also asmsym()
% those are mostly sections, or subsections (e.g. SDATA1 of SDATA,
%  and SLEAF/SCONST/STRING of STEXT)
% note: a symbol is assigned SXREF in ldobj() when the obj introduces an ANAME
%  about an D_EXTERN or D_STATIC symbol.




% This function creates a new symbol if it does not exist.
% v is for version, but really it's about handling static names.
% (we could have a typedef int version;? and VERSION0 = 0 so clearer to read?
% or a NO_STATIC = 0?)
<<function lookup>>=
Sym*
lookup(char *symb, int v)
{
    Sym *s;
    char *p;
    long h;
    int l, c;

    // h = hash(symb, v)
    h = v;
    for(p=symb; *p; p++) {
        c = *p;
        h = h+h+h + c;
    }
    l = (p - symb) + 1;
    h &= 0xffffff;
    h %= NHASH;
    
    // s = lookup(h, hash)
    for(s = hash[h]; s != S; s = s->link)
        if(s->version == v)
            if(memcmp(s->name, symb, l) == 0)
                return s;


    s = malloc(sizeof(Sym));
    s->name = malloc(l + 1); // +1 again?
    memmove(s->name, symb, l);
    s->type = SNONE;
    s->version = v;
    s->value = 0;
    s->sig = 0;

    s->link = hash[h];
    hash[h] = s;

    nsymbol++;
    return s;
}
@

<<global nsymbol linker>>=
long	nsymbol;
@
% for statistics

% s->link will be described in Safe linking section

\section{[[Opcode]] and [[Operand]]}

% in include/arm/5.out.h: 
% - Opcode (enum opcode), 
% - Operand_kind (enum operand_kind)
% see Aconv(opcode), Dconv(operand_kind)

% can reput major opcode here, AADD, ATEXT, AB, etc?
% and also R1, ... 
% and also D_REG, ... 
% and even D_STATIC, ...

% Adr = Operand of instruction, e.g. in MOV AX, BX, then AX is a form of Adr
<<struct Adr(arm)>>=
struct	Adr
{
    // enum<operand_kind> (D_NONE by default)
    short	type;

    union {
        long	offset;
        Ieee*	ieee;
        char*	sval;
    };

    <<[[Adr]] other fields>>
};
@
% Similar to Gen in Assembler.nw, but a few differences:
% - ieee was dval, and sval was sval[8]
% - have now a union for sym and autom, probably autom for the D_PARAM and
%   D_AUTO cases
% - new 'class' field (but seems local to oplook())
%see DConv
%note: offset abused for REGREG in which case it's really a int4
% but otherwise it's often used as an offset in D_BRANCH, D_OREG
% because indeed it's an offset to a basis (PC, SB, etc)
%note: ATEXT arguments are also Adr (abuse)
%less: rename Operand?
%less: would be better if had ADT so can have better Instruction type instead
% of those opcode, operand, Adr, and unions and all those comments

%give a few examples? show man page where have all the addressing modes

% one of the main thing a linker does is to relocate at the right place.
% offset can be based on PC (for D_BRANCH), SB(for D_STATIC, D_EXTERN),
% on FP(for D_PARAM), and on SP(for D_AUTO), 
% or can be direct value (for D_CONST)



<<[[Adr]] other fields>>=
// option<enum<registr>> None = R_NONE
short	reg; 
@
% again a reg field ... because most operands involve a register
%// Abused for NOPROF and DUPOK; abused for NOPROF function attributes
%less: could use a union again?

<<[[Adr]] other fields>>=
union {
    Sym*	sym;
    Auto*	autom;
};
@
%autom because auto is a reserved keyword? but has nothing to do
% with automata so maybe better to rename local_or_param
%should be set to curauto for the TEXT instructions and its to Adr field

% works with sym
<<[[Adr]] other fields>>=
// enum<sym_kind>
short	symkind;
@


% for locals or param symbols
<<struct Auto(arm)>>=
struct	Auto
{
    // enum<name_kind> (but D_AUTO or D_PARAM only?)
    short	type;

    Sym*	asym;
    long	aoffset;

    // Extra
    <<[[Auto]] extra fields>>
};
@


<<[[Auto]] extra fields>>=
Auto*	link;
@
% chain them so can do some basic checks? like right autosize?

%less: talk about curauto and autosize here?

\section{[[Instruction]]}

% bad name .... I think Prog is really an Instruction ... From and To
% are when do MOV AX, BX,    then AX is the from, BX the to
<<struct Prog(arm)>>=
struct	Prog
{
    //enum<opcode>
    byte	as;

    // operands
    Adr	from;
    Adr	to;

    <<[[Prog]] other fields>>

    // Extra
    <<[[Prog]] extra fields>>
};
@
% Similar to the arguments of outcode():
%  - as (opcode), from (g1), to (g2), reg, scond, and
%    line field was a lineno global
%  - ???
%see Pconv, %P
%less: could rename cond to pcond and AB to AJMP and could factorize
% more code with x86

%note: pseudo-opcode like ATEXT also have operands, so
% from can be abused to store the name of the procedure

% very arm specific!
<<[[Prog]] other fields>>=
// option<enum<registr>>, None = R_NONE
short	reg;
@
% ARM instructions have often 3 operands in which case at least
% one is a register.
% This is used also to store TEXT attributes, e.g. DUPOK, NOPROF. 

<<[[Prog]] other fields>>=
// enum<instr_cond>
byte	scond;
@


<<[[Prog]] other fields>>=
long	line;
@
% a global line after #include. When the object is the result
% of the assembly generated by 5c the line is the line in the .c
% so many ASM instructions have actually the same line because
% one C expression can result in many ASM instructions.

<<[[Prog]] other fields>>=
long	pc;
@
% The absolute pc of this instruction! needed for
% some check pc == p->pc somewhere.
% It evolves. First it's relative to the object code start (0..) in the .5
% and incremented by 1 (virtual pc),
% then it's adjusted when loading the object files (see ipc),
% then in span() and asmb() it's incremented by 4 or even more
% (concrete pc) and starts after INITTEXT.



<<[[Prog]] other fields>>=
//bitset<enum<mark>>
short	mark;
@
%old: was byte
% some generic tags to help some algoritms (e.g. for LEAF)

<<enum mark(arm)>>=
/* mark flags */
enum mark {
    <<enum mark cases>>
};
@
%dead: LABEL
%not-so-useful opti: FOLL
%useful opti: LEAF




%dead:
%<<[[Prog]] other fields>>=
%union
%{
%    long	regused;
%};
%@
% use anonymous union now, so don't need those aliases
%<<constant regused(arm)>>=
%#define	regused	u0.u0regused
%@
%<<constant forwd(arm)>>=
%#define	forwd	u0.u0forwd
%@
% now I just have a forward field, see mkfwd().

\section{[[firstp]], [[textp]], [[datap]], [[curtext]], etc}

% list of instructions (ATEXT and its instrs, but not ADATA, AGLOBL, ...)
% good name? first_instr better? also again there is strong
% coupling between firstp and lastp that should be encapsulated
% in a specific structure (like for datap/edatap)
<<global firstp>>=
// list<ref_own<Prog>>, next = Prog.link
Prog*	firstp;
@
% rename instrp?


<<[[Prog]] extra fields>>=
// list<ref<Prog>> from firstp/lastp, or datap/edatap
Prog*	link;
@

<<constant P>>=
#define	P		((Prog*)nil)
@


<<global lastp>>=
// ref<Prog>, last elt of firstp list
Prog*	lastp;
@
% option<Prog>? usually there is a sentinel so there is always
% a lastp






% list of procedures (ATEXT opcode), subset of firstp/lastp
<<global textp>>=
// list<ref<Prog>>, next = Prog.cond
Prog*	textp = P;
@

<<[[Prog]] extra fields>>=
// list<ref<Prog>> from textp/etextp
Prog*	cond;
@
%to link destination labels for branch instructions.
%also to quickly iterate over all the ATEXT as they are chained via cond.
% (is called pcond I think in x86, could choose same name)

<<global etextp>>=
// ref<Prog>, end of textp list
Prog*	etextp = P;
@




% list of data (ADATA opcode)
<<global datap>>=
// list<ref<Prog>>, next = Prog.next
Prog*	datap = P;
@
%note: no need for edatap in arm






% When iterate over all instrs, if the instr is a ATEXT then store it here.
% It's probably for error message, to say in which procedure we currently are.
<<global curtext>>=
//option<ref<Prog>> where Prog.as == ATEXT
Prog*	curtext = P;
@
% there will be different curxxx, a bit ugly use of globals
% curauto, curhist, curp

<<adjust curtext when iterate over instructions p>>=
if(p->as == ATEXT)
    curtext = p;
@
%note: I factorized code using this chunk more than what existed before
% by moving some curtext = p outside some if; it's sligtly slower
% but cleaner for LP purpose.

<<constant TNAME(arm)>>=
#define	TNAME (curtext && curtext->from.sym ? curtext->from.sym->name : noname)
@
% TNAME? TEXT NAME probably

<<global noname linker>>=
char	*noname		= "<none>";
@


<<global curp>>=
// option<ref<Prog>>
Prog*	curp;
@
% similar to curtext, for error report, but this time it can be any instr,
% not just the ATEXT



<<global undefp>>=
//@Scheck: not dead, used by UP
Prog	undefp;
@
% for error recovery? and for dynamic loading stuff?

<<constant UP>>=
#define	UP	(&undefp)
@



%\section{[[Optab]] and [[optab]]}?
%hmm maybe better later

%\section{[[Class]]}
%hmm maybe better later

%\section{[[Buf]] and [[buf]]}?
%hmm maybe better in appendix or later

%\section{[[pc]]}?

%\section{[[textsize]], [[datasize]], [[INITDAT]], ...}?

\chapter{[[main()]]}

% default object suffix, to generate x.out
<<global thechar>>=
char	thechar;
@

% to find library files? /arch/lib/...
<<global thestring>>=
char*	thestring;
@


% -o, 
<<global outfile>>=
char*	outfile;
@

% cout =~ create(outfile)
<<global cout>>=
fdt	cout = -1;
@



<<function main(arm)>>=
void
main(int argc, char *argv[])
{
    <<[[main()]] locals(arm)>>

    thechar = '5';
    thestring = "arm";   
    outfile = "5.out";

    <<[[main()]] debug initialization(arm)>>

    ARGBEGIN {
    <<[[main()]] command line processing(arm)>>
    } ARGEND

    USED(argc);
    if(*argv == nil)
        usage();

    <<[[main()]] addlibpath("/{thestring}/lib") or ccroot>>
    <<[[main()]] set HEADTYPE, INITTEXT, INITDAT, etc>>

    <<[[main()]] initialize globals(arm)>>

    cout = create(outfile, 1, 0775);
    if(cout < 0) {
        diag("cannot create %s: %r", outfile);
        errorexit();
    }

    // ------ main functions  ------
    <<[[main()]] cout is ready, LET'S GO(arm)>>

out:
    <<[[main()]] profile report>>
    errorexit();
}
@
%$


\section{Arguments processing}

<<[[main()]] command line processing(arm)>>=
case 'o':
    outfile = ARGF();
    break;
@


% -H executable format (header type)
<<global HEADTYPE>>=
// enum<headtype>
short	HEADTYPE = -1; /* type of header */
@
% was int in ARM and long in x86, but I don't think it matters



% -T text segment start virtual address (important! e.g. for kernel 0x7c00)
<<global INITTEXT>>=
long	INITTEXT = -1; /* text location */
@
% where expect the code to be loaded, at which (virtual) memory location

% -D data segment start
<<global INITDAT>>=
long	INITDAT = -1; /* data location */
@


% -E default _main (or _mainp when -p)
<<global INITENTRY>>=
char*	INITENTRY = nil;		/* entry point */
@


% less important
% -R text segment rounder at r multiple
<<global INITRND>>=
long	INITRND = -1; 		/* data round above text location */
@



<<[[main()]] command line processing(arm)>>=
case 'H':
    a = ARGF();
    if(a)
        HEADTYPE = atolwhex(a);
    /* do something about setting INITTEXT */
    break;
case 'T':
    a = ARGF();
    if(a)
        INITTEXT = atolwhex(a);
    break;
case 'D':
    a = ARGF();
    if(a)
        INITDAT = atolwhex(a);
    break;
case 'E':
    a = ARGF();
    if(a)
        INITENTRY = a;
    break;
case 'R':
    a = ARGF();
    if(a)
        INITRND = atolwhex(a);
    break;
@



% size of Header, 32 for a.out (0x20)
<<global HEADR>>=
long	HEADR; 		/* length of header */
@


<<[[main()]] set HEADTYPE, INITTEXT, INITDAT, etc>>=
if(HEADTYPE == -1) {
    HEADTYPE = DEFAULT;
}
switch(HEADTYPE) {
<<[[main()]] switch HEADTYPE cases(arm)>>
default:
    diag("unknown -H option");
    errorexit();
}
<<[[main()]] last INITXXX adjustments>>
DBG("HEADER = -H0x%d -T0x%lux -D0x%lux -R0x%lux\n",
        HEADTYPE, INITTEXT, INITDAT, INITRND);
@
%could put HEADTYPE=DEFAULT_HEADTYPE;

%l.h
<<enum headtype(arm)>>=
/*
 *	-H0				      no header
 *	-H2 -T4128 -R4096	  is plan9 format
 *	-H7				      is elf
 */
enum headtype {
     H_NOTHING = 0,
     H_PLAN9 = 2,
     H_ELF = 7,
};
@
%todo: H_OMACH
%old:
% *	-H1 -T0x10005000 -R4  is aif for risc os
% *	-H3 -T0xF0000020 -R4  is NetBSD format
% *	-H4				      is IXP1200 (raw)
% *	-H5 -T0xC0008010 -R1024 	is ipaq
% *	-H6 -R4096			   no header with segments padded to pages

<<constant DEFAULT>>=
#define	DEFAULT	H_PLAN9
@
%pad: I added that, before there was some stuff with -9 -B -U


% -H2, see enum headtype in Overview chapter
<<[[main()]] switch HEADTYPE cases(arm)>>=
case H_PLAN9:
    HEADR = 32L;
    if(INITTEXT == -1)
        INITTEXT = 4096+32;
    if(INITDAT == -1)
        INITDAT = 0;
    if(INITRND == -1)
        INITRND = 4096;
    break;
@
%32 = 0x20, hence this note in kernel mkfile:
%# see mem.h, the additional 20 are the size of the a.out header added by LD
%KTZERO_AND_HEADER=0xE0100020


% less important I think
<<[[main()]] last INITXXX adjustments>>=
if(INITDAT != 0 && INITRND != 0)
    print("warning: -D0x%lux is ignored because of -R0x%lux\n",
        INITDAT, INITRND);
@


\section{Main flow}

% TODO: all those functions that take no args are ugly, they use too much
% globals, e.g. firstp, lastp, I should really rewrite the code
% to be more functional.

<<[[main()]] cout is ready, LET'S GO(arm)>>=
firstp = prg();
lastp = firstp;

<<[[main()]] set INITENTRY>>

// Loading
while(*argv)
    objfile(*argv++);
if(load_libs)
    loadlib();

firstp = firstp->link;
if(firstp == P)
    goto out;

// Resolving
<<[[main()]] resolving phases>>

// Generating (writing to cout, finally)
asmb();

// Checking
undef();
@

% why firstp = firstp->link? the first prog is a fake?
% and why ->link and not ->cond?



<<constructor prg>>=
Prog*
prg(void)
{
    Prog *p;

    p = malloc(sizeof(Prog));
    *p = zprg;
    return p;
}
@

% empty prg, to initialize new Prog
<<global zprg>>=
Prog	zprg;
@

<<[[main()]] initialize globals(arm)>>=
<<[[main()]] set zprg(arm)>>
@

<<[[main()]] set zprg(arm)>>=
zprg.as = AGOK;
zprg.scond = COND_ALWAYS; 
zprg.reg = R_NONE;
zprg.from.type = D_NONE;
zprg.from.symkind = N_NONE;
zprg.from.reg = R_NONE;
zprg.to = zprg.from;
@
%GOK? God Only Knows? to be used as a special mark, there is diag()
% in ldobj() about AGOK
%less: have to use AGOK? why not AXXX? or ANOP?
%bug: what about .class? should be set to C_NONE no?
%bug? what about optab? should be null no? there is code
% using p->optab like oplook()

% many of the constants such as COND_ALWAYS are in 5.out.h



% new local added by me (but maybe was in x86 originally)
<<[[main()]] locals(arm)>>=
bool load_libs;
@

% -l means no automagic stdlibs
<<[[main()]] initialize globals(arm)>>=
load_libs = !debug['l'];
@




% when -l alone it means no startup lib

<<[[main()]] set INITENTRY>>=
if(INITENTRY == nil) {
    INITENTRY = "_main";
    <<[[main()]] adjust INITENTRY if profiling>>
    if(load_libs)
        lookup(INITENTRY, 0)->type = SXREF;
} else {
    <<[[main()]] if digit INITENTRY>>
}
@
%Why when have libs we set _main as SXREF? and why when -l we don't?
% by creating a new entry and setting it to SXREF (default is SNONE) we will
% force in loadlib() to consider _main as a starting point as we marked
% is a undefined (undefined but looked for)

% _main! not main, because _main is defined in libc and then call your main?
% SXREF means?

\section{Loading the objects, [[objfile()]]}

% this function can actually also load libraries passed on the
% command line when the file is a .a (and also core libs passed
% via -lxxx)

% less: objfile -> ldobj and ldobj -> ldinstrs
%  as it can actually load a slice of an object, just a procedure

% essentially modify which globals?
%  - should modify firstp! and textp, datap, lastp, etc
%  - will modify libraryp probably, the cool pragma "autolib"
%    which is why objfile() must be called before loadlib()

% SARMAG = Size ARchive MAGic string

<<function objfile>>=
void
objfile(char *file)
{
    fdt f;
    long l;
    char magbuf[SARMAG];
    <<[[objfile()]] other locals>>

    DBG("%5.2f objfile: %s\n", cputime(), file);

    <<[[objfile()]] adjust file if -lxxx filename>>

    f = open(file, 0);
    if(f < 0) {
        diag("cannot open %s: %r", file);
        errorexit();
    }

    l = read(f, magbuf, SARMAG);

    // is it a regular object (and not a library)
    if(l != SARMAG || strncmp(magbuf, ARMAG, SARMAG)){
        /* load it as a regular file */
        l = seek(f, 0L, SEEK__END);
        seek(f, 0L, SEEK__START);

        // the important call!
        ldobj(f, l, file);

        close(f);
        return;
    }

    <<[[objfile()]] when file is a library>>
}
@
% see next chapter for ldobj()


\section{Loading the libraries, [[loadlib()]]}

% It loads the libraries mentioned in the .5 via the .h and #pragma magic!
% (see later section)
% ldobj() is actually also loading libraries when they are mentioned
% explicitly as in 5l ... libxxx.a or via 5l ... -lxxx

% so loading objects with ldbobj() will modify some of the globals below

% then if(load_libs) loadlib()  in the main flow

% todo: it does some uniq? there is an order? this is why
% we need xrefresolv?

<<global library>>=
// array<option<filename>>
char*	library[50];
@
% addlib() modifies this global


<<global libraryp>>=
// index of first free entry in library array
int	libraryp;
@

% the .5 that mentioned a library via a #pragma? for debugging purpose?
<<global libraryobj>>=
char*	libraryobj[50];
@




<<function loadlib>>=
void
loadlib(void)
{
    int i;

    for(i=0; i<libraryp; i++) {
        DBG("%5.2f autolib: %s (from %s)\n", cputime(), library[i], libraryobj[i]);
        objfile(library[i]);
    }
}
@

%old:
%    long h;
%    Sym *s;
%loop:
%    <<[[loadlib()]] reset xrefresolv>>
%    for(i=0; i<libraryp; i++) {
%        DBG("%5.2f autolib: %s (from %s)\n", cputime(), library[i], libraryobj[i]);
%        objfile(library[i]);
%    }
%    <<[[loadlib()]] if xrefresolv>>
%
% this allows to have mutually dependent libraries, but I don't think
% it's a good idea, ocaml does not allow it, so I commented it for now.
% If people have mutually dependent, they'll have to mention
% the same lib multiple time on the command line!




\section{Resolving symbols, computing addresses}

% see chapter, many phases, many passes
% but actually not that many.


\section{Generating the executable, [[asmb()]]}
% asmb? asm binary?

% first function to actually use cout!

<<function asmb(arm)>>=
void
asmb(void)
{
    <<[[asmb()]] locals>>

    DBG("%5.2f asm\n", cputime());

    // TEXT SECTION
    <<[[asmb()]] TEXT section>>

    // DATA SECTION
    <<[[asmb()]] DATA section>>

    // SYMBOL AND LINE TABLE
    <<[[asmb()]] symbol and line table section>>

    // HEADER
    <<[[asmb()]] header section>>

    cflush();
}
@
% HEADER section at the end, paradoxal, but do SEEK, and because
% the HEADER contain info about other sections such as size, so need
% to know those size first.
% no BSS section because the binary executable will not contain
% anything related to BSS except its size.


<<[[asmb()]] locals>>=
long OFFSET;
@
%<<global OFFSET(arm)>>=
%long	OFFSET;
%@
% was  a global but can not just be a local in asmb()

\subsection{Header}

<<[[asmb()]] header section>>=
DBG("%5.2f header\n", cputime());

OFFSET = 0;
seek(cout, OFFSET, SEEK__START);

switch(HEADTYPE) {
// see Exec in a.out.h
case H_PLAN9:
    <<[[asmb()]] if dynamic module magic header adjustment(arm)>>
    else
        lput(0x647);			/* magic */

    lput(textsize);			/* sizes */
    lput(datsize);
    lput(bsssize);
    lput(symsize);			/* nsyms */
    lput(entryvalue());		/* va of entry */
    lput(0L);
    lput(lcsize);
    break;
<<[[asmb()]] switch HEADTYPE (for header generation) cases(arm)>>
}
@
% all those xxxsize are globals, modified by previous phases
% s/0x647/E_MAGIC?


% less: could at least take initentry as a parameter instead of using a global
<<function entryvalue(arm)>>=
long
entryvalue(void)
{
    char *a;
    Sym *s;

    a = INITENTRY; // usually "_main"
    <<[[entryvalue()]] if digit INITENTRY>>

    s = lookup(a, 0);

    switch(s->type) {
    case SNONE:
        return INITTEXT; // no _main, start at beginning of binary then
    case STEXT: case SLEAF:
        return s->value;
    <<[[entryvalue()]] if dynamic module case>>
    default:
        diag("entry not TEXT: %s", s->name);
        return 0;
    }
}
@


\subsection{Text section}

<<[[asmb()]] locals>>=
Prog *p;
Optab *o;
@

% arm specficic
<<global autosize(arm)>>=
long	autosize;
@
% size for the locals? (and params?)
% used a lot by aclass()
%less: could be renamed curautosize

%less: have a <<adjust autosize when iterate over p thing>> ?


% important call, asmout()
<<[[asmb()]] TEXT section>>=
OFFSET = HEADR;
seek(cout, OFFSET, SEEK__START);
pc = INITTEXT;

for(p = firstp; p != P; p = p->link) {
    <<adjust curtext when iterate over instructions p>>
    if(p->as == ATEXT) {
        autosize = p->to.offset + 4; // locals
    }
    <<[[asmb()]] when in TEXT section, sanity check pc>>
    curp = p;

    // generate instruction!
    o = oplook(p);	/* could probably avoid this call */
    asmout(p, o);

    pc += o->size;
}

<<[[asmb()]] if debug a>>
cflush();

<<[[asmb()]] TEXT section, output strings in text segment>>
}
@
% +4? locals + RETURN? see "runtime conventions" section.
%lesS: "could avoid this call" because could just use p->optab?



<<[[asmb()]] when in TEXT section, sanity check pc>>=
if(p->pc != pc) {
    diag("phase error %lux sb %lux", p->pc, pc);
    if(!debug['a'])
        prasm(curp);
    pc = p->pc;
}
@
% span() and asmb() should compute the same pc values


<<[[asmb()]] if debug a>>=
if(debug['a']) {
    Bprint(&bso, "\n");
    Bflush(&bso);
}
@

\subsection{Data section}

% important call, datblk()
<<[[asmb()]] DATA section>>=
curtext = P;
switch(HEADTYPE) {
case H_PLAN9:
    OFFSET = HEADR+textsize;
    seek(cout, OFFSET, SEEK__START);
    break;
<<[[asmb()]] switch HEADTYPE (to position after text) cases(arm)>>
}

<<[[asmb()]] if dynamic module, before datblk()>>

for(t = 0; t < datsize; t += sizeof(buf)-100) {
    if(datsize-t > sizeof(buf)-100)
        datblk(t, sizeof(buf)-100, false);
    else
        datblk(t, datsize-t, false);
}
@
% what the fuss about those 100?? and what is sizeof(buf)?

<<[[asmb()]] locals>>=
long t, etext;
@

% it's an opti? need that?
<<[[asmb()]] TEXT section, output strings in text segment>>=
/* output strings in text segment */
etext = INITTEXT + textsize;
for(t = pc; t < etext; t += sizeof(buf)-100) {
    if(etext-t > sizeof(buf)-100)
        datblk(t, sizeof(buf)-100, true);
    else
        datblk(t, etext-t, true);
@

\subsection{Symbol and line table section}

% important call: asmlc()?
<<[[asmb()]] symbol and line table section>>=
// modified by asmsym()
symsize = 0;
// modified by asmlc()
lcsize = 0;

if(!debug['s']) {
    switch(HEADTYPE) {
    case H_PLAN9:
        OFFSET = HEADR+textsize+datsize;
        seek(cout, OFFSET, SEEK__START);
        break;
    <<[[asmb()]] switch HEADTYPE (for symbol table generation) cases(arm)>>
    }

    DBG("%5.2f sym\n", cputime());
    asmsym();

    DBG("%5.2f pc\n", cputime());
    asmlc();

    <<[[asmb()]] if dynamic module, call asmdyn()>>

    cflush();
}
else {
    <<[[asmb()]] if dynamic module and no symbol table generation>>
}
@



\section{Checking for unresolved symbols, [[undef()]]}

% rename check_if_still_undefined_symbols()?
<<function undef>>=
void
undef(void)
{
    int i;
    Sym *s;

    for(i=0; i<NHASH; i++)
        for(s = hash[i]; s != S; s = s->link)
            if(s->type == SXREF)
                diag("%s: not defined", s->name);
}
@


\chapter{Loading Objects}
%note: was called parsing, but objects are stored in a binary format so
% "loading" is more appropriate I think

% does reverse operation than object generation in Assembler.nw, and more!

%less: hmmm if C had proper ADT and a Marshall module that would be easier ...
% (but maybe less other-languages friendly)
%less: could factorize code with libmach?
% why not using 5obj.c from libmach/? because 5obj.c is incomplete?
% because it cares just about the symbol table?

\section{Object format}
% again ... repeat Assembler.nw section?

\section{Buffered input, [[buf]]}

% See buffer managment appendix,
% essentially this buf global! and buf.ibuf  which is is input buffer.

<<[[ldobj()]] locals(arm)>>=
byte *bloc;
byte *bsize;
int r;
@
% and parameter 'int c'
% bloc[xxx] will be what we will read from below in ldobj()

<<[[ldobj()]] bloc and bsize init>>=
bsize = buf.ibuf;
bloc = buf.ibuf;
@


<<[[ldobj()]] read if needed in loop:, adjust bloc and bsize>>=
r = bsize - bloc;
if(r < 100 && r < c) {		/* enough for largest prog */
    bsize = readsome(f, buf.ibuf, bloc, bsize, c);
    if(bsize == 0)
        goto eof;
    bloc = buf.ibuf;
    goto loop;
}
@
% >> >> >> >>
% readsome() is in appendix too

\section{A global and virtual [[pc]]}

% each call to ldobj() will increment this pc
<<global pc>>=
long	pc = 0;
@

% internal pc? objects are loaded after each other,
% but when had a local D_BRANCH then need now to adjust to a global value
<<[[ldobj()]] locals(arm)>>=
long ipc;
@
% so set to current pc when at the beginning of object


% This is for the D_STATIC; to handle conflicts with different files
% defining the same static entity. This is bumped each time
% a new object file is parsed, so it's safe.
<<global version>>=
int	version = 0;
@

\section{Instructions input, [[ldobj()]]}

<<[[ldobj()]] locals(arm)>>=
// enum<opcode>
short o;
Prog *p;
@
% the instruction p will be allocated

<<[[ldobj()]] locals(arm)>>=
bool skip;
@
% If set to true then generate a NOP actually for the currently
% read instruction. Used for DUPOK for instance.


% main -> objfile -> <>
% f = fd of opened object file
% c = size of object file, 
% pn = filename of object, 
<<function ldobj(arm)>>=
void
ldobj(fdt f, long c, char *pn)
{
    <<[[ldobj()]] locals(arm)>>

    <<[[ldobj()]] remember set of object filenames>>
    <<[[ldobj()]] bloc and bsize init>>

// can come from AEND
newloop:
    ipc = pc;
    version++;
    skip = false;

    memset(h, 0, sizeof(h));
    histfrogp = 0;

loop:
    if(c <= 0)
        goto eof;

    <<[[ldobj()]] read if needed in loop:, adjust bloc and bsize>>

    o = bloc[0];		/* as */
    <<[[ldobj()]] sanity check opcode in range(arm)>>

    <<[[ldobj()]] if ANAME or ASIGNAME(arm)>>

    p = malloc(sizeof(Prog));
    p->as = o;
    // reading the object binary file, opposite of outcode() in Assembler.nw
    <<[[ldobj()]] read one instruction in p>>
    <<[[ldobj()]] sanity check p>>

    if(debug['W'])
        print("%P\n", p);

    switch(o) {
    <<[[ldobj()]] switch opcode cases(arm)>>

    default:
    casedef:
        if(skip)
            nopout(p);

        // putting each object after each other, local offset become global
        if(p->to.type == D_BRANCH)
            p->to.offset += ipc;

        //add_list(firstp, lastp, p)
        lastp->link = p;
        lastp = p;

        p->pc = pc;
        pc++;
        break;
    }
    goto loop;

eof:
    diag("truncated object file: %s", pn);
}
@
%bugfix: again on gethunk, was doing if(nhunk < ...) instead of while(nhunk...)
% the bug seems only in arm, x86 does the correct while
% but forsyth say anyway a hunk is begger than a Prog so a if would work too

%hmm when exit from this function without an error?
% via AEND! that does have a return!

%todo:how does p->to.offset += ipc; works with library code?
% in objfile it seems we seek to the TEXT procedure we want but
% this procedure may not be the beginning of the object, and
% the D_BRANCH offsets are based on the beginning of the object file no?







<<[[ldobj()]] read one instruction in p>>=
p->scond = bloc[1];
p->reg   = bloc[2];
p->line  = bloc[3] | (bloc[4]<<8) | (bloc[5]<<16) | (bloc[6]<<24);
r = 7;
r += zaddr(bloc+7, &p->from, h);
r += zaddr(bloc+r, &p->to, h);

bloc += r;
c -= r;

p->link = P;
p->cond = P;
@
% >> >> >>


<<[[ldobj()]] sanity check opcode in range(arm)>>=
if(o <= AXXX || o >= ALAST) {
    diag("%s: line %ld: opcode out of range %d", pn, pc-ipc, o);
    print("	probably not a .5 file\n");
    errorexit();
}
@

<<[[ldobj()]] sanity check p>>=
if(p->reg > NREG)
    diag("register out of range %d", p->reg);
@



%\section{[[AGOK]]}
% can happen? I think we can remove it, 5c can't produce such opcodes. Can it?
% another kind of sanity check:
<<[[ldobj()]] switch opcode cases(arm)>>=
case AGOK:
    diag("unknown opcode\n%P", p);
    p->pc = pc;
    pc++;
    break;
@
%x86:     diag("%s: GOK opcode in %s", pn, TNAME);



% for e.g. ATEXT that are DUPOK
<<function nopout>>=
void
nopout(Prog *p)
{
    p->as = ANOP;
    p->from.type = D_NONE;
    p->to.type = D_NONE;
}
@
% why care about .type? because some code is look for
% D_BRANCH, for symbols, and so putting D_NONE ensure those
% code will not be triggred for what was transformed in NOP.





\section{Operand input, [[zaddr()]]}

<<[[zaddr()]] locals>>=
int c; // symidx
int size;
@

% mostly reverse of zaddr() in Assembler.nw 
% ldobj -> <>
% return number of bytes read to read this Adr
<<function zaddr(arm)>>=
int
zaddr(byte *p, Adr *a, Sym *h[])
{
    <<[[zaddr()]] locals>>

    a->type = p[0];
    a->reg = p[1];
    c = p[2];
    <<[[zaddr()]] sanity check symbol range>>
    a->sym = h[c];
    a->symkind = p[3];

    size = 4;

    <<[[zaddr()]] sanity check register range>>

    switch(a->type) {
    <<[[zaddr()]] cases>>
    default:
        print("unknown type %d\n", a->type);
        p[0] = ALAST+1;
        return 0;	/*  force real diagnostic */

    }
    <<[[zaddr()]] adjust curauto for D_AUTO or D_PARAM symkind>>

    return size;
}
@


<<[[zaddr()]] cases>>=
case D_NONE:
case D_REG:
case D_PSR:
    break;

case D_REGREG:
    a->offset = p[4];
    size++;
    break;

case D_CONST:
case D_SHIFT:
case D_OREG:
case D_BRANCH:
    a->offset = p[4] | (p[5]<<8) | (p[6]<<16) | (p[7]<<24);
    size += 4;
    break;

case D_SCONST:
    a->sval = malloc(NSNAME);
    memmove(a->sval, p+4, NSNAME);
    size += NSNAME;
    break;
@
%//case D_OCONST: was with D_SHIFT
% >> >> >> >>









<<[[zaddr()]] sanity check symbol range>>=
if(c < 0 || c > NSYM){
    print("sym out of range: %d\n", c);
    p[0] = ALAST+1;
    return 0;
}
@
% not sure those p[0] have any effects

<<[[zaddr()]] sanity check register range>>=
if(a->reg < 0 || a->reg > NREG) {
    print("register out of range %d\n", a->reg);
    p[0] = ALAST+1;
    return 0;	/*  force real diagnostic */
}
@


\section{adjusting [[curauto]]}

% parameters + locals list
<<global curauto>>=
Auto*	curauto;
@
% set for the first time where? bug? should be = nil?


<<[[zaddr()]] locals>>=
int t, l;
Sym *s;
Auto *u;
@
%old: t was i, but t(ype) better than i


<<[[zaddr()]] adjust curauto for D_AUTO or D_PARAM symkind>>=
s = a->sym;
t = a->symkind;
l = a->offset;

if(s == S || (t != D_AUTO && t != D_PARAM))
    return size;

for(u=curauto; u; u=u->link)
    if(u->asym == s)
     if(u->type == t) {
        if(u->aoffset > l)
            u->aoffset = l;
        return size;
    }

u = malloc(sizeof(Auto));
u->asym = s;
u->type = t;
u->aoffset = l;

//add_list(u, curauto)
u->link = curauto;
curauto = u;
@


\section{[[ATEXT]]}

% abuse from = symbolname, to = immediate constant size for locals

<<[[ldobj()]] switch opcode cases(arm)>>=
case ATEXT:
    <<[[ldobj()]] case ATEXT, if curtext not null adjustments for curauto>>
    curtext = p;

    skip = false; // needed?

    autosize = (p->to.offset+3L) & ~3L;
    p->to.offset = autosize;
    autosize += 4;

    s = p->from.sym;

    <<[[ldobj()]] sanity check for ATEXT symbol s>>

    s->type = STEXT;
    s->value = pc;

    // like in default case
    //add_list(firstp, lastp, p)
    lastp->link = p;
    lastp = p;
    p->pc = pc;
    pc++;

    //add_list(textp, etextp, p)
    if(textp == P) {
        textp = p;
        etextp = p;
    } else {
        etextp->cond = p;
        etextp = p;
    }
    break;
@
%$
% "virtual pc"

<<[[ldobj()]] sanity check for ATEXT symbol s>>=
if(s == S) {
    diag("TEXT must have a name\n%P", p);
    errorexit();
}
if(s->type != SNONE && s->type != SXREF) {
    <<[[ldobj()]] case ATEXT and section not SNONE or SXREF, if DUPOK>>
    diag("redefinition: %s\n%P", s->name, p);
}
@

<<[[ldobj()]] case ATEXT, if curtext not null adjustments for curauto>>=
if(curtext != P) {
    <<[[ldobj()]] case ATEXT, curauto adjustments with curhist>>
    curtext->to.autom = curauto;
    curauto = nil;
}
@

% +4 for ? saved PC? what about saved SP? when RET?
% assumes caller saves/restores SP?


\section{[[AGLOBL]]}

% not added in any list? because bss?

<<[[ldobj()]] switch opcode cases(arm)>>=
case AGLOBL:
    s = p->from.sym;

    <<[[ldobj()]] sanity check for AGLOBL symbol s>>

    s->type = SBSS; // for now SBSS; will be set maybe to SDATA in dodata()
    s->value = 0;
    if(p->to.offset > s->value)
        s->value = p->to.offset;
    break;
@
% what is offset for AGLOBL? It should be the immediate constant size of 
% the global. But how can s->value be different from 0 anyway?
% the test p->to.offset > s->value seems to always return true to me.
% or it's just to sanity check people entering negative size for the globals?

<<[[ldobj()]] sanity check for AGLOBL symbol s>>=
if(s == S) {
    diag("GLOBL must have a name\n%P", p);
    errorexit();
}
if(s->type != SNONE && s->type != SXREF) {
        diag("redefinition: %s\n%P", s->name, p);
}
@
%pad: the second check used to be written differently, but I prefer
% it this way to mimic more what we do for ATEXT

\section{[[ADATA]]}

<<[[ldobj()]] switch opcode cases(arm)>>=
case ADATA:
    <<[[ldobj()]] sanity check for ADATA symbol s>>

    //add_list(datap, edatap, p)
    p->link = datap;
    datap = p;

    break;
@
% no s->type = SDATA? it's done in dodata()

<<[[ldobj()]] sanity check for ADATA symbol s>>=
if(p->from.sym == S) {
    diag("DATA without a sym\n%P", p);
    break;
}
@

\section{[[AEND]]}

<<[[ldobj()]] switch opcode cases(arm)>>=
case AEND:

    <<[[ldobj()]] case AEND, curauto adjustments with curhist>>
    <<[[ldobj()]] case AEND, curauto adjustments>>

    if(c)
        goto newloop;
    return;
@
% when goto newloop? when have stuff behind an AEND?
% for library? aggregate to have AEND between files?

<<[[ldobj()]] case AEND, curauto adjustments>>=
if(curtext != P)
    curtext->to.autom = curauto;
curauto = nil;
curtext = P;
@


\section{Symbol table, [[ANAME]]}
% and [[ASIGNAME]]
% spreaded symbol table


<<[[ldobj()]] locals(arm)>>=
byte *stop;
@

<<[[ldobj()]] locals(arm)>>=
Sym *h[NSYM];
Sym *s;
@

<<[[ldobj()]] locals(arm)>>=
int v;
@

% it's not part of the switch, it's done before!
<<[[ldobj()]] if ANAME or ASIGNAME(arm)>>=
if(o == ANAME || o == ASIGNAME) {
    sig = 0;
    <<[[ldobj()]] if SIGNAME adjust sig>>

    stop = memchr(&bloc[3], '\0', bsize-&bloc[3]);
    <<[[ldobj()]] if stop is nil refill buffer and retry>>

    v = bloc[1];	/* type */
    o = bloc[2];	/* sym */
    bloc += 3;
    c -= 3;

    r = 0;
    if(v == D_STATIC)
        r = version;

    s = lookup((char*)bloc, r);

    c -= &stop[1] - bloc;
    bloc = stop + 1;

    <<[[ldobj()]] if sig not zero>>

    if(debug['W'])
        print("	ANAME	%s\n", s->name);

    h[o] = s;

    if((v == D_EXTERN || v == D_STATIC) && s->type == SNONE)
        s->type = SXREF;

    <<[[ldobj()]] when ANAME opcode, if D_FILE>>
    goto loop;
}
@
% SXREF! so mark the symbol as "we want to find its definition!" for
% objfile() and loadlib() to correctly work!

% buffer managment crap again
<<[[ldobj()]] if stop is nil refill buffer and retry>>=
if(stop == nil){
    bsize = readsome(f, buf.ibuf, bloc, bsize, c);
    if(bsize == 0)
        goto eof;
    bloc = buf.ibuf;
    stop = memchr(&bloc[3], '\0', bsize-&bloc[3]);
    if(stop == nil){
        fprint(2, "%s: name too long\n", pn);
        errorexit();
    }
}
@
% >> >>

\section{Safe linking with [[ASIGNAME]]}
% put in advanced topics? At the same time safe linking is
% an essential feature to me
%note: cool, like in ocamlc! ocaml does that too, to make linking more safe!

% ASIGNAME is a pseudo opcode generated by 5c.
% when 2 .c include some .h and reference an object, we
% want that they refer to the same object with the same type!

<<[[Sym]] other fields>>=
// md5sum of the type of the symbol
long	sig;
@

<<[[ldobj()]] locals(arm)>>=
ulong sig;
@

<<[[ldobj()]] if SIGNAME adjust sig>>=
if(o == ASIGNAME){
    sig = bloc[1] | (bloc[2]<<8) | (bloc[3]<<16) | (bloc[4]<<24);
    bloc += 4;
    c -= 4;
}
@
% >> >> >> >>


% s = ? symbol set in ldobj() to be?
<<[[ldobj()]] if sig not zero>>=
if(sig != 0){
    if(s->sig != 0 && s->sig != sig)
        diag("incompatible type signatures %lux(%s) and %lux(%s) for %s", s->sig, filen[s->file], sig, pn, s->name);
    s->sig = sig;
    s->file = files-1;
}
@



% local, but really kinda globals
<<[[ldobj()]] locals(arm)>>=
// growing_array<filename>  (grown for every 16 elements)
static char **filen;
// index of next free entry in filen
static int files = 0;
@

<<[[Sym]] other fields>>=
// idx in filen
ushort	file;
@


<<[[ldobj()]] remember set of object filenames>>=
<<[[ldobj()]] grow filen if not enough space>>
filen[files++] = strdup(pn);
@



% new filen (not a static this time)
<<[[ldobj()]] locals(arm)>>=
char **nfilen;
@

% =~ realloc
<<[[ldobj()]] grow filen if not enough space>>=
if((files&15) == 0){
    nfilen = malloc((files+16)*sizeof(char*));
    memmove(nfilen, filen, files*sizeof(char*));
    free(filen);
    filen = nfilen;
}
@

\section{File and line information, [[AHISTORY]]}
% tracing origin??


<<global histfrog>>=
Sym*	histfrog[MAXHIST];
@

<<constant MAXHIST>>=
MAXHIST		= 20,	/* limit of path elements for history symbols */
@

<<global histfrogp>>=
int	histfrogp;
@





% used by what? for debugging? when signature conflict! to print
% current filenames in conflict


% pn? filename of object file, but addlib() really abuse histgrog global
<<[[ldobj()]] switch opcode cases(arm)>>=
case AHISTORY:
    if(p->to.offset == -1) {
        addlib(pn);
        histfrogp = 0;
        goto loop;
    }

    addhist(p->line, D_FILE);		/* 'z' */
    if(p->to.offset)
        addhist(p->to.offset, D_FILE1);	/* 'Z' */
    histfrogp = 0;
    goto loop;
@

<<function addhist>>=
void
addhist(long line, int type)
{
    Auto *u;
    Sym *s;
    int i, j, k;

    s = malloc(sizeof(Sym));
    s->name = malloc(2*(histfrogp+1) + 1);

    u = malloc(sizeof(Auto));
    u->asym = s;
    u->type = type;
    u->aoffset = line;

    u->link = curhist;
    curhist = u;

    j = 1;
    for(i=0; i<histfrogp; i++) {
        k = histfrog[i]->value;
        s->name[j+0] = k>>8;
        s->name[j+1] = k;
        j += 2;
    }
}
@



<<global curhist>>=
Auto*	curhist;
@
% like curauto

% ldobj (case AEND | ATEXT | ??) -> <>
<<function histtoauto>>=
void
histtoauto(void)
{
    Auto *l;

    while(l = curhist) {
        curhist = l->link;
        l->link = curauto;
        curauto = l;
    }
}
@


<<[[ldobj()]] case ATEXT, curauto adjustments with curhist>>=
histtoauto();
@

<<[[ldobj()]] case AEND, curauto adjustments with curhist>>=
histtoauto();
@




<<enum sxxx cases>>=
SFILE,
@

<<global histgen>>=
int	histgen = 0;
@

<<[[ldobj()]] when ANAME opcode, if D_FILE>>=
if(v == D_FILE) {
    if(s->type != SFILE) {
        histgen++;
        s->type = SFILE;
        s->value = histgen;
    }
    if(histfrogp < MAXHIST) {
        histfrog[histfrogp] = s;
        histfrogp++;
    } else
        collapsefrog(s);
}
@


<<function collapsefrog>>=
void
collapsefrog(Sym *s)
{
    int i;

    /*
     * bad encoding of path components only allows
     * MAXHIST components. if there is an overflow,
     * first try to collapse xxx/..
     */
    for(i=1; i<histfrogp; i++)
        if(strcmp(histfrog[i]->name+1, "..") == 0) {
            memmove(histfrog+i-1, histfrog+i+1,
                (histfrogp-i-1)*sizeof(histfrog[0]));
            histfrogp--;
            goto out;
        }

    /*
     * next try to collapse .
     */
    for(i=0; i<histfrogp; i++)
        if(strcmp(histfrog[i]->name+1, ".") == 0) {
            memmove(histfrog+i, histfrog+i+1,
                (histfrogp-i-1)*sizeof(histfrog[0]));
            goto out;
        }

    /*
     * last chance, just truncate from front
     */
    memmove(histfrog+0, histfrog+1,
        (histfrogp-1)*sizeof(histfrog[0]));

out:
    histfrog[histfrogp-1] = s;
}
@

\chapter{Loading Libraries}

% 5l actually loads only the object files in the librairies containing 
% the functions/data which are mentionned by the main object files
% (starting from _main).
% So it removes lots of code which helps generate small binaries 
% (see helloc which is only 4618 bytes).
% Note that the granularity is the object file; if it was the function/data
% it could remove even more code.

% see 5l -W -v helloc.5 to see the different passes, which symbols
% are needed, which object files in the archive are read, which ANAME
% are processed, etc.

\section{[[ar]] format}

% from ar.h
<<constant ARMAG>>=
#define	ARMAG	"!<arch>\n"
@
% ARchive MAGic?

<<constant SARMAG>>=
#define	SARMAG	8
@
%size ARMAG

<<constant ARFMAG>>=
#define	ARFMAG	"`\n"
@
% ARchive F? MAGic
% separator between each ar_hdr entries?

<<constant SARNAME>>=
#define SARNAME	16
@
%size ARNAME
% so can't have symbol names of more than 16 characters?

% seems to be the symbol file header and also each file entry header
<<struct ar_hdr>>=
struct	ar_hdr
{
    char	name[SARNAME];

    char	date[12];
    char	uid[6];
    char	gid[6];
    char	mode[8];

    char	size[10]; // use atolwhex() to get the value
    char	fmag[2]; // ARFMAG
};
@
%less: s/char/byte!

% an archive contains:
% MAGIC header "<arch"
% symbol table which is a kind of map from symbol to file entry offset
% file entry header
% object file content
% file entry header
% object file content
% ...

<<constant SAR_HDR>>=
#define	SAR_HDR	(SARNAME+44)
@
% sizeof(struct ar_hdr)


<<global symname linker>>=
char	symname[]	= SYMDEF;
@
% in 5.out.h #define	SYMDEF "__.SYMDEF"
% the first ar_hdr entry is the symbol table.

%todo: What is the format of the symbol table?
% see the strchr(e+5, ...) below, it's weird

%I could not originally see how ldobj() could work
% when you seek to an individual TEXT. Indeed the branch jumps
% are absolute with the 0 basis as the first instruction in the file,
% not the first instruction in the procedure. It's because you
% actually don't seek to individual function. The symbol table
% contains offsets for symbols which are not the offset of their TEXT
% but the offset of their object file entry in the archive file.

\section{Loading libraries manually [[5l libxxx.a]]}

<<[[objfile()]] other locals>>=
struct ar_hdr arhdr;
long off, esym, cnt;
Sym *s;
char pname[LIBNAMELEN];
char name[LIBNAMELEN];
char *e, *start, *stop;
bool work;
int pass = 1;
@



<<[[objfile()]] when file is a library>>=
DBG("%5.2f ldlib: %s\n", cputime(), file);

l = read(f, &arhdr, SAR_HDR);

<<[[objfile()]] sanity check library header size and content>>

esym = SARMAG + SAR_HDR + atolwhex(arhdr.size);
off = SARMAG + SAR_HDR;

/*
 * just bang the whole symbol file into memory
 */
seek(f, off, 0);
cnt = esym - off;
start = malloc(cnt + 10);
cnt = read(f, start, cnt);
if(cnt <= 0){
    close(f);
    return;
}
stop = &start[cnt];
memset(stop, '\0', 10);

work = true;
while(work) {

    DBG("%5.2f library pass%d: %s\n", cputime(), pass, file);
    pass++;
    work = false;
    for(e = start; e < stop; e = strchr(e+5, 0) + 1) {

        s = lookup(e+5, 0);
        if(s->type == SXREF) {
            sprint(pname, "%s(%s)", file, s->name);
            DBG("%5.2f library: %s\n", cputime(), pname);
            
            l = e[1] & 0xff;
            l |= (e[2] & 0xff) << 8;
            l |= (e[3] & 0xff) << 16;
            l |= (e[4] & 0xff) << 24;
            // >> >> >> >>
            
            seek(f, l, SEEK__START);
            l = read(f, &arhdr, SAR_HDR);
            <<[[objfile()]] sanity check entry header>>
            l = atolwhex(arhdr.size);

            // loading the object file containing the symbol
            ldobj(f, l, pname);
            
            if(s->type == SXREF) {
                diag("%s: failed to load: %s", file, s->name);
                errorexit();
            }
            work = true; // maybe some new SXREF has been found in ldobj()
        }
    }
}
return;

bad:
    diag("%s: bad or out of date archive", file);
out:
    close(f);
@

% >> >> >>

%old:
%        /* need readn to read the dumps (at least) */
%        l = readn(f, &arhdr, SAR_HDR);
% but seems ugly, readn in lib_core/libc/port/readn.c seems to just
% do some repetitive read()

% double loop!  while work, for ;;
% this is where we include all relevant entities(actually object files), 
% and only those,
% so 5l can produce small binaries (good because plan9 does not have
% shared libraries).

<<[[objfile()]] sanity check library header size and content>>=
if(l != SAR_HDR) {
    diag("%s: short read on archive file symbol header", file);
    goto out;
}
if(strncmp(arhdr.name, symname, strlen(symname))) {
    diag("%s: first entry not symbol header", file);
    goto out;
}
@

<<[[objfile()]] sanity check entry header>>=
if(l != SAR_HDR)
    goto bad;
if(strncmp(arhdr.fmag, ARFMAG, sizeof(arhdr.fmag)))
    goto bad;
@


% Why need multi pass for libs? ocamlc does not allow this, so I commented
% it for now
%  ...
%            work = true;
%            xrefresolv = true;
%  ...
%<<global xrefresolv>>=
%bool	xrefresolv;
%@
%
%<<[[loadlib()]] reset xrefresolv>>=
%xrefresolv = false;
%@
%
%<<[[loadlib()]] if xrefresolv>>=
%if(xrefresolv)
%    for(h=0; h<nelem(hash); h++)
%         for(s = hash[h]; s != S; s = s->link)
%             if(s->type == SXREF) {
%                 DBG("symbol %s still not resolved, looping\n", s->name);//pad
%                 goto loop;
%             }
%@
% still some unresolved symbols, loop

\section{Loading libraries semi automatically [[5l -lxxx]]}

\subsection{Library search path}

<<global libdir>>=
// growing_array<dirname>
char**	libdir;
@

<<global nlibdir>>=
// index of next free entry in libdir
int	nlibdir	= 0;
@

<<global maxlibdir>>=
// index of last free entry in libdir
static	int	maxlibdir = 0;
@


\subsection{[[5l -L]]}

<<[[main()]] command line processing(arm)>>=
case 'L':
    addlibpath(EARGF(usage()));
    break;
@


% was called 'a', but root is a better name
<<[[main()]] locals(arm)>>=
char *root;
@

<<constant LIBNAMELEN>>=
#define	LIBNAMELEN	300
@

% used locals? move closer the the code that use it then
<<[[main()]] locals(arm)>>=
int c;
char name[LIBNAMELEN];
char *a;
@
% *a still needed now that renamed to root?


<<[[main()]] addlibpath("/{thestring}/lib") or ccroot>>=
<<[[main()]] change root if ccroot>>

// usually /{thestring}/lib/ as root = ""
snprint(name, sizeof(name), "%s/%s/lib", root, thestring);
addlibpath(name);
@

% possible to change default / search path
<<[[main()]] change root if ccroot>>=
root = getenv("ccroot");

if(root != nil && *root != '\0') {
    if(!fileexists(root)) {
        diag("nonexistent $ccroot: %s", root);
        errorexit();
    }
}else
    root = "";
@
%$








<<function addlibpath>>=
void
addlibpath(char *arg)
{
    char **p;

    // growing array libdir
    if(nlibdir >= maxlibdir) {
        if(maxlibdir == 0)
            maxlibdir = 8;
        else
            maxlibdir *= 2;
        p = malloc(maxlibdir*sizeof(*p));
        if(p == nil) {
            diag("out of memory");
            errorexit();
        }
        memmove(p, libdir, nlibdir*sizeof(*p));
        free(libdir);
        libdir = p;
    }

    libdir[nlibdir++] = strdup(arg);
}
@

\subsection{[[5l -lxxx]]}

% actually can also load them manually by specifing the full
% path of the .a with the lib prefix.

% when done manually by -l in command line of ld
<<[[objfile()]] adjust file if -lxxx filename>>=
if(file[0] == '-' && file[1] == 'l') {
    snprint(pname, sizeof(pname), "lib%s.a", file+2);
    e = findlib(pname);
    if(e == nil) {
        diag("cannot find library: %s", file);
        errorexit();
    }
    snprint(name, sizeof(name), "%s/%s", e, pname);
    file = name;
}
@

<<function findlib>>=
char*
findlib(char *file)
{
    int i;
    char name[LIBNAMELEN];

    for(i = 0; i < nlibdir; i++) {
        snprint(name, sizeof(name), "%s/%s", libdir[i], file);
        if(fileexists(name))
            return libdir[i];
    }
    return nil;
}
@



\section{Loading libraries automagically [[#pragma lib]]}
% when done automatically

% ldobj(case AHISTORY and local_line == -1 special mark) -> <>
<<function addlib>>=
void
addlib(char *obj)
{
    char fn1[LIBNAMELEN], fn2[LIBNAMELEN], comp[LIBNAMELEN];
    char *p, *name;
    int i;
    bool search;

    if(histfrogp <= 0)
        return;

    name = fn1;
    search = false;
    if(histfrog[0]->name[1] == '/') {
        sprint(name, "");
        i = 1;
    } else if(histfrog[0]->name[1] == '.') {
        sprint(name, ".");
        i = 0;
    } else {
        sprint(name, "");
        i = 0;
        search = true;
    }

    for(; i<histfrogp; i++) {
        snprint(comp, sizeof comp, histfrog[i]->name+1);

        // s/$0/<thechar>/
        for(;;) {
            p = strstr(comp, "$O");
            if(p == nil)
                break;
            memmove(p+1, p+2, strlen(p+2)+1);
            p[0] = thechar;
        }
        // s/$M/<thestring>/
        for(;;) {
            p = strstr(comp, "$M");
            if(p == nil)
                break;
            if(strlen(comp)+strlen(thestring)-2+1 >= sizeof comp) {
                diag("library component too long");
                return;
            }
            memmove(p+strlen(thestring), p+2, strlen(p+2)+1);
            memmove(p, thestring, strlen(thestring));
        }

        if(strlen(fn1) + strlen(comp) + 3 >= sizeof(fn1)) {
            diag("library component too long");
            return;
        }
        if(i > 0 || !search)
            strcat(fn1, "/");
        strcat(fn1, comp);
    }

    cleanname(name);

    if(search){
        p = findlib(name);
        if(p != nil){
            snprint(fn2, sizeof(fn2), "%s/%s", p, name);
            name = fn2;
        }
    }


    for(i=0; i<libraryp; i++)
        if(strcmp(name, library[i]) == 0)
            return;
    if(libraryp == nelem(library)){
        diag("too many autolibs; skipping %s", name);
        return;
    }

    p = malloc(strlen(name) + 1);
    strcpy(p, name);
    library[libraryp] = p;
    p = malloc(strlen(obj) + 1);
    strcpy(p, obj);
    libraryobj[libraryp] = p;
    libraryp++;
}
@




\chapter{Resolving}

% Ok loading objects and libs has been done. Normally
% have now a linked list of instructions in firstp, with a valid Prog->pc
% and a good symbol table where can see for instance the pc
% for every TEXT symbols.

<<[[main()]] resolving phases>>=
<<[[main()]] if export table or dynamic module(arm)>>

patch();
<<[[main()]] call doprofxxx() if profiling>>
noops();

dodata();
dotext();
@
% dodata() must precede dotext(), e.g.
% for SSTRING one must do dotata() before dotext.

% what we need to resolve?
% - code references
% - data references

% For data(globl) references it's a symbol, so need to assign
% an absolute location to this symbol. If it's a local or parameter
% it's relative so easier.
% For code they can be reduced to branch pc jump. If we use
% pointer to link a src to it's dest, and then far later assign
% a absolute concrete pc to the instructions, then easy.



%old:
%   patch();
%   <<[[main()]] call doprofxxx() if profiling>>
%   dodata();
%   follow();
%   if(firstp == P)
%       goto out;

%   noops();
%   span();
%
% but I think follow is optional, the order can be changed as
% some steps are independent I think, and test for firstp is not useful
% I think if you remove follow.



\section{Linking branch instructions, [[patch()]]}

% needed because better to use pointers to virtual pc because
% we will change the linked list of instructions. remove, strip,
% compact.

% Set Prog->cond for the branch instructions.
% (before transform branch instructions using symbols in regular branch 
% instructions using offsets (like labels))

% who will use this Prog->cond later? follow(), but if don't care
% about unreachable instruction, is patch() useful????

<<[[patch()]] locals>>=
Prog *p, *q;
int a;
long c;
Sym *s;
@
% essentially will add some links with p->cond = q;   for instruction p
% with opcode a == ABxx where q->pc == c where c is the branch offset value.

<<function patch(arm)>>=
void
patch(void)
{
    <<[[patch()]] locals>>

    DBG("%5.2f patch\n", cputime());

    <<[[patch()]] initialisations>>

    // pass 1
    for(p = firstp; p != P; p = p->link) {
        <<adjust curtext when iterate over instructions p>>

        <<[[patch()]] resolve branch instructions using symbols>>

        if(p->to.type == D_BRANCH && p->cond != UP) {
            c = p->to.offset;
            <<[[patch()]] find Prog reference q with pc == c>>
            p->cond = q;
        }
    }

    // pass 2
    for(p = firstp; p != P; p = p->link) {
        <<adjust curtext when iterate over instructions p>>
        if(p->cond != P && p->cond != UP) {
            p->cond = brloop(p->cond);
            if(p->cond != P)
             if(p->to.type == D_BRANCH)
                p->to.offset = p->cond->pc;
        }
    }
}
@
%less: ARET in conditional? but ARET has no args in Assembler.nw
%note: has the p->cond == UP because can have such things
% done for SUNDEF sections

% p->to.offset = p->cond->pc;
% can have changed?? yes because of brloop()
% s/brloop()/? follow_AB?

\subsection{Resolving branch instructions using symbols}

<<[[patch()]] resolve branch instructions using symbols>>=
a = p->as;
if((a == ABL || a == AB || a == ARET) &&
   p->to.type != D_BRANCH && 
   p->to.sym != S) {
    s = p->to.sym;
    switch(s->type) {
    case STEXT:
        p->to.offset = s->value;
        p->to.type = D_BRANCH;
        break;
    <<[[patch()]] switch section type for branch instruction, cases>>
    }
}
@

<<[[patch()]] switch section type for branch instruction, cases>>=
default:
    diag("undefined: %s\n%P", s->name, p);
    s->type = STEXT;
    s->value = vexit;
    break;
@

<<[[patch()]] locals>>=
long vexit;
@

<<[[patch()]] initialisations>>=
s = lookup("exit", 0);
vexit = s->value;
@


\subsection{Indexing [[pc]], forward links overlay}

<<[[patch()]] initialisations>>=
mkfwd();
@

% Allows to do some big jmps forward in the list of instructions, 
% to be faster than going just through ->link.
% Interesting data structure overlay on top of a simple linked list
% alternatives: 
%  - a hashtbl on Prog.pc? to get a Prog from a specific pc

<<constant LOG>>=
#define	LOG	5
@

<<[[Prog]] other fields>>=
Prog*	forwd;
@
%old: used to be part of an union with regused, but regused was actually
% unused

% main -> <> patch -> <>
<<function mkfwd>>=
void
mkfwd(void)
{
    long dwn[LOG], cnt[LOG];
    Prog *lst[LOG];
    Prog *p;
    int i;

    for(i=0; i<LOG; i++) {
        if(i == 0)
            cnt[i] = 1; 
        else
            cnt[i] = LOG * cnt[i-1];
        dwn[i] = 1;
        lst[i] = P;
    }

    i = 0;
    for(p = firstp; p != P; p = p->link) {
        <<adjust curtext when iterate over instructions p>>
        i--;
        if(i < 0)
            i = LOG-1;
        p->forwd = P;
        dwn[i]--;
        if(dwn[i] <= 0) {
            dwn[i] = cnt[i];
            if(lst[i] != P)
                lst[i]->forwd = p;
            lst[i] = p;
        }
    }
}
@

\subsection{Finding instruction at virtual [[pc]]}

<<[[patch()]] find Prog reference q with pc == c>>=
for(q = firstp; q != P;) {
    if((q->forwd != P) && (c >= q->forwd->pc)) {
        q = q->forwd; // big jump
    } else {
        if(c == q->pc)
            break; // found it!
        q = q->link; // small jump
    }
}
if(q == P) {
    diag("branch out of range %ld\n%P", c, p);
    p->to.type = D_NONE;
}
@

\subsection{Compacting chains of [[AB]], [[brloop()]]}


% main -> patch -> <>
%  p->cond = brloop(p->cond);
% compact a chain of AB to the end, and "detect" infinite chain loops
<<function brloop(arm)>>=
Prog*
brloop(Prog *p)
{
    Prog *q;
    int c = 0;

    for(; p!=P;) {
        if(p->as != AB)
            return p;
        q = p->cond;
        if(q <= p) {
            c++;
            if(q == p || c > 5000)
                break;
        }
        p = q;
    }
    return P;
}
@
% less: diag infinute loop detected?




\section{Virtual opcode rewriting, [[noops()]]}

% ARM only. there is a dostkoff in x86 but it's related only to the become
% stuff that I have now deleted for the ARM.

%noops() is for ASM opcodes which have actually no
%machine opcode (e.g. ADIV, ARET) so was using a fake/virtual opcode

<<function noops(arm)>>=
void
noops(void)
{
    Prog *p, *q, *q1;
    int o;

    /*
     * find leaf subroutines
     * strip NOPs
     * expand RET
     */

    DBG("%5.2f noops\n", cputime());

    // pass 1
    curtext = P;
    for(p = firstp; p != P; p = p->link) {
        <<adjust curtext when iterate over instructions p>>
        switch(p->as) {
        <<[[noops()]] first pass switch opcode cases>>
        }
    }

    // pass 2
    curtext = P;
    for(p = firstp; p != P; p = p->link) {
        <<adjust curtext when iterate over instructions p>>
        o = p->as;
        switch(o) {
        <<[[noops()]] second pass switch opcode cases>>
        }
    }
}
@

%old: there was lots of stuff about BECOME which I think was
% a feature necessary for the alef compiler, but it
% has been removed from plan9 edition 4 so this code
% was probably dead.

%    int curframe, curbecome, maxbecome;
%
%     * become sizes
%     * frame sizes
%
%     * expand BECOME pseudo
%
%    curframe = 0;
%    curbecome = 0;
%    maxbecome = 0;
%
%        /* find out how much arg space is used in this TEXT */
%        if(p->to.type == D_OREG && p->to.reg == REGSP)
%            if(p->to.offset > curframe)
%                curframe = p->to.offset;
%
%
%            if(curtext && curtext->from.sym) {
%                curtext->from.sym->frame = curframe;
%                curtext->from.sym->become = curbecome;
%                if(curbecome > maxbecome)
%                    maxbecome = curbecome;
%            }
%            curframe = 0;
%            curbecome = 0;
%
%
%        case ARET:
%            /* special form of RET is BECOME */
%            if(p->from.type == D_CONST)
%                if(p->from.offset > curbecome)
%                    curbecome = p->from.offset;
%            break;
%
%    if(curtext && curtext->from.sym) {
%        curtext->from.sym->frame = curframe;
%        curtext->from.sym->become = curbecome;
%        if(curbecome > maxbecome)
%            maxbecome = curbecome;
%    }
%
%    if(debug['b'])
%        print("max become = %d\n", maxbecome);
%    xdefine("ALEFbecome", STEXT, maxbecome);
%
%    curtext = P;
%    for(p = firstp; p != P; p = p->link) {
%        <<adjust curtext when iterate over instructions p>>
%        switch(p->as) {
%        case ABL:
%            if(curtext != P && curtext->from.sym != S && curtext->to.offset >= 0) {
%                o = maxbecome - curtext->from.sym->frame;
%                if(o <= 0)
%                    break;
%                /* calling a become or calling a variable */
%                if(p->to.sym == S || p->to.sym->become) {
%                    curtext->to.offset += o;
%                    if(debug['b']) {
%                        curp = p;
%                        print("%D calling %D increase %d\n",
%                            &curtext->from, &p->to, o);
%                    }
%                }
%            }
%            break;
%        }
%    }
%
%
%            if(p->from.type == D_CONST)
%                goto become;
%
%        become:
%            if(curtext->mark & LEAF) {
%                if(!autosize) {
%                    p->as = AB;
%                    p->from = zprg.from;
%                    break;
%                }
%            }
%            q = prg();
%            q->scond = p->scond;
%            q->line = p->line;
%            q->as = AB;
%            q->from = zprg.from;
%            q->to = p->to;
%            q->cond = p->cond;
%            q->link = p->link;
%            p->link = q;
%
%            // MOVW autosize(SP), LINK
%            p->as = AMOVW;
%            p->scond |= C_PBIT;
%            p->from = zprg.from;
%            p->from.type = D_OREG;
%            p->from.offset = autosize;
%            p->from.reg = REGSP;
%            p->to = zprg.to;
%            p->to.type = D_REG;
%            p->to.reg = REGLINK;
%
%            break;


%old: this was under some ifdef, probably experimental stuff
%#ifdef optimise_time
%                if(autosize) {
%                    q = prg();
%                    q->as = ASUB;
%                    q->line = p->line;
%                    q->from.type = D_CONST;
%                    q->from.offset = autosize;
%                    q->to.type = D_REG;
%                    q->to.reg = REGSP;
%
%                    q->link = p->link;
%                    p->link = q;
%                }
%                break;
%#else
%
%
%#ifdef optimise_time
%                p->as = AADD;
%                p->from.type = D_CONST;
%                p->from.offset = autosize;
%                p->to.type = D_REG;
%                p->to.reg = REGSP;
%
%                q = prg();
%                q->as = AB;
%                q->scond = p->scond;
%                q->line = p->line;
%                q->to.type = D_OREG;
%                q->to.offset = 0;
%                q->to.reg = REGLINK;
%
%                q->link = p->link;
%                p->link = q;
%
%                break;
%#endif
%
%#ifdef optimise_time
%                q = prg();
%                q->scond = p->scond;
%                q->line = p->line;
%                q->as = AB;
%                q->from = zprg.from;
%                q->to = p->to;
%                q->cond = p->cond;
%                q->link = p->link;
%                p->link = q;
%
%                p->as = AADD;
%                p->from = zprg.from;
%                p->from.type = D_CONST;
%                p->from.offset = autosize;
%                p->to = zprg.to;
%                p->to.type = D_REG;
%                p->to.reg = REGSP;
%
%                break;
%#endif

\subsection{Leaf procedure optimisation}
% could be put in Optimisation section?

<<enum sxxx cases>>=
SLEAF, // arm
@
% SLEAF? the special opti ARM has for leaf functions?

% if leaf procedure, no need to save current SP, noone
% will RET back to this procedure. Also
% we can use a special ABL that use a register instead
% of the stack to save the current PC so RET is also
% faster from this leaf.

<<enum mark cases>>=
LEAF		= 1<<2,
@
% >>
% example of mark. useful to see early? (as there are a few
% case STEXT: case SLEAF: below)

<<[[noops()]] first pass switch opcode cases>>=
case ATEXT:
    p->mark |= LEAF;
    break;

case ABL:
    if(curtext != P)
        curtext->mark &= ~LEAF;
    // fallthrough
<<[[noops()]] first pass switch opcode ABL fallthrough>>
@

% assumes can not make jump outside the function ...?
% the assembler checks that?

\subsection{[[ATEXT]] patching}

% if leaf procedure, no need to save REGLINK in the stack!
% hence the autosize = 0 I think

<<[[noops()]] second pass switch opcode cases>>=
case ATEXT:
    autosize = p->to.offset + 4;
    if(autosize <= 4)
      if(curtext->mark & LEAF) {
        p->to.offset = -4;
        autosize = 0;
    }

    if(!autosize && !(curtext->mark & LEAF)) {
        DBG("save suppressed in: %s\n", curtext->from.sym->name);
        curtext->mark |= LEAF;
    }

    if(curtext->mark & LEAF) {
        if(curtext->from.sym)
            curtext->from.sym->type = SLEAF;
        if(!autosize)
            break;
    }

    // MOVW R14, -autosize(SP)
    q1 = prg();
    q1->as = AMOVW;
    q1->scond |= C_WBIT;
    q1->line = p->line;
    q1->from.type = D_REG;
    q1->from.reg = REGLINK;
    q1->to.type = D_OREG;
    q1->to.offset = -autosize;
    q1->to.reg = REGSP;

    q1->link = p->link;
    p->link = q1;
    break;
@
% wbit??

\subsection{[[ARET]] rewriting}

<<[[noops()]] second pass switch opcode cases>>=
case ARET:
    <<[[noops()]] case ARET, call nocache>>
    if((curtext->mark & LEAF) && !autosize) {
        // B (R14)
        p->as = AB;
        p->from = zprg.from;
        p->to.type = D_OREG;
        p->to.offset = 0;
        p->to.reg = REGLINK;
    } else {
        // MOVW autosize(SP), PC
        p->as = AMOVW;
        p->scond |= C_PBIT;
        p->from.type = D_OREG;
        p->from.offset = autosize;
        p->from.reg = REGSP;
        p->to.type = D_REG;
        p->to.reg = REGPC;
    }
    break;
@
% pbit??


\subsection{[[ANOP]] stripping}

<<[[noops()]] first pass swith opcode cases>>=
case ANOP:
    q1 = p->link;
    q->link = q1;		/* q is non-nop */
    q1->mark |= p->mark;
    continue;
@

% now that have also the ->cond for branches, we need
% to take care and update those links as we removed
% some ANOP.

% so also case ABL: before
<<[[noops()]] first pass switch opcode ABL fallthrough>>=
case AB:

case ABEQ:
case ABNE:
case ABHS:
case ABLO:
case ABMI:
case ABPL:
case ABVS:
case ABVC:
case ABHI:
case ABLS:
case ABGE:
case ABLT:
case ABGT:
case ABLE:

case ABCASE:

    q1 = p->cond;
    if(q1 != P) {
        while(q1->as == ANOP) {
            q1 = q1->link;
            p->cond = q1;
        }
    }
    break;
@
% bug? q1 could be null in the loop?
% todo: write test case showing the bug?
% I would rewrite the code as
%   while(q1 != P && q1->as == ANOP) 
%       q1 = q1->link;
%   p->cond = q1;


\section{Laying out data, [[dodata()]]}
% computing datasize (and bsssize)
% != generating DATA

<<global datsize>>=
long	datsize;
@

<<global bsssize>>=
long	bsssize;
@

% The programmer specifies sizes for GLOBL, and their content via DATA,
% but he does not want to care about the precise layout. Here we layout,
% we put all the globals (spreaded in different instructions and different
% object files) next to each other, assigning concrete locations 
% (actually offset to INITDAT) to each GLOBL.
% Note that Sym.value changes "type" going from a size to now a location.

<<function dodata(arm)>>=
void
dodata(void)
{
    int i, t;
    Sym *s;
    Prog *p;
    long orig;
    long v;

    DBG("%5.2f dodata\n", cputime());

    // DATA instructions loop
    for(p = datap; p != P; p = p->link) {
        s = p->from.sym;
        <<[[dodata()]] if ADYNT or AINIT>>
        if(s->type == SBSS)
            s->type = SDATA;
        <<[[dodata()]] sanity check DATA instructions>>
    }

    <<[[dodata()]] if string in text segment>>

    orig = 0;

    /*
     * pass 1
     *  sanity check data values, and align.
     */
    // symbol table loop
    for(i=0; i<NHASH; i++)
     for(s = hash[i]; s != S; s = s->link) {
        t = s->type;
        if(t == SDATA || t == SBSS) {
            v = s->value;
            if(v == 0) { // check
                diag("%s: no size", s->name);
                v = 1;
            }
            while(v & 3) // align
                v++;
            s->value = v; // adjust
            <<[[dodata()]] if small data size>>
        }
    }

    /*
     * pass 2
     *	assign (large) 'data' variables to data segment
     */
    for(i=0; i<NHASH; i++)
     for(s = hash[i]; s != S; s = s->link) {
        t = s->type;
        if(t == SDATA) {
            // s->value used to contain the size of the GLOBL, 
            // now it's its location!
            v = s->value;
            if(v == 0) {
                diag("%s: no size", s->name);
                v = 1;
            }
            s->value = orig;
            orig += v;
        } else {
            <<[[dodata()]] pass2, retag small data>>
        }
    }

    while(orig & 7)
        orig++;

    datsize = orig;

    /*
     * pass 3
     *	everything else to bss segment
     */
    for(i=0; i<NHASH; i++)
     for(s = hash[i]; s != S; s = s->link) {
        if(s->type == SBSS) {
            // s->value used to contain the size of the GLOBL, 
            // now it's its location
            v = s->value;
            s->value = orig;
            orig += v;
        }
    }
    while(orig & 7)
        orig++;

    bsssize = orig-datsize;

    <<[[dodata()]] define special symbols>>
}
@
% now Sym.value for GLOBL is not the size anymore but the offset
% (offset to INITDAT though) changed type!
% note that first iteration is on datap instructions, the other
% loops are on the symbol table.

% could do orig = INITDAT? no, we can't because we don't know yet the size
% of the text ... this is computed in dotext(). 
% But does it have to be mutually recursive? If we there was not the
% SSTRING thing, could we do just dotext() before dodata()?


<<[[dodata()]] sanity check DATA instructions>>=
if(s->type != SDATA)
    diag("initialize non-data (%d): %s\n%P",
        s->type, s->name, p);
v = p->from.offset + p->reg;
if(v > s->value)
    diag("initialize bounds (%ld): %s\n%P",
        s->value, s->name, p);
@
% p->reg for boundaries ('DATA name / con, ximm')

\section{Laying out code, [[dotext()]]}
% computing textsize
% != generating TEXT

% Adjusting pc and code addresses to concrete values, 
% not symbolic pc! so then when generating the code for AB in
% the next chapter we can do p->cond->pc to know where to concretely jump.
% Start of use of INITTEXT! switch from a symbolic pc to a real pc
% where the size of the instructions now matter (hence use of oplook()).

<<global textsize>>=
long	textsize;
@


<<[[span()]] locals>>=
Prog *p;
Optab *o;
long c;
long v;
Sym *s;
int m, i;
@

<<function span(arm)>>=
void
dotext(void)
{
    <<[[span()]] locals>>

    DBG("%5.2f span\n", cputime());

    c = INITTEXT;
    <<[[span()]] initialisation>>

    for(p = firstp; p != P; p = p->link) {
       <<adjust curtext when iterate over instructions p>>

        p->pc = c;
        o = oplook(p);
        m = o->size;

        if(m == 0) {
            if(p->as == ATEXT) {
                autosize = p->to.offset + 4;
                if(p->from.sym != S)
                    p->from.sym->value = c;
                <<[[span()]] detect if large procedure>>
            } else {
                diag("zero-width instruction\n%P", p);
            }
        } else {
            c += m;
            <<[[span()]] pool handling for optab o>>
        }
    }

    <<[[span()]] if string in text segment>>

    c = rnd(c, 8);

    textsize = c - INITTEXT;
    <<[[span()]] define special symbols>>
    if(INITRND)
        INITDAT = rnd(c, INITRND);
    DBG("tsize = %lux\n", textsize);
}
@
%less: use orig instead of 'c' so match more dodata()?
% but here it's really a concrete location whereas for dodata()
% it's relative to INITDAT that we actually compute here.

%Is there a mutual recursive problem? oplook call
% aclass() which needs to know offset size, but we don't know
% yet INITDAT and how far it will be from R12 or other stuff.
% so bug? No because R12 will be INITDAT+BIG! this will not change.
% subtle.


%\subsection{Large procedures}
% need that?

<<[[span()]] locals>>=
long    otxt;
@

<<[[span()]] initialisation>>=
otxt = c;
@

<<[[span()]] detect if large procedure>>=
if(c - otxt >= 1L<<17) {
    diag("Procedure %s too large\n", TNAME);
    errorexit();
}
otxt = c;
@
% >>
%TODO: why big procedures are a problem???


%old: there was some special code to handle really large procedures
% but the code looked buggy, so I commented it out for now.

%<<[[span()]] locals>>=
%bool bflag;
%@
%
%<<[[span()]] initialisation>>=
%bflag = false;
%@
%
%
%<<[[span()]] if large procedure set bflag>>=
%/* need passes to resolve branches */
%if(c - otxt >= 1L<<17)
%    bflag = true;
%@
%% >>
%
%
%<<[[span()]] if large procedure>>=
%/*
% * if any procedure is large enough to
% * generate a large SBRA branch, then
% * generate extra passes putting branches
% * around jmps to fix. this is rare.
% */
%while(bflag) {
%    DBG("%5.2f span1\n", cputime());
%    bflag = false;
%    c = INITTEXT;
%    for(p = firstp; p != P; p = p->link) {
%        <<adjust curtext when iterate over instructions p>>
%        p->pc = c;
%        o = oplook(p);
%        m = o->size;
%        if(m == 0) {
%            if(p->as == ATEXT) {
%                autosize = p->to.offset + 4;
%                if(p->from.sym != S)
%                    p->from.sym->value = c;
%            } else {
%                diag("zero-width instruction\n%P", p);
%            }
%        } else {
%             c += m;
%        }
%    }
%}
%@
%bug? does not have the [[span()]] if large procedure set bflag here?

%/* very larg branches
%            if(o->type == 6 && p->cond) {
%                otxt = p->cond->pc - c;
%                if(otxt < 0)
%                    otxt = -otxt;
%                if(otxt >= (1L<<17) - 10) {
%                    q = prg();
%                    q->link = p->link;
%                    p->link = q;
%                    q->as = AB;
%                    q->to.type = D_BRANCH;
%                    q->cond = p->cond;
%                    p->cond = q;
%                    q = prg();
%                    q->link = p->link;
%                    p->link = q;
%                    q->as = AB;
%                    q->to.type = D_BRANCH;
%                    q->cond = q->link->link;
%                    bflag = 1;
%                }
%            }
% */



\section{Defining special symbols [[etext]], [[edata]], [[end]]}

% the kernel uses etext! edata! those are important special symbols.
% some form of introspection capability.

% At this point we are in dodata() (or span()) in which case the 'value' field
% is now really a location (relative to INITDAT though for SDATA and SBSS).
% This means the xdefine below now have a different meaning: the 3rd
% argument is a location, not a size anymore!

<<[[dodata()]] define special symbols>>=
xdefine("bdata", SDATA, 0L);
xdefine("edata", SDATA, datsize);
xdefine("end", SBSS, datsize+bsssize);
@
% 0L because SDATA/SBSS are relative to INITDAT. There are many code
% later then do the final s->value+INITDAT.

% how 'end' can be in SBSS section? we actually want it initialized ...
% because here it's actually about the layout! 'end' will have a location
% at the end of the SBSS! If do &end in C (or $end in asm) then you'll get
% a pointer to the end of the BSS! reflection power! 'end' has no value
% because it's in the BSS, but its location is its interesting value!


<<[[span()]] define special symbols>>=
xdefine("etext", STEXT, INITTEXT+textsize);
@

%old: 
%<<[[dodata()]] define special symbols>>=
%xdefine("etext", STEXT, 0L);
%@
%and in span():
%setext = lookup("etext", 0);
%if(setext != S) {
%    setext->value = c;
%    textsize = c - INITTEXT;



<<function xdefine(arm)>>=
void
xdefine(char *p, int t, long v)
{
    Sym *s;

    s = lookup(p, 0);
    if(s->type == SNONE || s->type == SXREF) {
        s->type = t;
        s->value = v;
    }
}
@


\chapter{Machine Code Generation (ARM)}

% The code generation is done by 5l, not 5a, surprisingly!
% Why? Because it allows more optimisations? cross libs? as in llvm?
% also more compact and simpler object format? and more cross platform?

\section{[[Optab]] and [[optab]]}
% hmm put in core DS? but it's really specific to the code generation chapter

<<struct Optab(arm)>>=
struct	Optab
{
    // enum<opcode> from 5.out.h, but represents a range, see oprange[]
    byte	as;

    // enum<cxxx>, possible operand_kind/class for first operand
    short	a1;
    // enum<cxxx>, possible operand_kind/class for second operand
    short	a2;
    // enum<cxxx>, possible operand_kind/class for third operand
    short	a3;

    // idx for the code generator, see the giant switch in asmout()
    short	type; 

    // size of the corresponding machine code, should be a multiple of 4
    short	size; 

    <<[[Optab]] other fields>>
};
@
% order is important, see optab[] global

%ex of entries:
% Optab	optab[] =
% {
%    { ATEXT,	C_LEXT,	C_NONE,	C_LCON, 	 0, 0, 0 },
%    { ATEXT,	C_LEXT,	C_REG,	C_LCON, 	 0, 0, 0 },
%    ...
%    { AADD,		C_REG,	C_REG,	C_REG,		 1, 4, 0 },
%    { AADD,		C_REG,	C_NONE,	C_REG,		 1, 4, 0 },


% ARM has fixed-length instructions, 4, but 5a/ support
% some fake/virtual opcodes that actually expands to 
% multiple instructions, hence the size field above.


%\section{[[optab]]}

% This table contains the different valid combinations 
% of operands for the different opcodes. Actually not all opcodes are put,
% only some representative (see also oprange that describes
% the equivalence classes).
% There is a strong coupling with the grammar 5a/a.y to see
% what operands are allowed, e.g. AMOV has gen operand which
% allow many things, but AADD has more restricted operands
% (immediate, shift, or plain register).

% not sure it needs this complexity, things could probably
% be factorized more.

<<global optab (linkers/5l/optab.c)(arm)>>=
Optab	optab[] =
{
    <<[[optab]] entries>>
    { AXXX,		C_NONE,	C_NONE,	C_NONE,		 0, 4, 0 },
};
@
% AXXX at the end? why not ALAST instead?
%old: { ASWI,		C_NONE,	C_NONE,	C_LOREG,	10, 4, 0 },



\section{[[Class]] and [[aclass()]]}
% was in core DS, but I think better here with Optab.

<<[[Adr]] other fields>>=
// enum<classx>
short	class;
@
%a more precise Adr.type
%old: was char, but ugly
% usually the class is computed via aclass() and used as an index
% in the optab complex structure. Not sure why it needs to be stored
% here in Adr too.


% seems called the class, see aclass(), a more precise operand_kind?
<<enum cxxx(arm)>>=
enum classx {
    C_NONE		= 0,

    C_REG,
    C_REGREG,
    C_SHIFT,
    C_PSR,

    C_BRANCH,

    <<cxxx(arm) cases>>

    C_GOK, // must be at the end e.g. for xcmp[] decl, or buildop loops
};
@
%diffs with operand_kind:
% - OREG splitted in many xxxOREG and xxxEXT (SB), xxAUTO (FP, SP)
% - D_CONST splitted in many xxxCON
% - S_CONST?
% - a new C_GOK, but could be called C_LAST I think
%
%less: do big categories, xxCON, xxAUTO, xxEXT, xxREG?
%old: there was C_SBRA, C_LBRA but LBRA was unused so I s/C_LBRA/C_BRANCH/
% there was also this in cmp()
%    case C_LBRA:
%        if(b == C_SBRA)
%            return 1;
%        break;
%



<<function aclass(arm)>>=
int
aclass(Adr *a)
{
    Sym *s;
    int t;

    switch(a->type) {
    case D_NONE:
        return C_NONE;

    case D_REG:
        return C_REG;
    case D_REGREG:
        return C_REGREG;
    case D_SHIFT:
        return C_SHIFT;
    case D_PSR:
        return C_PSR;

    case D_BRANCH:
        return C_BRANCH;

    <<[[aclass()]] switch type cases>>
    }
    return C_GOK;
}
@
% I think aclass() assumes the size of the sections
% has been computed so it can know if a symbol reference
% is close and so could be stored in a half-word, or if
% it's far away.



\section{[[SB/R12]], Half, Small, Large, Rot, Neg, and [[aclass()]]}
% those are some kinds of optimisations no?

% The load/store ARM instructions take 2 registers (src_val, dst_address)
% and a 12 bits offset (for a range of 4096, so really a page, maybe 2 if can
% do negative offset with a bit).
% That means that if you do  'MOVW $1, myglobal', naively you'll have to
% encode it as 3 instructions:
%     MOV $1, R1
%     MOV $myglobal, R2
%     STR R1, R2.
% But if myglobal is not that far from address 0 and you have a special
% register reserved that always contain 0 (e.g. R12),
% then you could use the 12bits offset instead of using a register
% and just do
%     MOV $1, R1
%     STR R1, R12+$myglobal
% If you have a special register which always contain the value 1, 
% then you do even better with just do 
%     STR R0, R12+$myglobal! 
% which is 3 times faster (well if the global address is in a cache).
%
% In practice the first page of the address space is always reserved
% so it's better to store in R12 a bigger value. R12 will actually
% be set to INITDAT+BIG.

<<[[dodata()]] define special symbols>>=
xdefine("setR12", SDATA, 0L+BIG);
@
% the value here is a location for DATA, so there is
% an implicit +INITDAT. Has to be, otherwise would have a mutually
% recursive issue between dodata and dotext because dotext
% need the layout of data, but this layout must start after the
% text ...

<<constant BIG>>=
BIG		= (1<<12)-4,
@
% lib_core/libc/arm/main9.s will do 
%	MOVW	$setR12(SB), R(sb)
% before anything.

% Note again that we cannot override setR12 address with our own data
% because of the use of lots of symbols. It's the same for btext,
% bdata, etc. Here we care actually only about the address, not the
% content at that address.

% why -4? otherwise could not reach the first data? offset
% can be negative or positive so actually can cover 2 pages of
% small data variables!


\subsection{Immediate address}

<<function immaddr(arm)>>=
long
immaddr(long v)
{
    if(v >= 0 && v <= 0xfff)
        return (v & 0xfff) |
            (1<<24) |	/* pre indexing */
            (1<<23);	/* pre indexing, up */
    if(v >= -0xfff && v < 0)
        return (-v & 0xfff) |
            (1<<24);	/* pre indexing */
    return 0;
}
@
% >> >> >>
% rename immsmall?
% why 0xfff? = 4095 so a page.


\subsection{Half immediate address}

<<function immhalf(arm)>>=
int
immhalf(long v)
{
    if(v >= 0 && v <= 0xff)
        return v |
            (1<<24)  |	/* pre indexing */
            (1<<23);	/* pre indexing, up */
    if(v >= -0xff && v < 0)
        return (-v & 0xff)|
            (1<<24);	/* pre indexing */
    return 0;
}
@
% >> >> >>
% seems identical to immhalf no? no now it's 0xff! not 0xfff

\subsection{Rotated immediate address}

<<function immrot(arm)>>=
long
immrot(ulong v)
{
    int i;

    for(i=0; i<16; i++) {
        if((v & ~0xff) == 0)
            return (i<<8) | v | (1<<25);
        v = (v<<2) | (v>>30);
    }
    return 0;
}
@
% >> >>

\subsection{[[instoffset]]}

<<global instoffset(arm)>>=
long	instoffset;
@
% instruction offset?


\subsection{[[aclass()]] refinments}

\subsubsection{[[D_OREG]]}

<<[[aclass()]] switch type cases>>=
case D_OREG:
    switch(a->symkind) {
    <<[[aclass()]] D_OREG case, switch symkind cases>>
    }
    return C_GOK;
@
% OREG usually is a dereference of a register or a symbol reference
% (which is then really an implicit offet to SB)

% H S L ? half, small, large?
<<cxxx(arm) cases>>=
C_HEXT,
C_SEXT,
C_LEXT,

C_FEXT,
C_HFEXT,
@
% EXT for? external symbol?

%xxx+y(SB)
<<[[aclass()]] D_OREG case, switch symkind cases>>=
case D_EXTERN:
case D_STATIC:
    if(a->sym == nil || a->sym->name == nil) {
        print("null sym external\n");
        print("%D\n", a);
        return C_GOK;
    }
    s = a->sym;
    t = s->type;
    if(t == SNONE || t == SXREF) {
        diag("undefined external: %s in %s",
            s->name, TNAME);
        s->type = SDATA;
    }
    <<[[aclass()]] when D_OREG and external symbol and dlm>>
    instoffset = s->value + a->offset - BIG;
    t = immaddr(instoffset);
    if(t) {
        if(immfloat(t))
            return immhalf(instoffset)? C_HFEXT : C_FEXT;
        return immhalf(instoffset)? C_HEXT : C_SEXT;
    }
    return C_LEXT;
@




<<cxxx(arm) cases>>=
C_HAUTO,	/* halfword insn offset (-0xff to 0xff) */
C_SAUTO,	/* -0xfff to 0xfff */
C_LAUTO,

C_FAUTO,	/* float insn offset (0 to 0x3fc, word aligned) */
C_HFAUTO,	/* both H and F */
@

<<[[aclass()]] D_OREG case, switch symkind cases>>=
case D_AUTO:
    instoffset = autosize + a->offset;
    t = immaddr(instoffset);
    if(t){
        if(immfloat(t))
            return immhalf(instoffset)? C_HFAUTO : C_FAUTO;
        return immhalf(instoffset)? C_HAUTO : C_SAUTO;
    }
    return C_LAUTO;
@

<<[[aclass()]] D_OREG case, switch symkind cases>>=
case D_PARAM:
    instoffset = autosize + a->offset + 4L;
    t = immaddr(instoffset);
    if(t){
        if(immfloat(t))
            return immhalf(instoffset)? C_HFAUTO : C_FAUTO;
        return immhalf(instoffset)? C_HAUTO : C_SAUTO;
    }
    return C_LAUTO;
@
% +4??

% RO? rotated?
<<cxxx(arm) cases>>=
C_HOREG,
C_SOREG,
C_LOREG,

C_ROREG,
C_SROREG,	/* both S and R */

C_FOREG,
C_HFOREG,
@

<<[[aclass()]] D_OREG case, switch symkind cases>>=
case D_NONE:
    instoffset = a->offset;
    t = immaddr(instoffset);
    if(t) {
        if(immfloat(t))
            return immhalf(instoffset)? C_HFOREG : C_FOREG;
            /* n.b. that it will also satisfy immrot */

         /* n.b. that immhalf() will also satisfy immrot */
        if(immhalf(instoffset))	
            return C_HOREG;

        if(immrot(instoffset))
            return C_SROREG;
        return immhalf(instoffset)? C_HOREG : C_SOREG;
    }
    if(immrot(instoffset))
        return C_ROREG;
    return C_LOREG;
@




\subsubsection{[[D_CONST]]}

<<[[aclass()]] switch type cases>>=
case D_CONST:
    switch(a->symkind) {
    <<[[aclass()]] D_CONST case, switch symkind cases>>
    }
    return C_GOK;
@


% Rotated, Negative, Large?
<<cxxx(arm) cases>>=
C_RCON,		/* 0xff rotated */
C_NCON,		/* ~RCON */
C_LCON,
@
%dead: C_SCON,		/* 0xffff */

<<[[aclass()]] D_CONST case, switch symkind cases>>=
case D_NONE:
    instoffset = a->offset;
    if(a->reg != R_NONE)
        goto aconsize;

    if(immrot(instoffset))
        return C_RCON;
    if(immrot(~instoffset))
        return C_NCON;
    return C_LCON;
@


% External const
<<cxxx(arm) cases>>=
C_RECON,
@
%dead: C_LECON
%optab:    { AMOVW,	C_LECON,C_NONE,	C_REG,		34, 8, REGSB,	LFROM },
%cmp:    case C_LECON:
%        if(b == C_RECON)
%            return 1;
%        break;

<<[[aclass()]] D_CONST case, switch symkind cases>>=
case D_EXTERN:
case D_STATIC:
    s = a->sym;
    if(s == S) // no warning?
        break;
    switch(s->type) {
    case STEXT: case SLEAF: case SSTRING:
    case SCONST:
    case SUNDEF:
        instoffset = s->value + a->offset;
        return C_LCON;
    case SNONE: case SXREF:
        diag("undefined external: %s in %s", s->name, TNAME);
        s->type = SDATA;
        // Fall through
    case SDATA: case SBSS: case SDATA1:
        if(!dlm) {
            instoffset = s->value + a->offset - BIG;
            if(immrot(instoffset) && instoffset != 0)
                return C_RECON;
        }
        instoffset = s->value + a->offset + INITDAT;
        return C_LCON;
    }
    diag("unknown section for %s", s->name);
    break;
@


%old: used to be but more messy I think, the +INITDAT is then confusing
%    case SNONE: case SXREF:
%        diag("undefined external: %s in %s", s->name, TNAME);
%        s->type = SDATA;
%        break;
%    }
%    if(!dlm) {
%        instoffset = s->value + a->offset - BIG;
%        if(immrot(instoffset) && instoffset != 0)
%            return C_RECON;
%    }
%    instoffset = s->value + a->offset + INITDAT;
%    return C_LCON;




<<cxxx(arm) cases>>=
C_RACON,
C_LACON,
@

<<[[aclass()]] D_CONST case, switch symkind cases>>=
case D_AUTO:
    instoffset = autosize + a->offset;
    goto aconsize;

@
<<[[aclass()]] D_CONST case, switch symkind cases>>=
case D_PARAM:
    instoffset = autosize + a->offset + 4L;
    goto aconsize;
@

<<[[aclass()]] D_CONST case, switch symkind cases>>=
aconsize:
    return immrot(instoffset)? C_RACON : C_LACON;
@



%old: dead: this advanced addressing mode of 5a is not that useful
%    case D_OCONST:
%        switch(a->name) {
%        case D_EXTERN:
%        case D_STATIC:
%            s = a->sym;
%            t = s->type;
%            if(t == 0 || t == SXREF) {
%                diag("undefined external: %s in %s",
%                    s->name, TNAME);
%                s->type = SDATA;
%            }
%            instoffset = s->value + a->offset + INITDAT;
%            if(s->type == STEXT || s->type == SLEAF || s->type == SUNDEF)
%                instoffset = s->value + a->offset;
%            return C_LCON;
%        }
%        return C_GOK;





\subsection{Pool}
% ????

<<[[Optab]] other fields>>=
// 0 | REGSB | REGSP
short	param;
// bitset<enum<optab_flag>>
short	flag;
@
%old: was char, but ugly
% order is important, see optab[] global

<<enum optab_flag(arm)>>=
enum optab_flag {
    LFROM	= 1<<0,
    LTO		= 1<<1,
    LPOOL	= 1<<2,
    <<enum optab_flag cases>>
};
@
% >> >> >> >> >>



<<[[span()]] pool handling for optab o>>=
switch(o->flag & (LFROM|LTO|LPOOL)) {
case LFROM:
    addpool(p, &p->from);
    break;
case LTO:
    addpool(p, &p->to);
    break;

case LPOOL:
    if ((p->scond&C_SCOND) == COND_ALWAYS)
        flushpool(p, 0);
    break;
}

if(p->as==AMOVW && p->to.type==D_REG && p->to.reg==REGPC && 
   (p->scond&C_SCOND) == COND_ALWAYS)
    flushpool(p, 0);

if(blitrl)
    checkpool(p);
@
% c += m; used to be before if(blitrl)


% arm specific
<<global pool(arm)>>=
static struct {
    ulong	start;
    ulong	size;
} pool;
@


<<function checkpool(arm)>>=
/*
 * when the first reference to the literal pool threatens
 * to go out of range of a 12-bit PC-relative offset,
 * drop the pool now, and branch round it.
 * this happens only in extended basic blocks that exceed 4k.
 */
void
checkpool(Prog *p)
{
    if(pool.size >= 0xffc || immaddr((p->pc+4)+4+pool.size - pool.start+8) == 0)
        flushpool(p, 1);
    else if(p->link == P)
        flushpool(p, 2);
}
@

<<global blitrl(arm)>>=
Prog*	blitrl;
@

<<global elitrl(arm)>>=
Prog*	elitrl;
@


<<function flushpool(arm)>>=
void
flushpool(Prog *p, int skip)
{
    Prog *q;

    if(blitrl) {
        if(skip){
            if(debug['v'] && skip == 1)
                print("note: flush literal pool at %lux: len=%lud ref=%lux\n", p->pc+4, pool.size, pool.start);
            q = prg();
            q->as = AB;
            q->to.type = D_BRANCH;
            q->cond = p->link;
            q->link = blitrl;
            blitrl = q;
        }
        else if(p->pc+pool.size-pool.start < 2048)
            return;
        elitrl->link = p->link;
        p->link = blitrl;
        blitrl = nil;	/* BUG: should refer back to values until out-of-range */
        elitrl = nil;
        pool.size = 0;
        pool.start = 0;
    }
}
@

<<function addpool(arm)>>=
void
addpool(Prog *p, Adr *a)
{
    Prog *q, t;
    int c;

    c = aclass(a);

    t = zprg;
    t.as = AWORD;

    switch(c) {
    case C_SROREG:
    case C_LOREG:
    case C_ROREG:
    case C_FOREG:
    case C_SOREG:
    case C_FAUTO:
    case C_SAUTO:
    case C_LAUTO:
    case C_LACON:
        t.to.type = D_CONST;
        t.to.offset = instoffset;
        break;
    default:
        t.to = *a;
        break;
    }

    for(q = blitrl; q != P; q = q->link)	/* could hash on t.t0.offset */
        if(memcmp(&q->to, &t.to, sizeof(t.to)) == 0) {
            p->cond = q;
            return;
        }

    q = prg();
    *q = t;
    q->pc = pool.size;

    if(blitrl == P) {
        blitrl = q;
        pool.start = p->pc;
    } else
        elitrl->link = q;
    elitrl = q;
    pool.size += 4;

    p->cond = q;
}
@


\section{[[buildop()]]}

<<[[main()]] initialize globals(arm)>>=
buildop();
@

% Optab range?
<<struct Oprang(arm)>>=
struct	Oprang
{
    Optab*	start;
    Optab*	stop;
};
@

<<global oprange(arm)>>=
Oprang	oprange[ALAST];
@

<<function buildop(arm)>>=
void
buildop(void)
{
    int i, n;
    // enum<opcode> representing a range
    int r;

    <<[[buildop()]] initialize xcmp cache>>
    <<[[buildop()]] initializer floating flags>>

    for(n=0; optab[n].as != AXXX; n++) {
        <<[[buildop()]] adjust optab if floating flags>>
    }

    qsort(optab, n, sizeof(optab[0]), ocmp);

    for(i=0; i<n; i++) {
        r = optab[i].as;

        oprange[r].start = optab+i;
        while(optab[i].as == r)
            i++;
        oprange[r].stop = optab+i;
        i--;

        switch(r)
        {
        <<[[buildop()]] switch opcode r for ranges cases>>
        default:
            diag("unknown op in build: %A", r);
            errorexit();
        }
    }
}
@
%old:		case ABX:
%old:		case ABXRET:
% coupling with order of opcode in 5.out.h? no, this just
% describe the equivalence classes for optab, that
% is an entry in optab about AADD is also valid for AAND, etc.
% invariant: the case in the switch must be the entries in optab, not
% more, not less



<<[[buildop()]] switch opcode r for ranges cases>>=
case AXXX:
    break;
@
% no ARET? no because noops should have rewrote it.
% no ADATA/AGLOBL because buildop is used for code (TEXT) generation,
% not for data (DATA) generation.



% buildop -> qsort(..., <>)
<<function ocmp(arm)>>=
int
ocmp(const void *a1, const void *a2)
{
    Optab *p1, *p2;
    int n;

    p1 = (Optab*)a1;
    p2 = (Optab*)a2;

    n = p1->as - p2->as;
    if(n)
        return n;
    <<[[ocmp()]] if floating point flag on p1 or p2>>
    n = p1->a1 - p2->a1;
    if(n)
        return n;
    n = p1->a2 - p2->a2;
    if(n)
        return n;
    n = p1->a3 - p2->a3;

    if(n)
        return n;
    return 0;
}
@

%/*
%void
%buildrep(int x, int as)
%{
%    Opcross *p;
%    Optab *e, *s, *o;
%    int a1, a2, a3, n;
%
%    if(C_NONE != 0 || C_REG != 1 || C_GOK >= 32 || x >= nelem(opcross)) {
%        diag("assumptions fail in buildrep");
%        errorexit();
%    }
%    repop[as] = x;
%    p = (opcross + x);
%    s = oprange[as].start;
%    e = oprange[as].stop;
%    for(o=e-1; o>=s; o--) {
%        n = o-optab;
%        for(a2=0; a2<2; a2++) {
%            if(a2) {
%                if(o->a2 == C_NONE)
%                    continue;
%            } else
%                if(o->a2 != C_NONE)
%                    continue;
%            for(a1=0; a1<32; a1++) {
%                if(!xcmp[a1][o->a1])
%                    continue;
%                for(a3=0; a3<32; a3++)
%                    if(xcmp[a3][o->a3])
%                        (*p)[a1][a2][a3] = n;
%            }
%        }
%    }
%    oprange[as].start = 0;
%}
%*/

% there was this in oplook() but I think it could not work
% if buildrep was not called
%    if(o == nil) {
%        a1 = opcross[repop[r]][a1][a2][a3];
%        if(a1) {
%            p->optab = a1+1;
%            return optab+a1;
%        }
%        o = oprange[r].stop; /* just generate an error */
%    }

%extern	uchar	repop[ALAST];
%
%<<global repop(arm)>>=
%uchar	repop[ALAST];
%@
%
%typedef	uchar	Opcross[32][2][32];
%
%extern	Opcross	opcross[8];
%
%<<global opcross(arm)>>=
%Opcross	opcross[8];
%@

\section{[[oplook()]]}


% cmp for compatible?
<<function cmp(arm)>>=
bool
cmp(int a, int b)
{

    if(a == b)
        return true;

    switch(a) {
    case C_LCON:
        if(b == C_RCON || b == C_NCON)
            return true;
        break;
    case C_LACON:
        if(b == C_RACON)
            return true;
        break;

    case C_HFEXT:
        return b == C_HEXT || b == C_FEXT;
    case C_FEXT:
    case C_HEXT:
        return b == C_HFEXT;
    case C_SEXT:
        return cmp(C_HFEXT, b);
    case C_LEXT:
        return cmp(C_SEXT, b);

    case C_HFAUTO:
        return b == C_HAUTO || b == C_FAUTO;
    case C_FAUTO:
    case C_HAUTO:
        return b == C_HFAUTO;
    case C_SAUTO:
        return cmp(C_HFAUTO, b);
    case C_LAUTO:
        return cmp(C_SAUTO, b);

    case C_HFOREG:
        return b == C_HOREG || b == C_FOREG;
    case C_FOREG:
    case C_HOREG:
        return b == C_HFOREG;
    case C_SROREG:
        return cmp(C_SOREG, b) || cmp(C_ROREG, b);
    case C_SOREG:
    case C_ROREG:
        return b == C_SROREG || cmp(C_HFOREG, b);
    case C_LOREG:
        return cmp(C_SROREG, b);

    }
    return false;
}
@

% cmp() cache for oplook()
<<global xcmp(arm)>>=
char	xcmp[C_GOK+1][C_GOK+1];
@

<<[[buildop()]] initialize xcmp cache>>=
for(i=0; i<C_GOK; i++)
    for(n=0; n<C_GOK; n++)
        xcmp[i][n] = cmp(n, i);
@






<<[[Prog]] other fields>>=
byte	optab;
@
% not sure it's needed

% leverage the sorted data structure computed by buildop()
% dotext | asmb -> <>
<<function oplook(arm)>>=
Optab*
oplook(Prog *p)
{
    int a1, a2, a3, r;
    char *c1, *c3;
    Optab *o, *e;

    a1 = p->optab;
    if(a1)
        return optab+(a1-1);

    a1 = p->from.class;
    if(a1 == C_NONE) {
        a1 = aclass(&p->from) + 1;
        p->from.class = a1;
    }
    a1--;

    a3 = p->to.class;
    if(a3 == C_NONE) {
        a3 = aclass(&p->to) + 1;
        p->to.class = a3;
    }
    a3--;

    a2 = C_NONE;
    if(p->reg != R_NONE)
        a2 = C_REG;

    r = p->as;
    o = oprange[r].start;
    if(o == nil) {
        o = oprange[r].stop; /* just generate an error */
    }
    e = oprange[r].stop;
    c1 = xcmp[a1];
    c3 = xcmp[a3];
    for(; o<e; o++)
        if(o->a2 == a2)
         if(c1[o->a1])
          if(c3[o->a3]) {
            p->optab = (o-optab)+1;
            return o;
        }

    diag("illegal combination %A %d %d %d",
        p->as, a1, a2, a3);
    prasm(p);
    if(o == nil)
        o = optab;
    return o;
}
@

%    if(0) {
%        print("oplook %A %d %d %d\n",
%            (int)p->as, a1, a2, a3);
%        print("		%d %d\n", p->from.type, p->to.type);
%    }


<<[[noops()]] case ARET, call nocache>>=
nocache(p);
@

% ???
<<function nocache(arm)>>=
void
nocache(Prog *p)
{
    p->optab = 0;
    p->from.class = C_NONE;
    p->to.class = C_NONE;
}
@



\section{Text section, [[asmout()]]}

<<global PP(arm)>>=
static Prog *PP;
@

<<function asmout(arm)>>=
void
asmout(Prog *p, Optab *o)
{
    long o1, o2, o3, o4, o5, o6;
    long v;
    int r, rf, rt, rt2;
    Sym *s;

    PP = p;
    o1 = o2 = o3 = o4 = o5 = o6 = 0;

    switch(o->type) {
    <<[[asmout()]] switch on type cases>>
    default:
        diag("unknown asm %d", o->type);
        prasm(p);
        break;
    }

    if(debug['a'] > 1)
        Bprint(&bso, "%2d ", o->type);

    v = p->pc;
    switch(o->size) {
    <<[[asmout()]] switch on size cases>>
    default:
        if(debug['a'])
            Bprint(&bso, " %.8lux:\t\t%P\n", v, p);
        break;
    }
}
@
%$




<<[[asmout()]] switch on size cases>>=
case 4:
    if(debug['a'])
        Bprint(&bso, " %.8lux: %.8lux\t%P\n", v, o1, p);
    lputl(o1);
    break;
case 8:
    if(debug['a'])
        Bprint(&bso, " %.8lux: %.8lux %.8lux%P\n", v, o1, o2, p);
    lputl(o1);
    lputl(o2);
    break;
case 12:
    if(debug['a'])
        Bprint(&bso, " %.8lux: %.8lux %.8lux %.8lux%P\n", v, o1, o2, o3, p);
    lputl(o1);
    lputl(o2);
    lputl(o3);
    break;
case 16:
    if(debug['a'])
        Bprint(&bso, " %.8lux: %.8lux %.8lux %.8lux %.8lux%P\n",
            v, o1, o2, o3, o4, p);
    lputl(o1);
    lputl(o2);
    lputl(o3);
    lputl(o4);
    break;
case 20:
    if(debug['a'])
        Bprint(&bso, " %.8lux: %.8lux %.8lux %.8lux %.8lux %.8lux%P\n",
            v, o1, o2, o3, o4, o5, p);
    lputl(o1);
    lputl(o2);
    lputl(o3);
    lputl(o4);
    lputl(o5);
    break;
case 24:
    if(debug['a'])
        Bprint(&bso, " %.8lux: %.8lux %.8lux %.8lux %.8lux %.8lux %.8lux%P\n",
            v, o1, o2, o3, o4, o5, o6, p);
    lputl(o1);
    lputl(o2);
    lputl(o3);
    lputl(o4);
    lputl(o5);
    lputl(o6);
    break;
@



\subsection{[[ATEXT]]}

<<[[buildop()]] switch opcode r for ranges cases>>=
case ATEXT:
    break;
@


<<[[optab]] entries>>=
{ ATEXT,	C_LEXT,	C_NONE,	C_LCON, 	 0, 0, 0 },
{ ATEXT,	C_LEXT,	C_REG,	C_LCON, 	 0, 0, 0 },
@

<<[[asmout()]] switch on type cases>>=
case 0:		/* pseudo ops */
    break;
@
% nothing to be done! TEXT is a pseudo opcode, and noops()
% has patched it with the initial mov SP, so we're good
% to go

\subsection{[[AWORD]]}

<<[[buildop()]] switch opcode r for ranges cases>>=
case AWORD:
    break;
@

<<[[optab]] entries>>=
{ AWORD,	C_NONE,	C_NONE,	C_LCON,		11, 4, 0 },
{ AWORD,	C_NONE,	C_NONE,	C_LEXT,		11, 4, 0 },
@

<<[[asmout()]] switch on type cases>>=
case 11:	/* word */
    switch(aclass(&p->to)) {
    <<[[asmout()]] on WORD case, switch class cases>>
    }
    o1 = instoffset;
    break;
@

\subsection{Arithmetic opcodes}

<<[[buildop()]] switch opcode r for ranges cases>>=
case AADD:
    oprange[AAND] = oprange[r];
    oprange[AEOR] = oprange[r];
    oprange[ASUB] = oprange[r];
    oprange[ARSB] = oprange[r];
    oprange[AADC] = oprange[r];
    oprange[ASBC] = oprange[r];
    oprange[ARSC] = oprange[r];
    oprange[AORR] = oprange[r];
    oprange[ABIC] = oprange[r];
    break;
@
<<[[buildop()]] switch opcode r for ranges cases>>=
case ACMP:
    oprange[ATST] = oprange[r];
    oprange[ATEQ] = oprange[r];
    oprange[ACMN] = oprange[r];
    break;
@
<<[[buildop()]] switch opcode r for ranges cases>>=
case AMVN:
    break;
@


<<[[optab]] entries>>=
{ AADD,		C_REG,	C_REG,	C_REG,		 1, 4, 0 },
{ AADD,		C_REG,	C_NONE,	C_REG,		 1, 4, 0 },
{ AMOVW,	C_REG,	C_NONE,	C_REG,		 1, 4, 0 },
{ AMVN,		C_REG,	C_NONE,	C_REG,		 1, 4, 0 },
{ ACMP,		C_REG,	C_REG,	C_NONE,		 1, 4, 0 },

{ AADD,		C_RCON,	C_REG,	C_REG,		 2, 4, 0 },
{ AADD,		C_RCON,	C_NONE,	C_REG,		 2, 4, 0 },
{ AMOVW,	C_RCON,	C_NONE,	C_REG,		 2, 4, 0 },
{ AMVN,		C_RCON,	C_NONE,	C_REG,		 2, 4, 0 },
{ ACMP,		C_RCON,	C_REG,	C_NONE,		 2, 4, 0 },

{ AADD,		C_SHIFT,C_REG,	C_REG,		 3, 4, 0 },
{ AADD,		C_SHIFT,C_NONE,	C_REG,		 3, 4, 0 },
{ AMVN,		C_SHIFT,C_NONE,	C_REG,		 3, 4, 0 },
{ ACMP,		C_SHIFT,C_REG,	C_NONE,		 3, 4, 0 },
@

<<[[asmout()]] switch on type cases>>=
case 1:		/* op R,[R],R */
    o1 = oprrr(p->as, p->scond);
    rf = p->from.reg;
    rt = p->to.reg;
    r = p->reg;
    if(p->to.type == D_NONE)
        rt = 0;
    if(p->as == AMOVW || p->as == AMVN)
        r = 0;
    else if(r == R_NONE)
        r = rt;
    o1 |= rf | (r<<16) | (rt<<12);
    break;
@
% >> >>

<<function oprrr(arm)>>=
long
oprrr(int a, int sc)
{
    long o;

    o = (sc & C_SCOND) << 28;
    if(sc & C_SBIT)
        o |= 1 << 20;
    if(sc & (C_PBIT|C_WBIT))
        diag(".P/.W on dp instruction");

    switch(a) {
    case AAND:	return o | (0x0<<21);
    case AEOR:	return o | (0x1<<21);
    case ASUB:	return o | (0x2<<21);
    case ARSB:	return o | (0x3<<21);
    case AADD:	return o | (0x4<<21);
    case AADC:	return o | (0x5<<21);
    case ASBC:	return o | (0x6<<21);
    case ARSC:	return o | (0x7<<21);
    case ATST:	return o | (0x8<<21) | (1<<20);
    case ATEQ:	return o | (0x9<<21) | (1<<20);
    case ACMP:	return o | (0xa<<21) | (1<<20);
    case ACMN:	return o | (0xb<<21) | (1<<20);
    case AORR:	return o | (0xc<<21);
    case AMOVW:	return o | (0xd<<21);
    case ABIC:	return o | (0xe<<21);
    case AMVN:	return o | (0xf<<21);

    case AMULU:
    case AMUL:	return o | (0x0<<21) | (0x9<<4);
    case AMULA:	return o | (0x1<<21) | (0x9<<4);
    case AMULLU:	return o | (0x4<<21) | (0x9<<4);
    case AMULL:		return o | (0x6<<21) | (0x9<<4);
    case AMULALU:	return o | (0x5<<21) | (0x9<<4);
    case AMULAL:	return o | (0x7<<21) | (0x9<<4);

    case ASLL:	return o | (0xd<<21) | (0<<5);
    case ASRL:	return o | (0xd<<21) | (1<<5);
    case ASRA:	return o | (0xd<<21) | (2<<5);

    case ASWI:	return o | (0xf<<24);

    <<[[oprrr()]] switch cases>>
    }
    diag("bad rrr %d", a);
    prasm(curp);
    return 0;
}
@
% >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >>
% >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >>
% >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >>
% >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >>
% >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >>
% >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >>




<<[[asmout()]] switch on type cases>>=
case 2:		/* movbu $I,[R],R */
    aclass(&p->from);
    o1 = oprrr(p->as, p->scond);
    o1 |= immrot(instoffset);
    rt = p->to.reg;
    r = p->reg;
    if(p->to.type == D_NONE)
        rt = 0;
    if(p->as == AMOVW || p->as == AMVN)
        r = 0;
    else if(r == R_NONE)
        r = rt;
    o1 |= (r<<16) | (rt<<12);
    break;
@
%$

<<[[asmout()]] switch on type cases>>=
case 3:		/* add R<<[IR],[R],R */
mov:
    aclass(&p->from);
    o1 = oprrr(p->as, p->scond);
    o1 |= p->from.offset;
    rt = p->to.reg;
    r = p->reg;
    if(p->to.type == D_NONE)
        rt = 0;
    if(p->as == AMOVW || p->as == AMVN)
        r = 0;
    else if(r == R_NONE)
        r = rt;
    o1 |= (r<<16) | (rt<<12);
    break;
@
% >> >>




<<[[optab]] entries>>=
{ AADD,		C_NCON,	C_REG,	C_REG,		13, 8, 0 },
{ AADD,		C_NCON,	C_NONE,	C_REG,		13, 8, 0 },
{ AMVN,		C_NCON,	C_NONE,	C_REG,		13, 8, 0 },
{ ACMP,		C_NCON,	C_REG,	C_NONE,		13, 8, 0 },

{ AADD,		C_LCON,	C_REG,	C_REG,		13, 8, 0,	LFROM },
{ AADD,		C_LCON,	C_NONE,	C_REG,		13, 8, 0,	LFROM },
{ AMVN,		C_LCON,	C_NONE,	C_REG,		13, 8, 0,	LFROM },
{ ACMP,		C_LCON,	C_REG,	C_NONE,		13, 8, 0,	LFROM },
@


<<[[asmout()]] switch on type cases>>=
case 13:	/* op $lcon, [R], R */
    o1 = omvl(p, &p->from, REGTMP);
    if(!o1)
        break;
    o2 = oprrr(p->as, p->scond);
    o2 |= REGTMP;
    r = p->reg;
    if(p->as == AMOVW || p->as == AMVN)
        r = 0;
    else if(r == R_NONE)
        r = p->to.reg;
    o2 |= r << 16;
    if(p->to.type != D_NONE)
        o2 |= p->to.reg << 12;
    break;
@
%$

<<function omvl(arm)>>=
long
omvl(Prog *p, Adr *a, int dr)
{	
    long v, o1;
    if(!p->cond) {
        aclass(a);
        v = immrot(~instoffset);
        if(v == 0) {
            diag("missing literal");
            prasm(p);
            return 0;
        }
        o1 = oprrr(AMVN, p->scond&C_SCOND);
        o1 |= v;
        o1 |= dr << 12;
    } else {
        v = p->cond->pc - p->pc - 8;
        o1 = olr(v, REGPC, dr, p->scond&C_SCOND);
    }
    return o1;
}
@
% >> >> >>



<<[[buildop()]] switch opcode r for ranges cases>>=
case ASLL:
    oprange[ASRL] = oprange[r];
    oprange[ASRA] = oprange[r];
    break;
@


<<[[optab]] entries>>=
{ ASLL,		C_RCON,	C_REG,	C_REG,		 8, 4, 0 },
{ ASLL,		C_RCON,	C_NONE,	C_REG,		 8, 4, 0 },

{ ASLL,		C_REG,	C_NONE,	C_REG,		 9, 4, 0 },
{ ASLL,		C_REG,	C_REG,	C_REG,		 9, 4, 0 },
@

<<[[asmout()]] switch on type cases>>=
case 8:		/* sll $c,[R],R -> mov (R<<$c),R */
    aclass(&p->from);
    o1 = oprrr(p->as, p->scond);
    r = p->reg;
    if(r == R_NONE)
        r = p->to.reg;
    o1 |= r;
    o1 |= (instoffset&31) << 7;
    o1 |= p->to.reg << 12;
    break;
@
%$
% >> >>

<<[[asmout()]] switch on type cases>>=
case 9:		/* sll R,[R],R -> mov (R<<R),R */
    o1 = oprrr(p->as, p->scond);
    r = p->reg;
    if(r == R_NONE)
        r = p->to.reg;
    o1 |= r;
    o1 |= (p->from.reg << 8) | (1<<4);
    o1 |= p->to.reg << 12;
    break;
@
% >> >> >> >> 


<<[[buildop()]] switch opcode r for ranges cases>>=
case AMUL:
    oprange[AMULU] = oprange[r];
    break;
@

<<[[optab]] entries>>=
{ AMUL,		C_REG,	C_REG,	C_REG,		15, 4, 0 },
{ AMUL,		C_REG,	C_NONE,	C_REG,		15, 4, 0 },
@


<<[[asmout()]] switch on type cases>>=
case 15:	/* mul r,[r,]r */
    o1 = oprrr(p->as, p->scond);
    rf = p->from.reg;
    rt = p->to.reg;
    r = p->reg;
    if(r == R_NONE)
        r = rt;
    if(rt == r) {
        r = rf;
        rf = rt;
    }
    if(0)
    if(rt == r || rf == REGPC || r == REGPC || rt == REGPC) {
        diag("bad registers in MUL");
        prasm(p);
    }
    o1 |= (rf<<8) | r | (rt<<16);
    break;
@
% >> >> 


<<[[buildop()]] switch opcode r for ranges cases>>=
case ADIV:
    oprange[AMOD] = oprange[r];
    oprange[AMODU] = oprange[r];
    oprange[ADIVU] = oprange[r];
    break;
@

<<[[optab]] entries>>=
{ ADIV,		C_REG,	C_REG,	C_REG,		16, 4, 0 },
{ ADIV,		C_REG,	C_NONE,	C_REG,		16, 4, 0 },
@
% hmm but noops should have rewrite them no?

<<[[asmout()]] switch on type cases>>=
case 16:	/* div r,[r,]r */
    o1 = 0xf << 28;
    o2 = 0;
    break;
@
% 0xf?? o2 = 0 ??
% >>


<<[[buildop()]] switch opcode r for ranges cases>>=
case AMULL:
    oprange[AMULA] = oprange[r];
    oprange[AMULAL] = oprange[r];
    oprange[AMULLU] = oprange[r];
    oprange[AMULALU] = oprange[r];
    break;
@

<<[[optab]] entries>>=
{ AMULL,	C_REG,	C_REG,	C_REGREG,	17, 4, 0 },
@

<<[[asmout()]] switch on type cases>>=
case 17:
    o1 = oprrr(p->as, p->scond);
    rf = p->from.reg;
    rt = p->to.reg;
    rt2 = p->to.offset;
    r = p->reg;
    o1 |= (rf<<8) | r | (rt<<16) | (rt2<<12);
    break;
@
% >> >> >>

\subsection{Branching opcodes}

<<[[buildop()]] switch opcode r for ranges cases>>=
case AB:
case ABL:
    break;
case ABEQ:
    oprange[ABNE] = oprange[r];
    oprange[ABHS] = oprange[r];
    oprange[ABLO] = oprange[r];
    oprange[ABMI] = oprange[r];
    oprange[ABPL] = oprange[r];
    oprange[ABVS] = oprange[r];
    oprange[ABVC] = oprange[r];
    oprange[ABHI] = oprange[r];
    oprange[ABLS] = oprange[r];
    oprange[ABGE] = oprange[r];
    oprange[ABLT] = oprange[r];
    oprange[ABGT] = oprange[r];
    oprange[ABLE] = oprange[r];
    break;
@

<<[[optab]] entries>>=
{ AB,		C_NONE,	C_NONE,	C_BRANCH,		 5, 4, 0,	LPOOL },
{ ABL,		C_NONE,	C_NONE,	C_BRANCH,		 5, 4, 0 },
{ ABEQ,		C_NONE,	C_NONE,	C_BRANCH,		 5, 4, 0 },
@


<<[[asmout()]] switch on type cases>>=
case 5:		/* bra s */
    v = -8;
    if(p->cond == UP) {
        s = p->to.sym;
        if(s->type != SUNDEF)
            diag("bad branch sym type");
        v = (ulong)s->value >> (Roffset-2);
        dynreloc(s, p->pc, 0);
    }
    else if(p->cond != P)
        v = (p->cond->pc - pc) - 8;
    o1 = opbra(p->as, p->scond);
    o1 |= (v >> 2) & 0xffffff;
    break;
@
% p->cond->pc !! hence the need for patch()! and span()
% and do -pc because it's relative, and do -8 because ARM
% does implicitly a +8 (see Machine.nw)

<<function opbra(arm)>>=
long
opbra(int a, int sc)
{

    if(sc & (C_SBIT|C_PBIT|C_WBIT))
        diag(".S/.P/.W on bra instruction");
    sc &= C_SCOND;
    if(a == ABL)
        return (sc<<28)|(0x5<<25)|(0x1<<24);

    if(sc != 0xe)
        diag(".COND on bcond instruction");

    switch(a) {
    case ABEQ:	return (0x0<<28)|(0x5<<25);
    case ABNE:	return (0x1<<28)|(0x5<<25);
    case ABHS:	return (0x2<<28)|(0x5<<25);
    case ABLO:	return (0x3<<28)|(0x5<<25);
    case ABMI:	return (0x4<<28)|(0x5<<25);
    case ABPL:	return (0x5<<28)|(0x5<<25);
    case ABVS:	return (0x6<<28)|(0x5<<25);
    case ABVC:	return (0x7<<28)|(0x5<<25);
    case ABHI:	return (0x8<<28)|(0x5<<25);
    case ABLS:	return (0x9<<28)|(0x5<<25);
    case ABGE:	return (0xa<<28)|(0x5<<25);
    case ABLT:	return (0xb<<28)|(0x5<<25);
    case ABGT:	return (0xc<<28)|(0x5<<25);
    case ABLE:	return (0xd<<28)|(0x5<<25);
    case AB:	return (0xe<<28)|(0x5<<25);
    }
    diag("bad bra %A", a);
    prasm(curp);
    return 0;
}
@
% 
% >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >>
% >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >>




<<[[optab]] entries>>=
{ AB,		C_NONE,	C_NONE,	C_ROREG,	 6, 4, 0,	LPOOL },
{ ABL,		C_NONE,	C_NONE,	C_ROREG,	 7, 8, 0 },
@

<<[[asmout()]] switch on type cases>>=
case 6:		/* b ,O(R) -> add $O,R,PC */
    aclass(&p->to);
    o1 = oprrr(AADD, p->scond);
    o1 |= immrot(instoffset);
    o1 |= p->to.reg << 16;
    o1 |= REGPC << 12;
    break;
@
%$

<<[[asmout()]] switch on type cases>>=
case 7:		/* bl ,O(R) -> mov PC,link; add $O,R,PC */
    aclass(&p->to);
    o1 = oprrr(AADD, p->scond);
    o1 |= immrot(0);
    o1 |= REGPC << 16;
    o1 |= REGLINK << 12;

    o2 = oprrr(AADD, p->scond);
    o2 |= immrot(instoffset);
    o2 |= p->to.reg << 16;
    o2 |= REGPC << 12;
    break;
@
%$



\subsection{Memory opcodes}

<<[[buildop()]] switch opcode r for ranges cases>>=
case AMOVW:
case AMOVB:
case AMOVBU:
case AMOVH:
case AMOVHU:
    break;
@


% the MOV opcodes with size 4 which are simple, simple load or store
<<[[optab]] entries>>=
{ AMOVW,	C_RECON,C_NONE,	C_REG,		 4, 4, REGSB },
{ AMOVW,	C_RACON,C_NONE,	C_REG,		 4, 4, REGSP },
@

<<[[asmout()]] switch on type cases>>=
case 4:		/* add $I,[R],R */
    aclass(&p->from);
    o1 = oprrr(AADD, p->scond);
    o1 |= immrot(instoffset);
    r = p->from.reg;
    if(r == R_NONE)
        r = o->param;
    o1 |= r << 16;
    o1 |= p->to.reg << 12;
    break;
@
%$


<<[[optab]] entries>>=
{ AMOVW,	C_NCON,	C_NONE,	C_REG,		12, 4, 0 },
{ AMOVW,	C_LCON,	C_NONE,	C_REG,		12, 4, 0,	LFROM },
@

<<[[asmout()]] switch on type cases>>=
case 12:	/* movw $lcon, reg */
    o1 = omvl(p, &p->from, p->to.reg);
    break;
@
%$



<<[[optab]] entries>>=
{ AMOVB,	C_REG,	C_NONE,	C_REG,		14, 8, 0 },
{ AMOVBU,	C_REG,	C_NONE,	C_REG,		58, 4, 0 },
{ AMOVH,	C_REG,	C_NONE,	C_REG,		14, 8, 0 },
{ AMOVHU,	C_REG,	C_NONE,	C_REG,		14, 8, 0 },
@

<<[[asmout()]] switch on type cases>>=
case 14:	/* movb/movbu/movh/movhu R,R */
    o1 = oprrr(ASLL, p->scond);

    if(p->as == AMOVBU || p->as == AMOVHU)
        o2 = oprrr(ASRL, p->scond);
    else
        o2 = oprrr(ASRA, p->scond);

    r = p->to.reg;
    o1 |= (p->from.reg)|(r<<12);
    o2 |= (r)|(r<<12);
    if(p->as == AMOVB || p->as == AMOVBU) {
        o1 |= (24<<7);
        o2 |= (24<<7);
    } else {
        o1 |= (16<<7);
        o2 |= (16<<7);
    }
    break;
@

<<[[asmout()]] switch on type cases>>=
case 58:	/* movbu R,R */
    o1 = oprrr(AAND, p->scond);
    o1 |= immrot(0xff);
    rt = p->to.reg;
    r = p->from.reg;
    if(p->to.type == D_NONE)
        rt = 0;
    if(r == R_NONE)
        r = rt;
    o1 |= (r<<16) | (rt<<12);
    break;
@



<<[[optab]] entries>>=
{ AMOVW,	C_REG,	C_NONE,	C_SEXT,		20, 4, REGSB },
{ AMOVW,	C_REG,	C_NONE,	C_SAUTO,	20, 4, REGSP },
{ AMOVW,	C_REG,	C_NONE,	C_SOREG,	20, 4, 0 },
{ AMOVB,	C_REG,	C_NONE,	C_SEXT,		20, 4, REGSB },
{ AMOVB,	C_REG,	C_NONE,	C_SAUTO,	20, 4, REGSP },
{ AMOVB,	C_REG,	C_NONE,	C_SOREG,	20, 4, 0 },
{ AMOVBU,	C_REG,	C_NONE,	C_SEXT,		20, 4, REGSB },
{ AMOVBU,	C_REG,	C_NONE,	C_SAUTO,	20, 4, REGSP },
{ AMOVBU,	C_REG,	C_NONE,	C_SOREG,	20, 4, 0 },

{ AMOVW,	C_SEXT,	C_NONE,	C_REG,		21, 4, REGSB },
{ AMOVW,	C_SAUTO,C_NONE,	C_REG,		21, 4, REGSP },
{ AMOVW,	C_SOREG,C_NONE,	C_REG,		21, 4, 0 },
{ AMOVBU,	C_SEXT,	C_NONE,	C_REG,		21, 4, REGSB },
{ AMOVBU,	C_SAUTO,C_NONE,	C_REG,		21, 4, REGSP },
{ AMOVBU,	C_SOREG,C_NONE,	C_REG,		21, 4, 0 },

{ AMOVB,	C_SEXT,	C_NONE,	C_REG,		22, 12, REGSB },
{ AMOVB,	C_SAUTO,C_NONE,	C_REG,		22, 12, REGSP },
{ AMOVB,	C_SOREG,C_NONE,	C_REG,		22, 12, 0 },
{ AMOVH,	C_SEXT,	C_NONE,	C_REG,		22, 12, REGSB },
{ AMOVH,	C_SAUTO,C_NONE,	C_REG,		22, 12, REGSP },
{ AMOVH,	C_SOREG,C_NONE,	C_REG,		22, 12, 0 },
{ AMOVHU,	C_SEXT,	C_NONE,	C_REG,		22, 12, REGSB },
{ AMOVHU,	C_SAUTO,C_NONE,	C_REG,		22, 12, REGSP },
{ AMOVHU,	C_SOREG,C_NONE,	C_REG,		22, 12, 0 },

{ AMOVH,	C_REG,	C_NONE,	C_SEXT,		23, 12, REGSB },
{ AMOVH,	C_REG,	C_NONE,	C_SAUTO,	23, 12, REGSP },
{ AMOVH,	C_REG,	C_NONE,	C_SOREG,	23, 12, 0 },
{ AMOVHU,	C_REG,	C_NONE,	C_SEXT,		23, 12, REGSB },
{ AMOVHU,	C_REG,	C_NONE,	C_SAUTO,	23, 12, REGSP },
{ AMOVHU,	C_REG,	C_NONE,	C_SOREG,	23, 12, 0 },
@


<<[[asmout()]] switch on type cases>>=
case 20:	/* mov/movb/movbu R,O(R) */
    aclass(&p->to);
    r = p->to.reg;
    if(r == R_NONE)
        r = o->param;
    o1 = osr(p->as, p->from.reg, instoffset, r, p->scond);
    break;
@


<<[[asmout()]] switch on type cases>>=
case 21:	/* mov/movbu O(R),R -> lr */
    aclass(&p->from);
    r = p->from.reg;
    if(r == R_NONE)
        r = o->param;
    o1 = olr(instoffset, r, p->to.reg, p->scond);
    if(p->as != AMOVW)
        o1 |= 1<<22;
    break;
@

<<function olr(arm)>>=
long
olr(long v, int b, int r, int sc)
{
    long o;

    o = (sc & C_SCOND) << 28;
    if(sc & C_SBIT)
        diag(".S on LDR/STR instruction");
    if(!(sc & C_PBIT))
        o |= 1 << 24;
    if(!(sc & C_UBIT))
        o |= 1 << 23;
    if(sc & C_WBIT)
        o |= 1 << 21;
    o |= (0x1<<26) | (1<<20);
    if(v < 0) {
        v = -v;
        o ^= 1 << 23;
    }
    if(v >= (1<<12))
        diag("literal span too large: %ld (R%d)\n%P", v, b, PP);
    o |= v;
    o |= b << 16;
    o |= r << 12;
    return o;
}
@
% >> >> >> >> >> >> >> >> >> >>



<<[[asmout()]] switch on type cases>>=
case 22:	/* movb/movh/movhu O(R),R -> lr,shl,shr */
    aclass(&p->from);
    r = p->from.reg;
    if(r == R_NONE)
        r = o->param;
    o1 = olr(instoffset, r, p->to.reg, p->scond);

    o2 = oprrr(ASLL, p->scond);
    o3 = oprrr(ASRA, p->scond);
    r = p->to.reg;
    if(p->as == AMOVB) {
        o2 |= (24<<7)|(r)|(r<<12);
        o3 |= (24<<7)|(r)|(r<<12);
    } else {
        o2 |= (16<<7)|(r)|(r<<12);
        if(p->as == AMOVHU)
            o3 = oprrr(ASRL, p->scond);
        o3 |= (16<<7)|(r)|(r<<12);
    }
    break;
@
<<[[asmout()]] switch on type cases>>=
case 23:	/* movh/movhu R,O(R) -> sb,sb */
    aclass(&p->to);
    r = p->to.reg;
    if(r == R_NONE)
        r = o->param;
    o1 = osr(AMOVH, p->from.reg, instoffset, r, p->scond);

    o2 = oprrr(ASRL, p->scond);
    o2 |= (8<<7)|(p->from.reg)|(REGTMP<<12);

    o3 = osr(AMOVH, REGTMP, instoffset+1, r, p->scond);
    break;
@



<<[[optab]] entries>>=
{ AMOVW,	C_REG,	C_NONE,	C_LEXT,		30, 8, REGSB,	LTO },
{ AMOVW,	C_REG,	C_NONE,	C_LAUTO,	30, 8, REGSP,	LTO },
{ AMOVW,	C_REG,	C_NONE,	C_LOREG,	30, 8, 0,	LTO },
{ AMOVB,	C_REG,	C_NONE,	C_LEXT,		30, 8, REGSB,	LTO },
{ AMOVB,	C_REG,	C_NONE,	C_LAUTO,	30, 8, REGSP,	LTO },
{ AMOVB,	C_REG,	C_NONE,	C_LOREG,	30, 8, 0,	LTO },
{ AMOVBU,	C_REG,	C_NONE,	C_LEXT,		30, 8, REGSB,	LTO },
{ AMOVBU,	C_REG,	C_NONE,	C_LAUTO,	30, 8, REGSP,	LTO },
{ AMOVBU,	C_REG,	C_NONE,	C_LOREG,	30, 8, 0,	LTO },
@

<<[[asmout()]] switch on type cases>>=
case 30:	/* mov/movb/movbu R,L(R) */
    o1 = omvl(p, &p->to, REGTMP);
    if(!o1)
        break;
    r = p->to.reg;
    if(r == R_NONE)
        r = o->param;
    o2 = osrr(p->from.reg, REGTMP,r, p->scond);
    if(p->as != AMOVW)
        o2 |= 1<<22;
    break;
@




<<[[optab]] entries>>=
{ AMOVW,	C_LEXT,	C_NONE,	C_REG,		31, 8, REGSB,	LFROM },
{ AMOVW,	C_LAUTO,C_NONE,	C_REG,		31, 8, REGSP,	LFROM },
{ AMOVW,	C_LOREG,C_NONE,	C_REG,		31, 8, 0,	LFROM },
{ AMOVBU,	C_LEXT,	C_NONE,	C_REG,		31, 8, REGSB,	LFROM },
{ AMOVBU,	C_LAUTO,C_NONE,	C_REG,		31, 8, REGSP,	LFROM },
{ AMOVBU,	C_LOREG,C_NONE,	C_REG,		31, 8, 0,	LFROM },

{ AMOVB,	C_LEXT,	C_NONE,	C_REG,		32, 16, REGSB,	LFROM },
{ AMOVB,	C_LAUTO,C_NONE,	C_REG,		32, 16, REGSP,	LFROM },
{ AMOVB,	C_LOREG,C_NONE,	C_REG,		32, 16, 0,	LFROM },
{ AMOVH,	C_LEXT,	C_NONE,	C_REG,		32, 16, REGSB,	LFROM },
{ AMOVH,	C_LAUTO,C_NONE,	C_REG,		32, 16, REGSP,	LFROM },
{ AMOVH,	C_LOREG,C_NONE,	C_REG,		32, 16, 0,	LFROM },
{ AMOVHU,	C_LEXT,	C_NONE,	C_REG,		32, 16, REGSB,	LFROM },
{ AMOVHU,	C_LAUTO,C_NONE,	C_REG,		32, 16, REGSP,	LFROM },
{ AMOVHU,	C_LOREG,C_NONE,	C_REG,		32, 16, 0,	LFROM },
@

<<[[asmout()]] switch on type cases>>=
case 31:	/* mov/movbu L(R),R -> lr[b] */
case 32:	/* movh/movb L(R),R -> lr[b] */
    o1 = omvl(p, &p->from, REGTMP);
    if(!o1)
        break;
    r = p->from.reg;
    if(r == R_NONE)
        r = o->param;
    o2 = olrr(REGTMP,r, p->to.reg, p->scond);
    if(p->as == AMOVBU || p->as == AMOVB)
        o2 |= 1<<22;
    if(o->type == 31)
        break;

    o3 = oprrr(ASLL, p->scond);

    if(p->as == AMOVBU || p->as == AMOVHU)
        o4 = oprrr(ASRL, p->scond);
    else
        o4 = oprrr(ASRA, p->scond);

    r = p->to.reg;
    o3 |= (r)|(r<<12);
    o4 |= (r)|(r<<12);
    if(p->as == AMOVB || p->as == AMOVBU) {
        o3 |= (24<<7);
        o4 |= (24<<7);
    } else {
        o3 |= (16<<7);
        o4 |= (16<<7);
    }
    break;
@



<<[[optab]] entries>>=
{ AMOVH,	C_REG,	C_NONE,	C_LEXT,		33, 24, REGSB,	LTO },
{ AMOVH,	C_REG,	C_NONE,	C_LAUTO,	33, 24, REGSP,	LTO },
{ AMOVH,	C_REG,	C_NONE,	C_LOREG,	33, 24, 0,	LTO },
{ AMOVHU,	C_REG,	C_NONE,	C_LEXT,		33, 24, REGSB,	LTO },
{ AMOVHU,	C_REG,	C_NONE,	C_LAUTO,	33, 24, REGSP,	LTO },
{ AMOVHU,	C_REG,	C_NONE,	C_LOREG,	33, 24, 0,	LTO },
@

<<[[asmout()]] switch on type cases>>=
case 33:	/* movh/movhu R,L(R) -> sb, sb */
    o1 = omvl(p, &p->to, REGTMP);
    if(!o1)
        break;
    r = p->to.reg;
    if(r == R_NONE)
        r = o->param;
    o2 = osrr(p->from.reg, REGTMP, r, p->scond);
    o2 |= (1<<22) ;

    o3 = oprrr(ASRL, p->scond);
    o3 |= (8<<7)|(p->from.reg)|(p->from.reg<<12);
    o3 |= (1<<6);	/* ROR 8 */

    o4 = oprrr(AADD, p->scond);
    o4 |= (REGTMP << 12) | (REGTMP << 16);
    o4 |= immrot(1);

    o5 = osrr(p->from.reg, REGTMP,r,p->scond);
    o5 |= (1<<22);

    o6 = oprrr(ASRL, p->scond);
    o6 |= (24<<7)|(p->from.reg)|(p->from.reg<<12);
    o6 |= (1<<6);	/* ROL 8 */

    break;
@




<<[[optab]] entries>>=
{ AMOVW,	C_LACON,C_NONE,	C_REG,		34, 8, REGSP,	LFROM },
@

<<[[asmout()]] switch on type cases>>=
case 34:	/* mov $lacon,R */
    o1 = omvl(p, &p->from, REGTMP);
    if(!o1)
        break;

    o2 = oprrr(AADD, p->scond);
    o2 |= REGTMP;
    r = p->from.reg;
    if(r == R_NONE)
        r = o->param;
    o2 |= r << 16;
    if(p->to.type != D_NONE)
        o2 |= p->to.reg << 12;
    break;
@
%$


<<[[optab]] entries>>=
{ AMOVW,	C_PSR,	C_NONE,	C_REG,		35, 4, 0 },
{ AMOVW,	C_REG,	C_NONE,	C_PSR,		36, 4, 0 },
{ AMOVW,	C_RCON,	C_NONE,	C_PSR,		37, 4, 0 },
@

<<[[asmout()]] switch on type cases>>=
case 35:	/* mov PSR,R */
    o1 = (2<<23) | (0xf<<16) | (0<<0);
    o1 |= (p->scond & C_SCOND) << 28;
    o1 |= (p->from.reg & 1) << 22;
    o1 |= p->to.reg << 12;
    break;
@
<<[[asmout()]] switch on type cases>>=
case 36:	/* mov R,PSR */
    o1 = (2<<23) | (0x29f<<12) | (0<<4);
    if(p->scond & C_FBIT)
        o1 ^= 0x010 << 12;
    o1 |= (p->scond & C_SCOND) << 28;
    o1 |= (p->to.reg & 1) << 22;
    o1 |= p->from.reg << 0;
    break;
@
<<[[asmout()]] switch on type cases>>=
case 37:	/* mov $con,PSR */
    aclass(&p->from);
    o1 = (2<<23) | (0x29f<<12) | (0<<4);
    if(p->scond & C_FBIT)
        o1 ^= 0x010 << 12;
    o1 |= (p->scond & C_SCOND) << 28;
    o1 |= immrot(instoffset);
    o1 |= (p->to.reg & 1) << 22;
    o1 |= p->from.reg << 0;
    break;
@
%$


<<[[optab]] entries>>=
{ AMOVW,	C_SHIFT,C_NONE,	C_REG,		59, 4, 0 },
{ AMOVBU,	C_SHIFT,C_NONE,	C_REG,		59, 4, 0 },

{ AMOVB,	C_SHIFT,C_NONE,	C_REG,		60, 4, 0 },

{ AMOVW,	C_REG,	C_NONE,	C_SHIFT,	61, 4, 0 },
{ AMOVB,	C_REG,	C_NONE,	C_SHIFT,	61, 4, 0 },
{ AMOVBU,	C_REG,	C_NONE,	C_SHIFT,	61, 4, 0 },
@

<<[[asmout()]] switch on type cases>>=
case 59:	/* movw/bu R<<I(R),R -> ldr indexed */
    if(p->from.reg == R_NONE) {
        if(p->as != AMOVW)
            diag("byte MOV from shifter operand");
        goto mov;
    }
    if(p->from.offset&(1<<4))
        diag("bad shift in LDR");
    o1 = olrr(p->from.offset, p->from.reg, p->to.reg, p->scond);
    if(p->as == AMOVBU)
        o1 |= 1<<22;
    break;
@
% >> >> >>


<<[[asmout()]] switch on type cases>>=
case 60:	/* movb R(R),R -> ldrsb indexed */
    if(p->from.reg == R_NONE) {
        diag("byte MOV from shifter operand");
        goto mov;
    }
    if(p->from.offset&(~0xf))
        diag("bad shift in LDRSB");
    o1 = olhrr(p->from.offset, p->from.reg, p->to.reg, p->scond);
    o1 ^= (1<<5)|(1<<6);
    break;
@
% >> >> 

<<[[asmout()]] switch on type cases>>=
case 61:	/* movw/b/bu R,R<<[IR](R) -> str indexed */
    if(p->to.reg == R_NONE)
        diag("MOV to shifter operand");
    o1 = osrr(p->from.reg, p->to.offset, p->to.reg, p->scond);
    if(p->as == AMOVB || p->as == AMOVBU)
        o1 |= 1<<22;
    break;
@
% >> >>



<<[[buildop()]] switch opcode r for ranges cases>>=
case ASWPW:
    oprange[ASWPBU] = oprange[r];
    break;
@

<<[[optab]] entries>>=
{ ASWPW,	C_SOREG,C_REG,	C_REG,		40, 4, 0 },
@


<<[[asmout()]] switch on type cases>>=
case 40:	/* swp oreg,reg,reg */
    aclass(&p->from);
    if(instoffset != 0)
        diag("offset must be zero in SWP");
    o1 = (0x2<<23) | (0x9<<4);
    if(p->as != ASWPW)
        o1 |= 1 << 22;
    o1 |= p->from.reg << 16;
    o1 |= p->reg << 0;
    o1 |= p->to.reg << 12;
    o1 |= (p->scond & C_SCOND) << 28;
    break;
@
% >> >> >> >> >> >> >>

\subsection{Interrupt opcodes}

<<[[buildop()]] switch opcode r for ranges cases>>=
case ASWI:
case ARFE:
    break;
@


<<[[optab]] entries>>=
{ ASWI,		C_NONE,	C_NONE,	C_NONE,		10, 4, 0 },
@

<<[[asmout()]] switch on type cases>>=
case 10:	/* swi [$con] */
    o1 = oprrr(p->as, p->scond);
    if(p->to.type != D_NONE) {
        aclass(&p->to);
        o1 |= instoffset & 0xffffff;
    }
    break;
@
%$


<<[[optab]] entries>>=
{ ARFE,		C_NONE,	C_NONE,	C_NONE,		41, 4, 0 },
@
% there is no RFE in Machine.nw because all the system
% code is proxied, and so there is no assembly system code to emulate

<<[[asmout()]] switch on type cases>>=
case 41:	/* rfe -> movm.s.w.u 0(r13),[r15] */
    o1 = 0xe8fd8000;
    break;
@



\section{Data section, [[datblk()]]}

<<constant Dbufslop>>=
#define	Dbufslop	100
@


<<function datblk(arm)>>=
void
datblk(long s, long n, bool str)
{
    Sym *v;
    Prog *p;
    char *cast;
    long a, l, fl, j, d;
    int i, c;

    memset(buf.dbuf, 0, n+Dbufslop);

    for(p = datap; p != P; p = p->link) {
        if(str != (p->from.sym->type == SSTRING))
            continue;

        curp = p;

        a = p->from.sym->value + p->from.offset;
        l = a - s;
        c = p->reg;
        i = 0;
        if(l < 0) {
            if(l+c <= 0)
                continue;
            while(l < 0) {
                l++;
                i++;
            }
        }
        if(l >= n)
            continue;

        if(p->as != AINIT && p->as != ADYNT) {
            for(j=l+(c-i)-1; j>=l; j--)
                if(buf.dbuf[j]) {
                    print("%P\n", p);
                    diag("multiple initialization");
                    break;
                }
        }

        switch(p->to.type) {

        case D_FCONST:
            switch(c) {
            default:
            case 4:
                fl = ieeedtof(p->to.ieee);
                cast = (char*)&fl;
                for(; i<c; i++) {
                    buf.dbuf[l] = cast[fnuxi4[i]];
                    l++;
                }
                break;
            case 8:
                cast = (char*)p->to.ieee;
                for(; i<c; i++) {
                    buf.dbuf[l] = cast[fnuxi8[i]];
                    l++;
                }
                break;
            }
            break;

        case D_SCONST:
            for(; i<c; i++) {
                buf.dbuf[l] = p->to.sval[i];
                l++;
            }
            break;

        case D_CONST:
            d = p->to.offset;
            v = p->to.sym;
            if(v) {
                switch(v->type) {
                case SUNDEF:
                    ckoff(v, d);
                case STEXT: case SLEAF:
                case SSTRING:
                    d += p->to.sym->value;
                    break;
                case SDATA:
                case SBSS:
                    d += p->to.sym->value + INITDAT;
                }
                <<[[datblk()]] if dynamic module(arm)>>
            }
            cast = (char*)&d;

            switch(c) {
            case 1:
                for(; i<c; i++) {
                    buf.dbuf[l] = cast[inuxi1[i]];
                    l++;
                }
                break;
            case 2:
                for(; i<c; i++) {
                    buf.dbuf[l] = cast[inuxi2[i]];
                    l++;
                }
                break;
            case 4:
                for(; i<c; i++) {
                    buf.dbuf[l] = cast[inuxi4[i]];
                    l++;
                }
                break;

            default:
                diag("bad nuxi %d %d%P", c, i, curp);
                break;
            }
            break;

        default:
            diag("unknown mode in initialization%P", p);
            break;
        }
    }
    write(cout, buf.dbuf, n);
}
@

<<function ckoff>>=
void
ckoff(Sym *s, long v)
{
    if(v < 0 || v >= 1<<Roffset)
        diag("relocation offset %ld for %s out of range", v, s->name);
}
@

% >>


\subsection{Endianess, [[nuxiinit()]]}

%"unix" in some systems is represented as "nuxi" because of endianess

<<global inuxi1>>=
char	inuxi1[1];
@

<<global inuxi2>>=
char	inuxi2[2];
@

<<global inuxi4>>=
char	inuxi4[4];
@


<<global fnuxi4>>=
char	fnuxi4[4];
@

<<global fnuxi8>>=
char	fnuxi8[8];
@


<<[[main()]] initialize globals(arm)>>=
nuxiinit(); // ???
@

<<function nuxiinit(arm)>>=
void
nuxiinit(void)
{

    int i, c;

    for(i=0; i<4; i++) {
        c = find1(0x04030201L, i+1);
        if(i < 2)
            inuxi2[i] = c;
        if(i < 1)
            inuxi1[i] = c;
        inuxi4[i] = c;
        fnuxi4[i] = c;

        if(debug['d'] == 0){
            fnuxi8[i] = c;
            fnuxi8[i+4] = c+4;
        }
        else{
            fnuxi8[i] = c+4;		/* ms word first, then ls, even in little endian mode */
            fnuxi8[i+4] = c;
        }
    }

    if(debug['v']) {
        Bprint(&bso, "inuxi = ");
        for(i=0; i<1; i++)
            Bprint(&bso, "%d", inuxi1[i]);
        Bprint(&bso, " ");
        for(i=0; i<2; i++)
            Bprint(&bso, "%d", inuxi2[i]);
        Bprint(&bso, " ");
        for(i=0; i<4; i++)
            Bprint(&bso, "%d", inuxi4[i]);
        Bprint(&bso, "\nfnuxi = ");
        for(i=0; i<4; i++)
            Bprint(&bso, "%d", fnuxi4[i]);
        Bprint(&bso, " ");
        for(i=0; i<8; i++)
            Bprint(&bso, "%d", fnuxi8[i]);
        Bprint(&bso, "\n");
    }
    Bflush(&bso);
}
@




<<function find1>>=
int
find1(long l, int c)
{
    char *p;
    int i;

    p = (char*)&l;
    for(i=0; i<4; i++)
        if(*p++ == c)
            return i;
    return 0;
}
@


\chapter{Debugging Support}
% Symbol Tables.
% related to import/export table? I don't think so.

\section{Symbol table, [[asmsym()]]}

% nm helloc actually does not show everything,
% the 'f', 'p', and so are not shown by nm apparently.
% try 5l -n -o helloc helloc.5

<<global symsize>>=
long	symsize;
@
% for the a.out.h header


%5l -n ...
%T 000011d0 atexit
%m 0000000c .frame
%a 00000004 i
%p 00000000 f



% main -> asmb -> <>
<<function asmsym(arm)>>=
void
asmsym(void)
{
    Prog *p;
    Auto *a;
    Sym *s;
    int h;

    s = lookup("etext", 0);
    if(s->type == STEXT)
        putsymb(s->name, 'T', s->value, s->version);

    for(h=0; h<NHASH; h++)
        for(s=hash[h]; s!=S; s=s->link)
            switch(s->type) {
            case SDATA:
                putsymb(s->name, 'D', s->value+INITDAT, s->version);
                continue;
            case SBSS:
                putsymb(s->name, 'B', s->value+INITDAT, s->version);
                continue;

            case SCONST:
                putsymb(s->name, 'D', s->value, s->version);
                continue;
            case SSTRING:
                putsymb(s->name, 'T', s->value, s->version);
                continue;

            case SFILE:
                putsymb(s->name, 'f', s->value, s->version);
                continue;
            }

    for(p=textp; p!=P; p=p->cond) {
        s = p->from.sym;
        if(s->type == STEXT || s->type == SLEAF) {
            /* filenames first */
            <<[[asmsym()]] call putsymb for filenames>>
            
            if(s->type == STEXT)
                putsymb(s->name, 'T', s->value, s->version);
            else // SLEAF
                putsymb(s->name, 'L', s->value, s->version);
            
            /* frame, auto and param after */
            putsymb(".frame", 'm', p->to.offset+4, 0);
            for(a=p->to.autom; a; a=a->link)
                if(a->type == D_AUTO)
                    putsymb(a->asym->name, 'a', -a->aoffset, 0);
                else
                if(a->type == D_PARAM)
                    putsymb(a->asym->name, 'p', a->aoffset, 0);
        }
    }
    if(debug['v'] || debug['n']) {
        Bprint(&bso, "symsize = %lud\n", symsize);
        Bflush(&bso);
    }
}
@




<<function putsymb>>=
void
putsymb(char *s, int t, long v, int ver)
{
    int i, f;

    if(t == 'f')
        s++;

    lput(v);
    if(ver)
        t += 'a' - 'A';
    cput(t+0x80);			/* 0x80 is variable length */

    <<[[putsymb()]] if z or Z>>
    else {
        for(i=0; s[i]; i++)
            cput(s[i]);
        cput('\0');
    }
    symsize += 4 + 1 + i + 1;

    if(debug['n']) {
        <<[[putsymb()]] if z or Z in debug output>>
        if(ver)
            Bprint(&bso, "%c %.8lux %s<%d>\n", t, v, s, ver);
        else
            Bprint(&bso, "%c %.8lux %s\n", t, v, s);
    }
}
@
%>>


\section{Filenames}

% why they are shoved in to.autom with locals and params? a bit ugly
<<[[asmsym()]] call putsymb for filenames>>=
for(a=p->to.autom; a; a=a->link)
    if(a->type == D_FILE)
        putsymb(a->asym->name, 'z', a->aoffset, 0);
    else
    if(a->type == D_FILE1)
        putsymb(a->asym->name, 'Z', a->aoffset, 0);
@

<<[[putsymb()]] if z or Z>>=
if(t == 'z' || t == 'Z') {
    cput(s[0]);
    for(i=1; s[i] != 0 || s[i+1] != 0; i += 2) {
        cput(s[i]);
        cput(s[i+1]);
    }
    cput(0);
    cput(0);
    i++;
}
@

<<[[putsymb()]] if z or Z in debug output>>=
if(t == 'z' || t == 'Z') {
    Bprint(&bso, "%c %.8lux ", t, v);
    for(i=1; s[i] != 0 || s[i+1] != 0; i+=2) {
        f = ((s[i]&0xff) << 8) | (s[i+1]&0xff);
        Bprint(&bso, "/%x", f);
    }
    Bprint(&bso, "\n");
    return;
}
@
% >> >> >>

\section{Line table, [[asmlc()]]}

% lc? line count?
<<global lcsize>>=
long	lcsize;
@


<<constant MINLC(arm)>>=
#define	MINLC	4
@

<<function asmlc>>=
void
asmlc(void)
{
    long oldpc, oldlc;
    Prog *p;
    long v, s;

    oldpc = INITTEXT;
    oldlc = 0;
    for(p = firstp; p != P; p = p->link) {
        if(p->line == oldlc || p->as == ATEXT || p->as == ANOP) {
            <<adjust curtext when iterate over instructions p>>
            if(debug['V'])
                Bprint(&bso, "%6lux %P\n",
                    p->pc, p);
            continue;
        }
        if(debug['V'])
            Bprint(&bso, "\t\t%6ld", lcsize);
        v = (p->pc - oldpc) / MINLC;
        while(v) {
            s = 127;
            if(v < 127)
                s = v;
            cput(s+128);	/* 129-255 +pc */
            if(debug['V'])
                Bprint(&bso, " pc+%ld*%d(%ld)", s, MINLC, s+128);
            v -= s;
            lcsize++;
        }
        s = p->line - oldlc;
        oldlc = p->line;
        oldpc = p->pc + MINLC;
        if(s > 64 || s < -64) {
            cput(0);	/* 0 vv +lc */
            cput(s>>24);
            cput(s>>16);
            cput(s>>8);
            cput(s);
            if(debug['V']) {
                if(s > 0)
                    Bprint(&bso, " lc+%ld(%d,%ld)\n",
                        s, 0, s);
                else
                    Bprint(&bso, " lc%ld(%d,%ld)\n",
                        s, 0, s);
                Bprint(&bso, "%6lux %P\n",
                    p->pc, p);
            }
            lcsize += 5;
            continue;
        }
        if(s > 0) {
            cput(0+s);	/* 1-64 +lc */
            if(debug['V']) {
                Bprint(&bso, " lc+%ld(%ld)\n", s, 0+s);
                Bprint(&bso, "%6lux %P\n",
                    p->pc, p);
            }
        } else {
            cput(64-s);	/* 65-128 -lc */
            if(debug['V']) {
                Bprint(&bso, " lc%ld(%ld)\n", s, 64-s);
                Bprint(&bso, "%6lux %P\n",
                    p->pc, p);
            }
        }
        lcsize++;
    }
    while(lcsize & 1) {
        s = 129;
        cput(s);
        lcsize++;
    }
    if(debug['v'] || debug['V'])
        Bprint(&bso, "lcsize = %ld\n", lcsize);
    Bflush(&bso);
}
@




\chapter{Profiling Support}
% surprising again that it's ld's job to add profiling in plan9

% The code below is interesting because it inserts extra object code using
% directly "AST" constructs, so it helps to understand the data structure!!

% see NOPROF of 8.out.h in Assembler_extra.nw

\section{[[5l -p]]}


% where is defined _mainp? lib_core/libc/386/main9p.s
<<[[main()]] adjust INITENTRY if profiling>>=
if(debug['p'])
    INITENTRY = "_mainp";
@

% 8l -p -1
% after dostkoff(), before span() (matters?)
<<[[main()]] call doprofxxx() if profiling>>=
if(debug['p'])
    if(debug['1'])
        doprof1();
    else
        doprof2();
@

\section{[[__mcount[]]]}

% the idea o the code below is to add __mcount array, one index per function,
% and when call it increments the array at the right place.

% todo: who is using this information then? profreport of what?
% git grep __mcount does not seem to return stuff, maybe obsolete code?

<<function doprof1(arm)>>=
void
doprof1(void)
{
    Sym *s;
    long n;
    Prog *p, *q;

    DBG("%5.2f profile 1\n", cputime());

    s = lookup("__mcount", 0);
    n = 1;
    for(p = firstp->link; p != P; p = p->link) {
        if(p->as == ATEXT) {
            q = prg();
            q->line = p->line;
            q->link = datap;
            datap = q;

            q->as = ADATA;
            q->from.type = D_OREG;
            q->from.symkind = D_EXTERN;
            q->from.offset = n*4;
            q->from.sym = s;
            q->reg = 4;
            q->to = p->from;
            q->to.type = D_CONST;

            q = prg();
            q->line = p->line;
            q->pc = p->pc;
            q->link = p->link;
            p->link = q;
            p = q;

            p->as = AMOVW;
            p->from.type = D_OREG;
            p->from.symkind = D_EXTERN;
            p->from.sym = s;
            p->from.offset = n*4 + 4;
            p->to.type = D_REG;
            p->to.reg = REGTMP;

            q = prg();
            q->line = p->line;
            q->pc = p->pc;
            q->link = p->link;
            p->link = q;
            p = q;

            p->as = AADD;
            p->from.type = D_CONST;
            p->from.offset = 1;
            p->to.type = D_REG;
            p->to.reg = REGTMP;

            q = prg();
            q->line = p->line;
            q->pc = p->pc;
            q->link = p->link;
            p->link = q;
            p = q;

            p->as = AMOVW;
            p->from.type = D_REG;
            p->from.reg = REGTMP;
            p->to.type = D_OREG;
            p->to.symkind = D_EXTERN;
            p->to.sym = s;
            p->to.offset = n*4 + 4;

            n += 2;
            continue;
        }
    }
    q = prg();
    q->line = 0;
    q->link = datap;
    datap = q;

    q->as = ADATA;
    q->from.type = D_OREG;
    q->from.symkind = D_EXTERN;
    q->from.sym = s;
    q->reg = 4;
    q->to.type = D_CONST;
    q->to.offset = n;

    s->type = SBSS;
    s->value = n*4;
}
@


\section{[[_profin()]]}

% _profin() is defined by lib_core/libc/port/profile.c
% (_tracin() is defined by you)

% todo: why s2 and s4? why not sin, sout? and pin, pout?


<<global brcond(arm)>>=
static int brcond[] = {ABEQ, ABNE, ABHS, ABLO, ABMI, ABPL, ABVS, ABVC, ABHI, ABLS, ABGE, ABLT, ABGT, ABLE};
@

<<function doprof2(arm)>>=
void
doprof2(void)
{
    Sym *s2, *s4;
    Prog *p, *q, *q2;
    Prog *ps2, *ps4;

    DBG("%5.2f profile 2\n", cputime());

    <<[[doprof2()]] if embedded tracing>>
    else{
        s2 = lookup("_profin", 0);
        s4 = lookup("_profout", 0);
    }
    if(s2->type != STEXT || s4->type != STEXT) {
       <<[[doprof2()]] if embedded tracing diag()>>
        else
            diag("_profin/_profout not defined");
        return;
    }

    // finding ps2, ps4 = instruction (Prog) of s2 and s4
    ps2 = P;
    ps4 = P;
    for(p = firstp; p != P; p = p->link) {
        if(p->as == ATEXT) {
            if(p->from.sym == s2) {
                ps2 = p;
                p->reg = 1;
            }
            if(p->from.sym == s4) {
                ps4 = p;
                p->reg = 1;
            }
        }
    }
    for(p = firstp; p != P; p = p->link) {
        if(p->as == ATEXT) {

            <<[[doprof2()]] if NOPROF p(arm)>>

            /*
             * BL	profin
             */
            q = prg();
            q->line = p->line;
            q->pc = p->pc;
            q->link = p->link;

            <<[[doprof2()]] if embedded tracing ATEXT instrumentation(arm)>>
            else
                p->link = q;
            p = q;
            p->as = ABL;
            p->to.type = D_BRANCH;
            p->cond = ps2;
            p->to.sym = s2;

            continue;
        }
        if(p->as == ARET) {
            <<[[doprof2()]] if embedded tracing ARET instrumentation>>
            /*
             * RET
             */
            q = prg();
            q->as = ARET;
            q->from = p->from;
            q->to = p->to;
            q->cond = p->cond;
            q->link = p->link;
            q->reg = p->reg;
            p->link = q;

            if(p->scond != COND_ALWAYS) {
                q = prg();
                q->as = ABL;
                q->from = zprg.from;
                q->to = zprg.to;
                q->to.type = D_BRANCH;
                q->cond = ps4;
                q->to.sym = s4;
                q->link = p->link;
                p->link = q;

                p->as = brcond[p->scond^1];	/* complement */
                p->scond = COND_ALWAYS;
                p->from = zprg.from;
                p->to = zprg.to;
                p->to.type = D_BRANCH;
                p->cond = q->link->link;	/* successor of RET */
                p->to.offset = q->link->link->pc;

                p = q->link->link;
            } else {

                /*
                 * BL	profout
                 */
                p->as = ABL;
                p->from = zprg.from;
                p->to = zprg.to;
                p->to.type = D_BRANCH;
                p->cond = ps4;
                p->to.sym = s4;
                p->scond = COND_ALWAYS;

                p = q;
            }
            continue;
        }
    }
}
@



\section{[[5l -e]], [[_tracin()]]}

% -p -e, -e for embedded tracing

<<[[doprof2()]] if embedded tracing>>=
if(debug['e']){
    s2 = lookup("_tracein", 0);
    s4 = lookup("_traceout", 0);
}
@

<<[[doprof2()]] if embedded tracing diag()>>=
if(debug['e'])
    diag("_tracein/_traceout not defined %d %d", s2->type, s4->type);
@


<<[[doprof2()]] if embedded tracing ATEXT instrumentation(arm)>>=
if(debug['e']){		/* embedded tracing */
    q2 = prg();
    p->link = q2;
    q2->link = q;

    q2->line = p->line;
    q2->pc = p->pc;

    q2->as = AB;
    q2->to.type = D_BRANCH;
    q2->to.sym = p->to.sym;
    q2->cond = q->link;
}
@

<<[[doprof2()]] if embedded tracing ARET instrumentation>>=
/*
 * RET (default)
 */
if(debug['e']){		/* embedded tracing */
    q = prg();
    q->line = p->line;
    q->pc = p->pc;
    q->link = p->link;
    p->link = q;
    p = q;
}
@

\section{Disabling profiling attribute, [[NOPROF]]}

% NOPROF is in 5.out.h (in Assembler_extra.nw)

<<[[doprof2()]] if NOPROF p(arm)>>=
if(p->reg & NOPROF) {
    for(;;) {
        q = p->link;
        if(q == P || q->as == ATEXT)
            break;
        p = q;
    }
    continue;
}
@
%grrr continue, break, grrr


% useful for the tracing instructions themselves ... hmmm

\chapter{[[libmach/]]}

% a bit reverse of linker. linker actually does not use libmach/,
% but the debugger/profiler/emulator do.

% read .o (objects), read .out (binaries)

\section{[[Fhdr]] and [[crackhdr()]]}

<<struct Fhdr>>=
/*
 *	Common a.out header describing all architectures
 */
typedef struct Fhdr
{
    char	*name;		/* identifier of executable */
    byte	type;		/* file type - see codes above */
    byte	hdrsz;		/* header size */
    byte	_magic;		/* _MAGIC() magic */
    byte	spare;

    long	magic;		/* magic number */

    uvlong	txtaddr;	/* text address */
    vlong	txtoff;		/* start of text in file */
    uvlong	dataddr;	/* start of data segment */
    vlong	datoff;		/* offset to data seg in file */
    vlong	symoff;		/* offset of symbol table in file */

    uvlong	entry;		/* entry point */

    vlong	sppcoff;	/* offset of sp-pc table in file */
    vlong	lnpcoff;	/* offset of line number-pc table in file */

    long	txtsz;		/* text size */
    long	datsz;		/* size of data seg */
    long	bsssz;		/* size of bss */

    long	symsz;		/* size of symbol table */
    long	sppcsz;		/* size of sp-pc table */ // unused
    long	lnpcsz;		/* size of line number-pc table */

} Fhdr;
@
% use uvlong to encompass 32 and 64 architecture.


% crackhdr() at least?

\section{[[Map]], [[syminit()]], [[loadmap()]]}

\section{[[machdata]]}

\chapter{Utilities}

\section{[[size]]}

% errort (0 is ok)
<<function size>>=
int
size(char *file)
{
    fdt fd;
    Fhdr f;

    if((fd = open(file, OREAD)) < 0){
        fprint(2, "size: ");
        perror(file);
        return 1;
    }
    if(crackhdr(fd, &f)) {
        print("%ldt + %ldd + %ldb = %ld\t%s\n", f.txtsz, f.datsz,
            f.bsssz, f.txtsz+f.datsz+f.bsssz, file);
        close(fd);
        return 0;
    }
    fprint(2, "size: %s not an a.out\n", file);
    close(fd);
    return 1;
}
@

<<function main (linkers/misc/size.c)>>=
void
main(int argc, char *argv[])
{
    char *err;
    int i;

    ARGBEGIN {
    default:
        fprint(2, "usage: size [a.out ...]\n");
        exits("usage");
    } ARGEND;

    err = nil;
    if(argc == 0)
        if(size("8.out"))
            err = "error";
    for(i=0; i<argc; i++)
        if(size(argv[i]))
            err = "error";
    exits(err);
}
@

\section{[[nm]]}

\section{[[ar]]}

\section{[[strip]]}




\chapter{Advanced Topics}

\section{Optimisations}

\subsection{Opcode rewriting}
% at loading time

% would be better with ocaml pattern matching (but maybe not that shorter)
<<[[ldobj()]] switch opcode cases(arm)>>=
case ASUB:
    if(p->from.type == D_CONST)
     if(p->from.symkind == D_NONE)
      if(p->from.offset < 0) {
        p->from.offset = -p->from.offset;
        p->as = AADD;
    }
    goto casedef;
@
<<[[ldobj()]] switch opcode cases(arm)>>=
case AADD:
    if(p->from.type == D_CONST)
     if(p->from.symkind == D_NONE)
      if(p->from.offset < 0) {
        p->from.offset = -p->from.offset;
        p->as = ASUB;
    }
    goto casedef;
@

% see also before in previous section the Leaf procedure opti,
% a form of opcode rewriting where some TEXT and RET can
% be optimized.

\subsection{Operand rewriting}

% certain operand values immediate values can be in a certain range
% which then can be encoded as a single instruction.

% If they are out of range but a double of 2, then again
% can be encoded as a single instruction.

% otherwise have to decompose.

\subsection{Small data layout}
% improve data cache miss?

<<enum sxxx cases>>=
SDATA1,
@

<<constant MINSIZ>>=
MINSIZ		= 64,
@


<<[[dodata()]] if small data size>>=
/*
 *	assign 'small' variables to data segment
 *	(rational is that data segment is more easily
 *	 addressed through offset on R12)
 */
if(v <= MINSIZ) {
    s->value = orig;
    orig += v;
    s->type = SDATA1;
}
@

<<[[dodata()]] pass2, retag small data>>=
if(t == SDATA1)
    s->type = SDATA;
@





\subsection{Removing some useless instructions, [[follow()]]}
% a space optimisation more than speed opti (but can help speed
% a bit maybe because of icache)

%note: right now it's not executed by 5l

% Note that this code does not remove the unused functions
% The size of helloc is very small but mainly because of
% loadlib() and objfile() on demand loading strategy of used
% but not yet defined (SXREF) symbols (and multiple passes
% on library symbol table until fixpoint).

% Here I think it's mostly for unreachable code, and chains of direct jmps.
% Note that useful I think.

% does not remove all unreachable instrs so,
% and does not remove unreachable functions :( maybe more important

%less: print the removed code!! usuful diagnostic no?

%if remove follow() optimisations, can have far simpler linker no?
%just dodata(), and simple asmb()? no need patch(), follow()?
%need patch(), because need to link to pc that will change when
%generate the actual instructions.


<<function follow>>=
void
follow(void)
{

    DBG("%5.2f follow\n", cputime());

    firstp = prg();
    lastp = firstp;

    xfol(textp);

    lastp->link = P;
    firstp = firstp->link;
}
@

<<enum mark cases>>=
FOLL		= 1<<0,
@
% >>
% foll for follow?



% xfol? extended follow?
<<function xfol(arm)>>=
void
xfol(Prog *p)
{
    Prog *q, *r;
    int a, i;

loop:
    if(p == P)
        return;
    <<adjust curtext when iterate over instructions p>>
    a = p->as;

    if(a == AB) {
        q = p->cond;
        if(q != P) {
            p->mark |= FOLL;
            p = q;
            if(!(p->mark & FOLL))
                goto loop;
        }
    }

    if(p->mark & FOLL) {
        <<[[xfol()]] when p is marked, for loop to copy instructions>>
        a = AB;
        q = prg();
        q->as = a;
        q->line = p->line;
        q->to.type = D_BRANCH;
        q->to.offset = p->pc;
        q->cond = p;
        p = q;
    }

    p->mark |= FOLL;
    lastp->link = p;
    lastp = p;

    if(a == AB || (a == ARET && p->scond == COND_ALWAYS) || a == ARFE){
        return;
    }

    if(p->cond != P)
     <<[[xfol()]] if a is not ABL and p has a link>>
    p = p->link;
    goto loop;
}
@



<<[[xfol()]] if a is not ABL and p has a link>>=
if(a != ABL && p->link != P) {
   q = brchain(p->link);

   if(a != ATEXT && a != ABCASE)
    if(q != P && (q->mark & FOLL)) {
       p->as = relinv(a);
       p->link = p->cond;
       p->cond = q;
   }

   // recursive call
   xfol(p->link);

   q = brchain(p->cond);
   if(q == P)
       q = p->cond;
   if(q->mark&FOLL) {
       p->cond = q;
       return;
   }
   p = q;
   goto loop;
}
@

% follows a chain of AB, hmm but needed now that has brloop()?
<<function brchain(arm)>>=
Prog*
brchain(Prog *p)
{
    int i;

    for(i=0; i<20; i++) {
        if(p == P || p->as != AB)
            return p;
        p = p->cond;
    }
    return P;
}
@

<<function relinv(arm)>>=
int
relinv(int a)
{
    switch(a) {
    case ABEQ:	return ABNE;
    case ABNE:	return ABEQ;
    case ABHS:	return ABLO;
    case ABLO:	return ABHS;
    case ABMI:	return ABPL;
    case ABPL:	return ABMI;
    case ABVS:	return ABVC;
    case ABVC:	return ABVS;
    case ABHI:	return ABLS;
    case ABLS:	return ABHI;
    case ABGE:	return ABLT;
    case ABLT:	return ABGE;
    case ABGT:	return ABLE;
    case ABLE:	return ABGT;
    }
    diag("unknown relation: %s", anames[a]);
    return a;
}
@





<<[[xfol()]] when p is marked, for loop to copy instructions>>=
for(i=0, q=p; i<4 && q != lastp; i++, q=q->link) {
    a = q->as;
    if(a == ANOP) {
        i--;
        continue;
    }
    if(a == AB || (a == ARET && q->scond == COND_ALWAYS) || a == ARFE)
        goto copy;
    if(!q->cond || (q->cond->mark & FOLL))
        continue;
    if(a != ABEQ && a != ABNE)
        continue;

// here when a is one of AB, ARET, ARFE, ABEQ, ABNE
copy:
    for(;;) {
        r = prg();
        *r = *p;

        <<[[xfol()]] sanity check one, r should be marked>>

        if(p != q) {
            p = p->link;
            lastp->link = r;
            lastp = r;
            continue;
        }
        lastp->link = r;
        lastp = r;

        if(a == AB || (a == ARET && q->scond == COND_ALWAYS) || a == ARFE)
            return;

        // r->as = relinv(a)
        r->as = ABNE;
        if(a == ABNE)
            r->as = ABEQ;

        r->cond = p->link;
        r->link = p->cond;

        if(!(r->link->mark&FOLL))
            // recursive call
            xfol(r->link);

        <<[[xfol()]] sanity check two, [[r->cond]] should be marked>>

        return;
    }
}
@
%old: had        
% if(q == lastp)
%    break;
% at beginning of the for loop, but I moved it up in the for(;_here_;) instead
% (equivalent)




\ifallcode
<<[[xfol()]] sanity check one, r should be marked>>=
if(!(r->mark&FOLL))
    print("cant happen 1\n");
r->mark |= FOLL;
@

<<[[xfol()]] sanity check two, [[r->cond]] should be marked>>=
if(!(r->cond->mark&FOLL))
    print("cant happen 2\n");
@
\fi



\section{Strings in text segment, [[5l -t]]}

% what for? so cannot be modified?
% for constant strings? an optimisation?

<<enum sxxx cases>>=
SSTRING, // arm
@

<<[[dodata()]] if string in text segment>>=
if(debug['t']) {
    /*
     * pull out string constants
     */
    for(p = datap; p != P; p = p->link) {
        s = p->from.sym;
        if(p->to.type == D_SCONST)
            s->type = SSTRING;
    }
}
@


% after has layout all the TEXT instrs, can put behind the strings.
<<[[span()]] if string in text segment>>=
if(debug['t']) {
    /* 
     * add strings to text segment
     */
    c = rnd(c, 8);
    for(i=0; i<NHASH; i++)
     for(s = hash[i]; s != S; s = s->link)
      if(s->type == SSTRING) {
          v = s->value;
          while(v & 3)
              v++;
          s->value = c;
          c += v;
      }
}
@



\section{Overriding symbols attribute, [[DUPOK]]}

% case in kernel where override a previous symbol,
% e.g. sysfatal, werrstr

% DUPOK, x.scale & DUPOK

<<[[ldobj()]] case ATEXT and section not SNONE or SXREF, if DUPOK>>=
if(p->reg & DUPOK) {
    skip = true;
    goto casedef;
}
@

\section{Dynamic loading}

\subsection{Export table, [[5l -x]]}
% what this is for?

<<global doexp>>=
// do export table, -x
bool	doexp;
@


<<[[main()]] command line processing(arm)>>=
case 'x':	/* produce export table */
    doexp = true;
    if(argv[1] != nil && argv[1][0] != '-' && !isobjfile(argv[1]))
        readundefs(ARGF(), SEXPORT);
    break;
@
%in x86 there is also that
%        a = ARGF();
%        if(strcmp(a, "*") == 0)
%            allexport = true;
%        else

<<function isobjfile>>=
static int
isobjfile(char *f)
{
    int n, v;
    Biobuf *b;
    char buf1[5], buf2[SARMAG];

    b = Bopen(f, OREAD);
    if(b == nil)
        return 0;
    n = Bread(b, buf1, 5);
    if(n == 5 && (buf1[2] == 1 && buf1[3] == '<' || buf1[3] == 1 && buf1[4] == '<'))
        v = 1;	/* good enough for our purposes */
    else{
        Bseek(b, 0, 0);
        n = Bread(b, buf2, SARMAG);
        v = n == SARMAG && strncmp(buf2, ARMAG, SARMAG) == 0;
    }
    Bterm(b);
    return v;
}
@


<<global EXPTAB>>=
char*	EXPTAB;
@


<<[[main()]] if export table or dynamic module(arm)>>=
if(doexp || dlm){
    EXPTAB = "_exporttab";
    zerosig(EXPTAB);
    zerosig("etext");
    zerosig("edata");
    zerosig("end");

    <<[[main()]] if dynamic module(arm)>>
    else
        divsig();

    export();
}
@



<<function zerosig>>=
void
zerosig(char *sp)
{
    Sym *s;

    s = lookup(sp, 0);
    s->sig = 0;
}
@



<<global nimports>>=
int nimports;
@

<<global nexports>>=
int nexports;
@

<<global imports>>=
int	imports;
@

<<global exports>>=
int	exports;
@


<<[[Sym]] other fields>>=
// enum<section> too?
short	subtype;
@
%old: was char


<<function readundefs>>=
void
readundefs(char *f, int t)
{
    int i, n;
    Sym *s;
    Biobuf *b;
    char *l, buf[256], *fields[64];

    if(f == nil)
        return;
    b = Bopen(f, OREAD);
    if(b == nil){
        diag("could not open %s: %r", f);
        errorexit();
    }
    while((l = Brdline(b, '\n')) != nil){
        n = Blinelen(b);
        if(n >= sizeof(buf)){
            diag("%s: line too long", f);
            errorexit();
        }
        memmove(buf, l, n);
        buf[n-1] = '\0';
        n = getfields(buf, fields, nelem(fields), 1, " \t\r\n");
        if(n == nelem(fields)){
            diag("%s: bad format", f);
            errorexit();
        }
        for(i = 0; i < n; i++){
            s = lookup(fields[i], 0);
            s->type = SXREF;
            s->subtype = t;
            if(t == SIMPORT)
                nimports++;
            else
                nexports++;
        }
    }
    Bterm(b);
}
@




<<function export(arm)>>=
void
export(void)
{
    int i, j, n, off, nb, sv, ne;
    Sym *s, *et, *str, **esyms;
    Prog *p;
    char buf[NSNAME], *t;

    n = 0;
    for(i = 0; i < NHASH; i++)
        for(s = hash[i]; s != S; s = s->link)
            if(s->sig != 0 && s->type != SXREF && s->type != SUNDEF && (nexports == 0 || s->subtype == SEXPORT))
                n++;
    esyms = malloc(n*sizeof(Sym*));
    ne = n;
    n = 0;
    for(i = 0; i < NHASH; i++)
        for(s = hash[i]; s != S; s = s->link)
            if(s->sig != 0 && s->type != SXREF && s->type != SUNDEF && (nexports == 0 || s->subtype == SEXPORT))
                esyms[n++] = s;
    for(i = 0; i < ne-1; i++)
        for(j = i+1; j < ne; j++)
            if(strcmp(esyms[i]->name, esyms[j]->name) > 0){
                s = esyms[i];
                esyms[i] = esyms[j];
                esyms[j] = s;
            }

    nb = 0;
    off = 0;
    et = lookup(EXPTAB, 0);
    if(et->type != 0 && et->type != SXREF)
        diag("%s already defined", EXPTAB);
    et->type = SDATA;
    str = lookup(".string", 0);
    if(str->type == 0)
        str->type = SDATA;
    sv = str->value;
    for(i = 0; i < ne; i++){
        s = esyms[i];
        Bprint(&bso, "EXPORT: %s sig=%lux t=%d\n", s->name, s->sig, s->type);

        /* signature */
        p = newdata(et, off, sizeof(long), D_EXTERN);
        off += sizeof(long);
        p->to.offset = s->sig;

        /* address */
        p = newdata(et, off, sizeof(long), D_EXTERN);
        off += sizeof(long);
        p->to.symkind = D_EXTERN;
        p->to.sym = s;

        /* string */
        t = s->name;
        n = strlen(t)+1;
        for(;;){
            buf[nb++] = *t;
            sv++;
            if(nb >= NSNAME){
                p = newdata(str, sv-NSNAME, NSNAME, D_STATIC);
                p->to.type = D_SCONST;
                p->to.sval = malloc(NSNAME);
                memmove(p->to.sval, buf, NSNAME);
                nb = 0;
            }
            if(*t++ == 0)
                break;
        }

        /* name */
        p = newdata(et, off, sizeof(long), D_EXTERN);
        off += sizeof(long);
        p->to.symkind = D_STATIC;
        p->to.sym = str;
        p->to.offset = sv-n;
    }

    if(nb > 0){
        p = newdata(str, sv-nb, nb, D_STATIC);
        p->to.type = D_SCONST;
        p->to.sval = malloc(NSNAME);
        memmove(p->to.sval, buf, nb);
    }

    for(i = 0; i < 3; i++){
        newdata(et, off, sizeof(long), D_EXTERN);
        off += sizeof(long);
    }
    et->value = off;
    if(sv == 0)
        sv = 1;
    str->value = sv;
    exports = ne;
    free(esyms);
}
@




<<function newdata(arm)>>=
static Prog*
newdata(Sym *s, int o, int w, int t)
{
    Prog *p;

    p = prg();
    p->link = datap;
    datap = p;

    p->as = ADATA;
    p->reg = w;
    p->from.type = D_OREG;
    p->from.symkind = t;
    p->from.sym = s;
    p->from.offset = o;
    p->to.type = D_CONST;
    p->to.symkind = D_NONE;

    return p;
}
@



\subsection{Dynamic loading, [[5l -u]]}

% been disabled? can not find man page for dynld anymore, nor dynld.h
% -x, -u
% see dynld(2)

%see also rational for no dyn loading!
%http://sta.li/

<<global dlm>>=
bool dlm;
@

<<enum sxxx cases>>=
SIMPORT,
SEXPORT,
@



<<[[main()]] command line processing(arm)>>=
case 'u':	/* produce dynamically loadable module */
    dlm = true;
    if(argv[1] != nil && argv[1][0] != '-' && !isobjfile(argv[1]))
        readundefs(ARGF(), SIMPORT);
    break;
@
%x86 had this too:
%    // do not load standard libraries
%    debug['l'] = true;


<<[[asmb()]] if dynamic module magic header adjustment(arm)>>=
if(dlm)
    lput(0x80000000|0x647);	/* magic */
@




% import(), pending of export() ?

<<[[main()]] if dynamic module(arm)>>=
if(dlm){
    initdiv();
    import();
    HEADTYPE = H_PLAN9;
    INITTEXT = INITDAT = 0;
    INITRND = 8;
    INITENTRY = EXPTAB;
}
@





<<global dtype(arm)>>=
int	dtype = 4;
@

<<[[dodata()]] if ADYNT or AINIT>>=
if(p->as == ADYNT || p->as == AINIT)
    s->value = dtype;
@




<<function import(arm)>>=
void
import(void)
{
    int i;
    Sym *s;

    for(i = 0; i < NHASH; i++)
        for(s = hash[i]; s != S; s = s->link)
            if(s->sig != 0 && s->type == SXREF && (nimports == 0 || s->subtype == SIMPORT)){
                undefsym(s);
                Bprint(&bso, "IMPORT: %s sig=%lux v=%ld\n", s->name, s->sig, s->value);
            }
}
@

%on x86 additiona check and features, integrate them?
%                if(s->value != 0)
%                    diag("value != 0 on SXREF");
%                undefsym(s);
%                if(debug['X'])
%                    Bprint(&bso, "IMPORT: %s sig=%lux v=%ld\n", s->name, s->sig, s->value);
%                if(debug['S'])
%                    s->sig = 0;


<<enum rxxx>>=
enum rxxx {
    Roffset	= 22,		/* no. bits for offset in relocation address */
    Rindex	= 10,		/* no. bits for index in relocation address */
};
@

<<enum sxxx cases>>=
SUNDEF,
@
% for ??

<<[[patch()]] switch section type for branch instruction, cases>>=
case SUNDEF:
    if(p->as != ABL)
        diag("help: SUNDEF in AB || ARET");
    p->to.offset = 0;
    p->to.type = D_BRANCH;
    p->cond = UP;
    break;
@

% import -> undefsym
<<function undefsym>>=
void
undefsym(Sym *s)
{
    int n;

    n = imports;
    if(s->value != 0)
        diag("value != 0 on SXREF");
    if(n >= 1<<Rindex)
        diag("import index %d out of range", n);
    s->value = n<<Roffset;
    s->type = SUNDEF;
    imports++;
}
@
%>> >>



% port to arm?
%<<[[asmb()]] if dynamic module, when iterate from firstp(xxx)>>=
%if(dlm) {
%    if(p->as == ATEXT)
%        reloca = nil;
%    else if(reloca != nil)
%        diag("reloc failure: %P", curp);
%}
%@


% ???
<<[[asmb()]] if dynamic module, before datblk()>>=
if(dlm){
    char buf[8];

    write(cout, buf, INITDAT-textsize);
    textsize = INITDAT;
}
@

<<[[asmb()]] if dynamic module and no symbol table generation>>=
if(dlm){
    seek(cout, HEADR+textsize+datsize, 0);
    asmdyn();
    cflush();
}
@


<<[[entryvalue()]] if dynamic module case>>=
case SDATA:
    if(dlm)
        return s->value+INITDAT;
@





<<struct Reloc>>=
struct Reloc
{
    int n;
    int t;
    byte *m;
    ulong *a;
};
@

<<global rels>>=
Reloc rels;
@



<<[[asmb()]] if dynamic module, call asmdyn()>>=
if(dlm)
    asmdyn();
@

% asmb() -> asmdyn()

<<function asmdyn>>=
void
asmdyn()
{
    int i, n, t, c;
    Sym *s;
    ulong la, ra, *a;
    vlong off;
    byte *m;
    Reloc *r;

    cflush();
    off = seek(cout, 0, 1);
    lput(0);
    t = 0;
    lput(imports);
    t += 4;
    for(i = 0; i < NHASH; i++)
        for(s = hash[i]; s != S; s = s->link)
            if(s->type == SUNDEF){
                lput(s->sig);
                t += 4;
                t += sput(s->name);
            }

    la = 0;
    r = &rels;
    n = r->n;
    m = r->m;
    a = r->a;
    lput(n);
    t += 4;
    for(i = 0; i < n; i++){
        ra = *a-la;
        if(*a < la)
            diag("bad relocation order");
        if(ra < 256)
            c = 0;
        else if(ra < 65536)
            c = 1;
        else
            c = 2;
        cput((c<<6)|*m++);
        t++;
        if(c == 0){
            cput(ra);
            t++;
        }
        else if(c == 1){
            wput(ra);
            t += 2;
        }
        else{
            lput(ra);
            t += 4;
        }
        la = *a++;
    }

    cflush();
    seek(cout, off, 0);
    lput(t);

    DBG("import table entries = %d\n", imports);
    DBG("export table entries = %d\n", exports);
}
@
% >> >>

<<function sput>>=
static int
sput(char *s)
{
    char *p;

    p = s;
    while(*s)
        cput(*s++);
    cput(0);
    return  s-p+1;
}
@



<<global modemap>>=
int modemap[4] = { 0, 1, -1, 2, };
@


<<[[datblk()]] if dynamic module(arm)>>=
if(dlm)
    dynreloc(v, a+INITDAT, 1);
@


<<enum _anon_ (linkers/5l/span.c)(arm)>>=
enum{
    ABSD = 0,
    ABSU = 1,
    RELD = 2,
    RELU = 3,
};
@


<<function dynreloc(arm)>>=
void
dynreloc(Sym *s, long v, int abs)
{
    int i, k, n;
    byte *m;
    ulong *a;
    Reloc *r;

    if(v&3)
        diag("bad relocation address");
    v >>= 2;

    if(s != S && s->type == SUNDEF)
        k = abs ? ABSU : RELU;
    else
        k = abs ? ABSD : RELD;
    /* Bprint(&bso, "R %s a=%ld(%lx) %d\n", s->name, a, a, k); */
    k = modemap[k];
    r = &rels;
    n = r->n;
    if(n >= r->t)
        grow(r);
    m = r->m;
    a = r->a;
    for(i = n; i > 0; i--){
        if(v < a[i-1]){	/* happens occasionally for data */
            m[i] = m[i-1];
            a[i] = a[i-1];
        }
        else
            break;
    }
    m[i] = k;
    a[i] = v;
    r->n++;
}
@
% the align 4 check at the beginning are ARM specific

<<function grow>>=
static void
grow(Reloc *r)
{
    int t;
    byte *m, *nm;
    ulong *a, *na;

    t = r->t;
    r->t += 64;
    m = r->m;
    a = r->a;
    r->m = nm = malloc(r->t * sizeof(byte));
    r->a = na = malloc(r->t * sizeof(ulong));
    memmove(nm, m, t*sizeof(byte));
    memmove(na, a, t*sizeof(ulong));
    free(m);
    free(a);
}
@


\subsection{[[ADYNT]]}
% ???
% mv with dlm?
% seems never produced by 5a/5c
% was for alef?


<<[[ldobj()]] locals(arm)>>=
Sym *di = S;
@

<<enum sxxx cases>>=
SCONST,
@
% SCONST ... hmm confusing with D_SCONST IMHO

<<[[ldobj()]] switch opcode cases(arm)>>=
case ADYNT:
    if(p->to.sym == S) {
        diag("DYNT without a sym\n%P", p);
        break;
    }
    di = p->to.sym;
    p->reg = 4;
    if(di->type == SXREF) {
        if(debug['z'])
            Bprint(&bso, "%P set to %d\n", p, dtype);
        di->type = SCONST;
        di->value = dtype;
        dtype += 4;
    }
    if(p->from.sym == S)
        break;

    p->from.offset = di->value;
    p->from.sym->type = SDATA;
    if(curtext == P) {
        diag("DYNT not in text: %P", p);
        break;
    }
    p->to.sym = curtext->from.sym;
    p->to.type = D_CONST;
    p->link = datap;
    datap = p;
    break;
@



\subsection{[[AINIT]]}
% seems never produced by 5a/5c, like ADYNT, so move?
% seems to be just after a ADYNT, see the error message below


<<[[ldobj()]] switch opcode cases(arm)>>=
case AINIT:
    if(p->from.sym == S) {
        diag("INIT without a sym\n%P", p);
        break;
    }
    if(di == S) {
        diag("INIT without previous DYNT\n%P", p);
        break;
    }
    p->from.offset = di->value;
    p->from.sym->type = SDATA;
    p->link = datap;
    datap = p;
    break;

@

\subsection{Relocatable address, [[C_ADDR]]}

<<cxxx(arm) cases>>=
C_ADDR,		/* relocatable address */
@

<<[[aclass()]] when D_OREG and external symbol and dlm>>=
if(dlm) {
    switch(t) {
    case SUNDEF:
    case STEXT: case SLEAF: case SSTRING:
    case SCONST: 
        instoffset = s->value + a->offset;
        break;
    case SDATA: case SBSS:
    default:
        instoffset = s->value + a->offset + INITDAT;
        break;
    }
    return C_ADDR;
}
@
% I added the case SDATA: case SBSS:
% in default should return exn if not SDATA or SBSS no?

<<[[optab]] entries>>=
{ ATEXT,	C_ADDR,	C_NONE,	C_LCON, 	 0, 0, 0 },
{ ATEXT,	C_ADDR,	C_REG,	C_LCON, 	 0, 0, 0 },
@

<<[[optab]] entries>>=
{ AWORD,	C_NONE,	C_NONE,	C_ADDR,		11, 4, 0 },
@

<<[[asmout()]] on WORD case, switch class cases>>=
case C_LCON:
    if(!dlm)
        break;
    if(p->to.symkind != D_EXTERN && p->to.symkind != D_STATIC)
        break;
    // Fallthrough
case C_ADDR:
    if(p->to.sym->type == SUNDEF)
        ckoff(p->to.sym, p->to.offset);
    dynreloc(p->to.sym, p->pc, 1);
@

% Store
<<[[optab]] entries>>=
{ AMOVW,	C_REG,	C_NONE,	C_ADDR,		64, 8, 0,	LTO },
{ AMOVB,	C_REG,	C_NONE,	C_ADDR,		64, 8, 0,	LTO },
{ AMOVBU,	C_REG,	C_NONE,	C_ADDR,		64, 8, 0,	LTO },
@

<<[[asmout()]] switch on type cases>>=
/* reloc ops */
case 64:	/* mov/movb/movbu R,addr */
    o1 = omvl(p, &p->to, REGTMP);
    if(!o1)
        break;
    o2 = osr(p->as, p->from.reg, 0, REGTMP, p->scond);
    break;
@

% Load
<<[[optab]] entries>>=
{ AMOVW,	C_ADDR,	C_NONE,	C_REG,		65, 8, 0,	LFROM },
{ AMOVBU,	C_ADDR,	C_NONE,	C_REG,		65, 8, 0,	LFROM },
{ AMOVB,	C_ADDR,	C_NONE,	C_REG,		66, 16, 0,	LFROM },
{ AMOVH,	C_ADDR,	C_NONE,	C_REG,		66, 16, 0,	LFROM },
{ AMOVHU,	C_ADDR,	C_NONE,	C_REG,		66, 16, 0,	LFROM },
@


<<[[asmout()]] switch on type cases>>=
case 65:	/* mov/movbu addr,R */
case 66:	/* movh/movhu/movb addr,R */
    o1 = omvl(p, &p->from, REGTMP);
    if(!o1)
        break;
    o2 = olr(0, REGTMP, p->to.reg, p->scond);
    if(p->as == AMOVBU || p->as == AMOVB)
        o2 |= 1<<22;
    if(o->type == 65)
        break;

    o3 = oprrr(ASLL, p->scond);

    if(p->as == AMOVBU || p->as == AMOVHU)
        o4 = oprrr(ASRL, p->scond);
    else
        o4 = oprrr(ASRA, p->scond);

    r = p->to.reg;
    o3 |= (r)|(r<<12);
    o4 |= (r)|(r<<12);
    if(p->as == AMOVB || p->as == AMOVBU) {
        o3 |= (24<<7);
        o4 |= (24<<7);
    } else {
        o3 |= (16<<7);
        o4 |= (16<<7);
    }
    break;
@
% >> >> >> >> >> >> >>

<<[[optab]] entries>>=
{ AMOVH,	C_REG,	C_NONE,	C_ADDR,		67, 24, 0,	LTO },
{ AMOVHU,	C_REG,	C_NONE,	C_ADDR,		67, 24, 0,	LTO },
@

<<[[asmout()]] switch on type cases>>=
case 67:	/* movh/movhu R,addr -> sb, sb */
    o1 = omvl(p, &p->to, REGTMP);
    if(!o1)
        break;
    o2 = osr(p->as, p->from.reg, 0, REGTMP, p->scond);

    o3 = oprrr(ASRL, p->scond);
    o3 |= (8<<7)|(p->from.reg)|(p->from.reg<<12);
    o3 |= (1<<6);	/* ROR 8 */

    o4 = oprrr(AADD, p->scond);
    o4 |= (REGTMP << 12) | (REGTMP << 16);
    o4 |= immrot(1);

    o5 = osr(p->as, p->from.reg, 0, REGTMP, p->scond);

    o6 = oprrr(ASRL, p->scond);
    o6 |= (24<<7)|(p->from.reg)|(p->from.reg<<12);
    o6 |= (1<<6);	/* ROL 8 */
    break;
@
% >> >> >> >> >> >> >> >>


\section{Extra executable formats}


%<<[[main()]] switch HEADTYPE cases(arm)>>=
%case 0:	/* no header */
%case 6:	/* no header, padded segments */
%    HEADR = 0L;
%    if(INITTEXT == -1)
%        INITTEXT = 0;
%    if(INITDAT == -1)
%        INITDAT = 0;
%    if(INITRND == -1)
%        INITRND = 4;
%    break;
%case 1:	/* aif for risc os */
%    HEADR = 128L;
%    if(INITTEXT == -1)
%        INITTEXT = 0x10005000 + HEADR;
%    if(INITDAT == -1)
%        INITDAT = 0;
%    if(INITRND == -1)
%        INITRND = 4;
%    break;
%case 3:	/* boot for NetBSD */
%    HEADR = 32L;
%    if(INITTEXT == -1)
%        INITTEXT = 0xF0000020L;
%    if(INITDAT == -1)
%        INITDAT = 0;
%    if(INITRND == -1)
%        INITRND = 4096;
%    break;
%case 4: /* boot for IXP1200 */
%    HEADR = 0L;
%    if(INITTEXT == -1)
%        INITTEXT = 0x0;
%    if(INITDAT == -1)
%        INITDAT = 0;
%    if(INITRND == -1)
%        INITRND = 4;
%    break;
%case 5: /* boot for ipaq */
%    HEADR = 16L;
%    if(INITTEXT == -1)
%        INITTEXT = 0xC0008010;
%    if(INITDAT == -1)
%        INITDAT = 0;
%    if(INITRND == -1)
%        INITRND = 1024;
%    break;

%<<[[asmb()]] switch HEADTYPE (to position after text) cases(arm)>>=
%case 0:
%case 1:
%case 5:
%...
%case 3:
%case 6:	/* no header, padded segments */
%    OFFSET = rnd(HEADR+textsize, 4096);
%    seek(cout, OFFSET, 0);
%    break;


%<<[[asmb()]] switch HEADTYPE (for symbol table generation) cases(arm)>>=
%case 0:
%case 1:
%case 4:
%case 5:
%    debug['s'] = 1;
%    break;
%case 3:
%case 6:	/* no header, padded segments */
%    OFFSET += rnd(datsize, 4096);
%    seek(cout, OFFSET, 0);
%    break;


%<<[[asmb()]] switch HEADTYPE (for header generation) cases(arm)>>=
%case 0:	/* no header */
%case 6:	/* no header, padded segments */
%    break;
%case 1:	/* aif for risc os */
%    lputl(0xe1a00000);		/* NOP - decompress code */
%    lputl(0xe1a00000);		/* NOP - relocation code */
%    lputl(0xeb000000 + 12);		/* BL - zero init code */
%    lputl(0xeb000000 +
%        (entryvalue()
%         - INITTEXT
%         + HEADR
%         - 12
%         - 8) / 4);		/* BL - entry code */
%
%    lputl(0xef000011);		/* SWI - exit code */
%    lputl(textsize+HEADR);		/* text size */
%    lputl(datsize);			/* data size */
%    lputl(0);			/* sym size */
%
%    lputl(bsssize);			/* bss size */
%    lputl(0);			/* sym type */
%    lputl(INITTEXT-HEADR);		/* text addr */
%    lputl(0);			/* workspace - ignored */
%
%    lputl(32);			/* addr mode / data addr flag */
%    lputl(0);			/* data addr */
%    for(t=0; t<2; t++)
%        lputl(0);		/* reserved */
%
%    for(t=0; t<15; t++)
%        lputl(0xe1a00000);	/* NOP - zero init code */
%    lputl(0xe1a0f00e);		/* B (R14) - zero init return */
%    break;
%case 3:	/* boot for NetBSD */
%    lput((143<<16)|0413);		/* magic */
%    lputl(rnd(HEADR+textsize, 4096));
%    lputl(rnd(datsize, 4096));
%    lputl(bsssize);
%    lputl(symsize);			/* nsyms */
%    lputl(entryvalue());		/* va of entry */
%    lputl(0L);
%    lputl(0L);
%    break;
%case 4: /* boot for IXP1200 */
%    break;
%case 5: /* boot for ipaq */
%    lputl(0xe3300000);		/* nop */
%    lputl(0xe3300000);		/* nop */
%    lputl(0xe3300000);		/* nop */
%    lputl(0xe3300000);		/* nop */
%    break;
% >> 

\subsection{Elf}


<<[[main()]] switch HEADTYPE cases(arm)>>=
case H_ELF:	/* elf executable */
    HEADR = rnd(Ehdr32sz+3*Phdr32sz, 16);
    if(INITTEXT == -1)
        INITTEXT = 4096+HEADR;
    if(INITDAT == -1)
        INITDAT = 0;
    if(INITRND == -1)
        INITRND = 4;
    break;
@

<<[[asmb()]] switch HEADTYPE (to position after text) cases(arm)>>=
case H_ELF:
    OFFSET = HEADR+textsize;
    seek(cout, OFFSET, 0);
    break;
@

<<[[asmb()]] switch HEADTYPE (for symbol table generation) cases(arm)>>=
case H_ELF:
    break;
@

<<[[asmb()]] switch HEADTYPE (for header generation) cases(arm)>>=
case H_ELF:
    debug['S'] = 1;			/* symbol table */
    elf32(ARM, ELFDATA2LSB, 0, nil);
    break;
@
% >>


% start text physical address (elf only)
<<global INITTEXTP>>=
long	INITTEXTP = -1; /* text location (physical) */
@

<<[[main()]] last INITXXX adjustments>>=
if (INITTEXTP == -1)
    INITTEXTP = INITTEXT;
@


<<[[main()]] command line processing(arm)>>=
case 'P':
    a = ARGF();
    if(a)
        INITTEXTP = atolwhex(a);
    break;
@
% seems dead?

<<enum _anon_ (linkers/8l/elf.h)>>=
enum {
    Ehdr32sz	= 52,
    Phdr32sz	= 32,
    Shdr32sz	= 40,

    Ehdr64sz	= 64,
    Phdr64sz	= 56,
    Shdr64sz	= 64,
};
@

\subsection{OMach}

%\subsection{PE}
% windows format, see pe.h in golang/src/libmach/



\section{[[5l -E digits]]}

<<[[main()]] if digit INITENTRY>>=
if(!(*INITENTRY >= '0' && *INITENTRY <= '9'))
   lookup(INITENTRY, 0)->type = SXREF;
@
% 0_9 initentry means something special?

<<[[entryvalue()]] if digit INITENTRY>>=
if(*a >= '0' && *a <= '9')
    return atolwhex(a);
@



\section{Float instructions}

% string connection with the kernel floating port support.
% see bcm/vfp3.c, bcm/fpiarm.c, etc


<<function immfloat(arm)>>=
int
immfloat(long v)
{
    return (v & 0xC03) == 0;/* offset will fit in floating-point load/store */
}
@


<<cxxx(arm) cases>>=
C_FREG,
C_FCON,
C_FCR,
@

<<[[aclass()]] switch type cases>>=
case D_FREG:
    return C_FREG;
case D_FCONST:
    return C_FCON;
case D_FPCR:
    return C_FCR;
@

<<[[zaddr()]] cases>>=
case D_FREG:
case D_FPCR:
    break;
@



<<[[zaddr()]] cases>>=
case D_FCONST:
    a->ieee = malloc(sizeof(Ieee));

    a->ieee->l = p[4] | (p[5]<<8) | (p[6]<<16) | (p[7]<<24);
    a->ieee->h = p[8] | (p[9]<<8) | (p[10]<<16) | (p[11]<<24);
    size += 8;
    break;
@
% >> >> >> >> >> >>
% bugfix: there was a bug where it was using NSNAME instead of sizeof(Ieee)
%  but factorizing code with malloc fixed the issue too.


% 8.out.h

% ldobj -> <>
<<function ieeedtof>>=
long
ieeedtof(Ieee *e)
{
    int exp;
    long v;

    if(e->h == 0)
        return 0;
    exp = (e->h>>20) & ((1L<<11)-1L);
    exp -= (1L<<10) - 2L;
    v = (e->h & 0xfffffL) << 3;
    v |= (e->l >> 29) & 0x7L;
    if((e->l >> 28) & 1) {
        v++;
        if(v & 0x800000L) {
            v = (v & 0x7fffffL) >> 1;
            exp++;
        }
    }
    if(exp <= -126 || exp >= 130)
        diag("double fp to single fp overflow");
    v |= ((exp + 126) & 0xffL) << 23;
    v |= e->h & 0x80000000L;
    return v;
}
@

% Dconv -> <>
<<function ieeedtod>>=
double
ieeedtod(Ieee *ieeep)
{
    Ieee e;
    double fr;
    int exp;

    if(ieeep->h & (1L<<31)) {
        e.h = ieeep->h & ~(1L<<31);
        e.l = ieeep->l;
        return -ieeedtod(&e);
    }
    if(ieeep->l == 0 && ieeep->h == 0)
        return 0;
    fr = ieeep->l & ((1L<<16)-1L);
    fr /= 1L<<16;
    fr += (ieeep->l>>16) & ((1L<<16)-1L);
    fr /= 1L<<16;
    fr += (ieeep->h & (1L<<20)-1L) | (1L<<20);
    fr /= 1L<<21;
    exp = (ieeep->h>>20) & ((1L<<11)-1L);
    exp -= (1L<<10) - 2L;
    return ldexp(fr, exp);
}
@











<<enum optab_flag cases>>=
V4		= 1<<3,	/* arm v4 arch */
VFP		= 1<<4,	/* arm vfpv3 floating point */
@
% >> >>
%http://www.arm.com/products/processors/technologies/vector-floating-point.php

% from 8l(1) "Without this [-f] option, 5l generates arm7500 floating-point
% instructions which are emulated in the kernel."

<<[[ocmp()]] if floating point flag on p1 or p2>>=
n = (p2->flag&V4) - (p1->flag&V4);	/* architecture version */
if(n)
    return n;
n = (p2->flag&VFP) - (p1->flag&VFP);	/* floating point arch */
if(n)
    return n;
@

<<global vfp(arm)>>=
bool vfp;
@

% remove? and remove the relevant opcode also in optab? at least aspectize!
<<global armv4(arm)>>=
bool	armv4;
@

<<[[buildop()]] initializer floating flags>>=
armv4 = !debug['h'];
vfp = debug['f'];
@

<<[[buildop()]] adjust optab if floating flags>>=
if((optab[n].flag & VFP) && !vfp)
    optab[n].as = AXXX;
if((optab[n].flag & V4) && !armv4) {
    optab[n].as = AXXX;
    break;
}
@





<<[[ldobj()]] locals(arm)>>=
Prog *t;
@

<<[[ldobj()]] switch opcode cases(arm)>>=
case AMOVDF:
    if(!vfp || p->from.type != D_FCONST)
        goto casedef;
    p->as = AMOVF;
    /* fall through */
case AMOVF:
    if(skip)
        goto casedef;

    if(p->from.type == D_FCONST && chipfloat(p->from.ieee) < 0) {
        /* size sb 9 max */
        sprint(literal, "$%lux", ieeedtof(p->from.ieee));
        s = lookup(literal, 0);
        if(s->type == 0) {
            s->type = SBSS;
            s->value = 4;
            t = prg();
            t->as = ADATA;
            t->line = p->line;
            t->from.type = D_OREG;
            t->from.sym = s;
            t->from.symkind = D_EXTERN;
            t->reg = 4;
            t->to = p->from;
            t->link = datap;
            datap = t;
        }
        p->from.type = D_OREG;
        p->from.sym = s;
        p->from.symkind = D_EXTERN;
        p->from.offset = 0;
    }
    goto casedef;

case AMOVD:
    if(skip)
        goto casedef;

    if(p->from.type == D_FCONST && chipfloat(p->from.ieee) < 0) {
        /* size sb 18 max */
        sprint(literal, "$%lux.%lux",
            p->from.ieee->l, p->from.ieee->h);
        s = lookup(literal, 0);
        if(s->type == 0) {
            s->type = SBSS;
            s->value = 8;
            t = prg();
            t->as = ADATA;
            t->line = p->line;
            t->from.type = D_OREG;
            t->from.sym = s;
            t->from.symkind = D_EXTERN;
            t->reg = 8;
            t->to = p->from;
            t->link = datap;
            datap = t;
        }
        p->from.type = D_OREG;
        p->from.sym = s;
        p->from.symkind = D_EXTERN;
        p->from.offset = 0;
    }
    goto casedef;
@


<<global chipfloats(arm)>>=
static Ieee chipfloats[] = {
    {0x00000000, 0x00000000}, /* 0 */
    {0x00000000, 0x3ff00000}, /* 1 */
    {0x00000000, 0x40000000}, /* 2 */
    {0x00000000, 0x40080000}, /* 3 */
    {0x00000000, 0x40100000}, /* 4 */
    {0x00000000, 0x40140000}, /* 5 */
    {0x00000000, 0x3fe00000}, /* .5 */
    {0x00000000, 0x40240000}, /* 10 */
};
@
% ???

<<function chipfloat(arm)>>=
int
chipfloat(Ieee *e)
{
    Ieee *p;
    int n;

    if(vfp)
        return -1;
    for(n = sizeof(chipfloats)/sizeof(chipfloats[0]); --n >= 0;){
        p = &chipfloats[n];
        if(p->l == e->l && p->h == e->h)
            return n;
    }
    return -1;
}
@






<<[[noops()]] second pass switch opcode cases>>=
/*
 * 5c code generation for unsigned -> double made the
 * unfortunate assumption that single and double floating
 * point registers are aliased - true for emulated 7500
 * but not for vfp.  Now corrected, but this test is
 * insurance against old 5c compiled code in libraries.
 */
case AMOVWD:
    if((q = p->link) != P && q->as == ACMP)
     if((q = q->link) != P && q->as == AMOVF)
      if((q1 = q->link) != P && q1->as == AADDF)
       if(q1->to.type == D_FREG && q1->to.reg == p->to.reg) {
        q1->as = AADDD;
        q1 = prg();
        q1->scond = q->scond;
        q1->line = q->line;
        q1->as = AMOVFD;
        q1->from = q->to;
        q1->to = q1->from;
        q1->link = q->link;
        q->link = q1;
    }
    break;
@


\subsection{Common float instructions}


<<[[buildop()]] switch opcode r for ranges cases>>=
case AADDF:
    oprange[AADDD] = oprange[r];
    oprange[ASUBF] = oprange[r];
    oprange[ASUBD] = oprange[r];
    oprange[AMULF] = oprange[r];
    oprange[AMULD] = oprange[r];
    oprange[ADIVF] = oprange[r];
    oprange[ADIVD] = oprange[r];
    oprange[AMOVFD] = oprange[r];
    oprange[AMOVDF] = oprange[r];
    break;
    
case ACMPF:
    oprange[ACMPD] = oprange[r];
    break;

case AMOVF:
    oprange[AMOVD] = oprange[r];
    break;

case AMOVFW:
    oprange[AMOVWF] = oprange[r];
    oprange[AMOVWD] = oprange[r];
    oprange[AMOVDW] = oprange[r];
    break;
@

<<[[optab]] entries>>=
{ AMOVF,	C_FREG,	C_NONE,	C_FEXT,		50, 4, REGSB },
{ AMOVF,	C_FREG,	C_NONE,	C_FAUTO,	50, 4, REGSP },
{ AMOVF,	C_FREG,	C_NONE,	C_FOREG,	50, 4, 0 },

{ AMOVF,	C_FEXT,	C_NONE,	C_FREG,		51, 4, REGSB },
{ AMOVF,	C_FAUTO,C_NONE,	C_FREG,		51, 4, REGSP },
{ AMOVF,	C_FOREG,C_NONE,	C_FREG,		51, 4, 0 },

{ AMOVF,	C_FREG,	C_NONE,	C_LEXT,		52, 12, REGSB,	LTO },
{ AMOVF,	C_FREG,	C_NONE,	C_LAUTO,	52, 12, REGSP,	LTO },
{ AMOVF,	C_FREG,	C_NONE,	C_LOREG,	52, 12, 0,	LTO },

{ AMOVF,	C_LEXT,	C_NONE,	C_FREG,		53, 12, REGSB,	LFROM },
{ AMOVF,	C_LAUTO,C_NONE,	C_FREG,		53, 12, REGSP,	LFROM },
{ AMOVF,	C_LOREG,C_NONE,	C_FREG,		53, 12, 0,	LFROM },

{ AMOVF,	C_FREG,	C_NONE,	C_ADDR,		68, 8, 0,	LTO },
{ AMOVF,	C_ADDR,	C_NONE,	C_FREG,		69, 8, 0,	LFROM },

{ AADDF,	C_FREG,	C_NONE,	C_FREG,		54, 4, 0 },
{ AADDF,	C_FREG,	C_REG,	C_FREG,		54, 4, 0 },
{ AADDF,	C_FCON,	C_NONE,	C_FREG,		54, 4, 0 },
{ AADDF,	C_FCON,	C_REG,	C_FREG,		54, 4, 0 },
{ AMOVF,	C_FCON,	C_NONE,	C_FREG,		54, 4, 0 },
{ AMOVF,	C_FREG, C_NONE, C_FREG,		54, 4, 0 },

{ ACMPF,	C_FREG,	C_REG,	C_NONE,		54, 4, 0 },
{ ACMPF,	C_FCON,	C_REG,	C_NONE,		54, 4, 0 },

{ AMOVFW,	C_FREG,	C_NONE,	C_REG,		55, 4, 0 },
{ AMOVFW,	C_REG,	C_NONE,	C_FREG,		55, 4, 0 },
@



<<function regoff(arm)>>=
long
regoff(Adr *a)
{

    instoffset = 0;
    aclass(a);
    return instoffset;
}
@

<<[[asmout()]] switch on type cases>>=
case 50:	/* floating point store */
    v = regoff(&p->to);
    r = p->to.reg;
    if(r == R_NONE)
        r = o->param;
    o1 = ofsr(p->as, p->from.reg, v, r, p->scond, p);
    break;
@

%STC 6 << 25
<<function ofsr(arm)>>=
long
ofsr(int a, int r, long v, int b, int sc, Prog *p)
{
    long o;

    if(vfp)
        return ovfpmem(a, r, v, b, sc, p);

    o = (sc & C_SCOND) << 28;
    if(sc & C_SBIT)
        diag(".S on FLDR/FSTR instruction");
    if(!(sc & C_PBIT))
        o |= 1 << 24;
    if(sc & C_WBIT)
        o |= 1 << 21;
    o |= (6<<25) | (1<<24) | (1<<23);
    if(v < 0) {
        v = -v;
        o ^= 1 << 23;
    }
    if(v & 3)
        diag("odd offset for floating point op: %ld\n%P", v, p);
    else if(v >= (1<<10))
        diag("literal span too large: %ld\n%P", v, p);
    o |= (v>>2) & 0xFF;
    o |= b << 16;
    o |= r << 12;
    o |= 1 << 8;

    switch(a) {
    default:
        diag("bad fst %A", a);
    case AMOVD:
        o |= 1<<15;
    case AMOVF:
        break;
    }
    return o;
}
@
% >> >> >> >> >> >> >> >> >> >> >>



% LDC, 6 << 25 and 1 << 20
<<[[asmout()]] switch on type cases>>=
case 51:	/* floating point load */
    v = regoff(&p->from);
    r = p->from.reg;
    if(r == R_NONE)
        r = o->param;
    o1 = ofsr(p->as, p->to.reg, v, r, p->scond, p) | (1<<20);
    break;
@
% >>


% ADD ... STC
<<[[asmout()]] switch on type cases>>=
case 52:	/* floating point store, long offset UGLY */
    o1 = omvl(p, &p->to, REGTMP);
    if(!o1)
        break;
    r = p->to.reg;
    if(r == R_NONE)
        r = o->param;
    o2 = oprrr(AADD, p->scond) | (REGTMP << 12) | (REGTMP << 16) | r;
    o3 = ofsr(p->as, p->from.reg, 0, REGTMP, p->scond, p);
    break;
@
% >> >> >>

% ADD ... LTC
<<[[asmout()]] switch on type cases>>=
case 53:	/* floating point load, long offset UGLY */
    o1 = omvl(p, &p->from, REGTMP);
    if(!o1)
        break;
    r = p->from.reg;
    if(r == R_NONE)
        r = o->param;
    o2 = oprrr(AADD, p->scond) | (REGTMP << 12) | (REGTMP << 16) | r;
    o3 = ofsr(p->as, p->to.reg, 0, REGTMP, p->scond, p) | (1<<20);
    break;
@
% >> >> >>


<<[[oprrr()]] switch cases>>=
/* old arm 7500 fp using coprocessor 1 (1<<8) */
case AADDD:	return o | (0xe<<24) | (0x0<<20) | (1<<8) | (1<<7);
case AADDF:	return o | (0xe<<24) | (0x0<<20) | (1<<8);
case AMULD:	return o | (0xe<<24) | (0x1<<20) | (1<<8) | (1<<7);
case AMULF:	return o | (0xe<<24) | (0x1<<20) | (1<<8);
case ASUBD:	return o | (0xe<<24) | (0x2<<20) | (1<<8) | (1<<7);
case ASUBF:	return o | (0xe<<24) | (0x2<<20) | (1<<8);
case ADIVD:	return o | (0xe<<24) | (0x4<<20) | (1<<8) | (1<<7);
case ADIVF:	return o | (0xe<<24) | (0x4<<20) | (1<<8);
/* arguably, ACMPF should expand to RNDF, CMPD */
case ACMPD:
case ACMPF:	return o | (0xe<<24) | (0x9<<20) | (0xF<<12) | (1<<8) | (1<<4);	

case AMOVF:
case AMOVDF:	return o | (0xe<<24) | (0x0<<20) | (1<<15) | (1<<8);
case AMOVD:
case AMOVFD:	return o | (0xe<<24) | (0x0<<20) | (1<<15) | (1<<8) | (1<<7);

case AMOVWF:	return o | (0xe<<24) | (0<<20) | (1<<8) | (1<<4);
case AMOVWD:	return o | (0xe<<24) | (0<<20) | (1<<8) | (1<<4) | (1<<7);
case AMOVFW:	return o | (0xe<<24) | (1<<20) | (1<<8) | (1<<4);
case AMOVDW:	return o | (0xe<<24) | (1<<20) | (1<<8) | (1<<4) | (1<<7);
@
% >> >> >> >> >> >> >> >> >> >> >> >> >>
% >> >> >> >> >> >> >> >> >> >> >> >> >>
% >> >> >> >> >> >> >> >> >> >> >> >> >>
% >> >> >> >> >> >> >> >> >> >> >> >> >>
% >> >> >> >> >> >> >> >> >> >> >> >> >>
% >> >> >> >> >> >> >> >> >> >> >> >> >>
% 0xe << 24 => CDP instr, 1 << 8 => co processor 1




<<[[asmout()]] switch on type cases>>=
case 54:	/* floating point arith */
    o1 = oprrr(p->as, p->scond);
    if(p->from.type == D_FCONST) {
        rf = chipfloat(p->from.ieee);
        if(rf < 0){
            diag("invalid floating-point immediate\n%P", p);
            rf = 0;
        }
        rf |= (1<<3);
    } else
        rf = p->from.reg;
    rt = p->to.reg;
    r = p->reg;
    if(p->to.type == D_NONE)
        rt = 0;	/* CMP[FD] */
    else if(o1 & (1<<15))
        r = 0;	/* monadic */
    else if(r == R_NONE)
        r = rt;
    o1 |= rf | (r<<16) | (rt<<12);
    break;
@
% >> >> >> >> >>

<<[[asmout()]] switch on type cases>>=
case 55:	/* floating point fix and float */
    o1 = oprrr(p->as, p->scond);
    rf = p->from.reg;
    rt = p->to.reg;
    if(p->to.type == D_NONE){
        rt = 0;
        diag("to.type==D_NONE (asm/fp)");
    }
    if(p->from.type == D_REG)
        o1 |= (rf<<12) | (rt<<16);
    else
        o1 |= rf | (rt<<12);
    break;
@
% >> >> >> >>



<<[[asmout()]] switch on type cases>>=
case 68:	/* floating point store -> ADDR */
    o1 = omvl(p, &p->to, REGTMP);
    if(!o1)
        break;
    o2 = ofsr(p->as, p->from.reg, 0, REGTMP, p->scond, p);
    break;
@
<<[[asmout()]] switch on type cases>>=
case 69:	/* floating point load <- ADDR */
    o1 = omvl(p, &p->from, REGTMP);
    if(!o1)
        break;
    o2 = ofsr(p->as, p->to.reg, 0, REGTMP, p->scond, p) | (1<<20);
    break;
@
% >> >> >>

\subsection{VFP hardware instructions, [[5l -f]]}



<<function ovfpmem(arm)>>=
long
ovfpmem(int a, int r, long v, int b, int sc, Prog *p)
{
    long o;

    o = (sc & C_SCOND) << 28;
    if(sc & (C_SBIT|C_PBIT|C_WBIT))
        diag(".S/.P/.W on VLDR/VSTR instruction");
    o |= 0xd<<24 | (1<<23);
    if(v < 0) {
        v = -v;
        o ^= 1 << 23;
    }
    if(v & 3)
        diag("odd offset for floating point op: %ld\n%P", v, p);
    else if(v >= (1<<10))
        diag("literal span too large: %ld\n%P", v, p);
    o |= (v>>2) & 0xFF;
    o |= b << 16;
    o |= r << 12;
    switch(a) {
    default:
        diag("bad fst %A", a);
    case AMOVD:
        o |= 0xb<<8;
        break;
    case AMOVF:
        o |= 0xa<<8;
        break;
    }
    return o;
}
@
% >> >> >> >> >> >> >> >> 




<<[[optab]] entries>>=
{ AADDF,	C_FREG,	C_NONE,	C_FREG,		74, 4, 0, VFP },
{ AADDF,	C_FREG,	C_REG,	C_FREG,		74, 4, 0, VFP },
{ AMOVF,	C_FREG, C_NONE, C_FREG,		74, 4, 0, VFP },
{ ACMPF,	C_FREG,	C_REG,	C_NONE,		75, 8, 0, VFP },
{ ACMPF,	C_FCON,	C_REG,	C_NONE,		75, 8, 0, VFP },
{ AMOVFW,	C_FREG,	C_NONE,	C_REG,		76, 8, 0, VFP },
{ AMOVFW,	C_REG,	C_NONE,	C_FREG,		76, 8, 0, VFP },
@
% remember those are ranges!

<<[[asmout()]] switch on type cases>>=
/* VFP ops: */
case 74:	/* vfp floating point arith */
    o1 = opvfprrr(p->as, p->scond);
    rf = p->from.reg;
    if(p->from.type == D_FCONST) {
        diag("invalid floating-point immediate\n%P", p);
        rf = 0;
    }
    rt = p->to.reg;
    r = p->reg;
    if(r == R_NONE)
        r = rt;
    o1 |= rt<<12;
    if(((o1>>20)&0xf) == 0xb)
        o1 |= rf<<0;
    else
        o1 |= r<<16 | rf<<0;
    break;
@
% >> >> >>

<<[[asmout()]] switch on type cases>>=
case 75:	/* vfp floating point compare */
    o1 = opvfprrr(p->as, p->scond);
    rf = p->from.reg;
    if(p->from.type == D_FCONST) {
        if(p->from.ieee->h != 0 || p->from.ieee->l != 0)
            diag("invalid floating-point immediate\n%P", p);
        o1 |= 1<<16;
        rf = 0;
    }
    rt = p->reg;
    o1 |= rt<<12 | rf<<0;
    o2 = 0x0ef1fa10;	/* MRS APSR_nzcv, FPSCR */
    o2 |= (p->scond & C_SCOND) << 28;
    break;
@
% >> >> >> >>

<<[[asmout()]] switch on type cases>>=
case 76:	/* vfp floating point fix and float */
    o1 = opvfprrr(p->as, p->scond);
    rf = p->from.reg;
    rt = p->to.reg;
    if(p->from.type == D_REG) {
        o2 = o1 | rt<<12 | rt<<0;
        o1 = 0x0e000a10;	/* VMOV F,R */
        o1 |= (p->scond & C_SCOND) << 28 | rt<<16 | rf<<12;
    } else {
        o1 |= FREGTMP<<12 | rf<<0;
        o2 = 0x0e100a10;	/* VMOV R,F */
        o2 |= (p->scond & C_SCOND) << 28 | FREGTMP<<16 | rt<<12;
    }
    break;
@
%$
% >> >> >> >> >> >> >> >> >> >>



<<function opvfprrr(arm)>>=
long
opvfprrr(int a, int sc)
{
    long o;

    o = (sc & C_SCOND) << 28;
    if(sc & (C_SBIT|C_PBIT|C_WBIT))
        diag(".S/.P/.W on vfp instruction");
    o |= 0xe<<24;
    switch(a) {
    case AMOVWD:	return o | 0xb<<8 | 0xb<<20 | 1<<6 | 0x8<<16 | 1<<7;
    case AMOVWF:	return o | 0xa<<8 | 0xb<<20 | 1<<6 | 0x8<<16 | 1<<7;
    case AMOVDW:	return o | 0xb<<8 | 0xb<<20 | 1<<6 | 0xD<<16 | 1<<7;
    case AMOVFW:	return o | 0xa<<8 | 0xb<<20 | 1<<6 | 0xD<<16 | 1<<7;
    case AMOVFD:	return o | 0xa<<8 | 0xb<<20 | 1<<6 | 0x7<<16 | 1<<7;
    case AMOVDF:	return o | 0xb<<8 | 0xb<<20 | 1<<6 | 0x7<<16 | 1<<7;
    case AMOVF:	return o | 0xa<<8 | 0xb<<20 | 1<<6 | 0x0<<16 | 0<<7;
    case AMOVD:	return o | 0xb<<8 | 0xb<<20 | 1<<6 | 0x0<<16 | 0<<7;
    case ACMPF:	return o | 0xa<<8 | 0xb<<20 | 1<<6 | 0x4<<16 | 0<<7;
    case ACMPD:	return o | 0xb<<8 | 0xb<<20 | 1<<6 | 0x4<<16 | 0<<7;
    case AADDF:	return o | 0xa<<8 | 0x3<<20;
    case AADDD:	return o | 0xb<<8 | 0x3<<20;
    case ASUBF:	return o | 0xa<<8 | 0x3<<20 | 1<<6;
    case ASUBD:	return o | 0xb<<8 | 0x3<<20 | 1<<6;
    case AMULF:	return o | 0xa<<8 | 0x2<<20;
    case AMULD:	return o | 0xb<<8 | 0x2<<20;
    case ADIVF:	return o | 0xa<<8 | 0x8<<20;
    case ADIVD:	return o | 0xb<<8 | 0x8<<20;
    }
    diag("bad vfp rrr %d", a);
    prasm(curp);
    return 0;
}
@
% >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >>
% >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >>
% >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >>
% >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >>



\subsection{Kernel emulation}



<<[[optab]] entries>>=
{ AMOVW,	C_REG,	C_NONE,	C_FCR,		56, 4, 0 },
{ AMOVW,	C_FCR,	C_NONE,	C_REG,		57, 4, 0 },
@

<<[[asmout()]] switch on type cases>>=
/* old arm 7500 fp using coprocessor 1 (1<<8) */
case 56:	/* move to FP[CS]R */
    o1 = ((p->scond & C_SCOND) << 28) | (0xe << 24) | (1<<8) | (1<<4);
    o1 |= ((p->to.reg+1)<<21) | (p->from.reg << 12);
    break;
@
% >> >> >> >> >> >> >>
<<[[asmout()]] switch on type cases>>=
case 57:	/* move from FP[CS]R */
    o1 = ((p->scond & C_SCOND) << 28) | (0xe << 24) | (1<<8) | (1<<4);
    o1 |= ((p->from.reg+1)<<21) | (p->to.reg<<12) | (1<<20);
    break;
@
% >> >> >> >> >> >> >> >



%from bcm/arm.h
%#define CpOFPA		1			/* ancient 7500 FPA */
% => use coprocessor 1

% "without -f 5l generates arm7500 floating-point
% instructions which are emulated in the kernel."

% see bcm/fpiarm.c

<<[[optab]] entries>>=
{ AMOVH,	C_REG,	C_NONE,	C_HEXT,		70, 4, REGSB,	V4 },
{ AMOVH,	C_REG,	C_NONE, C_HAUTO,	70, 4, REGSP,	V4 },
{ AMOVH,	C_REG,	C_NONE,	C_HOREG,	70, 4, 0,		V4 },
{ AMOVHU,	C_REG,	C_NONE,	C_HEXT,		70, 4, REGSB,	V4 },
{ AMOVHU,	C_REG,	C_NONE, C_HAUTO,	70, 4, REGSP,	V4 },
{ AMOVHU,	C_REG,	C_NONE,	C_HOREG,	70, 4, 0,		V4 },

{ AMOVB,	C_HEXT,	C_NONE, C_REG,		71, 4, REGSB,	V4 },
{ AMOVB,	C_HAUTO,C_NONE,	C_REG,		71, 4, REGSP,	V4 },
{ AMOVB,	C_HOREG,C_NONE,	C_REG,		71, 4, 0,		V4 },
{ AMOVH,	C_HEXT,	C_NONE,	C_REG,		71, 4, REGSB,	V4 },
{ AMOVH,	C_HAUTO,C_NONE, C_REG,		71, 4, REGSP,	V4 },
{ AMOVH,	C_HOREG,C_NONE,	C_REG,		71, 4, 0,		V4 },
{ AMOVHU,	C_HEXT,	C_NONE,	C_REG,		71, 4, REGSB,	V4 },
{ AMOVHU,	C_HAUTO,C_NONE, C_REG,		71, 4, REGSP,	V4 },
{ AMOVHU,	C_HOREG,C_NONE,	C_REG,		71, 4, 0,		V4 },

{ AMOVH,	C_REG,	C_NONE,	C_LEXT,		72, 8, REGSB,	LTO|V4 },
{ AMOVH,	C_REG,	C_NONE, C_LAUTO,	72, 8, REGSP,	LTO|V4 },
{ AMOVH,	C_REG,	C_NONE,	C_LOREG,	72, 8, 0,		LTO|V4 },
{ AMOVHU,	C_REG,	C_NONE,	C_LEXT,		72, 8, REGSB,	LTO|V4 },
{ AMOVHU,	C_REG,	C_NONE, C_LAUTO,	72, 8, REGSP,	LTO|V4 },
{ AMOVHU,	C_REG,	C_NONE,	C_LOREG,	72, 8, 0,		LTO|V4 },

{ AMOVB,	C_LEXT,	C_NONE, C_REG,		73, 8, REGSB,	LFROM|V4 },
{ AMOVB,	C_LAUTO,C_NONE,	C_REG,		73, 8, REGSP,	LFROM|V4 },
{ AMOVB,	C_LOREG,C_NONE,	C_REG,		73, 8, 0,		LFROM|V4 },
{ AMOVH,	C_LEXT,	C_NONE,	C_REG,		73, 8, REGSB,	LFROM|V4 },
{ AMOVH,	C_LAUTO,C_NONE, C_REG,		73, 8, REGSP,	LFROM|V4 },
{ AMOVH,	C_LOREG,C_NONE,	C_REG,		73, 8, 0,		LFROM|V4 },
{ AMOVHU,	C_LEXT,	C_NONE,	C_REG,		73, 8, REGSB,	LFROM|V4 },
{ AMOVHU,	C_LAUTO,C_NONE, C_REG,		73, 8, REGSP,	LFROM|V4 },
{ AMOVHU,	C_LOREG,C_NONE,	C_REG,		73, 8, 0,		LFROM|V4 },
@

<<[[asmout()]] switch on type cases>>=
/* ArmV4 ops: */
case 70:	/* movh/movhu R,O(R) -> strh */
    aclass(&p->to);
    r = p->to.reg;
    if(r == R_NONE)
        r = o->param;
    o1 = oshr(p->from.reg, instoffset, r, p->scond);
    break;	
@
<<[[asmout()]] switch on type cases>>=
case 71:	/* movb/movh/movhu O(R),R -> ldrsb/ldrsh/ldrh */
    aclass(&p->from);
    r = p->from.reg;
    if(r == R_NONE)
        r = o->param;
    o1 = olhr(instoffset, r, p->to.reg, p->scond);
    if(p->as == AMOVB)
        o1 ^= (1<<5)|(1<<6);
    else if(p->as == AMOVH)
        o1 ^= (1<<6);
    break;
@
% >> >>  >>

<<[[asmout()]] switch on type cases>>=
case 72:	/* movh/movhu R,L(R) -> strh */
    o1 = omvl(p, &p->to, REGTMP);
    if(!o1)
        break;
    r = p->to.reg;
    if(r == R_NONE)
        r = o->param;
    o2 = oshrr(p->from.reg, REGTMP,r, p->scond);
    break;	
@

<<[[asmout()]] switch on type cases>>=
case 73:	/* movb/movh/movhu L(R),R -> ldrsb/ldrsh/ldrh */
    o1 = omvl(p, &p->from, REGTMP);
    if(!o1)
        break;
    r = p->from.reg;
    if(r == R_NONE)
        r = o->param;
    o2 = olhrr(REGTMP, r, p->to.reg, p->scond);
    if(p->as == AMOVB)
        o2 ^= (1<<5)|(1<<6);
    else if(p->as == AMOVH)
        o2 ^= (1<<6);
    break;
@
% >> >> >>


<<function olhr(arm)>>=
long
olhr(long v, int b, int r, int sc)
{
    long o;

    o = (sc & C_SCOND) << 28;
    if(sc & C_SBIT)
        diag(".S on LDRH/STRH instruction");

    if(!(sc & C_PBIT))
        o |= 1 << 24;
    if(sc & C_WBIT)
        o |= 1 << 21;
    o |= (1<<23) | (1<<20)|(0xb<<4);
    if(v < 0) {
        v = -v;
        o ^= 1 << 23;
    }
    if(v >= (1<<8))
        diag("literal span too large: %ld (R%d)\n%P", v, b, PP);
    o |= (v&0xf)|((v>>4)<<8)|(1<<22);
    o |= b << 16;
    o |= r << 12;
    return o;
}
@
% >> >> >> >> >> >> >> >> >> >> >> >>

<<function osr(arm)>>=
long
osr(int a, int r, long v, int b, int sc)
{
    long o;

    o = olr(v, b, r, sc) ^ (1<<20);
    if(a != AMOVW)
        o |= 1<<22;
    return o;
}
@
% >> >> >> >>

<<function oshr(arm)>>=
long
oshr(int r, long v, int b, int sc)
{
    long o;

    o = olhr(v, b, r, sc) ^ (1<<20);
    return o;
}
@
% >>


<<function osrr(arm)>>=
long
osrr(int r, int i, int b, int sc)
{

    return olr(i, b, r, sc) ^ ((1<<25) | (1<<20));
}
@
% >> >>

<<function oshrr(arm)>>=
long
oshrr(int r, int i, int b, int sc)
{
    return olhr(i, b, r, sc) ^ ((1<<22) | (1<<20));
}
@
% >> >>

<<function olrr(arm)>>=
long
olrr(int i, int b, int r, int sc)
{

    return olr(i, b, r, sc) ^ (1<<25);
}
@
% >>

<<function olhrr(arm)>>=
long
olhrr(int i, int b, int r, int sc)
{
    return olhr(i, b, r, sc) ^ (1<<22);
}
@
% >>



\section{Division instructions}

\subsection{[[ADIV]] rewriting}

<<[[noops()]] first pass switch opcode cases>>=
case ADIV:
case ADIVU:
case AMOD:
case AMODU:
    if(prog_div == P)
        initdiv();
    if(curtext != P)
        curtext->mark &= ~LEAF;
    continue;
@
% a bit ugly to do the initdiv here? at the same it's related to
% this notion of NOOP.

%    /* MOV a,4(SP) */
%    /* MOV b,REGTMP */
%    /* CALL appropriate */
%    /* MOV REGTMP, b */
%    /* ADD $8,SP */
%q1
%    /* SUB $8,SP */

<<[[noops()]] second pass switch opcode cases>>=
case ADIV:
case ADIVU:
case AMOD:
case AMODU:
    if(debug['M'])
        break;
    if(p->from.type != D_REG)
        break;
    if(p->to.type != D_REG)
        break;
    q1 = p;

    q = prg();
    q->link = p->link;
    p->link = q;
    p = q;

    /* MOV a,4(SP) */
    p->as = AMOVW;
    p->line = q1->line;
    p->from.type = D_REG;
    p->from.reg = q1->from.reg;
    p->to.type = D_OREG;
    p->to.reg = REGSP;
    p->to.offset = 4;

    q = prg();
    q->link = p->link;
    p->link = q;
    p = q;

    /* MOV b,REGTMP */
    p->as = AMOVW;
    p->line = q1->line;
    p->from.type = D_REG;
    p->from.reg = q1->reg;
    if(q1->reg == R_NONE)
        p->from.reg = q1->to.reg;
    p->to.type = D_REG;
    p->to.reg = REGTMP;
    p->to.offset = 0;

    q = prg();
    q->link = p->link;
    p->link = q;
    p = q;

    /* CALL appropriate */
    p->as = ABL;
    p->line = q1->line;
    p->to.type = D_BRANCH;
    p->cond = p;
    switch(o) {
    case ADIV:
        p->cond = prog_div;
        p->to.sym = sym_div;
        break;
    case ADIVU:
        p->cond = prog_divu;
        p->to.sym = sym_divu;
        break;
    case AMOD:
        p->cond = prog_mod;
        p->to.sym = sym_mod;
        break;
    case AMODU:
        p->cond = prog_modu;
        p->to.sym = sym_modu;
        break;
    }

    q = prg();
    q->link = p->link;
    p->link = q;
    p = q;

    /* MOV REGTMP, b */
    p->as = AMOVW;
    p->line = q1->line;
    p->from.type = D_REG;
    p->from.reg = REGTMP;
    p->from.offset = 0;
    p->to.type = D_REG;
    p->to.reg = q1->to.reg;

    q = prg();
    q->link = p->link;
    p->link = q;
    p = q;

    /* ADD $8,SP */
    p->as = AADD;
    p->from.type = D_CONST;
    p->from.reg = R_NONE;
    p->from.offset = 8;
    p->reg = R_NONE;
    p->to.type = D_REG;
    p->to.reg = REGSP;

    /* SUB $8,SP */
    q1->as = ASUB;
    q1->from.type = D_CONST;
    q1->from.offset = 8;
    q1->from.reg = R_NONE;
    q1->reg = R_NONE;
    q1->to.type = D_REG;
    q1->to.reg = REGSP;
    break;
@


<<global prog_div(arm)>>=
Prog*	prog_div;
@

<<global prog_divu(arm)>>=
Prog*	prog_divu;
@

<<global prog_mod(arm)>>=
Prog*	prog_mod;
@

<<global prog_modu(arm)>>=
Prog*	prog_modu;
@


\subsection{[[initdiv()]]}

<<global sym_div(arm)>>=
static	Sym*	sym_div;
@

<<global sym_divu(arm)>>=
static	Sym*	sym_divu;
@

<<global sym_mod(arm)>>=
static	Sym*	sym_mod;
@

<<global sym_modu(arm)>>=
static	Sym*	sym_modu;
@


<<constant SIGNINTERN(arm)>>=
#define SIGNINTERN	(1729*325*1729)
@

<<function sigdiv(arm)>>=
static void
sigdiv(char *n)
{
    Sym *s;

    s = lookup(n, 0);
    if(s->type == STEXT){
        if(s->sig == 0)
            s->sig = SIGNINTERN;
    }
    else if(s->type == SNONE || s->type == SXREF)
        s->type = SUNDEF;
}
@

<<function divsig(arm)>>=
void
divsig(void)
{
    sigdiv("_div");
    sigdiv("_divu");
    sigdiv("_mod");
    sigdiv("_modu");
}
@

<<function sdiv(arm)>>=
static void
sdiv(Sym *s)
{
    if(s->type == SNONE || s->type == SXREF){
        /* undefsym(s); */
        s->type = SXREF;
        if(s->sig == 0)
            s->sig = SIGNINTERN;
        s->subtype = SIMPORT;
    }
    else if(s->type != STEXT)
        diag("undefined: %s", s->name);
}
@

<<function initdiv(arm)>>=
void
initdiv(void)
{
    Sym *s2, *s3, *s4, *s5;
    Prog *p;

    if(prog_div != P)
        return;
    sym_div = s2 = lookup("_div", 0);
    sym_divu = s3 = lookup("_divu", 0);
    sym_mod = s4 = lookup("_mod", 0);
    sym_modu = s5 = lookup("_modu", 0);
    if(dlm) {
        sdiv(s2); if(s2->type == SXREF) prog_div = UP;
        sdiv(s3); if(s3->type == SXREF) prog_divu = UP;
        sdiv(s4); if(s4->type == SXREF) prog_mod = UP;
        sdiv(s5); if(s5->type == SXREF) prog_modu = UP;
    }
    for(p = firstp; p != P; p = p->link)
        if(p->as == ATEXT) {
            if(p->from.sym == s2)
                prog_div = p;
            if(p->from.sym == s3)
                prog_divu = p;
            if(p->from.sym == s4)
                prog_mod = p;
            if(p->from.sym == s5)
                prog_modu = p;
        }
    if(prog_div == P) {
        diag("undefined: %s", s2->name);
        prog_div = curtext;
    }
    if(prog_divu == P) {
        diag("undefined: %s", s3->name);
        prog_divu = curtext;
    }
    if(prog_mod == P) {
        diag("undefined: %s", s4->name);
        prog_mod = curtext;
    }
    if(prog_modu == P) {
        diag("undefined: %s", s5->name);
        prog_modu = curtext;
    }
}
@


\section{Multiple registers instructions}

<<[[buildop()]] switch opcode r for ranges cases>>=
case AMOVM:
    break;
@

<<[[optab]] entries>>=
{ AMOVM,	C_LCON,	C_NONE,	C_SOREG,	38, 4, 0 },
{ AMOVM,	C_SOREG,C_NONE,	C_LCON,		39, 4, 0 },
@

<<[[asmout()]] switch on type cases>>=
case 38:	/* movm $con,oreg -> stm */
    o1 = (0x4 << 25);
    o1 |= p->from.offset & 0xffff;
    o1 |= p->to.reg << 16;
    aclass(&p->to);
    goto movm;
@
%$

<<[[asmout()]] switch on type cases>>=
case 39:	/* movm oreg,$con -> ldm */
    o1 = (0x4 << 25) | (1 << 20);
    o1 |= p->to.offset & 0xffff;
    o1 |= p->from.reg << 16;
    aclass(&p->from);
movm:
    if(instoffset != 0)
        diag("offset must be zero in MOVM");
    o1 |= (p->scond & C_SCOND) << 28;
    if(p->scond & C_PBIT)
        o1 |= 1 << 24;
    if(p->scond & C_UBIT)
        o1 |= 1 << 23;
    if(p->scond & C_SBIT)
        o1 |= 1 << 22;
    if(p->scond & C_WBIT)
        o1 |= 1 << 21;
    break;
@
%$


\section{Compiler-only pseudo opcodes}

<<[[buildop()]] switch opcode r for ranges cases>>=
case ACASE:
case ABCASE:
    break;
@

<<[[optab]] entries>>=
{ ACASE,	C_REG,	C_NONE,	C_NONE,		62, 4, 0 },
{ ABCASE,	C_NONE, C_NONE, C_BRANCH,   63, 4, 0 },
@


<<[[asmout()]] switch on type cases>>=
case 62:	/* case R -> movw	R<<2(PC),PC */
    o1 = olrr(p->from.reg, REGPC, REGPC, p->scond);
    o1 |= 2<<7;
    break;
@
% >>  >>

<<[[asmout()]] switch on type cases>>=
case 63:	/* bcase */
    if(p->cond != P) {
        o1 = p->cond->pc;
        if(dlm)
            dynreloc(S, p->pc, 1);
    }
    break;
@




\chapter{Conclusion}












\appendix

\chapter{Debugging}

%\section{[[debug]]}

% hmm actually it's used not just for debugging but also for generic
% options, e.g. for -l, -p, etc in addition to the main use which is -v
<<global debug>>=
bool	debug[128];
@
% why not 256 like in Assembler.nw?


% -A, see diag()

%bso? 
<<global bso>>=
Biobuf	bso;
@



<<[[main()]] debug initialization(arm)>>=
Binit(&bso, 1, OWRITE);
listinit(); // fmtinstall()
@
%x86: memset(debug, false, sizeof(debug));

<<[[main()]] command line processing(arm)>>=
default:
    c = ARGC();
    if(c >= 0 && c < sizeof(debug))
        debug[c]++;
    break;
@

\section{Fmt}
% dupe with Compiler.nw

% why called listinit??

<<function prasm(arm)>>=
void
prasm(Prog *p)
{
    print("%P\n", p);
}
@


<<function listinit(arm)>>=
void
listinit(void)
{

    fmtinstall('A', Aconv);
    fmtinstall('C', Cconv);
    fmtinstall('D', Dconv);
    fmtinstall('P', Pconv);
    fmtinstall('S', Sconv);
    fmtinstall('N', Nconv);
}
@

<<function Nconv(arm)>>=
int
Nconv(Fmt *fp)
{
    char str[STRINGSZ];
    Adr *a;
    Sym *s;

    a = va_arg(fp->args, Adr*);
    s = a->sym;

    switch(a->symkind) {
    case N_NONE:
        sprint(str, "%ld", a->offset);
        break;

    case D_EXTERN:
        if(s == S)
            sprint(str, "%ld(SB)", a->offset);
        else
            sprint(str, "%s+%ld(SB)", s->name, a->offset);
        break;

    case D_STATIC:
        if(s == S)
            sprint(str, "<>+%ld(SB)", a->offset);
        else
            sprint(str, "%s<>+%ld(SB)", s->name, a->offset);
        break;

    case D_AUTO:
        if(s == S)
            sprint(str, "%ld(SP)", a->offset);
        else
            sprint(str, "%s-%ld(SP)", s->name, -a->offset);
        break;

    case D_PARAM:
        if(s == S)
            sprint(str, "%ld(FP)", a->offset);
        else
            sprint(str, "%s+%ld(FP)", s->name, a->offset);
        break;
    default:
        sprint(str, "GOK-name(%d)", a->symkind);
        break;

    }
    return fmtstrcpy(fp, str);
}
@




<<global strcond(arm)>>=
char*	strcond[16] =
{
    ".EQ",
    ".NE",
    ".HS",
    ".LO",
    ".MI",
    ".PL",
    ".VS",
    ".VC",
    ".HI",
    ".LS",
    ".GE",
    ".LT",
    ".GT",
    ".LE",
    "",
    ".NV"
};
@

<<function Cconv(arm)>>=
int
Cconv(Fmt *fp)
{
    char s[20];
    int c;

    c = va_arg(fp->args, int);
    strcpy(s, strcond[c & C_SCOND]);
    if(c & C_SBIT)
        strcat(s, ".S");
    if(c & C_PBIT)
        strcat(s, ".P");
    if(c & C_WBIT)
        strcat(s, ".W");
    if(c & C_UBIT)		/* ambiguous with FBIT */
        strcat(s, ".U");
    return fmtstrcpy(fp, s);
}
@





% defined in ../5c/enam.c, coupling with enum as in 5.out.h
% extern	char*	anames[];

<<function Aconv(arm)>>=
// enum<opcode> -> string
int
Aconv(Fmt *fp)
{
    char *s;
    int a;

    a = va_arg(fp->args, int);
    s = "???";
    if(a >= AXXX && a < ALAST)
        s = anames[a];
    return fmtstrcpy(fp, s);
}
@





<<constant STRINGSZ>>=
STRINGSZ	= 200,
@


<<function Pconv(arm)>>=
// Prog -> string
int
Pconv(Fmt *fp)
{
    char str[STRINGSZ], *s;
    Prog *p;
    int a;

    p = va_arg(fp->args, Prog*);
    curp = p;
    a = p->as;

    switch(a) {
    case ASWPW:
    case ASWPBU:
        sprint(str, "(%ld)	%A%C	R%d,%D,%D",
            p->line, a, p->scond, p->reg, &p->from, &p->to);
        break;

    case ADATA:

    case AINIT:
    case ADYNT:
        sprint(str, "(%ld)	%A%C	%D/%d,%D",
            p->line, a, p->scond, &p->from, p->reg, &p->to);
        break;

    default:
        s = str;
        s += sprint(s, "(%ld)", p->line);
        if(p->reg == R_NONE)
            sprint(s, "	%A%C	%D,%D",
                a, p->scond, &p->from, &p->to);
        else
        if(p->from.type != D_FREG)
            sprint(s, "	%A%C	%D,R%d,%D",
                a, p->scond, &p->from, p->reg, &p->to);
        else
            sprint(s, "	%A%C	%D,F%d,%D",
                a, p->scond, &p->from, p->reg, &p->to);
        break;

    }
    return fmtstrcpy(fp, str);
}
@





<<function Dconv(arm)>>=
// Adr -> string
int
Dconv(Fmt *fp)
{
    char str[STRINGSZ];
    char *op;
    Adr *a;
    long v;

    a = va_arg(fp->args, Adr*);
    switch(a->type) {

    case D_NONE:
        str[0] = 0;
        if(a->symkind != D_NONE || a->reg != R_NONE || a->sym != S)
            sprint(str, "%N(R%d)(NONE)", a, a->reg);
        break;

    case D_CONST:
        if(a->reg == R_NONE)
            sprint(str, "$%N", a);
        else
            sprint(str, "$%N(R%d)", a, a->reg);
        break;

    case D_SHIFT:
        v = a->offset;
        op = "<<>>->@>" + (((v>>5) & 3) << 1);
        if(v & (1<<4))
            sprint(str, "R%ld%c%cR%ld", v&15, op[0], op[1], (v>>8)&15);
        else
            sprint(str, "R%ld%c%c%ld", v&15, op[0], op[1], (v>>7)&31);
        if(a->reg != R_NONE)
            sprint(str+strlen(str), "(R%d)", a->reg);
        break;

    case D_OREG:
        if(a->reg != R_NONE)
            sprint(str, "%N(R%d)", a, a->reg);
        else
            sprint(str, "%N", a);
        break;

    case D_REG:
        sprint(str, "R%d", a->reg);
        if(a->symkind != D_NONE || a->sym != S)
            sprint(str, "%N(R%d)(REG)", a, a->reg);
        break;

    case D_REGREG:
        sprint(str, "(R%d,R%d)", a->reg, (int)a->offset);
        if(a->symkind != D_NONE || a->sym != S)
            sprint(str, "%N(R%d)(REG)", a, a->reg);
        break;

    case D_FREG:
        sprint(str, "F%d", a->reg);
        if(a->symkind != D_NONE || a->sym != S)
            sprint(str, "%N(R%d)(REG)", a, a->reg);
        break;

    case D_PSR:
        switch(a->reg) {
        case 0:
            sprint(str, "CPSR");
            break;
        case 1:
            sprint(str, "SPSR");
            break;
        default:
            sprint(str, "PSR%d", a->reg);
            break;
        }
        if(a->symkind != D_NONE || a->sym != S)
            sprint(str, "%N(PSR%d)(REG)", a, a->reg);
        break;

    case D_FPCR:
        switch(a->reg){
        case 0:
            sprint(str, "FPSR");
            break;
        case 1:
            sprint(str, "FPCR");
            break;
        default:
            sprint(str, "FCR%d", a->reg);
            break;
        }
        if(a->symkind != D_NONE || a->sym != S)
            sprint(str, "%N(FCR%d)(REG)", a, a->reg);

        break;

    case D_BRANCH:	/* botch */
        if(curp->cond != P) {
            v = curp->cond->pc;
            if(a->sym != S)
                sprint(str, "%s+%.5lux(BRANCH)", a->sym->name, v);
            else
                sprint(str, "%.5lux(BRANCH)", v);
        } else
            if(a->sym != S)
                sprint(str, "%s+%ld(APC)", a->sym->name, a->offset);
            else
                sprint(str, "%ld(APC)", a->offset);
        break;

    case D_FCONST:
        sprint(str, "$%e", ieeedtod(a->ieee));
        break;

    case D_SCONST:
        sprint(str, "$\"%S\"", a->sval);
        break;

    default:
        sprint(str, "GOK-type(%d)", a->type);
        break;

    }
    return fmtstrcpy(fp, str);
}
@

%    case D_OCONST:
%        sprint(str, "$*$%N", a);
%        if(a->reg != R_NONE)
%            sprint(str, "%N(R%d)(CONST)", a, a->reg);
%        break;







<<function Sconv(arm)>>=
// ?? -> string
int
Sconv(Fmt *fp)
{
    int i, c;
    char str[STRINGSZ], *p, *a;

    a = va_arg(fp->args, char*);
    p = str;
    for(i=0; i<sizeof(long); i++) {
        c = a[i] & 0xff;
        if(c >= 'a' && c <= 'z' ||
           c >= 'A' && c <= 'Z' ||
           c >= '0' && c <= '9' ||
           c == ' ' || c == '%') {
            *p++ = c;
            continue;
        }
        *p++ = '\\';
        switch(c) {
        case 0:
            *p++ = 'z';
            continue;
        case '\\':
        case '"':
            *p++ = c;
            continue;
        case '\n':
            *p++ = 'n';
            continue;
        case '\t':
            *p++ = 't';
            continue;
        }
        *p++ = (c>>6) + '0';
        *p++ = ((c>>3) & 7) + '0';
        *p++ = (c & 7) + '0';
    }
    *p = 0;
    return fmtstrcpy(fp, str);
}
@


\section{Verbose mode, [[5l -v]]}
% and [[DBG()]]

%used to have lots of code like:
%if(debug['v']) {
%    Bprint(&bso, "HEADER = -H0x%ld -T0x%lux -D0x%lux -R0x%lux\n",
%        HEADTYPE, INITTEXT, INITDAT, INITRND);
%    Bflush(&bso);
%}
% (The Bflush was outside the if, but makes more sense like this I think)
%but better to have a DBG macro for this

<<macro DBG>>=
#define DBG if(debug['v']) mylog
@

<<function log>>=
void mylog(char *fmt, ...) {

    va_list arg;

    va_start(arg, fmt);
    Bvprint(&bso, fmt, arg);
    va_end(arg);
    Bflush(&bso);
}
@

\section{Object loading debugging, [[5l -W]]}
% print object code when loading

%ex: of output:




\section{Machine code debugging, [[5l -a]]}
% print final concrete code in assembly language with addresses

%ex of output:





%\section{[[5l -9 -B -U]]}
% dead I think, -9 for plan9, B for planB? U for Unix?

%<<constant DEFAULT>>=
%#define	DEFAULT	'9'
%@
%
%
%% obsolete?
%<<[[main()]] adjust HEADTYPE if debug flags(arm)>>=
%if(!debug['9'] && !debug['U'] && !debug['B'])
%    debug[DEFAULT] = true;
%
%if(HEADTYPE == -1) {
%    if(debug['U'])
%        HEADTYPE = 0;
%    if(debug['B'])
%        HEADTYPE = 1;
%    if(debug['9'])
%        HEADTYPE = H_PLAN9;
%}
%@

\chapter{Error Managment}

<<global nerrors>>=
int	nerrors = 0;
@

<<function errorexit>>=
void
errorexit(void)
{

    if(nerrors) {
        if(cout >= 0)
            remove(outfile);
        exits("error");
    }
    exits(0);
}
@



% could use TNAME here too?
<<function diag>>=
void
diag(char *fmt, ...)
{
    char buf[STRINGSZ];
    char *tn;
    va_list arg;

    tn = "??none??";
    if(curtext != P && curtext->from.sym != S)
        tn = curtext->from.sym->name;
    va_start(arg, fmt);
    vseprint(buf, buf+sizeof(buf), fmt, arg);
    va_end(arg);
    print("%s: %s\n", tn, buf);

    nerrors++;
    if(nerrors > 20 && !debug['A']) {
        print("too many errors\n");
        errorexit();
    }
}
@
% ARM does not have the && !debug['A'], but probablt error no?


\chapter{Profiling}

% 5l -v
% had lots of cputime() too in calls to DBG, so a form of profiling

<<[[main()]] profile report>>=
if(debug['v']) {
    Bprint(&bso, "%5.2f cpu time\n", cputime());
    Bprint(&bso, "%ld symbols\n", nsymbol);
    Bprint(&bso, "%ld memory used\n", thunk);
    Bprint(&bso, "%d sizeof adr\n", sizeof(Adr));
    Bprint(&bso, "%d sizeof prog\n", sizeof(Prog));
    Bflush(&bso);
}
@

\chapter{Libc}

\section{Memory managmnent}
% same in Assembler.nw

<<global hunk>>=
char*	hunk;
@



<<global nhunk>>=
long	nhunk;
@
% = 0??


<<global thunk>>=
long	thunk;
@


<<constant NHUNK linker>>=
NHUNK		= 100000,
@


% not sure why don't use libc malloc and do low-level sbrk ...
% to optimize things? as they do no free?
<<function gethunk>>=
void
gethunk(void)
{
    char *h;
    long nh;

    nh = NHUNK;
    if(thunk >= 5L*NHUNK) {
        nh = 5L*NHUNK;
        if(thunk >= 25L*NHUNK)
            nh = 25L*NHUNK;
    }
    h = sbrk(nh);
    if(h == (char*)-1) {
        diag("out of memory");
        errorexit();
    }
    hunk = h;
    nhunk = nh;
    thunk += nh;
}
@




<<function malloc>>=
/*
 * fake malloc
 */
void*
malloc(ulong n)
{
    void *p;

    // upper_round(n, 8)
    while(n & 7)
        n++;

    while(nhunk < n)
        gethunk();
    p = hunk;
    nhunk -= n;
    hunk += n;
    return p;
}
@




% no free ...  hmmm
<<function free>>=
void
free(void *p)
{
    USED(p);
}
@



% not sure why but if redefine malloc and free then have to
% redefine this func too, otherwise get a link error
<<function setmalloctag>>=
//@Scheck: looks dead, but because we redefine malloc/free we must also redefine that
void setmalloctag(void *v, ulong pc)
{
    USED(v, pc);
}
@


\section{Buffer managmnent}

<<struct Buf>>=
union Buf
{
    struct
    {
        char	obuf[MAXIO];			/* output buffer */
        byte	ibuf[MAXIO];			/* input buffer */
    };
    char	dbuf[1];
};
@

<<constant MAXIO>>=
MAXIO		= 8192,
@

<<global buf>>=
union Buf buf;
@


<<function readsome>>=
byte*
readsome(int f, byte *buf, byte *good, byte *stop, int max)
{
    int n;

    n = stop - good;
    memmove(buf, good, stop - good);
    stop = buf + n;
    n = MAXIO - n;
    if(n > max)
        n = max;
    n = read(f, stop, n);
    if(n <= 0)
        return 0;
    return stop + n;
}
@



%<<constant cbuf>>=
%#define	Cbuf	u.obuf
%@
%<<constant xbuf>>=
%#define	Xbuf	u.ibuf
%@
%%simplified! use anonymous union!


<<global cbp>>=
char*	cbp;
@

<<global cbc>>=
int	cbc;
@



<<[[main()]] initialize globals(arm)>>=
cbp = buf.obuf;
cbc = sizeof(buf.obuf);
@



<<function cput(arm)>>=
void
cput(int c)
{
    cbp[0] = c;
    cbp++;
    cbc--;
    if(cbc <= 0)
        cflush();
}
@
% mostly similar to x86, x86 is using a macro though

% in the end print in cout
<<function cflush>>=
void
cflush(void)
{
    int n;

    n = sizeof(buf.obuf) - cbc;
    if(n)
        write(cout, buf.obuf, n);

    cbp = buf.obuf;
    cbc = sizeof(buf.obuf);
}
@




% xxxl means left? little endian?


<<function wputl(arm)>>=
void
wputl(long l)
{

    cbp[0] = l;
    cbp[1] = l>>8;
    cbp += 2;
    cbc -= 2;
    if(cbc <= 0)
        cflush();
}
@
% the x86 version seems more logical, normal?
% what about overflow?? sure cbc >= 2?

<<function wput(arm)>>=
void
wput(long l)
{

    cbp[0] = l>>8;
    cbp[1] = l;
    cbp += 2;
    cbc -= 2;
    if(cbc <= 0)
        cflush();
}
@



<<function lput(arm)>>=
void
lput(long l)
{

    cbp[0] = l>>24;
    cbp[1] = l>>16;
    cbp[2] = l>>8;
    cbp[3] = l;
    cbp += 4;
    cbc -= 4;
    if(cbc <= 0)
        cflush();
}
@



<<function lputl(arm)>>=
void
lputl(long l)
{

    cbp[3] = l>>24;
    cbp[2] = l>>16;
    cbp[1] = l>>8;
    cbp[0] = l;
    cbp += 4;
    cbc -= 4;
    if(cbc <= 0)
        cflush();
}
@


<<function llput>>=
void
llput(vlong v)
{
    lput(v>>32);
    lput(v);
}
@


<<function llputl>>=
void
llputl(vlong v)
{
    lputl(v);
    lputl(v>>32);
}
@




<<function strnput(arm)>>=
void
strnput(char *s, int n)
{
    for(; *s; s++){
        cput(*s);
        n--;
    }
    for(; n > 0; n--)
        cput(0);
}
@
% the x86 version is sligtly different

\section{File managment}

<<function fileexists>>=
int
fileexists(char *s)
{
    byte dirbuf[400];

    /* it's fine if stat result doesn't fit in dirbuf, since even then the file exists */
    return stat(s, dirbuf, sizeof(dirbuf)) >= 0;
}
@


\section{String processing}

% could be put in libc, with the other atoxxx
% atoxx? why a?  a to long with hexadecimal?
<<function atolwhex>>=
long
atolwhex(char *s)
{
    long n;
    int f;

    n = 0;
    f = 0;
    while(*s == ' ' || *s == '\t')
        s++;
    if(*s == '-' || *s == '+') {
        if(*s++ == '-')
            f = 1;
        while(*s == ' ' || *s == '\t')
            s++;
    }
    if(s[0]=='0' && s[1]){
        if(s[1]=='x' || s[1]=='X'){
            s += 2;
            for(;;){
                if(*s >= '0' && *s <= '9')
                    n = n*16 + *s++ - '0';
                else if(*s >= 'a' && *s <= 'f')
                    n = n*16 + *s++ - 'a' + 10;
                else if(*s >= 'A' && *s <= 'F')
                    n = n*16 + *s++ - 'A' + 10;
                else
                    break;
            }
        } else
            while(*s >= '0' && *s <= '7')
                n = n*8 + *s++ - '0';
    } else
        while(*s >= '0' && *s <= '9')
            n = n*10 + *s++ - '0';
    if(f)
        n = -n;
    return n;
}
@


\section{Mathematic functions}

<<function rnd>>=
long
rnd(long v, long r)
{
    long c;

    if(r <= 0)
        return v;
    v += r - 1;
    c = v % r;
    if(c < 0)
        c += r;
    v -= c;
    return v;
}
@


\chapter{Extra Code}

\ifallcode
#include "Linker_extra.nw"
\fi

\chapter{Changelog}
\label{sec:changelog}

\chapter{Glossary}
\label{sec:glossary}

\begin{verbatim}
\end{verbatim}

\chapter*{Indexes}
\addcontentsline{toc}{section}{Index}

%\chapter{References} 
\addcontentsline{toc}{section}{References}

\begin{thebibliography}{99}

\bibitem[1]{wp-literate-programming} Donald Knuth,,
{\em Literate Programming}, 
\url{http://en.wikipedia.org/wiki/Literate\_Program}

\bibitem[2]{noweb} Norman Ramsey,
{\em Noweb}, 
\url{http://www.cs.tufts.edu/~nr/noweb/}

\bibitem[3]{syncweb} Yoann Padioleau,
{\em Syncweb, literate programming meets unison}, 
\url{http://padator.org/software/project-syncweb/readme.txt}

\end{thebibliography}

%******************************************************************************
% Postlude
%******************************************************************************

\end{document}
