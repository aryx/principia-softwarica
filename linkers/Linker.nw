\documentclass[twocolumn, landscape]{report}

%******************************************************************************
% Prelude
%******************************************************************************
\newif\iffinal
\newif\ifverbose
\finaltrue\verbosefalse % see also other newif in Macros.tex

%------------------------------------------------------------------------------
%history:
%------------------------------------------------------------------------------

%thx to LP, I changed for the better a few things:
% - introduced Headtype enum instead of hardcoded integers
% - introduced mylog() and DBG() to factorize the tracing code
% - removed many portable myxxx() wrappers (and merged compat.c with utils.c)
% - collateral evolutions of changes in 5a, e.g., NREG -> R_NONE, 
%   D_FILE1 -> N_LINE, etc
% - removed some deadcode 
%    * C_LBRA, C_LECON, C_SCON, D_OCONST, regused
%    * ADYNT, AINIT (stuff used only by dead Alef language?)
%    * NENT
%    * commented lots of code that was in dead ifdefs or was related to
%      dead Alef features like BECOME
%    * forward decl typedef Count
%    * code to deal with UBIT where does not make sense (MOVW)
% - reorganized the code:
%    * split big enum in separate types: Section, Operand_class, misc
%    * around INITENTRY, -l, -E digit, make default path
%    * renames many local variables, more consistent (v = version, etc)
%    * mv Autom out of union, remove union, was confusing
%    * far cleaner oplook(), where optimizations have been aspectized
%    * introduced D_ADDR in Assembler so can have cleaner code in Linker
%    * more consistent olr/osr/olrr/... pass opcode and sc as first params
%      so can also factorize code regarding bit 22 and have simpler wrappers
% - reorganized the files to better match the chapters by introducing many more
%    files: main.c, lib.c, error.c, m.h, profile.c, hist.c, etc

%thx to 5l in ocaml: 
%  - see again that code could be so much simpler, no need so many globals,
%    can be far more functional, more explicit on which information is
%    needed by a function.
%  - introduced more files, obj.c, main.c (could also have a lookup.c)
%  - ANAME simplifies things actually in 5l; it factorizes code. We have
%    to write visitor boilerplate in ocaml.
%  - naming phase done thx also to ANAME. There is symbol table transformation!
%    Symbol now has a global version, instead of being just N_EXTERN vs
%    N_INTERN and a unique pointer.
%  - found bug with BL foo+4(SB) silently converted by 5l
%  - realize every RET is converted in a indirect jump!
%  - discover more invariants, e.g., SLL cant have C_SHIFT operands,
%    Bxx supports only static jumps, offset in IndirectJump always 0, ...
%  - understand the +4 for N_PARAM even though autosize has already had a +4
%  - understand that pool can be an ximm, that is not always a simple imm
%    e.g., for MOVW $foo(SB), R1, we need to generate a WORD $foo(SB) which
%    will be resolved in codegen, after layout_text has computed an
%    address for everything


%thx to codemap/codegraph/scheck:
% - see subtle dependency to 8c/enam.c through anames
% - use scheck to remove deadcode, dead prototypes, useless export
%   or mv as forward decl
%   (harder to understand big interface files)
% - use codegraph to move globals closer to their owner module

%thx to this manual, better understand linking:
% - that an object is really a module, the simplest/lowest module abstraction
%   with defs and uses to link together (for text and data).
% - that linker and loader are related by executable format and sections;
%   one generates data (the executable) that the other reads (the kernel)
% - disk image of executable and memory image of program are different
%   hence the -TText
% - mutual dependency between dotext and dodata where need layout
%   data before text but then need text before know where starts data
%   (solved via SB/R12 for 5l)
% - architecture constraints on immediate constants and offsets require
%   tricks in the linker such as SB/R12, BIG, special bootstrap
%   setR12 LCON, pooling, etc. (case also for x86?)
% - how debugging support works, how can track back file/line and stack traces
% - SEMI what if have multiple object defining the same global?
%   int x; int x; in different files? what if one also define value?
%   what if both define value? DUPOK?
% - sign vs unsigned operation, need to keep sign bit part, same with bitshift
% - TODO dynamic linking? export table? import table?
% - TODO fpic? 

%history LP-ization:
% - skeleton, mostly copy paste of Template.nw skeleton
% - put all content of files in the Extra section, via 'pfff -lpize'
%   which also now split in chunks!
%    * function, global, struct, enum, constant, macro(actually function)
%    * extra, other fields split
% - read Extra section, identify concepts, first TOC
% - distribute parts of the file before
% - understand main(), LP split main, improve TOC
% - understand main functions, LP split, cluster, improve TOC
% - LP split the structures, use datalog for flow to field info
% - nullify, boolify, typeify,    scheckify
% - aspectify advanced features!
% - add figures
% - add explanations

%------------------------------------------------------------------------------
% Packages
%------------------------------------------------------------------------------

\usepackage{../docs/latex/noweb}
 \noweboptions{footnotesizecode,nomargintag}
 %note: allow chunk on different pages, less white space at bottom of pages
 \def\nwendcode{\endtrivlist \endgroup}
 \let\nwdocspar=\par
\usepackage{xspace}
\usepackage{verbatim}
%note: required by noweblatexpad for the \t \l \n in this file
\usepackage{fancyvrb}
\usepackage{url}
\usepackage{hyperref}
 \hypersetup{colorlinks=true}
\usepackage[pageref]{backref}
 \def\backref{{\footnotesize cited page(s)}~}
\usepackage{booktabs} 
 \newcommand{\otoprule}{\midrule[\heavyrulewidth]}
\usepackage{multirow} % not in BasicTex
\usepackage{graphicx}

%------------------------------------------------------------------------------
% Macros
%------------------------------------------------------------------------------
\input{../docs/latex/Macros}

%------------------------------------------------------------------------------
% Config
%------------------------------------------------------------------------------
\allcodefalse
% ifallcode is used for:
%  - forward decl, func decl, extern decl, #ifdef, pragmas (stuff in Extra.nw)
%  - some local variables

%\setcounter{tocdepth}{1}

\addtolength{\topmargin}{-.850in}
\addtolength{\textheight}{1.70in}

\begin{document}
%******************************************************************************
% Title
%******************************************************************************
\title{
{\Huge 
Principia Softwarica: The ARM Linker [[5l]]
}\\
{version 0.1}
}

\author{
Yoann Padioleau\\
\texttt{yoann.padioleau@gmail.com}\\
\\
with code from\\
Rob Pike
}

\maketitle 
%alt: 8l, x86 (32 bits) edition
\l ARMv6 (32 bits) edition\\
\l Rob pike really author also of linker? or Ken Thompson?


\onecolumn
\hrule
\input{../docs/latex/Copyright}
\input{../docs/latex/CopyrightPlan9}
\hrule
\twocolumn

\begingroup
\hypersetup{linkcolor=blue}
% need to s/onecolumn/twocolumn in report.cls :) for \tableofcontents
\tableofcontents
\endgroup

%******************************************************************************
% Body
%******************************************************************************

\chapter{Introduction}

The goal of this book is to explain with full details the source code of
a {linker}.

\section{Motivations}

Why a linker?
Because I think you are a better programmer if 
you fully understand how things work under the hood, and
the linker is the final piece of any {development toolchain},
the one generating finally the {executable}.

There are very few books about linkers,
as opposed to a myriad of books on compilers or kernels.
\n the linker/loader book is mentioned later
Linkers are usually not even studied during the computer science curriculum. 
This is a pity because they are central.
Indeed, they make the link (no pun intended) between the compiler
and the kernel: the linker generates from {object files} {executables} 
that the kernel will {load}. Without a linker there is no program to execute.
\l linker/loader relation
\l Many blog posts, show interest from people
\l compiler rely a lot on linker, to link together modules!
\l often get errors from linker. never explained, maybe boring but important!
\n even to understand ocamlc, ocamlrun, -custom, important understand linker
\t Google made their own linker! because critical. At Facebook, hours
\t  lost because extremely slow linker. Nobody dared there to make a new
\t  one. Google did because hired original author. But linker not that
\t  complicated!

Here are a few questions we hope this book will answer:
\begin{itemize}
\item What is the format of object files?

\item What is the format of executables?
What is the format of machine instructions?

%\item What is the difference between the ELF and [[a.out]] formats?
% what means a.out? ELF?

\item What is the format of libraries?

\item How object files and libraries get combined together and patched
to form the final executable?

\item What is the difference between a linker and a loader?
\l still use LD instead of LK in Makefile, sad

\item What is the memory image of a program? 
How does it relate to the executable file? How does it relate to
the original source code?

\item What debugging information contains executables? How
source-level debuggers can find which C source code corresponds 
to a specific binary instruction?
\l actually 5l does also some profiling, but more unexpected

\end{itemize}
\l what is position independent code? 
\l how dynamic linking works? 
\l how shared libraries works? 
\l endianess? see the inuxi stuff? also lput vs lputl
\l how handle architecture constraints

%tags used in this file for different recurring themes:
 %assembler: relates code in the linker to similar (or absent) code in 5a
 %emulator: relates code in the linker to similar (or absent) code in 5i
 %sanity: I use "sanity check" in chunknames, to aspectize a bit error checking
 %
 %real-world: to relate to other linkers
 %ocaml: to give a hint on how rewriting C in OCaml could improve things
 %alt: alternative techniques
 %old: for original code I changed to be clearer
 %pad: for code (or files) I introduced to be clearer
 %dead: dead code removed
 %toc: %trans: %dup: %example: %chunks:

\t put in conclusion non-trivial adv algo and data structures seen? see comment
%data-structures (beyond list/hashtbl): (use list, queue, hashtbl)
% - AST again with enums, tag/union structure
% - Buffer with reading sliding window
% - growing array (for filename and incompatible signature report)
% - graph and pointers (from implicit graph in array with ref via pc integer)
% - forward overlay link indexation (and associated faster search)
%   aka skip lists
% - pattern matching array dispatch table (with subtype notions)
%   and associated indexation (range and cmp and caching), quite nice
%   way to overcome limitations of C; get close to ocaml in the end.
% - compression filenames with path elements indexing, and list of integers
%   with delta
% - reflection via special symbols
% - bitsets, lots of bit manipulations


%algorithms (beyond search/sort): (use binary search and use qsort)
% - unserialization/unmarshalling with shared enum and tags so simple dispatch
%   or with header specifying sizes, and sliding input buffer window
% - signature checking (header I_MAGIC, archive ARMAG, names ASIGNAME)
% - binary search (with overlay)
% - compression/indexing for list of filenames and list of integers
% - versioning for disambiguation (but gensym would be better term)
% - DFS? (follow?)

%other?
% - program instrumentation for profiling
% - smaller:
%   * def/use link again via symbol table and special marks (SXREF)
%   * AST rewriting and optimisations
%   * caching/memoizing and precomputation for optimisations
%   * dumpers
%   * endianess via inuxi or lput/lputl
% - =~ concatenation, resolution, relocation
% - poolization?
% - special algos for dynamic linking?

% many remaining questions in Assembler.nw are tied to Linker.nw
% (and also some to Machine.nw) so good to study linker.


\section{The \plan ARM linker: [[5l]]}

I will explain in this book the code of the \plan ARM linker
[[5l]]\footnote{See \url{http://plan9.bell-labs.com/magic/man2html/1/8l},
which despite its name covers also [[5l]]}
which is about 8150 lines of code (LOC).
\n make loc, counting only 5l, not ar.c, size.c, etc
\t say appendix also code of ar and say LOC too?
[[5l]] is written entirely in C.
%%%\footnote{
%%%An OCaml partial port is also shown in Appendix~\ref{chap:5l-ocaml}.
%%%}.


%dup: (and adapted) from Assembler.nw
Like for most books in \principia, I chose a \plan program because
those programs are simple, small, elegant, open source, and they form together
a coherent set.
The [[5]] comes from the \plan convention to name architectures
with a number or single letter (0 is MIPS, 5 is ARM, 8 is x86, etc),
and the [[l]] means linker.

%dup: (and adapted) from Assembler.nw
Like for the other \principia books covering the
{development toolchain}, I chose the ARM architecture~\cite{arm-refman}
variant, in this case of the \plan linker ([[5l]]),
and not for instance the x86 variant ([[8l]]), for
reasons of simplicity. Indeed RISC machines
are far simpler than CISC machines. Moreover, the availability
under \plan of an ARM emulator, [[5i]], helps to understand
the semantics of the machine instructions generated by [[5l]].

The \plan approach to linking is a bit different than in other
operating systems. The \plan linker is responsible
for generating executables, but also for generating the machine code 
from the object files. Indeed, the object files generated
by [[5a]] and [[5c]] 
%dup: (and adapted) from Assembler.nw
are ARM-specific, but they do not contain machine code. 
Instead, under \plan an object file is essentially the {serialized form} of the 
{abstract syntax tree} of an assembly source.
%
The linker [[5l]] generates the actual machine code.
% instruction selection too
%
I think though that it is actually a better design because it leads to
less code in total and also to simpler code.
\t why? because anyway linker need deep knowledge of machine code format
\l  because need patch it here and there, so why not put everything in it
\l  so assembler then is simpler 
\t Better for opti too. Things can be done only when know actual size, such as
\l  length of offset. Compiler has not the knowledge for that.
\n probably cos there was only 5c/5l before and responsabilities were shifted
%
The \plan linker does also some dead code elimination
\l well just for libraries, and it is not really dead code
\l and apparently it's pretty common for a linker to do that
\l also instruction selection? more opti?
\l inter-lib linking-time optimisations!?
which reduces the size of the binaries. 
This is partly to compensate for the lack of
dynamic shared libraries in \plan.
\l but shared libraries are evil! dynamic shared libraries?
\l Also there is no dynamic linking by default. Simpler approach again.
\t does also instruction selection? asmout, brloop are opti?

\n critique of go/plan9 toolchain,
%  -  http://dtrace.org/blogs/wesolows/2014/12/29/golang-is-trash/
%tutorial:
% http://blog.altoros.com/golang-internals-part-3-the-linker-and-object-files.html
%the design of the Go assembler (sucessor to plan9 assembler) talks about
% design decision behind compiler/assembler/linker
% https://www.youtube.com/watch?v=KINIAgRpkDA&feature=youtu.be


\section{Other linkers}

Here are a few linkers that I considered for this book, but
which I ultimately discarded:
\begin{itemize}

\item The GNU Linker [[ld]], part of the [[binutils]] package,
\t URLs
is probably the most used open source linker.
It is using the Binary File Descriptor (BFD) library 
to read and write object files using different formats.
It supports many architectures (ARM, x86, etc)
as well as many executable and object file formats (ELF, [[a.out]], etc).
\l also dynamic libraries, ELF
\n BFD =~ libmach
It is fairly big though: 30~000 LOC for [[ld/]]
and 500~000 LOC for [[bfd/]].
Even the ARM-specific file [[bfd/elf32-arm.c]] has already 17~000 LOC.

\item Gold is a faster multi-threaded ELF linker originally developed at Google.
It is now part of the [[binutils]] package.
It supports also many architectures (ARM, x86, etc).
\l not using BFD?
It is unfortunately also fairly big: 153~000 LOC.
Again, even the ARM-specific file [[gold/arm.cc]] has already 13~000 LOC.
\n cplusplus
\l show that useful to see how linker works! cf FB, so much time lost in ld
\l and engineers didnt even think to rewrite it, though impossible. barriers!

\item The LLVM Linker [[lld]] aims to remove the current dependency to
the host linker (e.g., [[ld]] under Linux) in the LLVM infrastructure.
Its goal is also to be more modular and extensible than [[ld]].
It supports also many architectures and executable formats.
\n (ARM, x86, etc) (ELF, COFF, etc).
It is smaller than [[ld]] and Gold, but still fairly large: 71~000 LOC.
\n cplusplus
\l lld seems to do advanced opti or going towards advanced opti with notion
\l    of Atoms vs Section (see lld/docs/design.rst)
% http://lld.llvm.org/NewLLD.html

%dup: (and adapted) from Assembler.nw
\item LD86 is an x86 16-bit and 32-bit linker, part of
Bruce Evans' C compiler (BCC). It is an historical linker
used to compile old versions of Minix and Linux.
\l sure?
%
It is fairly small: 6100 LOC, which is smaller than [[5l]].
But, to be fair, [[5l]] does also machine code generation,
which is done instead by AS86 for LD86. [[5a]]+[[5l]] is made of 12~000 LOC,
which is smaller than AS86+LD86 at 18~600 LOC.
Moreover, the instruction format in the ARM is far simpler to
understand than the one in the x86, which makes it a better candidate
for \principia.
\l (even for linker-related issues?)

\end{itemize}
\l add furl

\l a few other linkers, see the comment in the .nw
%industry:
% - optlink, digital mars, very fast, written in assembly though
%history:
% - ??
%other:
% - http://www.compilers.de/vlink.html, part of vbcc and vasm
%   by Frank Wille, 25 000 LOC but many formats, but not completly OSS I think
%mini:
% - http://recc.robertelder.org/ has a integerated linker in the compiler
% - linker and loaders book mention linker project in Perl, 
%   http://linker.iecc.com/code.html but contains helper code, not final code
%education:
% - https://github.com/trillek-team/computer-toolkit (for space game)
%   a toy asm, linker, and even a toy C compiler, for TR3200 machine
% - subc-2014, sld, 700LOC?
%modern:
% - lld, see above
% - .NET has one? or JIT so different?

%http://www.cl.cam.ac.uk/~pes20/rems/papers/oopsla-elf-linking-2016.pdf

%pro: %dup: Assembler.nw
\t Used not only in plan9. Used in Go 
%(\footnote{rewritten since Go X but still}).


\section{Getting started}
\label{sec:getting-started}

%dup: (and adapted) from Assembler.nw
To play with [[5l]] you will first need to install
the \plan fork used in \principia. See \urlinstall.
Once installed, you can test [[5l]] under \plan with:

\begin{verbatim}
1   $ cd /tests/5l
2   $ 5a hello.s && 5a world.s
3   $ 5l hello.5 world.5 -o hello
4   $ ./hello
5   hello world
6   $
\end{verbatim}
\n minimal example here! no libc.a, just to make sure the minimal stuff works

The command in Line 2 {assembles} the simple [[hello.s]]
and [[world.s]] ARM assembly programs and generates the 
[[hello.5]] and [[world.5]] ARM {object files}.
\l define object file? .5? explained later.
Line 3 then {links} the object files together and generates the final 
ARM binary executable [[hello]].
Line 4, which assumes you are under an ARM machine (e.g., a Raspberry Pi)
{launchs} the program.

Note that it is easy under \plan to {cross compile} from another architecture:
you can use the same commands, [[5a]], [[5l]], etc.
\l because magic /bin, and also because special 5 convention
To play with [[5l]] under an x86 machine you just need
after the linking step to use the ARM emulator [[5i]] instead:

\begin{verbatim}
...
4   $ 5i hello
...
\end{verbatim}

See the \book{Emulator} for more information on [[5i]].
\l actually cool cos can be used as an assembly debugger too


\section{Requirements}

%dup: from Assembler.nw
Because most of this book is made of C source code, 
you will need a good knowledge of 
the C programming language~\cite{k-r} to understand it.
%
In fact, for Chapter~\ref{chap:arm-codegen}, where we will
see the code which generates ARM instructions, 
you will need a very good knowledge of C.
Indeed, the code does lots of bit manipulations and uses many C idioms.

There are very few books explaining how a linker works.
I can cite {\em Linkers and Loaders}~\cite{ll}
and one chapter of 
{\em Computer Systems: A Programmer's Perspective}~\cite{cs-bryant}.
Thus, I assume most programmers do not really know how a linker works,
which is why, in addition to explaining the code of [[5l]],
I will also explain most of the concepts related to linking
in this book.
\n Scott's PL Pragmatics mention also linking, but chapter now on CD only.
%
This is a bit unusual in our \principia series.
Indeed, I usually assume the reader has read books introducing at least
the concepts and theories underlying the programs I present.
\l hmm actually might not be true anymore, except for Kernel and Compiler

Reading the \book{Assembler} is a requirement to understand
this book. Indeed, many data structures introduced
and fully explained in the \book{Assembler} are similar
to data structures used by [[5l]]. This is normal because
the assembler generates what the linker consumes.
Those data structures will be only quickly presented in this book.
The same is true for the object file format described at length
in the \book{Assembler}.


It is not necessary to know the ARM architecture to understand 
most of this book. 
\t maybe need know computer archi. sign, 2-complement, bitshift, arith shift
\t  byte/half-word and signs
For the machine code generation part though, in Chapter~\ref{chap:arm-codegen},
%dup: (and adapted) from Machine.nw
we highly recommend to print the excellent colorful ARM reference card
\url{http://re-eject.gbadev.org/files/armref.pdf}.
\l note that Intel syntax!!
It will help you to visually understand the binary format of the
instructions. This card is very helpful
to understand the code which does many bit manipulations to generate
different parts an ARM instruction.
%we recommend to read the \book{Emulator} to fully understand
%the semantics of some instructions.

\l man page? meh

\section{About this document}
#include "../docs/latex/About.nw"

\section{Copyright}
\input{../docs/latex/CopyrightPlan9Text}

\section{Acknowledgments}

I would like to acknowledge of course the author of
[[5l]], Rob Pike, 
who wrote in some sense most of this book.
\t really Pike?







\chapter{Overview}

%trans: %dup: Assembler.nw
Before showing the source code of [[5l]] in the following chapters, 
%toc:
I first give an overview in this chapter
of the general principles of a linker.
I also describe quickly the format of the object files 
generated by [[5a]] and [[5c]] 
and used as inputs by [[5l]], as
well as the format of the executables generated by [[5l]].
%dup: from Assembler.nw
I also define terms, explain how the code is organized, 
and more generally give the background necessary
to understand the code I will show later.

\section{Linker principles}

\n what
A {\em linker} is a program which takes as input multiple
{object files} and {combine} them to form an {executable}
as shown in Figure~\ref{fig:linker-overview}.
\n combine will be explained later
\t etymology of linker? why call that way? combine/concatenate/def-use =~ link

\begin{figure}[!]\centering
\begin{verbatim}
         +-----------+
         | assembler |
foo.s -->|   (5a)    |--> foo.5 --+
         +-----------+            |   +-----------+
                                  |   |  linker   |
         +-----------+            +-->|   (5l)    |--> 5.out
         | compiler  |            |   +-----------+
bar.c -->|   (5c)    |--> bar.5 --+
         +-----------+

Source files           Object files               Executable
\end{verbatim}
\caption{Linker inputs and output.}\label{fig:linker-overview}
\end{figure}
\n note that 5c generates directly obj files, does not need 5a


%dup: from Assembler.nw principles
An {\em object file} is really the simplest form of
a {\em module}. It packs code, data, and information
about {exported} and {imported} entities.
Object files are generated by {assemblers} and {compilers}.
\n explain here why need objects? separate compilation mentioned later.

An {\em executable} is a file containing machine instructions
as well as data. The code and data are stored in different
parts of the file called {\em sections} as shown in 
Figure~\ref{fig:linker-process}.
The size and location
of those sections are stored at the beginning of the file
in a part called the {\em header}. 
%
There are different kinds of headers
corresponding to different kinds of {\em executable formats}. In this
book we will focus on the [[a.out]] format which is very simple.
Section~\ref{sec:other-executable-formats} will present other
formats (including the popular ELF format used in Linux).

Thanks to the header, a part of the kernel called the {\em loader}
can know where the code and data are stored in the executable
file as well as its entry point. The loader, 
triggered by the [[exec()]] system call,
can then load (copy) in memory the different sections of 
the executable file and start executing its code.
\l actually man/1/8l uses term loader for 5l itself, hmm

\n how
Figure~\ref{fig:linker-process} gives an overview of the linking
process.
%
The linker first {\em concatenates} the code parts of the 
different object files together 
\l hence linker term?
to form the {\em code section} (the code parts [[C1]] to [[C4]]),
also known as the {\em text section}.
\n for 5l it actually transform them too, in machine instruction
It does the same for the data 
to form the {\em data section} ([[D1]] and [[D2]]).
\n for 5l this is the same
%
Then, it {links} the {\em uses} of {symbols} in those code (or data) parts,
e.g., the call to [[fbar]] in [[C1]],
to their {\em definitions} in possibly other code (or data) parts,
here the definition of [[fbar]] in [[C2]].
\l hence linker term again

%alt: multics segmentation? where each object can be in own space?

\begin{figure}[!]\centering
\begin{verbatim}
  lib.a------------+
  |                |
  |y.5------------+|
  |+--------------+|
  ||      D3      ||
  |+--------------+|                      +------------+
  ||      C5      ||                      |            |
  |+--------------+|--+                   |  Metadata  |
  |x.5------------+|  |                   |            |
  |+--------------+|  |                   X------------+260
  ||      C4      ||  |                  /|     D2     |
  ||TEXT util     ||  |     Data section| +------------+240
  |+--------------+|  |                  \|     D1     |
  +----------------+  |                   X------------+220
                      |                  /|     C4     |
   bar.5----------+   |   +-----------+ / |            |
   +--------------+   |   |  linker   | | +------------+200
   |      C3      |   +-->|    (5l)   |-+>|     C3     |
   |... CALL util |   |   +-----------+ | |.. CALL 200 |
   +--------------+   |                 | +------------+150
   |      D2      |---+                 / |     C2     |
   +--------------+   |    Code section|  |            |
   |      C2      |   |                 \ +------------+100
   |TEXT fbar     |   |                 | |.. CALL 100 |
   +--------------+   |                 \ |     C1     |
                      |                  \|... JMP 62  |
   foo.5----------+   |                   X------------+32
   +--------------+   |                   |   header   |
   |      D1      |   |                   |  (a.out)   |
   +--------------+   |                   +------------+0
   |... CALL fbar |---+
   |      C1      |
   |... JMP 30    |
   +--------------+

Input object files and                  Output executable
       library
\end{verbatim}
\caption{Linking process overview.}\label{fig:linker-process}
\end{figure}
\l actually in ARM it is BL not CALL and B not JMP
\l could be nice in final one to have arrow from CALL fbar to CALL 100

\subsection{Separate compilation}
\l and concatenation, separate and concatenate

One of the main operation of a linker is to concatenate parts
of different files together. 
\l actually in 5l less because generate also machine code
In fact, the program [[cat]] can be seen as a very primitive linker.
Instead of using a linker, we could use [[cat]] to concatenate
multiple source programs together and compile/assemble the resulting single
(big) file\footnote{
Assuming the compiler/assembler could from one source file
generate directly an executable.
}.
\l see bootstrapping from scratch, I mentioned that
\l MMIXAL actually neglect linker and assume linker = cat :) Same for fbas. 
\l Now that memory is cheap, can do it
%
As programs grow larger, this approach becomes inconvenient though.
Linkers and object files enable {\em separate compilation}
which in the long term saves lots of compilation time.
\l well for 5l/5a maybe less cos heavy part is machine codegen done in 5l
\l  other advantages? more language independent? cat foo.c foo.ml would not work
\l  but could also use assembly as the common format, cat foo_c.s foo_ml.s
\l modular analysis has same goal: does as much work as possible
\l  and cache this result


\subsection{Symbol resolution}
\n I didn't have subsections in Assembler.nw for its principles but I had a
\n tutorial later with many subsections. Here no tut so subsec in Principles.

Linking the uses of symbols to their definitions
is also called {\em resolving} the references to external symbols.
\n well for 5l/5a it is external and internal actually
%
The linker can do so because it has access to all the code (and data).
Once all the code (and data) parts are concatenated together, 
the final {addresses} of the different {entities} can be known. 
\l actually can need fixpoint on some archi, and in the end it is tricky
\l actually dynamic linking mean sometimes have still unresolved symbols
So, in Figure~\ref{fig:linker-process} the call to [[fbar]] in [[C1]]
can be transformed in a machine instruction to go to the
address 100 where the code of [[fbar]] resides (assuming [[fbar]]
was the first procedure in [[bar.5]] and so [[C2]]).
\n will see below that actually not 100 but 4196

% called link editor originally.

\subsection{Relocation}

Another important operation done by the linker is called {\em relocation}.
%
Remember from the \book{Assembler} that [[5a]] can resolve
the use of {labels} in jump instructions as both the definitions and uses of
those labels must be in the same file. 
\l in regular linker  same for calls to internal symbols? resolved but need
\l  to be relocated?
\n actually relocation is a kinda special case symbol resolution, could
\n  change 5a to not resolve labels and use fake private symbols for labels.
The instructions generated
for those jumps {assume} though that the code of the program was
loaded at the memory address 0. 
\l for the rest of the doc when I say memory address I mean virtual mem address
\l unless relative jump, but ARM can't do that
%alt: multics segmentation? or PIC.
For instance, to jump to
a label [[foo]] which happens to be defined just before the 30th instruction 
in a program [[foo.s]], 
the instruction [[JMP 30]] will be generated in the object file
\l because 5a use virtual PC
as shown in Figure~\ref{fig:linker-process} (see [[foo.5]]).
%
Once the code of object files are concatenated together and put
after the header, the linker must {\em relocate} 
the jump instructions
\l unless position independent code PIC in which case no need relocation
\l  ref to adv topic section?
to take into account the new {\em memory address origin}
where the object code containing the jump will be loaded.
For our previous example, the linker generated
the relocated instruction [[JMP 62]] in 
Figure~\ref{fig:linker-process} as [[C1]] is after the executable
header which uses 32 bytes.
\n will see below that actually not 62 but
\t if jmp relatif then no need, kinda PIC, but still actually need
\l again can have fixpoint issue, and relaxation hints (cf wikipedia linker)


\subsection{Architecture constraints TODO}

% There are general principles in linker, as we have seen,
% but also a lot specific to an architecture!
% Input and output first, object files, executable. specific. 
% Also constraints have implication on symbol resolution!

% resolving and relocating changes things! change addresses!
% this in turns change other things on some archi.

% CALL 100 whatif very far away? (well have 24 bits for offsets in
% ARM jmp, so not issue really)

% on x86 have small jump and far jump, and one faster than other
% but can work only if dest is not far.

% ARM has constraints on size of immediate, offsets, etc.
% when resolve and find out address of things, maybe can not use
% regular instr. Have to adapt! find tricks! intermediate instrs.
% but then change size of code section, so shift data, so 
% need reresolve!
\t generic term used in Levine book for that?

% which is why better do codegen in linker anyway no? linker need
% knowledge of architecture constraints!

% works for 5l because: 
% - offset for jmps is really big, so stable size of instr, and can use
%   that for pooling
% - address for globals are offsets to R12 and so stable
% - special case for setR12 where use absolute, possibly via pooling

\l other linkers do pooling? role of linker? who else can do that anyway?

%\subsection{Mutual dependency, fixpoint}


\subsection{Disk image versus memory image}
\label{sec:disk-image-vs-memory-image}
\l linker versus loader

Linkers and loaders are strongly connected, just like assemblers and linkers.
Indeed, one produces what the other consumes.
In fact, early linkers were also called loaders as they
were responsible for linking and loading in memory a program.
\l really? read Levine book introduction.
\l also linkage editor, etc.
\n actually man/1/8l uses the term loader, but I think they are confused.
\n  Linkers and Loaders says the same thing than me. 5l is not a loader.
It is important to note though, that
the {\em disk image} of an executable generated by the linker
does not necessarily match exactly the {\em memory image}
of the program when loaded in memory by the loader.
\l for instance BSS is not in disk image (but BSS explained later)
An offset in the file does not necessarily correspond to the same
offset in memory, even though we assumed this was the case
in Figure~\ref{fig:linker-process}.

Under \plan, the header and code section are actually not loaded
at the memory address 0 but instead after
the first {page} at 4096 (4K). Indeed, the first page
in the {virtual address space} of a program
is reserved by the kernel and marked specially to generate
{faults} when accessed. This helps for instance to
track {null pointer bugs}.
\t same way data section starts at page boundary because will have different
\t  protection (text might be read-only?) or because text shared but not
\t  data when have multiple time the same process instance (KImage in Kernel.nw)
\t but in file, the text and data follow each other. The linker though
\t  when resolving address assume the data will be loaded at a page boundary.
%
So, the instructions [[CALL fbar]] and [[JMP 30]]
in Figure~\ref{fig:linker-process}
would be actually transformed respectively
in the resolved [[CALL 4196]] and relocated [[JMP 4158]] 
instructions with [[5l]] under \plan.
\n 4128 because header
\l while still refering to machine code stored at offset X in the executable
\l say that could actually remove header when loaded in mem and so CALL 4164
\t notion of Text origin? actually header is 4096
\t notion of disk address vs (virtual) memory address

\l FIGURE? where see disk image vs memory image? file offset vs memory offset?
\l  and shift lines? see also INITRND, 
\l talk about pages, because different properties for code and data 
\l  (the case with 9?)

\subsection{Libraries}
\n talked here about [[cat]] and separate compil but better in different section

Object files can be concatenated together to form
{\em libraries} using a tool called [[ar]] (for archive).
\l which really is kinda cat, and also really kinda tar (tape archive)
The linker can also take as input a set of libraries as shown
in Figure~\ref{fig:linker-process} with [[lib.a]].
%
Those libraries are convenient for programmers because they
just have to remember the name of one file, e.g., [[libc.a]], instead
of a possible long list of object files.
\l other advantages?

Moreover, the linker can also take care of including only
the object files in the library that matters, that is the object files
containing code or data referenced by the other object files
passed on the command line.
For instance, in Figure~\ref{fig:linker-process} the linker
decided to include in the executable the code of [[x.5]] ([[C4]]), which
is part of [[lib.a]], 
because it contains the definition of a procedure [[util()]] which
is mentioned in the object file [[bar.5]]. 
\l well need fixpoint though, need take care
It did not include the code from [[y.5]] though because such code 
would be anyway {\em dead code} in the executable. 
Such code would waste disk and memory space.
\l well lazy code loading so maybe ok
\l other optimisations? fine grained dead code?
\l static detection! false positive? dynamic code? relation to -linkall ocaml?

\subsection{Static and dynamic linking}

The linking we described until now is completely {\em static}.
All the symbol references must be known at {\em link-time}
in which case they can be fully resolved to generate an executable.
This requires that all the object files (or libraries)
containing those symbols get passed to the linker on the command line.

Another popular form of linking is called {\em dynamic linking}.
\l actually more popular, but bad
Dynamic linking blurs the line between the responsibilities 
of the linker and loader.
\l dynamic linking vs dynamic loading? do both? or maybe not.
Indeed, with dynamic linking an executable can still contain
unresolved references to external symbols; the loader
at {\em load-time} must, before loading the program in memory,
link additional objects.
\t also can be in the hand of the programmer, dynlink()
\t  can link after being loaded. at {\em run-time}
\t dynamic linking vs dynamic loading? relink and load, or load and reload?
\t dynamic code is important? like living cell organism, self modifiable!
\l  (well but can still modify own source code, call 5a/5c/5l and exec())

\plan opted mainly for static linking and so [[5l]] is mainly
\l mainly is vague, ADYN enough for dynamic linking?
a static linker. 
Static linking is far simpler than dynamic linking and is arguably 
also better in many respects.
\l refs? static linking reloated? dll hell
I will delay the discussions on dynamic linking to 
Section~\ref{sec:dynamic-linking}.
\l can separate. Loader is in kernel.
\l Linker setups things for loader, code section, data section, etc
\l and loader is pretty simple, just load/copy (or actually lazy load/copy).
\l Also compute textsize, datasize, etc and adjust addresses.

\t dynamic linking and shared libraries are different? I think so.

\bigskip
For more information on the principles of linkers and loaders 
\l and dynamic linking?
we recommend to read {\em Linkers and Loaders}~\cite{ll} which
is entirely dedicated to the topic.



\l many post on linkers or executables, show it is a missing part of curriculum:
% - http://eli.thegreenplace.net/2012/08/13/how-statically-linked-programs-run-on-linux/
% - http://dbp-consulting.com/tutorials/debugging/linuxProgramStartup.html
% - http://www.lurklurk.org/linkers/linkers.html (for C++ programmers)
% - ian taylor posts http://www.airs.com/blog/archives/38
%   TOC here: http://lwn.net/Articles/276782/
% - https://github.com/0xAX/linux-insides/blob/master/Misc/linkers.md
%   and http://0xax.gitbooks.io/linux-insides/content/Misc/linkers.html
%   pretty good use of nm, objdump, readelf, etc
% - many on format of ELF header (referenced in Adv Topics section)

%\subsection{Summary}
\l put back essential steps? read object and lib, concatenate, 
%   resolve and relocate, and finally generate. but explained in soft archi?
\l which roughly correspond to different chapters

\section{[[5l]] command-line interface}

The command line interface of [[5l]] is pretty simple:
\begin{verbatim}
$ 5l
usage: 5l [-options] objects
$ 5l foo.5 bar.5 lib.a
$ ./5.out
\end{verbatim}

Given the set of {object files} [[foo.5]] and [[bar.5]],
and a {library} [[lib.a]], 
[[5l]] outputs an executable file called [[5.out]].
\n look for _main. But explained later.
%
You can change this default behaviour by using the [[-o <outfile>]] option.

The default {executable format} is [[a.out]], a classic \unix format,
\t cite? RFC? assembler (and linker) output.
but this can be changed with the [[-H<num>]] option ([[H]] for header)
as explained in Section~\ref{sec:choice-exec-format}.
\l see adv topic for more e.g., ELF.
You can also change the entry point of the program with [[-E<funcname>]] 
which by default is [[_main]] 
as explained in Section~\ref{sec:choice-entry-point}.
\l also have -l which suppress entry point?
Other options related to debugging will be described later
in Appendix~\ref{chap:debugging-appendix}.
\n actually next section introduces a few

%real-world:
Executables generated by C compilers in \unix-like operating systems, 
e.g., [[gcc]] under Linux, are usually called by default [[a.out]].
\l same name than format. confusing?
\l even if ELF format actually
\l why a.out? a? assembler output?
But, under \plan, for the same reason ARM object files use the [[.5]] filename
extension and not [[.o]], ARM executables are called [[5.out]] not [[a.out]].
This is more convenient in an operating system supporting 
multiple architectures at the same time.
That way, you can have in the same directory an ARM executable
[[5.out]] and an x86 executable [[8.out]] without any name conflict.
\l why not lib.5a then? solve conflict via /arm/lib/... /x86/lib/...


Another important linker option, [[-T<num>]], allows to change the
{memory address origin} of the code section ([[T]] for text section).
%dup: from overview/principles
\label{sec:kernel-load-4096}
In \plan the default value for this address is 4128.
Indeed, the loader in the kernel
loads executables after the first page (4096), and includes
the header which is using 32 bytes, so the text section
will start at the memory address 4128. 
The machine code generated for the jumps and calls
must then assume the code will be loaded at 4128.
%
You can also change the memory address origin of the data section
as explained in Section~\ref{sec:choice-exec-format}.
%
Those options are almost never used by programmers, but they
are necessary for producing special executables such as
kernels or boot loaders as we will see in the \book{Kernel}.
Indeed, those binaries will be loaded (by the bootstrapping process
or firmware) at special memory addresses, 
e.g., 0x80000000 for the ARM \plan kernel, 0x7c00 for an x86 bootloader.

Another set of options are used to manage libraries,
which are really files encapsulating a set of object files,
\l like tar, actually ar means archive
and will be introduced later in Chapter~\ref{chap:loading-libraries}.

\l also dynamic related options, -x -u

\l env: $ccroot
%$


\section{[[hello.5]] and [[world.5]]}
\label{sec:hello-world}

%trans:
In this section we adapt the [[helloworld.s]] example of the \book{Assembler}
%toc:
to illustrate the linking process with a concrete example. 
The goal is also to learn how to use the debugging options of [[5l]] as well
as tools such as [[nm]].
\l why? because useful to debug issues, to find where symbols are defined
\l and indeed to better understand indeed linking process

\subsection{The source files}
\label{sec:hello-world-source}

I split the original source file [[helloworld.s]] 
in two files [[hello2.s]] and [[world.s]].
I also use the C library functions [[fprint()]]
and [[exits()]] instead of using directly the [[PWRITE]] and [[EXITS]] 
system calls:

<<linkers/5l/tests/hello2.s>>=
TEXT main(SB), $8
        /* fprint(1,&hello) */
        MOVW $1, R0
        MOVW $hello(SB), R1
        MOVW R1, 8(R13)
        BL fprint(SB)
        /* exit(0) */
        MOVW $0, R0
        BL exits(SB)
@
%$
\n call libc via fprint/exits so != Assembler.nw, and use main not _main
\n (cant call print cos pointer func so more complex) 
\l use SP instead of R13? 
\l weird but using only stack and not R0 at all also works


<<linkers/5l/tests/world.s>>=
GLOBL   hello(SB), $12
DATA    hello+0(SB)/8, $"hello wo"
DATA    hello+8(SB)/4, $"rld\n"
@
%$

If you do not understand the code, or the calling
conventions, read the \book{Assembler}.
\l plus 8 cos 4 for saved R14, then 4 for first arg but R0, so 8 for 2nd arg
%
Symbol definitions and uses are now spread over different files:
the [[hello]] global is defined in [[world.s]] but used in [[hello2.s]].
Moreover, the [[fprint()]] and [[exits()]] functions are defined in 
source files of the C library but used in [[hello2.s]].

\subsection{The linking command}

To compile the previous program do:
\begin{verbatim}
$ cd /tests/5l
$ 5a hello2.s -o hello.5
$ 5a world.s
$ 5l hello.5 world.5 /arm/lib/libc.a -o hello
$ ./hello
hello world
\end{verbatim}

The main difference with the commands shown in 
Section~\ref{sec:getting-started} is the use of the C library,
compiled here for the ARM architecture: [[/arm/lib/libc.a]].
We will see in chapter~\ref{chap:loading-libraries} other
ways to link libraries.

\subsection{Inspecting objects with [[nm]]}

You can use the tool [[nm]] to get the set of symbols defined or
referenced in object files (this set is also called the [[n]]a[[m]]e list):

\begin{verbatim}
$ nm hello.5
 U exits
 U fprint
 U hello
 T main

$ nm world.5
D hello
\end{verbatim}
\n note that if call main in hello2.5, you will not get a U main
\n even though in practice intra-file calls are not resolved by 5a

[[nm]] can also be used on libraries:

\begin{verbatim}
$ nm /arm/lib/libc.a | grep fprint
...
fprint.5: T fprint
...
$ nm /arm/lib/libc.a | grep exits
...
atexit.5:         T exits
...
\end{verbatim}

[[U]] stands for undefined,
[[T]] for text (a defined procedure), and
[[D]] for data (a defined global).
%
From the previous commands we can see that [[hello.5]] has three
{undefined symbol} references, including [[hello]] which
is a global data defined in [[world.5]]. 
%
The job of the linker is then to link those definitions to their uses.

There are other kinds of symbols and so other single letter codes
used by [[nm]]. Those codes as well as the source of
[[nm]] will be described fully later in Appendix~\ref{sec:nm-code}.

\l nm is actually using libmach, crachhdr, etc, generic API for object manip
\t put libmach/5obj.c in this book?
\l nm is actually pretty useful in general, to solve linker issues, nm | grep!

\subsection{Dumping objects with [[5l -W]]}
\label{sec:dump-objects}

Another way, more complete, to inspect the content of object files is to use
the debugging option [[-W]] of [[5l]]. The effect of the option
is to ``dump''
the instructions of the object files passed on the command line:
\l close to disassembler, but actually easier
\l disassembler is actually in libmach and used by db

\begin{verbatim}
1   $ 5l -W hello.5 world.5 /arm/lib/libc.a
2   ...
3   	ANAME	main                        
4   (1)	TEXT	{main}00000+0(SB),$8        
5   (4)	MOVW	$1,R0                       
6   	ANAME	hello                       
7   (5)	MOVW	${hello}00000+0(SB),R1      
8   (5)	MOVW	R1,8(R13)                   
9   	ANAME	fprint                      
10  (6)	BL	,{fprint}00000+0(SB)            
11  (9)	MOVW	$0,R0                       
12  	ANAME	exits                       
13  (9)	BL	,{exits}00000+0(SB)             
14  (10)	END	,                           
15  ...
16  	ANAME	hello
17  (1)	GLOBL	{hello}00000+0(SB),$12
18  (2)	DATA	{hello}0000c+0(SB)/8,$"hell"
19  (3)	DATA	{hello}0000c+8(SB)/4,$"rld\n"
20  (4)	END	,
21  ...
22      ANAME	_main
23  (8)	TEXT	{_main}00000+0(SB),R1,$802
4      ANAME	setR12
25  (10)MOVW	${setR12}00000+0(SB),R12
26      ANAME	_tos
27  (11)MOVW	R0,{_tos}00000+0(SB)
28  ...
29  (21)BL	,{main}00000+0(SB)
\end{verbatim}
\n output was copy pasted from the running of kencc/5l, not our 5l
\n for dollar hello we should remove the (SB)? NO! it can use R12!
\n  but it will do R12 plus 00014 no? yes because offset is small.
\l a bit weird just have "hell"
\t why those lineno? seems wrong line number. BUG?
\l remove those comma? 
\l very close to assembler, indeed object file is just serialized asm source
%pad: I changed the format to use {} and to show the value (here 00000) of syms

The first two fragments show the instructions of [[hello.5]],
from Line 3 to Line 14,
and [[world.5]], from Line 16 to Line 20.
The output is very similar to the assembly sources of
Section~\ref{sec:hello-world-source}. 
%dup: from intro/5l (itself dup from Assembler.nw)
This is normal since under \plan an object file is essentially
the serialized form of the abstract syntax tree of an assembly source.
%
See the \book{Assembler} if you do not
understand the {opcodes} or {pseudo-opcodes} such as [[ANAME]].

Symbol references are enclosed in braces, e.g., [[{main}]] Line 4,
followed by the {\em symbol value} in hexadecimal, e.g., [[00000]] Line 4.
The symbol value corresponds normally to the 
resolved memory address of the symbol.
But, almost all those values and addresses are null 
when using [[-W]] because the option dumps instructions
while the object files are read into memory, at the beginning, and so
when the linker has not yet resolved any of those symbols.

Once a global has been declared, e.g., [[hello]] Line 17,
the value of its symbol is then (ab)used to store its size,
here [[0000c]] (12) Line 18.
%
Later we will see that the symbol value will contain the resolved address
of the global.
% as an offset to the start of the Data section       but too many

\label{sec:explain-_main}
The last fragment, starting at Line 22,
shows the instructions of a procedure called [[_main]].
%dup: (and adapted) from Assembler.nw
The linker [[5l]] is looking by default for such a procedure
for the {entry point} of the executables it generates
(unless the [[-E]] option is used), which is why it is included.
\t hmm but dumping option could dump everything of libc.a no? maybe
\t  delay discussion about _main to next section with -a?
\t  just do 5l -W hello.5 world.5 here? anyway can see error msg
\t  with _main which we can link to next section
%
The reason for a default called [[_main]], and not [[main]],
even though the entry point of C programs is [[main]],
is because [[_main()]] is normally a procedure defined in the C library.
This procedure, written in assembly, does some core initializations
and then calls [[main()]], as shown by the last dumped
instruction Line 29.
%
[[5l]] is usually called to link C programs, and
the C compiler [[5c]] assumes a few core initializations has
been done before the call to [[main()]], hence the choice
of [[_main]] as the default entry point.
%real-world: 
% actually gcc transforms main in _main, so startup in Linux is ?? 

For more information on [[5l -W]] see Appendix~\ref{sec:debugging-loading}.

%real-world:
\t readelf? objdump? 

\subsection{Debugging machine code generation with [[5l -a]]}
\label{sec:_main-set-r12}

You can also display the generated machine code by using
the debugging option [[-a]] of [[5l]]:

\begin{verbatim}
1   $ 5l -a hello.5 world.5 /arm/lib/libc.a
2 
3  00001020:          (1) TEXT {main}01020+0(SB),$8
4  00001020: e52de00c (1) MOVW.W R14,-12(R13)
5  00001024: e3a00001 (4) MOVW $1,R0
6  00001028: e59f1884 (5) MOVW ${hello}00014+0(SB),R1
7  0000102c: e58d1008 (5) MOVW R1,8(R13)
8  00001030: eb0000bb (6) BL ,{fprint}01324(BRANCH)
9  00001034: e3a00000 (9) MOVW $0,R0
10 00001038: eb00009a (9) BL ,{exits}012a8(BRANCH)       
11
12 0000103c:          (8) TEXT {_main}0103c+0(SB),R1,$80
13 0000103c: e52de054 (8) MOVW.W R14,-84(R13)
14 00001040: e59fc870 (10) MOVW ${setR12}00ffc+0(SB),R12
15 00001044: e50c0fd0 (11) MOVW R0,{_tos}0002c+0(SB)
16 ...
17 00001068: ebffffec (21) BL ,{main}01020(BRANCH)
18 ...
19
20 000012a8:          (915) TEXT {exits}012a8+0(SB),R1,$16
21 000012a8: e52de014 (915) MOVW.W R14,-20(R13)
22 ...
23
24 00001324:          (874) TEXT {fprint}01324+0(SB),R0,$20
25 00001324: e52de018 (874) MOVW.W R14,-24(R13)
26 ...
27
28 00006b50: e49df03c (890) MOVW.P 60(R13),R15
\end{verbatim}
\n this was also done via kencc/5l
\t .P and .W later


The first column contains the memory address
in hexadecimal where the code will be loaded (e.g., [[01020]] Line 4).
%
Then comes the 4 bytes in hexadecimal of the generated ARM instruction
(e.g., [[e52de00c]]). 
Indeed ARM uses fixed-length instructions of 4 bytes.
%
The third column contains the (global) line number
in parenthesis of the instruction in the original 
source file (assembly or C)\footnote{
See Section~\ref{sec:lineno} for more information about line numbers.
}.
%
Finally, the last column displays the disassembled instruction.
\l actually not really disassembled
As opposed to the previous section, the symbol values 
are not null anymore and contain now the resolved memory address
of the symbol, e.g., [[01324]] Line 8 for the [[fprint]] symbol.
%
The output contains also the [[TEXT]] {pseudo-instructions} to better
see the procedure boundaries, e.g., Line 3 and Line 12. 



The first instruction Line 4 starts at [[01020]] which is equal to 4128.
%dup: from overview/principles and overview/command-line
Indeed, as said previously in Section~\ref{sec:kernel-load-4096},
the kernel loads executables after the first page (4096)
and includes the [[a.out]] header which is using 32 bytes. Thus,
the code starts at the memory address 4128.

\l Note also code concatenated in section, no middle DATA of hello here

Note that even though it looks like there are two instructions
at [[01020]], with Line 3 and Line 4, the first instruction ([[TEXT ...]])
is a pseudo-instruction which got transformed by the linker
in the ARM instruction Line 4 ([[MOVW.M ...]]).
\t lots to explain here, 8 vs 12, MOVW.M which does multiple things.
Indeed, [[TEXT]] is an assembly directive introducing a symbol,
here [[main]], and symbols are {resolved} in 
{concrete addresses} by the linker. The generated machine code
contains only concrete addresses, no symbols (except for
debugging purposes as explained in Chapter~\ref{chap:debugging}).
%
So, the reference to [[main]] Line 17 is resolved to the concrete
address [[01020]].
In the same way, the calls to [[fprint]] and [[exits]]
Line 8 and 10 are fully resolved in respectively
the memory addresses [[01324]] (Line 25)  and [[012a8]] (Line 21).

\t discussion about _main? why included? 
\t  say that 5l includes only code in libc.a that are needed. so
\t  make sense exits and fprint, but _main?

The symbol value of [[hello]] Line~6 is [[00014]] which
seems incorrect. Indeed, data should be stored after
the code section and so the resolved address of [[hello]] should
be beyond [[06b50]] (the address of the last instruction Line 28).
%dup: section just before
But, the symbol value for data symbols contains the resolved address
of the symbol as {\em an offset to the start of the data section}.
The rational for this decision will be explained later
in Chapter~\ref{chap:resolving}.
Thus, the final address of [[hello]] is [[014 + INITDAT]]
where [[INITDAT]] is the address where starts the data section.
\t so if really disassemble e59f1884? get what? 7014? or BIG-7014?
\l actually see also initialisation of R12 with  very tricky
% MOVW	${setR12}00ffc+0(SB),R12
% which really is   MOVW    0xffc(R12=0), R12
\t put actual machine code! cos what is shown is not really machine code.
\t  the disassembly is original object instruction.
\t  real machine instruction is  
\t     ADD 14, R12, R1        (Well actually because of BIG it's not that)
\t  or
\t     LDR xxx(R15), R1  with Pool.


\l 6000 = ? just for including fprint and exits, hmmm

For more information on [[5l -a]] see
Appendix~\ref{sec:debugging-generated-code}.

\subsection{Inspecting executables with [[nm]]}
\label{sec:nm-executable}

[[nm]] can also be used on executables. In that case [[nm]] not only displays
the list of symbols, it also displays their addresses (in hexadecimal)
when loaded in memory. 
Here it is used with the [[-n]] option to sort by addresses:

\begin{verbatim}
1 $ nm -n 5.out
2     1020 T main
3     103c T _main
4     ...
5     110c T _div
6     1168 T _mod
7     ...
8     12a8 T exits
9     ...
10    1324 T fprint
11    ...
12    6b58 T etext
13    7000 d onexlock 
14    7000 D bdata    
15    7010 D argv0    
16    7014 D hello    
17    7020 d _exitstr 
18    ...             
19    7940 D edata    
20    7b44 B onex     
21    7c50 B end      
22    7ffc D setR12   
\end{verbatim}
\n this was also done via kencc/nm (actually inm)
\l why etext not 6b54?

We find the same resolved memory addresses we saw in the previous
section with [[5l -a]], e.g., [[12a8]] for [[exits]] Line 8,
or [[1324]] for [[fprint]] Line 10.

We can also now see the addresses of the data symbols.
[[hello]] Line 16 is at the address [[7014]]. The data
section starts at [[7000]] as indicated by the 
{\em special symbol} [[bdata]] (begin data) Line 14. 
So, [[INITDAT]] is [[7000]]
which confirms that the address of [[hello]] is indeed
[[14 + INITDAT]] ([[7014]]) as mentioned in the previous section.
\l but still a lot to explain because generated code is not that too,see setR12

The symbol after [[hello]] is [[_exitstr]] Line 17
at address [[7020]]. This confirms that [[hello]] is using 
12 bytes ([[0x7020]] - [[0x7014]] = [[0xc]] = 12) 
as said in the source of [[world.s]]
in Section~\ref{sec:hello-world-source}.

\t talk about _div, _mod,  because called by fprint
\t  to linker include more functions recursively. 

The linker defines a set of special symbols:
[[etext]] (end text) Line 12,
[[bdata]] (begin data) Line 14,
[[edata]] (end data) Line 19, and finally
[[end]] Line 21.
Those symbols are used only for their addresses and
allow a form of {\em reflection} on the structure
of the executable and its sections as explained
in Section~\ref{sec:special-symbols}.

Another special symbol, [[setR12]] Line 22
plays a complex role in [[5l]]. This symbol is notably
used by [[_main]] as indicated by the output of [[5l -W]]
and [[5l -a]] we saw in the previous sections.
Its role and its relationship with the {pseudo-register}
[[SB]] will be explained later in Chapter~\ref{chap:resolving}.
%~\ref{sec:sb-r12}.

\l _existstr 
\l small d means private symbol B means unitialized (BSS)

\l can also use db (or 5i) to inspect executable.

%trans:?
% how better view of objects and executables? will refine below?


\section{ARM architecture TODO}
% constraints

% little endian

\t maybe can do this section after understand better code generation

% Object instruction do not match exactly ARM instruction.
% Virtual, pseudo, etc but also:
% constraints on immediate constants, offsets

% register R0 to R15, 4 bits.

% cite ARM ref manual.
% Could cite also ARM Assembly Language: Fundamentals techniques,
%  which talks about literal pools, rotation scheme, etc.

\subsection{Immediate constant range}

% ADD I, R1, R2

% 12 bits. Clever trick for encoding, but still limited.

% so how do? 
% can use DATA. (but then can have issue as we will see next section)
% REGTMP
%alt: could use MUL :) 
%alt: can also use WORD in text, not far. called pooling, but talk below


\subsection{Offset range}

% different addressing mode in Assembler, indirect, ...
% but in the end can be reduced to indirect with offset.
% xxx(R1)

% 12 bits (a page), and sign.
% But again if big offset how do?
% - reduce offset, and add base, but if big number base too? :) 
%   in fact for ADD before, use DATA, but $bigcst(SB) can be far away too.
% => WORD!
% called pooling.


% special case SB, hello+whatever(SB), $hello+whatever(SB).
% here? or mv later? at least need give idea on how translate $xxx(SB)
%  and xxx(SB)
% show actual code of 
%  MOVW $hello(SB), R2    ==>   ADD offset1, R12, R2    or LDR offset2(R15),R2
%   (and ADD itself can use REGTMP)
% and
%  MOVW hello(SB), R2     ==>   LDR offset(R12), R2  or LDR offset3(R15),RTMP;
%   LDR RTMP, R2

\subsection{Jump range}

%  BL foo(SB)

% 24 bits, and actually implict +8 (hence later -8 in code).
% because useless loop over yourself and useless jump next (+4)
% so B_arm 0  = jmp + 8


%\subsection{Code pooling}
% big number bootstrap?
% so if address of DATA too far too? :) can boostrap  with PC and WORD!
%alt: could also use ADD, MUL, whatever to produce big number?

\section{Input object format}

The object file is now the input, as opposed
to the \book{Assembler} where it was the output.
%
The format of ARM object files is actually fully described
in the \book{Assembler} so we will not repeat
those explanations here.
%
Section~\ref{sec:object-format} contains a figure
summarizing this format though, which will be useful
to understand the code of Chapter~\ref{chap:loading-objects}
which loads object files.

Section~\ref{sec:dump-objects} contains the {dump}
of a few object files and shows, as we said previously, that
%dup: from intro/5l, overview, etc, maybe too much?
an object file is essentially
the serialized form of the abstract syntax tree of an assembly source.


\l could take figure in Assembler.nw and add the ANAME and AHISTORY?
\l or put concrete values everywhere?
\l 5l -W also show format a bit

\section{Output executable format, [[a.out]]}
\label{sec:exec-format}

\plan is using the very simple [[a.out]] executable format.
\t ref? rfc?
\l history? why called a.out? ok name of executable but why a? assembler output?
So, [[5l]] by default generates executables in this format.
This can be changed with the [[-H]] option. Other formats
will be described in Section~\ref{sec:other-executable-formats}

The file [[include/exec/a.out.h]] contains a formal
description of the [[a.out]] header:

<<struct Exec>>=
// a.out header
struct	Exec
{
    long	magic;		/* magic number */

    long	text;	 	/* size of text segment */
    long	data;	 	/* size of initialized data */
    long	bss;	  	/* size of uninitialized data */

    long	syms;	 	/* size of symbol table */

    // virtual address in [UTZERO+sizeof(Exec)..UTZERO+sizeof(Exec)+text]
    long	entry;	 	/* entry point */ 

    long	_unused;
    // see a.out.h man page explaining how to compute the line of a PC
    long	pcsz;		/* size of pc/line number table */
};
@
\t big-endian encoding!? check in Debugger?
%dead: _unused was actually:
%  // used only by 68020, spsize set to 0 for 8l TODO remove at some point!
%  long	spsz;		/* size of pc/sp offset table */

Figure~\ref{fig:executable-format} illustrates the format of
[[a.out]] executables.
%
An [[a.out]] header is made of 8 [[long]]s (32 bytes) used
as follows:
\begin{itemize}
\item The first four bytes in [[Exec.magic]] contains a 
{\em magic number} identifying the file
as an [[a.out]] executable as well as an ARM executable.
This magic number is recognized
by tools such as [[file]] and by the kernel loader
which will load only files having this magic number {\em signature}.

\item Then comes the size of the text and data sections. The format
of the ARM machine instructions in the text section will be
described in Chapter~\ref{chap:arm-codegen}.

\item [[Exec.bss]] contains the size of the BSS section which
corresponds to {uninitialized data}. 
\t BSS means?
The actual values for those data is not defined in the executable, 
as opposed to the data section, but the loader must
still reserve space in memory for those data.
The following C code shows which section will be used
depending on the declaration style of a variable:

\begin{verbatim}
int global = 1; // Data section
int another;    // BSS section
\end{verbatim}

\t but in \plan BSS is zeroed!! more deterministic programs. See Kernel
\t  or Emulator

\item [[Exec.syms]] and the {executable symbol table} will be discussed in 
Chapter~\ref{chap:debugging}.

\item [[Exec.entry]] contains the memory address of the entry point
of the program. This address is used by the kernel
loader to start the program. It is usually the address
of the [[_main]] procedure of the C library (unless
the [[-E]] option is used). 
%
So, for the [[hello]] executable of the previous section,
the value of the entry point is [[0x103c]].
%
The entry point can also be the
address of the [[_mainp]] procedure if profiling
is enabled as explained in Chapter~\ref{chap:profiling}.

\item Finally [[Exec.pcsz]] and the line table will be discussed in 
Chapter~\ref{chap:debugging}.

\end{itemize}


\begin{figure}[!]\centering
\begin{verbatim}
     +--------------+
     |     Line     | ^
     |    table     | |<-------+
     |              | v        |
     +--------------+          |
     |    Symbol    | ^        |
     |    table     | |<------+|
     |              | v       ||   +--------------+ +32
     +--------------+         |+---|  line size   |
     |              | ^       |    +--------------+ +28
     |     Data     | |<-----+|    |              |
     |              | v      ||    +--------------+ +24
     +--------------+        ||    | entry point  |------+
     |              | ^      ||    +--------------+ +20  |
     |     Code     | |      |+----| symbol size  |      |
     |    (Text)    | |      |     +--------------+ +16  |
     |              | |<----+|     |   bss size   |      |
+---->              | |     ||     +--------------+ +12  |
|    |              | v     |+-----|  data size   |      |
|+32 +--------------+       |      +--------------+  +8  |
|    |    Header    |       +------|  text size   |      |
|    |   (a.out)    |              +--------------+  +4  |
|    |              |              |    magic     |      |
|  0 +--------------+              +--------------+   0  |
|                                                        |
+--------------------------------------------------------+
     a.out executable                a.out Header
\end{verbatim}
\caption{[[a.out]] executable format.}\label{fig:executable-format}
\end{figure}

\l data just after code, but when loaded in mem, at round?
\l and then from lineno you can get file/line thx to Hist?

Note that the [[Exec]] structure is actually not used by
the code of [[5l]] for {\em writing} the header.
Instead, the function [[asmb()]], which
we will see in Section~\ref{sec:gen-executable}, outputs
directly the bytes of the header with a series
of calls to the [[lput()]] (for out[[put]] [[long]])
utility function.
\t actually portable format because lput is long put big-endian
%
The [[Exec]] structure is used though in programs 
which are {\em reading} the header of executables.
There are many programs which need to understand the
format of executables, e.g., the debugger [[db]], the
profiler, and small utilities like [[nm]]. Under \plan, all those
programs use a common library called [[libmach]] which
defines [[Exec]] as well as many other data structures and functions.
Appendix~\ref{chap:linker-related-programs} discusses the
[[libmach]] interface and the code of utilities such as [[nm]],
but the code of [[libmach]] itself will be shown in the
\book{Debugger}.

\t no dynlink notion in a.out? need ELF for that?





%\section{Calling conventions}

% memory model when loaded in memory? need that? seems more cc material
% frame format?
%  parameters (including space for first arg even if put in R0)
%  saved PC (from REGLINK when not a leaf procedure)
%  locals
% saved SP? assumer caller saves/restores registers including SP?

% When want to call a procedure, need to save current place,
% so do BL for branch and link where a special register
% holds a value. Then need to save this value in a stack
% (if it's not a leaf procedure).

% autosize = p->to.offset + 4; // locals
% + 4 = saved PC (REGLINK from BL)

% FP vs SP? SP seems not equal directly to R13!


\section{Code organization}

%dup: (and adapted) from Assembler.nw
Table~\ref{tab:code-orga} presents short descriptions
of the source files used by [[5l]], together with
the main entities (e.g., structures, functions, globals) the file defines,
and the corresponding chapter in this document in which the code
contained in the file is primarily discussed.
\n sorted by chapters, make more sense than sorted by dir


\begin{table*}[tbh!]
\begin{center}
\begin{tabular}{lcllr}
\toprule
{\bf Function}  & {\bf Chapter} & {\bf File} & {\bf Entities} & {\bf LOC} \\
\otoprule
data structures and constants            & \ref{chap:core-ds}            & [[l.h]]         & [[Sym]] [[Section]] [[Instr]]                                             & 471 \\% Adr Mark Auto Buf Headtype % like a dat.h and fns.h
globals                                  & \ref{chap:core-ds}            & [[globals.c]]   & [[hash]] [[pc]] [[firstp]] [[datap]] [[textsize]] [[datsize]] [[bsssize]] & 168 \\ %pad: I created this file
entry point                              & \ref{chap:main}               & [[main.c]]      & [[main()]]                                                                & 301 \\ %pad: I created this file, also undef could be in check.c
executable generation                    & \ref{chap:main}               & [[asm.c]]       & [[asmb()]]                                                                & 222 \\ %pad: asm.c -> executable.c?
data section generation                  & \ref{chap:main}               & [[datagen.c]]   & [[datblk()]]                                                              & 245 \\ %pad: I created this file

\midrule

loading objects                          & \ref{chap:loading-objects}    & [[obj.c]]       & [[ldobj()]]                                                               & 834 \\
loading libraries                        & \ref{chap:loading-libraries}  & [[lib.c]]       & [[loadlib()]]                                                             & 188 \\ %pad: I created this file

building the code instructions graph     & \ref{chap:resolving}          & [[pass.c]]      & [[patch()]]                                                               & 372 \\ %pad: pass.c -> graph.c?
rewriting virtual opcodes                & \ref{chap:resolving}          & [[noop.c]]      & [[noops()]]                                                               & 415 \\ %pad.c: noop.c -> rewrite.c?
laying out the code and data sections    & \ref{chap:resolving}          & [[layout.c]]    & [[dotext()]] [[dodata()]]                                                 & 432 \\ %pad: I created this file

\midrule

ARM code-generation data structures      & \ref{chap:arm-codegen}        & [[m.h]]         & [[Optab]] [[Oprange]] [[Operand_class]]                                   & 159 \\ %pad: I created this file
ARM opcodes lookup table                 & \ref{chap:arm-codegen}        & [[optab.c]]     & [[optab]]                                                                 & 293 \\
ARM opcodes lookup function              & \ref{chap:arm-codegen}        & [[span.c]]      & [[oplook()]] [[buildop()]]                                                & 670 \\    %pad: span.c -> oplook.c?
ARM instructions generation              & \ref{chap:arm-codegen}        & [[codegen.c]]   & [[asmout()]]                                                              & 1344 \\ %pad: I created this file

\midrule

debugging support                        & \ref{chap:debugging}          & [[debugging.c]] & [[asmsym()]] [[asmlc()]]                                                  & 244 \\ %pad: I created this file       
location information                     & \ref{chap:debugging}          & [[hist.c]]      & [[addhist()]]                                                             & 55 \\ %pad: I created this file
profiling support                        & \ref{chap:profiling}          & [[profile.c]]   & [[doprof1()]] [[doprof2()]]                                               & 264 \\ %pad: I created this file, profile.c -> profiling.c

\midrule
dynamic linking and import/export tables & \ref{chap:advanced}           & [[dynamic.c]]   & [[asmdyn()]]                                                              & 412 \\ %pad: I created this file
float instructions                       & \ref{chap:advanced}           & [[float.c]]     & [[ieeedtof()]]                                                            & 92 \\ %pad: I created this file
ELF constants                            & \ref{chap:advanced}           & [[elf.h]]       & [[Ehdr32sz]]                                                              & 21 \\       
ELF generation                           & \ref{chap:advanced}           & [[elf.c]]       & [[elf32()]]                                                               & 176 \\ % actually in 8l/

\midrule

dumpers                                  & \ref{chap:debugging-appendix} & [[fmt.c]]       & [[prasm()]] [[Pconv()]] [[Aconv()]] [[Dconv()]]                           & 355 \\ %pad: I renamed list.c -> fmt.c
%dumper for ARM opcodes                  & \ref{chap:debugging-appendix} & [[enam.c]]      & [[anames]]                                                                & 99 \\ %5l/enam.c: which is a symlink in 5c/
error management                         & \ref{chap:error}              & [[error.c]]     & [[diag()]] [[errorexit()]]                                                & 45 \\ %pad: I created this file
input/output buffer                      & \ref{chap:libc}               & [[io.c]]        & [[buf]] [[readsome()]] [[wput()]]                                         & 138   \\ %pad: I created this file 
utilities                                & \ref{chap:libc}               & [[utils.c]]     & [[lookup()]] [[malloc()]]                                                 & 226 \\ %pad: merged with compat.c

\otoprule
Total                                    &                               &                 &                                                                           & 8142 \\
\bottomrule
\end{tabular}
\end{center}
\caption{Chapters and source files of [[5l]].}
\label{tab:code-orga}
\end{table*}
\n see SRC_VIEWS in the Makefile, and make loc
\n I did not factorized in a ll/ this time, but I factorized via LP.
\n We could put include/exec/{a.out.h,elf.h} but 5l does not use them.
\l ar.h
\t mv a.out.h in Debugger then?
\n used to depend on 5c/ for one file ../5c/enam.c but now done via symlink
\l rename some of the files, see their comment, e.g. span.c -> oplook.c

An important file not included in Table~\ref{tab:code-orga}
is [[include/obj/5.out.h]]. It contains the
definition of the ARM assembly opcodes used by [[5l]]. 
\l also operand kind, and object file related DS. registers too.
It is not included here
because its content is described instead in the \book{Assembler}.



\section{Software architecture}
\label{sec:soft-archi}

%trans:? general sentence on orga of linker?

%dup: (and adapted) from Assembler.nw
Figure~\ref{fig:controlflow} describes roughly 
the main control flow of [[5l]], while
Figure~\ref{fig:dataflow} describes 
the main data flow of [[5l]].
%
The main steps of the linking process of [[5l]] are as follows:

\begin{enumerate}
\item {\em Load} (read) the object files and libraries (via [[objfile()]])
and {concatenate} their code and data in different sections in memory
(via [[ldobj()]])

\item {\em Resolve} symbol references (via [[patch()]], ...)
\n and {relocate} branching instructions; actually relocate done at load time

\item {\em Generate} the executable with its header and
machine code (via [[asmb()]])

\end{enumerate}


\begin{figure}[!]\centering
\begin{verbatim}
                    +---------+      +--------+
                +-->| objfile |----->| ldobj  |    Loading
                |   +---------+      +--------+
                |
                |     +---------+
                |+--->|  patch  |
                ||    +---------+
                ||    +---------+
+------------+  |+--->|  noops  |
|    main    +--++    +---------+
+------------+  ||                                 Resolving
                ||    +---------+
                |+--->| dodata  |
                ||    +---------+
                ||    +---------+
                |+--->| dotext  |
                |     +---------+
                |                     +--------+
                |                 +-->| datblk |
                |   +---------+   |   +--------+
                +-->|  asmb   |---+                Generating
                    +---------+   |   +--------+
                                  +-->| asmout |
                                      +--------+
\end{verbatim}
\caption{Control flow diagram of [[5l]].}\label{fig:controlflow}
\end{figure}
\n there is no loadlib(), it is an advanced  feature
%ocaml: if was more functional we could annotate arrows with types,
% and have more a pipeline than a tree of procedures

\begin{figure}[!]\centering
\begin{verbatim}
object file-\                /- code graph -\ 
             > instructions -                > executable
object file-/                \- data list  -/               

                  (use global symbol table)
\end{verbatim}
\caption{Data flow diagram of [[5l]].}\label{fig:dataflow}
\end{figure}
%ocaml: this is what I hope I will get, a transformation pipeline


After some basic command line processing and initializations,
the function [[main()]] first calls [[objfile()]] for
each object files and libraries to link. 
\n also loadlib(), but it is for advanced automagic lib feature
\n  and only their objects containing symbols we are looking for 
\n  (symbols uses mentioned in object files and so marked as SXREF) fixpoint
\n  so produce smaller binaries
%
[[objfile()]] opens
the object file or library and calls [[ldobj()]] to read
its object code in memory, which is mostly a {\em list of instructions}.
%
Doing so, [[ldobj()]] modifies also the globals [[firstp]] and [[datap]] 
containing respectively 
\t rename firstp to codep, or even codei
the list of {code instructions} and {data instructions}.
\n also [[textp]] and the list of {procedures}, but less important now.
Thus, all the code and data in the
object files are concatenated together in the appropriate {\em section}.
\l also Instr.type field with section name

[[ldobj()]] increments also a global [[pc]] after each code instruction
read. [[pc]] represents the current value of 
the {\em virtual program counter}. Each code instruction
in memory has a field [[Instr.pc]] with the value of [[pc]]
at the moment the instruction was read.
\n imperative style
\t ldobj relocate branching instruction, use global virtual pc instead of local.
\t global because of all the objs, as opposed to Assembler
\t virtual because virtual counter still! incremented by 1
%
Finally, [[ldobj()]] populates a {\em symbol table} called [[hash]],
which keeps track of different {properties} of symbols.
%
One of this property, [[Sym.value]], contains initially
a virtual program counter for symbols corresponding to procedures,
and a size for symbols corresponding to globals.
This will be useful to resolve symbol references.
%
This same field will contain at the end the resolved memory
address of the procedure or global.
\t really for Text? once resolved, Instr.pc of TEXT already has
\t  resolved address, no need for its Sym.value to be updated


After loading the object files,
[[main()]] calls a series of functions ([[patch()]], [[noops()]], etc)
which use the globals [[firstp]], [[datap]], and [[hash]] to
process or rewrite list of instructions.
\n actually does not really use datap, use more hash
%
First, [[patch()]] transforms the list of code instructions in a
{\em graph of instructions} where branching instructions have a
field [[Instr.cond]] pointing to the appropriate target instruction. 
\l FIGURE? too early maybe
%
To build this graph [[patch()]] is leveraging the symbol table [[hash]]
computed previously
to find the virtual program counter corresponding to a certain procedure symbol
(in its [[Sym.value]] field)
and {\em index} all [[Instr.pc]] to find the instruction pointer ([[Instr*]])
corresponding to a certain virtual program counter.


Once the graph has been built, there is no more need for the notion of
virtual program counter. 
Every code references (symbols or absolute jumps) in branching instructions
have been resolved. 
%
This allows in turn to transform safely some {\em virtual instructions} (see
the \book{Assembler}) such as [[RET]], [[DIV]], or [[NOP]] 
in machine instructions. 
\l actually still not real real; for instance still MOVW, and big imm cst
\l or do optimisations? e.g., ANOP
Indeed, [[noops()]] can
replace a virtual instruction by
multiple instructions or even delete the instruction without
any consequence on the other branching instructions (as long
at it maintains carefully the [[Instr.cond]] pointers pointing
to the original instruction).
%
Before the graph of instructions, inserting or
deleting an instruction would have forced to assign a new 
virtual program counter to each instruction and to relocate 
every branching instructions.

Once [[5l]] has the graph of machine code instructions and the set of globals
declarations, it can start to {\em lay out} the code and data.
[[dodata()]] assigns 
%dup: overview/tutorial
a memory address in [[Sym.value]] to each  globals in the symbol table
as an offset to the start of the data section.
\t again will explain rational for this decision and why not directly final
\t  address
\n not 'data definitions in [[datap]]' layout does not need DATA
\l e.g., 014 for hello
%
Then, [[dotext()]] does a similar thing for the code instructions.
For those code instructions [[Instr.pc]] will contain now the final code address
of the instruction (and not a virtual program counter anymore).
\l e.g., 0x1020 for main
\l so work by side effects, imperative style, on list of instructions

At this point, the size of the code and data sections are known
and stored respectively in the globals [[textsize]] and [[datsize]].
%
[[5l]] can finally call [[asmb()]] to generate the executable and 
its header. This function uses two helpers functions: one
to fill the data section [[datblk()]] 
\n this time use the DATA
and one to generate ARM instructions in the code section [[asmout()]].

\l How does handle mutually recursive object files?
%  for objects passed on the command line it loads every symbols
%  and at first some symbols get their type as SXREF (placeholder) but then
%  when you load the second object it sets it as a STEXT or SDATA.
\l How automatically grab all the necessary libs?
%  magic #pragma and special ANAME code in the .8?

\l Note that the linker loads lazily the objects in a library.
% It loads only what is necessary, that is objects in a lib
% containing symbols that are "looked for" that is symbols that are SXREF.
% (with a special case for _main which is not looked by
%  anything by default and so there is lookup(INITENTRY, 0)->type = SXREF
%  in the main of 8l/5l).

\l linker vs libmach, see appendix


%\section{Bootstrapping}
%bootstrap:
% source of 5l use 5l :) 
% [[cat]] can be bootstrapping tool :) See Principia.nw appendix


\section{Book structure}

%trans: %dup: (and adapted) from Assembler.nw
You now have enough background to understand the source code of [[5l]].
%toc:
The rest of the book is organized as follows.
%
I will start by describing the core data structures of [[5l]]
in Chapter~\ref{chap:core-ds}. 
%
Then, I will use a top-down approach in Chapter~\ref{chap:main}, and,
starting from [[main()]], we will present the code, or a high-level
view of the code, of some of the main functions, e.g., [[asmb()]].
%
The following chapters will describe
the main components of the linking pipeline:
Chapter~\ref{chap:loading-objects} will present the code to
load object files,
Chapter~\ref{chap:loading-libraries} the code to load libraries,
Chapter~\ref{chap:resolving} the code to resolve symbols,
and finally Chapter~\ref{chap:arm-codegen} the ARM machine code
generator.
%
In Chapter~\ref{chap:debugging} we will describe the code
responsible for adding debugging support in [[5l]], which
for instance adds line information in the executable. 
You can then know, when debugging a binary program,
to which original line and which source file an
instruction in the binary comes from, or what is the
original name of the procedure containing this instruction.
%
In a similar way, Chapter~\ref{chap:profiling} will describe the code
for adding profiling support in [[5l]].
%
Chapter~\ref{chap:advanced} presents other
features of the linker that I did not present 
before to simplify the explanations, for instance
the support for dynamic linking or 
the ARM code generation of  instructions involving floats. 
%
Finally, Chapter~\ref{chap:conclusion} concludes
and gives pointers to other books in the \principia series.

%toc:
Some appendices present the code of non-functional properties:
the code to help debug [[5l]] itself in Appendix~\ref{chap:debugging-appendix}, the code to manage errors in Appendix~\ref{chap:error}, and
the code which profiles [[5l]] itself in
Appendix~\ref{chap:profiling-appendix}.
%
Appendix~\ref{chap:libc} contains the code of generic
utility functions used by [[5l]] but which are not specific to [[5l]].
%
Appendix~\ref{chap:linker-related-programs} describes the code of small
programs such as [[nm]] and [[ar]] which are related to the linker.
%
%%%Finally, Appendix~\ref{chap:5l-ocaml} contains
%%%the code of an OCaml port of [[5l]].
%%%\t what for? :)



%###############################################################################

\chapter{Core Data Structures}
\label{chap:core-ds}

\begin{verse}
\begin{flushright}
  {\it Show me your code and conceal your data structures, and I shall
    continue to be mystified. Show me your data structures, and I
    won't usually need your code; it'll be obvious.\\
    ~\\
    Fred Brooks}
\end{flushright}
\end{verse}

%toc:
In this chapter we will present the core data structures of [[5l]],
which are essentially:
%
a symbol table keeping track of the memory address and section of symbols, 
the abstract syntax tree (AST) of the instructions contained in object files,
and a set of globals pointing to lists of instructions.

\section{[[Sym]]bols and [[hash]] table}
\label{sec:hash}

%dup: (and adapted) from Assembler
One of the main job of a linker is to {resolve} symbol references
by linking uses of a symbol to its definition.
The {\em symbol table}, which keeps track of those symbols,
is thus a central data structure of [[5l]].
The structure below represents a symbol and its {properties}. 
It essentially associates a {\em key} to a {\em value}:

<<struct Sym>>=
struct  Sym
{
    // The key
    // ref_own<string>
    char    *name;
    // 0 for global symbols, object file id for private symbols
    short   version; 

    // The generic value, 
    // e.g., virtual pc for a TEXT procedure, size for GLOBL
    long    value; 

    <<[[Sym]] section field>>

    <<[[Sym]] other fields>>
    // Extra
    <<[[Sym]] extra fields>>
};
@
%ocaml: no need special type, just use hashtbl for symbol table,
% and can define special 'scope' type instead of abuse int for version
\l rename Symbol?
\l transform value to a union?
\n conflict with include/a.out.h

\label{sec:version}
The key is made of a pair with the name of the symbol and a {\em version}.
\l bad name?
The version is used to differentiate {\em private symbols} 
(a.k.a static symbols)
\n private symbols are advanced feature but too important to delay because
\n  many interfaces like lookup take a version number.
\l private symbols could be resolved in Assembler? kinda but want keep
\l  symbol in executable for debugger and anyway linker need to resolve things
\l  already so why not also resolve private symbols
in different object files using the same name, e.g., [[tmp<>]] 
in [[foo.5]] and [[tmp<>]] in [[bar.5]]. 
%assembler:
\l need that compare to assembler because now combine! so can have conflict
See the \book{Assembler} for more information about private symbols.
A version is a unique integer representing an object file,
e.g., 1 for [[foo.5]] and 2 for [[bar.5]], so the two previous
symbols can be designated respectively by [[tmp.1]] and [[tmp.2]].
Public symbols have their version set to 0.

\t #define VGLOBAL 0, VPUBLIC?

The meaning of [[Sym.value]] depends on the kind of the symbol.
It also depends on the step in the linking pipeline. 
%dup: overview/soft-archi
At the beginning [[Sym.value]] contains 
a virtual program counter for [[TEXT]] symbols, and
a size for [[GLOBL]] symbols. 
At the end it contains 
a resolved memory address in the code section for procedures and 
a resolved offset to the start of the data section for globals.
\t use itemize? table!! with TEXT|GLOBL  and beginning|end!

\l The 'type' and 'value' in Sym are? 
% - for ATEXT it will be STEXT and the value will be a virtual pc
% - for AGLOBL it will be SBSS or SDATA, and the value will be its size
% - for path elements it is a unique histgen (an index)
% before dodata() the value for a global stores its size. After location.
% before span() the value stores a virtual pc,
%  incremented by 1 between each instruction. After span() it stores the
%  final location at 4 bytes boundaries.
% => maybe use an union! 


%assembler:
% Explain special encart to related to code of 5a, because
% similar but different. Can be nice too relate. But optional for reader.
%assembler: Similar to Sym in Assembler.nw, but a few differences:
% - no 'type' (token_kind) field, no 'macro' field
% - no labels, they were translated in pc values.
% - no symidx field (but was local to outcode())
% - a new 'version' field; N_INTERN was in the Operand.symkind but the linker
%   now manages multiple objects together where can have the same static name
%   multiple times
% - a new 'type' field for the section, the linker has to resolve
%   as opposed to the assembler
% So this is really a symbol table, used for only one thing! good.


%dup: from Assembler
The symbol table itself is represented by a global {hash table} called [[hash]].
It makes sense to use a global because
the symbol table will be accessed by different components
of the linking pipeline.
\l eg? ldobj, patch
%
One way to implement a hash table in C is to use a big array
of lists, also known as an array of {buckets}:

<<global hash linker>>=
// hash<Sym.name * Sym.version, ref_own<Sym>> (next = Sym.link in bucket)
Sym*	hash[NHASH];
@
\l when load the objects this hashtbl is populated
<<constant NHASH linker>>=
NHASH       = 10007,
@
%assembler: same except NHASH which was 503 in 5a
%ocaml: just use stdlib hashtbl, and does not have to be a global

%dup: from Assembler
One way to implement a list of something in C is to embed in
this something a [[link]] field pointing to the next
element in the list:

<<[[Sym]] extra fields>>=
// list<ref<Sym>> (from = hash)
Sym*    link;
@

%dup: from Assembler
The end of the list is represented by the null pointer:

<<constant S>>=
#define S       ((Sym*)nil)
@


%dup: (and adapted) from Assembler
The main interface to the symbol table is the
function [[lookup()]] which internally uses the global [[hash]].
It takes a symbol name and a version, forming a full key,
and returns the [[Sym]] in the symbol table [[hash]] associated with 
this key, or a new symbol if the key was not found:

<<function lookup>>=
Sym*
lookup(char *symb, int v)
{
    Sym *sym;
    long h;
    int len;
    <<[[lookup()]] other locals>>

    <<[[lookup()]] compute hash value [[h]] of [[(symb, v)]] and [[len]]>>
    
    // sym = hash_lookup((symb, v), h, hash)
    for(sym = hash[h]; sym != S; sym = sym->link)
        if(sym->version == v)
            if(memcmp(sym->name, symb, len) == 0)
                return sym;

    // else
    <<[[lookup()]] if symbol name not found>>
}
@
%old: I rename s -> sym and l -> len
\l typedef int version;? and VERSION0 = 0 so clearer to read? a GLOBAL = 0?
%ocaml: use stdlib Hashtbl.find, sad duplicate from 5a/
%assembler: very similar, diff is use of (symb, v) instead of just (symb)
% could do the opti of fast-path/slow-path which avoids some memcmp? meh

<<[[lookup()]] other locals>>=
char *p;
int c;
@
<<[[lookup()]] compute hash value [[h]] of [[(symb, v)]] and [[len]]>>=
// h = hashcode(symb, v); 
// len = strlen(symb);
h = v;
for(p=symb; *p; p++) {
    c = *p;
    h = h+h+h + c;
}
len = (p - symb) + 1;
h &= 0xffffff;
h %= NHASH;
@
\l why plus 1 ?? figure? example?

<<[[lookup()]] if symbol name not found>>=
sym = malloc(sizeof(Sym));
sym->name = malloc(len + 1); // +1 again?
memmove(sym->name, symb, len);
sym->version = v;

sym->value = 0;
sym->type = SNONE;
sym->sig = 0;

// add_hash(sym, hash)
sym->link = hash[h];
hash[h] = sym;

<<[[lookup()]] profiling>>
return sym;
@
\t could have a syminit like in 5a
\l why plus 1 again ??
%ocaml: not sure need SNONE

% sym->sig will be described in Safe linking section

\section{[[Section]]}

Another important property of a symbol is in which {\em section}
it will reside:

<<[[Sym]] section field>>=
//enum<Section>
short   type;
@
\l rename section?

<<enum Section(arm)>>=
enum Section
{
    SNONE = 0,

    STEXT,
    SDATA,
    SBSS,

    SXREF,
    <<[[Section]] cases>>
};
@
\l see also asmsym()
%ocaml: I think SNONE could be merged with SXREF, 
% also with ADT can give different argument to STEXT and SDATA (virtpc vs size)
% instead of abusing Sym.value. Also can have SText and SText2 to
% differentiate the kind of value they carry.

We can see enumerations above corresponding to the usual
text, data, and BSS sections of a program.
Note that there is no [[SSTACK]] enumeration as we care only 
about the executable file here, not the memory image of a program. 
The stack content and its maximum size is set initially by the kernel, 
not the executable.

[[SXREF]] is used to represent an {\em unknown reference}. When object
files are loaded in [[ldobj()]], symbol references in operands
are looked up in the symbol table. 
\l well N_EXTERN and N_INTERL
If the symbol has not been
defined yet, a new symbol is created with its section set to [[SXREF]]. Once
a [[TEXT]] or [[GLOBL]] directive introduces the symbol, 
its section can be adjusted.
%
At the end of the linking process there should be no more
symbols with [[SXREF]]. This is in fact checked by the
[[undef()]] function we will see in Section~\ref{sec:undef}.
\t lead to famous error message: undefined ref ...

\l those are mostly sections, or subsections 
% e.g., SDATA1 of SDATA, and STRING of STEXT (was SLEAF/SCONST before too)

\n need STEXT vs SDATA? firstp and datap not enough?
\n functions like datblk iterate over symbol table, not datap


\section{[[Opcode]] and [[Operand]]}
\label{sec:opcode-operand}

%trans:
An object file contains essentially a list of {instructions} where
each instruction is made of 
an {\em opcode} with possibly 1, 2, or 3 {\em operands}.
%
The [[Opcode]] type, [[Operand_kind]] type, and a few register
aliases such as [[REGPC]], all used by [[5l]], are all defined in
[[include/obj/5.out.h]]. 
Those types are fully described in the \book{Assembler}. 
%
{Dumpers} for those types are described in Appendix~\ref{sec:dumpers}
if you need to refresh your memory: 
\begin{itemize}
\item see [[Aconv()]] for the dumper of [[Opcode]] 
([[A]] because opcodes use the [[A]]$xxx$ syntax, e.g., [[ASUB]]),

\item see [[Dconv]] for the dumper of [[Operand_kind]] 
([[D]] because operand kinds use the [[D]]$xxx$ syntax, e.g., [[D_CONST]]).

\end{itemize}


Remember that the opcodes in object files do not correspond exactly to ARM
opcodes. They are mostly a superset because they also include
opcodes for {\em pseudo-instructions} such as [[ATEXT]] and [[AGLOBL]], as well
as opcodes for {\em virtual instructions} such as [[ARET]] and [[AMOVW]].
\n can put major opcodes here, AADD, ATEXT, AB, etc? done a bit above
\n and also D_REG? done a bit below.
\l and also N_INTERN?

[[include/obj/5.out.h]] does not define an [[Operand]] type though
as the assembler and linker have slightly different needs for
this data structure. Here is the [[Operand]] type used by [[5l]]:

<<struct Adr(arm)>>=
struct  Adr
{
    // enum<Operand_kind> (D_NONE by default)
    short   type;

    // switch on Operand.type
    union {
        long    offset;
        Ieee*   ieee;
        char*   sval;
    };

    // option<enum<Register>> None = R_NONE
    short   reg; 

    <<[[Adr]] other fields>>
};
@
\n see DConv too
\n ATEXT arguments are also Adr (abuse)
\t rename Operand! 
%old: was called Adr
%note: offset abused for REGREG in which case it's really a int4
% but otherwise it's often used as an offset in D_BRANCH, D_OREG
% because indeed it's an offset to a basis (PC, SB, etc)
%assembler: Similar to Gen in Assembler.nw, but a few differences:
% - ieee was dval, and sval was sval[8]
% - have autom for TEXT  to keep track of N_PARAM and N_LOCAL for frame symbols
% - new 'class' field (but seems local to oplook())
% - the pointed Sym structure is a bit different
%ocaml: would be better if had ADT so can have better Instruction type instead
% of those opcode, operand, Adr, and unions and all those comments
% also could factorize with Operand of 5a

%assembler:
[[Operand]] is until now almost identical to the [[Operand]] type 
used by [[5a]] and  described in the \book{Assembler}, except for
the way float operands are represented ([[Ieee*]] versus a [[double]]).
The {\em operand kind} is also stored in [[Operand.type]], e.g.
[[D_CONST]], [[D_REG]], [[D_OREG]].
\l talk about offset? and relocations?
\l offset can be based on PC (for D_BRANCH), SB(for N_INTERN, N_EXTERN),
\l  on FP(for N_PARAM), and on SP(for N_LOCAL), 
\l  or can be direct value (for D_CONST)
[[Operand.reg]] is used again for operands involving registers.
\l reg Abused for NOPROF and DUPOK? could use a union again?
We will see later though additional fields specific to the linker.


Operands involving symbols use an [[Operand.sym]] field and
the {\em symbol kind} is also stored in a [[Operand.symkind]] field,
e.g., [[N_EXTERN]], [[N_PARAM]], [[N_LOCAL]] (which are
enumerations defined also in [[include/obj/5.out.h]]):

<<[[Adr]] other fields>>=
// enum<Sym_kind>
short   symkind;
// option<ref<Sym>> (owner = hash)
Sym*    sym;
@
%old: was called 'name' but confusing, 
%old: sym was part of a union with Auto, but better that way

\l give a few examples of concrete operands? or refer to assembler book?

Symbols references in the assembly language of [[5a]], as well as in
object files, are all represented as ``offsets'' to {\em pseudo-registers}:
\l well for SB and globals it is kinda true

\begin{itemize}
\item procedures and globals use the [[SB]] ({\em static base}) 
pseudo-register, e.g., [[main(SB)]], [[hello(SB)]]. Their
symbol kind is [[N_EXTERN]] (or [[N_INTERN]] for private symbols
such as [[foo<>(SB)]]).

\item parameters are accessed via the [[FP]] ({\em frame pointer})
pseudo-register, e.g., [[p+4(FP)]]. Their symbol kind is [[N_PARAM]].

\item locals use the [[SP]] ({\em stack pointer}) pseudo-register,
e.g., [[v-8(SP)]]. Their symbol kind is [[N_LOCAL]].
\t SP usually negative no?

\end{itemize}

The symbol name for parameters and locals is actually optional.
What matters is the additional offset number for code generation. 
The symbol name is mostly a comment.
But, those symbols are still saved in the 
{executable symbol table} as we will see in Chapter~\ref{chap:debugging},
so they can be leveraged by tools such as debuggers.


\section{[[Instr]]uction}
\label{sec:instr}


The type below connects an opcode with its operands to form
a full {\em instruction}:

<<struct Prog(arm)>>=
struct  Prog
{
    //enum<Opcode>
    byte    as;

    // operands
    Adr from;
    Adr to;

    <<[[Prog]] other fields>>

    // Extra
    <<[[Prog]] extra fields>>
};
@
\t bad name .... I think Prog is really an Instruction
\t  Prog -> Instr,  p -> i | instr,  also Prog.as -> Instr.opcode?
%ocaml: could reuse type used by assembler, can put specificities
% outside the structure
%assembler: similar to the arguments of outcode():
%  - as (opcode), from (g1), to (g2), reg, scond, and
%    line field was a lineno global
%  - but some new fields: pc, mark, cond, forwd
\l could rename cond to pcond and AB to AJMP and could factorize
\l  more code with x86
\n pseudo-opcode like ATEXT have operands too; from abused to store proc names
\l see Pconv percent P in printf

Most opcodes use two operands, transferring or processing data {\em from}
a source operand {\em to} a target operand, e.g., [[MOVW R1, (R2)]].
%
Some opcodes use three operands, e.g., [[ADD R1, R2, R3]]. 
In that case the middle operand is always a register, hence
the more specialized field below representing this middle operand:

<<[[Prog]] other fields>>=
// option<enum<Register>>, None = R_NONE
short   reg;
@
\n very arm specific!
\l This is used also to store TEXT attributes, e.g., DUPOK, NOPROF. 

All ARM instructions have a {\em conditional execution}
(see the \book{Assembler} or \book{Emulator}):

<<[[Prog]] other fields>>=
// enum<Instr_cond>
byte    scond;
@
\t also special bits
\t scond? special bits and conditional exec bits?

For debugging purpose, each instruction has also a 
{\em global line number}:

<<[[Prog]] other fields>>=
long    line;
@
\t but now still valid? because local to an object file, but now
\t  we need to think globally, so meaning?

\l When object is the result of the assembly generated by 5c the line 
\l is the line in the .c so many ASM instructions have actually the 
\l same line because one C expression can result in many ASM instructions.
\l a global line after #include. 
For more information on line numbers and debugging
see Chapter~\ref{chap:debugging}.

\bigskip
%trans:
Up until now, [[Instr]] is very similar to
the type used in the \book{Assembler} to represent
an instruction\footnote{[[5a]] actually uses
a set of parameters to the [[outcode()]] function
to represent an instruction. Each parameter
is identical to one of the field of [[Instr]].
}.
%
The following field is new and specific to the linker.
It initially stores the {\em virtual program counter} of the instruction
(if the instruction is a code instruction, e.g., [[ADD]]):

<<[[Prog]] other fields>>=
// virtual program counter, and then real program counter
long    pc;
@
\l The absolute pc of this instruction! 
\l needed for some check pc == p->pc somewhere.
\t type is  long | addr ?
\n abused to store offset to start of pool
%ocaml: put outside structure, and differentiate depending on phase

%dup: overview/soft-archi 
The virtual program counter is incremented after each code instruction
is read in [[ldobj()]].
%
Later in the linking process [[Instr.pc]] will be assigned
a {\em real program counter} which will be a multiple of 4 as 
%dup: overview/5l-a
the ARM uses fixed-length instructions of 4 bytes.

%dup: overview/soft-archi
Later in the linking process, another field, [[Instr.cond]],
will be used to build a {\em graph of instruction}. 
Branching instructions will have their [[Instr.cond]] field points to the
target instruction.

<<[[Prog]] extra fields>>=
// option<ref<Prog>> for branch instructions
// (abused to list<ref<Prog>> (from = textp for TEXT instructions))
// (abused also for instructions using large constants)
Prog*   cond;
@
\l called pcond I think in x86, could choose same name
%ocaml: put in separate node type computed later


\label{sec:mark}
Finally, the field below is used by different algorithms to
temporarily {\em mark} instructions in the graph of instructions:

<<[[Prog]] other fields>>=
//bitset<enum<Mark>>
short   mark;
@
%old: was byte
%ocaml: can be a local hash variable of an algorithm instead of global field

%chunks:
I will describe gradually the different kinds of marks in this document:

<<enum Mark(arm)>>=
/* mark flags */
enum Mark {
    <<[[Mark]] cases>>
};
@
%dead: LABEL
%not-so-useful opti: FOLL
%useful opti: LEAF
\n present ex of mark such as LEAF early? 
\n there were a few cases STEXT:case SLEAF: but I removed SLEAF so ok


%dead:
%<<[[Prog]] other fields>>=
%union
%{
%    long	regused;
%};
%@
% use anonymous union now, so don't need those aliases
%<<constant regused(arm)>>=
%#define	regused	u0.u0regused
%@
%<<constant forwd(arm)>>=
%#define	forwd	u0.u0forwd
%@
% now I just have a forward field, see mkfwd().

\section{List of instructions}
\l and instruction pointer?

%toc:
In this section we will see a set of globals keeping track
of different lists of instructions.

\t FIGURE where see everything

% does plan9 code suffer from "bad taste"? could rewrite some code using
% list to use an indirect = &head; pointer to simplify the code?
%https://medium.com/@bartobri/applying-the-linus-tarvolds-good-taste-coding-requirement-99749f37684a#.mxcke2xtf

\subsection{Code instructions, [[firstp/lastp]]}

[[firstp]] points to the first instruction
of the list of all {code instructions} 
(everything except the [[GLOBL]] and [[DATA]] pseudo-instructions):
\l includes TEXT, also does not include AEND and other stuff?

<<global firstp>>=
// list<ref_own<Prog>> (next = Prog.link)
Prog*	firstp;
@
\l good name? first_instr better? rename instrp?
\t rename codei and lastp -> ecodei
%ocaml: return a list instead of having a global (actually can return array!)

%dup: symbol table link
The instructions are linked together with the following field:

<<[[Prog]] extra fields>>=
// list<ref<Prog>> (from = firstp or datap)
Prog*   link;
@

%dup: symbol table S
The end of the list is represented by the null pointer:

<<constant P>>=
#define P       ((Prog*)nil)
@

We can quickly access the end of the list by using the
following global:

<<global lastp>>=
// ref<Prog> (end from = firstp)
Prog*	lastp;
@
%ocaml: use a queue data structure, or use List.rev
\l strong coupling between firstp and lastp that should be encapsulated
\l   in a specific structure (like for datap/edatap)
% option<Prog>? usually there is a sentinel so there is always a lastp


\subsection{Data instructions, [[datap]]}

[[datap]] keeps track of the list of [[DATA]] pseudo-instructions:

<<global datap>>=
// list<ref_own<Prog>> (next = Prog.link)
Prog*	datap = P;
@
\n no need for edatap in arm
%ocaml: return list again instead of using global

[[datap]] points to the last data instruction. 
\l how access first? need first? no need because no order needed for data
Note that [[GLOBL]] instructions are not part of this list.
Instead, the [[GLOBL]] instructions, when read, modify symbols
in the symbol table.

Thanks to [[firstp]] and [[datap]] all the code and
data instructions are separated in different {\em sections}.


\section{Current instructions, [[curtext/curp]]}

During the linking process, we will iterate many times over
the list of instructions. It is useful for error messages
to store in globals in which procedure we currently are ([[curtext]]) 
and which instruction we are currently processing ([[curp]]):
\n it's an error management issue but it is too important to be delayed
\n actually curtext used also to link curauto, not just for error reporting


<<global curtext>>=
//option<ref<Prog>> where Prog.as == ATEXT
Prog*	curtext = P;
@
\n there will be different curxxx, a bit ugly use of globals
\n curauto, curhist
%ocaml: not sure needs this as a global, error report should be file x line
%  first, then curtext. Some algorithm such as rewrite could have also
%  a curtext as a local.

<<global curp>>=
// option<ref<Prog>>
Prog*	curp;
@
\l set only during iteration in asmb, but used in Pconv, diag messages, etc

Many algorithms will set [[curtext]] as follows while iterating
over instructions:

<<adjust curtext when iterate over instructions p>>=
if(p->as == ATEXT)
    curtext = p;
@
%old: I factorized code using this chunk more than what existed before
% by moving some curtext = p outside some if; it's sligtly slower
% but cleaner for LP purpose.

The [[TNAME]] macro (for [[T]]ext [[NAME]]) is used as an argument
to a few error management functions to display the name of the
current procedure when there is one:

<<constant TNAME(arm)>>=
#define TNAME (curtext && curtext->from.sym ? curtext->from.sym->name : noname)
@
<<global noname linker>>=
char	*noname		= "<none>";
@
\l firsp not necessarily a TEXT, even though for C programs it should be
\l  as anyway _main will call main (but could have labels that play tricks)

%trans:
% few more DS, especially codegen, but presented later in Chapter X

\t BIG figure where see pointers, relation with hash table, instr
\l  operands, etc.  see cond overloay over link

%---------------------------------------------

%\section{[[Exec]]utable}
% actually not used by 5l ...

%\section{[[Optab]] and [[optab]]}?
%hmm maybe better later

%\section{[[Operand_class]]}
%hmm maybe better later

%\section{[[Buf]] and [[buf]]}?
%hmm maybe better in appendix or later

%\section{[[textp/etextp]]}
% used only by asmsym so later

%\section{[[pc]]}?

%\section{[[textsize]], [[datasize]], [[INITDAT]], ...}?








\chapter{Main Functions}
\label{chap:main}

%trans: %dup: (and adapted) from Assembler.nw
I now switch to a top-down approach where
%toc:
I describe the main functions of [[5l]], starting from [[main()]]
down to [[asmb()]] which generates the executable.
\l well main in some sense is also generating the executable, hmm

\section{[[main()]]}

%trans: %dup: from Assembler.nw
Before showing the code of [[main()]] we first introduce
a few globals set by [[main()]].
%
A common pair of globals in \plan code
are [[thechar]] and [[thestring]] which both represent
the current architecture.
%dup: from intro/5l (and intro/5a)
As said in the introduction, \plan by convention 
represents architectures with a single character: 
[['0']] is MIPS, 
[['5']] is ARM, 
[['8']] is x86, etc.
%
This character is used by [[5l]]
for the filename extension of object files (e.g., [[hello.5]]): 
\n actually in 5l thechar is almost not used, just for histfrogp stuff
\l could be used also for 5.out but it is not.

<<global thechar>>=
char	thechar;
@

%dup: from Assembler
[[thestring]] contains the longer, more readable, version
of the architecture, e.g., [["arm"]] for [['5']].

<<global thestring>>=
char*	thestring;
@

This is used by [[5l]] to find the architecture-specific 
library files in [[/arm/lib/]]
as explained in Section~\ref{sec:loading-libraries-semi-auto}.

Another important global is the name of the executable,
which by default is [[5.out]]
%dup: overview/5l
and can be modified with the [[-o]] option:

<<global outfile>>=
char*	outfile;
@
\l why global? could pass around? for error msg?

The file descriptor of the created executable file will be
stored in the following global:

<<global cout>>=
fdt	cout = -1;
@
\n cout =~ create(outfile)
\l why need global for that? could be passed around too no? used only by asmb
\l  and asmout


%trans: %dup: (and adapted) from Assembler
We can now present the code of [[main()]], the entry point of [[5l]].
%chunks:
The most important part is the chunk below the [[-- main functions --]]
comment which contains the main flow of [[5l]]. It will be
described soon in Section~\ref{sec:main-flow}:

<<function main(arm)>>=
void
main(int argc, char *argv[])
{
    <<[[main()]] locals(arm)>>

    thechar = '5';
    thestring = "arm";   

    outfile = "5.out";

    <<[[main()]] debug initialization(arm)>>

    ARGBEGIN {
    <<[[main()]] command line processing(arm)>>
    } ARGEND

    USED(argc);
    if(*argv == nil)
        usage();

    <<[[main()]] initialize globals(arm)>>

    cout = create(outfile, 1, 0775);
    <<[[main()]] sanity check cout>>

    // ------ main functions  ------
    <<[[main()]] cout is ready, LET'S GO(arm)>>

out:
    <<[[main()]] profile report>>
    errorexit();
}
@
%old: set INITENTRY used to be in main flow after setting firstp/lastp
% but better here I think





<<function usage, linker>>=
void
usage(void)
{
    print("usage: %s [-options] objects", argv0);
    errorexit();
}
@
%old: was diag(...) not print(...) but then output ??none?? which was ugly

<<[[main()]] sanity check cout>>=
if(cout < 0) {
    diag("cannot create %s: %r", outfile);
    errorexit();
}
@

The error management functions [[diag()]] and [[errorexit()]]
are described in Appendix~\ref{chap:error}.
\l ex of output? 
\t Note percentr is error return code of last syscall I think


<<[[main()]] initialize globals(arm)>>=
<<[[main()]] addlibpath("/{thestring}/lib") or ccroot>>
<<[[main()]] set HEADTYPE, INITTEXT, INITDAT, etc>>
<<[[main()]] set INITENTRY>>
@
\l order important? if not then maybe can be introduced later gradually
\t explain? or introduce gradually?

\subsection{Arguments processing}

We have mentioned before the [[-o]] option:

<<[[main()]] command line processing(arm)>>=
case 'o':
    outfile = ARGF();
    break;
@

%chunks:
I will introduce the other command-line options gradually in this document. 
%trans:
An important set of options deals with the executable format 
and are presented below.

\subsection{Executable format choice, [[5l -H]]}
\label{sec:choice-exec-format}

One of the most important option of [[5l]] is [[-H<num>]]
\n even though it should be very rarely used
which modifies the global [[HEADTYPE]]
recording the format of the executable:

<<global HEADTYPE>>=
// option<enum<Headtype>>, None = -1
short	HEADTYPE = -1; /* type of header */
@
%old: was int in ARM and long in x86, but I don't think it matters
%ocaml: use string directly instead of integer

<<[[main()]] command line processing(arm)>>=
case 'H':
    a = ARGF();
    if(a)
        HEADTYPE = atolwhex(a);
    break;
@
%old:    /* do something about setting INITTEXT */    what was that?

The [[atolwhex()]] function, described in Appendix~\ref{sec:atolwhex},
converts a string representing a number into an integer. 
[[atolwhex()]] also handles numbers written in hexadecimal, hence the name.
This is not very useful for the [[-H]] option, but it will
be useful for other options such as [[-T]] as we will see later.

By default [[5l]] uses the [[a.out]] format
which is the executable format used by \plan:

<<enum headtype(arm)>>=
/*
 *  -H0                     no header
 *  -H2 -T4128 -R4096       is plan9 format
 *  -H7                     is elf
 */
enum Headtype {
     H_NOTHING = 0,
     H_PLAN9 = 2, // a.k.a H_AOUT
     H_ELF = 7,
};
@
\l rename H_AOUT? 
\l reassign them? cos weird to go from 0 to 2 and 2 to 7
%todo: H_OMACH, H_PE
%old:
% *	-H1 -T0x10005000 -R4  is aif for risc os
% *	-H3 -T0xF0000020 -R4  is NetBSD format
% *	-H4				      is IXP1200 (raw)
% *	-H5 -T0xC0008010 -R1024 	is ipaq

\t put back -H6 because used for bcm kernel
% *	-H6 -R4096			   no header with segments padded to pages
% H6 used bcm?

%pad: I originally added H_DEFAULT. before there was some stuff with -9 -B -U
%  for probably  plan 9, plan B, Unix, but I removed it since, not that useful
% <<constant DEFAULT>>=
% #define	H_DEFAULT	H_PLAN9
% @
% rename H_DEFAULT_HEADTYPE? and make it part of the enum?

%old: 
% \section{[[5l -9 -B -U]]}
% dead I think, -9 for plan9, B for planB? U for Unix?
% <<constant DEFAULT>>=
% #define	DEFAULT	'9'
% @
% <<[[main()]] adjust HEADTYPE if debug flags(arm)>>=
% if(!debug['9'] && !debug['U'] && !debug['B'])
%     debug[DEFAULT] = true;
% 
% if(HEADTYPE == -1) {
%     if(debug['U'])
%         HEADTYPE = 0;
%     if(debug['B'])
%         HEADTYPE = 1;
%     if(debug['9'])
%         HEADTYPE = H_PLAN9;
% }
% @


The other executable formats, e.g., ELF, will be described later in 
Section~\ref{sec:other-executable-formats}.


The executable format dictates 
the size of the header, 
where the code section will be loaded in memory,
and how the data section will follow the code section,
by setting the following globals:
%ocaml: has to be some globals? could not be passed to asmb? or in a struct?

<<global HEADR>>=
long	HEADR; /* length of header */
@
\n 32 for a.out (0x20)
\l long? really?
%ocaml: use a record to put all config parameters instead of global

<<global INITTEXT>>=
long	INITTEXT = -1; /* text location */
@
\t typedef long addr; ? and put option<Addr> where NONE = -1 ?
\l -1 is None
\n -T text segment start virtual address (important! e.g., for kernel 0x7c00)

<<global INITRND>>=
long	INITRND = -1; /* data round above text location */
@
\n -R text segment rounder at r multiple

<<global INITDAT>>=
long	INITDAT = -1; /* data location */
@
\n -D data segment start
\n normally after end of text, so dynamic



<<[[main()]] set HEADTYPE, INITTEXT, INITDAT, etc>>=
if(HEADTYPE == -1)
    HEADTYPE = H_PLAN9;
switch(HEADTYPE) {
<<[[main()]] switch HEADTYPE cases(arm)>>
default:
    diag("unknown -H option");
    errorexit();
}
<<[[main()]] sanity check INITXXX>>
DBG("HEADER = -H%d -T0x%lux -D0x%lux -R0x%lux\n",
        HEADTYPE, INITTEXT, INITDAT, INITRND);
@
%old: was -H0x%d but no sense
\t explain DBG?

Here are the specifics for the [[a.out]] format under \plan:

<<[[main()]] switch HEADTYPE cases(arm)>>=
case H_PLAN9:
    HEADR = 32L;
    if(INITTEXT == -1)
        INITTEXT = 4096+32; // 1 page + a.out header = 4128
    if(INITDAT == -1)
        INITDAT = 0;
    if(INITRND == -1)
        INITRND = 4096; // 1 page
    break;
@
\n 32 = 0x20 hence this note in kernel mkfile:
%# see mem.h, the additional 20 are the size of the a.out header added by LD
%KTZERO_AND_HEADER=0xE0100020

\t DBG explained in debugging-appendix, opportunity to explain -v,
\l and shows output?


[[INITDAT]] is initially set to 0 but it will be modified later
by [[dotext()]] to contain the address of the next memory {page}
\footnote{The size of the page is specified by [[INITRND]].}
after the code section.
Indeed, the memory pages for the code and data section will have different
properties (see the \book{Kernel}).

You can also manually set the start of the code and data sections, 
%dup: intro/5l
which is useful when producing {special binaries} such as kernels
or boot loaders:

<<[[main()]] command line processing(arm)>>=
case 'T':
    a = ARGF();
    if(a)
        INITTEXT = atolwhex(a);
    break;
case 'D':
    a = ARGF();
    if(a)
        INITDAT = atolwhex(a);
    break;
@
\l here useful atolwhex

<<[[main()]] command line processing(arm)>>=
case 'R':
    a = ARGF();
    if(a)
        INITRND = atolwhex(a);
    break;
@


<<[[main()]] sanity check INITXXX>>=
if(INITDAT != 0 && INITRND != 0)
    print("warning: -D0x%lux is ignored because of -R0x%lux\n",
        INITDAT, INITRND);
@
\l less important I think


\subsection{Executable entry point, [[5l -E]]}
\label{sec:choice-entry-point}

The entry point of a program can also be modified,
with the [[-E]] option:

<<global INITENTRY>>=
char*	INITENTRY = nil;		/* entry point */
@
<<[[main()]] command line processing(arm)>>=
case 'E':
    a = ARGF();
    if(a)
        INITENTRY = a;
    break;
@
\n -E default _main (or _mainp when -p)

%dup: introl/5l, overview/hello.5
It is set by default to [[_main]] under \plan, 
for reasons explained in Section~\ref{sec:explain-_main}:

<<[[main()]] set INITENTRY>>=
if(INITENTRY == nil) {
    INITENTRY = "_main";
    <<[[main()]] adjust INITENTRY if profiling>>
}
<<[[main()]] if rare condition do not set SXREF for INITENTRY, else>>
  lookup(INITENTRY, 0)->type = SXREF;
@
%old: this was done originally after setting firstp below, but
% better put that earlier I think
%ocaml: I actually do that after loading the objects, once I have a symbol table
%old: the code before was more complex IMHO
% <<[[main()]] set INITENTRY>>=
% if(INITENTRY == nil) {
%     INITENTRY = "_main";
%     <<[[main()]] adjust INITENTRY if profiling>>
%     <<[[main()]] adjust INITENTRY if load_libs>>
% } else {
%     <<[[main()]] if digit INITENTRY>>
% }
% @
% <<[[main()]] adjust INITENTRY if load_libs>>=
% if(load_libs)
%     lookup(INITENTRY, 0)->type = SXREF;
% @
% <<[[main()]] if digit INITENTRY>>=
% if(!(*INITENTRY >= '0' && *INITENTRY <= '9'))
%    lookup(INITENTRY, 0)->type = SXREF;
% @
% The SXREF setting is done only when load_libs and only in the then branch.
% But why not do lookup and set to SXREF the entry point all the time?
% Why only when load_libs? and why not for digit INITENTRY?
% Because if use -l we want possibly INITENTRY to be first instruction?
\t real reason? first obj is entry point? but could -E _start no?

Unless some rare conditions we will explained in 
Section~\ref{sec:loading-libraries-magically},
the symbol for the entry point (usually [[_main]])
is looked up\footnote{
Remember from Section~\ref{sec:version}
that the second argument of [[lookup()]] is a version number
and all global symbols use [[0]] for their version.
}.
This will create a new symbol in the symbol table [[hash]]
as the symbol table is empty at the beginning.
\l ref to semantic of lookup
Then, by setting its section to [[SXREF]], the symbol for the entry
point is marked as a ``wanted'' symbol.
\l bootstrap!
Hopefully the object files or libraries passed on the command
line to [[5l]] will define this symbol. Otherwise,
because of [[SXREF]], an error message will be displayed
at the very end such as:

\begin{verbatim}
$ 5l no_main.5
??none??: entry not text: _main
??none??: _main: not defined
\end{verbatim}
\l first error not great, noise

\subsection{Main flow}
\label{sec:main-flow}

%trans:
We can finally present the main control flow of [[5l]] with
the calls to its main {components}. 
%
The code below follows closely the software architecture
we described in Section~\ref{sec:soft-archi}:

<<[[main()]] cout is ready, LET'S GO(arm)>>=
// first empty instruction
firstp = prg();
lastp = firstp;

// Loading (populates firstp, datap, and hash)
while(*argv)
    objfile(*argv++);
<<[[main()]] load implicit libraries>>

// skip first empty instruction
firstp = firstp->link;
if(firstp == P)
    goto out;

// Resolving
<<[[main()]] resolving phase>>

// Generating (writing to cout, finally)
asmb();

// Checking
undef();
@
%old: used to have set INITENTRY here, but better before I think
\l rename chunkname main flow?
\l why goto out? then 5l world.5 does not call undef and does not complain
\l  for lack of _main
\l could have a function link() just like have assemble() in Assembler.nw?
\l  use stuff from main? then maybe good, can pass them around, more explicit
%ocaml: all those functions that take no args are ugly, they use too
% many globals, e.g., firstp, lastp, I should really rewrite the code
% to be more functional.
% Also return lists so no need sentinel.
\l check needs to be at the end? could be done earlier I think.

The code steps are as follows:
\begin{enumerate}
\item To {\em load} the object files and libraries passed on the command line
(as well as possibly other ``implicit'' libraries as explained in 
Section~\ref{sec:loading-libraries-magically})

\item To {\em resolve} symbols

\item To {\em generate} the executable

\item To {\em check} finally if there are still some undefined symbols
(e.g., whether [[_main]] has been defined)

\end{enumerate}

The first line above allocates an empty instruction with [[prg()]].
This first instruction is used as a {\em sentinel} which simplifies 
code modifying later [[firstp/lastp]]. 
This first empty instruction is then skipped a few lines later.
%
[[prg()]] uses the global [[zprg]] which is set to represent an empty
instruction:
\l well it is not really empty, it is more undefined or to-be-defined

<<constructor prg>>=
Prog*
prg(void)
{
    Prog *p;

    p = malloc(sizeof(Prog));
    *p = zprg;
    return p;
}
@
\l rename! new_instr?
%ocaml: no need, initialize directly

<<global zprg>>=
Prog	zprg;
@
\n zero prg, to initialize new Prog

<<[[main()]] initialize globals(arm)>>=
<<[[main()]] set zprg(arm)>>
@

<<[[main()]] set zprg(arm)>>=
zprg.as = AGOK;
zprg.scond = COND_ALWAYS; 
zprg.reg = R_NONE;
zprg.from.type = D_NONE;
zprg.from.symkind = N_NONE;
zprg.from.reg = R_NONE;
zprg.to = zprg.from;
@
\t BUGS not defined other fields?
%bug: what about .class? should be set to C_NONE no?
%bug? and optab? should be null no? there is code using p->optab like oplook()
%ocaml: no need, use marshall so initialized correctly

All of the constants above, e.g., [[R_NONE]], are defined
in [[include/obj/5.out.h]].
%
The [[AGOK]] (God Only Knows) opcode
\l sure it means god Only Knows? 
represents an  {\em undefined instruction}.
It is recognized by some error management code in [[5l]] 
(see Section~\ref{sec:AGOK})
and used as a form of {defensive programming}.
%ocaml: do not need that I think. typing and exhaustic check is better
% than defensive programming
\l could use AXXX? or ANOP? 
\t actually 5c generates some AGOK, but to continue even when error (meh?)

\bigskip
%toc:
The following sections will each describe one of the
function mentioned in the main flow above.
\n the main components

\section{Loading the objects and libraries, [[objfile()]]}

[[objfile()]] takes either the name of 
an object file (e.g., [[foo.5]]),
or a library (e.g., [[libc.a]]),
and reads the object code in it.
\l other way to link libs we will see later, but they call back objfile
%
First, [[objfile()]] opens and reads a few bytes of the file to decide
whether it is an archive or an object file 
\l why not use filename extension to decide?
by checking if those bytes match an {\em archive magic string} ([[ARMAG]]).
%
Then it loads the file.
The code below shows only the simple case where the file is an object file.
The more complex case where the file is a library will
be described later in Chapter~\ref{chap:loading-libraries}.
\l repeat too much the code?
\t sure no ambiguity with regular object files? Axxx

<<function objfile>>=
/// main | loadlib  -> <>
void
objfile(char *file)
{
    fdt f;
    long len;
    char magbuf[SARMAG]; // magic buffer
    <<[[objfile()]] other locals>>

    DBG("%5.2f objfile: %s\n", cputime(), file);

    <<[[objfile()]] adjust file if -lxxx filename>>

    f = open(file, 0);
    <<[[objfile()]] sanity check f>>

    len = read(f, magbuf, SARMAG);

    // is it a regular object? (not a library)
    if(len != SARMAG || strncmp(magbuf, ARMAG, SARMAG)){
        /* load it as a regular file */
        len = seek(f, 0L, SEEK__END); // len = filesize(f);
        seek(f, 0L, SEEK__START);

        // the important call!
        ldobj(f, len, file);

        close(f);
        return;
    }
    // else
    <<[[objfile()]] when file is a library>>
}
@
%old: renamed l -> len
\l rename objfile -> ldobj and ldobj -> ldinstrs, f -> fd?
\l  as it can actually load a slice of an object, just a procedure
\n portable function! (ldobj is not though)
\l explain DBG? used a bit for profiling here.
%ocaml: Marshall, and use filename extension to differentiate instead of magic?

[[SARMAG]] above stands for [[S]]ize of [[AR]]chive [[MAG]]ic string.
%
The most important part in the code above is the call
to [[ldboj()]] which loads in memory one (opened) object file.
\l or part of a library seeked to right place
Chapter~\ref{chap:loading-objects} will describe [[ldobj()]].

\l essentially modify which globals?
\l  - should modify firstp! and datap, lastp, textp, etc
\l  - will modify libraryp probably, the cool pragma "autolib"
\l    which is why objfile() must be called before loadlib()


<<[[objfile()]] sanity check f>>=
if(f < 0) {
    diag("cannot open %s: %r", file);
    errorexit();
}
@

\section{Resolving symbols, computing addresses}

%trans:
The next step, after loading the objects, is to 
%
resolve the symbol references in those objects and to compute the
final addresses of those symbols.
%
We will delay the explanations about this step to
Chapter~\ref{chap:resolving} where we will see multiple functions
doing multiple passes on the set of instructions
and the symbol table.
\l use firstp/lastp, use hash, build graph of instruction, layout

\section{Generating the executable, [[asmb()]]}
\label{sec:gen-executable}
\l asmb? asm binary? meh

%trans:
After the symbols are resolved, and their memory addresses computed,
%
we can finally generate the executable with [[asmb()]]:

<<function asmb(arm)>>=
/// main -> <>
void
asmb(void)
{
    <<[[asmb()]] locals>>

    DBG("%5.2f asm\n", cputime());

    // Text section
    <<[[asmb()]] Text section>>

    // Data section
    <<[[asmb()]] Data section>>

    // Symbol and Line table sections
    <<[[asmb()]] symbol and line table sections>>

    // Header
    <<[[asmb()]] header section>>

    cflush();
}
@
%ocaml: pass cout as a parameter, and also list of instr, data, hash, etc
\t cflush? shown in appendix, buffer management, cout

[[asmb()]] does not take any argument. It uses the global [[cout]],
which was initialized in [[main()]] with the file descriptor of the 
executable file, to output data in the executable.

Note that the order of operations above may seem incorrect.
The code to generate the header is at the end, which seems paradoxical.
\l even impossible, but SEEK
But, the header specifies the size of the sections,
and so we first need to know those sizes
before generating the header, hence the order of operations.
\l actually textsize/datasize are known already, but not symsize

\l no BSS section because the binary executable will not contain
\l  anything related to BSS except its size.

The code in [[asmb()]] uses and modifies the local variable [[OFFSET]]
below to point to different parts of the executable file. It will be passed
to the C function [[seek()]] to move around in the file.

<<[[asmb()]] locals>>=
long OFFSET;
@
%old: was a global but can be just a local in asmb()
% <<global OFFSET(arm)>>=
% long	OFFSET;
% @


%toc: ???
\t toc? or put before when see high-level view of code/

\subsection{Header}
\label{sec:gen-header}

The header generation (done last) assumes the set of globals
containing the size of sections ([[textsize]], [[datsize]], etc) 
have been computed previously:
\l but actually not in asmb() but in dotext() and dodata()
\l but symsize and lcsize are computed in asmb()

<<[[asmb()]] header section>>=
DBG("%5.2f header\n", cputime());

OFFSET = 0;
seek(cout, OFFSET, SEEK__START);

switch(HEADTYPE) {
<<[[asmb()]] switch HEADTYPE (for header generation) cases(arm)>>
}
@

<<[[asmb()]] switch HEADTYPE (for header generation) cases(arm)>>=
// see Exec in a.out.h
case H_PLAN9:
    <<[[asmb()]] if dynamic module magic header adjustment(arm)>>
    else
        lput(0x647);			/* magic */

    lput(textsize);			/* sizes */
    lput(datsize);
    lput(bsssize);
    lput(symsize);			/* nsyms */

    lput(entryvalue());		/* va of entry */
    lput(0L);
    lput(lcsize);
    break;
@
\t s/0x647/E_MAGIC?
%ocaml: could use intermediate type or use Exec, cleaner.

If you do not understand the order
of the [[lput()]] above, see Section~\ref{sec:exec-format} 
which describes the format of the [[a.out]] header used by \plan.
\t actually lput is long put big-endian


The address of the entry point is looked up in the symbol table
in the [[Sym.value]] field of the [[INITENTRY]] symbol:
\l explained in core DS chapter and in soft archi

<<function entryvalue(arm)>>=
long
entryvalue(void)
{
    char *a;
    Sym *s;

    a = INITENTRY; // usually "_main"
    <<[[entryvalue()]] if digit INITENTRY>>

    s = lookup(a, 0);

    switch(s->type) {
    case SNONE:
        // could warn no _main found?
        return INITTEXT; // no _main, start at beginning of binary then
    case STEXT:
        return s->value;
    <<[[entryvalue()]] if dynamic module case>>
    default:
        diag("entry not TEXT: %s", s->name);
        return 0;
    }
}
@
%old: case SLEAF:
\t rename a and s bad names; s -> sym. a -> ? str?
%ocaml: could at least take initentry as a parameter instead of using a global

\subsection{Text section}
\label{sec:asmb-text-section-overview}

%trans:
The text section generation is of course more complicated.
\l assumes layout code? well redo a bit with pc increment so assume less
%
[[asmb()]] iterates over all the code instructions
and calls [[oplook()]] to get additional information [[o]] about 
the instruction [[p]].
Then it calls the important function [[asmout()]] which
generates actual ARM instructions from [[p]].
[[asmout()]] will also use the global [[cout]] to modify the 
executable file.
\l repeat too much the code?

<<[[asmb()]] Text section>>=
OFFSET = HEADR;
seek(cout, OFFSET, SEEK__START);

pc = INITTEXT;
for(p = firstp; p != P; p = p->link) {
    <<adjust curtext when iterate over instructions p>>
    <<adjust autosize when iterate over instructions p>>
    curp = p;
    <<[[asmb()]] in Text section generation, sanity check pc>>

    o = oplook(p);
    // generate ARM instruction(s)!
    asmout(p, o);

    pc += o->size;
}
<<[[asmb()]] before cflush, debug>>
cflush();

<<[[asmb()]] Text section, output strings in text segment>>
}
@
\t need to be pc? need use the global? I understand for ldobj, but for asmb?
\t  could maybe use local like  realpc ?
%old: o = oplook(p);	/* could probably avoid this call */
% because could just use p->optab cache?
% but ok cos oplook actually uses optab. oplook() memoize things.

[[oplook()]] returns a pointer to an [[Optab]] entry
described in Section~\ref{sec:optab}.

<<[[asmb()]] locals>>=
Prog *p;
Optab *o;
@
\l o is bad name, looks like opcode.

[[oplook()]] essentially looks at the opcode and operands in [[p]] and 
\l pattern match
returns the {kinds} of actual ARM instructions that
will be needed to encode the instruction [[p]].
It also returns the total size of those ARM instructions.
%dup: overview/5l-a and core-ds/instr
Because the ARM uses fixed-length instructions of 4 bytes, 
the total size will be a multiple of 4.

Note that one instruction [[p]] can lead to
the generation of multiple ARM instructions.
%
Indeed, the instructions of the assembly language of [[5a]], 
and so the instructions in the object files, 
do not match exactly ARM instructions.
%
For instance, the {virtual instruction} [[DIV]] has
no counterpart in the ARM and is converted in a series of ARM 
instructions which ends with the call to the function [[_div()]] 
of the core C library.
\t actually noops has rewritten DIV already
\l same for MOVW, also constraints on immediate constant in ARM but not Asm5
\l  but maybe can delay later
See Chapter~\ref{chap:arm-codegen} for more information about
[[Optab]] and [[oplook()]].
\l and \book{Assembler} for more information about virtual instruction?


Note that 
[[OFFSET]] is initialized to [[HEADR]] above while
[[pc]] to [[INITTEXT]].
%dup: overview/principles
Indeed, offsets in the executable and memory addresses
are different concepts, as explained in 
Section~\ref{sec:disk-image-vs-memory-image}.


[[asmb()]] updates also the global [[pc]] above,
but the address resolution of code instructions
(in [[Instr.pc]])
has already been done in [[dotext()]]. This is repeated
here just for sanity checking:
\t hmm but maybe also used for code generation? need that in global? 
\t  as jumps are relative in the ARM!

<<[[asmb()]] in Text section generation, sanity check pc>>=
if(p->pc != pc) {
    diag("phase error %lux sb %lux", p->pc, pc);
    if(!debug['a'])
        prasm(curp);
    pc = p->pc;
}
@
\l actually good to do that, can have bugs where size of things
\l  can have changed (see the mutual dependency issue discussed later)





\subsection{Data section}

%trans:
The data section generation assumes the layout of globals
has already been done  (via [[dodata()]]),
just like the code section generation in the previous
section assumed the layout of code has also been done (via [[dotext()]]).
%dup: overview/tutorial overview/soft-archi, core-ds/sym
The [[Sym.value]] field of all data symbols should now
contain the address of the global
as an offset to the start of the data section, 
\t say here again rational for this vs final address explained in Section X?
\t (INITDAT)? or set actually by asmb?
and [[datsize]] should have been set.


\ifallcode
<<[[asmb()]] locals>>=
long t;
@
\fi

<<[[asmb()]] Data section>>=
curtext = P;
switch(HEADTYPE) {
<<[[asmb()]] switch HEADTYPE (to position after text) cases(arm)>>
}

<<[[asmb()]] if dynamic module, before datblk()>>

for(t = 0; t < datsize; t += sizeof(buf)-100) {
    if(datsize-t > sizeof(buf)-100)
        datblk(t, sizeof(buf)-100, false);
    else
        datblk(t, datsize-t, false);
}
@
\l what the fuss about those 100?? and what is sizeof(buf)?
\l  why not move this logic in datblk itself? cleaner!
\l  anyway leaky abstraction as do n plus Dbufslop behind
\t factorize code for those sizeof(buf)-100? and use Dbufslop?
\t no use of datap?
%ocaml: just fill directly a buffer big enough to hold everything,
% and sort entries

<<[[asmb()]] switch HEADTYPE (to position after text) cases(arm)>>=
case H_PLAN9:
    OFFSET = HEADR+textsize;
    seek(cout, OFFSET, SEEK__START);
    break;
@
%ocaml: use list of words and do lput after lput for text, so no need seek

Note again that the code seeks to [[HEADR+textsize]], which
may not be a page boundary. This is fine
%dup: overview/principles, previous section
since offsets in the executable file are not memory addresses
as explained in Section~\ref{sec:disk-image-vs-memory-image}.

%[[datblk()]] will be explained in Section~\ref{sec:datblk}.

\subsubsection{[[datblk()]]}
\label{sec:datblk}

% use buf.dbuf, from union Buf. See appendix.

% general idea? in bulk?
%alt: ? can not do it in a faster way?

<<constant Dbufslop>>=
#define	Dbufslop	100
@
% ? slop?
% why not use that before? instead of hardcoded 100?
% enough so don't overflow? but I think 8 is enough no (strings
% are the longest DATA)

\l FIGURE! like for input buffer


%sstring is bool used when call datblk for generating strings in text segment
% s is offset in data section
<<function datblk(arm)>>=
void
datblk(long s, long n, bool sstring)
{
    Prog *p; 
    // absolute address of a DATA
    long a; // ulong?
    // size of a DATA
    int c; 
    // index in output buffer for a DATA
    long l;
    // index in value of a DATA
    int i;
    <<[[datblk()]] other locals>>

    memset(buf.dbuf, 0, n+Dbufslop);

    for(p = datap; p != P; p = p->link) {
        <<[[datblk()]] if sstring might continue>>
        // else
        curp = p;

        a = p->from.sym->value + p->from.offset;
        l = a - s;
        c = p->reg;

        i = 0;
        if(l < 0) {
            if(l+c <= 0)
                continue;
            while(l < 0) {
                l++;
                i++;
            }
        }
        if(l >= n)
            continue;
        // else

        <<[[datblk()]] sanity check multiple initialization>>

        switch(p->to.type) {
        <<[[datblk()]] switch type of destination cases>>
        default:
            diag("unknown mode in initialization%P", p);
            break;
        }
    }
    write(cout, buf.dbuf, n);
}
@
\l not very optimal, do many passes on data
%  but GLOBL independent of DATA
%alt: sort datap! by address! (and still can check for overlap!)

\t FIGURE illustrating l, a, s, etc otherwise confusing all those
\t pointers

<<[[datblk()]] other locals>>=
long j;
@
<<[[datblk()]] sanity check multiple initialization>>=
for(j=l+(c-i)-1; j>=l; j--)
    if(buf.dbuf[j]) {
        print("%P\n", p);
        diag("multiple initialization");
        break;
    }
@
%old: if(p->as != AINIT && p->as != ADYNT) {



\subsubsection{[[D_SCONST]]}

%ex: DATA hello+0(SB)/8, "12345678"

<<[[datblk()]] switch type of destination cases>>=
case D_SCONST:
    for(; i<c; i++) {
        buf.dbuf[l] = p->to.sval[i];
        l++;
    }
    break;
@

\subsubsection{[[D_CONST]] and endianess}

%ex: DATA hello+0(SB)/4, 12345678

<<[[datblk()]] other locals>>=
char *cast;
long d;
@
\l use byte instead of char*?


<<[[datblk()]] switch type of destination cases>>=
case D_CONST: case D_ADDR:
    d = p->to.offset;
    <<[[datblk()]] if D_ADDR case>>
    cast = (char*)&d;

    switch(c) {
    case 1:
        for(; i<c; i++) {
            buf.dbuf[l] = cast[inuxi1[i]];
            l++;
        }
        break;
    case 2:
        for(; i<c; i++) {
            buf.dbuf[l] = cast[inuxi2[i]];
            l++;
        }
        break;
    case 4:
        for(; i<c; i++) {
            buf.dbuf[l] = cast[inuxi4[i]];
            l++;
        }
        break;

    default:
        diag("bad nuxi %d %d%P", c, i, curp);
        break;
    }
    break;
@
%old: case SLEAF: 
%pad: I added the case D_ADDR

%\subsubsection{Endianess, [[nuxiinit()]]}

%"unix" in some systems is represented as "nuxi" because of endianess

<<global inuxi1>>=
char	inuxi1[1];
@
<<global inuxi2>>=
char	inuxi2[2];
@
<<global inuxi4>>=
char	inuxi4[4];
@


<<[[main()]] initialize globals(arm)>>=
nuxiinit(); // ???
@

<<function nuxiinit(arm)>>=
void
nuxiinit(void)
{

    int i, c;

    for(i=0; i<4; i++) {
        c = find1(0x04030201L, i+1);
        if(i < 2)
            inuxi2[i] = c;
        if(i < 1)
            inuxi1[i] = c;
        inuxi4[i] = c;
        <<[[nuxiinit()]] in loop i, fnuxi initialisation>>
    }
    <<[[nuxiinit()]] debug>>
    Bflush(&bso);
}
@

<<function find1>>=
int
find1(long l, int c)
{
    char *p;
    int i;

    p = (char*)&l;
    for(i=0; i<4; i++)
        if(*p++ == c)
            return i;
    return 0;
}
@



<<[[nuxiinit()]] debug>>=
if(debug['v']) {
    Bprint(&bso, "inuxi = ");
    for(i=0; i<1; i++)
        Bprint(&bso, "%d", inuxi1[i]);
    Bprint(&bso, " ");
    for(i=0; i<2; i++)
        Bprint(&bso, "%d", inuxi2[i]);
    Bprint(&bso, " ");
    for(i=0; i<4; i++)
        Bprint(&bso, "%d", inuxi4[i]);
    Bprint(&bso, "\nfnuxi = ");
    for(i=0; i<4; i++)
        Bprint(&bso, "%d", fnuxi4[i]);
    Bprint(&bso, " ");
    for(i=0; i<8; i++)
        Bprint(&bso, "%d", fnuxi8[i]);
    Bprint(&bso, "\n");
}
@

\subsubsection{[[D_ADDR]]}

%ex: DATA hello+0(SB)/4, $hello(SB)
% but why want that?

<<[[datblk()]] other locals>>=
Sym *v;
@
<<[[datblk()]] if D_ADDR case>>=
v = p->to.sym;
if(v) {
    switch(v->type) {
    <<[[datblk()]] in D_ADDR case, switch symbol type cases>>
    }
    <<[[datblk()]] if dynamic module(arm)>>
}
@

<<[[datblk()]] in D_ADDR case, switch symbol type cases>>=
case STEXT: case SSTRING:
    d += p->to.sym->value;
    break;
case SDATA: case SBSS:
    d += p->to.sym->value + INITDAT;
    break;
@
%old: did not have break for SDATA SBSS but cleaner
\n no - BIG stuff here, no R12 involved, DATA generated so full address













\subsection{Symbol and line table sections}

The generation of the symbol and line table sections
will be explained in Chapter~\ref{chap:debugging}


\section{Checking for unresolved symbols, [[undef()]]}
\label{sec:undef}

The final step is making sure there is no more
undefined symbols:

<<function undef>>=
/// main -> <>
void
undef(void)
{
    int i;
    Sym *s;

    for(i=0; i<NHASH; i++)
        for(s = hash[i]; s != S; s = s->link)
            if(s->type == SXREF)
                diag("%s: not defined", s->name);
}
@
\l rename check_if_still_undefined_symbols()?
\l famous not defined error msg!
\n could be done after loading I think, but maybe defensive to do it later


%trans: ok seen asmb so at least know where we should go, what
% it the goal (textsize, datsize, Sym.value, Instr.pc, etc)




\chapter{Loading Objects}
\label{chap:loading-objects}
\n Was Parsing obj, but objs are stored in binary format so Loading obj better.
\n Confusing with the loader in the kernel? actually man/1/8l uses "loader".
\n  But 5l is actually also loading/copying data from disk in memory,
\n  a bit like the kernel loader, except it is a different file format.

%trans: %dup: (and quite adapted) from Assembler
Now that we have seen the code or a high-level view of
the code of the main functions of [[5l]], we can
start to go deeper and detail the different components of the
linking pipeline.
%toc
We start in this chapter with the {loading} of object files in memory
performed mostly by [[ldobj()]].
\n 'mostly' because also objfile()
\l actually load, name, partially resolve, populate symbol table, and split
\l  lots of stuff to setup many things in memory.

%ocaml: use Marshall (but less friendly to other languages) and visit/split
% in list of code and data (and return symbol table)

\section{Object file format, [[.5]]}
\label{sec:object-format}

%trans:
Before reading the code of [[ldobj()]]
it is good to have in mind the format of object files.
%
This format is summarized in Figure~\ref{fig:object-format-complete}.
See the \book{Assembler} if you need more explanations.

%dup: from Assembler.nw (just added AHISTORY,ANAME, AXXX, AEND)
\begin{figure}[!]\centering
\begin{verbatim}
+--------------+        ^-------------+
|     AEND     |       /|             |
+--------------+      / |             |
|Instruction 5 |     /  |             |
|              |    /   |  Operand 2  |
+--------------+    |   |             |
|Instruction 4 |    |   |             |
|              |    |   |             |       ^-------------+
+--------------+    |   |             |/-----/|             |
|  ANAME ...   |    |   +-------------X       |             |
+--------------+    |   |             |       |             |
|  ANAME ...   |    |   |             |       |Operand value|
+--------------+    |   |  Operand 1  |       |             |
|              |    /   |             |       |             |
|Instruction 3 |   /    |             |       |             |
|              |  /     |             |       |             |
+--------------+ /      +-------------X       +-------------+
|  ANAME ...   |/       |             |\      | Symbol kind |
+--------------X        |    Line     | \     +-------------+
|Instruction 2 |        |             |  \    |Symbol index |
|              |        |             |   \   +-------------+
+--------------X        +-------------+    \  |  Register   |
|Instruction 1 |\       |  Register   |     \ +-------------+
|              | \      +-------------+      \|Operand kind |
+--------------+  \--\  |  Condition  |       v-------------+
| Files/lines  |      \ +-------------+
|   history    |       \| Axxx Opcode |
|  (AHISTORY)  |        v-------------+
+--------------+

    File                  Instruction             Operand
\end{verbatim}
\caption{Format of a [[.5]] object file.}
\label{fig:object-format-complete}
\end{figure}

\section{A global and local program counter, [[pc]] and [[ipc]]}
\l could be put later? if aspectize code doing ipc = pc in ldobj?

%trans:? before ldobj see important global

%dup: overview/soft-archi, core-ds/instr
A very important global which will be used by [[ldobj()]] is
the {\em virtual program counter}:
\t actually later it become a real program counter

<<global pc>>=
long	pc = 0;
@
%ocaml: does not have to be a global, can be local to loading code

%dup: overview/soft-archi, core-ds/instr
[[ldobj()]] will increment [[pc]] after each code instruction read
as we will see in Section~\ref{sec:opcode-dispatch}.
%
Note that [[pc]] is a {\em global} and so
persists between different calls to [[ldobj()]]. Thus,
all the instructions in the different object files will
have a unique program counter value in their [[Instr.pc]] field.
\l that is the spirit of global concatenation
%
[[ldobj()]] is also using the {\em local} below
to store the value of the program counter at the beginning
of the call:

<<[[ldobj()]] locals(arm)>>=
long ipc;
@
\l internal pc? objects are loaded after each other,

[[ipc]] will be used for {relocating} branching instructions
as we will see in Section~\ref{sec:relocating}.

\section{Object code input, [[ldobj()]]}
\label{sec:ldobj}

%trans:
We can now see the code of [[ldobj()]].
%
The function takes 3 parameters:
[[f]] the file descriptor of the (opened) object file,
[[c]] the size of this object file, and
\l really? can be also size of whole library?
[[pn]] the name of this object file used mostly for error management.
\t rename f -> fd, c -> len, pn -> filename
%
[[ldobj()]] essentially reads instructions from [[f]]
in a loop where each iteration allocates a new instruction
[[p]] with the opcode [[o]] and populates either
[[firstp]] or [[datap]] depending on the opcode.
\l and also [[hash]] for operands, and some opcodes too, and also ANAME

<<[[ldobj()]] locals(arm)>>=
Prog *p;
// enum<Opcode>
short o;
@
\t actually byte would be enough

An important local of [[ldobj()]] is [[bloc]] which is a {\em cursor} in an
{\em input buffer} derived from [[f]] as explained soon in 
Section~\ref{sec:ldobj-input-buffer}.
%
It allows the code which parses instructions to access
individual bytes of an instruction in the object file as 
[[bloc[0]]], [[bloc[1]]], etc. 
\l a bit like it was mmap'ed

<<function ldobj(arm)>>=
/// main -> objfile -> <>
void
ldobj(fdt f, long c, char *pn)
{
    <<[[ldobj()]] locals(arm)>>

    <<[[ldobj()]] remember set of object filenames>>
    <<[[ldobj()]] bloc and bsize init>>

// can come from AEND
newloop:
    // new object file
    ipc = pc;
    <<[[ldobj()]] after newloop when new object file, more initializations>>

loop:
    if(c <= 0)
        goto eof;

    <<[[ldobj()]] read if needed in loop:, adjust bloc and bsize>>

    o = bloc[0];		/* as */
    <<[[ldobj()]] sanity check opcode in range(arm)>>

    // dispatch opcode part one
    <<[[ldobj()]] if ANAME or ASIGNAME(arm)>>
    // else

    p = malloc(sizeof(Prog));
    p->as = o;
    <<[[ldobj()]] read one instruction in p>>
    p->link = P;
    p->cond = P;

    <<[[ldobj()]] sanity check p>>
    <<[[ldobj()]] debug>>

    // dispatch opcode part two
    switch(o) {
    <<[[ldobj()]] switch opcode cases(arm)>>
    }
    goto loop;

eof:
    diag("truncated object file: %s", pn);
}
@
%old: I transformed the code to use malloc instead of gethunk()
%bugfix: again on gethunk, was doing if(nhunk < ...) instead of while(nhunk...)
% the bug seems only in arm, x86 does the correct while
% but Forsyth say anyway a hunk is bigger than a Prog so a if would work too

%trans: %chunks:
[[ldobj()]] is a complex and very long function. 
We split it in many {chunks} to facilitate its comprehension.
%toc:
The rest of this chapter will detail most of those chunks.

Note that the code above looks like a loop which can
finish only in an error. But, one of the chunk
dealing with the [[AEND]] opcode (see Section~\ref{sec:aend}),
hidden in the [[switch]] above,
contains actually a [[return]] which can escape the loop.
%
In fact, [[AEND]] explains also the reason for the two
loop labels [[newloop]] and [[loop]]. Indeed, [[ldobj()]] can
also be used to read a whole library in which case
we want to also iterate over the multiple object files 
contained in one library file, which, as we will see in
Chapter~\ref{chap:loading-libraries},
are separated by the [[AEND]] opcode.

\subsection{Single instruction input}

%trans:
An important chunk of [[ldobj()]] deals with the parsing
of one instruction whose format is described 
in the middle of Figure~\ref{fig:object-format-complete}.
%assembler:
The code below does mostly the reverse operation
of [[outcode()]] in the \book{Assembler}
and {reads} one instruction:


<<[[ldobj()]] read one instruction in p>>=
// mostly opposite of outcode() in 5a
// p->as = bloc[0] has been done already above so continue from bloc[1]
p->scond = bloc[1];
p->reg   = bloc[2];
p->line  = bloc[3] | (bloc[4]<<8) | (bloc[5]<<16) | (bloc[6]<<24);
r = 7;
r += inopd(bloc+r, &p->from, h);
r += inopd(bloc+r, &p->to, h);

bloc += r;
c -= r;
@
% >> >> >>
\l extract func and call incode? so opposite of outcode? 
% (but not good name either)

The code to read an operand uses [[inopd()]] which is shown
in the next section. %clever \ref{sec:inopd}
Its last argument is related to the {\em object file symbol table} and will
be fully explained in Section~\ref{sec:h}.


<<[[ldobj()]] sanity check opcode in range(arm)>>=
if(o <= AXXX || o >= ALAST) {
    diag("%s: line %ld: opcode out of range %d", pn, pc-ipc, o);
    print("	probably not a .5 file\n");
    errorexit();
}
@
\l it is not really a line, it is an estimation of line number
\l  but why not use bloc[3] and so on?
%ocaml: use constructor so no need this check

<<[[ldobj()]] sanity check p>>=
if(p->reg > NREG)
    diag("register out of range %d", p->reg);
@


\subsection{Operand input, [[inopd()]]}
\label{sec:inopd}

%assembler:
[[inopd()]] does mostly the reverse of [[outopd()]]
in the \book{Assembler}
%
and {reads} one operand from the object file.
The format of an operand is described 
in the right of Figure~\ref{fig:object-format-complete}.
%
[[inopd()]] returns the number of bytes that were used to read
this operand as operands can have different size:

<<function inopd(arm)>>=
/// main -> objfile -> ldobj -> <>
static int
inopd(byte *p, Adr *a, Sym *h[])
{
    int size; // returned
    int symidx;
    <<[[inopd()]] other locals>>

    a->type = p[0];
    a->reg = p[1];
    <<[[inopd()]] sanity check register range>>
    symidx = p[2];
    <<[[inopd()]] sanity check symbol range>>
    a->sym = h[symidx];
    a->symkind = p[3];
    <<[[inopd()]] sanity check D_CONST>>

    size = 4;

    switch(a->type) {
    <<[[inopd()]] cases>>
    default:
        print("unknown type %d\n", a->type);
        p[0] = ALAST+1;
        return 0;	/*  force real diagnostic */

    }
    <<[[inopd()]] adjust curauto for N_LOCAL or N_PARAM symkind>>

    return size;
}
@
\t rename a, use opd or something  and DO NOT USE p, use blocp or something
\t ALAST subtle because return 0, but maybe should use errorexit instead
\t  and actually will not work if issue was in first operand as there will
\t  be another call to inopd which may work ... by luck.
\l use AGOK instead of ALAST?
%old: was called zaddr() but I renamed to inopd()
%  similar to zaddr -> outopd in Assembler.nw
%  also c -> symidx
%old: I moved the sanity check of register ranger closer to a->reg
\l could do the set to SXREF when global symbol kind here
\l  instead of in code handling ANAME (and its redundant symkind)

The local [[symidx]] contains a {\em symbol index}
in the object file symbol table [[h]] passed as a parameter. 
This index and the table will be explained in Section~\ref{sec:h},
but the important result is that [[Operand.sym]] will point
to a symbol in the symbol table [[hash]].

The operands have variable size depending on the operand kind:

<<[[inopd()]] cases>>=
// 0 byte
case D_NONE:
case D_REG:
case D_PSR:
    break;

// 1 byte
case D_REGREG:
    a->offset = p[4];
    size++;
    break;

// 4 bytes
case D_CONST:
case D_ADDR:
case D_SHIFT:
case D_OREG:
case D_BRANCH:
    a->offset = p[4] | (p[5]<<8) | (p[6]<<16) | (p[7]<<24);
    size += 4;
    break;

// 8 bytes (NSNAME)
case D_SCONST:
    a->sval = malloc(NSNAME);
    memmove(a->sval, p+4, NSNAME);
    size += NSNAME;
    break;
@
%//case D_OCONST: was with D_SHIFT
% >> >> >> >>
%pad: added D_ADDR case
%ocaml: use ADT

<<[[inopd()]] sanity check register range>>=
if(a->reg < 0 || a->reg > NREG) {
    print("register out of range %d\n", a->reg);
    p[0] = ALAST+1;
    return 0;	/*  force real diagnostic */
}
@

\ifallcode
<<[[inopd()]] sanity check D_CONST>>=
if(a->type == D_CONST && a->symkind != N_NONE) {
    a->type = D_ADDR;
    //print("missing D_CONST -> D_ADDR\n");
    //p[0] = ALAST+1;
    //return 0;	/*  force real diagnostic */
}
//if(a->type == D_ADDR && a->symkind == N_NONE) {
//    print("wrong D_CONST -> D_ADDR\n");
//    p[0] = ALAST+1;
//    return 0;	/*  force real diagnostic */
//}
@
%pad: this is only when migrate D_CONST to D_ADDR,
% to catch code which didn't migrate yet
% but for now it's suspended because 5c migration was wrong
\fi

\subsection{Buffered input, [[buf]]}
\label{sec:ldobj-input-buffer}

%trans:
We can now explain the code connecting [[bloc]] 
to the file descriptor [[f]].
%
To read object files, [[ldobj()]]
uses a global called [[buf]] of type [[Buf]]
as well as many utility functions forming a sort
of {\em input/output buffer management} library. 
This code is quite generic and independent of [[5l]] and so
most of it is described in Appendix~\ref{sec:buffer-management}.
\l they could use libbio?
%ocaml: use stdlib, or load everything at once in memory when marshall
%
The most important thing for this chapter is that [[Buf.ibuf]]
contains an array of bytes, the {\em input buffer}, 
filled from time to time by the function [[readsome()]]. 
A few locals of [[ldobj()]] are pointers in this array:

<<[[ldobj()]] locals(arm)>>=
// array<byte> (slice of buf.ibuf)
byte *bloc;
// ref<byte> (end pointer in buf.ibuf)
byte *bsize;
// remaining bytes, bsize - bloc
int r;
@
%old: was char, but I prefer byte

%dup: loading-obj/ldobj
[[bloc]] is a {\em cursor} in the input buffer which is moved around.
%
It allows the code which parses instructions to access
individual bytes of an instruction in the object file as 
[[bloc[0]]], [[bloc[1]]], etc, 
as we have seen in the previous sections.
%alt: could use mmap?
%
It is initialized to the start of the input buffer:

<<[[ldobj()]] bloc and bsize init>>=
bloc = buf.ibuf;
bsize = buf.ibuf;
@

Figure~\ref{fig:input-buffer} represents the evolution of the state
of [[buf.ibuf]] while the input buffer gets filled by [[readsome()]].
%
The code to fill as needed the input buffer is below:

<<[[ldobj()]] read if needed in loop:, adjust bloc and bsize>>=
r = bsize - bloc;
if(r < 100 && r < c) {		/* enough for largest instruction */
    bsize = readsome(f, buf.ibuf, bloc, bsize, c);
    if(bsize == nil)
        goto eof;
    bloc = buf.ibuf; // readsome() does some memmove()
    goto loop;
}
@
%old: comment was "largest prog" but Prog -> Instr so I changed it.
%bug? if filename or string bigger than 100 in ANAME?
% no because the code above is only for for regular opcodes, not ANAME
\l need goto loop? can not just fallthrough?

%dup: (and adapted) from Assembler
\begin{figure}[!]\centering
\begin{verbatim}
0                                                      8192 
+-------------------------------------------------------+
|                                                       |
+-------------------------------------------------------+
^
|                             
bloc, bsize             r = 0 (< 100)

(a) Empty buffer in buf.ibuf

0                                                      8192
+-------------------------------------------------------+
|42|12|253|        ...                               |43|                       
+-------------------------------------------------------+
^<----------------------------------------------------->^
|              r                                        |
bloc                                                  bsize

(b) After first call to readsome(): returned bsize
\end{verbatim}
\caption{Evolution of input buffer and [[ldobj()]] pointers after [[readsome()]].}
\label{fig:input-buffer}
\end{figure}


The number [[100]] above represents a ``window'' large enough
to read one full instruction from the object file.
%
At some point [[bloc]] will get close to [[bsize]]
and [[readsome()]] will be called again, even if
the input buffer contains still some unprocessed bytes.
%
This simplifies the rest of the code in [[ldobj()]] 
and [[inopd()]] which can
simply access [[bloc[0]]], [[bloc[1]]], etc without
having to worry whether they need to call [[readsome()]] again.

Figure~\ref{fig:input-buffer2} represents the evolution of the state
of [[buf.ibuf]] while the input buffer gets filled another
time by [[readsome()]]. The bytes at the end of the input buffer
are first moved to its beginning and the rest of the buffer is
filled by more data from [[f]].

\begin{figure}[!]\centering
\begin{verbatim}
0                                    8093              8192
+-------------------------------------------------------+
|42|12|253|        ...                |10|   ...     |43|                       
+-------------------------------------------------------+
                                      ^<--------------->^
                                      |                 |
                    ldobj() locals:  bloc   r = 99    bsize
                 readsome() locals:  good     n       stop

(a) before second call to readsome()

0                99                                    8192
+-------------------------------------------------------+
|10|     ...  |43|36| ...                            |57|                       
+-------------------------------------------------------+
^                ^<------------------------------------>^
|                |               n                      |
|               stop                                    |
bloc                                                  bsize

(b) after second call to readsome()
\end{verbatim}
\caption{Evolution of the input buffer and [[readsome()]] pointers.}
\label{fig:input-buffer2}
\end{figure}


<<function readsome>>=
byte*
readsome(fdt f, byte *buf, byte *good, byte *stop, int max)
{
    int n;

    n = stop - good;
    memmove(buf, good, n);
    stop = buf + n;
    n = MAXIO - n;
    if(n > max)
        n = max;
    n = read(f, stop, n);
    if(n <= 0)
        return nil;
    return stop + n;
}
@
%old: argument to memmove was stop - good but n better
\n was in appendix, but too close; only issue is MAXIO but can say it is 8192
\l also need handle max, show figure where bsize is not always
\l  at the very end

\subsection{Object file symbol table, [[h]] and [[ANAME]]}
\label{sec:h}
\n better put before Opcode dispatch so understand use of from->sym in ATEXT
\n also closer to other discussions about object file format and readsome()

%trans:
Object files contain mostly instructions. They contain also 
%
an {\em object file symbol table} which is {\em spread}
in the file and where each entry starts with the [[ANAME]] opcode,
as shown in the left of Figure~\ref{fig:object-format-complete}.
The object file symbol table is also a {\em circular} array.
Its entries define symbols which are then referenced in operands
of some following instructions via a {\em symbol index},
as shown in the right of Figure~\ref{fig:object-format-complete}.

% subsubsection{ANAME format}

%trans:
An important chunk of [[ldobj()]] deals with those [[ANAME]] entries.
%
The format of each {entry} starts with 
the pseudo-opcode [[ANAME]]
followed by the kind, 
symbol index, and 
the name of the symbol as a possible long string terminated with [['\0']].
\t small FIGURE for ANAME format?
\t need kind? well for the SXREF below done only for global symbols.
\t   but could be done in inopd instead?
\t  yes but need for N_INTERN! so bump version and allocate different symbols!
\t   but could be done again in inopd
\t need index? fault-tolerance?
%
See the \book{Assembler} if you need more explanations.

% subsubsection{h}

%dup: (and adapted) from Assembler
The local [[h]] below mimics in memory this circular table:

<<[[ldobj()]] locals(arm)>>=
// array<option<ref<Sym>>>
Sym *h[NSYM];
@

[[NSYM]] is a constant defined in [[include/objs/common.out.h]]
which is also used by [[5a]] and so which was described already
in the \book{Assembler}.
\t include/devel/output/common.out.h  -> include/objs/ 
%assembler:
[[h]] was a global in [[5a]] but is a local variable in [[5l]] as
each object file contains its own symbol table.
\l also was Htab (=~ Sym x symkind) vs Sym
%
The table is reset for each new object file processed:

<<[[ldobj()]] after newloop when new object file, more initializations>>=
memset(h, 0, sizeof(h));
@
\l note newloop! because library have multi object files, multi symbol tables

[[h]] is populated by [[ldobj()]] as the object file is read
and new [[ANAME]] entries are found. [[ldobj()]]
also populates the global symbol table [[hash]] via [[lookup()]].
Figure~\ref{fig:object-h-hash} shows the relation
between those data structures.
%
Remember that the first operand of an instruction like 
[[MOVW foo(SB), R1]] is represented in the object file
as 4 elements, as shown in the right of Figure~\ref{fig:object-format-complete},
using 4 bytes: 
the operand kind ([[D_OREG]]), 
a possible register number ([[R_NONE]]),
a symbol index ([[1]]), and
a symbol kind ([[N_EXTERN]]).
%
This operand is summarized as [[idx:1 EXT]]
in Figure~\ref{fig:object-h-hash}.

\begin{figure}[!]\centering
\begin{verbatim}
+--------------------+                                 +---+
|AEND                |                                 |   |
+--------------------+                                 |   |
|                    |                                 |   |
|...                 |                                 |   |
|                    |                  +----------+   +---+
|                    |                  |...       |<--+-  |
+--------------------+                  +----------+   +---+
|AMOVW idx:2 EXT, R3 |                                 |   |
|                    |          +---+   +----------+   +---+
+--------------------+   +---+  |   |<--|"foo", ...|<--+-  |
|ANAME EXT 2 "bar"   | 49|   |  +---+   +----------+   +---+
+--------------------+   +---+                ^        |   |
|AMOVW R2, idx:1 EXT |   |   |                |        |   |
|                    |   |   |                |        |   |
+--------------------+   |...|                |        |   |
|AMOVW idx:1 EXT, R1 |   |   | +--------------+        |   |
|                    |   |   | |                       |   |
+--------------------+   |   | |                       |   |
|ANAME EXT 1 "foo"   |   +---+ |                       +---+
+--------------------+  2|  -+-+-+                     |   |
|AADD R1, R2, R3     |   +---+ | |      +----------+   +---+
|                    |  1|  -+-+ +----->|"bar", ...|<--+-  |
+--------------------+   +---+          +----------+   +---+
|AHISTORY ...        |  0|   |                         |   |
+--------------------+   +---+                         +---+
                                          Symbols
      Object file          h                           hash
\end{verbatim}
\caption{Example of object file and content of [[h]] and [[hash]].}
\label{fig:object-h-hash}
\end{figure}

% subsubsection{ldobj and ANAME}

We can now see the local variables
and the code of [[ldobj()]] dealing with [[ANAME]]
(and also partially with [[ASIGNAME]] which will be explained 
in section~\ref{sec:ASIGNAME}):

<<[[ldobj()]] locals(arm)>>=
// enum<Sym_kind>
int k;
int symidx;
int v;
// ref<byte> (in Buf.ibuf)
byte *stop;
@
%pad: I introduced symidx, and renamed v -> k, and keep v for version


<<[[ldobj()]] if ANAME or ASIGNAME(arm)>>=
if(o == ANAME || o == ASIGNAME) {
    <<[[ldobj()]] if SIGNAME adjust sig>>

    stop = memchr(&bloc[3], '\0', bsize-&bloc[3]);
    <<[[ldobj()]] if stop is nil refill buffer and retry>>

    k = bloc[1];	/* type */
    symidx = bloc[2];	/* sym */

    bloc += 3;
    c -= 3;

    v = 0; // global version by default
    <<[[ldobj()]] when ANAME opcode, if private symbol adjust version>>

    // this will possibly create new symbols
    s = lookup((char*)bloc, v);

    c -= &stop[1] - bloc;
    bloc = stop + 1;

    <<[[ldobj()]] if sig not zero>>
    <<[[ldobj()]] when ANAME, debug>>

    h[symidx] = s;

    if((k == N_EXTERN || k == N_INTERN) && s->type == SNONE)
        s->type = SXREF;

    <<[[ldobj()]] when ANAME opcode, if N_FILE>>
    goto loop;
}
@
%ocaml: Marshall, oh my god we save so much code by using marshall.
% BUT at least by using intermediate ANAME it can optimize things
% by factorizing for instance signature checking (but maybe can memoize things).
% Also it factorizes code a bit because no need to write instruction visitor
%  for instance to find all the entities. All entity are references are there.
%old: was abusing o to store symidx, r to store version, v to store name
% I introduced instead symidx, v, n;
\n it's not part of the switch, it's done before!
\t what about symbol uses for params and locals with same name than globals?
\t  5a accepts that? conflict?

[[ldobj()]] first extracts the string from the 
[[ANAME]] entry and calls [[lookup()]] on it.
%
This creates a new entry in the symbol table [[hash]],
unless this symbol is a global symbol ([[v == 0]]) which was defined
in another object file loaded before, or if the same symbol
was introduced before in the same object file due to the circular
nature of the object file symbol table.
[[ldobj()]] then updates [[h]] so further references
of the symbol index in operands of instructions coming after
will be transformed in pointers (in [[Operand.sym]]) to the right
symbol entry in [[hash]]. 
%
% subsubsection{inopd and symbol index}
%
Indeed, see the instruction
[[a->sym = h[symidx]]] of [[inopd()]] in Section~\ref{sec:inopd}.
%
We can now also understand the sanity check of the symbol 
index in [[inopd()]]:

<<[[inopd()]] sanity check symbol range>>=
if(symidx < 0 || symidx > NSYM){
    print("sym out of range: %d\n", symidx);
    p[0] = ALAST+1;
    return 0;
}
@
\t use errorexit, not this ALAST trick and return 0

% subsubsection{XXX}

Note also that [[ldobj()]] sets the symbol section to [[SXREF]]
for symbols refering to procedures or globals (e.g., [[foo(SB)]]
but also [[tmp<>(SB)]]) if the symbol was just created.
This symbol is now marked as ``wanted''.
\l for objfile() and loadlib() to correctly work! checked by undef
\t explain partially also why need redundant symkind in ANAME, because
\t  job done here (but could be done instead in inopd() I think)


% subsubsection{buffered input for ANAME}

The reading of an [[ANAME]] entry requires to have the full
string (ending with [['\0']]) in the input buffer:

% buffer management crap again
<<[[ldobj()]] if stop is nil refill buffer and retry>>=
if(stop == nil){
    bsize = readsome(f, buf.ibuf, bloc, bsize, c);
    if(bsize == nil)
        goto eof;
    bloc = buf.ibuf;
    stop = memchr(&bloc[3], '\0', bsize-&bloc[3]);
    if(stop == nil){
        fprint(2, "%s: name too long\n", pn);
        errorexit();
    }
}
@
% >> >>

\subsection{Private symbols and version}

As mentioned in Section~\ref{sec:version}, {private symbols}
in different object files using the same name, e.g., [[tmp<>]] 
in [[foo.5]] and [[tmp<>]] in [[bar.5]], can be differentiated
thanks to a {\em version} number stored in a global:

<<global version>>=
int	version = 0;
@

This version is a unique integer representing an object file
by simply incrementing it each time a new object file is parsed:

<<[[ldobj()]] after newloop when new object file, more initializations>>=
version++;
@

Every reference to a private symbol in an object file then uses
the version corresponding to this object file:

<<[[ldobj()]] when ANAME opcode, if private symbol adjust version>>=
if(k == N_INTERN)
    v = version;
@




\section{Opcode dispatch}
\label{sec:opcode-dispatch}

%trans:
Once an instruction [[p]] with its opcode and operands have been read, 
%
[[ldobj()]] looks at the opcode and modifies different
globals in a [[switch]] on the opcode value.
%toc:
The following sections describe the different cases of this
[[switch]] which are mostly concerned with {pseudo-instructions}.

\subsection{[[A]]$xxx$}
\label{sec:axxx}

The default case corresponds to regular instructions, e.g., [[AMUL]].
%that is non pseudo-instructions:
\n note that ASUB is handled specially to look for opti opportunity
\n  but go back to casedef is optimisation pattern does not match

\label{sec:relocating}
<<[[ldobj()]] switch opcode cases(arm)>>=
default:
casedef:
    <<[[ldobj()]] in switch opcode default case, if skip>>

    // relocation
    if(p->to.type == D_BRANCH)
        p->to.offset += ipc;

    //add_queue(firstp, lastp, p)
    lastp->link = p;
    lastp = p;

    p->pc = pc;
    pc++;
    break;
@
\l how does p->to.offset plus egal ipc; works with library code?
% in objfile it seems we seek to the TEXT procedure we want but
% this procedure may not be the beginning of the object, and
% the D_BRANCH offsets are based on the beginning of the object file no?
%ocaml: easier in C to relocate, in ocaml has to write a visitor
% since we have a more precise (but then irregular) AST.

The code above modifies many of the globals we mentioned before
and illustrates many of the concepts we introduced before.
Here are a few notes about this code:

\begin{itemize}

\item Branching instructions are {relocated} thanks to the local
program counter [[ipc]] which contains the new 
{memory address origin} of the object file containing the instruction
\l well in term of virtual pc still

%dup: overview/soft-archi core-ds/list-instrs
\item The global [[firstp]] (via [[lastp]]) is updated to contain the
new code instruction

%dup: overview/soft-archi core-ds/instr load-obj/global-pc
\item Each instruction gets its [[Instr.pc]] field set to the
value of the program counter at the moment the instruction is read
%dup: ... too many
%(and will contain later the final code address of the instruction)

%dup: overview/soft-archi core-ds/instr load-obj/global-pc
\item The virtual program counter [[pc]] is incremented after
a code instruction is read

\end{itemize}
\n same order than in code



\subsection{[[ATEXT]] and [[autosize]]}

Remember from the \book{Assembler} that
pseudo-instructions use the same format than regular instructions
in the object file.
\n actually everywhere, also in memory, a bit abuse
%
So, for the [[TEXT]] pseudo-instruction, e.g., [[TEXT foo(SB), $8]], %$
the name of the procedure is stored in the first operand 
([[Instr.from]])
while the size for its {local variables} is stored in the second operand 
([[Instr.to]]).
In fact, [[Instr.from.sym]] is a pointer to a symbol in the
symbol table [[hash]] (see the code of [[inopd()]] in Section~\ref{sec:inopd})
where [[Sym.name]] contains the procedure's name:
\l symbol table only for global or procedures, not for locals/params anymore

<<[[ldobj()]] locals(arm)>>=
Sym *s;
@
\t rename sym?

<<[[ldobj()]] switch opcode cases(arm)>>=
case ATEXT:
    <<[[ldobj()]] case ATEXT, if curtext not null adjustments for curauto>>
    curtext = p;
    <<[[ldobj()]] in switch opcode ATEXT case, reset skip>>
    <<[[ldobj()]] in switch opcode ATEXT case, set autosize>>

    s = p->from.sym;
    <<[[ldobj()]] sanity check for ATEXT symbol s>>
    s->type = STEXT;
    s->value = pc;

    // like in default case
    //add_queue(firstp, lastp, p)
    lastp->link = p;
    lastp = p;

    p->pc = pc;
    pc++;

    <<[[ldobj()]] in switch opcode ATEXT case, populate textp>>
    break;
@
%$
\l see curtext

The code is similar to the default case we have seen in 
the previous section.
In addition, 
%the list of procedures in [[textp]] is updated and
the section and value {properties} of the procedure symbol
are modified. In particular, 
%dup: overview/soft-archi core-ds/symbol
[[Sym.value]] contains now
the virtual program counter of the procedure,
%
which will be useful for resolving branching instructions involving
the procedure's name later in Chapter~\ref{chap:resolving}.
\l later Sym.value will be final address
\l Sym.value = Instr.pc here
%
%Note that the code above also increments [[pc]] because as we will see
%in Section~\ref{sec:atext-patching} the [[TEXT]] pseudo-instruction
%can acually be transformed in a real ARM instruction.
%We would not want a branch to the procedure's symbol to be the same
% than a branch to  ...
\t maybe need increment pc independently of this special instruction



<<[[ldobj()]] sanity check for ATEXT symbol s>>=
if(s == S) {
    diag("TEXT must have a name\n%P", p);
    errorexit();
}
if(!(s->type == SNONE || s->type == SXREF)) {
    <<[[ldobj()]] case ATEXT and section not SNONE or SXREF, if DUPOK>>
    diag("redefinition: %s\n%P", s->name, p);
}
@
%old: s->type != SNONE && s->type != SXREF
%ocaml: s == S impossible by construction, stricter ast_asm5.ml
% and I think SNONE could be merged with SXREF

%\subsection{adjusting [[autosize]]}

The size for the local variables of the current procedure
is also stored in a global:

<<global autosize(arm)>>=
long	autosize;
@
\t rename stacksize? curstacksize?
% arm specific? not in x86?
% used a lot by aclass(), for what?
%ocaml: could be a local in a few algorithms instead (e.g., RET rewrite).
% Has to be a global in general? For codegen?


Local variables, also known as {\em automatic variables},
are hold in the {\em stack} of the process.
%
The size for those locals is specified in the procedure
declaration, e.g., 8 in [[TEXT foo(sb), $8]], %$
which will be enough to contain 2 locals using 4 bytes each.
%
In fact, [[5l]] first {rounds} the size at a 4 byte boundary
and then increments it by 4:

<<[[ldobj()]] in switch opcode ATEXT case, set autosize>>=
p->to.offset = rnd(p->to.offset, 4);
autosize = p->to.offset;
autosize += 4;
@
\l could do a diag if not multiple of 4, bug in program IMHO
%old:
% autosize = (p->to.offset+3L) & ~3L;
% p->to.offset = autosize;
%ocaml: has to be a global at this point? can be stricter and diag when not 
% multiple of 4

The reason for the 4 increment is to allocate space in the stack
to {save} the {\em return address} stored in the
{\em link register} [[R14]] (aliased as [[REGLINK]]).
See the \book{Assembler} to refresh your memory
about the {branch and link} instruction and the \plan{}
{calling conventions}.
\t ref to talk more about that in ATEXT patching and RET?

Many algorithms will update [[autosize]] as follows while iterating
over all the instructions, just like they do with [[curtext]]:

<<adjust autosize when iterate over instructions p>>=
if(p->as == ATEXT) {
    autosize = p->to.offset + 4;
}
@



\subsection{[[AGLOBL]]}

%trans:
The code dealing with globals is simpler than the one dealing with procedures.
%
Remember that 
for the [[GLOBL]] pseudo-instruction, e.g., [[GLOBL hello(SB), $12]], %$
the symbol of the global is stored in the first operand  ([[Instr.from]])
while its optional size is stored in the second operand ([[Instr.to]]):

<<[[ldobj()]] switch opcode cases(arm)>>=
case AGLOBL:
    s = p->from.sym;
    <<[[ldobj()]] sanity check for AGLOBL symbol s>>
    s->type = SBSS; // for now; will be set maybe to SDATA in dodata()
    s->value = (p->to.offset > 0) ? p->to.offset : 0;
    break;
@
%old: 
%    s->value = 0;
%    if(p->to.offset > s->value)
%        s->value = p->to.offset;
\l sanity check people entering negative size for the globals? can happen?
\l could be even more succint?
\t offset? has a meaning?
%ocaml: forbid offset by construction

No list of instructions is modified. The only effect of a [[GLOBL]]
{declaration} is the modification of a symbol in the symbol table. 
It is the [[DATA]] pseudo-instructions which populate the data section
as we will see in the next section.
%dup: overview/tutorial overview/soft-archi core-ds/sym main/gen/data
Note that for now [[Sym.value]] contains the size of the global.
%Later it will contain the resolved memory address of the global
%(as an offset to the start of the data section).

<<[[ldobj()]] sanity check for AGLOBL symbol s>>=
if(s == S) {
    diag("GLOBL must have a name\n%P", p);
    errorexit();
}
if(!(s->type == SNONE || s->type == SXREF))
    diag("redefinition: %s\n%P", s->name, p);
@
%ocaml: s == S impossible by construction
%old: the second check used to be written differently, but I prefer
% it this way to mimic more what we do for ATEXT
%old:
%		if(s->type == 0 || s->type == SXREF) {
%			s->type = SBSS;
%			s->value = 0;
%		}
%		if(s->type != SBSS) {
%			diag("redefinition: %s\n%P", s->name, p);
%			s->type = SBSS;
%			s->value = 0;
%		}

\subsection{[[ADATA]]}

The code dealing with [[DATA]] pseudo-instructions is trivial.
It just populates [[datap]]:

<<[[ldobj()]] switch opcode cases(arm)>>=
case ADATA:
    <<[[ldobj()]] sanity check for ADATA symbol s>>

    //add_list(datap, p)
    p->link = datap;
    datap = p;

    break;
@

Note that we could set the section of the symbol to [[SDATA]]
here with code like [[s->type = SDATA;]]. But this would
complicate the code to detect redefinition of symbols
in the previous section. Indeed, [[DATA]] pseudo-instructions
can precede a [[GLOBL]] declaration.
This is why the modification of the section to [[SDATA]]
is done in [[dodata()]] later instead.


<<[[ldobj()]] sanity check for ADATA symbol s>>=
if(p->from.sym == S) {
    diag("DATA without a sym\n%P", p);
    break;
}
@
%ocaml: impossible by construction, stricter AST ftw

\subsection{[[AEND]]}
\label{sec:aend}

[[AEND]] is a pseudo-opcode inserted as the end of each object file
by the assembler or compiler.
%dup: (and adapted a little) from Assembler
It is a {\em special marker} convenient to have 
when dealing with {libraries}. Indeed, libraries are little
more than object files concatenated together, as we will
see in Chapter~\ref{chap:loading-libraries},
and [[AEND]] marks represent object {boundaries}.

<<[[ldobj()]] switch opcode cases(arm)>>=
case AEND:
    <<[[ldobj()]] case AEND, curauto adjustments with curhist>>
    <<[[ldobj()]] case AEND, curauto adjustments>>
    curtext = P;

    if(c)
        goto newloop;
    return;
@
%ocaml: no need that if use Marshall, end of list is recognized

The important instruction above is [[return]] which
allows to exit from [[ldobj()]] without any error.
%
\l when goto newloop? when have stuff behind an AEND?
\l for library? aggregate to have AEND between files?
\l see next chapter.
\t but seems like objfile call ldobj with len for just object file
\t  so not sure why need newloop.

\l really need AEND? anyway header of .ar have size of objects so ...
\l  or it is useful for redundancy, fault-tolerance?

\subsection{[[AGOK]]}
\label{sec:AGOK}

[[AGOK]] (God Only Knows) is a pseudo-opcode used
to initialize new instructions in [[5l]]. It is also used
for the same reason in [[5c]].
\n in 5a? there is no Instr, just outcode
It should always be overridden at some point by a real opcode, 
hence the warning code below:
\l defensive programming? it continues? no errorexit?

%sanity:
<<[[ldobj()]] switch opcode cases(arm)>>=
case AGOK:
    diag("unknown opcode\n%P", p);
    p->pc = pc;
    pc++;
    break;
@
%x86:     diag("%s: GOK opcode in %s", pn, TNAME);
%ocaml: do not use, initialize instructions directly with right opcode
\l could use AXXX? or ALAST?




\section{Safe linking}
\label{sec:ASIGNAME}
\n in adv topic? safe linking is an essential feature IMHO!
%ocaml: cool, like in ocamlc! ocaml does that too, to make linking more safe!

An interesting feature of object files and [[5l]], 
not present in traditional linkers,
\l the Linux kernel has something related to that
is the possibility 
(1) to attach {\em signatures} to symbols in object files, and 
(2) to check for {\em signature compatibility} when the same symbol
is mentioned multiple times in different object files.
%
This makes linking far {safer}.

\subsection{Motivations}

Imagine the following scenario: a file [[foo.c]]
defines a function [[foo()]] taking two integer parameters
and not returning anything.
The function is exported in a header file [[foo.h]].
Another file [[bar.c]] is including the header and
calls [[foo()]] with two integers. Both files
are compiled resulting in the object files [[foo.5]] and [[bar.5]] which
can be linked together.
%
Later on, an additional
parameter is added to [[foo()]] in [[foo.h]] and [[foo.c]]
and [[foo.c]] is recompiled leading to a new [[foo.5]] object file.
%
At this point, without signatures, there is nothing that prevents
the new [[foo.5]] and 
the old [[bar.5]] 
to be linked together to form an executable.
%
Traditional linkers will happily link those object
files resulting in an executable
which, at run-time, will not have the right behavior
([[bar.5]] contains a call to [[foo()]] with not enough parameters).


Of course, many projects use a [[Makefile]] where accurate
file dependencies can alleviate the issue.
%
You can specify manually for instance that [[bar.5]] depends also
on [[foo.h]]. Then, any modification of [[foo.h]] will trigger automatically
the regeneration of [[bar.5]].
%
Dependencies can also be automatically generated by tools like [[gcc -MM]].
%
Still, it is easy to make mistakes and miss some dependencies,
or to forget to use {shared headers},
in which case there is no tool to detect the possible linking
of incompatible object files (except by running the executable
and get occasionally a segmentation fault).

\subsection{[[ASIGNAME]] and [[5c -T]]}

When two C files reference the same entity,
we want to enforce that those two references have the same {\em type}.
\l enforced by compiler via shared header, at least compatible type.
\l actually not really enforced by compiler, can do wrong extern declaration
\l  if not using shared header
%
[[ASIGNAME]] is a pseudo-opcode generated by [[5c]] 
when using the [[-T]] option ([[T]] for type)
which attaches a {\em signature} to a symbol. It is an alternate to
[[ANAME]] with additional 4 bytes after the [[ASIGNAME]] opcode,
and before the symbol kind, to store a signature
as a [[ulong]]:

<<[[ldobj()]] locals(arm)>>=
ulong sig;
@
<<[[ldobj()]] if SIGNAME adjust sig>>=
sig = 0;
if(o == ASIGNAME){
    sig = bloc[1] | (bloc[2]<<8) | (bloc[3]<<16) | (bloc[4]<<24);
    bloc += 4;
    c -= 4;
}
@
% >> >> >> >>

This signature is stored as another symbol property:

<<[[Sym]] other fields>>=
// for instance last 32 bits of md5sum of the type of the symbol
ulong   sig;
@
%old: was long, but not consistent with ulong sig; local in ldobj

<<[[ldobj()]] if sig not zero>>=
if(sig != 0){
    <<[[ldobj()]] signature compatibility check>>
    s->sig = sig;
    <<[[ldobj()]] remember file introducing the symbol>>
}
@


In practice, signatures are {derived} from the type
of an entity by the compiler. 
%
For instance, in our scenario above,
the signature of [[foo()]] in the object file could
be the result of the last 32-bits of the {\em md5sum} of the string
representing the type, e.g., [[md5sum("void(int,int)") == 0x4a2489a1]].
%
This signature would be attached to the symbol [[foo]] in
[[foo.5]] and [[bar.5]].
%
Later on, when an integer parameter
is added, the signature of [[foo]] in [[foo.5]] would become
[[md5sum("void(int,int,int)") == 0x74100cff]].
%
The linking of the new [[foo.5]] and old [[bar.5]] would then
be detected and prevented by the code below:


<<[[ldobj()]] signature compatibility check>>=
if(s->sig != 0 && s->sig != sig)
    diag("incompatible type signatures %lux(%s) and %lux(%s) for %s", 
         s->sig, filen[s->file], 
         sig, pn, 
         s->name);
@
\n but must have every object file use ASIGNAME. If one use ANAME no check.

The actual algorithm used by [[5c]] to compute the signature
is actually not the md5sum. See the \book{Compiler}
to learn more about how signatures are generated.
\l by default 5c generates ANAME instead of ASIGNAME

\n can disable locally with #pragma incomplete Xxx (useful, see draw.h issue)
\n  or with #pragma incomplete _off_  and _on_

\subsection{Error management}

To give good error messages like:

\begin{verbatim}
$ 5l foo.5 misc.5 bar.5 /arm/lib/libc.a 
bar: incompatible type signatures bde91c57(foo.5) and adb3322b(bar.5)
  for foo
\end{verbatim}
%pad: I split on two lines

\noindent one needs to remember in the symbol which file introduced
the symbol the first time. 
[[Sym.file]] below contains an {\em index}
in the private array [[filen]] representing the file:

<<[[Sym]] other fields>>=
// index in filen[]
ushort  file;
@
%bug?  ushort? so can link 65536 files maximum
%ocaml: just use string directly, it will be shared for free!

<<[[ldobj()]] locals(arm)>>=
// growing_array<option<string>>  (grown for every 16 elements)
static char **filen;
// index of next free entry in filen
static int files = 0;
@

<<[[ldobj()]] remember set of object filenames>>=
<<[[ldobj()]] grow filen if not enough space>>
filen[files++] = strdup(pn);
@

<<[[ldobj()]] remember file introducing the symbol>>=
s->file = files-1;
@

[[filen]] is actually a {\em growing array}:

<<[[ldobj()]] locals(arm)>>=
char **nfilen; // new filen
@
<<[[ldobj()]] grow filen if not enough space>>=
if((files&15) == 0){
    nfilen = malloc((files+16)*sizeof(char*));
    memmove(nfilen, filen, files*sizeof(char*));
    free(filen);
    filen = nfilen;
}
@
\n =~ realloc

Thanks to [[Sym.file]] and [[filen]], the two conflicting files
can be displayed by the (repeated) code below:
\begin{verbatim}
diag("incompatible type signatures %lux(%s) and %lux(%s) for %s", 
    s->sig, filen[s->file], 
    sig, pn, 
    s->name);
\end{verbatim}



%\section{File and line information, [[AHISTORY]]}
% see debugging section







\chapter{Loading Libraries TODO}
\label{chap:loading-libraries}

%trans:
% next in linking pipeline is loading library. Actually also
% performed partly by ldobj(). library is set of objects
% so call ldobj too.

% 5l actually loads only the object files in the libraries containing 
% the functions/data which are mentioned by the main object files
% (starting from _main).
% So it removes lots of code which helps generate small binaries 
% (see helloc which is only 4618 bytes).
% Note that the granularity is the object file; if it was the function/data
% it could remove even more code.

% see 5l -W -v helloc.5 to see the different passes, which symbols
% are needed, which object files in the archive are read, which ANAME
% are processed, etc.

\section{Archive library format, [[.a]]}

% see ar(5) man page

% from ar.h
<<constant ARMAG>>=
#define	ARMAG	"!<arch>\n"
@
% ARchive MAGic?

<<constant SARMAG>>=
#define	SARMAG	8
@
%size ARMAG

<<constant ARFMAG>>=
#define	ARFMAG	"`\n"
@
% ARchive F? MAGic
% separator between each ar_hdr entries?

<<constant SARNAME>>=
#define SARNAME	16
@
%size ARNAME
% so can't have symbol names of more than 16 characters?

% seems to be the symbol file header and also each file entry header
<<struct ar_hdr>>=
struct	ar_hdr
{
    char	name[SARNAME];

    char	date[12];
    char	uid[6];
    char	gid[6];
    char	mode[8];

    char	size[10]; // use atolwhex() to get the value
    char	fmag[2]; // ARFMAG
};
@
%less: s/char/byte!

% an archive contains:
% MAGIC header "<arch"
% symbol table which is a kind of map from symbol to file entry offset
% file entry header
% object file content
% file entry header
% object file content
% ...

<<constant SAR_HDR>>=
#define	SAR_HDR	(SARNAME+44)
@
% sizeof(struct ar_hdr)


<<global symname linker>>=
char	symname[]	= SYMDEF;
@
% in 5.out.h #define	SYMDEF "__.SYMDEF"
% the first ar_hdr entry is the symbol table.

%todo: What is the format of the symbol table?
% see the strchr(e+5, ...) below, it's weird

%I could not originally see how ldobj() could work
% when you seek to an individual TEXT. Indeed the branch jumps
% are absolute with the 0 basis as the first instruction in the file,
% not the first instruction in the procedure. It's because you
% actually don't seek to individual function. The symbol table
% contains offsets for symbols which are not the offset of their TEXT
% but the offset of their object file entry in the archive file.

% AEND boundary mark

\section{Loading libraries manually, [[5l libxxx.a]]}

<<[[objfile()]] other locals>>=
struct ar_hdr arhdr;
long off, esym, cnt;
Sym *s;
char pname[LIBNAMELEN];
char name[LIBNAMELEN];
char *e, *start, *stop;
bool work;
int pass = 1;
@



<<[[objfile()]] when file is a library>>=
DBG("%5.2f ldlib: %s\n", cputime(), file);

len = read(f, &arhdr, SAR_HDR);

<<[[objfile()]] sanity check library header size and content>>

esym = SARMAG + SAR_HDR + atolwhex(arhdr.size);
off = SARMAG + SAR_HDR;

/*
 * just bang the whole symbol file into memory
 */
seek(f, off, 0);
cnt = esym - off;
start = malloc(cnt + 10);
cnt = read(f, start, cnt);
if(cnt <= 0){
    close(f);
    return;
}
stop = &start[cnt];
memset(stop, '\0', 10);

work = true;
while(work) {

    DBG("%5.2f library pass%d: %s\n", cputime(), pass, file);
    pass++;
    work = false;
    for(e = start; e < stop; e = strchr(e+5, 0) + 1) {

        s = lookup(e+5, 0);
        // loading only the object files containing symbols we are looking for
        if(s->type == SXREF || 
           (s->type == SNONE && strcmp(s->name, "main") == 0)) {
            sprint(pname, "%s(%s)", file, s->name);
            DBG("%5.2f library: %s\n", cputime(), pname);
            
            len = e[1] & 0xff;
            len |= (e[2] & 0xff) << 8;
            len |= (e[3] & 0xff) << 16;
            len |= (e[4] & 0xff) << 24;
            // >> >> >> >>
            
            seek(f, len, SEEK__START);
            len = read(f, &arhdr, SAR_HDR);
            <<[[objfile()]] sanity check entry header>>
            len = atolwhex(arhdr.size);

            // loading the object file containing the symbol
            ldobj(f, len, pname);
            
            if(s->type == SXREF) {
                diag("%s: failed to load: %s", file, s->name);
                errorexit();
            }
            work = true; // maybe some new SXREF has been found in ldobj()
           <<[[objfile()]] an SXREF was found hook>>
        }
    }
}
return;

bad:
    diag("%s: bad or out of date archive", file);
out:
    close(f);
@

% >> >> >>

%old:
%        /* need readn to read the dumps (at least) */
%        l = readn(f, &arhdr, SAR_HDR);
% but seems ugly, readn in lib_core/libc/port/readn.c seems to just
% do some repetitive read()

% double loop!  while work, for ;;
% this is where we include all relevant entities(actually object files), 
% and only those!!!
% so 5l can produce small binaries (good because plan9 does not have
% shared libraries).
% Remember that lookup returns a symbol with SNONE when it didn't
% find a symbol (not SXREF).
% This is also why we do the lookup(INITENTRY, 0)->type = SXREF
% in main to force the loading of the object defining _main in libc.a
% which in turn will provoke the loading of more code.

%ugly: I added a special hack regarding "main" because of ocamlc.
% in ocamlc the main() is in libcamrun.a, so in the library, but
% library passed to the command line are not considered magic libs
% where a fixpoint is done for mutually dependent libs (see section
% below), so I had to cheat.

<<[[objfile()]] sanity check library header size and content>>=
if(len != SAR_HDR) {
    diag("%s: short read on archive file symbol header", file);
    goto out;
}
if(strncmp(arhdr.name, symname, strlen(symname))) {
    diag("%s: first entry not symbol header", file);
    goto out;
}
@

<<[[objfile()]] sanity check entry header>>=
if(len != SAR_HDR)
    goto bad;
if(strncmp(arhdr.fmag, ARFMAG, sizeof(arhdr.fmag)))
    goto bad;
@


\section{Loading libraries semi automatically, [[5l -lxxx]]}
\label{sec:loading-libraries-semi-auto}

\subsection{Library search path}

<<global libdir>>=
// growing_array<dirname>
char**	libdir;
@

<<global nlibdir>>=
// index of next free entry in libdir
int	nlibdir	= 0;
@

<<global maxlibdir>>=
// index of last free entry in libdir
static	int	maxlibdir = 0;
@


\subsection{[[5l -L]]}

<<[[main()]] command line processing(arm)>>=
case 'L':
    addlibpath(EARGF(usage()));
    break;
@


% was called 'a', but root is a better name
<<[[main()]] locals(arm)>>=
char *root;
@

<<constant LIBNAMELEN>>=
#define LIBNAMELEN  300
@

% used locals? move closer the the code that use it then
<<[[main()]] locals(arm)>>=
int c;
char name[LIBNAMELEN];
char *a;
@
% *a still needed now that renamed to root?


<<[[main()]] addlibpath("/{thestring}/lib") or ccroot>>=
<<[[main()]] change root if ccroot>>

// usually /{thestring}/lib/ as root = ""
snprint(name, sizeof(name), "%s/%s/lib", root, thestring);
addlibpath(name);
@

% possible to change default / search path
<<[[main()]] change root if ccroot>>=
root = getenv("ccroot");

if(root != nil && *root != '\0') {
    if(!fileexists(root)) {
        diag("nonexistent $ccroot: %s", root);
        errorexit();
    }
}else
    root = "";
@
%$








<<function addlibpath>>=
void
addlibpath(char *arg)
{
    char **p;

    // growing array libdir
    if(nlibdir >= maxlibdir) {
        if(maxlibdir == 0)
            maxlibdir = 8;
        else
            maxlibdir *= 2;
        p = malloc(maxlibdir*sizeof(*p));
        <<[[addlibpath()]] sanity check p>>
        memmove(p, libdir, nlibdir*sizeof(*p));
        free(libdir);
        libdir = p;
    }

    libdir[nlibdir++] = strdup(arg);
}
@

<<[[addlibpath()]] sanity check p>>=
if(p == nil) {
    diag("out of memory");
    errorexit();
}
@

\subsection{[[5l -lxxx]]}

% actually can also load them manually by specifing the full
% path of the .a with the lib prefix.

% when done manually by -l in command line of ld
<<[[objfile()]] adjust file if -lxxx filename>>=
if(file[0] == '-' && file[1] == 'l') {
    snprint(pname, sizeof(pname), "lib%s.a", file+2);
    e = findlib(pname);
    if(e == nil) {
        diag("cannot find library: %s", file);
        errorexit();
    }
    snprint(name, sizeof(name), "%s/%s", e, pname);
    file = name;
}
@

<<function findlib>>=
char*
findlib(char *file)
{
    int i;
    char name[LIBNAMELEN];

    for(i = 0; i < nlibdir; i++) {
        snprint(name, sizeof(name), "%s/%s", libdir[i], file);
        if(fileexists(name))
            return libdir[i];
    }
    return nil;
}
@



\section{Loading libraries automagically, [[#pragma lib "libxxx.a"]]}
\label{sec:loading-libraries-magically}

% another nice and original thing of plan9 linker, with safe linking,
% is automatic library linking. Just include header and its library
% will be linked automatically! Avoid long linking command,
% remember set of libs
% (hmm but still need in theory to put them in mkfile for dependency
% tracking? maybe not)


% pn? filename of object file, but addlib() really abuse histfrog global
<<[[ldobj()]] in AHISTORY case, if pragma lib>>=
if(p->to.offset == -1) {
    addlib(pn);
    histfrogp = 0;
    goto loop;
}
@
% ugly special value -1 for AHISTORY, see Assembler

%old:
% <<[[main()]] locals(arm)>>=
% bool load_libs;
% @
% <<[[main()]] initialize globals(arm)>>=
% load_libs = !debug['l'];
% @
% (but actually not a global)
%
% load_libs was new local added by me (but maybe was in x86 originally)
% but it does not help actually.

% -l means no automagic stdlibs
% when -l alone it means no startup lib

<<[[main()]] load implicit libraries>>=
if(!debug['l'])
    loadlib();
@

<<[[main()]] if rare condition do not set SXREF for INITENTRY, else>>=
if(debug['l']) {}
else
@
% useful for kernel!

\l By creating a new entry and setting it to SXREF (default is SNONE) we will
\l force in loadlib() to consider _main as a starting point as we marked
\l it as an undefined (undefined but looked for!).



%\section{Loading the libraries, [[loadlib()]]}
% used to be in Main functions, but it is an advanced feature


% It loads the libraries mentioned in the .5 via the .h and #pragma magic!
% (see later section)
% ldobj() is actually also loading libraries when they are mentioned
% explicitly as in 5l ... libxxx.a or via 5l ... -lxxx

% but this chunk will be explained later.
%    <<[[objfile()]] when file is a library>>
% regarding the automatic libs, see below.


% so loading objects with ldbobj() will modify some of the globals below

% then if(load_libs) loadlib()  in the main flow

<<global library>>=
// array<option<filename>>
char*	library[50];
@
% addlib() modifies this global


<<global libraryp>>=
// index of first free entry in library array
int	libraryp;
@

% the .5 that mentioned a library via a #pragma? for debugging purpose?
<<global libraryobj>>=
char*	libraryobj[50];
@



% SIMPLE VERSION
<<function loadlib simple version>>=
void
loadlib(void)
{
    int i;

    for(i=0; i<libraryp; i++) {
        DBG("%5.2f autolib: %s (from %s)\n", cputime(), library[i], libraryobj[i]);
        objfile(library[i]);
    }
}
@
% simple version because in practice we want to allow mutually 
% dependent libs, see section later





%\section{Mutually dependent libraries}
% in advanced topic?


<<function loadlib>>=
void
loadlib(void)
{
    int i;
    long h;
    Sym *s;
loop:
    <<[[loadlib()]] reset xrefresolv>>
    for(i=0; i<libraryp; i++) {
        DBG("%5.2f autolib: %s (from %s)\n", cputime(), library[i], libraryobj[i]);
        objfile(library[i]);
    }
    <<[[loadlib()]] if xrefresolv>>
}
@

% this allows to have mutually dependent libraries, but I don't think
% it's a good idea, ocaml does not allow it.
%% If people have mutually dependent, they'll have to mention
%% the same lib multiple time on the command line!

% but ironically ocamlc requires to have support for mutually 
% dependent libraries :) indeed under plan9 I pass
% libcamlrun.a which defines main, but depend on ape/libap.a which
% defines an _main which calls a main.

% note that this is only for the libs in librarp, so only
% for the automagic libraries! Not for the libs passed on the
% command line

<<global xrefresolv>>=
bool	xrefresolv;
@

<<[[loadlib()]] reset xrefresolv>>=
xrefresolv = false;
@

<<[[loadlib()]] if xrefresolv>>=
if(xrefresolv)
    for(h=0; h<nelem(hash); h++)
         for(s = hash[h]; s != S; s = s->link)
             if(s->type == SXREF) {
                 DBG("symbol %s still not resolved, looping\n", s->name);//pad
                 goto loop;
             }
@
% still some unresolved symbols, loop

<<[[objfile()]] an SXREF was found hook>>=
xrefresolv = true;
@













% when done automatically

<<function addlib>>=
/// ldobj(case AHISTORY and local_line == -1 special mark) -> <>
void
addlib(char *obj)
{
    char fn1[LIBNAMELEN], fn2[LIBNAMELEN], comp[LIBNAMELEN];
    char *p, *name;
    int i;
    bool search;

    if(histfrogp <= 0)
        return;

    name = fn1;
    search = false;
    if(histfrog[0]->name[1] == '/') {
        sprint(name, "");
        i = 1;
    } else if(histfrog[0]->name[1] == '.') {
        sprint(name, ".");
        i = 0;
    } else {
        sprint(name, "");
        i = 0;
        search = true;
    }

    for(; i<histfrogp; i++) {
        snprint(comp, sizeof comp, histfrog[i]->name+1);

        // s/$0/<thechar>/
        for(;;) {
            p = strstr(comp, "$O");
            if(p == nil)
                break;
            memmove(p+1, p+2, strlen(p+2)+1);
            p[0] = thechar;
        }
        // s/$M/<thestring>/
        for(;;) {
            p = strstr(comp, "$M");
            if(p == nil)
                break;
            if(strlen(comp)+strlen(thestring)-2+1 >= sizeof comp) {
                diag("library component too long");
                return;
            }
            memmove(p+strlen(thestring), p+2, strlen(p+2)+1);
            memmove(p, thestring, strlen(thestring));
        }

        if(strlen(fn1) + strlen(comp) + 3 >= sizeof(fn1)) {
            diag("library component too long");
            return;
        }
        if(i > 0 || !search)
            strcat(fn1, "/");
        strcat(fn1, comp);
    }

    cleanname(name);

    if(search){
        p = findlib(name);
        if(p != nil){
            snprint(fn2, sizeof(fn2), "%s/%s", p, name);
            name = fn2;
        }
    }


    for(i=0; i<libraryp; i++)
        if(strcmp(name, library[i]) == 0)
            return;
    if(libraryp == nelem(library)){
        diag("too many autolibs; skipping %s", name);
        return;
    }

    p = malloc(strlen(name) + 1);
    strcpy(p, name);
    library[libraryp] = p;
    p = malloc(strlen(obj) + 1);
    strcpy(p, obj);
    libraryobj[libraryp] = p;
    libraryp++;
}
@




% rare condition not lookup






\chapter{Resolving}
\label{chap:resolving}

%trans:
Once the object files and libraries have been loaded, 
the next step in the linking pipeline is to
%
{resolve} the symbol references in the instructions of those object files.
Here is the responsible code:

<<[[main()]] resolving phase>>=
<<[[main()]] if export table or dynamic module(arm)>>

patch();
<<[[main()]] call doprofxxx() if profiling>>
noops();

dodata();
dotext();
@
%old: I modified the original code, to simplify, to look more symetric
%   patch();
%   <<[[main()]] call doprofxxx() if profiling>>
%   dodata();
%   follow();
%   if(firstp == P)
%       goto out;
%   noops();
%   span();
% so:
% - span() -> dotext()
% - I think follow() is optional, and the order can be changed as
%   some steps are independent I think. 
% - the test for firstp is not useful I think if you remove follow.

%toc: %dup: overview/soft-archi
[[patch()]] builds a graph of code instructions,
[[noops()]] rewrites virtual instructions in machine instructions,
\n well still not completely real though
[[dodata()]] {layout} data by assigning a memory address to each
\n actually offset
globals, and finally
[[dotext()]] does a similar thing for the code, assigning a 
{real code address} to each instruction.

%toc:
In the first section of this chapter we will discuss the different
issues in symbol resolution. We will also explain the need for
the 4 functions above and the rational for the order of their calls.
Then, the following sections will each explain one of the 4 functions
above.
\l then final discussions xdefine, SB/R12

\section{Issues in symbol resolution}

The linker has mainly two kinds of references to resolve: 
\begin{itemize}
\item {\em Code references} in branching instructions,
e.g., [[BL foo(SB)]], which ultimately should be transformed
in an ARM instruction with, as an operand, a concrete address in
the {code section}, e.g., [[BL 0x1020]]
\l actually ARM use relative jumps
\l can jump to a data?
\n there is also code ref in memory instructions
\n   [[MOVW $foo(SB), R1]] %$

\item {\em Data references} in memory instructions, 
e.g., [[MOVW hello(SB), R1]], which ultimately should
be transformed in an ARM instruction with, as an operand,
a concrete address in the {data section}, e.g., [[LDR 0x7014(R0), R1]].
\footnote{Remember from the \book{Assembler} that [[MOVW]] is 
actually a {virtual instruction} which unifies the two
separate ARM instructions [[LDR]] (load register) and [[STR]] (store register).
}
\n actually not  0x7014 but 0x14(R12), and actually not even than because of BIG
\n actually has also memory reference in DATA instruction? ximm can have addr

\end{itemize}

Note that some branching instructions have been
{partially resolved} at this point.
\l D_BRANCH
%
Indeed, 
branching to a {label} (e.g., [[B loop]]), or 
{relative jumps} using the pseudo-register [[PC]] (e.g., [[B 2(PC)]]),
have already been resolved and converted by the assembler [[5a]] in
{\em absolute jumps} (e.g., [[B 13]]). See the \book{Assembler}.
%alt: alt to convert to absolute virtual jump? keep label in .obj?
% how do relative jumps? assume programmer knows size of instrs?
%
Those absolute jumps
have even been {relocated} by the linker to a new memory address
origin in Section~\ref{sec:relocating} (e.g., [[B 113]]).

Resolving and converting the remaining branching instructions 
(e.g., [[BL foo(SB)]])
\l D_OREG
to absolute jumps is very easy thanks to the symbol table and
the [[Sym.value]] field of procedure symbols.
%trans:
There are still some remaining issues though that makes
the resolving step non-trivial as we will see in the following
sections.

\subsection{Virtual program counter versus real code address}

%trans:
The first issue is that
%
the value in the absolute jump instructions we mentioned before refers to a 
{\em virtual program counter} which is not a {\em real code address}\footnote{
Note that a {\em real} code address under \plan is actually a {\em virtual}
memory address. But, the use of virtual in this context would be confusing,
which is why we will keep to use the term ``real code address''.
}.

%dup: overview/soft-archi core-ds/instr loading/pc-ipc loading/axxx
Indeed, the virtual program counter starts at 0
and is incremented by 1 in [[ldobj()]] after each
code instruction read. 
%dup: overview/disk-image-mem-image overview/5l overview/5l-a main/-H
Real code addresses on the other hand start at [[INITTEXT]] (4128 under \plan),
%dup: overview/5l-a core-ds/instr main/asmb/text-sec 
and because the ARM uses fixed-length instructions 
of 4 bytes, are always a multiple of 4.
\l note though that ARM wants relative jumps ...


Unfortunately, going from a virtual program counter to
a real code address can not be done simply by 
multiplying by~4 and adding [[INITTEXT]].
%dup: main/asmb/text-section-gen-oplook
Indeed, as said in Section~\ref{sec:asmb-text-section-overview},
the instructions in object files do not match exactly 
ARM instructions.
%
This means that one instruction in the object file
may lead to the generation of multiple ARM instructions in
the executable, or no instruction at all sometimes.
%
Even though the assembly language of [[5a]] tries to mimic
closely the ARM instruction set, there is still a mismatch
for a few reasons explained below:

\begin{itemize}
\item {\em Virtual instructions} such as 
%dup: main/asmb/text-sec 
[[DIV]] have no counterpart in the ARM. 
[[DIV]] and [[MOD]] are converted by [[5l]]
in a series of ARM 
instructions which ends with the call to
respectively [[_div()]] and [[_mod()]] of the core C library
(see Section~\ref{sec:div-mod}) which implement
in software the division and modulo algorithms (using [[ADD]],
[[MUL]], [[SUB]], etc).
\n but then could have done expansion in ldobj()? maybe, but then
\n  need relocate branching instr
\n ARET? well always one instr, but its MOVW could have different size
\n  also profiling generate lots of instr
\n ANOP? well could generate fake instr without side effect? can we?
\n AMOVW? ok, constraint anyway for STR/LDR
%real-world: pb specific to 5l?

\item The {\em pseudo-instruction} [[TEXT]] leads to the generation of
0, 1, or many ARM instructions depending on the situation. 
Indeed, if the procedure 
%is a {\em non-leaf} function (see Section~\ref{sec:leaf}) or 
use some locals, it
will need an extra ARM instruction to 
%save the {\em link register}
decrement the {\em stack pointer} (see Section~\ref{sec:atext-patching}).
\l both can be done in one instruction, magic
Moreover, if profiling is enabled, a few more ARM instructions will be added
for the {instrumentation} of the procedure to gather statistics
(see Chapter~\ref{chap:profiling}).
\n again, could have done expansion in ldobj(), but still need relocate then
%
The same is true for [[RET]].
%real-world: pb specific to 5l?

\label{sec:constraints-immediate-and-offset}
\item {\em Constraints} on immediate constants and offsets
imposed by the ARM are relaxed by [[5a]] and the object file.
%dup: overview/5l-a core-ds/instr main/asmb/text-sec resolve/issue/vpc
As said before, the ARM uses fixed-length instructions of 4 bytes,
%
so for instructions involving immediate constants 
(e.g., [[ADD $10256, R1, R2]]) %$
or offsets (e.g., [[MOVW 54000(R0), R2]]), 
%dup: (and adapted) from Assembler in parsing/immediage-constant 
the range of those numbers is quite limited.
%Indeed, a few of the 32 bits of an instruction are already used to encode
%the opcode and a few more to encode the other operands.
For arithmetic instructions, only 12 bits of the ARM instruction
are available to encode the constant.
%Even though the ARM uses a clever trick to represent numbers
%using those 12 bits (see Section~\ref{sec:clever-trick-numbers}),
%the set of numbers which can be represented is still limited.
%
This is why even a regular instruction such as [[ADD]] may lead
to the generation of multiple ARM instructions.
Indeed, if the instruction uses a big number, this number
\l actually not necessarily big, just one that is not immrot()
must first be loaded in a temporary register with an extra instruction
(see Section~\ref{sec:pool-and-reg-tmp}).
\t but how? same pb for loading it no? refer to Overview!
%real-world: specific 5l? how other assembler do? 
% error message at assembly time?

\end{itemize}

%trans:
Because of all of this, it is not trivial to convert a
virtual program counter reference in a branching instruction
to a real code address.
%
The solution adopted by [[5l]] operates in three steps:

\label{sec:dotext-big-picture}
\begin{enumerate}
\item The function [[patch()]] builds
a {\em graph of code instructions} by transforming the use
of a virtual program counter {reference} 
%in a branching instruction 
to a real {pointer} ([[Instr*]]).
%dup: overview/soft-archi coreds/instr
This pointer will be stored in the [[Instr.cond]] field
of the branching instruction
and will point to the target instruction
having the specified virtual program counter in his [[Instr.pc]].

\item The function [[dotext()]]
sets [[pc]] to INITTEXT and
iterates over all the code instructions. 
For each instruction, [[dotext()]] computes the actual number
of ARM instructions which are needed for this
instruction (via [[oplook()]]), 
sets [[Instr.pc]] to [[pc]] which both represent now
{\em real program counters}, 
and increment [[pc]] accordingly (e.g., by 4 if only one ARM instruction
was necessary).
\t need use same global pc for that? could not use local? need pc as global?
\t  actually it is using the local c, but could be instead realpc?

\item The code generator [[asmout()]] when involved with a branching
instruction [[p]] can find the target code address
by simply looking at [[p->cond->pc]].
\l and compute a relative jump by [[p->pc - p->cond->pc - 8]]

\end{enumerate}

\l FIGURE illustrating process? item 1 and 2 combine to make possible 3

%real-world: pb specific to 5a/5l? no virtual-instr in other assembler?
% but also issue of size of instr no? and need relocate labels
% which are complicated because of varying size of instr (and fixpoint?)?
% alternative techniques to graph of code instruction?
%alt: other technique? what I will use for 5l in ocaml?

Thanks to the graph of code instructions, it is also easy
after [[patch()]] to call [[noops()]] to rewrite virtual
instructions in machine instructions.
\n and actually still not completely real, TEXT gets converted in MOVW
\n but could be part of oplook() and could be done in asmout() instead
%dup: overview/soft-archi
Indeed, [[noops()]] can replace a virtual instruction by
multiple machine instructions chained together
or even delete the instruction without
any consequence on the other branching instructions (as long
at it maintains carefully the [[Instr.cond]] pointers in
instructions pointing to the original instruction).
%dup: overview/soft-archi
Before the graph of instructions, inserting or
deleting an instruction would have forced to assign a new 
virtual program counter to all the following instructions and to relocate 
every branching instructions.

Thanks to the graph, it is also possible to perform some
optimizations before code generation,
such as dead code elimination,
as we will see in Section~\ref{sec:optimisations}.
\l actually double thanks to graph cos use graph to traverse and
\l  thx to graph dont have to relocate every other stuff after
\l can change "blocks" in graph. remove, strip,compact.


\subsection{Data address and code size mutual dependency}
\n was 'code instruction size' but too long title in TOC

%trans:
The second issue which makes the resolving step non-trivial is
%
the {mutual dependency} between the layout of code and data.
\l define layout somewhere?
Indeed, to generate code one needs to resolve memory instructions involving
globals which means one must know the address of those globals.
\n note that I use generate here, but it is also true for layout
%
This suggests to layout first data and then the code.
%
But, because those globals are in the data section, which is after the code
section, one needs first to know at least the {size of the code section} to
start to layout data. 
%
This suggests to layout first the code and then the data, 
hence the mutual dependency.


Of course, we just need the size of the code section to layout data,
%alt: could also put data first in executable, would be simpler
so we could first layout the code using {fake addresses} for the globals
referenced in memory instructions. We would get a size
\n actually no, estimation only as explained soon
for the code section which we could use as the starting
point of the data section, to layout data. 
Finally, we would layout the code a second time using 
real addresses for the globals this time, to generate the real code.


One difficulty is that the size of the code section computed
during the first layout would be only an {estimation}.
\t specific to ARM? then add ARM somewhere
Indeed, some instructions involving globals may have different size
\l well abuse of lang, some instr lead to generation of multiple ARM instr
depending on the address of the global.
\t refer to overview! address become offset.
Offsets in ARM instructions
have a limited range, as mentioned 
in the previous section. %clever \ref{sec:sec:constraints-immediate-and-offset}
%
This means some memory instructions may require the use of an extra
instruction if the address of the global happens to be large.
\t but how bootstrapped? WORD and LDR
Using fake addresses during the first layout would be imprecise.
%alt: put safe gap after estimation? anyway has INITRND. and fixpoint? 
% how ensure termination of fixpoint?

The solution adopted by [[5l]] to solve the mutual dependency
problem operates in four steps: 

\label{sec:dodata-big-picture}
\begin{enumerate}
\item The layout of data is done first, via [[dodata()]],
by iterating over all the globals.
\n using hash, not datap
%dup: overview/5l-a overview-soft-archi
But, each globals is assigned a memory address (in [[Sym.value]])
as {\em an offset to the start of the data section},
not an absolute address.
%
Note that the old value in [[Sym.value]] contained the size
of the global which is used to layout globals one after the other.

\item [[dotext()]] then layouts code by iterating over all the instructions.
But, it assumes the {\em reserved register} [[R12]] will, at {\em run-time},
when the executable is executed,
contain [[INITDAT]], the address of the start of the data section.
\n actually not exactly that because BIG opti
It also assumes that operands involving globals such as
[[MOVW hello(SB), R1]] can be transformed later (in [[asmout()]])
as an {\em indirect with offset} operand
(see the \book{Assembler}).
This operand can then use [[R12]] as the {\em base} and 
the [[Sym.value]] of the global (computed previously)
as the {\em offset}, e.g.,  [[LDR 14(R12), R1]].
\t actually not all are like that, can use also Pool if LCON
%
In the same way, instructions involving global addresses such as
[[MOVW $hello(SB), R1]] %$ 
can be transformed as [[ADD $14, R12, R1]]. %$
\t but what if offset too large? and so can not express address
\t  as offset, then will use absolute address and Pool, 
%
That way, [[dotext()]] can compute accurately the size of the
instruction.
\t but anyway, it's not gonna change, still not fake address! 
\t second layout would be the same

\item One of the first instruction of the program must
initialize [[R12]] with the value of [[INITDAT]].
%
\l could stop here? and explain later subtelity of bootstrap need.
This value is recorded in the executable as a special symbol,
[[setR12]], using a form of reflection explained in Section~\ref{sec:sb-r12}.
\n actually opti so not that
%
In practice, the function [[_main()]] from the core
C library is the first function executed by
the program (see Section~\ref{sec:choice-entry-point}).
This is why one of its first instruction is:
[[MOVW $setR12(SB), R12]].%$
%

\item The instruction [[MOVW $setR12(SB), R12]] %$
itself uses the address of a global but it must not be transformed
as [[ADD 0, R12, R12]] like other similar instructions.
Indeed, the whole point of the instruction is to initialize [[R12]],
and so it can not rely on [[R12]].
%which could be
%small or large depending on the program. So, this instruction
%may have different size depending on the address
%which brings us back to the original problem. 
To {\em bootstrap},
this address is recognized in a special way in the code
generator in [[asmout()]] and leads to the generation
of an instruction which uses the absolute address of [[setR12]],
e.g., [[MOV $0x7000, R12]]. %$
\t it is a MOV not MOVW, it's the MOV of the ARM this time
%of a fixed number
%of instructions, whatever the value of the address.
\t  special case to use LCON not RECON!! subtle, ref to code in aclass?
\l see also section X where see code of _main?

\end{enumerate}
%alt: fixpoint?

\t what about memory reference to code section other than branch?
\t  ref to etext? ref to $foo(SB)? %$
\t  this is why get a xdefine("etext", STEXT, 0L)? but then pb
\t  fixpoint?

All of this explains the order of the calls we saw
at the beginning of this chapter:

\begin{verbatim}
patch();
noops();

dodata();
dotext();
\end{verbatim}
\n actually dodata() could be before patch I think.
\l also for SSTRING one must do dotata() before dotext.
\l other reasons?

\bigskip
%trans:
Now that we have a better picture of how things work
together to resolve symbols, we
can go through the code of each of the functions above,
starting with [[patch()]].


\section{Building the code instructions graph, [[patch()]]}
\label{sec:patch}

%trans:
As explained before, 
%dup: resolving/issue/virtualpc
the goal of [[patch()]] is to set the [[Instr.cond]] field
\l introduced in \ref{sec:instr-cond}
of branching instructions to point to the right target instruction.
\n so later in asmout can get real pc with p->cond->pc (also useful for follow)
%
Essentially [[patch()]] will iterate over all the code instructions
[[p]] and for branch instructions it will {look for}
the target instruction [[q]] with the virtual program counter 
[[q->pc]] equal to the absolute jump value [[p->to.offset]]:

<<function patch(arm)>>=
/// main -> <>
void
patch(void)
{
    Prog *p;
    Prog *q;
    long c; // not ulong?
    <<[[patch()]] other locals>>

    DBG("%5.2f patch\n", cputime());

    <<[[patch()]] initialisations>>

    // pass 1
    for(p = firstp; p != P; p = p->link) {
        <<adjust curtext when iterate over instructions p>>

        <<[[patch()]] resolve branch instructions using symbols>>

        if(p->to.type == D_BRANCH && p->cond != UP) {
            c = p->to.offset; // target pc
            <<[[patch()]] find Prog reference [[q]] with [[q->pc == c]]>>
            p->cond = q;
        }
    }
    // pass 2
    <<[[patch()]] optimisation pass>>
}
@
\t use pc instead of c? can be a local

The extra condition [[p->cond != UP]] above is not very
important and can be ignored for now.
It will be explained in Section~\ref{sec:UP}.
\n because of SUNDEF
Normally, before the call to [[patch()]], 
[[Instr.cond]] should be a null pointer\footnote{
See the instruction [[p->cond = P;]] in [[ldobj()]] Section~\ref{sec:ldobj}.
}
which is different than [[UP]].


%trans: %chunks:
[[patch()]] is a complex function. 
I split it in a few {chunks} to facilitate its comprehension.
%
To find [[q]], [[patch()]] needs to first initialize some
data structures that makes the search more efficient.
%
It also needs to (partially) resolve branching instructions using
symbols and convert them to absolute jumps.
That way all branching instructions become uniforms.
%toc:
The following sections will explain those different steps.


\subsection{Resolving branch instructions using symbols}

Converting the use of symbols in branching instruction
(e.g., [[B foo(SB)]]) to absolute jumps (e.g., [[B 113]])
is trivial thanks to the [[Sym.value]] of procedure symbols
which contains the virtual program counter of the procedure:
\l a bit too much explanations?

<<[[patch()]] other locals>>=
Sym *s;
// enum<Opcode>
int a;
@

<<[[patch()]] resolve branch instructions using symbols>>=
a = p->as;
if((a == ABL || a == AB) &&
   p->to.type != D_BRANCH &&  // must be D_OREG then
   p->to.sym != S) {
    s = p->to.sym;
    switch(s->type) {
    case STEXT:
        p->to.offset = s->value;
        p->to.type = D_BRANCH;
        break;
    <<[[patch()]] switch section type for branch instruction, cases>>
    }
}
@
%old: had  || a == ARET   but I cant see how can have this and a p->to.sym
%bug: ARET? ARET has no args in Assembler.nw. cos of SUNDEF? I don't think so.
\n can do B foo(SB)? why not if have no arguments, could. Tail call!
%bug: overwrite offset silently? so BL foo+4(SB) is not handled?

If the procedure can not be found, an error is reported:

<<[[patch()]] switch section type for branch instruction, cases>>=
// SNONE, SXREF, etc
default:
    diag("undefined: %s\n%P", s->name, p);
    s->type = STEXT;
    s->value = 0;
    break;
@
\n see also SUNDEF case
%old: s->value = vexit;

To avoid reporting multiple times the same error,
the symbol of the undefined procedure is modified to become a (fake)
defined procedure.
That way, if another instruction later calls the same procedure,
[[5l]] will not report an error.
%
Note that there is no risk of generating a wrong executable though
as the call to [[diag()]] will prevent such a thing 
(see Appendix~\ref{chap:error}).
\n also first intr just change s, not p, so
\n does not change p->to.type so still D_OREG so will not generate  any code

%old:
%  s->value = vexit;
%  ...
%  <<[[patch()]] other locals>>=
%  long vexit;
%  @
%  <<[[patch()]] initialisations>>=
%  s = lookup("exit", 0);
%  vexit = s->value;
%  @
%% exit? part of C library? no, but will be pc = 0 if not.
%but seems uselessly complicated. Anyway no executable will be generated



\subsection{Finding instruction at [[pc]]}
\label{sec:find-q}
\n better to present how use DS first I think, hence the order

The naive way to find the instruction [[q]] with a certain [[pc]]
is a linear search over all the instructions, by 
following [[Instr.link]].
%ocaml: or use an array, so then really trivial!
%
To optimize the search, [[patch()]] relies on another pointer, 
[[Instr.forwd]] which will point not to the next instruction,
but to a few more instructions forward (hence the name),
as shown in Figure~\ref{fig:forward-pointer}.
\n well a few can be actually a lot when LOG=5

<<[[Prog]] other fields>>=
Prog*   forwd;
@
%old: used to be part of an union with regused, but regused was actually
% unused
%alt: 
% - an array instead of a list (but then noops() harder? no cos
%   can still return a graph with pointers after)
% - a hashtbl on Prog.pc? to get a Prog from a specific pc


\begin{figure}[!]\centering
\begin{verbatim}
        +-------+
        |PC = 0 |------------+
        +---+---+ forwd      |
            |link            |
        +---v---+            |
+-------|PC = 1 |            |
| forwd +---+---+            |
|           |link            |
|       +---v---+            |
|       |PC = 2 |            |
|       +---+---+            |
|           |link            |
+------>+---v---+            |
+-------|PC = 3 |            |
| forwd +---+---+            |
|           |link            |
|       +---v---+<-----------+
|       |PC = 4 |------------+
|       +---+---+ forwd      |
|           |link            |
+------>+---v---+            |
+-------|PC = 5 |            |
| forwd +---+---+            |
|           |link            |
|       +---v---+            |
|       |PC = 6 |            |
|       +---+---+            |
|           |link            |
+------>+---v---+            |
+-------|PC = 7 |            |
| forwd +---+---+            |
|           |link            |
|       +---v---+<-----------+
|       |PC = 8 |
|       +---+---+
|           |link
+------>+---v---+
        |PC = 9 |
        +-------+
\end{verbatim}
\caption{Forward pointers.}\label{fig:forward-pointer}
\end{figure}

That way you can make bigger jumps sometimes:

<<[[patch()]] find Prog reference [[q]] with [[q->pc == c]]>>=
for(q = firstp; q != P;) {
    if((q->forwd != P) && (c >= q->forwd->pc)) {
        q = q->forwd; // big jump
    } else {
        if(c == q->pc)
            break; // found it!
        q = q->link; // small jump
    }
}
if(q == P) {
    diag("branch out of range %ld\n%P", c, p);
    p->to.type = D_NONE;
}
@
\l you can not jump outside code area!

By carefully setting [[Instr.forwd]], the search can become
a {\em binary search}.
%
Indeed, to find for instance the instruction with [[PC==7]]
in Figure~\ref{fig:forward-pointer}, shortened to $p_7$,
one needs only 3 steps: starting from $p_0$ we can go
directly to $p_4$ with [[forwd]], then $p_5$ with [[link]]
and finally $p_7$ with another [[forwd]].
A linear search with only [[link]] would require 7 steps.

\subsection{Indexing [[pc]], forward links overlay}

% called skip lists:
% http://ticki.github.io/blog/skip-lists-done-right/

The [[Instr.forwd]] fields are set by [[mkfwd()]]:

<<[[patch()]] initialisations>>=
mkfwd();
@

[[mkfwd()]] essentially builds a {\em binary search tree} on
top of a {linked list}.
%
It relies on the constant [[LOG]] which controls at the same time
the lengths of the forward arcs and the depth of the search tree:

<<constant LOG>>=
#define	LOG	5
@

To illustrate [[mkfwd()]] though, we will use [[LOG=2]],
which leads to Figure~\ref{fig:forward-pointer}
when [[mkfwd()]] is applied to a list of 10 instructions.

<<function mkfwd>>=
/// main -> patch -> <>
void
mkfwd(void)
{
    long cnt[LOG]; // (length of arc)/LOG at a certain level (constant)
    long dwn[LOG]; // remaining elements to skip at a level (goes down)
    Prog *lst[LOG]; // past instruction saved at a level
    Prog *p;
    int i; // level

    <<[[mkfwd()]] initializes cnt, dwn, lst>>

    i = 0;
    for(p = firstp; p != P; p = p->link) {
        <<adjust curtext when iterate over instructions p>>
        p->forwd = P;

        <<[[mkfwd()]] in for loop, add forward links from past p in lst to p>>
    }
}
@

%trans: %chunks:
The code of [[mkfwd()]] is very subtle 
which is why I split it in multiple chunks.
%
It iterates over all the instructions [[p]] and at certain {\em frequencies}
adds a forward link from a past instruction saved in [[lst[i]]]
to the current instruction [[p]]. 
It does so for different {\em levels} [[i]].
%
The frequency (divided by [[LOG]])
for a certain level [[i]] is stored in [[cnt[i]]]
initialized by the following code:

<<[[mkfwd()]] initializes cnt, dwn, lst>>=
for(i=0; i<LOG; i++) {
    if(i == 0)
        cnt[i] = 1; 
    else
        cnt[i] = LOG * cnt[i-1];
    dwn[i] = 1;
    lst[i] = P;
}
@

Here are the initial values of [[cnt]] for different [[LOG]]:
\begin{verbatim}
// LOG = 2
cnt[] = {1, 2};
// LOG = 3
cnt[] = {1, 3, 9};
// LOG = 4
cnt[] = {1, 4, 16, 64};
// LOG = 5
cnt[] = {1, 5, 25, 125, 625};
\end{verbatim}
% // so frequency level0 = 2 (LOG * 1), level1 = 4 (LOG * 2)

We can finally see the body of the loop of [[mkfwd()]]:

<<[[mkfwd()]] in for loop, add forward links from past p in lst to p>>=
// first loop, the levels
i--;
if(i < 0)
    i = LOG-1;

// second loop, the frequency at a certain level
dwn[i]--;
if(dwn[i] <= 0) {
    dwn[i] = cnt[i];

    if(lst[i] != P)
        lst[i]->forwd = p; // link from past p to p
    lst[i] = p;
}
@

The idea is to first loop over the different levels [[i]],
and then loop over the frequency at a certain level [[i]].
%
So, for [[LOG=2]], [[mkfwd()]] will add forward links
of length 4 (every $LOG * 2$ instructions), and 
of length 2 (every $LOG * 1$ instructions), as illustrated 
in Figure~\ref{fig:forward-pointer}.

Here is a simple trace of [[mkfwd()]] for [[LOG=2]]
which could help understand the algorithm.
%with the data in Figure~\ref{fig:forward-pointer}.
It shows the value of the different variables at the {\em end}
of each iteration of the [[for]] loop:

\begin{verbatim}
// does not change
LOG = 2
cnt[] = { 1, 2 }; 

// before for loop
i = 0  dwn[] = { 1, 1 } lst[] = {P, P};


// end of each iteration
p=p0 i=1 dwn[]={1,2} lst[]={P, p0} // save p0
p=p1 i=0 dwn[]={1,2} lst[]={p1,p0} // save p1
p=p2 i=1 dwn[]={1,1} lst[]={p1,p0} // decrement dwn[1]
p=p3 i=0 dwn[]={1,1} lst[]={p3,p0} // + p1 -> p3 forwd link
p=p4 i=1 dwn[]={1,2} lst[]={p3,p4} // + p0 -> p4 forwd link
p=p5 i=0 dwn[]={1,2} lst[]={p5,p4} // + p3 -> p5 forwd link
p=p6 i=1 dwn[]={1,1} lst[]={p5,p4}
p=p7 i=0 dwn[]={1,1} lst[]={p7,p4} // + p5 -> p7 forwd link
p=p8 i=1 dwn[]={1,2} lst[]={p7,p8} // + p4 -> p8 forwd link
p=p9 i=0 dwn[]={1,1} lst[]={p9,p8} // + p7 -> p9 forwd link
\end{verbatim}

For [[LOG=5]], [[mkfwd()]] will add forward links
of lengths 3125 ($5 * 625 = 5^5$), 
625 ($5^4$), 
125 ($5^3$), 
25 ($5^2$), and 
5 ($5^1$).



\section{Virtual opcodes rewriting, [[noops()]]}
\label{sec:noops}

\n ARM only. there is a dostkoff() in x86 but it's related only to the become
\n  stuff that I have now deleted for the ARM.

%trans:
As explained before, 
%dup: overview/soft-archi ... resolving/issue/virtualpc
[[noops()]] rewrites pseudo and virtual instructions 
which do not have a corresponding 
ARM opcode ([[no]] [[op]]), e.g., [[ARET]],
to machine instructions which have one.
%
It works in two passes over the list of code instructions.
The first pass mostly {\em marks} certain instructions in
[[Instr.mark]] (see Section~\ref{sec:mark}). 
%
This pass can also rely on [[q]] which stores the previous instruction to [[p]].
%
The second pass possibly uses the mark to transform
virtual instructions:
\l actually ANOP stripping done in first pass

<<function noops(arm)>>=
/// main -> <>
void
noops(void)
{
    Prog *p, *q, *q1;
    // enum<Opcode>
    int o;

    /*
     * find leaf subroutines
     * strip NOPs
     * expand RET
     */

    DBG("%5.2f noops\n", cputime());

    // pass 1, mark or delete
    curtext = P;
    q = P;
    for(p = firstp; p != P; p = p->link) {
        <<adjust curtext when iterate over instructions p>>

        switch(p->as) {
        <<[[noops()]] first pass switch opcode cases>>
        }
        q = p;
    }

    // pass 2, transform
    curtext = P;
    for(p = firstp; p != P; p = p->link) {
        <<adjust curtext when iterate over instructions p>>

        o = p->as;
        switch(o) {
        <<[[noops()]] second pass switch opcode cases>>
        }
    }
}
@
\l could be more symetric and use o = p->as;  also in first pass?
%bugfix: I forgot the 'q = p;' after some refactoring, but need it!
%dead: there was lots of stuff about BECOME which I think was
% a feature necessary for the alef compiler, but it
% has been removed from plan9 edition 4 so this code
% was probably dead.
%
%    int curframe, curbecome, maxbecome;
%
%     * become sizes
%     * frame sizes
%     * expand BECOME pseudo
%
%    curframe = 0;
%    curbecome = 0;
%    maxbecome = 0;
%
%        /* find out how much arg space is used in this TEXT */
%        if(p->to.type == D_OREG && p->to.reg == REGSP)
%            if(p->to.offset > curframe)
%                curframe = p->to.offset;
%
%
%            if(curtext && curtext->from.sym) {
%                curtext->from.sym->frame = curframe;
%                curtext->from.sym->become = curbecome;
%                if(curbecome > maxbecome)
%                    maxbecome = curbecome;
%            }
%            curframe = 0;
%            curbecome = 0;
%
%
%        case ARET:
%            /* special form of RET is BECOME */
%            if(p->from.type == D_CONST)
%                if(p->from.offset > curbecome)
%                    curbecome = p->from.offset;
%            break;
%
%    if(curtext && curtext->from.sym) {
%        curtext->from.sym->frame = curframe;
%        curtext->from.sym->become = curbecome;
%        if(curbecome > maxbecome)
%            maxbecome = curbecome;
%    }
%
%    if(debug['b'])
%        print("max become = %d\n", maxbecome);
%    xdefine("ALEFbecome", STEXT, maxbecome);
%
%    curtext = P;
%    for(p = firstp; p != P; p = p->link) {
%        <<adjust curtext when iterate over instructions p>>
%        switch(p->as) {
%        case ABL:
%            if(curtext != P && curtext->from.sym != S && curtext->to.offset >= 0) {
%                o = maxbecome - curtext->from.sym->frame;
%                if(o <= 0)
%                    break;
%                /* calling a become or calling a variable */
%                if(p->to.sym == S || p->to.sym->become) {
%                    curtext->to.offset += o;
%                    if(debug['b']) {
%                        curp = p;
%                        print("%D calling %D increase %d\n",
%                            &curtext->from, &p->to, o);
%                    }
%                }
%            }
%            break;
%        }
%    }
%
%            if(p->from.type == D_CONST)
%                goto become;
%
%        become:
%            if(curtext->mark & LEAF) {
%                if(!autosize) {
%                    p->as = AB;
%                    p->from = zprg.from;
%                    break;
%                }
%            }
%            q = prg();
%            q->scond = p->scond;
%            q->line = p->line;
%            q->as = AB;
%            q->from = zprg.from;
%            q->to = p->to;
%            q->cond = p->cond;
%            q->link = p->link;
%            p->link = q;
%
%            // MOVW autosize(SP), LINK
%            p->as = AMOVW;
%            p->scond |= C_PBIT;
%            p->from = zprg.from;
%            p->from.type = D_OREG;
%            p->from.offset = autosize;
%            p->from.reg = REGSP;
%            p->to = zprg.to;
%            p->to.type = D_REG;
%            p->to.reg = REGLINK;
%
%            break;
%
%dead: this was under some ifdef, probably experimental stuff
%#ifdef optimise_time
%                if(autosize) {
%                    q = prg();
%                    q->as = ASUB;
%                    q->line = p->line;
%                    q->from.type = D_CONST;
%                    q->from.offset = autosize;
%                    q->to.type = D_REG;
%                    q->to.reg = REGSP;
%
%                    q->link = p->link;
%                    p->link = q;
%                }
%                break;
%#else
%
%#ifdef optimise_time
%                p->as = AADD;
%                p->from.type = D_CONST;
%                p->from.offset = autosize;
%                p->to.type = D_REG;
%                p->to.reg = REGSP;
%
%                q = prg();
%                q->as = AB;
%                q->scond = p->scond;
%                q->line = p->line;
%                q->to.type = D_OREG;
%                q->to.offset = 0;
%                q->to.reg = REGLINK;
%
%                q->link = p->link;
%                p->link = q;
%
%                break;
%#endif
%
%#ifdef optimise_time
%                q = prg();
%                q->scond = p->scond;
%                q->line = p->line;
%                q->as = AB;
%                q->from = zprg.from;
%                q->to = p->to;
%                q->cond = p->cond;
%                q->link = p->link;
%                p->link = q;
%
%                p->as = AADD;
%                p->from = zprg.from;
%                p->from.type = D_CONST;
%                p->from.offset = autosize;
%                p->to = zprg.to;
%                p->to.type = D_REG;
%                p->to.reg = REGSP;
%
%                break;
%#endif


%toc:
The following sections will detail those passes.

\subsection{Leaf procedure optimisation}
\label{sec:leaf}
\n could be in Opti section? but talked in Assembler and have many implications

An important concept related to the ARM architecture is 
whether a procedure is a leaf (see the \book{Assembler}). 
Such procedures will be marked in the first pass of [[noops()]]:

<<[[Mark]] cases>>=
LEAF        = 1<<2,
@
% >>
%ocaml: could be a local variable (a set) in the rewrite function
% but in the end my visiting code is longer than the C code, sniff

A {\em leaf} is a procedure which does not call other procedures.
Such a procedure is thus a leaf in the {\em call tree}:

<<[[noops()]] first pass switch opcode cases>>=
case ATEXT:
    p->mark |= LEAF;
    break;

case ABL:
    if(curtext != P)
        curtext->mark &= ~LEAF;
    // fallthrough
<<[[noops()]] first pass switch opcode ABL fallthrough>>
@

Depending on whether a procedure is a leaf, 
the code for [[ATEXT]] and [[ARET]] can be optimized
to not use memory at all and just use the 
{\em link register} [[R14]], 
%toc:
as we will see in the following sections.

%old:
% <<[[Section]] cases>>=
% SLEAF, // arm
% @
% but used only for symbol table, so I removed and use mark instead.


\subsection{[[ATEXT]] patching}
\label{sec:atext-patching}

If a procedure is a leaf, there is no need to save [[R14]]
in the stack. Indeed, such a procedure will 
not contain any [[BL]] instruction, and so will
not overwrite [[R14]].
%
[[5l]] does this optimization though only if the procedure
does not declare also any locals (e.g., [[ATEXT foo(SB), $0]]).%$
\t why?

Otherwise, if the procedure is not a leaf, or use some locals,
then an extra word ([[+4]] bytes) is reserved in the stack
to save the return address to the caller stored in [[R14]].

<<[[noops()]] second pass switch opcode cases>>=
case ATEXT:
    if(p->to.offset <= 0) {
      if(curtext->mark & LEAF) {
        // to compensate further + 4 to get autosize == 0.
        p->to.offset = -4;
      }
    }
    autosize = p->to.offset + 4;

    <<[[noops()]] in second pass, if size local was -4 and not a leaf>>

    if((curtext->mark & LEAF) && (autosize == 0))
      break;
    // else

    // MOVW.W R14, -autosize(R13)
    q1 = prg();
    q1->as = AMOVW;
    q1->scond |= C_WBIT;
    q1->line = p->line; // origin tracking
    q1->from.type = D_REG;
    q1->from.reg = REGLINK;
    q1->to.type = D_OREG;
    q1->to.reg = REGSP;
    q1->to.offset = -autosize;

    // insert_after(p, q1)
    q1->link = p->link;
    p->link = q1;
    break;
@
\n forgot Instr.pc ? does not matter anymore, graph already built.
%old:
%    autosize = p->to.offset + 4;
%    if(autosize <= 4)
%      if(curtext->mark & LEAF) {
%        p->to.offset = -4;
%        autosize = 0;
%    }
%
%    if(!autosize && !(curtext->mark & LEAF)) {
%        DBG("save suppressed in: %s\n", curtext->from.sym->name);
%        curtext->mark |= LEAF;
%    }
%
%    if(curtext->mark & LEAF) {
%        if(curtext->from.sym)
%            curtext->from.sym->type = SLEAF;
%        if(!autosize)
%            break;
%    }
% - removed the code about SLEAF
% - use autosize == 0, more readable than !autosize, anyway it's not a bool!
% - reorg order of assignments, simpler I think
%ocaml: I store directly final autosize so no need to compensate with -4
% for further +4 as there will be no further +4, we store the final autosize
% directly.

The single instruction [[MOVW.W R14, -autosize(R13)]],
which uses the {\em special bit} [[.W]] (see the \book{Assembler}),
is equivalent to the sequence:
\begin{verbatim}
MOVW R14, -autosize(R13)
SUB autosize, R13, R13
\end{verbatim}
\l really?
\t see section X!!

Note that the [[ATEXT]] instruction in [[p]] is kept.
It is not replaced by a new instruction [[q1]] but instead
[[q1]] is added after [[p]].
That way, further iterations over the list of instructions
can still rely on [[curtext]].


In some situations, even if the procedure is not a leaf, 
one would like to not save [[R14]] in the stack.
\t why? getcallerpc is a leaf.
In that case, the programmer needs to declare his procedure with
[[-4]] for the size of its locals (e.g., [[TEXT foo(SB), $-4]]). %$

<<[[noops()]] in second pass, if size local was -4 and not a leaf>>=
if((autosize == 0) && !(curtext->mark & LEAF)) {
    DBG("save suppressed in: %s\n", curtext->from.sym->name);
    curtext->mark |= LEAF;
}
@

\subsection{[[ARET]] rewriting}
\label{sec:ARET-rewrite}

[[ARET]] is complementary to [[ATEXT]].
Its transformation is pretty straightforward:

<<[[noops()]] second pass switch opcode cases>>=
case ARET:
    if((curtext->mark & LEAF) && (autosize == 0)) {
        // B 0(R14)
        p->as = AB;
        p->from = zprg.from;
        p->to.type = D_OREG;
        p->to.offset = 0;
        p->to.reg = REGLINK;
    } else {
        // MOVW.P autosize(R13), R15
        p->as = AMOVW;
        p->scond |= C_PBIT;
        p->from.type = D_OREG;
        p->from.offset = autosize;
        p->from.reg = REGSP;
        p->to.type = D_REG;
        p->to.reg = REGPC;
    }
    break;
@
%old:    <<[[noops()]] case ARET, call nocache>>

The single instruction [[MOVW.P autosize(R13), R15]],
which uses the {special bit} [[.P]] (see the \book{Assembler}),
\t mean post indexing, mean dont use offset for address, but then
\t  after adjust address and use offset
is equivalent to the sequence:
\begin{verbatim}
ADD autosize, R13, R13
MOVW -autosize(R13), R15
\end{verbatim}
\n in fact it is MOVW (R13), R15; ADD autosize, R13, R13   but then subtle
\n  cos done exactly at the same time


Note that this time the instruction [[p]] is overwritten;
[[RET]] really disappears.


Figure~\ref{fig:text-ret} summarizes the possible
translations for [[ATEXT]] and [[ARET]] on a simple
program with 3 procedures [[foo]], [[bar]], and
[[leaf]] where [[leaf]] is the only leaf procedure.
%
The numbers in the middle column, e.g., [[5000]],
represent the code addresses of the generated code in
the executable.
%
Figure~\ref{fig:text-ret-stack} shows
the stack after [[foo]] has called [[bar]] which
has called [[leaf]].

\begin{figure}[!]\centering
\begin{verbatim}
TEXT foo(SB), $4      5000: MOVW R14, $-8(R13)  
...                   5004: SUB $8, R13, R13
                            ...
BL bar(SB)        ==> 5020: BL 6000
...                         ...
RET                   5040: ADD $8, R13, R13                       
                      5044: MOVW $-8(R13), R15


TEXT bar(SB), $8      6000: MOVW R14, $-12(R13)
...                   6004: SUB $12, R13, R13
                            ...
BL leaf(SB)       ==> 6052: BL 7000
...                         ...
RET                   6080: ADD $12, R13, R13
                      6084: MOVW $-12(R13), R15


TEXT leaf(SB), $0     7000: /* nothing */
...               ==>       ...
RET                   7028: B (R14)
\end{verbatim}
\caption{[[TEXT]] and [[RET]] translations.}\label{fig:text-ret}
\end{figure}
\l actually not BL 6000, BL uses relative number, but what is saved
\l  in the stack is an absolute address!

\begin{figure}[!]\centering
\begin{verbatim}
                |       |
----------- +20 +-------+ <----------------+ old value of R13
 foo            | ???   |  foo local
            +16 +-------+  
 frame          | 4054  |  return address of foo (in main)
----------- +12 +-------+ <----------------+ old value of R13
                | ???   |  bar first local
 bar         +8 +-------+  
                | ???   |  bar second local
 frame       +4 +-------+  
                | 5024  |  return address of bar (in foo)
-----------   0 +-------+ <----------------+ R13

R14 = 6056  = return address of leaf (in bar)
\end{verbatim}
\caption{Stack before [[B (R14)]] in [[leaf()]].}\label{fig:text-ret-stack}
\end{figure}



\subsection{[[ANOP]] stripping}

%trans:
Another virtual instruction rewritten by [[noops()]] is [[ANOP]].
%
The semantic of [[ANOP]] is to do nothing (nope),
which is why it can be removed from the graph of instructions:
\l there is a NOP in the ARM?

<<[[noops()]] first pass switch opcode cases>>=
case ANOP:
    q1 = p->link;
    q->link = q1;		// q is a non-ANOP before p
    q1->mark |= p->mark;
    continue;           // no  q = p; so q remains a non-ANOP
@
%old: /* q is non-nop */
%bug? q could be null, or assume never generate ANOP without anything before?
\l rely on q = p; done in for loop in noops, see code before
\t need propagate mark? not sure useful.

The compiler [[5c]] occasionally generates code using [[ANOP]]
(see the \book{Compiler}).
\t what for? USED, SET, other? need wait for Compiler.nw
[[5l]] does too as we will see in Section~\ref{sec:dupok-nop}.

Note that some instructions could have this deleted [[ANOP]] instruction
[[p]] as their branching target in [[Instr.cond]].
In that case their [[Instr.cond]] field must be updated:

% so also case ABL: before
<<[[noops()]] first pass switch opcode ABL fallthrough>>=
case AB:
case ABEQ: case ABNE:
case ABHS: case ABLO:
case ABMI: case ABPL:
case ABVS: case ABVC:
case ABHI: case ABLS:
case ABGE: case ABLT:
case ABGT: case ABLE:
case ABCASE:
    q1 = p->cond;
    if(q1 != P) {
        while(q1->as == ANOP) {
            q1 = q1->link;
        }
        p->cond = q1;
    }
    break;
@
\n no ABL since always branch to a TEXT so we know not a NOP
%old: p->cond = q1;  was inside while but better outside
%bug? q1 could be null in the loop?
%todo: write test case showing the bug?
% I would rewrite the code as
%   while(q1 != P && q1->as == ANOP) 
%       q1 = q1->link;
%   p->cond = q1;


\bigskip
There are other virtual instructions rewritten by [[noops()]]
beside [[TEXT]], [[RET]], and [[NOP]]. Those are the most
important one though.
Chapter~\ref{chap:advanced} will present the transformation of
the remaining virtual instructions: [[DIV]], [[MOD]], and [[MOVWD]].
\l Also some virtual instr transformed in asmout() ... like MOVW!


\section{Laying out data, [[dodata()]]}

%trans:
As explained before,
%dup: overview/soft-archi main/asmb/data-sect resolving/issue
the goal of [[dodata()]] is to {layout} globals by
essentially modifying the [[Sym.value]] field of those globals.
%
This field was originally storing the size of the global
and will contain, after [[dodata()]], 
an offset to the start of the data section.
%
[[dodata()]] also computes two important globals storing
the size of the data and BSS sections:

<<global datsize>>=
long	datsize;
@

<<global bsssize>>=
long	bsssize;
@

Those globals are then used to generate the [[a.out]] header
in [[asmout()]], as shown in Section~\ref{sec:gen-header}.


The programmer {declares} globals and
specifies their {\em size} with [[GLOBL]],
e.g., [[GLOBL foo(SB), $4]]. %$
%
He can also specify their {\em content} with [[DATA]],
e.g., [[DATA foo(SB)/4, "hey\n"]], in which case the global
will be part of the data section ([[SDATA]]) 
instead of the BSS section ([[SBSS]]).
%
But, he does not care about the precise layout of those globals
in their respective sections.
%
[[dodata()]] gathers all the global declarations, spread in different
object files, and places them next to each other in memory.
\l layout = placing
It also {\em aligns} those globals at word boundaries
to satisfy architecture constraints on memory addressing.
\t constraint = ? for optimize too? or would also not work?
\l will also have alignment then in executable for data section globals.

The code is pretty straightforward once all the motivations
and the big picture have been presented 
(see Section~\ref{sec:dodata-big-picture}):

<<function dodata(arm)>>=
/// main -> <>
void
dodata(void)
{
    Prog *p;
    Sym *s;
    // offset to start of data section
    long orig;
    // size of data
    long v;
    //enum<Section>
    int t;
    int i;

    DBG("%5.2f dodata\n", cputime());

    // DATA instructions loop
    for(p = datap; p != P; p = p->link) {
        s = p->from.sym;
        if(s->type == SBSS)
            s->type = SDATA;
        <<[[dodata()]] sanity check DATA instructions>>
    }

    <<[[dodata()]] if string in text segment>>

    orig = 0;

    /*
     * pass 1
     *  sanity check data values, and align.
     */
    // symbol table loop
    for(i=0; i<NHASH; i++)
     for(s = hash[i]; s != S; s = s->link) {
        t = s->type;
        if(t == SDATA || t == SBSS) {
            v = s->value; // size of global for now
            <<[[dodata()]] sanity check GLOBL instructions, size of data v>>
            v = rnd(v, 4); // align
            s->value = v;   // adjust
            <<[[dodata()]] in pass 1, if small data size, adjust orig>>
        }
    }

    /*
     * pass 2
     *	assign (large) 'data' variables to data segment
     */
    for(i=0; i<NHASH; i++)
     for(s = hash[i]; s != S; s = s->link) {
        t = s->type;
        if(t == SDATA) {
            v = s->value;
            // s->value used to contain the size of the GLOBL.
            // Now it contains its location (as an offset to INITDAT)
            s->value = orig;
            orig += v;
        } else {
            <<[[dodata()]] in pass 2, retag small data>>
        }
    }
    orig = rnd(orig, 8);

    datsize = orig;

    /*
     * pass 3
     *	everything else to bss segment
     */
    for(i=0; i<NHASH; i++)
     for(s = hash[i]; s != S; s = s->link) {
        if(s->type == SBSS) {
            v = s->value;
            s->value = orig;
            orig += v;
        }
    }
    orig = rnd(orig, 8);

    bsssize = orig-datsize;

    <<[[dodata()]] define special symbols>>
}
@
\l do not use v? was used for version previously
\t why not use offset instead of orig?
\n first iteration is on datap instructions, the other are on the symbol table.
%old:         <<[[dodata()]] if ADYNT or AINIT>>
%old:
%            while(v & 3) // align
%                v++;
%    while(orig & 7) // align
%        orig++;
%    while(orig & 7) // align
%        orig++;
%   better use rnd()
%old: was doing <<[[dodata()]] sanity check size of data v>>
% in pass2 for SDATA but not for BSS. I think more consistent not do it
% anywhere, any redundant with check done in pass1.

Note that we are just laying out globals here. We use mostly
the [[GLOBL]] declarations which are stored in the symbol table
[[hash]].
%
The use of the [[DATA]] instructions and [[datap]]
to generate the data section in the executable is done in [[datblk()]]
(see Section~\ref{sec:datblk}), not in [[dodata()]].

\t what matters is do before dotext() though! because oplook! instoffset, etc.

\l could do orig = INITDAT? no, we can't because we don't know yet the size
\l   of the text ... this is computed in dotext().

\n Order of globals in executable = order in hash table = hard to predict.
\l  which is why does this weird datblk() multi pass strategy.
%alt: base it on the DATA decl instead of GLOBL?


<<[[dodata()]] sanity check GLOBL instructions, size of data v>>=
if(v == 0) { // check
    diag("%s: no size", s->name);
    v = 1;
}
@
\t if less than 0?

<<[[dodata()]] sanity check DATA instructions>>=
if(s->type != SDATA)
    diag("initialize non-data (%d): %s\n%P",
        s->type, s->name, p);

v = p->from.offset + p->reg;
if(v > s->value)
    diag("initialize bounds (%ld): %s\n%P",
        s->value, s->name, p);
@

Remember that [[Instr.reg]] is (ab)used to store
the size of the [[DATA]] {slice}, e.g., 4
in [[DATA foo+8(SB)/4, "hey!"]].



\section{Laying out code, [[dotext()]]}
\label{sec:dotext}

%trans:
We are now ready to see the last function of the 
resolving phase: [[dotext()]].
%dup: (and adapted) from resolving/dodata
As explained before,
%dup: overview/soft-archi main/asmb/text resolving/issue/pc
the goal of [[dotext()]] is to {layout} code by
essentially modifying the [[Instr.pc]] of all code instructions.
%
This field was originally storing a virtual program counter
and will contain, after [[dotext()]], a real program counter.
%
[[dotext()]] also computes the important global below which stores
the size of the text section:

<<global textsize>>=
long	textsize;
@

This global is also used to generate the [[a.out]] header
in [[asmout()]], as shown in Section~\ref{sec:gen-header}.
%
[[dotext()]] also computes [[INITDAT]] which will be used
to initialize [[R12]] at run-time.
\t and in code generation when computing absolute address sometimes!

%dup: (and adapted) resolving/dodata
The code of [[dotext()]] is pretty straightforward once all the motivations
and the big picture have been presented 
(see Section~\ref{sec:dotext-big-picture}):

<<function span(arm)>>=
/// main -> <>
void
dotext(void)
{
    Prog *p;
    Optab *o;
    // real code address
    long c; // ulong?
    // size of instruction
    int m;
    <<[[dotext()]] other locals>>

    DBG("%5.2f span\n", cputime());

    c = INITTEXT;
    <<[[dotext()]] initialisation>>

    for(p = firstp; p != P; p = p->link) {
       <<adjust curtext when iterate over instructions p>>
       <<adjust autosize when iterate over instructions p>>

        // real program counter transition
        p->pc = c;

        o = oplook(p);
        m = o->size;
        c += m;

        if(m == 0) {
            if(p->as == ATEXT) {
                if(p->from.sym != S)
                    p->from.sym->value = c;
                <<[[dotext()]] detect if large procedure>>
            } else {
                diag("zero-width instruction\n%P", p);
            }
        } else {
            <<[[dotext()]] pool handling for optab o>>
        }
    }

    <<[[dotext()]] if string in text segment>>

    c = rnd(c, 8);

    textsize = c - INITTEXT;
    <<[[dotext()]] refine special symbols>>
    if(INITRND)
        INITDAT = rnd(c, INITRND);
    DBG("tsize = %lux\n", textsize);
}
@
\t use orig instead of 'c' so match more dodata()? or better, use realpc!
\t need to modify Sym.value? used later?
\l oplook call aclass() which needs to know offset size, 
%old:
%  - was called span()
%  - the c+=m was in second else branch, but I put before
%  - the autosize adjustment was done later but actually bug?
%    anyway if was ATEXT then no aclass() call anyway
%  - the curtext adjustment was done later too
% but here it's really a concrete location whereas for dodata()
% it's relative to INITDAT that we actually compute here.


[[dotext()]] relies on modifications done by the previous functions
of the resolving phase:
\begin{itemize}
\item [[noops()]], so [[oplook()]] does not have to deal
with virtual instructions (except [[MOVW]])

\item [[patch()]], which is needed for [[noops()]] to work
\l also later for p->cond->pc but for asmout, not dotext

\item [[dodata()]], so all globals have an assigned address
(as an offset to [[R12]]) and so [[oplook()]] can predict
the size of instructions involving globals
\n aclass()

\end{itemize}

%dup: (and adapted) resolving/dodata
Note again that we are just laying out code here. We do not
generate code. The generation of the code section of
the executable is done in [[asmb()]] 
and [[asmout()]] (see Section~\ref{sec:asmout}),
not in [[dotext()]].


%\subsection{Large procedures}

<<[[dotext()]] other locals>>=
long    otxt;
@
<<[[dotext()]] initialisation>>=
otxt = c;
@
\l could do just long otxt = INITTEXT;

<<[[dotext()]] detect if large procedure>>=
if(c - otxt >= 1L<<17) {
    diag("Procedure %s too large\n", TNAME);
    errorexit();
}
otxt = c;
@
% >>
\t why large procedure special? because of limitations of ARM? why 17??
%old: there was some special code to handle really large procedures
% but the code looked buggy, so I commented it out for now.
% it was mentioning SBRA which I removed

%<<[[dotext()]] locals>>=
%bool bflag;
%@
%<<[[dotext()]] initialisation>>=
%bflag = false;
%@
%<<[[dotext()]] if large procedure set bflag>>=
%/* need passes to resolve branches */
%if(c - otxt >= 1L<<17)
%    bflag = true;
%@
%
%<<[[dotext()]] if large procedure>>=
%/*
% * if any procedure is large enough to
% * generate a large SBRA branch, then
% * generate extra passes putting branches
% * around jmps to fix. this is rare.
% */
%while(bflag) {
%    DBG("%5.2f span1\n", cputime());
%    bflag = false;
%    c = INITTEXT;
%    for(p = firstp; p != P; p = p->link) {
%        <<adjust curtext when iterate over instructions p>>
%        p->pc = c;
%        o = oplook(p);
%        m = o->size;
%        if(m == 0) {
%            if(p->as == ATEXT) {
%                autosize = p->to.offset + 4;
%                if(p->from.sym != S)
%                    p->from.sym->value = c;
%            } else {
%                diag("zero-width instruction\n%P", p);
%            }
%        } else {
%             c += m;
%        }
%    }
%}
%@
%bug? does not have the [[dotext()]] if large procedure set bflag here?

%/* very larg branches
%            if(o->type == 6 && p->cond) {
%                otxt = p->cond->pc - c;
%                if(otxt < 0)
%                    otxt = -otxt;
%                if(otxt >= (1L<<17) - 10) {
%                    q = prg();
%                    q->link = p->link;
%                    p->link = q;
%                    q->as = AB;
%                    q->to.type = D_BRANCH;
%                    q->cond = p->cond;
%                    p->cond = q;
%                    q = prg();
%                    q->link = p->link;
%                    p->link = q;
%                    q->as = AB;
%                    q->to.type = D_BRANCH;
%                    q->cond = q->link->link;
%                    bflag = 1;
%                }
%            }
% */



\section{Defining special symbols [[etext]], [[edata]], [[end]]}
\label{sec:special-symbols}

%dup: overview/hello-world/nm-exec
The linker defines a few {\em special symbols}
which allow a form of {\em reflection} on the executable structure
and its sections.
%
Those symbols and their meanings
are listed in Figure~\ref{fig:special-symbols}
which describes the memory layout of the [[hello]] executable
we saw in Section~\ref{sec:hello-world}.

\begin{figure}[!]\centering
\begin{verbatim}
                     |              |
                     |    HEAP      |
                     |              |
            ^ 0x7c50 +--------------+<---- end
            |        |     BSS      |
    bsssize |        |              |
            v 0x7940 +--------------+<---- edata (end data)
            ^        |              |
    datsize |        |     Data     |
            |        |              |
INITDAT --> v 0x7000 +--------------+<---- bdata (begin data)
                     |  (padding)   |
              0x6b58 +--------------+<---- etext (end text)
                     |              |
                     |     Code     |
                     |    (Text)    |
                     |              |
                     |              |
              0x1020 +--------------+
                     |    header    |
              0x1000 +--------------+
                     | (first page  |
                     |  unmapped)   |
                     |              |
                   0 +--------------+
                  Memory layout of hello     special symbols
                        executable
\end{verbatim}
\caption{Memory layout of [[hello]] and special symbols.}
\label{fig:special-symbols}
\end{figure}
\n also some padding before and after BSS, but very small, just 8

Those symbols are introduced by [[5l]] with [[xdefine()]]:

<<[[dodata()]] define special symbols>>=
xdefine("bdata", SDATA, 0L);
xdefine("edata", SDATA, datsize);
xdefine("end",   SBSS, datsize+bsssize);
@

<<function xdefine(arm)>>=
void
xdefine(char *p, int t, long v)
{
    Sym *s;

    s = lookup(p, 0);
    if(s->type == SNONE || s->type == SXREF) {
        s->type = t;
        s->value = v;
    }
}
@
\t should maybe diag if symbol already there no?

Note that the [[Sym.value]] for the [[bdata]] symbol
is [[0]], not [[INITDAT]]. Indeed, just like for 
globals, special data symbols have their addresses
represented as an offset to the start of the data section.
%
Moreover, [[INITDAT]] has not yet been computed in [[dodata()]].
But, it is important to layout those special symbols in [[dodata()]],
before [[dotext()]], just like globals, as they may also be
referenced in instructions.
\l There are many code later then do the final s->value _plus_ INITDAT.

Special symbols are similar to globals
but they do not take any space in the data or BSS section.
In fact, the first global of the data section will have the same
address than [[bdata]].
%
They are used only for their addresses in instructions
such as [[MOVW $etext(SB), R1]]. %$
The \plan kernel uses the addresses of those symbols
to move itself in memory during the boot procedure (see the \book{Kernel}).
\l show code?
The [[sbrk()]] system call, which is used by [[malloc()]], uses [[end]]
to know where the heap starts (see the \book{Libcore}).
\l If do &end in C (or dollar end in asm) then you'll get pointer to end of BSS

\l (part of symbol table (for debugging))

[[etext]] is also initialized in [[dodata()]] so it can be referenced
in instructions:

<<[[dodata()]] define special symbols>>=
xdefine("etext", STEXT, 0L);
@

% I wrote that, but it's buggy if keep previous xdefine as xdefine
%  set only if symbol was undefined
%<<[[dotext()]] define special symbols>>=
%xdefine("etext", STEXT, INITTEXT+textsize);
%@

But its final value can be set only in [[dotext()]]:

<<[[dotext()]] refine special symbols>>=
lookup("etext", 0)->value = INITTEXT+textsize;
@
%old: in span():
% setext = lookup("etext", 0);
% if(setext != S) {
%    setext->value = c;
%    textsize = c - INITTEXT;

Note that for code symbols, [[Sym.value]] contains a real
code address, not an offset.

\t fixpoint issue? not for dollar etext because anyway will be LCON
\t  but for etext(SB) then yes could have pb if final address
\t  become a LCON




\section{Mutual recursion in layout and [[SB/R12]]}
\label{sec:sb-r12}

The last special symbol [[5l]] defines is [[setR12]]
which we mentioned before:

<<[[dodata()]] define special symbols setR12 IF unoptimized>>=
xdefine("setR12", SDATA, 0L);
@

It is the last piece of the process we outlined in
Section~\ref{sec:dodata-big-picture} to solve the
mutual dependency issue between the layout of code and data.
%
Note that the [[Sym.value]] of [[setR12]], just like for [[bdata]],
is [[0]], not [[INITDAT]].
But, 
The address of [[setR12]] when used in an instruction,
e.g., [[MOVW $setR12(SB), R12]], %$
is recognized in a special way by the code generator
and will be converted in an instruction which loads
its {\em absolute address}, which will be [[INITDAT]].
\t ref to section that explains full thing?
%
Just like for [[etext]] and [[edata]], the use of
the special symbol [[setR12]] allows a form of reflection
which is needed to communicate the value of [[INITDAT]]
to the program.
%alt: could generate instr after _main? simpler?

% >>
% lib_core/libc/arm/main9.s will do 
%	MOVW	$setR12(SB), R(sb)
% before anything.

Section~\ref{sec:BIG} will present an optimisation around [[setR12]]
which will actually change its value.












\chapter{Machine Code Generation}
\label{chap:arm-codegen}

\t could put schematic of instruction format?

%trans:
The final step in the linking pipeline is the machine code generation.
%dup: The code generation is done by 5l, not 5a, surprisingly!
%trans:
We have seen already [[asmb()]], in Section~\ref{sec:gen-executable},
which generates the [[a.out]] header and contains some of the
logic to generate the code and data sections.
The only missing pieces were the functions 
[[oplook()]] and [[asmout()]]:

<<[[asmb()]] Text section, in iteration over instruction [[p]](repeated code)>>=
    Optab* o = oplook(p);
    asmout(p, o);
@

%toc:
Those two functions work together 
to generate the ARM instructions and will be covered in this chapter.
But before, we will describe the binary format of the
ARM instructions and present additional data structures
used by [[oplook()]] and [[asmout()]], especially [[Optab]].

%real-world: what do they do at this stage in ld? just patching?

\l principles: try leverage to the maximum the archi! => NCON because of MVN
\l  ROREG because of ADD, 0xff and MOVB opti. Specialize when can!

\section{ARM instruction format}

% 4 bytes:
\t typedef long instr; ?  so clearer oprrr, olr, immrot or partialinstr?

%dup: intro/requirements
% as said in X, great .
% excellent ARM reference card\url{http://re-eject.gbadev.org/files/armref.pdf}.
% colorful. Great to understand bit manip in code starting from Section X.
\n note about intel syntax and naming conventions explained later

% Also \book{Emulator} to fully understand semantics.

% general shape:  cond, class, rest.
% FIGURE

% mainly 4 categories, 6 formats: arith, arith with immediate,
%  memory with offsets, branch immediate, branch
% FIGURE FIGURE FIGURE FIGURE
% arith have its own set of sub-opcodes (4 bits)

% register 0 to 15 so 4 bits enough. rf, rt, r.

% immediate value, 8+4 bits

% memory address and offsets, register + 12 bits (1 page)

% => constraints on size of things so need find tricks.
% first Class will say if satisfy constraint.
% If not then pool. 
% Other?

% 1 bit of LDR vs STR, 1 bit for Sign, 1 bit for U, 1 bit for B vs Word, etc

\section{Additional data structures}
\l rules, patterns, ranges, classes

Most of the data structures presented in this section work together
to provide a concise way to express the {\em rules} of the ARM code generator.
\l burg?
A {rule} is made of a {\em pattern} specifying the shape of an instruction,
and an {\em action} to be taken if the pattern {\em matches} an instruction.
%
A single {pattern} can match a {\em set} of opcodes
\n I was using range, but then possibly confusing with Oprange
and certain {\em classes} of operands.
%
An {action} in a rule consists mostly of an {\em action identifier}
which is then used in [[asmout()]] to choose the appropriate 
{instruction generator}.
%ocaml: use pattern directly, no need special data structure

%toc: 
The following sections introduce the data structures and
a few concrete examples for
the rules, patterns, and operand classes we just mentioned.
\n and there is also Pool, which is different, and will have own section

\subsection{[[Optab]] and [[optab]]}
\label{sec:optab}
\n could put in core DS but it's really specific to the code generation chapter

The structure below represents a {rule}:

<<struct Optab(arm)>>=
struct  Optab
{
    // ---------------------------
    // The pattern (if)
    // ---------------------------

    // enum<Opcode> (the opcode is the representant of a set of opcodes)
    byte    as;

    // enum<Operand_class>, possible operand class for first operand (from)
    short   a1;
    // enum<Operand_class>, possible operand class for middle operand
    short   a2;
    // enum<Operand_class>, possible operand class for third operand (to)
    short   a3;

    // ---------------------------
    // The action (then)
    // ---------------------------

    // action id for the code generator (see the giant switch in asmout())
    short   type; 
    // size of the corresponding machine code (should be a multiple of 4)
    short   size; 

    <<[[Optab]] param field>>
    <<[[Optab]] flag field>>
};
@
\l rename Rule?
\t rename Optab.type -> Optab.action_id ?
%ocaml: use a single pattern match so far easier. no need extra DS.
% no need split between pattern and action code in asmout switch.

A very important global is [[optab]] which contains
all the rules of the ARM code generator:

<<global optab (linkers/5l/optab.c)(arm)>>=
Optab	optab[] =
{
    <<[[optab]] entries>>
    { AXXX,		C_NONE,	C_NONE,	C_NONE,		 0, 4 },
};
@
\l rename rules?
\l AXXX at the end? why not ALAST instead? and size 4??
\n order of entries not important, anyway sorted by ocmp()
%old: I removed the last 0 after the 4, to be closer to the structure def above
% and I did that for many entries

%chunks:
I will present elements of this array gradually in this chapter.
%
The last entry uses the [[AXXX]] opcode which is used as an {\em end-of-array}
marker\footnote{[[NULL]] is often used for this purpose.}.
It is recognized by [[buildop()]] which we will cover 
in Section~\ref{sec:buildop}.
%ocaml: why not simply use Array.iter?
\l why not ARRAY_LEN macro which use sizeof? cant?

Here are examples of entries in [[optab]], that is rules:

<<[[optab]] example of entries (repeated)>>=
//           Pattern                Action
{ AADD,  C_REG,  C_REG, C_REG,       1, 4 },
{ AADD,  C_RCON, C_REG, C_REG,       2, 4 },
{ AADD,  C_LCON, C_REG, C_REG,      13, 8 },
@
\n actually there is  LFROM for last entry
%alt: a series of ifs?

The first entry says that
{\em if} an instruction has for opcode [[AADD]] and 
has 3 registers ([[C_REG]]) for operands,
{\em then} the first entry (the action id [[1]]) in the dispatch
code of [[asmout()]] should be used to generate
the code, and 4 bytes should be necessary for this code
(one ARM instruction).
\l oplook(p) -> optab!  o->size !
%
In fact, this first rule will also match instructions
using [[ASUB]], [[AAND]], [[AORR]], etc. Indeed, 
as we will see in Section~\ref{sec:oprange}, [[Optab.as]]
contains the {\em representant} (here [[AADD]])
of a set of opcodes.

Up until now, the {\em class} of an operand (e.g., [[C_REG]] above),
which will be described fully in Section~\ref{sec:operand-class},
looks similar to the {\em kind} of an operand, which we presented
quickly in Section~\ref{sec:opcode-operand} and
fully in the \book{Assembler}.
%
Indeed, [[C_REG]] is very similar to the operand
kind for registers [[D_REG]].
%
For constants though we will start to see a deviation.
Indeed, the operand kind [[D_CONST]] is actually divided in
multiple operand classes: [[C_RCON]], [[C_LCON]],
and a few more we will describe in Section~\ref{sec:operand-class-DCONST}.
%
The reason for the division is that depending on the value of the constant,
one might need to use different kinds of instructions.
For instance, the third entry of [[optab]] above says that if the first
operand is a large constant ([[C_LCON]]), then 2 ARM instructions
will be necessary (8 bytes). 
\l one extra which loads REGTMP
%
If the number is small
or can be rotated in a certain way ([[C_RCON]]), then 1 ARM instruction
will be enough, as indicated by the second entry above.
Indeed, this small or rotatable number can be encoded directly 
in the instruction.

%assembler:
% There is a strong coupling with the grammar 5a/a.y to see
% what operands are allowed, e.g., AMOV has gen operand which
% allow many things, but AADD has more restricted operands
% (immediate, shift, or plain register).

\t optab must contain many rules to cover whole spectrum. in fact
\t  coupling with 5a/a.y and also reason for late messages
\t  e.g., MOVW (R1), (R1)

The [[optab]] global will be eventually sorted in [[buildop()]]
with the {ordering function} [[ocmp()]] which we will 
see in Section~\ref{sec:ocmp}.
All the rules about [[AADD]] will then
be put next to each other in the array (if they were originally spread).
In fact, [[ocmp()]] orders first by opcodes, but also then by operand
classes. The order for those classes is actually important as we
will see later.
\l For instance C_HFAUTO must be before C_LAUTO otherwise
% the careful order of entries in optab will not be taken
% into account.

[[Optab]] has two optional fields, [[Optab.param]] and [[Optab.flag]]
which will be presented later in this chapter.
\l this is why some rules have extra elements
%\subsection{[[Optab.param]] and [[Optab.flag]]}
% {rule parameter}
% {rule flag}



\subsection{[[Oprange]]}
\label{sec:oprange}

The structure below represents a {\em range} of entries
in the sorted global [[optab]]:

<<struct Oprange(arm)>>=
struct  Oprange
{
    //starting index in (sorted) optab
    Optab*  start;
    //ending index in (sorted) optab
    Optab*  stop;
};
@
%old: was Oprang
%ocaml: no need as factorized opcodes in big categories already (Arith, Mov)
% and for the optimisation aspect of oprange we can hope for fast
% compiled pattern matching

The global below associates a range to every opcode:

<<global oprange(arm)>>=
// map<enum<Opcode>, Oprange>
Oprange	oprange[ALAST];
@

[[oprange]] is also set by [[buildop()]] and contains
originally the ranges for the opcodes mentioned in the [[optab]] array.
For instance, the range for [[AADD]], given the [[optab]] entries
of the previous section, could be:
\begin{verbatim}
// range for AADD, optab[0..3[ <=> optab[0..2]
{ .start = &optab[0];
  .stop  = &optab[3];
}
\end{verbatim}

This range will be the starting point for the algorithm in [[oplook()]]
to find the rule matching an instruction (see Section~\ref{sec:oplook}).
%
Indeed, given an instruction [[p]], [[oplook()]] will look first in 
[[oprange[p->as]]] to get a range of entries.
[[oplook()]] can then iterate over all those entries, which are rules,
%ocaml: compiled big match is efficient? will sort by opcode?
and check if the classes of the operands 
[[p->from]], [[p->reg]], and [[p->to]] match the one specified
in the rule. The operand matching function is actually not just
equality but a subtle function, [[cmp()]],
which we will see in Section~\ref{sec:cmp}.
%
The first rule matching the instruction will be returned
by [[oplook()]].


In addition to its role as an {\em indexing structure} for [[oplook()]],
[[oprange]] can also be used to {\em factorize} rules.
Indeed, by doing for instance 
[[oprange[ASUB] = oprange[AADD];]] at the end of [[buildop()]],
all the rules with [[AADD]] in [[optab]] will be tried for instructions
with the opcode [[ASUB]]. So, in effect [[AADD]] becomes the
{\em representant} of the set of opcodes [[{AADD, ASUB}]].
%
Then, one just needs to write rules with [[AADD]] instead of
having to repeat them also for [[ASUB]].
\n one form of general pattern, for instr, will see another one soon
%chunks:
I will gradually see in this chapter the different opcodes sets
and their representants.


\subsection{[[Operand_class]]}
\label{sec:operand-class}
\n was in core DS, but I think better here with Optab.

%trans:
We have seen already a few elements of the
[[Operand_class]] type: [[C_REG]], [[C_RCON]], and [[C_LCON]].
%
As mentioned before, the operand classes are similar
to the operand kinds. In fact, many are almost
identical, e.g., [[C_REG]] versus [[D_REG]]:

%\subsubsection{Basic classes}

<<enum Operand_class(arm)>>=
// order of entries for one kind matters! coupling with cmp() and ocmp()
enum Operand_class {
    C_NONE      = 0,

    C_REG,     // D_REG
    C_BRANCH,  // D_BRANCH

    // D_CONST
    <<[[Operand_class]] C_xCON cases>>

    // D_OREG
    <<[[Operand_class]] C_xOREG cases>>
    // D_OREG with symbol N_EXTERN (or N_INTERN)
    <<[[Operand_class]] C_xEXT cases>>
    // D_OREG with symbol N_PARAM or N_LOCAL
    <<[[Operand_class]] C_xAUTO cases>>

    // D_ADDR
    <<[[Operand_class]] C_xxCON cases>>

    <<[[Operand_class]] cases>>
    C_GOK, // must be at the end e.g., for xcmp[] decl, or buildop loops
};
@
%assembler: diffs with operand_kind
% - OREG split in many xxxOREG and xxxEXT (SB), xxAUTO (FP, SP)
% - D_CONST split in many xxxCON
% - a new C_GOK, but could be called C_LAST I think
%pad: was originally in the same enum than STEXT, SBSS, etc, so I split
% and named it Operand_class, consistent with Operand_kind. C vs D.
% and also because there was a function called aclass()
%dead: there was C_SBRA, C_LBRA but LBRA was unused so I s/C_LBRA/C_BRANCH/
% there was also this in cmp()
%    case C_LBRA:
%        if(b == C_SBRA)
%            return 1;
%        break;
%ocaml: no need C_GOK, and can have subclasses via general constructor
% and subconstructors

Some kinds are also divided in {\em subclasses}, e.g.
[[D_CONST]] in [[C_RCON]], [[C_LCON]], and a few more.
%chunks:
We will present those subclasses gradually in this chapter.
\l order of entries matter! look at code of cmp() to see which
\l  classes are subclasses and must be after.

%\subsubsection{[[aclass()]]}

The function below converts an operand kind to an operand class.
It is used notably by [[oplook()]]:

<<function aclass(arm)>>=
// oplook | ... -> <>
int
aclass(Adr *a)
{
    <<[[aclass()]] locals>>

    switch(a->type) {
    <<[[aclass()]] switch type cases>>
    }
    return C_GOK;
}
@
\l C_GOK, defensive programming, should never happen

<<[[aclass()]] switch type cases>>=
case D_NONE:
    return C_NONE;
case D_REG:
    return C_REG;
case D_BRANCH:
    return C_BRANCH;
@

Up until now the code of [[aclass()]] is pretty simple.
Later, for operands involving constants ([[D_CONST]]),
offsets ([[D_OREG]]), or addresses ([[D_ADDR]]), 
the code will be more complicated as one operand kind
may lead to different subclasses.
%
In fact, [[aclass()]] assumes the layout of globals
has already been done (via [[dodata()]]).
That way [[aclass()]] can know for instance the section and 
concrete offset of a global.
This is necessary to know the subclass of this operand, to know
for instance whether the offset is small enough 
to be encoded directly in the instruction.
\l See section X for all refined classes.

<<[[aclass()]] locals>>=
Sym *s;
// enum<Section>
int t;
@
\l add i, because abuse t for different things

\t well called from dotext, where INITDAT not set yet, but offset set
\t so enough to know if can do RECON. If not then do LCON so fine,
\t no need to know INITDAT. Also for code address STEXT then always
\t use LCON too so safe. just that instoffset value during dotext
\t is incorrect.





\section{[[oplook()]] and [[buildop()]]}

%trans:
We are now ready to understand the code of [[oplook()]].
%
[[oplook()]] assumes the global [[optab]] has been
sorted and [[oprange]] has been set. 
Those two operations are performed by [[buildop()]]
%toc:
which we will present after [[oplook()]].

\subsection{[[oplook()]] and [[cmp()]]}
\label{sec:oplook}

[[oplook]] takes an instruction as a parameter and returns
a rule ([[Optab*]]) {matching} the opcode and operands
of the instruction.
%
Its code is pretty simple once the different data structures it is using
have been explained and its optimization hidden (for now):

<<function oplook(arm)>>=
/// main -> (dotext | asmb) -> <>
Optab*
oplook(Prog *p)
{
    // enum<Opcode> (to index oprange[])
    int r;
    // enum<Operand_class>
    int a1, a2, a3;
    // ref<Optab> (from = optab)
    Optab *o, *e;
    <<[[oplook()]] other locals>>
 
    <<[[oplook()]] if use opti, part1>>
    else {
        a1 = aclass(&p->from);
        a3 = aclass(&p->to);
    }
    a2 = (p->reg != R_NONE)? C_REG : C_NONE;
    r = p->as;

    // find the range of relevant optab entries
    o = oprange[r].start;
    e = oprange[r].stop;
    <<[[oplook()]] sanity check o>>

    <<[[oplook()]] debug>>

    <<[[oplook()]] if use opti, part2>>
    else {
        // iterate over the range
        for(; o<e; o++)
            // compare the operands
            if(o->a2 == a2)
             if(cmp(o->a1, a1))
              if(cmp(o->a3, a3)) {
                // found a matching rule!
                return o;
            }
    }
    <<[[oplook()]] illegal combination error>>
}
@
%pad: I rewrote a lot this code to aspectize optimisations and to have
% a simpler version. It's far clearer.
%ocaml: just use pattern matching

If no rule is found a linking error is reported:

<<[[oplook()]] sanity check o>>=
if(o == nil) {
    o = oprange[r].stop; /* just generate an error */
}
@
<<[[oplook()]] illegal combination error>>=
diag("illegal combination %A %d %d %d",  p->as, a1, a2, a3);
prasm(p);
if(o == nil)
    o = optab;
return o;
@
%ocaml: checked by construction thx to precise ast_asm.ml

\t important, happens often. e.g., MOVW (R1), (R2)
\t have to use intermediate MOVW (R1), R10;  MOVW R10, (R2)
\t this is why need very complete optab.
\n ugly a bit, late error.

\label{sec:cmp}
The {matching} of operand classes in [[oplook()]] is using simply
[[==]] for the middle operand ([[a2]]). Indeed, this operand class
is always either a register ([[C_REG]]) or nothing ([[C_NONE]]).
But, for the other operands the function [[cmp()]] (for compatible)
below is used:

<<function cmp(arm)>>=
bool
cmp(int a, int b)
{

    if(a == b)
        return true;

    switch(a) {
    <<[[cmp()]] switch on a, the operand class in optab rule, cases>>
    }
    return false;
}
@
\l rename compatible_operand?
\n diff with ocmp? 
\n  - this is only for one operand, ocmp is sorting the whole p
\n  - it does not care about the order of the classes. ocmp care
\n  - it does return a boolean, not a cmp_result

[[cmp()]] is used as [[cmp(o->a1, a1)]] in [[oplook()]],
so the parameter [[a]] corresponds to the class
of the operand in one of the rule of [[optab]] ([[o->a1]]),
and the parameter [[b]] the actual class of the
operand of the instruction ([[a1]]).
%
Up until now [[cmp()]] is similar to [[==]]. But, for certain
classes, [[cmp()]] can also express {inclusion} between classes and
a notion of {subclasses}.
%
For instance, if the operand class of a rule is [[C_LCON]],
then it will also match the actual operand classes [[C_RCON]]
and [[C_NCON]] of the instruction thanks to this code:

<<[[cmp()]] switch on a, the operand class in optab rule, cases>>=
case C_LCON:
    if(b == C_RCON || b == C_NCON)
        return true;
    break;
@

Indeed, a large constant ([[C_LCON]]) is more {general} than
a rotatable constant ([[C_RCON]]) or a negative rotatable constant
([[C_NCON]]).
\l FIGURE VENN diagram
\l But if rule C_RCON, match only C_RCON!
Thanks to this encoding of inclusion via cases of [[cmp()]],
a single rule can match many different kinds of instructions.
%
Just like [[oprange]] we saw in Section~\ref{sec:oprange}
allows with one opcode to actually match a set of opcodes, 
[[cmp()]] allows with one {\em general} operand class (e.g., [[C_LCON]])
to actually match also more {\em specialized} operand classes 
(e.g., [[C_RCON]] and [[C_NCON]]).
%chunks:
We will present those general and specialized
classes, and their encoding in [[cmp()]],
gradually in this chapter.
\n will see also soon that order is important! see next section



\subsection{[[buildop()]] and [[ocmp()]]}
\label{sec:buildop}

[[buildop()]] is pretty simple. 
%dup: machine-gen/oplook
It sorts [[optab]] and then sets [[oprange]] which
is used by [[oplook()]]:

<<[[main()]] initialize globals(arm)>>=
buildop();
@
\l rename build_oprange?

<<function buildop(arm)>>=
/// main -> <>
void
buildop(void)
{
    int i, n;
    // enum<Opcode> representing a range
    int r;

    <<[[buildop()]] initialize xcmp cache>>
    <<[[buildop()]] initialize flags>>

    for(n=0; optab[n].as != AXXX; n++) {
        <<[[buildop()]] adjust optab if flags, remove certain rules>>
    }
    // n contains now the size of optab

    qsort(optab, n, sizeof(optab[0]), ocmp);

    for(i=0; i<n; i++) {
        r = optab[i].as;

        // initialize oprange for the representants
        oprange[r].start = optab+i;
        while(optab[i].as == r)
            i++;
        oprange[r].stop = optab+i;
        i--; // compensate the i++ of the for

        // setup opcode sets of representants
        switch(r)
        {
        <<[[buildop()]] switch opcode r for ranges cases>>
        default:
            diag("unknown op in build: %A", r);
            errorexit();
        }
    }
}
@
%dead:
%  case ABX:
%  case ABXRET:
%  ...
\n the cases in the switch must be the entries in optab, not more, not less,
\n no ARET in switch? no because noops should have rewrite it.
\n no ADATA/AGLOBL? buildop is used for code generation, not data

%chunks:
The cases of the [[switch]] above, which we will present gradually
in this chapter, specify the opcodes sets of the representants.

<<[[buildop()]] switch opcode r for ranges cases>>=
case AXXX:
  break;
@
\t AXXX should be dead as it's after n ... ? but get ``unknown op in build''!
\t  it is because of V4 and VFP which generates new AXXX entries


The {ordering} of rules in the sorted [[optab]] is governed by 
the function below:

\label{sec:ocmp}
<<function ocmp(arm)>>=
/// main -> buildop -> qsort(..., <>)
int
ocmp(const void *a, const void *b)
{
    Optab *p1, *p2;
    int n;

    p1 = (Optab*)a;
    p2 = (Optab*)b;

    n = p1->as - p2->as;
    if(n)
        return n;
    <<[[ocmp()]] if v4 flag on p1 or p2>>
    <<[[ocmp()]] if floating point flag on p1 or p2>>
    n = p1->a1 - p2->a1;
    if(n)
        return n;
    n = p1->a2 - p2->a2;
    if(n)
        return n;
    n = p1->a3 - p2->a3;

    if(n)
        return n;
    return 0;
}
@
%old: (const void *a1, const void *a2) but confusing with fields of optab

[[ocmp()]] orders first by opcode (opcodes with lower enumeration values in
[[Opcode]] are first),
then by the class of the first
operand, then second, and finally third operand.
%
\label{sec:order-operand-class-matters}
Note that the order of the enumerations cases in [[Operand_class]]
matters. Indeed, if [[C_RCON]] was after [[C_LCON]], as in:
\begin{verbatim}
enum Operand_class {
 ...
 C_LCON,
 ...
 C_RCON
 ...
};
\end{verbatim}

\noindent the enumeration value of [[C_RCON]] would be greater than [[C_LCON]].
Then entries in [[optab]] will be sorted as follows:

\begin{verbatim}
// sorted optab
optab[] = {
 ...
{ AADD,  C_LCON, C_REG, C_REG,      13, 8 },
{ AADD,  C_RCON, C_REG, C_REG,       2, 4 },
 ...
};
\end{verbatim}

But, [[C_LCON]] is considered more general than [[C_RCON]]
according to [[cmp()]]. That means that an arithmetic instruction
with a small or rotatable constant as a first operand will
already match the rule with [[C_LCON]] in [[oplook()]] which
is unfortunate. Indeed, we would rather have it match
the rule with [[C_RCON]] which is more specialized.
%
This is why the order of enumerations in [[Operand_class]] 
matters. [[C_RCON]] must be before [[C_LCON]] as in:
\begin{verbatim}
enum Operand_class {
 ...
 C_RCON,
 C_LCON,
 ...
};
\end{verbatim}

The enumerations of general operand classes must be after the
enumerations of their subclasses.



\subsection{Optimizations}
\l could be in Adv Topics? maybe easier to understand now, and pretty simple

There are a few optimizations which improve
[[oplook()]], [[aclass()]], and [[cmp()]], which we will cover now.

\subsubsection{Caching}

The first set of optimizations involves {\em caching} (a.k.a {\em memoizing}).
%
[[oplook()]] is called once from [[dotext()]] and another time
from [[asmb()]] so it makes sense to cache the result of
the first call to [[oplook()]],
that is the rule matching an instruction, in the instruction itself:

<<[[Prog]] other fields>>=
// option<index in optab[] (1-based)>, 0 means None, i means optab[i-1]
byte    optab;
@
\l byte enough?? less than 256 entries in optab?
%ocaml: use option, cleaner than this ugly -1

In the same way, [[aclass()]] is called from [[oplook()]] but
also from [[asmout()]], so we can also cache the result
of [[aclass()]] in the operand itself:
\l aclass call immrot, immaddr, etc, so nice to cache.

<<[[Adr]] other fields>>=
// option<enum<Operand_class>>, 0 means None, i means i-1 is the class you want
short   class;
@
%old: was char, but ugly
\t initialized correctly in zprg? I don't think so. bug? no cos zeroed page
\t when use brk

Those caching fields are used and set in [[oplook()]]:

<<[[oplook()]] other locals>>=
bool useopti = true;
int i;
@
%pad: I introduced useopti, to aspectize optimisations
% and to introduce non-optimized code that I wrote myself
%old: was abusing a1, but I prefer use different variable name, so I added i

<<[[oplook()]] if use opti, part1>>=
if(useopti) {
    i = p->optab;
    if(i)
        return optab+(i-1);
    
    a1 = p->from.class;
    if(a1 == 0) {
        a1 = aclass(&p->from) + 1;
        p->from.class = a1;
    }
    a1--;
    
    a3 = p->to.class;
    if(a3 == 0) {
        a3 = aclass(&p->to) + 1;
        p->to.class = a3;
    }
    a3--;
}
@
%old: was abusing a1 for optab, now I use i

<<[[oplook()]] if use opti, in part2, memoize matching rule [[o]]>>=
p->optab = (o-optab)+1;
@

Note that if one transforms an instruction [[p]] after
the result of [[oplook()]] or [[aclass()]] has been
cached in [[p]] and its operands, one should reset
this cache with [[nocache()]] below. That way it will force 
the next call to [[oplook()]] and [[aclass()]] to recompute things:

<<function nocache(arm)>>=
void
nocache(Prog *p)
{
    p->optab = 0;
    p->from.class = 0;
    p->to.class = 0;
}
@

%dead:
%  This is notably used for [[ARET]] which is indeed transformed
%  in [[noops()]]:
%  
%  <<[[noops()]] case ARET, call nocache>>=
%  nocache(p);
%  @
% but useless I think. Dead since optab is used only in oplook()
% which is called only by span() and asmb() which are both called
% long after noops().
% Moreover there is not even a rule with ARET in optab.



\subsubsection{Precomputing}

Another optimization {\em precomputes} the result of [[cmp()]]
on any pair of operand classes:

<<global xcmp(arm)>>=
bool	xcmp[C_GOK+1][C_GOK+1];
@
%old: was char, but I prefer bool
\l why plus 1? could have NOPCLASS

<<[[buildop()]] initialize xcmp cache>>=
for(i=0; i<C_GOK; i++)
    for(n=0; n<C_GOK; n++)
        xcmp[i][n] = cmp(n, i);
@
\l subtle the order to cmp here, cmp(n,i) not cmp(i,n)
\t bug? should be <= since do +1 above. or assume will be false.

This in turns will improve [[oplook()]].

<<[[oplook()]] other locals>>=
bool *c1, *c3;
@
%old was char

<<[[oplook()]] if use opti, part2>>=
if(useopti) {
    c1 = xcmp[a1];
    c3 = xcmp[a3];
    for(; o<e; o++)
        if(o->a2 == a2)
         if(c1[o->a1])
          if(c3[o->a3]) {
            <<[[oplook()]] if use opti, in part2, memoize matching rule [[o]]>>
            return o;
        }
}
@


%dead: was commented in original code already, so dead.
%/*
%void
%buildrep(int x, int as)
%{
%    Opcross *p;
%    Optab *e, *s, *o;
%    int a1, a2, a3, n;
%
%    if(C_NONE != 0 || C_REG != 1 || C_GOK >= 32 || x >= nelem(opcross)) {
%        diag("assumptions fail in buildrep");
%        errorexit();
%    }
%    repop[as] = x;
%    p = (opcross + x);
%    s = oprange[as].start;
%    e = oprange[as].stop;
%    for(o=e-1; o>=s; o--) {
%        n = o-optab;
%        for(a2=0; a2<2; a2++) {
%            if(a2) {
%                if(o->a2 == C_NONE)
%                    continue;
%            } else
%                if(o->a2 != C_NONE)
%                    continue;
%            for(a1=0; a1<32; a1++) {
%                if(!xcmp[a1][o->a1])
%                    continue;
%                for(a3=0; a3<32; a3++)
%                    if(xcmp[a3][o->a3])
%                        (*p)[a1][a2][a3] = n;
%            }
%        }
%    }
%    oprange[as].start = 0;
%}
%*/
%
%
%dead: there was this in oplook() but I think it could not work
% if buildrep() was not called:
%    if(o == nil) {
%        a1 = opcross[repop[r]][a1][a2][a3];
%        if(a1) {
%            p->optab = a1+1;
%            return optab+a1;
%        }
%        o = oprange[r].stop; /* just generate an error */
%    }
%dead:
% extern	uchar	repop[ALAST];
% %<<global repop(arm)>>=
% uchar	repop[ALAST];
% @
% typedef	uchar	Opcross[32][2][32];
% %extern	Opcross	opcross[8];
% %<<global opcross(arm)>>=
% Opcross	opcross[8];
% @

\section{[[asmout()]]}
\label{sec:asmout}
\l and endianess

[[asmout()]] is the heart of the ARM code generator.
%
Given an instruction [[p]] and a rule [[o]]
found via [[oplook()]], [[asmout()]] will dispatch
the action identifier in [[o->type]] in a big
[[switch]] which generates the ARM code:

<<function asmout(arm)>>=
/// main -> asmb -> for p { <> }
void
asmout(Prog *p, Optab *o)
{
    // ARM 32 bits instructions, set in the switch
    long o1, o2, o3, o4, o5, o6;
    <<[[asmout()]] other locals>>

    o1 = o2 = o3 = o4 = o5 = o6 = 0;

    // first switch, action id dispatch, set o1, o2, ...
    switch(o->type) {
    <<[[asmout()]] switch on type cases>>
    default:
        diag("unknown asm %d", o->type);
        prasm(p);
        break;
    }

    <<[[asmout()]] debug>>

    // second switch, output o1, o2, ...
    switch(o->size) {
    <<[[asmout()]] switch on size cases>>
    }
}
@
%$
\t long -> ulong for instr? typedef?
\t long for pc? also typedef? realpc?

Note that one instruction [[p]] in the object file
may lead to the generation of up to 6 ARM instructions
(24 bytes) in the executable, hence the use of local variables 
up to [[o6]] above.
Those local variables are set in the cases of the first [[switch]]
%chunks:
(cases we will see gradually in this chapter)
%
and passed later to [[lputl()]] in cases of the second [[switch]]:

<<[[asmout()]] switch on size cases>>=
case 4:
    <<[[asmout()]] when 1 generated instruction, debug>>
    lputl(o1);
    break;
case 8:
    <<[[asmout()]] when 2 generated instructions, debug>>
    lputl(o1);
    lputl(o2);
    break;
case 12:
    <<[[asmout()]] when 3 generated instructions, debug>>
    lputl(o1);
    lputl(o2);
    lputl(o3);
    break;
case 16:
    <<[[asmout()]] when 4 generated instructions, debug>>
    lputl(o1);
    lputl(o2);
    lputl(o3);
    lputl(o4);
    break;
case 20:
    <<[[asmout()]] when 5 generated instructions, debug>>
    lputl(o1);
    lputl(o2);
    lputl(o3);
    lputl(o4);
    lputl(o5);
    break;
case 24:
    <<[[asmout()]] when 6 generated instructions, debug>>
    lputl(o1);
    lputl(o2);
    lputl(o3);
    lputl(o4);
    lputl(o5);
    lputl(o6);
    break;
default:
    <<[[asmout()]] when other size, debug>>
    break;
@
\n could put case 0 accepted only for ATEXT, but done too in caller in asmb
%ocaml: could return a list instead of hardcoded o1, o2, ...

%dup: and adapted from loading/ldobj/buffered-input
[[lputl()]] is one of the function from the 
{\em input/output buffer management} library
described in Appendix~\ref{sec:buffer-management}.
\l which we introduced partially in Section loading.
%
The most important thing for this chapter is that [[lputl()]] fills
an array of bytes in [[Buf.obuf]], the {\em output buffer},
through a global [[cbp]] setup in [[main()]]:

<<global cbp>>=
// array<byte> (slice of buf.obuf) 
char*	cbp;
@
<<global cbc>>=
// remaining bytes in buf.obuf
int	cbc;
@

<<[[main()]] initialize globals(arm)>>=
cbp = buf.obuf;
cbc = sizeof(buf.obuf);
@

Then, this buffer gets {\em flushed} once in a while in [[cflush()]],
which finally outputs the data in the executable
via the global [[cout]]:


<<function lputl(arm)>>=
void
lputl(long l)
{

    cbp[3] = l>>24;
    cbp[2] = l>>16;
    cbp[1] = l>>8;
    cbp[0] = l;
    cbp += 4;
    cbc -= 4;
    if(cbc <= 0)
        cflush();
}
@
\t how know had enough space for 4 bytes?? bug?
%bug! if have intermediate calls to cput then yes can have bugs!
% otherwise lucky that MAXIO is multiple of 4

<<function cflush>>=
void
cflush(void)
{
    int n;

    n = sizeof(buf.obuf) - cbc;
    if(n)
        write(cout, buf.obuf, n);

    cbp = buf.obuf;
    cbc = sizeof(buf.obuf);
}
@
\l simpler than input buffer
%ocaml: no need, just return list of words and then let ocaml do the flushing
% when write in executable

Note that [[lputl()]] means ``long put little-endian''.
The lowest byte of a number have the lowest memory address.
Indeed the ARM uses a little-endian architecture.
\n actually bi
There is another function [[lput()]], which does a similar
thing but for {big-endian} architecture, where
the lower bits of a number have the higher address (as in the x86):

<<function lput(arm)>>=
void
lput(long l)
{

    cbp[0] = l>>24;
    cbp[1] = l>>16;
    cbp[2] = l>>8;
    cbp[3] = l;
    cbp += 4;
    cbc -= 4;
    if(cbc <= 0)
        cflush();
}
@

In fact, this function is actually used for the [[a.out]] generation
in Section~\ref{sec:gen-header}. Indeed the [[a.out]] format
imposes a big-endian order for the numbers in the header.
\l can say big endian more convenient when comparing to hexdump!
\l  because we read from left to right and 0x12345678 would be
\l  stored in memory and dump as 12 34 56 78 on a big-endian machine


\bigskip
The cases of the first [[switch]] in [[asmout()]] will rely
on a set of temporary variables to store registers
and symbols:

<<[[asmout()]] other locals>>=
int rf; // register ``from''
int rt; // register ``to''
int r;  // middle register
Sym *s;
@




\bigskip
%trans: %chunks:
The rest of this chapter will present gradually the different cases
of the first [[switch]] of [[asmout()]].
%
In fact, each of those cases is associated with a set of entries 
in [[optab]] which
mention the action identifier representing the case.
This is why we will present also gradually those entries.
%
In the same way the set of opcodes in [[oprange]]
%the class and subclasses in [[Operand_class]], and their order in [[cmp()]] 
will be gradually explained in the following sections next to the
entries of optab and the cases of [[asmout()]].
%
All those elements work together to express the ARM code generation rules
of [[5l]].
%ocaml: pattern and final action would be together, no need split
% in one function oplook() and another asmout()

\section{Pseudo opcodes}

%toc:
The first code generation rules we will see concern pseudo-opcodes.

\subsection{[[ATEXT]]}

[[ATEXT]] is kept in the list of code instructions only
for [[curtext]], so that error messages can mention in which
procedure the problematic instruction is.
%
No code is generated for [[ATEXT]]:

<<[[optab]] entries>>=
{ ATEXT,	C_LEXT,	C_NONE,	C_LCON, 	 0, 0 },
{ ATEXT,	C_LEXT,	C_REG,	C_LCON, 	 0, 0 },
@
\l could explain now C_LEXT, C_REG in middle, and C_LCON
<<[[buildop()]] switch opcode r for ranges cases>>=
case ATEXT:
    break;
@
<<[[asmout()]] switch on type cases>>=
case 0:		/* pseudo ops */
    break;
@
\l noops() has patched it with the initial mov to save REGLINK in stack
%ocaml: no need repeat operand classes, by construction ast_asm ensures that

\subsection{[[AWORD]]}

[[WORD]] is a directive which provides an adhoc way
to write a word (hence the name) in the code section.
%
It is often used to overcome some limitations of [[5a]]
which does not handle every possible opcodes, e.g.
opcodes to call a coprocessor (see the \book{Assembler}).
%
It is also used to represent large literal constants in the 
code section, which is very useful to support the encoding of certain
instructions as we will see in Section~\ref{sec:pool}.

<<[[optab]] entries>>=
{ AWORD,	C_NONE,	C_NONE,	C_LCON,		11, 4 },
@
%pad: I originally thought the following was a dead rule:
% { AWORD,	C_NONE,	C_NONE,	C_LEXT,		11, 4, 0 },
% Indeed what means WORD foo; ?
% WORD $foo; ok, I get it, but then it should be a C_LACON, not an C_LEXT
% BUT, because of the literal pools, one can have some generated
% AWORD instruction with for operand an C_LEXT!
\t more rules with AWORD actually!

%dup: codegen/ds/optab codegen/ds/operand-class codegen/oplook codegen/buildop
Remember than [[C_LCON]] is a general operand class
and so the single rule above will also match instructions
with operands having (sub)classes such as [[C_RCON]] or [[C_NCON]].

<<[[buildop()]] switch opcode r for ranges cases>>=
case AWORD:
    break;
@

\ifallcode
<<[[asmout()]] other locals>>=
int c;
@
\fi

<<[[asmout()]] switch on type cases>>=
case 11:	/* word */
    c = aclass(&p->to);
    <<[[asmout()]] in AWORD case, when dlm>>
    o1 = instoffset;
    break;
@
%pad: I rewrote to aspectize more the switch by introducing extra local c

In addition to returning the class of an operand, [[aclass()]] has
also for side effect to modify the global [[instoffset]],
%trans:
as we will see in the next section. %clever ref{sec:operand-subclasses}
%
This global contains the immediate constant or offset in the operand.
So, [[o1]] above will contain [[p->to.offset]].
%
Remember that the second [[switch]] of [[asmout()]] will eventually
output the content of the local variable [[o1]] in the executable.



\section{Operand subclasses and [[instoffset]]}
\label{sec:operand-subclasses}

%trans:
Before seeing the ARM code generation rules for arithmetic
instructions, memory instructions, and more,
%toc:
we will present in this section the remaining operand classes
and subclasses used in [[5l]]. Those classes 
are referenced in many of the code generation rules.
We will also finish to present the code of [[aclass()]].
%dup: codegen/pseudo/word
As said before, [[aclass()]] also modifies the following global,
which is then used extensively in [[asmout()]]:

<<global instoffset(arm)>>=
long	instoffset;
@
\l instruction offset? but it's actually more operand offset.
\l  but it is true than there is usually only 1 offset in a full instr
\n really needs to be a global? yes! used outside aclass()?
\t seems to be used both for immediate constant and offset
\t  also for locals it is actually autosize plus offset, so it is many
\t  things at the same time
%ocaml: aclass() should return a pair!

\subsection{[[D_CONST]], [[C_xCON]], and [[immrot()]]}
\label{sec:operand-class-DCONST}

%dup: codegen/ds/optab codegen/ds/operand-class codegen/oplook codegen/buildop
We mentioned before the general class 
[[C_LCON]] (large constant) and its subclasses 
[[C_RCON]] (rotatable small constant) and 
[[C_NCON]] (rotatable small negative constant):

<<[[Operand_class]] C_xCON cases>>=
C_RCON,     /* 0xff rotated */ // [0..0xff] range, possibly rotated
C_NCON,     /* ~RCON */
C_LCON,
@
%dead: C_SCON,		/* 0xffff */
\t NCON similar to LCON when you look at optab? maybe but does not use LFROM
\t  so probably different! 
\t NCON cos can leverage MVN at least
\l Those are some kinds of optimisations? Can not just take always LCON? maybe.
\l but those are important optimisations. linker is supposed to leverage every
\l speed opportunities offered by the machine.

%dup: codegen/buildop/ocmp
Remember from Section~\ref{sec:order-operand-class-matters}
that the order of those enumeration matters, and that
the general class [[C_LCON]] must be after its subclasses
[[C_RCON]] and [[C_NCON]].

All those classes derive from the operand kind [[D_CONST]]:

<<[[aclass()]] switch type cases>>=
case D_CONST:
    instoffset = a->offset;
    if(a->reg != R_NONE) // when??????
        goto aconsize;

    if(immrot(instoffset))
        return C_RCON;
    if(immrot(~instoffset))
        return C_NCON;
    return C_LCON;
@
%old: now use D_ADDR instead
%    switch(a->symkind) {
%    <<[[aclass()]] D_CONST case, switch symkind cases>>
%    }
%    return C_GOK;
%  ...
%  <<[[aclass()]] D_CONST case, switch symkind cases>>=
%  case N_NONE:
%  ...
\t when get not R_NONE?? for D_ADDR on automatic variables? when have no sym?
\t  but then should still have a symkind, so dead code??

%\subsection{immediate values (possibly rotated), [[immrot()]]}

%trans:
We can now define what is a rotatable small number 
and see the code of [[immrot()]].
%dup: from Assembler,  TODO overview/arm/immediate-range?
\label{sec:clever-trick-numbers}
The ARM use 12 bits to encode immediate constants in arithmetic
instructions but it is using a clever trick
to be able to represent numbers larger than 4096.
%
Indeed, the 12 bits are divided in two parts: 8 bits to represent
a number from [[0]] to [[0xff]], and 4 bits to represent
a rotation of this number. The 16 possible rotations
are not simply a bitshift to the left from 0 to 15.
Indeed, this would not be enough to represent large numbers
such as $2^31$. Instead, each rotation is a double bit rotation to
the right.
Here are a few examples of numbers and their ARM encoding:
\begin{verbatim}
0    => rotation = 0b0000; number = 0b00000000
255  => rotation = 0b0000; number = 0b11111111
256  => rotation = 0b1100; number = 0b00000001
512  => rotation = 0b1100; number = 0b00000010
2^31 => rotation = 0b0001; number = 0b00000010
\end{verbatim}

%dup: (and adapted slightly) Assembler
Not all 32 bits integers can be represented
using that scheme but many important numbers like all
the powers of 2 between 0 and 31 can be expressed
which is very useful in operations involving bitsets.
\n but not bitmasks
See \url{http://alisdair.mcdiarmid.org/arm-immediate-value-encoding/}
for an excellent tutorial on the topic. This page contains also
an interactive application where you can enter any number and
get its encoding (when the number is rotatable).

We can now see the code of [[immrot()]]:

<<function immrot(arm)>>=
// ulong -> option<long> (None = 0)
long
immrot(ulong v)
{
    // the rotation
    int i;

    for(i=0; i<16; i++) {
        if((v & ~0xff) == 0)
            //      i,r,r opcodes       rotation     number        
            return  (1<<25)         |    (i<<8)   |   v     ;
        // inverse of 2 bits rotation to the right
        v = (v<<2) | 
            (v>>30);
    }
    return 0;
}
@
% >> >>
%old: last instruction put on separate lines otherwise noweb issue
\t so immrot(0) == 0? no cos bit will be set, which is
\t  why it sets bit 25, because 0 already used for NONE, ugly! subtle!
%ocaml: maybe easier in C, sometimes nice to have int as a bool

%example:
[[immrot(255)]] will return when [[i == 0]] since
[[255 & ~255 == 0]].
%
For $2^31$, the first iteration will not return as this number 
is not between 0 and [[0xff]]. 
So, [[v]] will be rotated to the left 2 times, and the
2 upper bits will be put back to the beginning by bitshiting
the number to the right by 30. Now [[i==1]] and [[v==2]]
and [[immrot()]] will return since [[v]] is now
between 0 and [[0xff]].


In addition to returning the ARM encoding of the rotatable constant,
[[immrot()]] also sets the special bit 25 in the return value.
This bit is set for all instructions involving an immediate
constant, as shown in the ARM reference card.
%\url{http://re-eject.gbadev.org/files/armref.pdf}.
%See the \book{Emulator} or the 
This will allow later code such as:
\begin{verbatim}
o1 |= immrot(instoffset);
\end{verbatim}
\l the 1 < < 25 means we are in the  i,r,r  case
\t actually important also to differentiate error from immrot of 0





\subsection{[[D_OREG]], [[C_xOREG]], and [[immaddr()]]}
\label{sec:c-xoreg}
\label{sec:immaddr}

% offsets constraints
% ex of instr: MOVW OFF(R13), R2

<<[[Operand_class]] C_xOREG cases>>=
<<[[Operand_class]] cases, in C_xOREG, half case>>
<<[[Operand_class]] cases, in C_xOREG, float cases>>
C_SOREG,
C_LOREG,

C_ROREG,
C_SROREG,   /* both S and R */
@
% need rotatable offset reg, because some instructions
% with O(R) are converted in arithmetic instructions. e.g., B O(R)
% -> add $O,R,PC

<<[[aclass()]] switch type cases>>=
case D_OREG:
    switch(a->symkind) {
    <<[[aclass()]] D_OREG case, switch symkind cases>>
    }
    return C_GOK;
@
% OREG usually is a dereference of a register or a symbol reference
% (which is then really an implicit offet to SB)

<<[[aclass()]] D_OREG case, switch symkind cases>>=
case N_NONE:
    instoffset = a->offset;
    t = immaddr(instoffset);
    if(t) {
        <<[[aclass()]] if immfloat for N_NONE symbol>>
        <<[[aclass()]] if immhalf for N_NONE symbol>>
        if(immrot(instoffset))
            return C_SROREG;
        return C_SOREG;
    }
    if(immrot(instoffset))
        return C_ROREG;
    return C_LOREG;
@
%pad: I rewrote the code to aspectize more immfloat
%old: 
%	instoffset = a->offset;
%	t = immaddr(instoffset);
%	if(t) {
%		if(immhalf(instoffset))		 /* n.b. that it will also satisfy immrot */
%			return immfloat(t) ? C_HFOREG : C_HOREG;
%		if(immfloat(t))
%			return C_FOREG; /* n.b. that it will also satisfy immrot */
%		t = immrot(instoffset);
%		if(t)
%			return C_SROREG;
%		if(immhalf(instoffset))
%			return C_HOREG;
%		return C_SOREG;
%	}
%	t = immrot(instoffset);
%	if(t)
%		return C_ROREG;
%	return C_LOREG;



<<[[cmp()]] switch on a, the operand class in optab rule, cases>>=
case C_SROREG:
    return cmp(C_SOREG, b) || cmp(C_ROREG, b);
case C_SOREG:
case C_ROREG:
    return b == C_SROREG || cmp(C_HFOREG, b);
case C_LOREG:
    return cmp(C_SROREG, b);
@



%\subsection{Immediate address, [[immaddr()]]}

% The load/store ARM instructions take 2 registers (src_val, dst_address)
% and a 12 bits offset (for a range of 4096, so really a page, 2 as
% actually have negative offsets with a bit).

% That means that if you do  'MOVW $1, myglobal', naively you'll have to
% encode it as 3 instructions:
%     MOV $1, R1
%     MOV $myglobal, R2
%     STR R1, R2.
% But if myglobal is not that far from address 0 and you have a special
% register reserved that always contain 0 (e.g., R12),
% then you could use the 12bits offset instead of using a register
% and just do
%     MOV $1, R1
%     STR R1, R12+$myglobal
% If you have a special register which always contain the value 1, 
% then you do even better with just do 
%     STR R0, R12+$myglobal! 
% which is 3 times faster (well if the global address is in a cache).
%
% In practice the first page of the address space is always reserved
% so it's better to store in R12 a bigger value. R12 will actually
% be set to INITDAT+BIG.




<<function immaddr(arm)>>=
// ulong -> option<long> (None = 0)
long
immaddr(long v)
{
    if(v >= 0 && v <= 0xfff)
        return (v & 0xfff) |
            (1<<24) |	/* pre indexing */
            (1<<23);	/* up */

    if(v < 0 && v >= -0xfff)
        return (-v & 0xfff) |
            (1<<24);	/* pre indexing */
    return 0;
}
@
% >> >> >>
\l rename immoffset()?
\t could return bool instead. Clearer. Anyway set special bits in olr already.
\t It is true its result is passed to immfloat but could rewrite immfloat too
\t  (or just pass abs(instoffset) & 0xfff to immfloat).
\t  It is maybe more symetric with immrot to keep it like that.
\t why need v & 0xfff? redundant no?




\subsection{[[D_OREG]] with globals, [[C_xEXT]]}
\label{sec:c-xext}

% H S L ? half, small, large?
<<[[Operand_class]] C_xEXT cases>>=
<<[[Operand_class]] cases, in C_xEXT, half case>>
<<[[Operand_class]] cases, in C_xEXT, float cases>>
C_SEXT,
C_LEXT,
@
% EXT for? external symbol?
% see Section X later expose constraint to satisfy for address


<<[[aclass()]] D_OREG case, switch symkind cases>>=
case N_EXTERN:
case N_INTERN:
    <<[[aclass()]] D_OREG case, N_EXTERN case, sanity check a>>
    s = a->sym;
    t = s->type;
    <<[[aclass()]] D_OREG case, N_EXTERN case, sanity check t>>
    <<[[aclass()]] when D_OREG and external symbol and dlm>>
    instoffset = s->value + a->offset - BIG;
    t = immaddr(instoffset);
    if(t) {
        <<[[aclass()]] if immfloat for N_EXTERN symbol>>
        <<[[aclass()]] if immhalf for N_EXTERN symbol>>
        return C_SEXT;
    }
    return C_LEXT;
@
% offset_to_r12, factorize BIG
\t MOVW foo(SB), R1 ??? meaning? symbol here is always a data symbol?

<<[[cmp()]] switch on a, the operand class in optab rule, cases>>=
case C_SEXT:
    return cmp(C_HFEXT, b);
case C_LEXT:
    return cmp(C_SEXT, b);
@

% xFy is for float (why mixed?)

<<[[aclass()]] D_OREG case, N_EXTERN case, sanity check a>>=
if(a->sym == nil || a->sym->name == nil) {
    print("null sym external\n");
    print("%D\n", a);
    return C_GOK;
}
@
%ocaml: impossible by construction

<<[[aclass()]] D_OREG case, N_EXTERN case, sanity check t>>=
if(t == SNONE || t == SXREF) {
    diag("undefined external: %s in %s", s->name, TNAME);
    s->type = SDATA;
}
@
%ocaml: should not happen when do check earlier





\subsection{[[D_OREG]] with automatics, [[C_xAUTO]]}
\label{sec:c-xauto}
\l use stack variables?

<<[[Operand_class]] C_xAUTO cases>>=
<<[[Operand_class]] cases, in C_xAUTO, half case>>
<<[[Operand_class]] cases, in C_xAUTO, float cases>>
C_SAUTO,    /* -0xfff to 0xfff */
C_LAUTO,
@
% the order matters! because of ocmp() and the order of entries in optab
% hence the chynk for float here

<<[[cmp()]] switch on a, the operand class in optab rule, cases>>=
case C_SAUTO:
    return cmp(C_HFAUTO, b);
case C_LAUTO:
    return cmp(C_SAUTO, b);
@

% SP, usually offset negatif
<<[[aclass()]] D_OREG case, switch symkind cases>>=
case N_LOCAL:
    instoffset = autosize + a->offset;
    t = immaddr(instoffset);
    if(t){
        <<[[aclass()]] if immfloat for N_LOCAL or N_PARAM symbol>>
        <<[[aclass()]] if immhalf for N_LOCAL or N_PARAM symbol>>
        return C_SAUTO;
    }
    return C_LAUTO;
@
% ex  TEXT foo(SB), $8,    then layout in memory? value of R13?
%  autosize so go to the top, and then negatif offset so go down

% FP

<<[[aclass()]] D_OREG case, switch symkind cases>>=
case N_PARAM:
    instoffset = autosize + 4L + a->offset;
    t = immaddr(instoffset);
    if(t){
        <<[[aclass()]] if immfloat for N_LOCAL or N_PARAM symbol>>
        <<[[aclass()]] if immhalf for N_LOCAL or N_PARAM symbol>>
        return C_SAUTO;
    }
    return C_LAUTO;
@
%old: autosize + a->offset + 4L;
% autosize so go to top, then +4 for save REGLINK then positive offset
\t remember that autosize compensated back to -4 when leaf?
\t  NO offset is compensated back, not autosize, autosize here will be
\t  zero if was a leaf function.
\t but then actually autosize already adjusted to plus 4, so why another
\t  plus 4 here? SEE ARET rewrting section!, +4 because we are in 
\t  frame of the caller
\t  and if caller for sure this caller is not a leaf and so before
\t  its locals he will have his own return address saved! hence the +4


\subsection{[[D_ADDR]], [[C_xxCON]]}
%pad: I introduced D_ADDR in 5.out.h, so cleaner code

% rotated External const?? meh
<<[[Operand_class]] C_xxCON cases>>=
C_RECON,
@
%dead: C_LECON
% optab:    { AMOVW,	C_LECON,C_NONE,	C_REG,		34, 8, REGSB,	LFROM },
% cmp:    case C_LECON:
%        if(b == C_RECON)
%            return 1;
%        break;

<<[[aclass()]] switch type cases>>=
case D_ADDR:
    switch(a->symkind) {
    <<[[aclass()]] D_ADDR case, switch symkind cases>>
    }
    return C_GOK;
@

<<[[aclass()]] D_ADDR case, switch symkind cases>>=
case N_EXTERN:
case N_INTERN:
    s = a->sym;
    <<[[aclass()]] D_ADDR case, N_EXTERN case, sanity check s>>
    switch(s->type) {
    case STEXT: case SSTRING: case SUNDEF:
        instoffset = s->value + a->offset;
        return C_LCON; // etext is stable
    case SNONE: case SXREF:
        diag("undefined external: %s in %s", s->name, TNAME);
        s->type = SDATA;
        // Fall through
    case SDATA: case SBSS: case SDATA1:
        <<[[aclass()]] in D_ADDR case, SDATA case, if dlm>>
        instoffset = s->value + a->offset - BIG;
        if(immrot(instoffset) && instoffset != 0) {// VERY IMPORTANT != 0
             return C_RECON;
        } else {
            instoffset = s->value + a->offset + INITDAT;
            return C_LCON;
        }
    }
    diag("unknown section for %s", s->name);
    break;
@
%pad: I added the final diag() because of the way I wrote the code
%old: used to be but more messy because of return and break
%    case SNONE: case SXREF:
%        diag("undefined external: %s in %s", s->name, TNAME);
%        s->type = SDATA;
%        break;
%    }
%    if(!dlm) {
%        instoffset = s->value + a->offset - BIG;
%        if(immrot(instoffset) && instoffset != 0)
%            return C_RECON;
%    }
%    instoffset = s->value + a->offset + INITDAT;
%    return C_LCON;
%old: case SLEAF: 
%old: case SCONST:
%ocaml: can have an offset with D_ADDR?

% for LCON have to do the INITDAT!
% really need RECON?
% what about setR12? how bootstrap? can match C_RECON?
% no cos of the special case != 0!! because setR12 is BIG, so
% BIG-BIG = 0 so use LCON for that


<<[[aclass()]] D_ADDR case, N_EXTERN case, sanity check s>>=
if(s == S) // no warning?
    break;
@



%\subsection{[[D_ADDR]] with automatics and [[C_xxCON]]}

%todo: need that? when do we get the address of a local or parameter?
% for which code we have those classes used??
<<[[Operand_class]] C_xxCON cases>>=
C_RACON,
C_LACON,
@
%RA Rotate Address? and Long Address?

<<[[cmp()]] switch on a, the operand class in optab rule, cases>>=
case C_LACON:
    if(b == C_RACON)
        return true;
    break;
@

<<[[aclass()]] D_ADDR case, switch symkind cases>>=
case N_LOCAL:
    instoffset = autosize + a->offset;
    goto aconsize;
@
<<[[aclass()]] D_ADDR case, switch symkind cases>>=
case N_PARAM:
    instoffset = autosize + a->offset + 4L;
    goto aconsize;
@


<<[[aclass()]] D_ADDR case, switch symkind cases>>=
aconsize:
    return immrot(instoffset)? C_RACON : C_LACON;
@


%dead: this advanced addressing mode of 5a is not that useful
%    case D_OCONST:
%        switch(a->name) {
%        case N_EXTERN:
%        case N_INTERN:
%            s = a->sym;
%            t = s->type;
%            if(t == 0 || t == SXREF) {
%                diag("undefined external: %s in %s",
%                    s->name, TNAME);
%                s->type = SDATA;
%            }
%            instoffset = s->value + a->offset + INITDAT;
%            if(s->type == STEXT || s->type == SLEAF || s->type == SUNDEF)
%                instoffset = s->value + a->offset;
%            return C_LCON;
%        }
%        return C_GOK;




\section{Arithmetic and logic opcodes}
\label{sec:arith-logic-gen}

%trans:
Now that we have seen all the operand classes, we can focus on the opcodes, 
%toc:
starting in this section with the 
code generation rules for the arithmetic and logic opcodes,
e.g., [[AADD]], [[ASUB]], [[ACMP]], etc.
%
As explained in Section~\ref{sec:oprange}, [[AADD]] is made
the {representant} of many other opcodes in the [[optab]] rules
thanks to the following code:

<<[[buildop()]] switch opcode r for ranges cases>>=
case AADD:
    oprange[ASUB] = oprange[r];

    oprange[AAND] = oprange[r];
    oprange[AEOR] = oprange[r];
    oprange[AORR] = oprange[r];

    oprange[AADC] = oprange[r];
    oprange[ASBC] = oprange[r];
    oprange[ARSC] = oprange[r];
    oprange[ARSB] = oprange[r];
    oprange[ABIC] = oprange[r];
    break;
@
%ocaml: just use general constructor Arith which gathers all those opcodes
% and have pattern matching with _ do the rest

The same is true for [[ACMP]] which represents also
[[ATST]], [[ATEQ]], and [[ACMN]]:

<<[[buildop()]] switch opcode r for ranges cases>>=
case ACMP:
    oprange[ATST] = oprange[r];
    oprange[ATEQ] = oprange[r];
    oprange[ACMN] = oprange[r];
    break;
@

Even if this section is about arithmetic and logic opcodes,
we will also see rules about opcodes associated more traditionally with memory
instructions, e.g., [[AMOVW]]. The reason is that [[AMOVW]]
is a very general instruction which can also be used to
set registers as in [[MOVW $1, R1]]. %$
This instruction does not involve any memory and is actually
converted in an ARM instruction using an arithmetic opcode
as we will see soon.
\t talk MVN and MOV? the ARM one and possible confusing with Asm5 one?
\t  Asm5 generalize the MOV to be MOV and LDR/STR/.... but also MVN

<<[[buildop()]] switch opcode r for ranges cases>>=
case AMVN:
    break;
@

\n Logic, add/sub, comparisons, simple movs

%toc:
The following subsections are organized according to the shape
of the operands (the operand classes), more than by
the kind of the operation.
This is a different organization that the one we chose in 
the \book{Assembler}, but it better matches how instructions 
are organized in the ARM.

\subsection{Register-only operands}
\n and oprrr, used many times later

%trans:
The simplest instructions are probably the one involving
only registers, e.g., [[ADD R1, R2, R3]]:

<<[[optab]] entries>>=
//          From    Middle  To       
{ AADD,     C_REG,  C_REG,  C_REG,       1, 4 },
{ AADD,     C_REG,  C_NONE, C_REG,       1, 4 },

{ AMOVW,    C_REG,  C_NONE, C_REG,       1, 4 },
{ AMVN,     C_REG,  C_NONE, C_REG,       1, 4 },
{ ACMP,     C_REG,  C_REG,  C_NONE,      1, 4 },
@
\l talk action id 1 above correspond to case 1 below?
%ocaml: arguably shorter rule thanks to flexible constructor, also no need
% mention middle operand at all or ugly C_NONE sometimes in middle or
% sometimes in last.

They can be encoded in a single ARM instruction, hence
the rule size [[4]] in the rules above, 
and the use of only [[o1]] in the code below:

<<[[asmout()]] switch on type cases>>=
case 1:		/* op R,[R],R */
    o1 = oprrr(p->as, p->scond);
    rf = p->from.reg;
    rt = p->to.reg;
    r = p->reg;
    <<[[asmout()]] adjust [[r]] and [[rt]]>>
    o1 |= (r<<16) | (rt<<12) | rf;
    break;
@
% >> >>
\n actually in ARM op R, [R], R  and op R, [R], R <> 0 are the same
%ocaml: use binding in pattern to directly name rf, rt, r

We will see [[oprrr()]] below, but it essentially sets
the {\em conditional execution}\footnote{
See the \book{Assembler} or \book{Emulator}.
} bits (bits 28 to 32)
and the bits for the arithmetic opcode (bits 21 to 24) 
of a {partial ARM instruction} returned and
stored in the local variable [[o1]] above.
%
Then, the code above extracts from the original instruction [[p]]
the ``from'' register [[rf]], which will endup as bits 0 to 3 in 
[[o1]]\footnote{
Remember from the \book{Assembler} that registers go from [[R0]] to [[R15]]
so 4 bits are enough for their encoding in an instruction.
}, 
the ``to'' register [[rt]], which will endup as bits 12 to 15 in [[o1]] hence
the [[rt<<12]] above,
%>>
and the middle register [[r]], which will endup as bits 16 to 19 in [[o1]] hence
the [[r<<16]] above.
%>>

%dup: (adapted a little) intro/requirements codegen/arm-instr
Again, we highly recommend to print the excellent
colorful ARM reference card \url{http://re-eject.gbadev.org/files/armref.pdf}
to better understand the bit manipulations in this chapter.
This card represents visually in a very compact way the ARM
instruction format.
%
The only differences with the conventions used in this chapter is that 
[[rf]] is called [[Rm]] in the card,
\l m for? 
[[rt]] is called [[Rd]] (for destination), and
[[r]] is called  [[Rn]]. 
\n actually Emulator take same convention than refcard
\l n for?
Moreover the instructions in the card use the Intel syntax
with a {\em right-to-left} assignment syntax.
This book, as well as [[5a]], use
the \att syntax with a {\em left-to-right} assignment syntax.
%
So [[ADD Rd, Rn, Rm]] in the card corresponds to [[ADD rf, r, rt]]
using the conventions of this chapter.


Note that the assembler allows to write
[[ADD R1, R2]] which is transformed by the linker
in [[ADD R1, R2, R2]], hence this piece of code below
which will be repeated in many places in [[asmout()]]:

<<[[asmout()]] adjust [[r]]>>=
if(r == R_NONE) // ADD FROM, TO ==> ADD FROM, TO, TO
    r = rt;
@

\l part of larger adjustment for arith.

<<[[asmout()]] adjust [[r]] and [[rt]]>>=
if(p->to.type == D_NONE)
    rt = 0;
if(p->as == AMOVW || p->as == AMVN)
    r = 0;
else 
  <<[[asmout()]] adjust [[r]]>>
@
\t when have D_NONE in TO? for CMP! where need SBZ for rt (rd)
%ocaml: Cmp and Movw are treated in a different rules so no factorization
% abuse leading to this kind of code


As mentioned above, [[oprrr()]] returns a partial
instruction, to be completed later, with the 
conditional execution bits and opcode bits set according to
its two parameters:
\t typedef instr?

<<function oprrr(arm)>>=
long
oprrr(int a, int sc)
{
    long o;

    // bits 28 to 32
    o = (sc&C_SCOND) << 28;
    <<[[oprrr()]] sign bit handling>>
    <<[[oprrr()]] sanity check sc>>

    switch(a) {

    // bits 21 to 24 (and sometimes bit 20)
    case AAND:	return o | (0x0<<21);
    case AEOR:	return o | (0x1<<21);
    case ASUB:	return o | (0x2<<21);
    case ARSB:	return o | (0x3<<21);
    case AADD:	return o | (0x4<<21);
    case AADC:	return o | (0x5<<21);
    case ASBC:	return o | (0x6<<21);
    case ARSC:	return o | (0x7<<21);

    case ATST:	return o | (0x8<<21) | (1<<20);
    case ATEQ:	return o | (0x9<<21) | (1<<20);
    case ACMP:	return o | (0xa<<21) | (1<<20);
    case ACMN:	return o | (0xb<<21) | (1<<20);

    case AORR:	return o | (0xc<<21);
    case AMOVW:	return o | (0xd<<21); // MOV
    case ABIC:	return o | (0xe<<21);
    case AMVN:	return o | (0xf<<21); // MVN

    // bits 20 to 27
    <<[[oprrr()]] switch cases>>
    }
    diag("bad rrr %d", a);
    prasm(curp);
    return 0;
}
@
% >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >>
% >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >>
% >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >>
% >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >>
\l why oprrr? rename?
\t AMOVW above is really more AMOV

[[oprrr()]] occasionally sets bit 20, the {\em S bit},
if the programmer requested it by using the {\em special bit}
[[S]] as in [[ADD.S R1, R2, R3]].
See the \book{Assembler} and \book{Emulator}
for more information on {special bits} and the semantic of the S bit.
\t it does not mean sign  but  set-flags
\t why not have it on always? faster without? and by having 
\t  with ADD means can do in one instr multiple things? then faster too
\t  than one ADD and one CMP?

<<[[oprrr()]] sign bit handling>>=
if(sc & C_SBIT)
    o |= 1 << 20;
@
% >>

This bit is always set for the comparison opcodes, as shown
in the case for [[ATST]] and so on in the [[switch]] above.
\t indeed makes sense, those instructions set flags
\l and when 0 it is used for other instructions, MSR, MRS, even BX

<<[[oprrr()]] sanity check sc>>=
if(sc & (C_PBIT|C_WBIT))
    diag(".P/.W on dp instruction");
@
%ocaml: no needed by construction, more precise AST
\n dp = data processing, ARM terminology I think
\t and .U on dp instruction? make sense?

\l oprrr also used for other opcodes, will expose gradually

\subsection{Small rotatable immediate constant operand}

We have seen in Section~\ref{sec:operand-class-DCONST}
the different subclasses of constants, especially [[C_RCON]]
for rotatable constants. Those constants can be encoded
directly in the ARM instruction, hence the rule size
[[4]] in the rules below:

<<[[optab]] entries>>=
{ AADD,		C_RCON,	C_REG,	C_REG,		 2, 4 },
{ AADD,		C_RCON,	C_NONE,	C_REG,		 2, 4 },

{ AMOVW,	C_RCON,	C_NONE,	C_REG,		 2, 4 },
{ AMVN,		C_RCON,	C_NONE,	C_REG,		 2, 4 },
{ ACMP,		C_RCON,	C_REG,	C_NONE,		 2, 4 },
@

<<[[asmout()]] switch on type cases>>=
case 2:		/* op $I,[R],R */
    aclass(&p->from);
    o1 = oprrr(p->as, p->scond);
    o1 |= immrot(instoffset); // set also bit 25 for Immediate
    rt = p->to.reg;
    r = p->reg;
    <<[[asmout()]] adjust [[r]] and [[rt]]>>
    o1 |= (r<<16) | (rt<<12);
    break;
@
%$
%old: the comment was about movbu, but it was wrong I think, so I put 'op'
\n remember also that immrot set bit 25! 

%dup: codegen/pseudo/word codegen/operand-subclasses
Remember from Section~\ref{sec:operand-subclasses}
that the call to [[aclass()]] above has for side
effect to set the global [[instoffset]] which can
then be passed to [[immrot()]]. 

\l see later large constant, more complex.

\subsection{Bitshifted register}

%trans:
In the \book{Assembler}, the grammar rule
for the first operand of arithmetic instructions is called
[[imsr]] which stands for:
%dup: Assembler
[[im]]mediate (constant) or 
[[s]]hifted-register or 
[[r]]egister.
%trans:
We have seen the ARM code generation rules 
for the register ([[C_REG]]) and 
immediate constant ([[C_RCON]]) cases in the previous sections.
%
We can now see the rules for the bitshifted register ([[C_SHIFT]]):
 
<<[[Operand_class]] cases>>=
C_SHIFT,   // D_SHIFT
@
<<[[aclass()]] switch type cases>>=
case D_SHIFT:
    return C_SHIFT;
@


<<[[optab]] entries>>=
{ AADD,		C_SHIFT,C_REG,	C_REG,		 3, 4 },
{ AADD,		C_SHIFT,C_NONE,	C_REG,		 3, 4 },

{ AMVN,		C_SHIFT,C_NONE,	C_REG,		 3, 4 },
{ ACMP,		C_SHIFT,C_REG,	C_NONE,		 3, 4 },
@
\l shifted simple MOVW in adv topics

<<[[asmout()]] switch on type cases>>=
case 3:		/* op R<<[IR],[R],R */
mov:
    aclass(&p->from);
    o1 = oprrr(p->as, p->scond);
    o1 |= p->from.offset; // set in 5a, complex bit layout
    rt = p->to.reg;
    r = p->reg;
    <<[[asmout()]] adjust [[r]] and [[rt]]>>
    o1 |= (r<<16) | (rt<<12);
    break;
@
% >> >> >> >> >> >> >> >> >> >> >>
%old: add -> op in the comment

%dup: (and adapted) from Assembler
A bitshifted register combines 
a register (a [[D_REG]]) and
an immediate constant (a [[D_CONST]]) % or another register (another [[D_REG]]),
in a single operand.
%dup: (and adapted) from Assembler
As explained in the \book{Assembler},
the [[Operand.offset]] field for bitshifted registers
directly encodes the operand in the ARM instruction format:
the first 4 bits (bits 0 to 3) are used for the register number (0 to 15),
bits 5 and 6 are used to encode the kind of shift, e.g., [[0 << 5]]
%>>
for a left shift, and bits 7 to 11  to encode either a small immediate constant
or another register.
%
This is why the code above just does [[o1 |= p->from.offset]]
as part of the ARM instruction encoding has already been done
by [[5a]].

\t but diff in binary format with op R, R, R  then?
\t  it is just that shift is zero and use  op R < < 0, R, R is equivalent
% >> 
\t   to op R, R, R

\subsection{Bitshift opcodes}

%trans:
In addition to the use of bitshited registers,
%
[[5a]] supports the more traditional bitshift instructions
[[SLL]], [[SRL]], and [[SRA]]:

<<[[buildop()]] switch opcode r for ranges cases>>=
case ASLL:
    oprange[ASRL] = oprange[r];
    oprange[ASRA] = oprange[r];
    break;
@

\t SRL vs SRA? example? fill with 1

<<[[optab]] entries>>=
{ ASLL,		C_RCON,	C_REG,	C_REG,		 8, 4 },
{ ASLL,		C_RCON,	C_NONE,	C_REG,		 8, 4 },
@

Those instructions are {virtual instructions} transformed by the linker in
an ARM [[MOV]] with a bitshifted register as shown below:

<<[[asmout()]] switch on type cases>>=
case 8:		/* sll $c,[R],R -> mov (R<<$c),R */
    aclass(&p->from);
    o1 = oprrr(p->as, p->scond);
    rt = p->to.reg;
    r = p->reg;
    <<[[asmout()]] adjust [[r]]>>
    o1 |= (rt<<12) | ((instoffset&31) << 7) | r;
    break;
@
%$
% >> >>
%pad: I added rt so could factorize with 'adjust' chunk
\t should warn when more than 31!! instead of silently &31
\t  test on 5a/shift.s

\t offset only 0 and 31, but good enough for bitshift of 32 bits register!

Note that [[MOV]] is an ARM opcode with two operands. 
It is used to set the content of a register. 
It should not be confused with the virtual
instruction [[MOVW]] of [[5a]], which is more general, and which
can be transformed depending on its operands as
the ARM instructions [[LDR]], [[STR]],
or [[MOV]] when the operands are a constant and a register.

The bits encoding the shift operation are set via [[oprrr()]]:

<<[[oprrr()]] switch cases>>=
//                       MOV      shift op
case ASLL:	return o | (0xd<<21) | (0<<5);
case ASRL:	return o | (0xd<<21) | (1<<5);
case ASRA:	return o | (0xd<<21) | (2<<5);
@
% >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >>
% >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >>



<<[[optab]] entries>>=
{ ASLL,		C_REG,	C_NONE,	C_REG,		 9, 4 },
{ ASLL,		C_REG,	C_REG,	C_REG,		 9, 4 },
@
\t note that no SLL and C_SHIFT. normal, already converted in
\t  bitshift so cant do 2 bitshift

<<[[asmout()]] switch on type cases>>=
case 9:		/* sll R,[R],R -> mov (R<<R),R */
    o1 = oprrr(p->as, p->scond);
    rf = p->from.reg;
    rt = p->to.reg;
    r = p->reg;
    <<[[asmout()]] adjust [[r]]>>
    o1 |= (rt<<12) | (rf<<8) | (1<<4) | r ;
    break;
@
% >> >> >> >> 


\subsection{Byte and half word extractions}

The following instructions allow to extract parts of a register
and store the result in another register:
\t recall B bs BU vs H vs HU? dup Assembler.nw?

<<[[optab]] entries>>=
{ AMOVB,	C_REG,	C_NONE,	C_REG,		14, 8 },
{ AMOVBU,	C_REG,	C_NONE,	C_REG,		58, 4 },
{ AMOVH,	C_REG,	C_NONE,	C_REG,		14, 8 },
{ AMOVHU,	C_REG,	C_NONE,	C_REG,		14, 8 },
@

\t sign vs unsigned version because keep sign bit or not.

[[MOVB R1, R2]] is a virtual instruction transformed in two 
instructions:
\begin{verbatim}
SLL $24, R1, R2 // o1
SRA $24, R2, R2 // o2
\end{verbatim}
\l actually SLL SRA also virtual

This is why the rule size in the rules above is [[8]]
and the code below uses the variables [[o1]] and [[o2]] for
the first time:

\t difference signed unsigned? Machine? SRL vs SRA? one fills with 1 the right!
\t  if was negative number.

<<[[asmout()]] switch on type cases>>=
case 14:	/* movb/movbu/movh/movhu R,R */
    o1 = oprrr(ASLL, p->scond);

    if(p->as == AMOVBU || p->as == AMOVHU)
        o2 = oprrr(ASRL, p->scond);
    else
        o2 = oprrr(ASRA, p->scond);

    rf = p->from.reg;
    rt = p->to.reg;
    if(p->as == AMOVB || p->as == AMOVBU) {
        o1 |= (rt<<12) | (24<<7) | rf;
        o2 |= (rt<<12) | (24<<7) | rt;
    } else {
        o1 |= (rt<<12) | (16<<7) | rf;
        o2 |= (rt<<12) | (16<<7) | rt;
    }
    break;
@
% >> >> >> >> >> >> >> >>
%old: was using r = p->to.reg but inconsistent with the rest so I put rt.
%old: distribute rf and rt, more consistent with case 31

[[MOVBU R1, R2]] can be optimized and encoded using only 1 ARM instruction
as [[0xff]] is a rotatable constant. Note that [[0xffff]] is not
a rotatable constant hence the need for two instructions above for [[MOVHU]].

<<[[asmout()]] switch on type cases>>=
case 58:	/* movbu R,R -> AND $0xff, R, R */
    o1 = oprrr(AAND, p->scond);
    o1 |= immrot(0xff);
    rt = p->to.reg;
    r = p->from.reg;
    if(p->to.type == D_NONE)
        rt = 0;
    <<[[asmout()]] adjust [[r]]>>
    o1 |= (r<<16) | (rt<<12);
    break;
@
% >> >>
%$
\t what is this D_NONE thing??? how to can be D_NONE? it has to be D_REG!!
\n why not using rf for register from? but then adjust r will be wrong!
\t  r has to be 0, so the adjust r is really a set r
%old: I added the -> in the comment above to explain the translation


\subsection{Multiplication opcodes}

Multiplication in the ARM uses a different format
than the other arithmetic instructions. It supports
only registers as operands:

<<[[buildop()]] switch opcode r for ranges cases>>=
case AMUL:
    oprange[AMULU] = oprange[r];
    break;
@
\t anyway why need AMULU? diff with AMUL?

<<[[optab]] entries>>=
{ AMUL,		C_REG,	C_REG,	C_REG,		15, 4 },
{ AMUL,		C_REG,	C_NONE,	C_REG,		15, 4 },
@


<<[[asmout()]] switch on type cases>>=
case 15:	/* mul r,[r,]r */
    o1 = oprrr(p->as, p->scond);
    rf = p->from.reg;
    rt = p->to.reg;
    r = p->reg;
    <<[[asmout()]] adjust [[r]]>>
    <<[[asmout()]] adjust registers when mul>>
    o1 |= (rt<<16) | (rf<<8) | r;
    break;
@
% >> >> 
%old code
%    if(0)
%    if(rt == r || rf == REGPC || r == REGPC || rt == REGPC) {
%        diag("bad registers in MUL");
%        prasm(p);
%    }


<<[[oprrr()]] switch cases>>=
case AMULU:
case AMUL:	return o | (0x0<<21) | (0x9<<4);
@
% >> >>
\l no diff MUL and MULU??

<<[[asmout()]] adjust registers when mul>>=
if(rt == r) {
    r = rf;
    rf = rt;
}
@
\t ??? Machine?

Note that the operands of [[AMUL]], and in particular
its result, are stored in 32 bits registers. 
Because the multiplication of two 32 bits numbers can easily overflow,
Section~\ref{sec:mull} presents other ARM multiplication opcodes
where the result is contained in 2 registers, thus supporting
a 64 bits target.
\l long long? or vlong? multiplication

Note also that there is no [[DIV]] opcode in the ARM so [[ADIV]] is a virtual
instruction transformed in a series of instructions implementing
the division in software, as explained in Section~\ref{sec:div-mod}.

\subsection{Large constant operand, [[REGTMP]] and literal pools}
\label{sec:pool-and-reg-tmp}
\n and Optab.flag


%trans:
We can finally see the translation of arithmetic instructions using
a large constant ([[C_LCON]]) or 
a negative rotatable constant ([[C_NCON]]) 
as a first operand. 
Those instructions are more complex to handle than the instructions with 
a rotatable constant ([[C_RCON]]) we saw before.
%
Indeed, large constants can not be encoded directly in the instruction.
This is why the rules in this section have a rule size of [[8]].
%toc:
We will first cover the rules and the code to deal with [[C_NCON]]
which has a lot in common with [[C_LCON]] but is simpler to see first.


[[C_NCON]] represents a negative rotatable constant meaning
a constant not directly rotatable, but with a negation that is
rotatable, e.g., [[-0xff]] (since [[0xff)]]  is rotatable).
\l does not have to be a negative number I think.

<<[[optab]] entries>>=
{ AADD,		C_NCON,	C_REG,	C_REG,		13, 8 },
{ AADD,		C_NCON,	C_NONE,	C_REG,		13, 8 },
{ AMVN,		C_NCON,	C_NONE,	C_REG,		13, 8 },
{ ACMP,		C_NCON,	C_REG,	C_NONE,		13, 8 },
@

The translation of instructions matching the rules above involves
a temporary register reserved by the linker: [[R11]].
This register is aliased as [[REGTMP]] in the \book{Assembler} and in
[[include/obj/5.out.h]].
%
So, [[ADD $-0xff, R2, R3]] %$
is translated by [[5l]] in the two following instructions:

\begin{verbatim}
MVN $0xff, R11  // o1
ADD R11, R2, R3 // o2
\end{verbatim}
\t MVN = move negatif

<<[[asmout()]] switch on type cases>>=
case 13:	/* op $lcon, [R], R */
    o1 = omvl(p, &p->from, REGTMP);
    <<[[asmout()]] sanity check o1>>

    o2 = oprrr(p->as, p->scond);
    rf = REGTMP;
    rt = p->to.reg;
    r = p->reg;
    if(p->as == AMOVW || p->as == AMVN) // can be AMOVW??
        r = 0;
    else 
      <<[[asmout()]] adjust [[r]]>>
    o2 |= (r<<16) | rf;
    if(p->to.type != D_NONE)
        o2 |= rt << 12;
    break;
@
%$
%old: used to do o2 |= REGTMP and prefer to use rf to be more consistent
\t what is this D_NONE again?? when can this happen? for ACMP!
\t and what is special case for AMOVW?

The code above relies on [[omvl()]] (for move large) which
returns an instruction which
loads an operand [[a]] in a register [[dr]] (usually [[REGTMP]]):

<<function omvl(arm)>>=
long
omvl(Prog *p, Adr *a, int dr)
{	
    long v, o1;

    <<[[omvl()]] when C_LCON case>>
    else {
        // C_NCON case
        aclass(a);
        v = immrot(~instoffset);
        <<[[omvl()]] sanity check v>>
        o1 = oprrr(AMVN, p->scond&C_SCOND);
        o1 |= (dr<<12) | v;
    }
    return o1;
}
@
% >> >> >>
%old: I inverse the condition, it was !p->cond, so can better aspectize
% things

<<[[omvl()]] sanity check v>>=
if(v == 0) {
    diag("missing literal");
    prasm(p);
    return 0;
}
@
<<[[asmout()]] sanity check o1>>=
if(!o1)
    break;
@
\t warning instead?






%trans:
We can now see the arithmetic rules using [[C_LCON]] and their translations.
%
Those rules use the same action identifier than before, [[13]],
as they share lots of the code to deal with [[C_NCON]],
but they have the special {\em rule flag} [[LFROM]].
% which we will explain soon

<<[[optab]] entries>>=
{ AADD,		C_LCON,	C_REG,	C_REG,		13, 8, 0,	LFROM },
{ AADD,		C_LCON,	C_NONE,	C_REG,		13, 8, 0,	LFROM },
{ AMVN,		C_LCON,	C_NONE,	C_REG,		13, 8, 0,	LFROM },
{ ACMP,		C_LCON,	C_REG,	C_NONE,		13, 8, 0,	LFROM },
@

This flag is stored in an extra field of [[Optab]]:

<<[[Optab]] flag field>>=
// bitset<enum<Optab_flag>>
short   flag;
@
%old: was char, but ugly
% order is important, see optab[] global


As it will be explained fully later in Section~\ref{sec:pool},
large constants in operands are transformed as data
in the code section using the [[WORD]] pseudo-opcode.
The instruction [[ADD $0xffff, R2, R3]] %$
is thus transformed in the following instructions:

\begin{verbatim}
2000: LDR 1000(R15), R11
2004: ADD R11, R2, R3
...
...
3000: WORD $0xffff
\end{verbatim}
\t offset must be small! need support olr()

When a rule with the [[LFROM]] {rule flag}
matches an instruction [[p]],
[[dotext()]] calls [[addpool()]] with the from
operand ([[p->from]]), as we will see in Section~\ref{sec:pool}.
%
[[addpool()]] extracts the constant from the operand and creates
a new [[WORD]] instruction at the end of the program 
\l actually not exactly end of program
with this constant as an operand.
%
This new instruction is part of what is called a {\em literal pool},
meaning a set of pseudo-instructions containing {literals}.
[[addpool()]] also modifies the passed instruction [[p]] and
sets its [[Instr.cond]] field to point to this newly added
instruction. 
%
Finally, [[omvl]] looks whether this field has been set, in which
case it knows it is handling the [[C_LCON]] case:

<<[[omvl()]] when C_LCON case>>=
if(p->cond) {
    // C_LCON case with Pool
    v = p->cond->pc - p->pc - 8;
    // =~ LDR v(R15), R11
    o1 = olr(AMOVW, p->scond&C_SCOND, v, REGPC, dr);
}
@
%pad: added AMOVW parameter since refactored olr

We will see [[olr()]] later in Section~\ref{sec:load}
when we cover the memory instructions which {loads}
data from memory in a register.
%
The reason for the [[-8]] above will be explained
when we cover the branching instructions in
Section~\ref{sec:branching}.



<<[[optab]] entries>>=
{ AMOVW,	C_NCON,	C_NONE,	C_REG,		12, 4 },
{ AMOVW,	C_LCON,	C_NONE,	C_REG,		12, 4, 0,	LFROM },
@

<<[[asmout()]] switch on type cases>>=
case 12:	/* movw $lcon, reg */
    o1 = omvl(p, &p->from, p->to.reg);
    break;
@
%$

\t subtle but MOVW dollar foo(SB), R1  where foo is a procedure
\t  is quite subtle. aclass will say it's a LCON because
\t  the address of a procedure can not be known at layout_text time
\t  so make worse estimate and return in pool the whole ximm
\t  so later will have some WORD dollar foo(SB) but
\t  those will be resolved only at the very very end, after
\t  actually all procedure has been layout and so we can know
\t  their address.



\section{Control flow opcodes}
\label{sec:branching}

%trans:
The next big category of ARM instructions are
%
branching instructions. They alter the control flow of the program.

<<[[buildop()]] switch opcode r for ranges cases>>=
case AB:
case ABL:
    break;
@

[[ABEQ]] is the representant of a set of virtual opcodes
to express {\em conditional jumps}. Those virtual instructions are converted
in {\em unconditional jumps} ([[AB]]) but using the general
mechanism of {\em conditional execution} provided by the ARM, as we will
see soon.

<<[[buildop()]] switch opcode r for ranges cases>>=
case ABEQ:
    oprange[ABNE] = oprange[r];
    oprange[ABHS] = oprange[r];
    oprange[ABLO] = oprange[r];
    oprange[ABMI] = oprange[r];
    oprange[ABPL] = oprange[r];
    oprange[ABVS] = oprange[r];
    oprange[ABVC] = oprange[r];
    oprange[ABHI] = oprange[r];
    oprange[ABLS] = oprange[r];
    oprange[ABGE] = oprange[r];
    oprange[ABLT] = oprange[r];
    oprange[ABGT] = oprange[r];
    oprange[ABLE] = oprange[r];
    break;
@

\subsection{Direct jumps}
\label{sec:direct-jumps}
\l static, direct, relative

<<[[optab]] entries>>=
{ AB,		C_NONE,	C_NONE,	C_BRANCH,		 5, 4, 0,	LPOOL },
{ ABL,		C_NONE,	C_NONE,	C_BRANCH,		 5, 4 },
{ ABEQ,		C_NONE,	C_NONE,	C_BRANCH,		 5, 4 },
@

The rule flag [[LPOOL]] will be explained later in Section~\ref{sec:lpool}.
%
We can see the important use of [[Instr.cond]] set by [[patch()]]
(see Section~\ref{sec:patch}) in the code below to find
the code address of the target instruction:

<<[[asmout()]] switch on type cases>>=
case 5:		/* bra s */
    <<[[asmout()]] BRA case, if undefined target>>
    else 
      if(p->cond != P)
        v = (p->cond->pc - p->pc) - 8;
      else 
        v = -8; // warning?
    o1 = opbra(p->as, p->scond);
    o1 |= (v >> 2) & 0xffffff;
    break;
@
%old: was -pc but I prefer -p->pc. Cleaner than global and consistent with omvl.
\t can overflow? branch somewhere too far?
\t important 0xffffff! will not become a negative C integer
\t but will be interpreted by Machine has one.

There are many interesting elements in the code above which 
require a small comment:
\begin{itemize}
\item [[p->cond->pc - p->pc]]: 
Jumps are {\em relative} in the ARM, but [[Instr.pc]] contains
an {\em absolute} code address, hence the subtraction.

\item [[0xffffff]]: Jump offsets are encoded in 24 bits in the ARM.
\t and negative number? part of it! -4 = 0xfffffff8 in 32 bits
\t and so 0xfffff8 after the &

\item [[v >> 2]]: Jumps are in terms of instructions in the ARM, not
bytes, hence the division by 4 since
%dup: overview/5l-a core-ds/instr main/asmb/text-sec resolve/issue/
the ARM uses fixed-length instruction of 4 bytes.

\item [[-8]]: The ARM implicitly does a [[+8]]
(see the \book{Emulator}) on the jump offset (after it multiplied
it by 4). So, a jump offset of 0 in an ARM jump instruction actually jumps
2 instructions forward.
%
The reason is probably that it
seems {incorrect} to jump on the same instruction (hence an
implicit [[+4]]), and it seems {useless} to jump on the
next instruction (hence another implicit [[+4]]) as one
could do the same by not using any jump instruction.
\l To loop forever need B - 8 ARM.
\l This is why you need an assembler :) too tricky, need layer on top of ARM.

\end{itemize}

\l opbra similar to oprrr, but can manually set condition also

<<function opbra(arm)>>=
long
opbra(int a, int sc)
{

    <<[[opbra()]] sanity check sc>>
    sc &= C_SCOND;
    if(a == ABL)
        return (sc<<28)|(0x5<<25)|(0x1<<24);
    <<[[opbra()]] sanity check sc if not ABL>>

    switch(a) {
    // manual setting of the conditional execution
    // bits 28 to 32
    case ABEQ:	return (0x0<<28)|(0x5<<25);
    case ABNE:	return (0x1<<28)|(0x5<<25);
    case ABHS:	return (0x2<<28)|(0x5<<25);
    case ABLO:	return (0x3<<28)|(0x5<<25);
    case ABMI:	return (0x4<<28)|(0x5<<25);
    case ABPL:	return (0x5<<28)|(0x5<<25);
    case ABVS:	return (0x6<<28)|(0x5<<25);
    case ABVC:	return (0x7<<28)|(0x5<<25);
    case ABHI:	return (0x8<<28)|(0x5<<25);
    case ABLS:	return (0x9<<28)|(0x5<<25);
    case ABGE:	return (0xa<<28)|(0x5<<25);
    case ABLT:	return (0xb<<28)|(0x5<<25);
    case ABGT:	return (0xc<<28)|(0x5<<25);
    case ABLE:	return (0xd<<28)|(0x5<<25);
    case AB:	return (0xe<<28)|(0x5<<25);
    }
    diag("bad bra %A", a);
    prasm(curp);
    return 0;
}
@
% 
% >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >>
% >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >>

<<[[opbra()]] sanity check sc>>=
if(sc & (C_SBIT|C_PBIT|C_WBIT))
    diag(".S/.P/.W on bra instruction");
@
\l U bit?
%ocaml: impossible by construction

<<[[opbra()]] sanity check sc if not ABL>>=
if(sc != 0xe)
    diag("redundant .EQ/.NE/... on B/BEQ/BNE/...  instruction");
@
%old: .COND on bcond instruction

\subsection{Indirect jumps}
\l dynamic, indirect, absolute

Most jumps in a program are {\em static}, e.g., jumping to
a procedure or a label.
%
Even the assembly instruction [[B 2(PC)]], which uses
the pseudo-register [[PC]] (to perform a relative jump),
is actually converted in a static jump.
%dup: resolving/issue
Indeed, the instruction is 
(1) converted by the assembler in an absolute jump,
% (using a virtual program counter), 
(2) relocated in [[ldobj()]] in Section~\ref{sec:relocation},
(3) patched to find the actual target instruction in Section~\ref{sec:patch},
and finally (4) converted back to a static relative jump ARM instruction
in the previous section. %clever \ref{sec:direct-jumps}
% using real program counters.
\l in the middle haved handled virtual instr expansion, etc.

The assembly language of [[5a]] supports also {\em dynamic} 
jumps where the content
of a regular register and an offset can specify an absolute
code address to jump to, e.g., [[B 10(R4)]].
%
Such instructions are useful to encode for instance in C
calls through a function pointer as in [[(*f)(1,2);]]
which are dynamic.
\t also every return of procedure is using dynamic jump!!
%The address of [[f]] is put in a register and 
\l see 5c -S and functpointer.c
%
The ARM branching instructions support only 24 bits static offsets though,
but you can manipulate directly the {program counter register} ([[R15]])
and {link register} ([[R14]]) to encode dynamic jumps using simple
arithmetic instructions:

<<[[optab]] entries>>=
{ AB,		C_NONE,	C_NONE,	C_ROREG,	 6, 4, 0,	LPOOL },
{ ABL,		C_NONE,	C_NONE,	C_ROREG,	 7, 8 },
@
\t if it's a really big offset that is not immrot(), no code generation?
\t  offset is always 0 according to the grammar so of course it's ok.
\l note that no indirect jump with conditional jumps

<<[[asmout()]] switch on type cases>>=
case 6:		/* b O(R) -> add $O,R,PC */
    aclass(&p->to);
    o1 = oprrr(AADD, p->scond);
    o1 |= immrot(instoffset);
    r = p->to.reg;
    rt = REGPC; 
    o1 |= (r<<16) | (rt<<12);
    break;
@
%$
\n note that ADD x, R, PC set the final result of PC, so it's not relative jump
\t if do manually add x, R, R15,  then get the LPOOL?
\t if do B 8(R15)?? actually want B 0(R15) because of exposed semantic

The translation of indirect calls ([[BL]]) requires two ARM instructions:

<<[[asmout()]] switch on type cases>>=
case 7:		/* bl Offset(R) -> ADD $0,PC,LINK; add $Offset,R,PC */
    aclass(&p->to);
    o1 = oprrr(AADD, p->scond);
    rt = REGLINK;
    r = REGPC;
    o1 |= (r<<16) | (rt<<12) | immrot(0);

    o2 = oprrr(AADD, p->scond);
    r = p->to.reg;
    rt = REGPC;
    o2 |= (r<<16) | (rt<<12) | immrot(instoffset);
    break;
@
% >> >> >> >>
%old: /* bl O(R) -> mov PC,link; add $O,R,PC */
\l could use AMOVW instead of AADD no?
\l subtle but immrot(0) != 0, it sets bit 25

Note that the first generated instruction above which adds zero to [[R15]] and
saves the result in [[R14]] seems incorrect. 
Indeed, the return address saved in [[R14]] should not be the current 
instruction but the next instruction, which in our case should be
at [[R15+8]] since the linker generated two ARM instructions for [[BL]].
But, again the ARM does implicitely a [[+8]] when one of the 
{\em source} operand of an arithmetic instruction is [[R15]]
(see the \book{Emulator}). Note that there is no implicit [[+8]]
though when [[R15]] is the {\em destination} operand as in the second
generated ARM instruction above.






\section{Memory opcodes}

%toc:
We will see in this section the many ARM code generation rules
for [[AMOVW]] and its variants when one of its operands
references a memory area.
\l but at most one? if two then linking error?

\l here are the variants (but seen before in arith section)
<<[[buildop()]] switch opcode r for ranges cases>>=
case AMOVW:
case AMOVB:
case AMOVBU:
case AMOVH:
case AMOVHU:
    break;
@

%trans:
We have seen already a few rules concerning [[AMOVW]]
in Section~\ref{sec:arith-logic-gen}
when the operands of [[AMOVW]] were simple registers and constants.
%
Indeed, [[AMOVW]] is a very general virtual instruction
which unifies with one virtual opcode many ARM opcodes: [[MOV]], [[MVN]],
but more importantly for this section [[LDR]], [[STR]],
and even more as some [[AMOVW]] can also be translated in [ADD]].
\l also MSR, MRS, etc
%
In fact, one move instruction can lead to the generation of up
to 6 ARM instructions (24 bytes) as we will see soon.

%toc:? load/store/swap/address/half-byte
\t in adv topics also movw for float, status register, etc

\subsection{Load}
\label{sec:load}
\n and Optab.param

%trans:
An important use of [[MOVW]],
beyond the setting of a register from another register or a constant
(via the ARM instructions [[MOV]] and [[MVN]]),
%
is to {\em load} data from memory in a register, e.g., [[MOVW 10(R1), R2]]. 
This will result in the use of the ARM instruction [[LDR]].
%toc:
We will first see the rules when the offset is small,
%
that is when the operand class has the form [[C_S]]$xxx$,
e.g., [[C_SEXT]] (see Section~\ref{sec:immaddr} and [[immaddr()]]).
In those cases the offset can be encoded directly in the ARM instruction,
hence the rule size [[4]] below:

<<[[optab]] entries>>=
{ AMOVW,	C_SEXT,	C_NONE,	C_REG,		21, 4, REGSB },
{ AMOVW,	C_SAUTO,C_NONE,	C_REG,		21, 4, REGSP },
{ AMOVW,	C_SOREG,C_NONE,	C_REG,		21, 4 },

{ AMOVBU,	C_SEXT,	C_NONE,	C_REG,		21, 4, REGSB },
{ AMOVBU,	C_SAUTO,C_NONE,	C_REG,		21, 4, REGSP },
{ AMOVBU,	C_SOREG,C_NONE,	C_REG,		21, 4 },
@
\l maybe could have factorized with same representant in the end? lots of dupes

<<[[asmout()]] switch on type cases>>=
case 21:	/* mov/movbu O(R),R */
    aclass(&p->from);
    rt = p->to.reg;
    r = p->from.reg;
    <<[[asmout()]] adjust maybe r to rule param>>
    o1 = olr(p->as, p->scond, instoffset, r, rt);
    break;
@
% >> >> >>
%old: if(p->as != AMOVW) -> positive form for bit 22, and factorized in olr now
%old: was '-> lr' in comment, but clearer nothing

%dup:
Remember that [[aclass()]] above modifies the global [[instoffset]]
whose value depends on the operand class parameter.
%
[[instoffset]] can contain
a {computed offset} to [[R12]] for external symbols ([[EXT]],
see Section~\ref{sec:c-xext}),
an {adjusted offset} to [[R13]] for stack access ([[AUTO]],
see Section~\ref{sec:c-xauto}),
or {the given offset} for the other cases ([[OREG]],
see Section~\ref{sec:c-xoreg}).
%
Each kind of offset corresponds to a different {\em base register},
which can actually be specified in the rule itself.
\l could modify p->from.reg to record pseudo-register instead? no need Param?
Indeed, an extra field of [[Optab]] can be used to contain
extra parameters:
%note the use for the first time of [[Optab.param]] 
%in the rules above:
%(see Section~\ref{sec:optab-param}) 

<<[[Optab]] param field>>=
// 0 | REGSB | REGSP
short   param;
@

For instance [[REGSB]] is used in when the rule concerns an external
symbol ([[C_SEXT]]).
This extra parameter can then be accessed from [[asmout()]] to
adjust the {base register}:

%optional (which is why didn't put in example above).
% pass additional information to asmout() in addition to
% action id.


<<[[asmout()]] adjust maybe r to rule param>>=
if(r == R_NONE)
    r = o->param;
@

The code for [[case 21:]] above relies on [[olr()]]
which factorizes most of the code related to the instruction 
format of memory instructions. It is actually also used for
the generation of [[STR]] instructions as we will see soon.


<<function olr(arm)>>=
long
olr(int a, int sc, long v, int b, int rt)
{
    long o;

    o = (sc&C_SCOND) << 28;
    <<[[olr()]] sanity check sc>>

    <<[[olr()]] set special bits>>
    o |= (0x1<<26) | // memory instructions class
         (1<<20);    // LDR
    if(v >= 0) {
        o |= 1 << 23; // Up bit, positive offset
    } else {
        // bit 23 unset, Down, negative offset
        v = -v;
    }
    <<[[olr()]] sanity check offset [[v]]>>
    switch(a) {
    case AMOVB:
    case AMOVBU: 
        o |= 1<<22; 
        break;
    case AMOVW: 
        break;
    default:
        <<[[olr()]] sanity check [[a]]>>
    }        
    o |= (b<<16) | (rt<<12) | v;
    return o;
}
@
% >> >> >> >> >> >> >> >> >> >>
\n AMOVH and AMOVHU? should adjust in caller! clearer then.
\n note that order mimic order of instr,  MOVW v(b), rt
%old: 
% - use rt, not r, more consistent
%dead:
% - was doing tricky stuff with U bit but I simplified
%    if(!(sc & C_UBIT))
%        o |= 1 << 23; // up?? bug?
%    ...
%    if(v < 0) {
%        v = -v;
%        o ^= 1 << 23; // down
%    }
%pad:
% - added int a, and put sc first. More consistent with oprrr, opbra, etc.
%   and also more consistent with osr which was taking opcode 'a'
% - factorized code about bit 22, and added diag() in switch
\t v can be offset (pos/neg) or register number (rm)

Remember from the \book{Assembler} that memory instructions
can use the [[.P]] or [[.W]] suffixes to offer additional
addressing modes. Those suffixes are converted by [[5a]]
in {special bits} in [[Instr.cond]] which then leads
to the setting of special bits in the ARM instruction itself:

<<[[olr()]] set special bits>>=
if(!(sc & C_PBIT))
    o |= 1 << 24; // pre (not post)
if(sc & C_WBIT)
    o |= 1 << 21; // write back
@
% >> >> >> >>

\l as in [[MOVW.W R14, -4(R13)]], 
\l as in [[MOVW.P -4(R13), R15]], 


<<[[olr()]] sanity check sc>>=
if(sc & C_SBIT)
    diag(".S on LDR/STR instruction");
if(sc & C_UBIT)
    diag(".U on LDR/STR instruction");
@
\n dual, .P.W forbidden on arith
%pad: I added the code to forbid UBIT cos make no sense for MOVW
% cos we handle the direction automatically based on the offset.
%ocaml: not needed, enforced by construction


<<[[olr()]] sanity check offset [[v]]>>=
if(v >= (1<<12))
    diag("literal span too large: %ld (R%d)\n%P", v, b, curp);
@
% >>
%old: use curp instead of PP above, and remove dead code then:
%   <<global PP(arm)>>=
%   static Prog *PP;
%   @
%   % to communicate info to olr for better diagnostic
%   <<[[asmout()]] other initialisations>>=
%   PP = p;
%   @
%ocaml: should be checked by overlap component checking

<<[[olr()]] sanity check [[a]]>>=
diag("expect move operation, not: %P", curp);
@
%pad: I added that


The use of large offsets ([[C_L]]$xxx$) requires an additional instruction
to first load the offset in [[REGTMP]]:

<<[[optab]] entries>>=
{ AMOVW,	C_LEXT,	C_NONE,	C_REG,		31, 8, REGSB,	LFROM },
{ AMOVW,	C_LAUTO,C_NONE,	C_REG,		31, 8, REGSP,	LFROM },
{ AMOVW,	C_LOREG,C_NONE,	C_REG,		31, 8, 0,	LFROM },

{ AMOVBU,	C_LEXT,	C_NONE,	C_REG,		31, 8, REGSB,	LFROM },
{ AMOVBU,	C_LAUTO,C_NONE,	C_REG,		31, 8, REGSP,	LFROM },
{ AMOVBU,	C_LOREG,C_NONE,	C_REG,		31, 8, 0,	LFROM },
@

The code below uses also [[omvl()]] which we saw
in Section~\ref{sec:pool-and-reg-tmp} for arithmetic instructions.
Remember than [[omvl()]] internally calls [[olr()]].
Indeed, we also need here to load from a {literal pool}
a large number, here an offset. So loading
certain data from memory requires actually two [[LDR]] instructions.

<<[[asmout()]] switch on type cases>>=
case 31:	/* mov/movbu L(R),R */
    o1 = omvl(p, &p->from, REGTMP);
    <<[[asmout()]] sanity check o1>>

    rt = p->to.reg;
    r = p->from.reg;
    <<[[asmout()]] adjust maybe r to rule param>>
    o2 = olrr(p->as, p->scond, REGTMP, r, rt);
    break;
@
% >>
%old: the code used to be factorized with case 32 with
%    if(o->type == 31)
%        break;
% and    if(p->as == AMOVBU || p->as == AMOVB), but now factorized in olr
% and was  '-> lr[b]' in comment but unclear

Note that [[i]] below represents a register number ([[REGTMP]])
which is passed to [[olr()]] instead of [[instoffset]] in previous calls.
Indeed, the immediate offset or the register containing
the offset are both encoded at the beginning of the ARM instruction
(the low bits).

<<function olrr(arm)>>=
long
olrr(int a, int sc, int i, int b, int r)
{

    return olr(a, sc, i, b, r) | (1<<25); // Rm not immediate offset
}
@
% >>
%old: was ^ xor but more logic | I think
%pad: added int a and moved int sc earlier, like for olr
%ocaml: take mem_op as a parameter (LDR vs STR) and either type for
% offset or register, so cleaner

\n actually 5a does not allow this syntax! R1(R2), but 5l can generate it




\subsection{Store}
\label{sec:store}

%dup: dual with previous section
[[MOVW]] can also be used to {\em store} data
from a register in memory, e.g., [[MOVW R2, 10(R1)]].
%dup: dual with previous section
This will result in the use of the ARM instruction [[STR]].


<<[[optab]] entries>>=
{ AMOVW,	C_REG,	C_NONE,	C_SEXT,		20, 4, REGSB },
{ AMOVW,	C_REG,	C_NONE,	C_SAUTO,	20, 4, REGSP },
{ AMOVW,	C_REG,	C_NONE,	C_SOREG,	20, 4, 0 },

{ AMOVBU,	C_REG,	C_NONE,	C_SEXT,		20, 4, REGSB },
{ AMOVBU,	C_REG,	C_NONE,	C_SAUTO,	20, 4, REGSP },
{ AMOVBU,	C_REG,	C_NONE,	C_SOREG,	20, 4, 0 },
@


<<[[asmout()]] switch on type cases>>=
case 20:	/* mov/movb/movbu R,O(R) */
    aclass(&p->to);
    rf = p->from.reg;
    r = p->to.reg;
    <<[[asmout()]] adjust maybe r to rule param>>
    o1 = osr(p->as, p->scond, rf, instoffset, r);
    break;
@


<<function osr(arm)>>=
long
osr(int a, int sc, int r, long v, int b)
{

    return olr(a, sc, v, b, r) ^ (1<<20); // STR, unset (via xor) bit 20
}
@
% >> >> >> >>
\n inconsistent param order with olr? no, mimic MOVW r, v(b)
%old: now set 22 in olr, so can factorize code, pass 'a' to olr
%    long o;
%
%    o = olr(v, b, r, sc) ^ (1<<20);
%    if(a != AMOVW)
%        o |= 1<<22;
%    return o;

Note that [[osr()]] is a small wrapper around 
[[olr()]] as the instruction format
for [[LDR]] and [[STR]] are very similar except for the bit 20.


<<[[optab]] entries>>=
{ AMOVW,	C_REG,	C_NONE,	C_LEXT,		30, 8, REGSB,	LTO },
{ AMOVW,	C_REG,	C_NONE,	C_LAUTO,	30, 8, REGSP,	LTO },
{ AMOVW,	C_REG,	C_NONE,	C_LOREG,	30, 8, 0,	LTO },

{ AMOVBU,	C_REG,	C_NONE,	C_LEXT,		30, 8, REGSB,	LTO },
{ AMOVBU,	C_REG,	C_NONE,	C_LAUTO,	30, 8, REGSP,	LTO },
{ AMOVBU,	C_REG,	C_NONE,	C_LOREG,	30, 8, 0,	LTO },
@

<<[[asmout()]] switch on type cases>>=
case 30:	/* mov/movb/movbu R,L(R) */
    o1 = omvl(p, &p->to, REGTMP);
    <<[[asmout()]] sanity check o1>>

    rf = p->from.reg;
    r = p->to.reg;
    <<[[asmout()]] adjust maybe r to rule param>>
    o2 = osrr(p->as, p->scond, rf, REGTMP, r);
    break;
@
%old: now done in olr
%    if(p->as != AMOVW)
%        o2 |= 1<<22;

\l so here 1 store requires actually a LDR and a STR

<<function osrr(arm)>>=
long
osrr(int a, int sc, int r, int i, int b)
{

    return olrr(a, sc, i, b, r) ^ (1<<20); // STR
}
@
% >> >>
%old:    return olr(i, b, r, sc) ^ ((1<<25) | (1<<20));

The previous cases work also for [[AMOVB]]:

<<[[optab]] entries>>=
{ AMOVB,	C_REG,	C_NONE,	C_SEXT,		20, 4, REGSB },
{ AMOVB,	C_REG,	C_NONE,	C_SAUTO,	20, 4, REGSP },
{ AMOVB,	C_REG,	C_NONE,	C_SOREG,	20, 4, 0 },
@

<<[[optab]] entries>>=
{ AMOVB,	C_REG,	C_NONE,	C_LEXT,		30, 8, REGSB,	LTO },
{ AMOVB,	C_REG,	C_NONE,	C_LAUTO,	30, 8, REGSP,	LTO },
{ AMOVB,	C_REG,	C_NONE,	C_LOREG,	30, 8, 0,	LTO },
@

Indeed, {storing} a signed byte or an unsigned byte from a register
involves the same ARM instruction.
%
This is not the case though for {loading}.
Indeed, loading a signed byte from memory in a register may require
to fill with 1s the 24 upper bits of the register if the
number in memory was negative. We will see the rules for
loading and [[AMOVB]] later in Section~\ref{sec:amovb-load}.


\subsection{Swaps}

[[SWP]] and [[SWPBU]] have a format more strict
than other memory operations.
\l Emulator? say use of swap?

<<[[buildop()]] switch opcode r for ranges cases>>=
case ASWPW:
    oprange[ASWPBU] = oprange[r];
    break;
@

<<[[optab]] entries>>=
{ ASWPW,	C_SOREG,C_REG,	C_REG,		40, 4 },
@
\l offset must be zero actually

<<[[asmout()]] switch on type cases>>=
case 40:	/* swp oreg,reg,reg */
    aclass(&p->from);
    <<[[asmout()]] sanity check instoffset for SWP>>
    o1 = (0x2<<23) | (0x9<<4); // SWP
    if(p->as == ASWPBU)
        o1 |= 1 << 22;
    rf = p->from.reg;
    rt = p->to.reg;
    r = p->reg;
    o1 |= ((p->scond & C_SCOND) << 28) | (rf<<16) | (rt<<12) | r;
    break;
@
% >> >> >> >> >> >> >>
%old: rewrote to use my consistent style

<<[[asmout()]] sanity check instoffset for SWP>>=
if(instoffset != 0)
    diag("offset must be zero in SWP");
@
%ocaml: enforced in AST

\subsection{Symbol addresses}

The loading of an address (e.g., [[MOVW $hello(SB), R1]]) %$
which happens after resolution to be a small rotatable offset
to a base register (e.g., [[SB]])
can be encoded efficiently using simply [[ADD]]:

<<[[optab]] entries>>=
{ AMOVW,	C_RECON,C_NONE,	C_REG,		 4, 4, REGSB },
{ AMOVW,	C_RACON,C_NONE,	C_REG,		 4, 4, REGSP },
@

<<[[asmout()]] switch on type cases>>=
case 4:		/* add $I,[R],R */
    aclass(&p->from);
    o1 = oprrr(AADD, p->scond);
    rt = p->to.reg;
    r = p->from.reg;
    <<[[asmout()]] adjust maybe r to rule param>>
    o1 |= (r<<16) | (rt<<12) | immrot(instoffset);
    break;
@
%$
\n again from should always be R_NONE

The address of an entity which is not a rotatable offset
must be loaded from a literal pool with [[omvl()]]:
\t address loaded from memory, meta
\t how load literal itself?? via PC! and guaranteed small offset
\t so no need ovml itself :)

\t what about address of code? well aclass returns actually
\t  a C_LCON for that we the rule we saw before is applied,
\t  like for other large immediate constant (use pool too, and
\t  here it will be a WORD dollar foo(SB)


% REGSP is here

<<[[optab]] entries>>=
{ AMOVW,	C_LACON,C_NONE,	C_REG,		34, 8, REGSP,	LFROM },
@

<<[[asmout()]] switch on type cases>>=
case 34:	/* mov $lacon,R -> LDR x(R15), R11; ADD R11, R13, R */
    o1 = omvl(p, &p->from, REGTMP);
    <<[[asmout()]] sanity check o1>>

    o2 = oprrr(AADD, p->scond);
    rf = REGTMP;
    rt = p->to.reg;
    r = p->from.reg; 
    <<[[asmout()]] adjust maybe r to rule param>>
    o2 |= (r<<16) | (rt<<12) | rf;
    break;
@
%$
%pad: I added the -> in the comment, and the rf = REGTMP;
%old:
%    if(p->to.type != D_NONE)
%        o2 |= p->to.reg << 12;
% but how can be D_NONE? has to be D_REG
\n p->from.reg should be always R_NONE, but code consistent with other
\n  rules which have a C_LOREG case


\subsection{Half words and signed bytes}

%trans:
The last rules for memory instructions we will see in this chapter
%toc:
concern the loading and storing of 
signed and unsigned {half words} (2 bytes) as well as
signed {bytes} (1 byte).
%
Many ARM processors have special support for those instructions.
In this section though we will see the simpler ARM code generation
rules for old ARM processors. 
\l helps understand more signed/unsigned differences
In those cases, [[MOVH]], [[MOVHU]]
and [[MOVB]] are virtual instructions transformed
by [[5l]] in multiple ARM instructions using [[LDR/STR]]
and bitshift instructions.
\n could have done in noops but then need if ARMv4 in noops
%
The rules for more recent ARM processors are described
in Section~\ref{sec:armv4}.

\subsubsection{Load}
\label{sec:amovb-load}

<<[[optab]] entries>>=
{ AMOVH,	C_SEXT,	C_NONE,	C_REG,		22, 12, REGSB },
{ AMOVH,	C_SAUTO,C_NONE,	C_REG,		22, 12, REGSP },
{ AMOVH,	C_SOREG,C_NONE,	C_REG,		22, 12, 0 },

{ AMOVHU,	C_SEXT,	C_NONE,	C_REG,		22, 12, REGSB },
{ AMOVHU,	C_SAUTO,C_NONE,	C_REG,		22, 12, REGSP },
{ AMOVHU,	C_SOREG,C_NONE,	C_REG,		22, 12, 0 },

{ AMOVB,	C_SEXT,	C_NONE,	C_REG,		22, 12, REGSB },
{ AMOVB,	C_SAUTO,C_NONE,	C_REG,		22, 12, REGSP },
{ AMOVB,	C_SOREG,C_NONE,	C_REG,		22, 12, 0 },
@

[[MOVHU 10(R1), R2]] is transformed in 3 instructions:
\begin{verbatim}
LDR 10(R1), R2 // load more than needed
SLL $16, R2 // reset the 16
SRL $16, R2 // upper bits
\end{verbatim}
\n can not do AND 0xffff ? :(

<<[[asmout()]] switch on type cases>>=
case 22:	/* movb/movh/movhu O(R),R -> lr,shl,shr */
    aclass(&p->from);
    rt = p->to.reg;
    r = p->from.reg;
    <<[[asmout()]] adjust maybe r to rule param>>
    o1 = olr(AMOVW, p->scond, instoffset, r, rt);

    o2 = oprrr(ASLL, p->scond);
    if(p->as == AMOVHU)
        o3 = oprrr(ASRL, p->scond);
    else
        o3 = oprrr(ASRA, p->scond);

    if(p->as == AMOVB) {
        o2 |= (rt<<12) | (24<<7) | rt;
        o3 |= (rt<<12) | (24<<7) | rt;
    } else {
        o2 |= (rt<<12) | (16<<7) | rt;
        o3 |= (rt<<12) | (16<<7) | rt;
    }
    break;
@
% >> >> >> >> >> >> >> >>
%old: I made more symetric with case 32
%    o3 = oprrr(ASRA, p->scond);
%    ...
%        if(p->as == AMOVHU)
%            o3 = oprrr(ASRL, p->scond);

Note that the rules for [[AMOVB]] and loading are in this section
while the rules for [[AMOVB]] and storing were presented
before and equivalent to the rules for [[AMOVBU]].
%
This asymmetry is due to how signed integers are represented in the machine:
in {\em two's complement} form.
%dup: codegen/memory/store
Loading a signed byte from memory in a 32 bits register may require
to fill with 1s the 24 upper bits of the register if the
number in memory was negative.
%
For instance the signed byte [[-128]] is represented in binary
as [[0b1000_0000]]. The signed word [[-128]] is represented
in binary as [[0b11....1000_0000]] though.
So one needs first to {logical shift} to
the left ([[SLL]]) [[0b1000_0000]] 24 times, and then
do an {\em arithmetic} shift to the right ([[SRA]]) 24 times back
so the possible presence of a [[1]] in bit 8 will be repeated
in all the upper bits.



<<[[optab]] entries>>=
{ AMOVH,	C_LEXT,	C_NONE,	C_REG,		32, 16, REGSB,	LFROM },
{ AMOVH,	C_LAUTO,C_NONE,	C_REG,		32, 16, REGSP,	LFROM },
{ AMOVH,	C_LOREG,C_NONE,	C_REG,		32, 16, 0,	LFROM },

{ AMOVHU,	C_LEXT,	C_NONE,	C_REG,		32, 16, REGSB,	LFROM },
{ AMOVHU,	C_LAUTO,C_NONE,	C_REG,		32, 16, REGSP,	LFROM },
{ AMOVHU,	C_LOREG,C_NONE,	C_REG,		32, 16, 0,	LFROM },

{ AMOVB,	C_LEXT,	C_NONE,	C_REG,		32, 16, REGSB,	LFROM },
{ AMOVB,	C_LAUTO,C_NONE,	C_REG,		32, 16, REGSP,	LFROM },
{ AMOVB,	C_LOREG,C_NONE,	C_REG,		32, 16, 0,	LFROM },
@

<<[[asmout()]] switch on type cases>>=
case 32:	/* movh/movb L(R),R */
    o1 = omvl(p, &p->from, REGTMP);
    <<[[asmout()]] sanity check o1>>

    rt = p->to.reg;
    r = p->from.reg;
    <<[[asmout()]] adjust maybe r to rule param>>
    o2 = olrr(p->as, p->scond, REGTMP,r, rt);

    o3 = oprrr(ASLL, p->scond);
    if(p->as == AMOVHU)
        o4 = oprrr(ASRL, p->scond);
    else
        o4 = oprrr(ASRA, p->scond);

    if(p->as == AMOVB) {
        o3 |= (rt<<12) | (24<<7) | rt;
        o4 |= (rt<<12) | (24<<7) | rt;
    } else {
        o3 |= (rt<<12) | (16<<7) | rt;
        o4 |= (rt<<12) | (16<<7) | rt;
    }
    break;
@
% >> >> >> >> >> >>  >> >>
\l could factorize shift
\n can not factorize with case 22 because here we use o3/o4, not o2/o3
%old: factorized in olrr now
%    if(p->as == AMOVB)
%        o2 |= 1<<22;
%old: made more symetric with case 31
%    o3 |= (rt<<12) | rt;
%    o4 |= (rt<<12) | rt;
%old: -> lr[b]  in comment but not helpful

\subsubsection{Store}

<<[[optab]] entries>>=
{ AMOVH,	C_REG,	C_NONE,	C_SEXT,		23, 12, REGSB },
{ AMOVH,	C_REG,	C_NONE,	C_SAUTO,	23, 12, REGSP },
{ AMOVH,	C_REG,	C_NONE,	C_SOREG,	23, 12, 0 },

{ AMOVHU,	C_REG,	C_NONE,	C_SEXT,		23, 12, REGSB },
{ AMOVHU,	C_REG,	C_NONE,	C_SAUTO,	23, 12, REGSP },
{ AMOVHU,	C_REG,	C_NONE,	C_SOREG,	23, 12, 0 },
@
\l remember no AMOVB for store, similar code than for AMOVBU

[[MOVHU R2, 10(R1)]] is transformed in 3 instructions:
\begin{verbatim}
LDRB R2, 10(R1) // load first byte
SRL $8, R2, R11 // extract second byte
LDRB R11, 11(R1) // load second byte
\end{verbatim}

<<[[asmout()]] switch on type cases>>=
case 23:	/* movh/movhu R,O(R) -> sb,sb */
    aclass(&p->to);
    rf = p->from.reg;
    r = p->to.reg;
    <<[[asmout()]] adjust maybe r to rule param>>
    o1 = osr(AMOVBU, p->scond, rf, instoffset, r);

    o2 = oprrr(ASRL, p->scond);
    rt = REGTMP;
    o2 |= (rt<<12) | (8<<7) | rf;

    o3 = osr(AMOVBU, p->scond, REGTMP, instoffset+1, r);
    break;
@
% >> >>
%old: 
% - was osr(AMOVH, ...) but more consistent to use AMOVB as indeed
%   it is converted in a MOVBU
% - use rt for REGTMP, more consistent, an clearer

Note the rule size of [[24]] below for the translation
of [[AMOVH]] using a large offset:

% 24 size ...
<<[[optab]] entries>>=
{ AMOVH,	C_REG,	C_NONE,	C_LEXT,		33, 24, REGSB,	LTO },
{ AMOVH,	C_REG,	C_NONE,	C_LAUTO,	33, 24, REGSP,	LTO },
{ AMOVH,	C_REG,	C_NONE,	C_LOREG,	33, 24, 0,	LTO },

{ AMOVHU,	C_REG,	C_NONE,	C_LEXT,		33, 24, REGSB,	LTO },
{ AMOVHU,	C_REG,	C_NONE,	C_LAUTO,	33, 24, REGSP,	LTO },
{ AMOVHU,	C_REG,	C_NONE,	C_LOREG,	33, 24, 0,	LTO },
@

[[MOVHU R2, 0xffff(R1)]] is transformed in 6 ARM instructions:
\begin{verbatim}
LDR xxx(R15), R11 // load offset
STR.B R2, R11(R1) // store first byte
ROR $8, R2, R2    // MOV R2@>8, R2
ADD $1, R11, R11
STR.B R2, R11(R1) // store second byte
ROR $24, R2, R2   // MOV R2@>24, R2
\end{verbatim}

<<[[asmout()]] switch on type cases>>=
case 33:	/* movh/movhu R,L(R) -> sb, sb */
    o1 = omvl(p, &p->to, REGTMP);
    <<[[asmout()]] sanity check o1>>

    rf = p->from.reg;
    r = p->to.reg;
    <<[[asmout()]] adjust maybe r to rule param>>
    o2 = osrr(AMOVBU, p->scond, rf, REGTMP, r);

    o3 = oprrr(ASRL, p->scond);
    o3 |= (rf<<12) | (8<<7) | rf;
    o3 |= (1<<6);	/* ROR 8 */

    o4 = oprrr(AADD, p->scond);
    o4 |= (REGTMP<<16) | (REGTMP<<12);
    o4 |= immrot(1);

    o5 = osrr(AMOVBU, p->scond, rf, REGTMP,r);

    // restore rf
    o6 = oprrr(ASRL, p->scond);
    o6 |= (rf<<12) | (24<<7) | rf;
    o6 |= (1<<6);	/* ROL 8 */

    break;
@
% >> >> >> >> >> >> >> >>
%old: now factorized in osrr
%    o2 |= (1<<22);
%    o5 |= (1<<22);




\section{Software interrupt opcodes}

%trans:

The final ARM code generation rules concern software interrupts.
\l actually last instr of ARM, class 7, and bit 24 set
%
[[SWI]] creates a software interrupt 
and performs a {\em system call} to a kernel function.
[[RFE]] returns from an {\em interrupt handler} in the kernel. 
[[RFE]] stands for ``Return From Exception''
as certain interrupts are due to hardware exceptions (e.g.
division by zero).
\l coprocessors

<<[[buildop()]] switch opcode r for ranges cases>>=
case ASWI:
case ARFE:
    break;
@


%dup: Assembler
Normally the argument to [[SWI]] in the ARM specifies an entry in an
{interrupt table}
\t really? not sure about that, seems more like a comment
but under \plan this argument is actually not
used. Instead, [[R0]] is used to store the system call code.

<<[[optab]] entries>>=
{ ASWI,		C_NONE,	C_NONE,	C_NONE,		10, 4 },
{ ASWI,		C_NONE,	C_NONE,	C_LCON,		10, 4 },
{ ASWI,		C_NONE,	C_NONE,	C_LOREG,	10, 4 },
@
%old: { ASWI,		C_NONE,	C_NONE,	C_LOREG,	10, 4, 0 },
%pad: I added the entry for LCON to allow SWI $0 which make more sense to me
% than SWI 0 which was used in 9syscall/mkfile originally
%old: I used to comment the LOREG entry because SWI was not having
% any argument in Assembler.nw, but now it has back an argument so
% I put it back.

<<[[asmout()]] switch on type cases>>=
case 10:	/* swi [$con] */
    o1 = oprrr(p->as, p->scond);
    if(p->to.type != D_NONE) {
        aclass(&p->to);
        o1 |= instoffset & 0xffffff;
    }
    break;
@
%$

<<[[oprrr()]] switch cases>>=
case ASWI:	return o | (0xf<<24);
@
% >> 

[[RFE]] is actually a virtual instruction which is
transformed by [[5l]] in an instruction
using [[MOVM]], the multiple
register move opcode (see Section~\ref{sec:movm}):

<<[[optab]] entries>>=
{ ARFE,		C_NONE,	C_NONE,	C_NONE,		41, 4 },
@
%emulator:
% there is no RFE in Machine.nw because all the system
% code is proxied, and so there is no assembly system code to emulate

<<[[asmout()]] switch on type cases>>=
case 41:	/* rfe -> movm.s.w.u 0(r13),[r15] */
    o1 = 0xe8fd8000;
    break;
@
\t meaning??
% .s has a special meaning when MOVM. see arm.pdf
%  w? useful offset is 0 anyway.
%  u? useful? offset is 0 anyway
% r13 = REGSP
% lol






\section{Literal Pools}
\label{sec:pool}

%trans:
We will now fully explain the final piece of the ARM code generation:
%
the management of {\em literal pools}.
Those pools are used for the translation of instructions using 
large constants, e.g., [[ADD $0xffff, R2, R3]], %$
or 
large offsets, e.g., [[MOVW 0xffce(R1), R2]]).
\l or addresses
%dup: codegen/arith/large-constant
As explained in Section~\label{sec:pool-and-reg-tmp},
large constants in operands are transformed as data
in the code section by using the [[WORD]] pseudo-opcode.
%
The two previous instructions are thus transformed,
thanks to the help of data structures and functions presented
in this section, in the following ARM instructions:

\begin{verbatim}
// ADD $0xffff, R2, R3
2000: LDR 1000(R15), R11
2004: ADD R11, R2, R3
// MOVW 0xffce(R1), R2
2008: LDR 996(R15), R11
2012: LDR R11(R1), R2
...
// literal pool at the end of the code section
3000: WORD $0xffff
3004: WORD $0xffce
\end{verbatim}

\l see 5l -v -a, see WORD generated at the end for constants

%toc: ? will explain how represented pool, how add new literal to pool,
% link to instr, and gen pool end of prog.
% finally bootstrap issue, if offset R15 too large?? check pool
% out of reach.

%real-world: ARM specific? x86 does not need that? probably not, can have
%  big constant just after. Not fixed-length instruction
% wikipedia says it's a bit ARM specfic.
% https://en.wikipedia.org/wiki/Literal_pool
% also Java uses pools too (for strings and class constants)

\subsection{[[blitrl/elitrl]]}

The literal pool, which is a list of [[WORD]] instructions, 
is represented by the globals [[blitrl]] and [[elitrl]]
which respectively stores the beginning and end of this list:

% [[b]]egin/[[e]]nd [[lit]]e[[r]]a[[l]] (confusing blit ...)
<<global blitrl(arm)>>=
// list<ref_own<prog>> (next = Prog.link)
Prog*	blitrl;
@
<<global elitrl(arm)>>=
// ref<Prog> (end from = blitrl)
Prog*	elitrl;
@


\subsection{[[addpool()]]}

As mentioned in Section~\ref{sec:pool-and-reg-tmp}, 
the addition of large constants in the literal pool is done
through the function [[addpool()]]. This function is called 
from [[dotext()]], as we will see soon,
thanks to a {\em rule flag} indicating which operand
in the instruction contains the large constant. 
Here are past examples of rules with a rule flag:

<<[[optab]] example of entries with rule flags (repeated)>>=
{ AADD,		C_LCON,	C_REG,	C_REG,		13, 8, 0,	LFROM },
{ AMOVW,	C_REG,	C_NONE,	C_LOREG,	30, 8, 0,	LTO },
@

The set of rule flags is defined by the type below:

<<enum Optab_flag(arm)>>=
enum Optab_flag {
    // Flags related to literal pools
    LFROM   = 1<<0,
    LTO     = 1<<1,

    LPOOL   = 1<<2,
    // Flags related architecture restrictions
    <<[[Optab_flag]] cases>>
};
@
% >> >> >> >> >>
%ocaml: return option with literal value directly, no need
% encode where to find it (in from or to operand)

[[LPOOL]] will be described in Section~\ref{sec:lpool}.
The remaining flags are described in Chapter~\ref{chap:advanced}.
\n V4, VFP

Remember from Section~\ref{sec:dotext} that [[dotext()]]
layouts code and calls [[oplook()]] to find
which rule [[o]] matches an instruction [[p]].
The presence of a rule flag in the rule [[o]]
determines the possible call to [[addpool()]]:

<<[[dotext()]] pool handling for optab o>>=
switch(o->flag & (LFROM|LTO|LPOOL)) {
<<[[dotext()]] pool handling, switch flag cases>>
}
<<[[dotext()]] pool handling, flush if MOVW REGPC>>
<<[[dotext()]] pool handling, checkpool>>
@
%old: c += m; used to be before if(blitrl)

<<[[dotext()]] pool handling, switch flag cases>>=
case LFROM:
    addpool(p, &p->from);
    break;
case LTO:
    addpool(p, &p->to);
    break;
@
\t not that from can be also an Address, not just an Immediate constant
\t  as in MOVW dollar foo(SB), R1

[[addpool()]] essentially adds a new [[WORD]] instruction
in the list [[blitrl]] with as an operand (in [[Instr.to]]),
the large constant or large offset in the operand parameter [[a]].
\t or address of entity that will be resolved later!
%
It also modifies the parameter [[p]]
so that its [[Instr.cond]] field links to the newly
added [[WORD]] instruction:

<<function addpool(arm)>>=
void
addpool(Prog *p, Adr *a)
{
    Prog *q;
    Prog t;
    //enum<Operand_class>
    int c;

    c = aclass(a);

    t = zprg;
    t.as = AWORD;
    <<[[addpool()]] set t.to using a>>

    <<[[addpool()]] if literal already present in pool>>
    // else

    q = prg();
    *q = t;

    <<[[addpool()]] set pool.start and pool.size>>

    // add_queue(q, blitrl, elitrl)
    if(blitrl == P) {
        blitrl = q;
    } else
        elitrl->link = q;
    elitrl = q;

    // for omvl()!
    p->cond = q;
}
@
%bug? where initialized pool.size to 0? because BSS zeroe'd
%old: the modification of pool.start and pool.size used
% to be more spead but I aspected it and grouped

Thanks to the instruction [[p->cond = q]] above,
[[omvl()]] in Section~\ref{sec:pool-and-reg-tmp},
will be able to know the offset to [[R15]] it needs to generate,
e.g., [[LDR 1000(R15), ...]],
to load this new literal.
%
Note that once the literal pool will be added at the end of the list
of code instructions (via [[flushpool()]] which we will
see in the next section), the [[WORD]] instructions
in the pool will be also processed by [[dotext()]] to
get their [[Instr.pc]] field set.
\l which is why when omvl, in asmout, everything is resolved and setup


[[addpool()]] is used with operands representing
large constants ([[C_LCON]]), but also
large offsets ([[C_LOREG]], [[C_LAUTO]]), and also with
symbols which when resolved are large offsets to [[R12]] 
([[C_LEXT]], [[C_LACON]]).
% code generation rule for AWORD in section X
% is aclass(). o1 = instoffset.
% default case below, just copy operand.
% so if operand D_CONST, so fine with WORD.
\t simplify code? add rules for WORD! and create test file showing issue
\t  if have no rule with C_LEXT

% { AWORD,	C_NONE,	C_NONE,	C_LEXT,		11, 4, 0 },

<<[[addpool()]] set t.to using a>>=
switch(c) {
<<[[addpool()]] switch operand class [[c]] cases>>
}
@

<<[[addpool()]] switch operand class [[c]] cases>>=
// C_LCON|C_xCON, C_LEXT|C_xEXT? TODO warning if other case?
default:
    t.to = *a;
    break;
@

% but need to rewrite the operand of WORD for other?

<<[[addpool()]] switch operand class [[c]] cases>>=
case C_SROREG:
case C_LOREG:
case C_ROREG:
case C_FOREG:
case C_SOREG:
case C_FAUTO:
case C_SAUTO:
case C_LAUTO:
case C_LACON:
    t.to.type = D_CONST;
    t.to.offset = instoffset;
    break;
@
\t just so avoid having too many rules? meh? add rules, better!!
\t  ugly repeat here subclasses.
\t  Also bug, forgot C_LEXT? or because adhoc WORD rules for C_LEXT
\t  then maybe simpler to generalize and add more rules for WORD!
\t how can have C_SAUTO and addpool? because does not have specialized
\t  rule with C_SAUTO for certain opcodes? so got to C_LCON?


There is no need to generate a new [[WORD]] instruction
if the pool contains already the literal we want to add:

<<[[addpool()]] if literal already present in pool>>=
// find_list(t.to, blitrl)
for(q = blitrl; q != P; q = q->link)
    if(memcmp(&q->to, &t.to, sizeof(Adr)) == 0) {
        // for omvl()
        p->cond = q;
        return;
    }
@
%old:	/* could hash on t.t0.offset */


\subsection{[[flushpool()]]}

% see soon how flushpool is called, but
% in simplest case with last code instructio p,
% so p->link = P.

<<function flushpool(arm)>>=
/// (dotext -> checkpool) | dotext -> <>
void
flushpool(Prog *p, bool skip)
{
    Prog *q;

    if(blitrl) {
        <<[[flushpool()]] if skip or corner case>>

        //insert_list_after_elt(blitlr, elitrl, p)
        elitrl->link = p->link;
        p->link = blitrl;

        blitrl = nil;/* BUG: should refer back to values until out-of-range */
        elitrl = nil;
        pool.size = 0;
        pool.start = 0;
    }
}
@
%old: if(debug['v'] && skip)  but skip always true because upper if
% so I simplified

% FIGURE? with insertion of list?


\subsection{[[checkpool()]]}

% simple case. flushpool called from checkpool from dotext
% when last instruction:

<<[[dotext()]] pool handling, checkpool>>=
if(blitrl)
    checkpool(p);
@

<<function checkpool(arm)>>=
void
checkpool(Prog *p)
{
    if(p->link == P)
        flushpool(p, true);
    else
    <<[[checkpool()]] if special condition>>
}
@
%old:
%    if(pool.size >= 0xffc || immaddr((p->pc+4)+4+pool.size - pool.start+8) == 0)
%        flushpool(p, 1);
%    else if(p->link == P)
%        flushpool(p, 2);
% but no diff between 1 and 2 since it's a bool

\t but issue! if too far?
\t bootstrapping,  LDR(1000)R15, R1,  small offset!
\t which is why use code section, othwewise could have done
\t with DATA pool1 0xffff, but then maybe too far and blocked!


Another global, [[pool]], is used to store additional
information about the pool:

<<global pool(arm)>>=
static struct {
    // PC of first instruction referencing the pool
    ulong	start;
    // a multiple of 4
    ulong	size;
} pool;
@


<<[[addpool()]] set pool.start and pool.size>>=
// will be overwritten when dotext() layout the pool later
q->pc = pool.size;

if(blitrl == P) {
    pool.start = p->pc;
}
pool.size += 4;
@




<<[[checkpool()]] if special condition>>=
/*
 * When the first reference to the literal pool threatens
 * to go out of range of a 12-bit PC-relative offset,
 * drop the pool now, and branch round it.
 * This happens only in extended basic blocks that exceed 4k.
 */
if(pool.size >= 0xffc || 
   immaddr((p->pc+4) + 4 + pool.size - pool.start + 8) == 0)
    flushpool(p, true);
@
\t 12 bits because offset    MOVW XXX(R15), R11
\t  aspectize other weird condition
%old: I moved the comment here, it used to be before
% checkpool, and I capitalized sentences.

<<[[flushpool()]] if skip or corner case>>=
if(skip){
    DBG("note: flush literal pool at %lux: len=%lud ref=%lux\n", 
        p->pc+4, pool.size, pool.start);
    q = prg();
    q->as = AB;
    q->to.type = D_BRANCH;
    q->cond = p->link;
    
    //insert_list(q, blitrl)
    q->link = blitrl;
    blitrl = q;
}
<<[[flushpool()]] else if not skip and corner case>>
@
\l when easy case of last instruction, still need to call with skip = true
\l otherwise might go in the else


\subsection{[[LPOOL]]}
\label{sec:lpool}
\t adv topics

% ex: AB instruction, etc.
% { AB,		C_NONE,	C_NONE,	C_BRANCH,		 5, 4, 0,	LPOOL },

<<[[dotext()]] pool handling, switch flag cases>>=
case LPOOL:
    if ((p->scond&C_SCOND) == COND_ALWAYS)
        flushpool(p, false);
    break;
@

% what for? improve locality??

<<[[dotext()]] pool handling, flush if MOVW REGPC>>=
// MOVW ..., R15  => flush
if(p->as==AMOVW && p->to.type==D_REG && p->to.reg==REGPC && 
   (p->scond&C_SCOND) == COND_ALWAYS)
    flushpool(p, false);
@

<<[[flushpool()]] else if not skip and corner case>>=
else if((p->pc + pool.size - pool.start) < 2048)
    return;
@






\chapter{Debugging Support}
\label{chap:debugging}

\n What. (good to see goal first, what kinds of features we want)
%dup: from Assembler 
The \plan debugger [[db]], which we will describe in the \book{Debugger},
has access to lots of {\em metadata} in the executable to help debug programs.
For instance, here is a simplified output of [[db]] when 
debugging a C program:

%dup: from Assembler 
\begin{verbatim}
$ db hello
...
main(argv=...) /usr/.../main.c 
      called from _main+26 (/sys/.../main9.s:12)
...
\end{verbatim}
\t add more trace with parameters and locals, stack trace

%dup: (adapted, talk about piece of code, not machine code) from Assembler
[[db]] knows from which {\em file} and which {\em line} a piece of
code comes from. It also knows 
the name of the {\em function} containing this piece of code, 
the {\em parameters} of this function (names and values), as well as 
the name of the {\em caller} to this function. 
Finally it knows also the file and line of this caller function.
\t also stack trace!
% in db doing $C  dumps the stacktrace with parameters values! and locals!
%  ex:
%  caml_main(argv=...) /home/pad/../main.c called from main+f (/home/pad/...)
%    caml_main.raise_buf/ 0x1
%    caml_main.pos/ 0x0
%    caml_main.trail/ 0x4cf2c
%    ...
%  main(argv=...) /home/pad/.../main.c called from _main+26 (.../main9.s:12)

\n How.
The metadata in the executable comes from
corresponding metadata in the object files generated by [[5a]] and [[5c]]. 
%
Indeed, the names of the parameters, locals, and entities are kept 
in the {\em object file symbol table}
which we have seen in Section~\ref{sec:h}
(and in the \book{Assembler}).
Each entry of this table uses the special opcode [[ANAME]].
%
In the same way, the object file contains also a {\em file/line table}
which uses the special opcode [[AHISTORY]] (see the \book{Assembler}).
\l but actually explained in this chapter. actually also use ANAME for filename
\l also each instr has global line number
%toc:
In this chapter we will see how two corresponding tables
are also stored in the executable: 
the {\em executable symbol table} and 
the {\em program counter and line table}.
\n not really file and line in exec, really just line table
\l cooperation of 5a, 5c, and now last piece: 5l.
\t also how stacktrace? caller? need special layout convention?

\l intro what is debugging? meh

\section{[[asmb()]] and the debugging tables}

%trans:
As explained in Section~\ref{sec:gen-executable}, 
the generation of the executable is done by [[asmb()]].
%
Here is the part of [[asmb()]] which generates the debugging sections:

<<[[asmb()]] symbol and line table sections>>=
// modified by asmsym()
symsize = 0;
// modified by asmlc()
lcsize = 0;

if(!debug['s']) {
    switch(HEADTYPE) {
    <<[[asmb()]] switch HEADTYPE (for symbol table generation) cases(arm)>>
    }
    DBG("%5.2f sym\n", cputime());
    asmsym();
    DBG("%5.2f pc\n", cputime());
    asmlc();

    <<[[asmb()]] if dynamic module, call asmdyn()>>
    cflush();
}
else {
    <<[[asmb()]] if dynamic module and no symbol table generation>>
}
@
\l could get rid of = 0 initialisations as done by 9 loader anyway.

Note that you can {\em strip} the executable of debugging
information by using the [[5l -s]] option.
You can also use instead later the [[strip]] command (described
in Appendix~\ref{sec:strip}) on the executable.

We saw in Section~\ref{sec:exec-format} that the debugging
tables are stored after the data section in an [[a.out]]
executable, hence the [[seek()]] below:

<<[[asmb()]] switch HEADTYPE (for symbol table generation) cases(arm)>>=
case H_PLAN9:
    OFFSET = HEADR+textsize+datsize;
    seek(cout, OFFSET, SEEK__START);
    break;
@

%toc:
The next two sections will describe the generation
of the executable symbol table, via [[asmsym()]],
\l (related to import/export table? I don't think so)
and the program counter and line table, via [[asmlc()]].


\section{Executable symbol table}
\l [[asmsym()]]

One side effect of [[asmsym()]] is to modify
the global [[symsize]] below, which contains the size of the symbol table.
The value in this global will then be stored in the [[a.out]] header
(see Section~\ref{sec:gen-header}).

<<global symsize>>=
long	symsize;
@

\subsection{Symbol table format, [[putsymb()]]}
\label{sec:exec-symbol-table}

%trans:
In Section~\ref{sec:h} we saw the rather subtle format
of the object file symbol table: a spread and circular array on disk.
We saw also in Section~\ref{sec:hash} the symbol table [[hash]],
which resides in memory, and which uses a hash table data structure.
Both tables were used for resolving symbols.
%
The format of the executable symbol table is very simple instead.
It is just a list of {\em symbol descriptions} separated by [['\0']].
The format of a symbol description as well as an example is shown in 
Figure~\ref{fig:exec-symbol-table}. The purpose of the
executable symbol table is mostly
to help debuggers to display names to the programmer
instead of memory addresses.
\l idea is that if arrive at 1022, can show that actually a _main plus 2 
\l (ref to previous example)
\n not resolving symbols, because done already :)
\l for dyn linking too?
\n labels in executable symbol table? no, was just for debugging 5l itself.

\begin{figure}[!]\centering
\begin{verbatim}
0         4     5             10   11                                        
+-----------------------------------+
|  1020   | 'T' |   "_main"    |'\0'|                       
+-----------------------------------+
   value    type     name        end 
                (variable size) marker
\end{verbatim}
\caption{Executable symbol table entry format.}
\label{fig:exec-symbol-table}
\end{figure}
\t how this is sufficient for type info? return type? need acid?

%\subsection{[[putsymb()]]}

[[putsymb()]] generates a new symbol description
in the executable, e.g., with [[putsymb("_main", 'T', 0x1020, 0)]].

<<function putsymb>>=
void
putsymb(char *s, int t, long v, int ver)
{
    int i, f;

    <<[[putsymb()]] adjust string [[s]] if file symbol>>

    // value
    lput(v);
    // type
    if(ver)
        t += 'a' - 'A'; // lowercase(t)
    cput(t+0x80);			/* 0x80 is variable length */

    <<[[putsymb()]] if z or Z>>
    else {
        // name
        for(i=0; s[i]; i++)
            cput(s[i]);
        // end marker
        cput('\0');
    }
    symsize += 4 + 1 + i + 1;

    <<[[putsymb()]] debug>>
}
@
%>>
\l int t? char t no?
\t why 0x80??


\subsection{Globals and procedures symbols, [[asmsym()]]}
\label{sec:asmsym}

%trans:
We can now see [[asmsym()]] which 
%
first calls [[putsymb()]] for all the data symbols in [[hash]]:

<<function asmsym(arm)>>=
/// main -> asmb -> <>
void
asmsym(void)
{
    Sym *s;
    int h;
    Prog *p;
    <<[[asmsym()]] other locals>>

    <<[[asmsym()]] generate symbol for etext>>

    // data symbols
    for(h=0; h<NHASH; h++)
        for(s=hash[h]; s!=S; s=s->link)
            switch(s->type) {
            case SDATA:
                putsymb(s->name, 'D', s->value+INITDAT, s->version);
                continue;
            case SBSS:
                putsymb(s->name, 'B', s->value+INITDAT, s->version);
                continue;
            <<[[asmsym()]] in symbol table iteration, switch section cases>>
            }

    // procedure symbols
    for(p=textp; p!=P; p=p->cond) {
        s = p->from.sym;
        if(s->type == STEXT) {
            /* filenames first */
            <<[[asmsym()]] call putsymb for filenames>>
            
            if(p->mark & LEAF)
                putsymb(s->name, 'L', s->value, s->version);
            else
                putsymb(s->name, 'T', s->value, s->version);

            // local symbols
            <<[[asmsym()]] frame symbols>>
        }
    }
    if(debug['v'] || debug['n']) {
        Bprint(&bso, "symsize = %lud\n", symsize);
        Bflush(&bso);
    }
}
@
\t bad name, has nothing to do with assembly really
\n the plus INITDAT for data symbols
%old: 
% || s->type == SLEAF
%            if(s->type == STEXT)
%                putsymb(s->name, 'T', s->value, s->version);
%            else // SLEAF
%                putsymb(s->name, 'L', s->value, s->version);
%old:
%            case SCONST:
%                putsymb(s->name, 'D', s->value, s->version);
%                continue;
%pad: I rewrote when I removed SLEAF, which is redundant with p->mark.

[[asmsym()]] could generate the entries for the procedures
by also using [[hash]]. 
\n actually we need the path element symbols at least before the procedures
Instead, it relies on [[textp]]
which contains the list of all procedures (and which we
will be described soon in Section~\ref{sec:textp}).
This list is a subset of the list of instructions in [[firstp]].
%
The reason for iterating over instructions instead of 
the symbol table for procedure symbols
is because the leaf information [[p->mark]] (see Section~\ref{sec:leaf})
is in the [[TEXT]] instruction of the procedure, not its symbol.
\n but the T vs L is not super important honestly, could be skipped
%trans:
Moreover, information about the parameters and local variables
of a procedure are also stored in the [[TEXT]] instruction as
we will see in the next section.

[[etext]] is defined via [[xdefine()]]
in Section~\ref{sec:special-symbols} and is part of the
text section ([[STEXT]]). It is not a real procedure though so it would not
be found in [[textp]], hence the special code below:

<<[[asmsym()]] generate symbol for etext>>=
s = lookup("etext", 0);
if(s->type == STEXT)
    putsymb(s->name, 'T', s->value, s->version);
@
\l why thing about etext is first? 
\n I don't think it matters. What matters is need special code cos not in textp

\subsection{Stack variables symbols}
\l frame?

In addition to {global} symbols, the executable symbol table
contains also information about the {local} variables
of a procedure and its parameters, that is stack variables.
\l also known as {\em automatic variables}.
This is really useful for displaying {\em stack traces} in a debugger.
%dup: from Assembler
This is also why assembly programmers write code like 
[[MOVW  count+4(FP), R1]] (or why [[5c]] generates such assembly code)
even though [[count]] is not used to generate any machine code;
[[count]] will be present in the executable symbol table and used
by the debugger to name stack variables.
\l and will be associated with 4(FP)
\l ex stack trace?

%trans:
Before showing the code of [[asmsym()]] which generates
entries for those stack variables, we need to explain first
the code which keeps track of those variables when
loading the object files in [[ldobj()]].

\subsubsection{[[Auto]]}

The [[Auto]] structure below is used to keep track of all the parameters
and locals accessed by a procedure:

<<struct Auto(arm)>>=
struct  Auto
{
    // enum<Sym_kind> (N_LOCAL, N_PARAM, or N_FILE/N_LINE)
    short   type;

    // <ref<Sym>>
    Sym*    asym;
    long    aoffset;

    // Extra
    <<[[Auto]] extra fields>>
};
@
\t rename Var?
\l will see later also abused for Hist

%example:
For instance, [[p+4(FP)]] will be represented by:
\begin{verbatim}
// p+4(FP)
{ .type = N_PARAM;  // (FP)
  .asym = &<p Sym>; // p
  .aoffset = 4;     // +4
}
\end{verbatim}

Those stack variables are chained together:

<<[[Auto]] extra fields>>=
// list<ref<Auto> (head = curauto or Instr.to.autom of TEXT instruction)
Auto*   link;
@

The head of the list is stored in one of the field
of one of the operand of the [[TEXT]] instruction:

<<[[Adr]] other fields>>=
// list<ref_own<Auto> (next = Auto.link), only used by TEXT instruction
Auto*   autom;
@
%old:
%   union {
%       // ref<Sym> of hash
%       Sym*	sym;
%       // list<ref_own<Auto> (next = Auto.link)
%       Auto*	autom;
%   };
% but really stupid opti that makes code harder to read and
% less identical to Operand type of 5a
\l rename autom and Auto
\n autom because auto is a reserved keyword? but nothing to do with automata
\l maybe better to rename local_or_param


\subsubsection{[[curauto]]}
\label{sec:curauto}

The set of stack variables for the current procedure ([[curtext]])
is stored in [[curauto]] and updated at loading
time by [[inopd()]] (which is called by [[ldobj()]]):

<<global curauto>>=
// list<ref<Auto>> (next = Auto.link)
Auto*	curauto;
@
%bug? should be = nil! initialized where? but done by kernel loader.



<<[[inopd()]] other locals>>=
Sym *s;
// <enum<Sym_kind>>
int t;
int l;
Auto *u;
@
%old: t was i, but t(ype) better than i


<<[[inopd()]] adjust curauto for N_LOCAL or N_PARAM symkind>>=
s = a->sym;
t = a->symkind;
l = a->offset;

// a parameter or local with a symbol, e.g., p+4(FP)
if(s != S && (t == N_LOCAL || t == N_PARAM)) {
  
   <<[[inopd()]] return if stack variable already present in curauto>>
    // else
    
    u = malloc(sizeof(Auto));
    u->asym = s;
    u->type = t;
    u->aoffset = l;
    
    //add_list(u, curauto)
    u->link = curauto;
    curauto = u;
}
@
%old: was
% if(s == S || (t != N_LOCAL && t != N_PARAM))
%    return size;
% but anyway has return size after
\l conflict with global entity with same name? maybe, so actually
\l  shared Sym? anyway, will use this Sym only for its name
\l  the actual value of the local is stored outside in aoffset

<<[[inopd()]] return if stack variable already present in curauto>>=
for(u=curauto; u; u=u->link)
    if(u->asym == s)
     if(u->type == t) {
        if(u->aoffset > l)
            u->aoffset = l; // diag()? inconsistent offset?
        return size;
    }
@
\l why adjust? meh

Once the code of a procedure has been fully read,
[[curauto]] can be transfered to the [[Instr.to.autom]] field
of the [[TEXT]] instruction of the current procedure:

<<[[ldobj()]] case ATEXT, if curtext not null adjustments for curauto>>=
if(curtext != P) {
    <<[[ldobj()]] case ATEXT, curauto adjustments with curhist>>
    curtext->to.autom = curauto;
    curauto = nil;
}
@

<<[[ldobj()]] case AEND, curauto adjustments>>=
if(curtext != P)
    curtext->to.autom = curauto;
curauto = nil;
@
\l so if no procedure in object? no file info ... because file/line use curauto
\l  diag() at least no?


\subsubsection{Procedure declarations, [[textp/etextp]]}
\label{sec:textp}
\l used by follow too ( and asmsym above)

%trans:
We can now see the pair of globals which keeps track of the 
list of procedures (the [[TEXT]] pseudo-instructions):
\n what for? for asmsym and follow()

<<global textp>>=
// list<ref<Prog>> (next = Prog.cond)
Prog*	textp = P;
@
<<global etextp>>=
// ref<Prog> (end from = textp)
Prog*	etextp = P;
@
\n seems dead but not, used to link textp in right order

The procedure instructions are chained together 
by (ab)using [[Instr.cond]]:

<<[[ldobj()]] in switch opcode ATEXT case, populate textp>>=
//add_queue(textp, etextp, p)
if(textp == P) {
    textp = p;
    etextp = p;
} else {
    etextp->cond = p;
    etextp = p;
}
@

Note that the instructions in the list [[textp/etextp]]
are a subset of the list of instructions in [[firstp/lastp]].
\l also use cond because anyway unused for TEXT, not a jump instr.

\subsubsection{Frame symbols}

We can now see the code which leverages [[Auto]]
to generate the symbols for the stack variables
of a procedure:

<<[[asmsym()]] other locals>>=
Auto *a;
@
<<[[asmsym()]] frame symbols>>=
/* frame, auto and param after */
putsymb(".frame", 'm', p->to.offset+4, 0);
for(a=p->to.autom; a; a=a->link)
    if(a->type == N_LOCAL)
        putsymb(a->asym->name, 'a', -a->aoffset, 0);
    else
    if(a->type == N_PARAM)
        putsymb(a->asym->name, 'p', a->aoffset, 0);
@
\l use a final_autosize() instead of magic  plus 4?


We refer to the \book{Debugger} to see how those symbols
are used to improve the debugging experience.
%
Note that the [[.frame]] symbol allows to know the size
in the stack necessary to hold
the local variables used by the procedure
as well as the return address to the caller (the [[+4]] above).
This part of the stack is also called the {\em frame} of a procedure.
Thanks to [[.frame]], the debugger can go up the stack
and identify the different frames of the different procedures
in the call stack.

%real-world: need rbp? -fomit-frame-pointer?


% nm helloc actually does not show everything,
% the 'f', 'p', and so are not shown by nm apparently.
% try 5l -n -o helloc helloc.5

%5l -n ...
%T 000011d0 atexit
%m 0000000c .frame
%a 00000004 i
%p 00000000 f

% nm -??


\subsection{Filename and line origin symbols}

The executable symbol table contains also information
about the filenames of the assembly or C sources
where the object files come from.
Those filenames are encoded using a compact scheme we will 
describe in Section~\ref{sec:file-line-symbols}.
%It stores the different parts
%of absolute filenames, e.g., [[usr]] in [[/usr/pad/main.c]],
%which we call {\em path elements}.
%
The symbol table also stores information about the 
[[#include]] and [[#line]] directives
used in those source files and which are kept in the object files.
Those directives help to keep track of the file and line origin 
of any piece of machine code.

% For path elements value is histgen (and no conflict with
%  procedure or global because starts with '<')
% For directive, it's split in two symbols,
% filename referencing path elements (and no conflict because
% starts with 0), and value is global line
%  and possibly local line in another symbol.


\section{File and line information}
\l [[asmlc()]]

%trans: 
Before seeing the code of [[asmlc()]] we need first to
%toc:
recall how file and line information are stored in object files,
and to explain the code of [[ldobj()]] which loads this information
in memory.

\subsection{Locations in objects, [[AHISTORY]]}
\label{sec:lineno}
\l and [[ANAME]] and [[Instr.line]]

%\subsubsection{[[Hist]]}

%dup: (adapted and summarized a lot) Assembler
In the \book{Assembler} we saw that some file and line information
were stored in the memory of [[5a]], in a list of [[Hist]] structures. 
\n important remind Hist because later have AHISTORY and funcs like addhist()
Each element of this list represented any one of the original source filename,
a [[#include]], or a [[#line]] directive, and contained 
the following three elements:

%dup: (adapted) Assembler
\begin{itemize}
\item A filename (or nil to indicate the end of a [[#include]])

\item A {\em global line number} representing a line number
after preprocessing
\n not so global now since we have many object files

\item A {\em local line number}, which was either 
[[0]] for the original source and [[#include]] directives, or
a positive integer for [[#line]] directives
(or [[-1]] for [[#pragma lib]] directives,
see Section~\ref{sec:loading-libraries-magically})

\end{itemize}
%ocaml: really should be a tree, so no need nil (or just a list of #line)

%\subsubsection{[[Instr.line]]}

%dup: (adapted and summarized a lot) Assembler
Thanks to this list,
we can then easily convert the global line number 
assigned to each instruction in the object file
in [[Instr.line]] (see Section~\ref{sec:instr})
to a pair of (source) filename and (local) line information.
\l Note that #line very important, for 5c generated objs!
\n (actually obj generated directly by 5c, so no need #line in 5a)
%
%dup: (and adapted) from Assembler
Figure~\ref{fig:hist} illustrates the evolution of
the global line number on the content of [[/tests/cpp/foo.s]]
(which includes other files) as well as the list of [[Hist]]s
after having pre-processed the entire file.

%dup: (and adapted slightly) from Assembler
\begin{figure}[!]\centering
\begin{verbatim}
                                              
                                       +--------------------+
     foo.s--------------------------+  |"foo.s", G1, L0     |
 1   |L1                            |  +--------------------+
 2   |L2                            |
 3   |L3 #include "foo.h"           |  +--------------------+
     |   foo.h-------------------+  |  |"foo.h", G4, L0     |
 4   |   |L1 #include "foo1.h"   |  |  +--------------------+
     |   |   foo1.h-----------+  |  |  |"foo1.h", G5, L0    |
 5   |   |   |L1              |  |  |  +--------------------+
     |   |   +----------------+  |  |  |nil, G6, L0         |
 6   |   |L2                     |  |  +--------------------+
 7   |   |L3 #include "foo2.h"   |  |  +--------------------+
     |   |   foo2.h-----------+  |  |  |"foo2.h", G8, L0    |
 8   |   |   |L1              |  |  |  +--------------------+
     |   |   +----------------+  |  |  |nil, G9, L0         |
 9   |   |L4                     |  |  +--------------------+
 10  |   |L5                     |  |  +--------------------+
     |   +-----------------------+  |  |nil, G11, L0        |
 11  |L4                            |  +--------------------+
 12  |L5 #include "bar.s"           |  +--------------------+
     |   bar.s-------------------+  |  |"bar.s", G13, L0    |
 13  |   |L1                     |  |  +--------------------+
 14  |   |L2                     |  |  +--------------------+
     |   +-----------------------+  |  |nil, G15, L0        |
 15  | L6                           |  +--------------------+
 16  | L7                           |  +--------------------+
 17  | L8#line 10 "foobar.c"        |  |"foobar.c", G18, L10|
 18  | L9                           |  +--------------------+
 19  |L10                           |  +--------------------+
     +------------------------------+  |nil, G20, L0        |
                                       +--------------------+
global         foo.s and                       list of
line         included files                 Hist structures
number
\end{verbatim}
\caption{File and line information for [[/tests/cpp/foo.s]].}
\label{fig:hist}
\end{figure}
\t copy latest from Assembler with dash arrows (and adapt?)

%\subsubsection{[[AHISTORY]]}

We also saw in the \book{Assembler} how the list of [[Hist]]
structures is stored at the beginning of the object file 
in instructions using the special opcode [[AHISTORY]].
\n abuse instr format
%
In fact, each [[AHISTORY]] instruction records just the
global line number (in [[Instr.line]]) and 
local line number (in [[Instr.to.offset]]) of an [[Hist]].
%
The filename of the [[Hist]] is encoded in a series
of [[ANAME]] preceding the [[AHISTORY]] instruction.
Each [[ANAME]] encodes a {\em path element} of the filename.
\l absolute filename always?
%
%example:
For instance, here is the series of instructions in the object file
which encode the directive [[#line 10 "/usr/foobar.c"]] 
of Figure~\ref{fig:hist}:
\begin{verbatim}
ANAME <usr
ANAME <foobar.c
AHISTORY 17 10
\end{verbatim}
\l can see that with 5l -W?

We will see later why each path element is prefixed by a [[<]]
and why a filename is split in multiple path elements.
\n to respectively avoid conflicts and help linker to compress later
\l why not [[/]]? defensive programming?

\subsection{Locations in [[5l]] memory}

%trans: %assembler:
[[5a]] uses the function [[outhist()]] to
write the [[Hist]]s in the object file by using [[AHISTORY]] and [[ANAME]]
instructions.
%toc:
We will now see the code of [[5l]] which reads those [[AHISTORY]]
and [[ANAME]] instructions in the different object files via [[ldboj()]].
%and [[addhist()]].   and inopd()
\l quite complicated, subtle compact encoding, save space

\subsubsection{[[AHISTORY]] and [[addhist]]}

Reading an [[AHISTORY]] in [[ldobj()]] is pretty simple since 
it is using the same format than regular instructions.
We can just write a new [[case]] in the opcode [[switch]] of [[ldobj()]]
and access information from the read instruction [[p]]:

<<[[ldobj()]] switch opcode cases(arm)>>=
case AHISTORY:
    <<[[ldobj()]] in AHISTORY case, if pragma lib>>
    // else

    // the global line
    addhist(p->line, N_FILE);		/* 'z' */
    // the local line (if needed for #line)
    if(p->to.offset)
        addhist(p->to.offset, N_LINE);	/* 'Z' */
    <<[[ldobj()]] in AHISTORY case, end of case, reset histfrogp>>
    goto loop;
@
%ocaml: such a mess, just marshall in, marshall out, no need spread
% info in AHISTORY and ANAME and then abuse symbol table
%assembler: see outhist() in 5a

As we will see in the rest of this chapter,
{one} [[AHISTORY]] instruction in the object file will become eventually
{two} symbols in the executable symbol table (if the local line 
number is non zero), hence the two
calls to [[addhist()]] above (and the [['z']] and [['Z']] comments).
\l but name of symbol?? see soon
\n why 'z' comment? cos compressed! why 'Z' because related (like 'T' and 't')
%
Indeed, [[addhist()]] below creates a new symbol, which we will
call an {\em [[Hist]] symbol} from now on, and a new [[Auto]] 
which is then stored in the global [[curhist]].
%
As we will see soon,
[[curhist]] is then copied in [[curauto]] which is then assigned
to one of the field of the first [[TEXT]] instruction of an object file.
Ultimately, the [[Hist]] symbols created by [[addhist()]] will be stored
in the executable symbol table.

<<function addhist>>=
void
addhist(long line, int type)
{
    Auto *u;
    Sym *s;
    <<[[addhist()]] other locals>>

    s = malloc(sizeof(Sym));

    u = malloc(sizeof(Auto));
    u->asym = s;
    u->type = type;
    u->aoffset = line;

    //add_list(u, curhist)
    u->link = curhist;
    curhist = u;

    <<[[addhist()]] set symbol name to filename using compact encoding>>
}
@

The second parameter of [[addhist()]] above can be either [[N_FILE]]
or [[N_LINE]], which are two new {symbol kinds}
(see Section~\ref{sec:opcode-operand}) used here respectively
to represent a global line number and a local line number (if there
is one).
%
The reason for using two [[Hist]] symbols for one [[AHISTORY]] is because
a symbol description in the executable symbol table can contain
only one integer value (see Section~\ref{sec:exec-symbol-table}),
but an [[AHISTORY]] carry two line numbers.
\n have room in one Auto to store two numbers, but not in exec symbol table

The code which sets the name of an [[Hist]] symbol will
be described soon; it is using a subtle compact encoding.
The next section will describe [[curhist]].

\n AHISTORY in Auto, so textp, so firstp
\n ANAME in symbol table (classic)

% Already abuse instruction format, AHISTORY opcode, to store
% line information. here abuse Auto.
% directives about file/line not stored in beginning of executable,
% but attached to first procedure of obj,
% after symbol of the procedure,
% before params/locals. So for each object can see a mapping
% to source code (hmm but for pop?)

\subsubsection{[[curhist]] and [[curauto]]}

[[curhist]] below is used to accumulate the list of [[Auto]]
created by [[addhist()]]. This list derives from the [[AHISTORY]] instructions.
[[curhist]] is similar to [[curauto]] which we saw in Section~\ref{sec:curauto}.

<<global curhist>>=
Auto*	curhist;
@

In fact, the elements in [[curhist]] are gradually transfered
to [[curauto]]:

<<[[ldobj()]] case ATEXT, curauto adjustments with curhist>>=
histtoauto();
@

<<[[ldobj()]] case AEND, curauto adjustments with curhist>>=
histtoauto();
@

<<function histtoauto>>=
/// ldobj (case AEND | ATEXT) -> <>
void
histtoauto(void)
{
    Auto *l;

    // append_list(curhist, curauto); curhist = nil;
    while(l = curhist) {
        curhist = l->link;

        l->link = curauto;
        curauto = l;
    }
}
@

%assembler: 
In [[5a]], [[Hist]]s are stored in memory in a single global ([[hist]])
because [[5a]] deals with only one assembly file at a time.
Global line numbers are unique there.
The [[Hist]]s are then stored at the beginning of the generated object file.
%
In [[5l]], because we deal with many object files, 
global line numbers are not unique anymore.
So, the [[Hist]]s, which became [[Auto]]s, are spread in the first
[[TEXT]] instructions of every input object files.
%
Eventually, as we will see in Section~\ref{sec:file-line-symbols},
the [[Hist]] symbols will be also spread in the executable symbol table
next to the symbols of the first procedures of every input
object files.
\t FIGURE! Where see flow of AHISTORY become 2 Auto, with ANAME, etc
\l so when global line number of instr, how know which conversion table to use?

\subsubsection{[[ANAME]] and path elements}

%trans: %dup: debugging/file-line-info/loc-in-objects
As said earlier, each [[AHISTORY]] instruction in the object file 
is preceded by a series of [[ANAME]]s which each encodes a path element
of the [[Hist]]'s filename.
%
The code in [[ldobj()]] dealing with [[ANAME]]s first lookups
in [[hash]] the symbol [[s]] introduced by this [[ANAME]] 
(see Section~\ref{sec:h}) and then executes the following code:

<<[[ldobj()]] when ANAME opcode, if N_FILE>>=
if(k == N_FILE) {
    if(s->type != SFILE) {
        s->type = SFILE;
        histgen++;
        s->value = histgen;
    }
    <<[[ldobj()]] when ANAME opcode, if N_FILE, update histfrogp>>
    <<[[ldobj()]] when ANAME opcode, if N_FILE, if no more space in histfrog>>
}
@
%ocaml: why so complicated ... why not just marshall
\l really should be N_PATH_ELEM
\l maybe should assert that it is SXREF when looked for the first time?

Note that because path elements are prefixed with a [[<]],
e.g., [[<usr]], their symbols can not conflict with the symbols used 
for globals or procedures, e.g., [[foo]].
%
A new section is used for those new kind of symbols:

<<[[Section]] cases>>=
SFILE,
@

Note also that if another [[ANAME]] instruction contains the same
path element, they will share the same symbol.
%
That way, if filenames of different [[Hist]]s have common roots,
they will share their common parts.
%
In fact, as shown by the code above,
each {path element symbol} is assigned a unique integer,
[[histgen]], stored in [[Sym.value]],
which will act as we will see soon as an {\em index}.

<<global histgen>>=
int	histgen = 0;
@
\l actually should be a short! 16 bits limit. No overflow checking, bad.

\subsubsection{Full filenames and [[histfrog]]}

The series of path element symbols corresponding to
the series of [[ANAME]]s preceding an [[AHISTORY]] 
are then accumulated in the following global array:

<<global histfrog>>=
Sym*	histfrog[MAXHIST];
@
\l frog?

<<constant MAXHIST>>=
MAXHIST     = 20,   /* limit of path elements for history symbols */
@

<<[[ldobj()]] when ANAME opcode, if N_FILE, update histfrogp>>=
if(histfrogp < MAXHIST) {
    histfrog[histfrogp] = s;
    histfrogp++;
} 
@

<<global histfrogp>>=
int	histfrogp;
@


The array is reseted after each processed [[AHISTORY]]:

<<[[ldobj()]] in AHISTORY case, end of case, reset histfrogp>>=
histfrogp = 0;
@

<<[[ldobj()]] after newloop when new object file, more initializations>>=
histfrogp = 0;
@
\l redundant I think

%trans:
We can now finally see how are encoded the names of [[Hist]] symbols.
%
[[5l]] is using a compact encoding. Instead, of 
storing the full string of the full filename, the symbol
name is made of a series of 16 bits integers representing
each a path element. Each integer corresponds
to the index [[histgen]] stored in [[Sym.value]] of
the corresponding path element symbol:

<<[[addhist()]] other locals>>=
int i, j, k;
@
<<[[addhist()]] set symbol name to filename using compact encoding>>=
s->name = malloc(2*(histfrogp+1) + 1);
j = 1;
for(i=0; i<histfrogp; i++) {
    k = histfrog[i]->value;
    s->name[j+0] = k>>8;
    s->name[j+1] = k;
    j += 2;
}
@
\t s[0] = ? 0 I think because malloc (use dumper to check!!)
\t 2*(histfrog plus 1)?? why need plus 1? because ending \0\0
\t could be nil? if it's a pop? then not set??
\l compression scheme??? then limit 16 bits histgen!

Symbol descriptions are usually separated by a [['\0']]
(see Section~\ref{sec:exec-symbol-table}),
but the 16 bits corresponding to an [[histgen]] can contain
a null character. Indeed, an [[histgen]] can be less than 256 
or a multiple of 256.
To avoid ambiguities, the first byte of an [[Hist]] symbol is the null
character and the name ends with a double null character,
hence [[malloc(2*(histfrogp+1) + 1)]] in the code above.
%
Note also that [[histgen]] starts at 1, which avoids
any ambiguity with the double ending null characters.


%example:
For instance, the start of the object file [[foo.5]]
resulting from the assembling of [[/usr/foo.s]] in Figure~\ref{fig:hist}
could be:

\begin{verbatim}
ANAME <usr
ANAME <foo.s
AHISTORY 1 0
ANAME <usr
ANAME <foo.h
AHISTORY 4 0
\end{verbatim}

Given this object file, here is the list of corresponding symbols
created by [[5l]] and their values:

\begin{verbatim}
{ .name = "<usr", .value = 1; }   // ANAME <usr
{ .name = "<foo.s", .value = 2; } // ANAME <foo.s
{ .name = "\0\0\1\0\2\0\0", .value = 1; } // AHISTORY 1 0, /usr/foo.s
{ .name = "<foo.h", .value = 3; } // ANAME foo.h
{ .name = "\0\0\1\0\3\0\0", .value = 4; } // AHISTORY 4 0, /usr/foo.h
\end{verbatim}



\subsubsection{[[collapsefrog()]]}

[[5l]] limits filenames to 20 path elements (see [[MAXHIST]]).
A longer filename will be truncated. Nevertheless, some path elements
such as [[".."]] or [["."]] can be resolved, which allows to extend 
partially the limit thanks to the code below:

<<[[ldobj()]] when ANAME opcode, if N_FILE, if no more space in histfrog>>=
else
        collapsefrog(s);
@
\l useful opti? just diag() !

Remember that [[<]] is the first character in all path elements,
hence the many [[+1]] in the code below:

<<function collapsefrog>>=
static void
collapsefrog(Sym *s)
{
    int i;

    /*
     * bad encoding of path components only allows
     * MAXHIST components. if there is an overflow,
     * first try to collapse xxx/..
     */
    for(i=1; i<histfrogp; i++)
        if(strcmp(histfrog[i]->name+1, "..") == 0) {
            memmove(histfrog+i-1, histfrog+i+1,
                (histfrogp-i-1)*sizeof(histfrog[0]));
            histfrogp--;
            goto out;
        }

    /*
     * next try to collapse .
     */
    for(i=0; i<histfrogp; i++)
        if(strcmp(histfrog[i]->name+1, ".") == 0) {
            memmove(histfrog+i, histfrog+i+1,
                (histfrogp-i-1)*sizeof(histfrog[0]));
            goto out;
        }

    /*
     * last chance, just truncate from front
     */
    memmove(histfrog+0, histfrog+1,
        (histfrogp-1)*sizeof(histfrog[0]));

out:
    histfrog[histfrogp-1] = s;
}
@
\l at least resistant to abuse


\subsection{Locations in executables}

%trans:
Now that all the file and line information has been loaded in memory
(in the symbol table, 
in some [[Auto]]s of some procedures, and 
in the [[Instr.line]] of every instructions)
we can see how this information is stored in the executable.
%toc:
Just like for object files, location information is split in two
parts: one part corresponding to the [[Hist]]s
is stored in the executable symbol table, while the other part
corresponding to the global line numbers of every instructions
is stored in a new {\em program counter and line table}.

\subsubsection{Path element and [[Hist]] symbols}
\label{sec:file-line-symbols}

Because path element symbols are shared by all object files,
they can be stored at the beginning of the executable symbol
table, with the symbols for globals:
\n also simple to be before any Hist, will help the debugger loading code

<<[[asmsym()]] in symbol table iteration, switch section cases>>=
case SFILE:
    putsymb(s->name, 'f', s->value, s->version);
    continue;
@

Remember that the value of path elements symbols is an [[histgen]],
an identifier referenced in the name of [[Hist]] symbols.
%
The [[<]] prefix in path elements can be skipped:

<<[[putsymb()]] adjust string [[s]] if file symbol>>=
if(t == 'f')
    s++;
@


[[Hist]] symbols are stored in the
[[Instr.to.autom]] field of the first procedure
of every object files. They are written just before the symbol
of the procedure (see Section~\ref{sec:asmsym}) in the executable
symbol table:

<<[[asmsym()]] call putsymb for filenames>>=
for(a=p->to.autom; a; a=a->link)
    if(a->type == N_FILE)
        putsymb(a->asym->name, 'z', a->aoffset, 0);
    else
    if(a->type == N_LINE)
        putsymb(a->asym->name, 'Z', a->aoffset, 0);
@
%ocaml: ugly to shove in to.autom with locals and params

The character type of an [[Hist]] symbol is a [['z']] to remind that the name
is using a compression scheme.
%

<<[[putsymb()]] if z or Z>>=
if(t == 'z' || t == 'Z') {
    cput(s[0]);
    for(i=1; s[i] != '\0' || s[i+1] != '\0'; i += 2) {
        cput(s[i]);
        cput(s[i+1]);
    }
    cput('\0');
    cput('\0');
    i++;
}
@

Note that there is only one [[i++]] above. The code
of [[putsymb()]] (see Section~\ref{sec:exec-symbol-table})
uses [[i]] to adjust [[symsize]] but it does add
1 to [[i]] to account for the very last null character.


\subsubsection{Program counter line table format}

%trans: Now that info in Hists are encoded in a way in exec
% via multiple symbols, time for global line numbers of Instruction.
% When machine code, line info disappear. 
% Need program counter -> global line. The program counter line table!

% Idea is Instr.line, global line number of each instr (which is not
% so global anymore, cos multiple object files).
% Naive would be pair of 32 bits integer.
% pc -> global line. for each instr.
% But means 2 words for each word of instruction in executable :(
% triple size of executable.

% but pc usually always +4, so could just global line for each instr.
% and global line increment small usually, so one byte! from 8 to 1 byte.
% then need deal with exceptions:
%  - line can go down back to 0 when code from another object
%  - not always +4 when instr generated multiple

\l FIGURE!
% tricky encoding, save space, store increment so can use byte
% instead of 32 bytes each time

% Refer to Debugger to code reading this format.
% Note that then need semi-global line number -> file x line not that easy.

% read man page? or format description a.out? there is the procedure
% to understand line table format


%dup: (and adapted) debugging/symbol-table
One side effect of [[asmlc()]] is to modify
the global [[lcsize]] below, which contains the size of the line table.
The value in this global will then be stored in the [[a.out]] header
(see Section~\ref{sec:gen-header}).

% lc? line count?
<<global lcsize>>=
long	lcsize;
@
\l bad name again


\subsubsection{[[asmlc()]]}

<<constant MINLC(arm)>>=
#define	MINLC	4
@
% size of instr (code of asmlc is copy pasted in 8l)

<<function asmlc>>=
void
asmlc(void)
{
    long oldpc, oldlc;
    Prog *p;
    long v;
    long s;

    oldpc = INITTEXT;
    oldlc = 0;
    for(p = firstp; p != P; p = p->link) {
        if(p->line == oldlc || p->as == ATEXT || p->as == ANOP) {
            <<adjust curtext when iterate over instructions p>>
            <<[[asmlc()]] dump instruction p, debug>>
            continue;
        }
        // else
        <<[[asmlc()]] dump lcsize, debug>>
        v = (p->pc - oldpc) / MINLC;
        while(v) {
            s = (v < 127)? v : 127; // min(), but impossible more than 6 (o6)
            cput(s+128);	/* 129-255 +pc */
            <<[[asmlc()]] dump s, debug>>
            v -= s;
            lcsize++;
        }
        s = p->line - oldlc;
        oldlc = p->line;
        oldpc = p->pc + MINLC;

        if(s > 64 || s < -64) {
            cput(0);	/* 0 vv +lc */
            cput(s>>24);
            cput(s>>16);
            cput(s>>8);
            cput(s);
            <<[[asmlc()]] dump big line change, debug>>
            lcsize += 5;
        } else {
            if(s > 0) {
                cput(0+s);	/* 1-64 +lc */
                <<[[asmlc()]] dump small line increment, debug>>
            } else {
                cput(64-s);	/* 65-128 -lc */
                <<[[asmlc()]] dump negative line increment, debug>>
            }
            lcsize++;
        }
    }
    // padding
    while(lcsize & 1) {
        s = 129;
        cput(s);
        lcsize++;
    }
    if(debug['v'] || debug['V'])
        Bprint(&bso, "lcsize = %ld\n", lcsize);
    Bflush(&bso);
}
@
\l bad name again
\l can have ANOP at this point??
%old:
%            s = 127;
%            if(v < 127)
%                s = v;
%old:
%  continue;   in if big line jump -> else if
\t change while() in diag() if more than 6? but code also shared by 8l
\t  maybe can copy paste anyway
\l why need final padding?

\t use 129 only when not pc+4, but when one instr generated multiple
\t  opti again! have to use special range otherwise ambiguity!



%\section{Tracing}?
% in profiling section right now, and buggy anyway





\chapter{Profiling Support}
\label{chap:profiling}

In many operating systems, profiling is
enabled by a flag of the compiler, e.g., [[gcc -p]].
%real-world: gcc -p
\n in ocaml need to use ocamlcp and then ocamlprof, or ocamlopt -p and gprof
\l actually now people use oprofile or perf where maybe need less flag
Surprisingly, in \plan 
%toc:
profiling support is enabled instead by a flag of the linker: [[5l -p]].
By {\em instrumenting} the instructions [[TEXT]] and [[RET]]
in different ways, [[5l]] can provide easily different sorts of profiling
which we will see in this chapter.

\n The code below was interesting because it inserted extra object code using
\n  directly "AST" constructs, so it helped to understand the data structure!!

\l intro profiling before? 
\n mechanism to get statistic about a program runtime behavior?

\section{[[5l -p]] and [[_mainp]]}

The effect of the use of the [[-p]] flag is twofold.
First, it changes the entry point of the program from
[[_main]] to [[_mainp]]:

<<[[main()]] adjust INITENTRY if profiling>>=
if(debug['p'])
    INITENTRY = "_mainp";
@

[[_mainp]] is a procedure written in assembly
in [[lib_core/libc/arm/main9p.s]]. The main
difference with [[_main]] is the call to [[_profmain()]]
defined in [[lib_core/libc/port/profile.c]] which
initializes profiling data.
See the \book{Profiler} for more information.

The second effect of [[-p]] is the execution of [[doprof1()]]
or [[doprof2()]] which perform different kinds 
of profiling:

<<[[main()]] call doprofxxx() if profiling>>=
if(debug['p'])
    if(debug['1'])
        doprof1();
    else
        doprof2();
@

Those functions are called after [[patch()]] and before [[noops()]]
(see Chapter~\ref{chap:resolving}).
Thanks to [[patch()]] and the graph of code instructions 
(see Section~\ref{sec:patch}), we can easily instrument
a program in a similar way to [[noops()]] (see Section~\ref{sec:noops}).
The idea is to insert 
new profiling instructions  {\em after} the pseudo instruction [[TEXT]], and
new profiling instructions {\em before} the virtual instruction [[RET]].

\section{[[5l -p -1]] and [[__mcount]]}

The first {profiling strategy} we will see counts 
{\em the number of times a function is called}. 
It is enabled by [[5l -p -1]]. 
\t good to see first, didactic. dead but didactic. profin/profout more fuzzy.
\n ocamlcp and ocamlprof are doing that; they count also branches
%
Note that it does not count the {\em time spent}
in those functions, which is another strategy we will see 
in the next section. %clever \ref{sec:_profin}
%
Nevertheless, even if the function calls count is a rudimentary information,
it can be already useful for improving the performance of a program. 
%dup: (and adapted) Principia.nw
In fact, it can be also very useful to find bugs in a program.
Indeed, unexpected statistics can be good leads for fixing code.
\t Bentley!

The main idea of [[doprof1()]] below is to use a global
array [[__mcount]] in which each entry corresponds
to a function. Each entry uses 8 bytes: the first 4 bytes
contain the address of the function, which is a simple way to
identify a function,
\t you can find name then thx to symbol table?
and the last 4 bytes the function calls count.
Each call to a function will then increment an element in [[__mcount]]
at runtime.

%example:
Here is an example of how the code is instrumented by [[5l -p -1]] for
a program with 2 procedures [[foo]] and [[bar]]:

\begin{verbatim}
TEXT foo(SB), $0 -> TEXT foo(SB), $0
                    MOVW __mcount+8(SB), R11
...                 ADD $1, R11
                    MOVW R11, __mcount+8(SB)
                    ...

RET              -> RET
                     
TEXT bar(SB), $0 -> TEXT bar(SB), $0
                    MOVW __mcount+16(SB), R11
...                 ADD $1, R11
                    MOVW R11, __mcount+16(SB)
                    ...
RET              -> RET
                     

DATA __mcount+0(SB)/4, $5 // number of words used by mcount
// start of info about foo
DATA __mcount+4(SB)/4,  $foo(SB)
// start of info about bar
DATA __mcount+12(SB)/4, $bar(SB)
\end{verbatim}
\t how know initialized to zero in between? datblk??

The code of [[doprof1()]] is pretty straightforward:

<<function doprof1(arm)>>=
void
doprof1(void)
{
    Sym *s;
    Prog *p, *q;
    long n;

    DBG("%5.2f profile 1\n", cputime());

    s = lookup("__mcount", 0);
    n = 1;
    for(p = firstp->link; p != P; p = p->link) {
        if(p->as == ATEXT) {

            // DATA __mcount+n*4(SB)/4,  $foo(SB) //$
            q = prg();
            q->line = p->line;
            q->as = ADATA;
            q->from.type = D_OREG;
            q->from.symkind = N_EXTERN;
            q->from.offset = n*4;
            q->from.sym = s;
            q->reg = 4; // size of this DATA slice
            q->to = p->from;
            q->to.type = D_ADDR;

            // add_list(q, datap)
            q->link = datap;
            datap = q;

            // MOVW __mcount+ n*4+4(SB), R11
            q = prg();
            q->line = p->line;
            q->pc = p->pc;
            q->as = AMOVW;
            q->from.type = D_OREG;
            q->from.symkind = N_EXTERN;
            q->from.sym = s;
            q->from.offset = n*4 + 4;
            q->to.type = D_REG;
            q->to.reg = REGTMP;

            // add_after(q, p)            
            q->link = p->link;
            p->link = q;

            p = q;

            // ADD, $1, R11 //$
            q = prg();
            q->line = p->line;
            q->pc = p->pc;
            q->as = AADD;
            q->from.type = D_CONST;
            q->from.offset = 1;
            q->to.type = D_REG;
            q->to.reg = REGTMP;

            // add_after(q, p)            
            q->link = p->link;
            p->link = q;

            p = q;

            // MOVW R11, __mcount+ n*4+4(SB)
            q = prg();
            q->line = p->line;
            q->pc = p->pc;
            q->as = AMOVW;
            q->from.type = D_REG;
            q->from.reg = REGTMP;
            q->to.type = D_OREG;
            q->to.symkind = N_EXTERN;
            q->to.sym = s;
            q->to.offset = n*4 + 4;

            // add_after(q, p)            
            q->link = p->link;
            p->link = q;

            p = q;

            n += 2;
            continue;
        }
    }

    // DATA __mcount+0(SB)/4, $n 
    q = prg();
    q->line = 0;
    q->as = ADATA;
    q->from.type = D_OREG;
    q->from.symkind = N_EXTERN;
    q->from.sym = s;
    q->reg = 4;
    q->to.type = D_CONST;
    q->to.offset = n;

    // add_list(q, datap)
    q->link = datap;
    datap = q;

    s->type = SBSS;
    s->value = n*4;
}
@
%$
%pad: was D_CONST above but I put D_ADDR now
%old: was mixing setting of new instr via p and q, better do everything with q
\l could use textp to go faster
\t bug because of q->pc = p->pc? and then mkfwd and find target?
\t  could find wrong target? NO cos patch has already been done!
\t  but then need propagate pc? anyway unused after patch() no?

Note the use of [[SBSS]] instead of [[SDATA]] 
above since the profiling instrumentation
is done before [[dodata()]]. The layout of data has not been done yet.

Given the instrumentation done by [[doprof1()]], we can then
easily modify the [[main()]]
of the profiled program to print data from [[__mcount]].
We can then display all the function calls counts or a subset of
those counts.
\t not shown, because dead option, but interesting for didactic
\l just need declare extern __mcount!
\n git grep __mcount does not seem to return stuff, probably obsolete code


\section{[[5l -p]] and [[_profin()/_profout()]]}
\label{sec:_profin}

%trans:
The second and default profiling strategy,
implemented by [[doprof2()]], 
%
is to count {\em the time spent in each function}.
%
Most of the logic for this strategy is actually implemented in
[[lib_core/libc/port/profile.c]] in two functions:
[[_profin()]] and [[_profout()]].
\n moreover _mainp call _profmain
We refer to the \book{Profiler} for more information on those functions.
In this section we will just explain how [[5l]] instruments
the code to call those functions.

%example:
Here is an example of how the code is instrumented by [[5l -p]] for
a program with 2 procedures [[foo]] and [[bar]]:

\begin{verbatim}
TEXT foo(SB), $0 -> TEXT foo(SB), $0
                    BL _profin(SB)
...                 ...

RET              -> BL _profout(SB)
                    RET
                     
TEXT bar(SB), $0 -> TEXT bar(SB), $0
                    BL _profin(SB)
...                 ...

RET              -> BL _profout(SB)
                    RET
\end{verbatim}
\t how magic works? getcallerpc? _tos? and then how report?

Again, the code of [[doprof2()]] is pretty straightforward:

<<function doprof2(arm)>>=
void
doprof2(void)
{
    Sym *s2, *s4;
    Prog *p, *q;
    <<[[doprof2()]] other locals>>

    DBG("%5.2f profile 2\n", cputime());

    // in lib_core/libc/port/profile.c
    s2 = lookup("_profin", 0);
    s4 = lookup("_profout", 0);
    <<[[doprof2()]] sanity check s2 and s4>>

    <<[[doprof2()]] find ps2, ps4, the Instr of s2 and s4>>

    for(p = firstp; p != P; p = p->link) {
        if(p->as == ATEXT) {
            <<[[doprof2()]] if NOPROF p(arm)>>
            <<[[doprof2()]] ATEXT instrumentation>>
            continue;
        }
        if(p->as == ARET) {
            <<[[doprof2()]] ARET instrumentation>>
            continue;
        }
    }
}
@
\l why s2 and s4? why not sin, sout? and pin, pout?
\l could be a switch, so less need continue
\l could use textp again so faster
%old:
%    <<[[doprof2()]] if embedded tracing>>
%    else{
%
%       <<[[doprof2()]] if embedded tracing diag()>>
%        else
%
%            <<[[doprof2()]] if embedded tracing ARET instrumentation>>


%trans:
Before instrumenting [[ATEXT]] and [[ARET]], we need first
%
to find the instructions containing the [[ATEXT]] of [[_profin()]]
and [[_profout()]]. Indeed, later we will 
generate instructions which call those functions, and so we
will need to set their [[Instr.cond]] fields to point to the
right instruction. We need to maintain what [[patch()]] did 
for the other branching instructions.

<<[[doprof2()]] other locals>>=
Prog *ps2 = P;
Prog *ps4 = P;
@

<<[[doprof2()]] find ps2, ps4, the Instr of s2 and s4>>=
for(p = firstp; p != P; p = p->link) {
    if(p->as == ATEXT) {
        if(p->from.sym == s2) {
            ps2 = p;
            <<[[doprof2()]] set TEXT attribute of _profin or _profout>>
        }
        if(p->from.sym == s4) {
            ps4 = p;
            <<[[doprof2()]] set TEXT attribute of _profin or _profout>>
        }
    }
}
@
%old: 
% ps2 = P;
% ps4 = P;
% better done at decl time


The [[ATEXT]] instrumentation is trivial:

<<[[doprof2()]] ATEXT instrumentation>>=
/*
 * BL	profin
 */
q = prg();
q->line = p->line;
q->pc = p->pc;
q->as = ABL;
q->to.type = D_BRANCH;
q->cond = ps2; // _profin
q->to.sym = s2;

//insert_after(q, p)
q->link = p->link;
p->link = q;

p = q;
@
%old: was mixing setting of new instr via p and q, better do everything with q
%old:
% <<[[doprof2()]] if embedded tracing ATEXT instrumentation(arm)>>
% else

The [[ARET]] instrumentation is more subtle.
%
First, we need to take care of
the possible branching instructions which were originally branching
to the [[RET]] instruction. We want those instructions to
now branch to the instrumented [[BL _profout]]. 
Indeed, we don't want to return before
calling [[_profout()]]. This is why in the code below,
[[p]], to which branching instructions may point to via
their [[Instr.cond]] fields, is first copied
in [[q]] and then overwritten:


<<[[doprof2()]] ARET instrumentation>>=
/*
 * RET
 */
q = prg();
// *q = *p;
q->as = ARET;
q->from = p->from;
q->to = p->to;
q->cond = p->cond;
q->link = p->link;
q->reg = p->reg;

// insert_after(q, p)
p->link = q;

<<[[doprof2()]] in ARET case, if conditinal execution>>
else {
   /*
    * BL	profout
    */
   // overwrite original RET instruction
   p->as = ABL;
   p->from = zprg.from;
   p->to = zprg.to;
   p->to.type = D_BRANCH;
   p->cond = ps4; // _profout
   p->to.sym = s4;
   p->scond = COND_ALWAYS;

   p = q;
}
@
%old: was mixing setting of new instr via p and q, better do everything with q
\t why not *q = *p ???

The second subtelity is due to the possible setting of
a conditional execution on [[RET]], e.g., [[RET.EQ]].
In that case we want to also conditionally execute
[[_profout()]] hence the code below which may
jump over the call to [[_profout()]].
%example:
Here is an example of instrumentation:
\begin{verbatim}
...       
RET.EQ        -> 1000: B.NE 1012
                 1004: BL _profout
                 1008: RET      
ADD R1, R2    -> 1012: ADD R1, R2

\end{verbatim}

<<[[doprof2()]] in ARET case, if conditinal execution>>=
if(p->scond != COND_ALWAYS) {
    // BL _profout
    q = prg();
    q->as = ABL;
    q->from = zprg.from;
    q->to = zprg.to;
    q->to.type = D_BRANCH;
    q->cond = ps4; // _profout
    q->to.sym = s4;

    // insert_after(q, p)
    q->link = p->link;
    p->link = q;

    // overwrite original RET instruction with  B.XXX 
    p->as = brcond[p->scond^1];	/* complement */
    p->scond = COND_ALWAYS;
    p->from = zprg.from;
    p->to = zprg.to;
    p->to.type = D_BRANCH;
    p->cond = q->link->link;	/* successor of RET */
    p->to.offset = q->link->link->pc; // useful??
        
    p = q->link->link;
}
@

The expression [[p->scond^1]] will reverse the last bit
of the conditional execution which when used to index 
[[brcond]] below will return the complement condition:

<<global brcond(arm)>>=
static int brcond[] = 
 {ABEQ, ABNE, 
  ABHS, ABLO, 
  ABMI, ABPL, 
  ABVS, ABVC, 
  ABHI, ABLS, 
  ABGE, ABLT, 
  ABGT, ABLE};
@


<<[[doprof2()]] sanity check s2 and s4>>=
if(s2->type != STEXT || s4->type != STEXT) {
    diag("_profin/_profout not defined");
    return;
}
@


\t once done, when exec calls _profin/_profout in profile.c
\t  which generate data which can then be analyzed by [[prof]].
\t  [[prof]] use executable symbol table? to find addr->mem? what
\t  is in generated data by _profin? See Profiler.

%\section{[[5l -p -e]] and [[_tracein()/_traceout()]]}
\n not in kencc, maybe dead, because code does not make sense honestly

% _profin() is defined by 
% (_tracin() is defined by you)
% -p -e, -e for embedded tracing

%dead: code does not make sense, or should just keep the first 2 chunks below
%
%   <<[[doprof2()]] if embedded tracing>>=
%   if(debug['e']){
%       s2 = lookup("_tracein", 0);
%       s4 = lookup("_traceout", 0);
%   }
%   @
%   
%   <<[[doprof2()]] if embedded tracing diag()>>=
%   if(debug['e'])
%       diag("_tracein/_traceout not defined %d %d", s2->type, s4->type);
%   @
%   
%   
%   <<[[doprof2()]] other locals>>=
%   Prog *q2;
%   @
%   <<[[doprof2()]] if embedded tracing ATEXT instrumentation(arm)>>=
%   if(debug['e']){		/* embedded tracing */
%       // B 
%       q2 = prg();
%       q2->line = p->line;
%       q2->pc = p->pc;
%   
%       q2->as = AB;
%       q2->to.type = D_BRANCH;
%       q2->to.sym = p->to.sym;
%       q2->cond = q->link;
%   
%       //insert_between(q2, p, q)
%       p->link = q2;
%       q2->link = q;
%   }
%   @
%   % ??? jump over yourself??
%   
%   
%   <<[[doprof2()]] if embedded tracing ARET instrumentation>>=
%   /*
%    * RET (default)
%    */
%   if(debug['e']){		/* embedded tracing */
%       q = prg();
%       q->line = p->line;
%       q->pc = p->pc;
%   
%       q->link = p->link;
%       p->link = q;
%       p = q;
%   }
%   @
%   % ??? set q->as ???


\section{Disabling profiling attribute, [[NOPROF]]}

You can disable profiling for certain functions
by setting the [[NOPROF]] {\em attribute} ([[1<<0]]),
e.g., with [[TEXT foo(SB), 1, $0]]. %$
This attribute is declared in [[5.out.h]]. See the \book{Assembler}
for more information on text attributes.

<<[[doprof2()]] if NOPROF p(arm)>>=
if(p->reg & NOPROF) {
    for(;;) {
        q = p->link;
        if(q == P || q->as == ATEXT)
            break;
        p = q;
    }
    continue;
}
@
\l grrr continue, break, grrr
The code above will skip the instrumentation of the current
procedure. It will actually skip all the instructions
of the procedure, including its [[RET]],
until the next procedure.

Of course we do not want to instrument the [[_profin()]]
and [[_profout()]] functions, otherwise we would generate
infinite loops, hence the defensive code below:

<<[[doprof2()]] set TEXT attribute of _profin or _profout>>=
p->reg = NOPROF;
@
%old: was using 1 but better use NOPROF







\chapter{Advanced Topics TODO}
\label{chap:advanced}

%dup: (and adapted) from Assembler
% seen major stuff, major code.

%toc:


\section{Dynamic linking}
\label{sec:dynamic-linking}
\l dynamic loading?
\t dynamic linking vs dynamic loading?

%http://harmful.cat-v.org/software/dynamic-linking/


<<global dlm>>=
bool dlm;
@

<<[[Section]] cases>>=
SIMPORT,
SEXPORT,
@



\subsection{Export table, [[5l -x]]}
% what this is for?

<<global doexp>>=
// do export table, -x
bool	doexp;
@


<<[[main()]] command line processing(arm)>>=
case 'x':	/* produce export table */
    doexp = true;
    if(argv[1] != nil && argv[1][0] != '-' && !isobjfile(argv[1]))
        readundefs(ARGF(), SEXPORT);
    break;
@
%in x86 there is also that
%        a = ARGF();
%        if(strcmp(a, "*") == 0)
%            allexport = true;
%        else

<<function isobjfile>>=
int
isobjfile(char *f)
{
    int n, v;
    Biobuf *b;
    char buf1[5], buf2[SARMAG];

    b = Bopen(f, OREAD);
    if(b == nil)
        return 0;
    n = Bread(b, buf1, 5);
    if(n == 5 && (buf1[2] == 1 && buf1[3] == '<' || buf1[3] == 1 && buf1[4] == '<'))
        v = 1;	/* good enough for our purposes */
    else{
        Bseek(b, 0, 0);
        n = Bread(b, buf2, SARMAG);
        v = n == SARMAG && strncmp(buf2, ARMAG, SARMAG) == 0;
    }
    Bterm(b);
    return v;
}
@


<<global EXPTAB>>=
char*	EXPTAB;
@


<<[[main()]] if export table or dynamic module(arm)>>=
if(doexp || dlm){
    EXPTAB = "_exporttab";
    zerosig(EXPTAB);
    zerosig("etext");
    zerosig("edata");
    zerosig("end");

    <<[[main()]] if dynamic module(arm)>>
    else
        divsig();

    export();
}
@



<<function zerosig>>=
void
zerosig(char *sp)
{
    Sym *s;

    s = lookup(sp, 0);
    s->sig = 0;
}
@



<<global nimports>>=
int nimports;
@

<<global nexports>>=
int nexports;
@

<<global imports>>=
int	imports;
@

<<global exports>>=
int	exports;
@


<<[[Sym]] other fields>>=
// enum<Section> too?
short   subtype;
@
%old: was char


<<function readundefs>>=
void
readundefs(char *f, int t)
{
    int i, n;
    Sym *s;
    Biobuf *b;
    char *l, buf[256], *fields[64];

    if(f == nil)
        return;
    b = Bopen(f, OREAD);
    if(b == nil){
        diag("could not open %s: %r", f);
        errorexit();
    }
    while((l = Brdline(b, '\n')) != nil){
        n = Blinelen(b);
        if(n >= sizeof(buf)){
            diag("%s: line too long", f);
            errorexit();
        }
        memmove(buf, l, n);
        buf[n-1] = '\0';
        n = getfields(buf, fields, nelem(fields), 1, " \t\r\n");
        if(n == nelem(fields)){
            diag("%s: bad format", f);
            errorexit();
        }
        for(i = 0; i < n; i++){
            s = lookup(fields[i], 0);
            s->type = SXREF;
            s->subtype = t;
            if(t == SIMPORT)
                nimports++;
            else
                nexports++;
        }
    }
    Bterm(b);
}
@




<<function export(arm)>>=
void
export(void)
{
    int i, j, n, off, nb, sv, ne;
    Sym *s, *et, *str, **esyms;
    Prog *p;
    char buf[NSNAME], *t;

    n = 0;
    for(i = 0; i < NHASH; i++)
        for(s = hash[i]; s != S; s = s->link)
            if(s->sig != 0 && s->type != SXREF && s->type != SUNDEF && (nexports == 0 || s->subtype == SEXPORT))
                n++;
    esyms = malloc(n*sizeof(Sym*));
    ne = n;
    n = 0;
    for(i = 0; i < NHASH; i++)
        for(s = hash[i]; s != S; s = s->link)
            if(s->sig != 0 && s->type != SXREF && s->type != SUNDEF && (nexports == 0 || s->subtype == SEXPORT))
                esyms[n++] = s;
    for(i = 0; i < ne-1; i++)
        for(j = i+1; j < ne; j++)
            if(strcmp(esyms[i]->name, esyms[j]->name) > 0){
                s = esyms[i];
                esyms[i] = esyms[j];
                esyms[j] = s;
            }

    nb = 0;
    off = 0;
    et = lookup(EXPTAB, 0);
    if(et->type != 0 && et->type != SXREF)
        diag("%s already defined", EXPTAB);
    et->type = SDATA;
    str = lookup(".string", 0);
    if(str->type == 0)
        str->type = SDATA;
    sv = str->value;
    for(i = 0; i < ne; i++){
        s = esyms[i];
        Bprint(&bso, "EXPORT: %s sig=%lux t=%d\n", s->name, s->sig, s->type);

        /* signature */
        p = newdata(et, off, sizeof(long), N_EXTERN);
        off += sizeof(long);
        p->to.offset = s->sig;

        /* address */
        p = newdata(et, off, sizeof(long), N_EXTERN);
        off += sizeof(long);
        p->to.symkind = N_EXTERN;
        p->to.sym = s;

        /* string */
        t = s->name;
        n = strlen(t)+1;
        for(;;){
            buf[nb++] = *t;
            sv++;
            if(nb >= NSNAME){
                p = newdata(str, sv-NSNAME, NSNAME, N_INTERN);
                p->to.type = D_SCONST;
                p->to.sval = malloc(NSNAME);
                memmove(p->to.sval, buf, NSNAME);
                nb = 0;
            }
            if(*t++ == 0)
                break;
        }

        /* name */
        p = newdata(et, off, sizeof(long), N_EXTERN);
        off += sizeof(long);
        p->to.symkind = N_INTERN;
        p->to.sym = str;
        p->to.offset = sv-n;
    }

    if(nb > 0){
        p = newdata(str, sv-nb, nb, N_INTERN);
        p->to.type = D_SCONST;
        p->to.sval = malloc(NSNAME);
        memmove(p->to.sval, buf, nb);
    }

    for(i = 0; i < 3; i++){
        newdata(et, off, sizeof(long), N_EXTERN);
        off += sizeof(long);
    }
    et->value = off;
    if(sv == 0)
        sv = 1;
    str->value = sv;
    exports = ne;
    free(esyms);
}
@




<<function newdata(arm)>>=
static Prog*
newdata(Sym *s, int o, int w, int t)
{
    Prog *p;

    p = prg();
    p->link = datap;
    datap = p;

    p->as = ADATA;
    p->reg = w;
    p->from.type = D_OREG;
    p->from.symkind = t;
    p->from.sym = s;
    p->from.offset = o;
    p->to.type = D_CONST;
    p->to.symkind = N_NONE;

    return p;
}
@



\subsection{Dynamic loading, [[5l -u]]}

% been disabled? can not find man page for dynld anymore, nor dynld.h
% -x, -u
% see dynld(2)

%see also rational for no dyn loading!
%http://sta.li/



<<[[main()]] command line processing(arm)>>=
case 'u':	/* produce dynamically loadable module */
    dlm = true;
    if(argv[1] != nil && argv[1][0] != '-' && !isobjfile(argv[1]))
        readundefs(ARGF(), SIMPORT);
    break;
@
%x86 had this too:
%    // do not load standard libraries
%    debug['l'] = true;


<<[[asmb()]] if dynamic module magic header adjustment(arm)>>=
if(dlm)
    lput(0x80000000|0x647);	/* magic */
@




% import(), pending of export() ?

<<[[main()]] if dynamic module(arm)>>=
if(dlm){
    initdiv();
    import();
    HEADTYPE = H_PLAN9;
    INITTEXT = INITDAT = 0;
    INITRND = 8;
    INITENTRY = EXPTAB;
}
@









<<function import(arm)>>=
void
import(void)
{
    int i;
    Sym *s;

    for(i = 0; i < NHASH; i++)
        for(s = hash[i]; s != S; s = s->link)
            if(s->sig != 0 && s->type == SXREF && (nimports == 0 || s->subtype == SIMPORT)){
                undefsym(s);
                Bprint(&bso, "IMPORT: %s sig=%lux v=%ld\n", s->name, s->sig, s->value);
            }
}
@

%on x86 additiona check and features, integrate them?
%                if(s->value != 0)
%                    diag("value != 0 on SXREF");
%                undefsym(s);
%                if(debug['X'])
%                    Bprint(&bso, "IMPORT: %s sig=%lux v=%ld\n", s->name, s->sig, s->value);
%                if(debug['S'])
%                    s->sig = 0;


<<enum rxxx>>=
enum rxxx {
    Roffset = 22,       /* no. bits for offset in relocation address */
    Rindex  = 10,       /* no. bits for index in relocation address */
};
@


\subsection{[[SUNDEF]]}

<<[[Section]] cases>>=
SUNDEF,
@
% for ??


<<global undefp>>=
//@Scheck: not dead, used by UP
Prog	undefp;
@
% for error recovery? and for dynamic loading stuff?

\label{sec:UP}
<<constant UP>>=
#define UP  (&undefp)
@
% who does = UP?


<<[[patch()]] switch section type for branch instruction, cases>>=
case SUNDEF:
    if(p->as != ABL)
        diag("help: SUNDEF in AB || ARET");
    p->to.offset = 0;
    p->to.type = D_BRANCH;
    p->cond = UP;
    break;
@

<<[[asmout()]] BRA case, if undefined target>>=
if(p->cond == UP) {
    s = p->to.sym;
    if(s->type != SUNDEF)
        diag("bad branch sym type");
    v = (ulong)s->value >> (Roffset-2);
    dynreloc(s, p->pc, 0);
}
@


% import -> undefsym
<<function undefsym>>=
void
undefsym(Sym *s)
{
    int n;

    n = imports;
    if(s->value != 0)
        diag("value != 0 on SXREF");
    if(n >= 1<<Rindex)
        diag("import index %d out of range", n);
    s->value = n<<Roffset;
    s->type = SUNDEF;
    imports++;
}
@
%>> >>


<<[[datblk()]] in D_ADDR case, switch symbol type cases>>=
case SUNDEF:
    ckoff(v, d);
    d += p->to.sym->value;
    break;
@
%old: was fallthrough on STEXT case, but I prefered to copy paste

<<function ckoff>>=
void
ckoff(Sym *s, long v)
{
    if(v < 0 || v >= 1<<Roffset)
        diag("relocation offset %ld for %s out of range", v, s->name);
}
@

% >>


\subsection{XXX}

<<[[aclass()]] in D_ADDR case, SDATA case, if dlm>>=
if(dlm) {
    instoffset = s->value + a->offset + INITDAT;
    return C_LCON;
}
@
%old: used to be in negative form in aclass but I rewrote it

% port to arm?
%<<[[asmb()]] if dynamic module, when iterate from firstp(xxx)>>=
%if(dlm) {
%    if(p->as == ATEXT)
%        reloca = nil;
%    else if(reloca != nil)
%        diag("reloc failure: %P", curp);
%}
%@


% ???
<<[[asmb()]] if dynamic module, before datblk()>>=
if(dlm){
    char buf[8];

    write(cout, buf, INITDAT-textsize);
    textsize = INITDAT;
}
@

<<[[asmb()]] if dynamic module and no symbol table generation>>=
if(dlm){
    seek(cout, HEADR+textsize+datsize, 0);
    asmdyn();
    cflush();
}
@


<<[[entryvalue()]] if dynamic module case>>=
case SDATA:
    if(dlm)
        return s->value+INITDAT;
@





<<struct Reloc>>=
struct Reloc
{
    int n;
    int t;
    byte *m;
    ulong *a;
};
@

<<global rels>>=
Reloc rels;
@



<<[[asmb()]] if dynamic module, call asmdyn()>>=
if(dlm)
    asmdyn();
@

% asmb() -> asmdyn()

<<function asmdyn>>=
void
asmdyn()
{
    int i, n, t, c;
    Sym *s;
    ulong la, ra, *a;
    vlong off;
    byte *m;
    Reloc *r;

    cflush();
    off = seek(cout, 0, 1);
    lput(0);
    t = 0;
    lput(imports);
    t += 4;
    for(i = 0; i < NHASH; i++)
        for(s = hash[i]; s != S; s = s->link)
            if(s->type == SUNDEF){
                lput(s->sig);
                t += 4;
                t += sput(s->name);
            }

    la = 0;
    r = &rels;
    n = r->n;
    m = r->m;
    a = r->a;
    lput(n);
    t += 4;
    for(i = 0; i < n; i++){
        ra = *a-la;
        if(*a < la)
            diag("bad relocation order");
        if(ra < 256)
            c = 0;
        else if(ra < 65536)
            c = 1;
        else
            c = 2;
        cput((c<<6)|*m++);
        t++;
        if(c == 0){
            cput(ra);
            t++;
        }
        else if(c == 1){
            wput(ra);
            t += 2;
        }
        else{
            lput(ra);
            t += 4;
        }
        la = *a++;
    }

    cflush();
    seek(cout, off, 0);
    lput(t);

    DBG("import table entries = %d\n", imports);
    DBG("export table entries = %d\n", exports);
}
@
% >> >>

<<function sput>>=
static int
sput(char *s)
{
    char *p;

    p = s;
    while(*s)
        cput(*s++);
    cput(0);
    return  s-p+1;
}
@



<<global modemap>>=
int modemap[4] = { 0, 1, -1, 2, };
@


<<[[datblk()]] if dynamic module(arm)>>=
if(dlm)
    dynreloc(v, a+INITDAT, 1);
@


<<enum _anon_ (linkers/5l/span.c)(arm)>>=
enum{
    ABSD = 0,
    ABSU = 1,
    RELD = 2,
    RELU = 3,
};
@


<<function dynreloc(arm)>>=
void
dynreloc(Sym *s, long v, int abs)
{
    int i, k, n;
    byte *m;
    ulong *a;
    Reloc *r;

    if(v&3)
        diag("bad relocation address");
    v >>= 2;

    if(s != S && s->type == SUNDEF)
        k = abs ? ABSU : RELU;
    else
        k = abs ? ABSD : RELD;
    /* Bprint(&bso, "R %s a=%ld(%lx) %d\n", s->name, a, a, k); */
    k = modemap[k];
    r = &rels;
    n = r->n;
    if(n >= r->t)
        grow(r);
    m = r->m;
    a = r->a;
    for(i = n; i > 0; i--){
        if(v < a[i-1]){	/* happens occasionally for data */
            m[i] = m[i-1];
            a[i] = a[i-1];
        }
        else
            break;
    }
    m[i] = k;
    a[i] = v;
    r->n++;
}
@
% the align 4 check at the beginning are ARM specific

<<function grow>>=
static void
grow(Reloc *r)
{
    int t;
    byte *m, *nm;
    ulong *a, *na;

    t = r->t;
    r->t += 64;
    m = r->m;
    a = r->a;
    r->m = nm = malloc(r->t * sizeof(byte));
    r->a = na = malloc(r->t * sizeof(ulong));
    memmove(nm, m, t*sizeof(byte));
    memmove(na, a, t*sizeof(ulong));
    free(m);
    free(a);
}
@



\subsection{Relocatable address, [[C_ADDR]]}
% rename? C_RELOC ? so can have D_ADDR and C_ADDR used for addresses?
%  and no confusion?

<<[[Operand_class]] cases>>=
C_ADDR,     /* relocatable address */
@

<<[[aclass()]] when D_OREG and external symbol and dlm>>=
if(dlm) {
    switch(t) {
    case STEXT: case SSTRING:
    case SUNDEF:
        instoffset = s->value + a->offset;
        break;
    case SDATA: case SBSS:
    default:
        instoffset = s->value + a->offset + INITDAT;
        break;
    }
    return C_ADDR;
}
@
%old: case SLEAF: case SCONST:
%pad: I added the case SDATA: case SBSS:
% in default should return exn if not SDATA or SBSS no?

<<[[optab]] entries>>=
{ ATEXT,	C_ADDR,	C_NONE,	C_LCON, 	 0, 0 },
{ ATEXT,	C_ADDR,	C_REG,	C_LCON, 	 0, 0 },
@
% size 0 so catched in dotext()

<<[[optab]] entries>>=
{ AWORD,	C_NONE,	C_NONE,	C_ADDR,		11, 4 },
@

<<[[asmout()]] in AWORD case, when dlm>>=
switch(c) {
case C_LCON:
    if(!dlm)
        break;
    if(p->to.symkind != N_EXTERN && p->to.symkind != N_INTERN)
        break;
    // Fallthrough
case C_ADDR:
    if(p->to.sym->type == SUNDEF)
        ckoff(p->to.sym, p->to.offset);
    dynreloc(p->to.sym, p->pc, 1);
}
@

% Store
<<[[optab]] entries>>=
{ AMOVW,	C_REG,	C_NONE,	C_ADDR,		64, 8, 0,	LTO },
{ AMOVB,	C_REG,	C_NONE,	C_ADDR,		64, 8, 0,	LTO },
{ AMOVBU,	C_REG,	C_NONE,	C_ADDR,		64, 8, 0,	LTO },
@

<<[[asmout()]] switch on type cases>>=
/* reloc ops */
case 64:	/* mov/movb/movbu R,addr */
    o1 = omvl(p, &p->to, REGTMP);
    if(!o1)
        break;
    o2 = osr(p->as, p->scond, p->from.reg, 0, REGTMP);
    break;
@

% Load
<<[[optab]] entries>>=
{ AMOVW,	C_ADDR,	C_NONE,	C_REG,		65, 8, 0,	LFROM },
{ AMOVBU,	C_ADDR,	C_NONE,	C_REG,		65, 8, 0,	LFROM },
{ AMOVB,	C_ADDR,	C_NONE,	C_REG,		66, 16, 0,	LFROM },
{ AMOVH,	C_ADDR,	C_NONE,	C_REG,		66, 16, 0,	LFROM },
{ AMOVHU,	C_ADDR,	C_NONE,	C_REG,		66, 16, 0,	LFROM },
@


<<[[asmout()]] switch on type cases>>=
case 65:	/* mov/movbu addr,R */
case 66:	/* movh/movhu/movb addr,R */
    o1 = omvl(p, &p->from, REGTMP);
    if(!o1)
        break;
    o2 = olr(p->as, p->scond, 0, REGTMP, p->to.reg);
    if(o->type == 65)
        break;

    o3 = oprrr(ASLL, p->scond);

    if(p->as == AMOVBU || p->as == AMOVHU)
        o4 = oprrr(ASRL, p->scond);
    else
        o4 = oprrr(ASRA, p->scond);

    r = p->to.reg;
    o3 |= (r)|(r<<12);
    o4 |= (r)|(r<<12);
    if(p->as == AMOVB || p->as == AMOVBU) {
        o3 |= (24<<7);
        o4 |= (24<<7);
    } else {
        o3 |= (16<<7);
        o4 |= (16<<7);
    }
    break;
@
% >> >> >> >> >> >> >>
%old: factorized in olr now
%    if(p->as == AMOVBU || p->as == AMOVB)
%        o2 |= 1<<22;

<<[[optab]] entries>>=
{ AMOVH,	C_REG,	C_NONE,	C_ADDR,		67, 24, 0,	LTO },
{ AMOVHU,	C_REG,	C_NONE,	C_ADDR,		67, 24, 0,	LTO },
@

<<[[asmout()]] switch on type cases>>=
case 67:	/* movh/movhu R,addr -> sb, sb */
    o1 = omvl(p, &p->to, REGTMP);
    if(!o1)
        break;
    o2 = osr(p->as, p->scond, p->from.reg, 0, REGTMP);

    o3 = oprrr(ASRL, p->scond);
    o3 |= (8<<7)|(p->from.reg)|(p->from.reg<<12);
    o3 |= (1<<6);	/* ROR 8 */

    o4 = oprrr(AADD, p->scond);
    o4 |= (REGTMP << 12) | (REGTMP << 16);
    o4 |= immrot(1);

    o5 = osr(p->as, p->scond, p->from.reg, 0, REGTMP);

    o6 = oprrr(ASRL, p->scond);
    o6 |= (24<<7)|(p->from.reg)|(p->from.reg<<12);
    o6 |= (1<<6);	/* ROL 8 */
    break;
@
% >> >> >> >> >> >> >> >>



%\section{Dynamic typing}

%\subsection{[[ADYNT]]}

%dead: asm.pdf says it was for alef for dynamic typing, so safe to remove
% it is never produced by 5a/5c


%<<global dtype(arm)>>=
%int	dtype = 4;
%@
%<<[[dodata()]] if ADYNT or AINIT>>=
%if(p->as == ADYNT || p->as == AINIT)
%    s->value = dtype;
%@

%<<[[ldobj()]] locals(arm)>>=
%Sym *di = S;
%@
%
%<<[[Section]] cases>>=
%SCONST,
%@
% SCONST ... hmm confusing with D_SCONST IMHO

%<<[[ldobj()]] switch opcode cases(arm)>>=
%case ADYNT:
%    if(p->to.sym == S) {
%        diag("DYNT without a sym\n%P", p);
%        break;
%    }
%    di = p->to.sym;
%    p->reg = 4;
%    if(di->type == SXREF) {
%        if(debug['z'])
%            Bprint(&bso, "%P set to %d\n", p, dtype);
%        di->type = SCONST;
%        di->value = dtype;
%        dtype += 4;
%    }
%    if(p->from.sym == S)
%        break;
%
%    p->from.offset = di->value;
%    p->from.sym->type = SDATA;
%    if(curtext == P) {
%        diag("DYNT not in text: %P", p);
%        break;
%    }
%    p->to.sym = curtext->from.sym;
%    p->to.type = D_CONST;
%    p->link = datap;
%    datap = p;
%    break;
%@

% \subsection{[[AINIT]]}
% seems never produced by 5a/5c, like ADYNT,
% seems to be just after a ADYNT, see the error message below

%<<[[ldobj()]] switch opcode cases(arm)>>=
%case AINIT:
%    if(p->from.sym == S) {
%        diag("INIT without a sym\n%P", p);
%        break;
%    }
%    if(di == S) {
%        diag("INIT without previous DYNT\n%P", p);
%        break;
%    }
%    p->from.offset = di->value;
%    p->from.sym->type = SDATA;
%    p->link = datap;
%    datap = p;
%    break;
%
%@

\section{Position independent code (PIC)}

%PIC, -fpic

% how ugly it is for x86:
% http://ewontfix.com/18/



\section{Optimizations}
\label{sec:optimisations}

% have seen already some opti in Section X for oplook, aclass, cmp.

\subsection{Opcode rewriting}
% at loading time

% would be better with ocaml pattern matching (but maybe not that shorter)
<<[[ldobj()]] switch opcode cases(arm)>>=
case ASUB:
    if(p->from.type == D_CONST)
      if(p->from.offset < 0) {
        p->from.offset = -p->from.offset;
        p->as = AADD;
    }
    goto casedef;
@
%pad: not needed with D_ADDR     if(p->from.symkind == N_NONE)

<<[[ldobj()]] switch opcode cases(arm)>>=
case AADD:
    if(p->from.type == D_CONST)
      if(p->from.offset < 0) {
        p->from.offset = -p->from.offset;
        p->as = ASUB;
    }
    goto casedef;
@
%pad: same     if(p->from.symkind == N_NONE)

% see also before in previous section the Leaf procedure opti,
% a form of opcode rewriting where some TEXT and RET can
% be optimized.

\subsection{Operand rewriting}

% certain operand values immediate values can be in a certain range
% which then can be encoded as a single instruction.

% If they are out of range but a double of 2, then again
% can be encoded as a single instruction.

% otherwise have to decompose.



% then introduce BIG optimisation below, or put in
% adv topic chapter with small data segment?

\label{sec:BIG}
<<[[dodata()]] define special symbols>>=
xdefine("setR12", SDATA, 0L+BIG);
@

<<constant BIG>>=
//BIG       = (1<<12)-4,
BIG     = 0,
@

% having BIG set to a page is good because STR/LDR
% accept immediate offset of 12 bits and a sign, so can encode
% easily [-4096,+4096] range.
% So good for hello(SB) but not so good for $hello(SB).
% Indeed, resulting offset will be negatif because do  Sym.value of
% hello which should be close to 0, minus BIG, which should
% be a negatif number. But RECON matchs only when can immrot(instoffset)
% and can do then ADD v, R12, Rwhatever, but when v is negatif
% and big number, not so easy to satisfy immrot(). In that case
% get a LCON.

% why -4? otherwise could not reach the first data? offset
% can be negative or positive so actually can cover 2 pages of
% small data variables!


\subsection{Small data first}
% improve data cache miss?

<<[[Section]] cases>>=
SDATA1,
@

<<constant MINSIZ>>=
MINSIZ      = 64,
@


<<[[dodata()]] in pass 1, if small data size, adjust orig>>=
/*
 *	assign 'small' variables to data segment
 *	(rational is that data segment is more easily
 *	 addressed through offset on R12)
 */
if(v <= MINSIZ) {
    s->value = orig;
    orig += v;
    s->type = SDATA1;
}
@

<<[[dodata()]] in pass 2, retag small data>>=
if(t == SDATA1)
    s->type = SDATA;
@

% also a few chunks where have case SDATA: case SDATA1:


\subsection{Compacting chains of [[AB]], [[brloop()]]}

% when need that? because of 5c generate a big sloppy code
% for loops?
% try 5c -S on simple programs using ifs.



<<[[patch()]] optimisation pass>>=
for(p = firstp; p != P; p = p->link) {
    <<adjust curtext when iterate over instructions p>>

    if(p->cond != P && p->cond != UP) {
        p->cond = brloop(p->cond);
        if(p->cond != P)
         if(p->to.type == D_BRANCH)
            p->to.offset = p->cond->pc;
    }
}
@

% p->to.offset = p->cond->pc;
% can have changed?? yes because of brloop()
% s/brloop()/? follow_AB?



%  p->cond = brloop(p->cond);
% compact a chain of AB to the end, and "detect" infinite chain loops
<<function brloop(arm)>>=
/// main -> patch -> <>
Prog*
brloop(Prog *p)
{
    Prog *q;
    int c = 0;

    for(; p!=P;) {
        if(p->as != AB)
            return p;
        q = p->cond;
        if(q <= p) {
            c++;
            if(q == p || c > 5000)
                break;
        }
        p = q;
    }
    return P;
}
@
% less: diag infinite loop detected??





\subsection{Removing useless instructions, [[follow()]]}
\label{sec:opti-follow}

% a space optimisation more than speed opti (but can help speed
% a bit maybe because of icache)

%note: right now it's not executed by 5l

% Note that this code does not remove the unused functions
% The size of helloc is very small but mainly because of
% loadlib() and objfile() on demand loading strategy of used
% but not yet defined (SXREF) symbols (and multiple passes
% on library symbol table until fixpoint).

% Here I think it's mostly for unreachable code, and chains of direct jmps.
% Note that useful I think.

% does not remove all unreachable instrs so,
% and does not remove unreachable functions :( maybe more important

%less: print the removed code!! usuful diagnostic no?

%if remove follow() optimisations, can have far simpler linker no?
%just dodata(), and simple asmb()? no need patch(), follow()?
%need patch(), because need to link to pc that will change when
%generate the actual instructions.


<<function follow>>=
void
follow(void)
{

    DBG("%5.2f follow\n", cputime());

    firstp = prg();
    lastp = firstp;

    xfol(textp);

    lastp->link = P;
    firstp = firstp->link;
}
@

<<[[Mark]] cases>>=
FOLL        = 1<<0,
@
% >>
% foll for follow?



% xfol? extended follow?
<<function xfol(arm)>>=
void
xfol(Prog *p)
{
    Prog *q, *r;
    int a, i;

loop:
    if(p == P)
        return;
    <<adjust curtext when iterate over instructions p>>
    a = p->as;

    if(a == AB) {
        q = p->cond;
        if(q != P) {
            p->mark |= FOLL;
            p = q;
            if(!(p->mark & FOLL))
                goto loop;
        }
    }

    if(p->mark & FOLL) {
        <<[[xfol()]] when p is marked, for loop to copy instructions>>
        a = AB;
        q = prg();
        q->as = a;
        q->line = p->line;
        q->to.type = D_BRANCH;
        q->to.offset = p->pc;
        q->cond = p;
        p = q;
    }

    p->mark |= FOLL;
    lastp->link = p;
    lastp = p;

    if(a == AB || (a == ARET && p->scond == COND_ALWAYS) || a == ARFE){
        return;
    }

    if(p->cond != P)
     <<[[xfol()]] if a is not ABL and p has a link>>
    p = p->link;
    goto loop;
}
@



<<[[xfol()]] if a is not ABL and p has a link>>=
if(a != ABL && p->link != P) {
   q = brchain(p->link);

   if(a != ATEXT && a != ABCASE)
    if(q != P && (q->mark & FOLL)) {
       p->as = relinv(a);
       p->link = p->cond;
       p->cond = q;
   }

   // recursive call
   xfol(p->link);

   q = brchain(p->cond);
   if(q == P)
       q = p->cond;
   if(q->mark&FOLL) {
       p->cond = q;
       return;
   }
   p = q;
   goto loop;
}
@

% follows a chain of AB, hmm but needed now that has brloop()?
<<function brchain(arm)>>=
static Prog*
brchain(Prog *p)
{
    int i;

    for(i=0; i<20; i++) {
        if(p == P || p->as != AB)
            return p;
        p = p->cond;
    }
    return P;
}
@

<<function relinv(arm)>>=
int
relinv(int a)
{
    switch(a) {
    case ABEQ:	return ABNE;
    case ABNE:	return ABEQ;
    case ABHS:	return ABLO;
    case ABLO:	return ABHS;
    case ABMI:	return ABPL;
    case ABPL:	return ABMI;
    case ABVS:	return ABVC;
    case ABVC:	return ABVS;
    case ABHI:	return ABLS;
    case ABLS:	return ABHI;
    case ABGE:	return ABLT;
    case ABLT:	return ABGE;
    case ABGT:	return ABLE;
    case ABLE:	return ABGT;
    }
    diag("unknown relation: %s", anames[a]);
    return a;
}
@





<<[[xfol()]] when p is marked, for loop to copy instructions>>=
for(i=0, q=p; i<4 && q != lastp; i++, q=q->link) {
    a = q->as;
    if(a == ANOP) {
        i--;
        continue;
    }
    if(a == AB || (a == ARET && q->scond == COND_ALWAYS) || a == ARFE)
        goto copy;
    if(!q->cond || (q->cond->mark & FOLL))
        continue;
    if(a != ABEQ && a != ABNE)
        continue;

// here when a is one of AB, ARET, ARFE, ABEQ, ABNE
copy:
    for(;;) {
        r = prg();
        *r = *p;

        <<[[xfol()]] sanity check one, r should be marked>>

        if(p != q) {
            p = p->link;
            lastp->link = r;
            lastp = r;
            continue;
        }
        lastp->link = r;
        lastp = r;

        if(a == AB || (a == ARET && q->scond == COND_ALWAYS) || a == ARFE)
            return;

        // r->as = relinv(a)
        r->as = ABNE;
        if(a == ABNE)
            r->as = ABEQ;

        r->cond = p->link;
        r->link = p->cond;

        if(!(r->link->mark & FOLL))
            // recursive call
            xfol(r->link);

        <<[[xfol()]] sanity check two, [[r->cond]] should be marked>>

        return;
    }
}
@
%old: had        
% if(q == lastp)
%    break;
% at beginning of the for loop, but I moved it up in the for(;_here_;) instead
% (equivalent)




\ifallcode
<<[[xfol()]] sanity check one, r should be marked>>=
if(!(r->mark & FOLL))
    print("cant happen 1\n");
r->mark |= FOLL;
@

<<[[xfol()]] sanity check two, [[r->cond]] should be marked>>=
if(!(r->cond->mark & FOLL))
    print("cant happen 2\n");
@
\fi



\section{Overriding symbol attribute, [[DUPOK]]}
\label{sec:dupok-nop}

% case in kernel where override a previous symbol,
% e.g., sysfatal, werrstr

% DUPOK, x.scale & DUPOK


<<[[ldobj()]] locals(arm)>>=
bool skip;
@
<<[[ldobj()]] after newloop when new object file, more initializations>>=
skip = false;
@
% If set to true then generate a NOP actually for the currently
% read instruction. Used for DUPOK for instance.



<<[[ldobj()]] case ATEXT and section not SNONE or SXREF, if DUPOK>>=
if(p->reg & DUPOK) {
    skip = true;
    goto casedef;
}
@
% skip all until next TEXT


<<[[ldobj()]] in switch opcode default case, if skip>>=
if(skip)
    nopout(p);
@

<<[[ldobj()]] in switch opcode ATEXT case, reset skip>>=
skip = false; // needed?
@



% for e.g., ATEXT that are DUPOK
<<function nopout>>=
static void
nopout(Prog *p)
{
    p->as = ANOP;
    p->from.type = D_NONE;
    p->to.type = D_NONE;
}
@
% why care about .type? because some code is look for
% D_BRANCH, for symbols, and so putting D_NONE ensure those
% code will not be triggred for what was transformed in NOP.




\section{Other executable formats}
\label{sec:other-executable-formats}


%<<[[main()]] switch HEADTYPE cases(arm)>>=
%case 0:	/* no header */
%case 6:	/* no header, padded segments */
%    HEADR = 0L;
%    if(INITTEXT == -1)
%        INITTEXT = 0;
%    if(INITDAT == -1)
%        INITDAT = 0;
%    if(INITRND == -1)
%        INITRND = 4;
%    break;
\t used for raspberry pi! see bcm/.../mkfile

%case 1:	/* aif for risc os */
%    HEADR = 128L;
%    if(INITTEXT == -1)
%        INITTEXT = 0x10005000 + HEADR;
%    if(INITDAT == -1)
%        INITDAT = 0;
%    if(INITRND == -1)
%        INITRND = 4;
%    break;
%case 3:	/* boot for NetBSD */
%    HEADR = 32L;
%    if(INITTEXT == -1)
%        INITTEXT = 0xF0000020L;
%    if(INITDAT == -1)
%        INITDAT = 0;
%    if(INITRND == -1)
%        INITRND = 4096;
%    break;
%case 4: /* boot for IXP1200 */
%    HEADR = 0L;
%    if(INITTEXT == -1)
%        INITTEXT = 0x0;
%    if(INITDAT == -1)
%        INITDAT = 0;
%    if(INITRND == -1)
%        INITRND = 4;
%    break;
%case 5: /* boot for ipaq */
%    HEADR = 16L;
%    if(INITTEXT == -1)
%        INITTEXT = 0xC0008010;
%    if(INITDAT == -1)
%        INITDAT = 0;
%    if(INITRND == -1)
%        INITRND = 1024;
%    break;

%<<[[asmb()]] switch HEADTYPE (to position after text) cases(arm)>>=
%case 0:
%case 1:
%case 5:
%...
%case 3:
%case 6:	/* no header, padded segments */
%    OFFSET = rnd(HEADR+textsize, 4096);
%    seek(cout, OFFSET, 0);
%    break;


%<<[[asmb()]] switch HEADTYPE (for symbol table generation) cases(arm)>>=
%case 0:
%case 1:
%case 4:
%case 5:
%    debug['s'] = 1;
%    break;
%case 3:
%case 6:	/* no header, padded segments */
%    OFFSET += rnd(datsize, 4096);
%    seek(cout, OFFSET, 0);
%    break;


%<<[[asmb()]] switch HEADTYPE (for header generation) cases(arm)>>=
%case 0:	/* no header */
%case 6:	/* no header, padded segments */
%    break;
%case 1:	/* aif for risc os */
%    lputl(0xe1a00000);		/* NOP - decompress code */
%    lputl(0xe1a00000);		/* NOP - relocation code */
%    lputl(0xeb000000 + 12);		/* BL - zero init code */
%    lputl(0xeb000000 +
%        (entryvalue()
%         - INITTEXT
%         + HEADR
%         - 12
%         - 8) / 4);		/* BL - entry code */
%
%    lputl(0xef000011);		/* SWI - exit code */
%    lputl(textsize+HEADR);		/* text size */
%    lputl(datsize);			/* data size */
%    lputl(0);			/* sym size */
%
%    lputl(bsssize);			/* bss size */
%    lputl(0);			/* sym type */
%    lputl(INITTEXT-HEADR);		/* text addr */
%    lputl(0);			/* workspace - ignored */
%
%    lputl(32);			/* addr mode / data addr flag */
%    lputl(0);			/* data addr */
%    for(t=0; t<2; t++)
%        lputl(0);		/* reserved */
%
%    for(t=0; t<15; t++)
%        lputl(0xe1a00000);	/* NOP - zero init code */
%    lputl(0xe1a0f00e);		/* B (R14) - zero init return */
%    break;
%case 3:	/* boot for NetBSD */
%    lput((143<<16)|0413);		/* magic */
%    lputl(rnd(HEADR+textsize, 4096));
%    lputl(rnd(datsize, 4096));
%    lputl(bsssize);
%    lputl(symsize);			/* nsyms */
%    lputl(entryvalue());		/* va of entry */
%    lputl(0L);
%    lputl(0L);
%    break;
%case 4: /* boot for IXP1200 */
%    break;
%case 5: /* boot for ipaq */
%    lputl(0xe3300000);		/* nop */
%    lputl(0xe3300000);		/* nop */
%    lputl(0xe3300000);		/* nop */
%    lputl(0xe3300000);		/* nop */
%    break;
% >> 

\subsection{ELF, Linux}

%real-world: real world indeed. why a.out dead? no good support for dyn libs?

% ELF dissection:
% - https://github.com/mewrev/dissection
% - very nice diagram a la xkcd
%   https://code.google.com/p/corkami/wiki/ELF101
% - http://jvns.ca/blog/2014/09/06/how-to-read-an-executable/
% - https://linux-audit.com/elf-binaries-on-linux-understanding-and-analysis/
% - https://github.com/cameronswinoga/yabfc/wiki/Generating-executable-files-from-scratch

<<[[main()]] switch HEADTYPE cases(arm)>>=
case H_ELF:	/* elf executable */
    HEADR = rnd(Ehdr32sz+3*Phdr32sz, 16);
    if(INITTEXT == -1)
        INITTEXT = 4096+HEADR;
    if(INITDAT == -1)
        INITDAT = 0;
    if(INITRND == -1)
        INITRND = 4;
    break;
@

<<[[asmb()]] switch HEADTYPE (to position after text) cases(arm)>>=
case H_ELF:
    OFFSET = HEADR+textsize;
    seek(cout, OFFSET, 0);
    break;
@

<<[[asmb()]] switch HEADTYPE (for symbol table generation) cases(arm)>>=
case H_ELF:
    break;
@

<<[[asmb()]] switch HEADTYPE (for header generation) cases(arm)>>=
case H_ELF:
    debug['S'] = 1;			/* symbol table */
    elf32(ARM, ELFDATA2LSB, 0, nil);
    break;
@
% >>


% start text physical address (elf only)
<<global INITTEXTP>>=
long	INITTEXTP = -1; /* text location (physical) */
@

<<[[main()]] last INITXXX adjustments>>=
if (INITTEXTP == -1)
    INITTEXTP = INITTEXT;
@


<<[[main()]] command line processing(arm)>>=
case 'P':
    a = ARGF();
    if(a)
        INITTEXTP = atolwhex(a);
    break;
@
% seems dead?

<<enum _anon_ (linkers/8l/elf.h)>>=
enum {
    Ehdr32sz	= 52,
    Phdr32sz	= 32,
    Shdr32sz	= 40,

    Ehdr64sz	= 64,
    Phdr64sz	= 56,
    Shdr64sz	= 64,
};
@

\subsection{OMach, mac OS}

%https://www.objc.io/issues/6-build-tools/mach-o-executables/
%http://lowlevelbits.org/parse-mach-o-files/

\subsection{PE, Windows}

% windows format, see pe.h in golang/src/libmach/
% exe and dll (.so)

%format, a la xkcd:
%http://i.imgur.com/tnUca.jpg (nice use of color)

%\subsection{COFF}
% common object code file format


\section{Other instructions}

\subsection{Float operations}

% strong connection with the kernel floating port support.
% see bcm/vfp3.c, bcm/fpiarm.c, etc


\subsubsection{Operand kind}

<<[[inopd()]] cases>>=
case D_FREG:
case D_FPCR:
    break;
@

<<[[inopd()]] cases>>=
case D_FCONST:
    a->ieee = malloc(sizeof(Ieee));

    a->ieee->l = p[4] | (p[5]<<8) | (p[6]<<16) | (p[7]<<24);
    a->ieee->h = p[8] | (p[9]<<8) | (p[10]<<16) | (p[11]<<24);
    size += 8;
    break;
@
% >> >> >> >> >> >> >>
% bugfix: there was a bug where it was using NSNAME instead of sizeof(Ieee)
%  but factorizing code with malloc fixed the issue too.


% 8.out.h

<<function ieeedtof>>=
/// main -> objfile -> ldobj -> <>
long
ieeedtof(Ieee *e)
{
    int exp;
    long v;

    if(e->h == 0)
        return 0;
    exp = (e->h>>20) & ((1L<<11)-1L);
    exp -= (1L<<10) - 2L;
    v = (e->h & 0xfffffL) << 3;
    v |= (e->l >> 29) & 0x7L;
    if((e->l >> 28) & 1) {
        v++;
        if(v & 0x800000L) {
            v = (v & 0x7fffffL) >> 1;
            exp++;
        }
    }
    if(exp <= -126 || exp >= 130)
        diag("double fp to single fp overflow");
    v |= ((exp + 126) & 0xffL) << 23;
    v |= e->h & 0x80000000L;
    return v;
}
@
% >> >> >> >>

<<function ieeedtod>>=
/// Dconv -> <>
double
ieeedtod(Ieee *ieeep)
{
    Ieee e;
    double fr;
    int exp;

    if(ieeep->h & (1L<<31)) {
        e.h = ieeep->h & ~(1L<<31);
        e.l = ieeep->l;
        return -ieeedtod(&e);
    }
    if(ieeep->l == 0 && ieeep->h == 0)
        return 0;
    fr = ieeep->l & ((1L<<16)-1L);
    fr /= 1L<<16;
    fr += (ieeep->l>>16) & ((1L<<16)-1L);
    fr /= 1L<<16;
    fr += (ieeep->h & (1L<<20)-1L) | (1L<<20);
    fr /= 1L<<21;
    exp = (ieeep->h>>20) & ((1L<<11)-1L);
    exp -= (1L<<10) - 2L;
    return ldexp(fr, exp);
}
@
% >> >> >> >> >> >> >> >> >>



\subsubsection{Operand class}

<<[[Operand_class]] cases>>=
C_FREG,
C_FCON,
C_FCR,
@

<<[[aclass()]] switch type cases>>=
case D_FREG:
    return C_FREG;
case D_FCONST:
    return C_FCON;
case D_FPCR:
    return C_FCR;
@



<<function immfloat(arm)>>=
static int
immfloat(long v)
{
    return (v & 0xC03) == 0;/* offset will fit in floating-point load/store */
}
@

<<[[Operand_class]] cases, in C_xEXT, float cases>>=
C_FEXT,
C_HFEXT,
@
%bug: must be inside C_xEXT, not after C_LEXT!

<<[[aclass()]] if immfloat for N_EXTERN symbol>>=
if(immfloat(t))
    return immhalf(instoffset)? C_HFEXT : C_FEXT;
@
\t why pass t? why not pass instoffset

<<[[Operand_class]] cases, in C_xAUTO, float cases>>=
C_FAUTO,    /* float insn offset (0 to 0x3fc, word aligned) */
C_HFAUTO,   /* both H and F */
@
%bug: must be inside C_xAUTO, not after C_LAUTO! see long pb vlong.c :)
% with addpool(), WORD d+4(FP), and illegal combination error.

<<[[aclass()]] if immfloat for N_LOCAL or N_PARAM symbol>>=
if(immfloat(t))
    return immhalf(instoffset)? C_HFAUTO : C_FAUTO;
@

<<[[Operand_class]] cases, in C_xOREG, float cases>>=
C_FOREG,
C_HFOREG,
@


<<[[aclass()]] if immfloat for N_NONE symbol>>=
if(immfloat(t))
    return immhalf(instoffset)? C_HFOREG : C_FOREG;
    /* n.b. that [C_FOREG] will also satisfy immrot */
@
%pad: I rewritten the code to aspectize the floating aspect

\subsubsection{VFP}


<<[[Optab_flag]] cases>>=
VFP     = 1<<4, /* arm vfpv3 floating point */
@
% >> >>
%http://www.arm.com/products/processors/technologies/vector-floating-point.php

% from 8l(1) "Without this [-f] option, 5l generates arm7500 floating-point
% instructions which are emulated in the kernel."

<<[[ocmp()]] if floating point flag on p1 or p2>>=
n = (p2->flag&VFP) - (p1->flag&VFP);	/* floating point arch */
if(n)
    return n;
@

<<global vfp(arm)>>=
bool vfp;
@



<<[[buildop()]] initialize flags>>=
vfp = debug['f'];
@

<<[[buildop()]] adjust optab if flags, remove certain rules>>=
if((optab[n].flag & VFP) && !vfp)
    optab[n].as = AXXX;
@






<<[[ldobj()]] locals(arm)>>=
Prog *t;
@

<<global literal(arm)>>=
char	literal[32];
@

<<[[ldobj()]] switch opcode cases(arm)>>=
case AMOVDF:
    if(!vfp || p->from.type != D_FCONST)
        goto casedef;
    p->as = AMOVF;
    /* fall through */
case AMOVF:
    if(skip)
        goto casedef;

    if(p->from.type == D_FCONST && chipfloat(p->from.ieee) < 0) {
        /* size sb 9 max */
        sprint(literal, "$%lux", ieeedtof(p->from.ieee));
        s = lookup(literal, 0);
        if(s->type == 0) {
            s->type = SBSS;
            s->value = 4;
            t = prg();
            t->as = ADATA;
            t->line = p->line;
            t->from.type = D_OREG;
            t->from.sym = s;
            t->from.symkind = N_EXTERN;
            t->reg = 4;
            t->to = p->from;
            t->link = datap;
            datap = t;
        }
        p->from.type = D_OREG;
        p->from.sym = s;
        p->from.symkind = N_EXTERN;
        p->from.offset = 0;
    }
    goto casedef;

case AMOVD:
    if(skip)
        goto casedef;

    if(p->from.type == D_FCONST && chipfloat(p->from.ieee) < 0) {
        /* size sb 18 max */
        sprint(literal, "$%lux.%lux",
            p->from.ieee->l, p->from.ieee->h);
        s = lookup(literal, 0);
        if(s->type == 0) {
            s->type = SBSS;
            s->value = 8;
            t = prg();
            t->as = ADATA;
            t->line = p->line;
            t->from.type = D_OREG;
            t->from.sym = s;
            t->from.symkind = N_EXTERN;
            t->reg = 8;
            t->to = p->from;
            t->link = datap;
            datap = t;
        }
        p->from.type = D_OREG;
        p->from.sym = s;
        p->from.symkind = N_EXTERN;
        p->from.offset = 0;
    }
    goto casedef;
@


<<global chipfloats(arm)>>=
static Ieee chipfloats[] = {
    {0x00000000, 0x00000000}, /* 0 */
    {0x00000000, 0x3ff00000}, /* 1 */
    {0x00000000, 0x40000000}, /* 2 */
    {0x00000000, 0x40080000}, /* 3 */
    {0x00000000, 0x40100000}, /* 4 */
    {0x00000000, 0x40140000}, /* 5 */
    {0x00000000, 0x3fe00000}, /* .5 */
    {0x00000000, 0x40240000}, /* 10 */
};
@
% ???

<<function chipfloat(arm)>>=
int
chipfloat(Ieee *e)
{
    Ieee *p;
    int n;

    if(vfp)
        return -1;
    for(n = sizeof(chipfloats)/sizeof(chipfloats[0]); --n >= 0;){
        p = &chipfloats[n];
        if(p->l == e->l && p->h == e->h)
            return n;
    }
    return -1;
}
@






<<[[noops()]] second pass switch opcode cases>>=
/*
 * 5c code generation for unsigned -> double made the
 * unfortunate assumption that single and double floating
 * point registers are aliased - true for emulated 7500
 * but not for vfp.  Now corrected, but this test is
 * insurance against old 5c compiled code in libraries.
 */
case AMOVWD:
    if((q = p->link) != P && q->as == ACMP)
     if((q = q->link) != P && q->as == AMOVF)
      if((q1 = q->link) != P && q1->as == AADDF)
       if(q1->to.type == D_FREG && q1->to.reg == p->to.reg) {
        q1->as = AADDD;
        q1 = prg();
        q1->scond = q->scond;
        q1->line = q->line;
        q1->as = AMOVFD;
        q1->from = q->to;
        q1->to = q1->from;
        q1->link = q->link;
        q->link = q1;
    }
    break;
@


<<[[datblk()]] other locals>>=
long fl;
@

<<[[datblk()]] switch type of destination cases>>=
case D_FCONST:
    switch(c) {
    default:
    case 4:
        fl = ieeedtof(p->to.ieee);
        cast = (char*)&fl;
        for(; i<c; i++) {
            buf.dbuf[l] = cast[fnuxi4[i]];
            l++;
        }
        break;
    case 8:
        cast = (char*)p->to.ieee;
        for(; i<c; i++) {
            buf.dbuf[l] = cast[fnuxi8[i]];
            l++;
        }
        break;
    }
    break;
@

<<global fnuxi4>>=
char	fnuxi4[4];
@

<<global fnuxi8>>=
char	fnuxi8[8];
@

<<[[nuxiinit()]] in loop i, fnuxi initialisation>>=
fnuxi4[i] = c;
if(debug['d'] == 0){
    fnuxi8[i] = c;
    fnuxi8[i+4] = c+4;
}
else{
    fnuxi8[i] = c+4; /* ms word first, then ls, even in little endian mode */
    fnuxi8[i+4] = c;
}
@

\subsubsection{Common float instructions}


<<[[buildop()]] switch opcode r for ranges cases>>=
case AADDF:
    oprange[AADDD] = oprange[r];
    oprange[ASUBF] = oprange[r];
    oprange[ASUBD] = oprange[r];
    oprange[AMULF] = oprange[r];
    oprange[AMULD] = oprange[r];
    oprange[ADIVF] = oprange[r];
    oprange[ADIVD] = oprange[r];
    oprange[AMOVFD] = oprange[r];
    oprange[AMOVDF] = oprange[r];
    break;
    
case ACMPF:
    oprange[ACMPD] = oprange[r];
    break;

case AMOVF:
    oprange[AMOVD] = oprange[r];
    break;

case AMOVFW:
    oprange[AMOVWF] = oprange[r];
    oprange[AMOVWD] = oprange[r];
    oprange[AMOVDW] = oprange[r];
    break;
@

<<[[optab]] entries>>=
{ AMOVF,	C_FREG,	C_NONE,	C_FEXT,		50, 4, REGSB },
{ AMOVF,	C_FREG,	C_NONE,	C_FAUTO,	50, 4, REGSP },
{ AMOVF,	C_FREG,	C_NONE,	C_FOREG,	50, 4, 0 },

{ AMOVF,	C_FEXT,	C_NONE,	C_FREG,		51, 4, REGSB },
{ AMOVF,	C_FAUTO,C_NONE,	C_FREG,		51, 4, REGSP },
{ AMOVF,	C_FOREG,C_NONE,	C_FREG,		51, 4, 0 },

{ AMOVF,	C_FREG,	C_NONE,	C_LEXT,		52, 12, REGSB,	LTO },
{ AMOVF,	C_FREG,	C_NONE,	C_LAUTO,	52, 12, REGSP,	LTO },
{ AMOVF,	C_FREG,	C_NONE,	C_LOREG,	52, 12, 0,	LTO },

{ AMOVF,	C_LEXT,	C_NONE,	C_FREG,		53, 12, REGSB,	LFROM },
{ AMOVF,	C_LAUTO,C_NONE,	C_FREG,		53, 12, REGSP,	LFROM },
{ AMOVF,	C_LOREG,C_NONE,	C_FREG,		53, 12, 0,	LFROM },

{ AMOVF,	C_FREG,	C_NONE,	C_ADDR,		68, 8, 0,	LTO },
{ AMOVF,	C_ADDR,	C_NONE,	C_FREG,		69, 8, 0,	LFROM },

{ AADDF,	C_FREG,	C_NONE,	C_FREG,		54, 4, 0 },
{ AADDF,	C_FREG,	C_REG,	C_FREG,		54, 4, 0 },
{ AADDF,	C_FCON,	C_NONE,	C_FREG,		54, 4, 0 },
{ AADDF,	C_FCON,	C_REG,	C_FREG,		54, 4, 0 },
{ AMOVF,	C_FCON,	C_NONE,	C_FREG,		54, 4, 0 },
{ AMOVF,	C_FREG, C_NONE, C_FREG,		54, 4, 0 },

{ ACMPF,	C_FREG,	C_REG,	C_NONE,		54, 4, 0 },
{ ACMPF,	C_FCON,	C_REG,	C_NONE,		54, 4, 0 },

{ AMOVFW,	C_FREG,	C_NONE,	C_REG,		55, 4, 0 },
{ AMOVFW,	C_REG,	C_NONE,	C_FREG,		55, 4, 0 },
@



<<function regoff(arm)>>=
long
regoff(Adr *a)
{

    instoffset = 0;
    aclass(a);
    return instoffset;
}
@

<<[[asmout()]] switch on type cases>>=
case 50:	/* floating point store */
    v = regoff(&p->to);
    r = p->to.reg;
    <<[[asmout()]] adjust maybe r to rule param>>
    o1 = ofsr(p->as, p->from.reg, v, r, p->scond, p);
    break;
@

%STC 6 << 25
<<function ofsr(arm)>>=
long
ofsr(int a, int r, long v, int b, int sc, Prog *p)
{
    long o;

    if(vfp)
        return ovfpmem(a, r, v, b, sc, p);

    o = (sc & C_SCOND) << 28;
    if(sc & C_SBIT)
        diag(".S on FLDR/FSTR instruction");
    if(!(sc & C_PBIT))
        o |= 1 << 24;
    if(sc & C_WBIT)
        o |= 1 << 21;
    o |= (6<<25) | (1<<24) | (1<<23);
    if(v < 0) {
        v = -v;
        o ^= 1 << 23;
    }
    if(v & 3)
        diag("odd offset for floating point op: %ld\n%P", v, p);
    else if(v >= (1<<10))
        diag("literal span too large: %ld\n%P", v, p);
    o |= (v>>2) & 0xFF;
    o |= b << 16;
    o |= r << 12;
    o |= 1 << 8;

    switch(a) {
    default:
        diag("bad fst %A", a);
    case AMOVD:
        o |= 1<<15;
    case AMOVF:
        break;
    }
    return o;
}
@
% >> >> >> >> >> >> >> >> >> >> >>



% LDC, 6 << 25 and 1 << 20
<<[[asmout()]] switch on type cases>>=
case 51:	/* floating point load */
    v = regoff(&p->from);
    r = p->from.reg;
    <<[[asmout()]] adjust maybe r to rule param>>
    o1 = ofsr(p->as, p->to.reg, v, r, p->scond, p) | (1<<20);
    break;
@
% >>


% ADD ... STC
<<[[asmout()]] switch on type cases>>=
case 52:	/* floating point store, long offset UGLY */
    o1 = omvl(p, &p->to, REGTMP);
    if(!o1)
        break;
    r = p->to.reg;
    <<[[asmout()]] adjust maybe r to rule param>>
    o2 = oprrr(AADD, p->scond) | (REGTMP << 12) | (REGTMP << 16) | r;
    o3 = ofsr(p->as, p->from.reg, 0, REGTMP, p->scond, p);
    break;
@
% >> >> >>

% ADD ... LTC
<<[[asmout()]] switch on type cases>>=
case 53:	/* floating point load, long offset UGLY */
    o1 = omvl(p, &p->from, REGTMP);
    if(!o1)
        break;
    r = p->from.reg;
    <<[[asmout()]] adjust maybe r to rule param>>
    o2 = oprrr(AADD, p->scond) | (REGTMP << 12) | (REGTMP << 16) | r;
    o3 = ofsr(p->as, p->to.reg, 0, REGTMP, p->scond, p) | (1<<20);
    break;
@
% >> >> >>


\subsubsection{Old ARM 7500 floating point}

% why rely on kernel? kernel does not seem to use the coprocessor
% but emulate the instructions with fpiadd, fpimul, etc. so why
% not do that directly in the generated code and rely on libc to
% do that instead of the kernel??

<<[[oprrr()]] switch cases>>=
/* old arm 7500 fp using coprocessor 1 (1<<8) */
case AADDD:	return o | (0xe<<24) | (0x0<<20) | (1<<8) | (1<<7);
case AADDF:	return o | (0xe<<24) | (0x0<<20) | (1<<8);
case AMULD:	return o | (0xe<<24) | (0x1<<20) | (1<<8) | (1<<7);
case AMULF:	return o | (0xe<<24) | (0x1<<20) | (1<<8);
case ASUBD:	return o | (0xe<<24) | (0x2<<20) | (1<<8) | (1<<7);
case ASUBF:	return o | (0xe<<24) | (0x2<<20) | (1<<8);
case ADIVD:	return o | (0xe<<24) | (0x4<<20) | (1<<8) | (1<<7);
case ADIVF:	return o | (0xe<<24) | (0x4<<20) | (1<<8);
/* arguably, ACMPF should expand to RNDF, CMPD */
case ACMPD:
case ACMPF:	return o | (0xe<<24) | (0x9<<20) | (0xF<<12) | (1<<8) | (1<<4);	

case AMOVF:
case AMOVDF:	return o | (0xe<<24) | (0x0<<20) | (1<<15) | (1<<8);
case AMOVD:
case AMOVFD:	return o | (0xe<<24) | (0x0<<20) | (1<<15) | (1<<8) | (1<<7);

case AMOVWF:	return o | (0xe<<24) | (0<<20) | (1<<8) | (1<<4);
case AMOVWD:	return o | (0xe<<24) | (0<<20) | (1<<8) | (1<<4) | (1<<7);
case AMOVFW:	return o | (0xe<<24) | (1<<20) | (1<<8) | (1<<4);
case AMOVDW:	return o | (0xe<<24) | (1<<20) | (1<<8) | (1<<4) | (1<<7);
@
% >> >> >> >> >> >> >> >> >> >> >> >> >>
% >> >> >> >> >> >> >> >> >> >> >> >> >>
% >> >> >> >> >> >> >> >> >> >> >> >> >>
% >> >> >> >> >> >> >> >> >> >> >> >> >>
% >> >> >> >> >> >> >> >> >> >> >> >> >>
% >> >> >> >> >> >> >> >> >> >> >> >> >>
% 0xe << 24 => CDP instr, 1 << 8 => co processor 1




<<[[asmout()]] switch on type cases>>=
case 54:	/* floating point arith */
    o1 = oprrr(p->as, p->scond);
    if(p->from.type == D_FCONST) {
        rf = chipfloat(p->from.ieee);
        if(rf < 0){
            diag("invalid floating-point immediate\n%P", p);
            rf = 0;
        }
        rf |= (1<<3);
    } else
        rf = p->from.reg;
    rt = p->to.reg;
    r = p->reg;
    if(p->to.type == D_NONE)
        rt = 0;	/* CMP[FD] */
    else if(o1 & (1<<15))
        r = 0;	/* monadic */
    else 
      <<[[asmout()]] adjust [[r]]>>
    o1 |= rf | (r<<16) | (rt<<12);
    break;
@
% >> >> >> >> >>

<<[[asmout()]] switch on type cases>>=
case 55:	/* floating point fix and float */
    o1 = oprrr(p->as, p->scond);
    rf = p->from.reg;
    rt = p->to.reg;
    if(p->to.type == D_NONE){
        rt = 0;
        diag("to.type==D_NONE (asm/fp)");
    }
    if(p->from.type == D_REG)
        o1 |= (rf<<12) | (rt<<16);
    else
        o1 |= rf | (rt<<12);
    break;
@
% >> >> >> >>



<<[[asmout()]] switch on type cases>>=
case 68:	/* floating point store -> ADDR */
    o1 = omvl(p, &p->to, REGTMP);
    if(!o1)
        break;
    o2 = ofsr(p->as, p->from.reg, 0, REGTMP, p->scond, p);
    break;
@
<<[[asmout()]] switch on type cases>>=
case 69:	/* floating point load <- ADDR */
    o1 = omvl(p, &p->from, REGTMP);
    if(!o1)
        break;
    o2 = ofsr(p->as, p->to.reg, 0, REGTMP, p->scond, p) | (1<<20);
    break;
@
% >> >> >>

%\subsubsection{Kernel emulation}

<<[[optab]] entries>>=
{ AMOVW,	C_REG,	C_NONE,	C_FCR,		56, 4 },
{ AMOVW,	C_FCR,	C_NONE,	C_REG,		57, 4 },
@

<<[[asmout()]] switch on type cases>>=
/* old arm 7500 fp using coprocessor 1 (1<<8) */
case 56:	/* move to FP[CS]R */
    o1 = ((p->scond & C_SCOND) << 28) | (0xe << 24) | (1<<8) | (1<<4);
    o1 |= ((p->to.reg+1)<<21) | (p->from.reg << 12);
    break;
@
% >> >> >> >> >> >> >>
<<[[asmout()]] switch on type cases>>=
case 57:	/* move from FP[CS]R */
    o1 = ((p->scond & C_SCOND) << 28) | (0xe << 24) | (1<<8) | (1<<4);
    o1 |= ((p->from.reg+1)<<21) | (p->to.reg<<12) | (1<<20);
    break;
@
% >> >> >> >> >> >> >> >

\subsubsection{VFP hardware instructions, [[5l -f]]}

%from bcm/arm.h
%#define CpOFPA		1			/* ancient 7500 FPA */
% => use coprocessor 1

% "without -f 5l generates arm7500 floating-point
% instructions which are emulated in the kernel."

% see bcm/fpiarm.c


<<function ovfpmem(arm)>>=
long
ovfpmem(int a, int r, long v, int b, int sc, Prog *p)
{
    long o;

    o = (sc & C_SCOND) << 28;
    if(sc & (C_SBIT|C_PBIT|C_WBIT))
        diag(".S/.P/.W on VLDR/VSTR instruction");
    o |= 0xd<<24 | (1<<23);
    if(v < 0) {
        v = -v;
        o ^= 1 << 23;
    }
    if(v & 3)
        diag("odd offset for floating point op: %ld\n%P", v, p);
    else if(v >= (1<<10))
        diag("literal span too large: %ld\n%P", v, p);
    o |= (v>>2) & 0xFF;
    o |= b << 16;
    o |= r << 12;
    switch(a) {
    default:
        diag("bad fst %A", a);
    case AMOVD:
        o |= 0xb<<8;
        break;
    case AMOVF:
        o |= 0xa<<8;
        break;
    }
    return o;
}
@
% >> >> >> >> >> >> >> >> 




<<[[optab]] entries>>=
{ AADDF,	C_FREG,	C_NONE,	C_FREG,		74, 4, 0, VFP },
{ AADDF,	C_FREG,	C_REG,	C_FREG,		74, 4, 0, VFP },
{ AMOVF,	C_FREG, C_NONE, C_FREG,		74, 4, 0, VFP },
{ ACMPF,	C_FREG,	C_REG,	C_NONE,		75, 8, 0, VFP },
{ ACMPF,	C_FCON,	C_REG,	C_NONE,		75, 8, 0, VFP },
{ AMOVFW,	C_FREG,	C_NONE,	C_REG,		76, 8, 0, VFP },
{ AMOVFW,	C_REG,	C_NONE,	C_FREG,		76, 8, 0, VFP },
@
% remember those are ranges!

<<[[asmout()]] switch on type cases>>=
/* VFP ops: */
case 74:	/* vfp floating point arith */
    o1 = opvfprrr(p->as, p->scond);
    rf = p->from.reg;
    if(p->from.type == D_FCONST) {
        diag("invalid floating-point immediate\n%P", p);
        rf = 0;
    }
    rt = p->to.reg;
    r = p->reg;
    <<[[asmout()]] adjust [[r]]>>
    o1 |= rt<<12;
    if(((o1>>20)&0xf) == 0xb)
        o1 |= rf<<0;
    else
        o1 |= r<<16 | rf<<0;
    break;
@
% >> >> >>

<<[[asmout()]] switch on type cases>>=
case 75:	/* vfp floating point compare */
    o1 = opvfprrr(p->as, p->scond);
    rf = p->from.reg;
    if(p->from.type == D_FCONST) {
        if(p->from.ieee->h != 0 || p->from.ieee->l != 0)
            diag("invalid floating-point immediate\n%P", p);
        o1 |= 1<<16;
        rf = 0;
    }
    rt = p->reg;
    o1 |= rt<<12 | rf<<0;
    o2 = 0x0ef1fa10;	/* MRS APSR_nzcv, FPSCR */
    o2 |= (p->scond & C_SCOND) << 28;
    break;
@
% >> >> >> >>

<<[[asmout()]] switch on type cases>>=
case 76:	/* vfp floating point fix and float */
    o1 = opvfprrr(p->as, p->scond);
    rf = p->from.reg;
    rt = p->to.reg;
    if(p->from.type == D_REG) {
        o2 = o1 | rt<<12 | rt<<0;
        o1 = 0x0e000a10;	/* VMOV F,R */
        o1 |= (p->scond & C_SCOND) << 28 | rt<<16 | rf<<12;
    } else {
        o1 |= FREGTMP<<12 | rf<<0;
        o2 = 0x0e100a10;	/* VMOV R,F */
        o2 |= (p->scond & C_SCOND) << 28 | FREGTMP<<16 | rt<<12;
    }
    break;
@
%$
% >> >> >> >> >> >> >> >> >> >>



<<function opvfprrr(arm)>>=
long
opvfprrr(int a, int sc)
{
    long o;

    o = (sc & C_SCOND) << 28;
    if(sc & (C_SBIT|C_PBIT|C_WBIT))
        diag(".S/.P/.W on vfp instruction");
    o |= 0xe<<24;
    switch(a) {
    case AMOVWD:	return o | 0xb<<8 | 0xb<<20 | 1<<6 | 0x8<<16 | 1<<7;
    case AMOVWF:	return o | 0xa<<8 | 0xb<<20 | 1<<6 | 0x8<<16 | 1<<7;
    case AMOVDW:	return o | 0xb<<8 | 0xb<<20 | 1<<6 | 0xD<<16 | 1<<7;
    case AMOVFW:	return o | 0xa<<8 | 0xb<<20 | 1<<6 | 0xD<<16 | 1<<7;
    case AMOVFD:	return o | 0xa<<8 | 0xb<<20 | 1<<6 | 0x7<<16 | 1<<7;
    case AMOVDF:	return o | 0xb<<8 | 0xb<<20 | 1<<6 | 0x7<<16 | 1<<7;
    case AMOVF:	return o | 0xa<<8 | 0xb<<20 | 1<<6 | 0x0<<16 | 0<<7;
    case AMOVD:	return o | 0xb<<8 | 0xb<<20 | 1<<6 | 0x0<<16 | 0<<7;
    case ACMPF:	return o | 0xa<<8 | 0xb<<20 | 1<<6 | 0x4<<16 | 0<<7;
    case ACMPD:	return o | 0xb<<8 | 0xb<<20 | 1<<6 | 0x4<<16 | 0<<7;
    case AADDF:	return o | 0xa<<8 | 0x3<<20;
    case AADDD:	return o | 0xb<<8 | 0x3<<20;
    case ASUBF:	return o | 0xa<<8 | 0x3<<20 | 1<<6;
    case ASUBD:	return o | 0xb<<8 | 0x3<<20 | 1<<6;
    case AMULF:	return o | 0xa<<8 | 0x2<<20;
    case AMULD:	return o | 0xb<<8 | 0x2<<20;
    case ADIVF:	return o | 0xa<<8 | 0x8<<20;
    case ADIVD:	return o | 0xb<<8 | 0x8<<20;
    }
    diag("bad vfp rrr %d", a);
    prasm(curp);
    return 0;
}
@
% >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >>
% >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >>
% >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >>
% >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >>



\subsection{Division}
\label{sec:div-mod}
\n could have a div.c, but right now abuse in noop.c

% like for floats, different options

% how do compilers optimize the division:
%https://zneak.github.io/fcd/2017/02/19/divisions.html

\subsubsection{[[ADIV]] rewriting}

%    /* MOV a,4(SP) */
%    /* MOV b,REGTMP */
%    /* CALL appropriate */
%    /* MOV REGTMP, b */
%    /* ADD $8,SP */
%q1
%    /* SUB $8,SP */

<<[[noops()]] second pass switch opcode cases>>=
case ADIV:
case ADIVU:
case AMOD:
case AMODU:
    <<[[noops()]] second pass, ADIV rewrite, case ADIV and so on, if -M>>
    if(p->from.type != D_REG)
        break;
    if(p->to.type != D_REG)
        break;
    // else
    q1 = p;

    q = prg();
    q->link = p->link;
    p->link = q;
    p = q;

    /* MOV a,4(SP) */
    p->as = AMOVW;
    p->line = q1->line;
    p->from.type = D_REG;
    p->from.reg = q1->from.reg;
    p->to.type = D_OREG;
    p->to.reg = REGSP;
    p->to.offset = 4;

    q = prg();
    q->link = p->link;
    p->link = q;
    p = q;

    /* MOV b,REGTMP */
    p->as = AMOVW;
    p->line = q1->line;
    p->from.type = D_REG;
    p->from.reg = q1->reg;
    if(q1->reg == R_NONE)
        p->from.reg = q1->to.reg;
    p->to.type = D_REG;
    p->to.reg = REGTMP;
    p->to.offset = 0;

    q = prg();
    q->link = p->link;
    p->link = q;
    p = q;

    /* CALL appropriate */
    p->as = ABL;
    p->line = q1->line;
    p->to.type = D_BRANCH;
    p->cond = p;
    switch(o) {
    case ADIV:
        p->cond = prog_div;
        p->to.sym = sym_div;
        break;
    case ADIVU:
        p->cond = prog_divu;
        p->to.sym = sym_divu;
        break;
    case AMOD:
        p->cond = prog_mod;
        p->to.sym = sym_mod;
        break;
    case AMODU:
        p->cond = prog_modu;
        p->to.sym = sym_modu;
        break;
    }

    q = prg();
    q->link = p->link;
    p->link = q;
    p = q;

    /* MOV REGTMP, b */
    p->as = AMOVW;
    p->line = q1->line;
    p->from.type = D_REG;
    p->from.reg = REGTMP;
    p->from.offset = 0;
    p->to.type = D_REG;
    p->to.reg = q1->to.reg;

    q = prg();
    q->link = p->link;
    p->link = q;
    p = q;

    /* ADD $8,SP */
    p->as = AADD;
    p->from.type = D_CONST;
    p->from.reg = R_NONE;
    p->from.offset = 8;
    p->reg = R_NONE;
    p->to.type = D_REG;
    p->to.reg = REGSP;

    /* SUB $8,SP */
    q1->as = ASUB;
    q1->from.type = D_CONST;
    q1->from.offset = 8;
    q1->from.reg = R_NONE;
    q1->reg = R_NONE;
    q1->to.type = D_REG;
    q1->to.reg = REGSP;
    break;
@

% for -M, in 8l(1):
% "Generate instructions rather than calls to emulation routines
% for multiply and divide."

<<global prog_div(arm)>>=
Prog*	prog_div;
@

<<global prog_divu(arm)>>=
Prog*	prog_divu;
@

<<global prog_mod(arm)>>=
Prog*	prog_mod;
@

<<global prog_modu(arm)>>=
Prog*	prog_modu;
@


\subsubsection{[[initdiv()]]}

<<global sym_div(arm)>>=
static	Sym*	sym_div;
@

<<global sym_divu(arm)>>=
static	Sym*	sym_divu;
@

<<global sym_mod(arm)>>=
static	Sym*	sym_mod;
@

<<global sym_modu(arm)>>=
static	Sym*	sym_modu;
@


<<constant SIGNINTERN(arm)>>=
#define SIGNINTERN  (1729*325*1729)
@

<<function sigdiv(arm)>>=
static void
sigdiv(char *n)
{
    Sym *s;

    s = lookup(n, 0);
    if(s->type == STEXT){
        if(s->sig == 0)
            s->sig = SIGNINTERN;
    }
    else if(s->type == SNONE || s->type == SXREF)
        s->type = SUNDEF;
}
@

<<function divsig(arm)>>=
void
divsig(void)
{
    sigdiv("_div");
    sigdiv("_divu");
    sigdiv("_mod");
    sigdiv("_modu");
}
@

<<function sdiv(arm)>>=
static void
sdiv(Sym *s)
{
    if(s->type == SNONE || s->type == SXREF){
        /* undefsym(s); */
        s->type = SXREF;
        if(s->sig == 0)
            s->sig = SIGNINTERN;
        s->subtype = SIMPORT;
    }
    else if(s->type != STEXT)
        diag("undefined: %s", s->name);
}
@

<<function initdiv(arm)>>=
void
initdiv(void)
{
    Sym *s2, *s3, *s4, *s5;
    Prog *p;

    if(prog_div != P)
        return;
    sym_div = s2 = lookup("_div", 0);
    sym_divu = s3 = lookup("_divu", 0);
    sym_mod = s4 = lookup("_mod", 0);
    sym_modu = s5 = lookup("_modu", 0);
    if(dlm) {
        sdiv(s2); if(s2->type == SXREF) prog_div = UP;
        sdiv(s3); if(s3->type == SXREF) prog_divu = UP;
        sdiv(s4); if(s4->type == SXREF) prog_mod = UP;
        sdiv(s5); if(s5->type == SXREF) prog_modu = UP;
    }
    for(p = firstp; p != P; p = p->link)
        if(p->as == ATEXT) {
            if(p->from.sym == s2)
                prog_div = p;
            if(p->from.sym == s3)
                prog_divu = p;
            if(p->from.sym == s4)
                prog_mod = p;
            if(p->from.sym == s5)
                prog_modu = p;
        }
    if(prog_div == P) {
        diag("undefined: %s", s2->name);
        prog_div = curtext;
    }
    if(prog_divu == P) {
        diag("undefined: %s", s3->name);
        prog_divu = curtext;
    }
    if(prog_mod == P) {
        diag("undefined: %s", s4->name);
        prog_mod = curtext;
    }
    if(prog_modu == P) {
        diag("undefined: %s", s5->name);
        prog_modu = curtext;
    }
}
@




<<[[noops()]] first pass switch opcode cases>>=
case ADIV:
case ADIVU:
case AMOD:
case AMODU:
    if(prog_div == P)
        initdiv();
    if(curtext != P)
        curtext->mark &= ~LEAF;
    continue; // no q = p;
@
% a bit ugly to do the initdiv here? at the same it's related to
% this notion of NOOP.


\subsubsection{Kernel emulation, [[5l -M]]}
% can access coprocessor from regular programs? so need syscall for float op?
% argh.

<<[[noops()]] second pass, ADIV rewrite, case ADIV and so on, if -M>>=
if(debug['M'])
    break;
@
% if -M then break in noops and so does not rewrite the ADIV
% and so the code below becomes reachable

<<[[buildop()]] switch opcode r for ranges cases>>=
case ADIV:
    oprange[AMOD] = oprange[r];
    oprange[AMODU] = oprange[r];
    oprange[ADIVU] = oprange[r];
    break;
@

<<[[optab]] entries>>=
{ ADIV,		C_REG,	C_REG,	C_REG,		16, 4 },
{ ADIV,		C_REG,	C_NONE,	C_REG,		16, 4 },
@
% hmm but noops should have rewrite them no? not if used
% also 5l -M

<<[[asmout()]] switch on type cases>>=
case 16:	/* div r,[r,]r */
    o1 = 0xf << 28;
    o2 = 0;
    break;
@
% 0xf? SWI? o2 = 0 ?? illegal instruction? so kernel trap?
% >>
% anyway will not use o2 ... since size is 4
% and how will know the actual register?


\subsection{Long multiplication}
\label{sec:mull}
% in advanced topic, like I did in Assembler.nw


<<[[buildop()]] switch opcode r for ranges cases>>=
case AMULL:
    oprange[AMULA] = oprange[r];
    oprange[AMULAL] = oprange[r];
    oprange[AMULLU] = oprange[r];
    oprange[AMULALU] = oprange[r];
    break;
@

<<[[optab]] entries>>=
{ AMULL,	C_REG,	C_REG,	C_REGREG,	17, 4 },
@

<<[[Operand_class]] cases>>=
C_REGREG,  // D_REGREG
@
<<[[aclass()]] switch type cases>>=
case D_REGREG:
    return C_REGREG;
@


<<[[asmout()]] other locals>>=
int rt2;
@

<<[[asmout()]] switch on type cases>>=
case 17:
    o1 = oprrr(p->as, p->scond);
    rf = p->from.reg;
    rt = p->to.reg;
    rt2 = p->to.offset;
    r = p->reg;
    o1 |= (rf<<8) | r | (rt<<16) | (rt2<<12);
    break;
@
% >> >> >>

<<[[oprrr()]] switch cases>>=
case AMULA:	return o | (0x1<<21) | (0x9<<4);
case AMULLU:	return o | (0x4<<21) | (0x9<<4);
case AMULL:		return o | (0x6<<21) | (0x9<<4);
case AMULALU:	return o | (0x5<<21) | (0x9<<4);
case AMULAL:	return o | (0x7<<21) | (0x9<<4);
@
% >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >>
% >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >> >>




\subsection{Multiple registers move}
\label{sec:movm}

% used by RFE

<<[[buildop()]] switch opcode r for ranges cases>>=
case AMOVM:
    break;
@

<<[[optab]] entries>>=
{ AMOVM,	C_LCON,	C_NONE,	C_SOREG,	38, 4 },
{ AMOVM,	C_SOREG,C_NONE,	C_LCON,		39, 4 },
@

<<[[asmout()]] switch on type cases>>=
case 38:	/* movm $con,oreg -> stm */
    o1 = (0x4 << 25);
    o1 |= p->from.offset & 0xffff;
    o1 |= p->to.reg << 16;
    aclass(&p->to);
    goto movm;
@
%$

<<[[asmout()]] switch on type cases>>=
case 39:	/* movm oreg,$con -> ldm */
    o1 = (0x4 << 25) | (1 << 20);
    o1 |= p->to.offset & 0xffff;
    o1 |= p->from.reg << 16;
    aclass(&p->from);
movm:
    if(instoffset != 0)
        diag("offset must be zero in MOVM");
    o1 |= (p->scond & C_SCOND) << 28;
    if(p->scond & C_PBIT)
        o1 |= 1 << 24;
    if(p->scond & C_UBIT)
        o1 |= 1 << 23;
    if(p->scond & C_SBIT)
        o1 |= 1 << 22;
    if(p->scond & C_WBIT)
        o1 |= 1 << 21;
    break;
@
%$


\subsection{Status register}

<<[[optab]] entries>>=
{ AMOVW,	C_PSR,	C_NONE,	C_REG,		35, 4 },
{ AMOVW,	C_REG,	C_NONE,	C_PSR,		36, 4 },
{ AMOVW,	C_RCON,	C_NONE,	C_PSR,		37, 4 },
@

<<[[Operand_class]] cases>>=
C_PSR,     // D_PSR
@
<<[[aclass()]] switch type cases>>=
case D_PSR:
    return C_PSR;
@

<<[[asmout()]] switch on type cases>>=
case 35:	/* mov PSR,R */
    o1 = (2<<23) | (0xf<<16) | (0<<0);
    o1 |= (p->scond & C_SCOND) << 28;
    o1 |= (p->from.reg & 1) << 22;
    o1 |= p->to.reg << 12;
    break;
@
<<[[asmout()]] switch on type cases>>=
case 36:	/* mov R,PSR */
    o1 = (2<<23) | (0x29f<<12) | (0<<4);
    if(p->scond & C_FBIT)
        o1 ^= 0x010 << 12;
    o1 |= (p->scond & C_SCOND) << 28;
    o1 |= (p->to.reg & 1) << 22;
    o1 |= p->from.reg << 0;
    break;
@

<<[[asmout()]] switch on type cases>>=
case 37:	/* mov $con,PSR */
    aclass(&p->from);
    o1 = (2<<23) | (0x29f<<12) | (0<<4);
    if(p->scond & C_FBIT)
        o1 ^= 0x010 << 12;
    o1 |= (p->scond & C_SCOND) << 28;
    o1 |= immrot(instoffset);
    o1 |= (p->to.reg & 1) << 22;
    o1 |= p->from.reg << 0;
    break;
@
%$

\subsection{Half words and bytes moves since ARMv4}
\label{sec:armv4}

% saw section X virtual instr.

<<global armv4(arm)>>=
bool	armv4;
@
<<[[buildop()]] initialize flags>>=
armv4 = !debug['h'];
@
% on by default

<<[[Optab_flag]] cases>>=
V4      = 1<<3, /* arm v4 arch */
@
% >>

<<[[buildop()]] adjust optab if flags, remove certain rules>>=
if((optab[n].flag & V4) && !armv4) {
    optab[n].as = AXXX;
    break;
}
@

<<[[ocmp()]] if v4 flag on p1 or p2>>=
n = (p2->flag&V4) - (p1->flag&V4);	/* architecture version */
if(n)
    return n;
@
% so V4 rules first, so C_LEXT of v4 has prio over C_LEXT of non v4





<<[[Operand_class]] cases, in C_xEXT, half case>>=
C_HEXT,
@
% why that? because since ARMv4 other instr, and use 8 bits
% to encode offset

<<[[aclass()]] if immhalf for N_EXTERN symbol>>=
if(immhalf(instoffset))
    return C_HEXT;
@

<<[[cmp()]] switch on a, the operand class in optab rule, cases>>=
case C_HFEXT:
    return b == C_HEXT || b == C_FEXT;
case C_FEXT:
case C_HEXT:
    return b == C_HFEXT;
@


<<[[Operand_class]] cases, in C_xAUTO, half case>>=
C_HAUTO,    /* halfword insn offset (-0xff to 0xff) */
@

<<[[cmp()]] switch on a, the operand class in optab rule, cases>>=
case C_HFAUTO:
    return b == C_HAUTO || b == C_FAUTO;
case C_FAUTO:
case C_HAUTO:
    return b == C_HFAUTO;
@

<<[[aclass()]] if immhalf for N_LOCAL or N_PARAM symbol>>=
if(immhalf(instoffset))
    return C_HAUTO;
@




<<[[Operand_class]] cases, in C_xOREG, half case>>=
C_HOREG,
@

<<[[aclass()]] if immhalf for N_NONE symbol>>=
 /* n.b. that immhalf() will also satisfy immrot */
if(immhalf(instoffset))	
    return C_HOREG;
@


<<[[cmp()]] switch on a, the operand class in optab rule, cases>>=
case C_HFOREG:
    return b == C_HOREG || b == C_FOREG;
case C_FOREG:
case C_HOREG:
    return b == C_HFOREG;
@

%\subsection{Half immediate address, [[immhalf()]]}

<<function immhalf(arm)>>=
static int
immhalf(long v)
{
    if(v >= 0 && v <= 0xff)
        return v |
            (1<<24)  |	/* pre indexing */
            (1<<23);	/* pre indexing, up */
    if(v >= -0xff && v < 0)
        return (-v & 0xff)|
            (1<<24);	/* pre indexing */
    return 0;
}
@
% >> >> >>
% seems identical to immhalf no? no now it's 0xff! not 0xfff







<<[[optab]] entries>>=
{ AMOVH,	C_REG,	C_NONE,	C_HEXT,		70, 4, REGSB,	V4 },
{ AMOVH,	C_REG,	C_NONE, C_HAUTO,	70, 4, REGSP,	V4 },
{ AMOVH,	C_REG,	C_NONE,	C_HOREG,	70, 4, 0,		V4 },

{ AMOVHU,	C_REG,	C_NONE,	C_HEXT,		70, 4, REGSB,	V4 },
{ AMOVHU,	C_REG,	C_NONE, C_HAUTO,	70, 4, REGSP,	V4 },
{ AMOVHU,	C_REG,	C_NONE,	C_HOREG,	70, 4, 0,		V4 },


{ AMOVB,	C_HEXT,	C_NONE, C_REG,		71, 4, REGSB,	V4 },
{ AMOVB,	C_HAUTO,C_NONE,	C_REG,		71, 4, REGSP,	V4 },
{ AMOVB,	C_HOREG,C_NONE,	C_REG,		71, 4, 0,		V4 },

{ AMOVH,	C_HEXT,	C_NONE,	C_REG,		71, 4, REGSB,	V4 },
{ AMOVH,	C_HAUTO,C_NONE, C_REG,		71, 4, REGSP,	V4 },
{ AMOVH,	C_HOREG,C_NONE,	C_REG,		71, 4, 0,		V4 },

{ AMOVHU,	C_HEXT,	C_NONE,	C_REG,		71, 4, REGSB,	V4 },
{ AMOVHU,	C_HAUTO,C_NONE, C_REG,		71, 4, REGSP,	V4 },
{ AMOVHU,	C_HOREG,C_NONE,	C_REG,		71, 4, 0,		V4 },


{ AMOVH,	C_REG,	C_NONE,	C_LEXT,		72, 8, REGSB,	LTO|V4 },
{ AMOVH,	C_REG,	C_NONE, C_LAUTO,	72, 8, REGSP,	LTO|V4 },
{ AMOVH,	C_REG,	C_NONE,	C_LOREG,	72, 8, 0,		LTO|V4 },

{ AMOVHU,	C_REG,	C_NONE,	C_LEXT,		72, 8, REGSB,	LTO|V4 },
{ AMOVHU,	C_REG,	C_NONE, C_LAUTO,	72, 8, REGSP,	LTO|V4 },
{ AMOVHU,	C_REG,	C_NONE,	C_LOREG,	72, 8, 0,		LTO|V4 },


{ AMOVB,	C_LEXT,	C_NONE, C_REG,		73, 8, REGSB,	LFROM|V4 },
{ AMOVB,	C_LAUTO,C_NONE,	C_REG,		73, 8, REGSP,	LFROM|V4 },
{ AMOVB,	C_LOREG,C_NONE,	C_REG,		73, 8, 0,		LFROM|V4 },

{ AMOVH,	C_LEXT,	C_NONE,	C_REG,		73, 8, REGSB,	LFROM|V4 },
{ AMOVH,	C_LAUTO,C_NONE, C_REG,		73, 8, REGSP,	LFROM|V4 },
{ AMOVH,	C_LOREG,C_NONE,	C_REG,		73, 8, 0,		LFROM|V4 },

{ AMOVHU,	C_LEXT,	C_NONE,	C_REG,		73, 8, REGSB,	LFROM|V4 },
{ AMOVHU,	C_LAUTO,C_NONE, C_REG,		73, 8, REGSP,	LFROM|V4 },
{ AMOVHU,	C_LOREG,C_NONE,	C_REG,		73, 8, 0,		LFROM|V4 },
@

<<[[asmout()]] switch on type cases>>=
/* ArmV4 ops: */
case 70:	/* movh/movhu R,O(R) -> strh */
    aclass(&p->to);
    r = p->to.reg;
    <<[[asmout()]] adjust maybe r to rule param>>
    o1 = oshr(p->from.reg, instoffset, r, p->scond);
    break;	
@
<<[[asmout()]] switch on type cases>>=
case 71:	/* movb/movh/movhu O(R),R -> ldrsb/ldrsh/ldrh */
    aclass(&p->from);
    r = p->from.reg;
    <<[[asmout()]] adjust maybe r to rule param>>
    o1 = olhr(instoffset, r, p->to.reg, p->scond);
    if(p->as == AMOVB)
        o1 ^= (1<<5)|(1<<6);
    else if(p->as == AMOVH)
        o1 ^= (1<<6);
    break;
@
% >> >>  >>

<<[[asmout()]] switch on type cases>>=
case 72:	/* movh/movhu R,L(R) -> strh */
    o1 = omvl(p, &p->to, REGTMP);
    if(!o1)
        break;
    r = p->to.reg;
    <<[[asmout()]] adjust maybe r to rule param>>
    o2 = oshrr(p->from.reg, REGTMP,r, p->scond);
    break;	
@

<<[[asmout()]] switch on type cases>>=
case 73:	/* movb/movh/movhu L(R),R -> ldrsb/ldrsh/ldrh */
    o1 = omvl(p, &p->from, REGTMP);
    if(!o1)
        break;
    r = p->from.reg;
    <<[[asmout()]] adjust maybe r to rule param>>
    o2 = olhrr(REGTMP, r, p->to.reg, p->scond);
    if(p->as == AMOVB)
        o2 ^= (1<<5)|(1<<6);
    else if(p->as == AMOVH)
        o2 ^= (1<<6);
    break;
@
% >> >> >>


<<function olhr(arm)>>=
long
olhr(long v, int b, int r, int sc)
{
    long o;

    o = (sc & C_SCOND) << 28;
    if(sc & C_SBIT)
        diag(".S on LDRH/STRH instruction");

    if(!(sc & C_PBIT))
        o |= 1 << 24;
    if(sc & C_WBIT)
        o |= 1 << 21;
    o |= (1<<23) | (1<<20) | (0xb<<4);
    if(v < 0) {
        v = -v;
        o ^= 1 << 23;
    }
    if(v >= (1<<8))
        diag("literal span too large: %ld (R%d)\n%P", v, b, curp);
    o |= (v&0xf)|((v>>4)<<8)|(1<<22);
    o |= b << 16;
    o |= r << 12;
    return o;
}
@
% >> >> >> >> >> >> >> >> >> >> >> >>
%old: was using PP

<<function oshr(arm)>>=
long
oshr(int r, long v, int b, int sc)
{
    long o;

    o = olhr(v, b, r, sc) ^ (1<<20);
    return o;
}
@
% >>



<<function oshrr(arm)>>=
long
oshrr(int r, int i, int b, int sc)
{
    return olhr(i, b, r, sc) ^ ((1<<22) | (1<<20));
}
@
% >> >>


<<function olhrr(arm)>>=
long
olhrr(int i, int b, int r, int sc)
{
    return olhr(i, b, r, sc) ^ (1<<22);
}
@
% >>



\subsection{Shifted moves}


<<[[optab]] entries>>=
{ AMOVW,	C_SHIFT,C_NONE,	C_REG,		59, 4 },
{ AMOVBU,	C_SHIFT,C_NONE,	C_REG,		59, 4 },

{ AMOVB,	C_SHIFT,C_NONE,	C_REG,		60, 4 },

{ AMOVW,	C_REG,	C_NONE,	C_SHIFT,	61, 4 },
{ AMOVB,	C_REG,	C_NONE,	C_SHIFT,	61, 4 },
{ AMOVBU,	C_REG,	C_NONE,	C_SHIFT,	61, 4 },
@

<<[[asmout()]] switch on type cases>>=
case 59:	/* movw/bu R<<I(R),R -> ldr indexed */
    if(p->from.reg == R_NONE) {
        if(p->as != AMOVW)
            diag("byte MOV from shifter operand");
        goto mov;
    }
    if(p->from.offset&(1<<4))
        diag("bad shift in LDR");
    o1 = olrr(p->as, p->scond, p->from.offset, p->from.reg, p->to.reg);
    break;
@
% >> >> >>
%old: factorized in olrr now
%    if(p->as == AMOVBU)
%        o1 |= 1<<22;


<<[[asmout()]] switch on type cases>>=
case 60:	/* movb R(R),R -> ldrsb indexed */
    if(p->from.reg == R_NONE) {
        diag("byte MOV from shifter operand");
        goto mov;
    }
    if(p->from.offset&(~0xf))
        diag("bad shift in LDRSB");
    o1 = olhrr(p->from.offset, p->from.reg, p->to.reg, p->scond);
    o1 ^= (1<<5)|(1<<6);
    break;
@
% >> >> 

<<[[asmout()]] switch on type cases>>=
case 61:	/* movw/b/bu R,R<<[IR](R) -> str indexed */
    if(p->to.reg == R_NONE)
        diag("MOV to shifter operand");
    o1 = osrr(p->as, p->scond, p->from.reg, p->to.offset, p->to.reg);
    break;
@
% >> >>
%old: factorized in osrr
%    if(p->as == AMOVB || p->as == AMOVBU)
%        o1 |= 1<<22;


\section{Compiler-only pseudo opcodes}

<<[[buildop()]] switch opcode r for ranges cases>>=
case ACASE:
case ABCASE:
    break;
@

<<[[optab]] entries>>=
{ ACASE,	C_REG,	C_NONE,	C_NONE,		62, 4 },
{ ABCASE,	C_NONE, C_NONE, C_BRANCH,   63, 4 },
@


<<[[asmout()]] switch on type cases>>=
case 62:	/* case R -> movw	R<<2(PC),PC */
    o1 = olrr(AMOVW, p->scond, p->from.reg, REGPC, REGPC);
    o1 |= 2<<7;
    break;
@
% >>  >>
%old: passed AMOVW since rewrote olrr, actually clearer!

<<[[asmout()]] switch on type cases>>=
case 63:	/* bcase */
    if(p->cond != P) {
        o1 = p->cond->pc;
        if(dlm)
            dynreloc(S, p->pc, 1);
    }
    break;
@


\section{[[5l -E digits]]}
\l remove? used by who? useful feature? for -E0x7c00 ?

<<[[main()]] if rare condition do not set SXREF for INITENTRY, else>>=
if(*INITENTRY >= '0' && *INITENTRY <= '9') {}
else
@

<<[[entryvalue()]] if digit INITENTRY>>=
if(*a >= '0' && *a <= '9')
    return atolwhex(a);
@


\section{Strings in text segment, [[5l -t]]}

% what for? so cannot be modified? text is marked as writable
%  in Kernel.nw?
% for constant strings? 
% an optimisation?

% Section

<<[[Section]] cases>>=
SSTRING, // arm
@


<<[[dodata()]] if string in text segment>>=
if(debug['t']) {
    /*
     * pull out string constants
     */
    for(p = datap; p != P; p = p->link) {
        s = p->from.sym;
        if(p->to.type == D_SCONST)
            s->type = SSTRING;
    }
}
@

% Layout


<<[[dotext()]] other locals>>=
Sym *s;
long v;
int i;
@

% after has layout all the TEXT instrs, can put behind the strings.
<<[[dotext()]] if string in text segment>>=
if(debug['t']) {
    /* 
     * add strings to text segment
     */
    c = rnd(c, 8);
    for(i=0; i<NHASH; i++)
     for(s = hash[i]; s != S; s = s->link)
      if(s->type == SSTRING) {
          v = s->value;
          v = rnd(v, 4);
          s->value = c;
          c += v;
      }
}
@
%old:
%          while(v & 3)
%              v++;

% Code generation

<<[[asmb()]] locals>>=
long etext;
@

% it's an opti? need that? put later?
<<[[asmb()]] Text section, output strings in text segment>>=
/* output strings in text segment */
etext = INITTEXT + textsize;
for(t = pc; t < etext; t += sizeof(buf)-100) {
    if(etext-t > sizeof(buf)-100)
        datblk(t, sizeof(buf)-100, true);
    else
        datblk(t, etext-t, true);
@




<<[[datblk()]] if sstring might continue>>=
if(sstring != (p->from.sym->type == SSTRING))
    continue;
@


<<[[asmsym()]] in symbol table iteration, switch section cases>>=
case SSTRING:
    putsymb(s->name, 'T', s->value, s->version);
    continue;
@

% and more chunks we didn't put such as case STEXT: STRING: ...







\chapter{Conclusion}
\label{chap:conclusion}

%dup: (and adapted) from Assembler.nw
You now know how the \plan ARM linker [[5l]] works,
to the smallest details, and more generally how many 
linkers work.

\l next step? kernel/loader. 
\l debugger which uses libmach. profiler.



%\section{Limitations/Bugs}
% - large procedure not handled for now (not sure why the constraint)



%###############################################################################

\appendix

\chapter{Debugging}
\label{chap:debugging-appendix}

%\section{[[debug]]}

% hmm actually it's used not just for debugging but also for generic
% options, e.g., for -l, -p, etc in addition to the main use which is -v
<<global debug>>=
bool	debug[128];
@
% why not 256 like in Assembler.nw?

<<[[main()]] command line processing(arm)>>=
default:
    c = ARGC();
    if(c >= 0 && c < sizeof(debug))
        debug[c]++;
    break;
@



% -A, see diag()

%bso? 
<<global bso>>=
Biobuf	bso;
@


<<[[main()]] debug initialization(arm)>>=
Binit(&bso, 1, OWRITE);
listinit(); // fmtinstall()
@
%x86: memset(debug, false, sizeof(debug));
\l use STDOUT?


\section{Dumpers}
\label{sec:dumpers}

% dupe with Compiler.nw

\l why called listinit??

<<function listinit(arm)>>=
void
listinit(void)
{

    fmtinstall('A', Aconv);
    fmtinstall('C', Cconv);
    fmtinstall('D', Dconv);
    fmtinstall('N', Nconv);
    fmtinstall('P', Pconv);
    fmtinstall('S', Sconv);
}
@

<<pragmas varargck type>>=
#pragma varargck    type    "A" int
#pragma varargck    type    "A" uint
#pragma varargck    type    "C" int
#pragma varargck    type    "D" Adr*
#pragma varargck    type    "N" Adr*
#pragma varargck    type    "P" Prog*
#pragma varargck    type    "S" char*
@

\subsection{Instruction dumper, [[Pconv()]]}

% Pconv, Prog print

<<function prasm(arm)>>=
void
prasm(Prog *p)
{
    print("%P\n", p);
}
@


<<constant STRINGSZ>>=
STRINGSZ    = 200,
@


<<function Pconv(arm)>>=
// Prog -> string
int
Pconv(Fmt *fp)
{
    char str[STRINGSZ], *s;
    Prog *p;
    int a;

    p = va_arg(fp->args, Prog*);
    curp = p;
    a = p->as;

    switch(a) {
    case ASWPW:
    case ASWPBU:
        sprint(str, "(%ld)	%A%C	R%d,%D,%D",
            p->line, a, p->scond, p->reg, &p->from, &p->to);
        break;

    case ADATA:

    default:
        s = str;
        s += sprint(s, "(%ld)", p->line);
        if(p->reg == R_NONE)
            sprint(s, "	%A%C	%D,%D",
                a, p->scond, &p->from, &p->to);
        else
        if(p->from.type != D_FREG)
            sprint(s, "	%A%C	%D,R%d,%D",
                a, p->scond, &p->from, p->reg, &p->to);
        else
            sprint(s, "	%A%C	%D,F%d,%D",
                a, p->scond, &p->from, p->reg, &p->to);
        break;

    }
    return fmtstrcpy(fp, str);
}
@
%    case AINIT:
%    case ADYNT:
%        sprint(str, "(%ld)	%A%C	%D/%d,%D",
%            p->line, a, p->scond, &p->from, p->reg, &p->to);
%        break;



\subsection{Opcode dumper, [[Aconv()]]}

% Aconv because Axxx


% defined in ../5c/enam.c, coupling with enum as in 5.out.h
% extern	char*	anames[];

<<function Aconv(arm)>>=
// enum<Opcode> -> string
int
Aconv(Fmt *fp)
{
    char *s;
    int a;

    a = va_arg(fp->args, int);
    s = "???";
    if(a >= AXXX && a < ALAST)
        s = anames[a];
    return fmtstrcpy(fp, s);
}
@


\subsection{Operand dumper, [[Dconv()]]}

% Dconv Dxxx

\t when have reg != R_NONE??? sanity check in inopd and remove case?

<<function Dconv(arm)>>=
// Adr -> string
int
Dconv(Fmt *fp)
{
    char str[STRINGSZ];
    char *op;
    Adr *a;
    long v;

    a = va_arg(fp->args, Adr*);
    switch(a->type) {

    case D_NONE:
        str[0] = '\0';
        if(a->symkind != N_NONE || a->reg != R_NONE || a->sym != S)
            sprint(str, "%N(R%d)(NONE)", a, a->reg);
        break;

    case D_CONST:
        sprint(str, "$%N", a);
        break;

    case D_ADDR:
        if(a->reg == R_NONE)
            sprint(str, "$%N", a);
        else
            sprint(str, "$%N(R%d)", a, a->reg);
        break;

    case D_SHIFT:
        v = a->offset;
        op = "<<>>->@>" + (((v>>5) & 3) << 1);
        if(v & (1<<4))
            sprint(str, "R%ld%c%cR%ld", v&15, op[0], op[1], (v>>8)&15);
        else
            sprint(str, "R%ld%c%c%ld", v&15, op[0], op[1], (v>>7)&31);
        if(a->reg != R_NONE)
            sprint(str+strlen(str), "(R%d)", a->reg);
        break;

    case D_OREG:
        if(a->reg != R_NONE)
            sprint(str, "%N(R%d)", a, a->reg);
        else
            sprint(str, "%N", a);
        break;

    case D_REG:
        sprint(str, "R%d", a->reg);
        if(a->symkind != N_NONE || a->sym != S)
            sprint(str, "%N(R%d)(REG)", a, a->reg);
        break;

    case D_REGREG:
        sprint(str, "(R%d,R%d)", a->reg, (int)a->offset);
        if(a->symkind != N_NONE || a->sym != S)
            sprint(str, "%N(R%d)(REG)", a, a->reg);
        break;

    case D_FREG:
        sprint(str, "F%d", a->reg);
        if(a->symkind != N_NONE || a->sym != S)
            sprint(str, "%N(R%d)(REG)", a, a->reg);
        break;

    case D_PSR:
        switch(a->reg) {
        case 0:
            sprint(str, "CPSR");
            break;
        case 1:
            sprint(str, "SPSR");
            break;
        default:
            sprint(str, "PSR%d", a->reg);
            break;
        }
        if(a->symkind != N_NONE || a->sym != S)
            sprint(str, "%N(PSR%d)(REG)", a, a->reg);
        break;

    case D_FPCR:
        switch(a->reg){
        case 0:
            sprint(str, "FPSR");
            break;
        case 1:
            sprint(str, "FPCR");
            break;
        default:
            sprint(str, "FCR%d", a->reg);
            break;
        }
        if(a->symkind != N_NONE || a->sym != S)
            sprint(str, "%N(FCR%d)(REG)", a, a->reg);

        break;

    case D_BRANCH:	/* botch */
        if(curp->cond != P) {
            v = curp->cond->pc;
            if(a->sym != S)
                sprint(str, "{%s}%.5lux(BRANCH)", a->sym->name, v);
            else
                sprint(str, "%.5lux(BRANCH)", v);
        } else
            if(a->sym != S)
                sprint(str, "{%s}%ld(APC)", a->sym->name, a->offset);
            else
                sprint(str, "%ld(APC)", a->offset);
        break;

    case D_FCONST:
        sprint(str, "$%e", ieeedtod(a->ieee));
        break;

    case D_SCONST:
        sprint(str, "$\"%S\"", a->sval);
        break;

    default:
        sprint(str, "GOK-type(%d)", a->type);
        break;

    }
    return fmtstrcpy(fp, str);
}
@
%pad: I put braces around symbol name to better indicate they are comments now
%pad: I added case for D_ADDR
%    case D_CONST:
%        if(a->reg == R_NONE)
%            sprint(str, "$%N", a);
%        else
%            sprint(str, "$%N(R%d)", a, a->reg);
%        break;

%old:
%    case D_OCONST:
%        sprint(str, "$*$%N", a);
%        if(a->reg != R_NONE)
%            sprint(str, "%N(R%d)(CONST)", a, a->reg);
%        break;


%TODO
%\subsection{Operand class dumper, [[??conv()]]}



\subsection{Symbol kind dumper, [[Nconv()]]}

% Nxxx so Nconv
%old: was actually some D_xxx but I split from other D_XXX and renamed N_xxx
% (which proves I was right to split and rename)

<<function Nconv(arm)>>=
int
Nconv(Fmt *fp)
{
    char str[STRINGSZ];
    Adr *a;
    Sym *s;

    a = va_arg(fp->args, Adr*);
    s = a->sym;

    switch(a->symkind) {
    case N_NONE:
        sprint(str, "%ld", a->offset);
        break;

    case N_EXTERN:
        if(s == S)
            sprint(str, "%ld(SB)", a->offset);
        else
            sprint(str, "{%s}%.5lux+%ld(SB)", s->name, s->value, a->offset);
        break;

    case N_INTERN:
        if(s == S)
            sprint(str, "<>+%ld(SB)", a->offset);
        else
            sprint(str, "{%s<>}%.5lux+%ld(SB)", s->name, s->value, a->offset);
        break;

    case N_LOCAL:
        if(s == S)
            sprint(str, "%ld(SP)", a->offset);
        else
            sprint(str, "{%s}-%ld(SP)", s->name, -a->offset);
        break;

    case N_PARAM:
        if(s == S)
            sprint(str, "%ld(FP)", a->offset);
        else
            sprint(str, "{%s}%ld(FP)", s->name, a->offset);
        break;
    default:
        sprint(str, "GOK-name(%d)", a->symkind);
        break;

    }
    return fmtstrcpy(fp, str);
}
@
%pad: I added the s->value for dumping resolved value of $hello in tutorial
% and put braces around symbol to better show that they are really comment
% now because they are resolved.
% before: $hello+0(SB),R1
% after:  ${hello}00014+0(SB), R1

\subsection{Conditional execution dumper, [[Cconv()]]}


<<global strcond(arm)>>=
char*	strcond[16] =
{
    ".EQ",
    ".NE",
    ".HS",
    ".LO",
    ".MI",
    ".PL",
    ".VS",
    ".VC",
    ".HI",
    ".LS",
    ".GE",
    ".LT",
    ".GT",
    ".LE",
    "",
    ".NV"
};
@

<<function Cconv(arm)>>=
int
Cconv(Fmt *fp)
{
    char s[20];
    int c;

    c = va_arg(fp->args, int);
    strcpy(s, strcond[c & C_SCOND]);
    if(c & C_SBIT)
        strcat(s, ".S");
    if(c & C_PBIT)
        strcat(s, ".P");
    if(c & C_WBIT)
        strcat(s, ".W");
    if(c & C_UBIT)		/* ambiguous with FBIT */
        strcat(s, ".U");
    return fmtstrcpy(fp, s);
}
@


\subsection{String dumper, [[Sconv()]]}

% for D_DSCONST, for sval

% why need Fmt? cant just use %s ? sanity check?
% used to also print 0 to \z

<<function Sconv(arm)>>=
// string -> string
int
Sconv(Fmt *fp)
{
    int i, c;
    char str[STRINGSZ], *p, *a;

    a = va_arg(fp->args, char*);
    p = str;
    for(i=0; i<sizeof(long); i++) {
        c = a[i] & 0xff;
        if(c >= 'a' && c <= 'z' ||
           c >= 'A' && c <= 'Z' ||
           c >= '0' && c <= '9' ||
           c == ' ' || c == '%') {
            *p++ = c;
            continue;
        }
        *p++ = '\\';
        switch(c) {
        case '\0':
            *p++ = 'z';
            continue;
        case '\\':
        case '"':
            *p++ = c;
            continue;
        case '\n':
            *p++ = 'n';
            continue;
        case '\t':
            *p++ = 't';
            continue;
        }
        // else
        *p++ = (c>>6) + '0';
        *p++ = ((c>>3) & 7) + '0';
        *p++ = (c & 7) + '0';
    }
    *p = '\0';
    return fmtstrcpy(fp, str);
}
@
% why not make default instead of // else, and use break instead of continue?

\section{Verbose mode, [[5l -v]]}
\l and [[DBG()]]

%old: used to have lots of code like:
% if(debug['v']) {
%    Bprint(&bso, "HEADER = -H0x%ld -T0x%lux -D0x%lux -R0x%lux\n",
%        HEADTYPE, INITTEXT, INITDAT, INITRND);
%    Bflush(&bso);
%}
% (The Bflush was outside the if, but makes more sense like this I think)
% but better to have a DBG() macro for this

<<macro DBG>>=
#define DBG if(debug['v']) mylog
@
%pad: I introduced that

<<function log>>=
void mylog(char *fmt, ...) {

    va_list arg;

    va_start(arg, fmt);
    Bvprint(&bso, fmt, arg);
    va_end(arg);
    Bflush(&bso);
}
@
%pad: I introduced that

\section{Objects loading debugging, [[5l -W]]}
\label{sec:debugging-loading}

<<[[ldobj()]] debug>>=
if(debug['W'])
    print("%P\n", p);
@
% see Pconv before

<<[[ldobj()]] when ANAME, debug>>=
if(debug['W'])
    print("	ANAME	%s\n", s->name);
@

\l -W for? what is the connexion to object loading?

% print object code when loading

% (but need good enam.c! up to date and in sync with 5.out.h)


%ex: of output:


\section{Opcode table debugging, [[5l -t]]}

<<[[oplook()]] debug>>=
if(debug['t']) {
    print("oplook %P %A %d %d %d\n",
        p, (int)p->as, a1, a2, a3);
}
@
%pad: I added that
%old: used to be under a if 0 but pretty useful when debugging issues
%      print("		%d %d\n", p->from.type, p->to.type);


\section{Machine code generation debugging, [[5l -a]]}
\label{sec:debugging-generated-code}
\l why -a? assembly? meh

% print final concrete code in assembly language with addresses
% very nice!

%ex of output:
% 00001020: e52de024 (12) MOVW.W R14, -36(R13)
%  with lineno (12) but it's a global_lineno so take care

% if do 5l -a -a two times then get also the o->type and so know
% which case was triggered which is also very useful (remember MOVD
% generation pb with addpool())

<<[[asmout()]] other locals>>=
// pc (real)
long v;
@

<<[[asmout()]] debug>>=
if(debug['a'] > 1)
    Bprint(&bso, "%2d ", o->type);
v = p->pc; // for debugging later
@
% when -a -a


<<[[asmout()]] when 1 generated instruction, debug>>=
if(debug['a'])
    Bprint(&bso, " %.8lux: %.8lux\t%P\n", v, o1, p);
@
<<[[asmout()]] when 2 generated instructions, debug>>=
if(debug['a'])
    Bprint(&bso, " %.8lux: %.8lux %.8lux%P\n", v, o1, o2, p);
@
<<[[asmout()]] when 3 generated instructions, debug>>=
if(debug['a'])
    Bprint(&bso, " %.8lux: %.8lux %.8lux %.8lux%P\n", v, o1, o2, o3, p);
@
<<[[asmout()]] when 4 generated instructions, debug>>=
if(debug['a'])
    Bprint(&bso, " %.8lux: %.8lux %.8lux %.8lux %.8lux%P\n",
        v, o1, o2, o3, o4, p);
@
<<[[asmout()]] when 5 generated instructions, debug>>=
if(debug['a'])
    Bprint(&bso, " %.8lux: %.8lux %.8lux %.8lux %.8lux %.8lux%P\n",
        v, o1, o2, o3, o4, o5, p);
@
<<[[asmout()]] when 6 generated instructions, debug>>=
if(debug['a'])
    Bprint(&bso, " %.8lux: %.8lux %.8lux %.8lux %.8lux %.8lux %.8lux%P\n",
        v, o1, o2, o3, o4, o5, o6, p);
@
<<[[asmout()]] when other size, debug>>=
if(debug['a'])
    Bprint(&bso, " %.8lux:\t\t%P\n", v, p);
@



<<[[asmb()]] before cflush, debug>>=
if(debug['a']) {
    Bprint(&bso, "\n");
    Bflush(&bso);
}
@




\section{Symbol table debugging, [[5l -n]]}

<<[[putsymb()]] debug>>=
if(debug['n']) {
    <<[[putsymb()]] if z or Z in debug output>>
    if(ver)
        Bprint(&bso, "%c %.8lux %s<%d>\n", t, v, s, ver);
    else
        Bprint(&bso, "%c %.8lux %s\n", t, v, s);
}
@

<<[[putsymb()]] if z or Z in debug output>>=
if(t == 'z' || t == 'Z') {
    Bprint(&bso, "%c %.8lux ", t, v);
    for(i=1; s[i] != 0 || s[i+1] != 0; i+=2) {
        f = ((s[i]&0xff) << 8) | (s[i+1]&0xff);
        Bprint(&bso, "/%x", f);
    }
    Bprint(&bso, "\n");
    return;
}
@
% >> >> >>
% could use symbol table and their histgen to find the final meaning
% (but would be slow to iterate over all symbol table each time,
%  would need some indexing of histgen maybe)

\section{Line table debugging, [[5l -V]]}

<<[[asmlc()]] dump instruction p, debug>>=
if(debug['V'])
    Bprint(&bso, "%6lux %P\n", p->pc, p);
@

<<[[asmlc()]] dump lcsize, debug>>=
if(debug['V'])
    Bprint(&bso, "\t\t%6ld", lcsize);
@

<<[[asmlc()]] dump s, debug>>=
if(debug['V'])
    Bprint(&bso, " pc+%ld*%d(%ld)", s, MINLC, s+128);
@


<<[[asmlc()]] dump big line change, debug>>=
if(debug['V']) {
    if(s > 0)
        Bprint(&bso, " lc+%ld(%d,%ld)\n",
            s, 0, s);
    else
        Bprint(&bso, " lc%ld(%d,%ld)\n",
            s, 0, s);
    Bprint(&bso, "%6lux %P\n",
        p->pc, p);
}
@

<<[[asmlc()]] dump small line increment, debug>>=
if(debug['V']) {
    Bprint(&bso, " lc+%ld(%ld)\n", s, 0+s);
    Bprint(&bso, "%6lux %P\n",
        p->pc, p);
}
@

<<[[asmlc()]] dump negative line increment, debug>>=
if(debug['V']) {
    Bprint(&bso, " lc%ld(%ld)\n", s, 64-s);
    Bprint(&bso, "%6lux %P\n",
        p->pc, p);
}
@



\chapter{Error Management}
\label{chap:error}

<<global nerrors>>=
int	nerrors = 0;
@

<<function errorexit>>=
void
errorexit(void)
{

    if(nerrors) {
        if(cout >= 0)
            remove(outfile);
        exits("error");
    }
    exits(0);
}
@
\l why exits(0) when call errorexit for regular exit? what 5a does?
%assembler: similar


<<pragmas varargck argpos>>=
#pragma varargck    argpos  diag 1
@

% could use TNAME here too?
<<function diag>>=
void
diag(char *fmt, ...)
{
    char buf[STRINGSZ];
    char *tn;
    va_list arg;

    tn = "??none??";
    if(curtext != P && curtext->from.sym != S)
        tn = curtext->from.sym->name;
    va_start(arg, fmt);
    vseprint(buf, buf+sizeof(buf), fmt, arg);
    va_end(arg);
    print("%s: %s\n", tn, buf);

    nerrors++;
    if(nerrors > 20 && !debug['A']) {
        print("too many errors\n");
        errorexit();
    }
}
@
% ARM does not have the && !debug['A'], but probablt error no?

% note that call to diag increment nerror and so prevent
% any executable generation (but allow error recovery and continue)

\t percent r is error return code of last syscall I think, so common to have
\t  it in fmt

%\section{[[5l -A]]}
% get all errors



\chapter{Profiling}
\label{chap:profiling-appendix}

% 5l -v
% had lots of cputime() too in calls to DBG, so a form of profiling

<<[[main()]] profile report>>=
if(debug['v']) {
    Bprint(&bso, "%5.2f cpu time\n", cputime());
    Bprint(&bso, "%ld symbols\n", nsymbol);
    Bprint(&bso, "%ld memory used\n", thunk);

    Bprint(&bso, "%d sizeof adr\n", sizeof(Adr));
    Bprint(&bso, "%d sizeof prog\n", sizeof(Prog));
    Bflush(&bso);
}
@

<<global nsymbol linker>>=
long	nsymbol;
@
% for statistics
<<[[lookup()]] profiling>>=
nsymbol++;
@



\chapter{Utilities}
\label{chap:libc}

\section{Memory management}
% same in Assembler.nw
\l could get rid of it? remove all those globals and use plain libc malloc?

<<global hunk>>=
char*	hunk;
@

<<global nhunk>>=
long	nhunk;
@
% = 0??


<<global thunk>>=
long	thunk;
@
% for statistics

<<constant NHUNK linker>>=
NHUNK       = 100000,
@


% not sure why don't use libc malloc and do low-level sbrk ...
% to optimize things? as they do no free?
<<function gethunk>>=
static void
gethunk(void)
{
    char *h;
    long nh;

    nh = NHUNK;
    if(thunk >= 5L*NHUNK) {
        nh = 5L*NHUNK;
        if(thunk >= 25L*NHUNK)
            nh = 25L*NHUNK;
    }
    h = sbrk(nh);
    if(h == (char*)-1) {
        diag("out of memory");
        errorexit();
    }
    hunk = h;
    nhunk = nh;
    thunk += nh;
}
@

% note that because malloc always return a newly allocated area,
% and never reuse a previously allocated space (one that
% would have been free'ed to  be made available again),
% the data returned is always reset to 0. Indeed sbrk()
% allocates zero-filled data (see Kernel.nw).
% Replacing malloc but the libc malloc may result in bug
% as at a few place we don't initialize some fields to 0.

<<function malloc>>=
/*
 * fake malloc
 */
void*
malloc(ulong n)
{
    void *p;

    // upper_round(n, 8)
    while(n & 7)
        n++;

    while(nhunk < n)
        gethunk();
    p = hunk;
    nhunk -= n;
    hunk += n;
    return p;
}
@




% no free ...  hmmm
<<function free>>=
void
free(void *p)
{
    USED(p);
}
@



% not sure why but if redefine malloc and free then have to
% redefine this func too, otherwise get a link error
<<function setmalloctag>>=
//@Scheck: looks dead, but because we redefine malloc/free we must also redefine that
void setmalloctag(void *v, ulong pc)
{
    USED(v, pc);
}
@


\section{Buffer management}
\label{sec:buffer-management}

<<struct Buf>>=
union Buf
{
    struct
    {
        char    obuf[MAXIO];            /* output buffer */
        byte    ibuf[MAXIO];            /* input buffer */
    };
    char    dbuf[1]; // variable size
};
@
<<constant MAXIO>>=
MAXIO       = 8192,
@

<<global buf>>=
union Buf buf;
@


% see readsome() also but not as generic as rest below
% and needed to undertand ldobj so put before


%<<constant cbuf>>=
%#define	Cbuf	u.obuf
%@
%<<constant xbuf>>=
%#define	Xbuf	u.ibuf
%@
%%simplified! use anonymous union!

\subsection{Output buffer}


% cflush in chapter X


<<function cput(arm)>>=
void
cput(int c)
{
    cbp[0] = c;
    cbp++;
    cbc--;
    if(cbc <= 0)
        cflush();
}
@
% mostly similar to x86, x86 is using a macro though



% xxxl means left? little endian?

% used only by elf.c
<<function wputl(arm)>>=
void
wputl(long l)
{

    cbp[0] = l;
    cbp[1] = l>>8;
    cbp += 2;
    cbc -= 2;
    if(cbc <= 0)
        cflush();
}
@
% the x86 version seems more logical, normal?
% what about overflow?? sure cbc >= 2?

<<function wput(arm)>>=
void
wput(long l)
{

    cbp[0] = l>>8;
    cbp[1] = l;
    cbp += 2;
    cbc -= 2;
    if(cbc <= 0)
        cflush();
}
@

% lputl and lput in Chapter X






%dead: or used in the end only for x86?
% <<function llput>>=
% void
% llput(vlong v)
% {
%     lput(v>>32);
%     lput(v);
% }
% @
% 
%dead:
% <<function llputl>>=
% void
% llputl(vlong v)
% {
%     lputl(v);
%     lputl(v>>32);
% }
% @




%used only by 8l/elf.c 
<<function strnput(arm)>>=
void
strnput(char *s, int n)
{
    for(; *s; s++){
        cput(*s);
        n--;
    }
    for(; n > 0; n--)
        cput(0);
}
@
% the x86 version is sligtly different, so generic code in elf.c
%  but specialized method in asm.c for it

\subsection{Input buffer}

% saw readsome(), etc in chapter X

\section{File management}

<<function fileexists>>=
int
fileexists(char *s)
{
    byte dirbuf[400];

    /* it's fine if stat result doesn't fit in dirbuf, since even then the file exists */
    return stat(s, dirbuf, sizeof(dirbuf)) >= 0;
}
@


\section{String processing}
\label{sec:atolwhex}

% could be put in libc, with the other atoxxx
% atoxx? why a?  a to long with hexadecimal?
<<function atolwhex>>=
long
atolwhex(char *s)
{
    long n;
    int f;

    n = 0;
    f = 0;
    while(*s == ' ' || *s == '\t')
        s++;
    if(*s == '-' || *s == '+') {
        if(*s++ == '-')
            f = 1;
        while(*s == ' ' || *s == '\t')
            s++;
    }
    if(s[0]=='0' && s[1]){
        if(s[1]=='x' || s[1]=='X'){
            s += 2;
            for(;;){
                if(*s >= '0' && *s <= '9')
                    n = n*16 + *s++ - '0';
                else if(*s >= 'a' && *s <= 'f')
                    n = n*16 + *s++ - 'a' + 10;
                else if(*s >= 'A' && *s <= 'F')
                    n = n*16 + *s++ - 'A' + 10;
                else
                    break;
            }
        } else
            while(*s >= '0' && *s <= '7')
                n = n*8 + *s++ - '0';
    } else
        while(*s >= '0' && *s <= '9')
            n = n*10 + *s++ - '0';
    if(f)
        n = -n;
    return n;
}
@


\section{Mathematic functions}

% rnd, exemple:  rnd(16, 8) = 16. rnd(17, 8) = 24

\t maybe show code of alternatives?
%alt: code like that too
%   while(orig & 7) // align
%     orig++;
% or
%   autosize = (p->to.offset+3L) & ~3L;
% which is optimal when rnd at power of 2?

<<function rnd>>=
long
rnd(long v, long r)
{
    long c;

    <<[[rnd()]] if r is null or negative>>
    v += r - 1;
    c = v % r;
    <<[[rnd()]] if v was negative>>
    v -= c;
    return v;
}
@


<<[[rnd()]] if r is null or negative>>=
if(r <= 0)
    return v;
@
<<[[rnd()]] if v was negative>>=
if(c < 0)
    c += r;
@


\chapter{Linker-related Programs TODO}
\label{chap:linker-related-programs}

% what is objcopy?

\section{[[include/mach.h]]}

% can copy Fhdr here.

% actually linker does not depend on libmach/! because it's writing 
% specific stuff and libmach is mostly about generic reading interface 
% to many specifics
% (and not just 5l)

% FIGURE where see linker which does not use libmach, write vs read

% see libmach to read back this executable!
%FIGURE
% so   .s --5a--> .o (.5) --5l--> .exe (5.out) --libmach--> readable
% (hmm libmach is also reading .o (.5)

\l could factorize code between ldobj and libmach?
% why not using 5obj.c from libmach/? because 5obj.c is incomplete?
% because it cares just about the symbol table?


\section{[[size]]}
\label{sec:size-code}

% errort (0 is ok)
<<function size>>=
int
size(char *file)
{
    fdt fd;
    Fhdr f;

    if((fd = open(file, OREAD)) < 0){
        fprint(2, "size: ");
        perror(file);
        return 1;
    }
    if(crackhdr(fd, &f)) {
        print("%ldt + %ldd + %ldb = %ld\t%s\n", f.txtsz, f.datsz,
            f.bsssz, f.txtsz+f.datsz+f.bsssz, file);
        close(fd);
        return 0;
    }
    fprint(2, "size: %s not an a.out\n", file);
    close(fd);
    return 1;
}
@

<<function main (linkers/misc/size.c)>>=
void
main(int argc, char *argv[])
{
    char *err;
    int i;

    ARGBEGIN {
    default:
        fprint(2, "usage: size [a.out ...]\n");
        exits("usage");
    } ARGEND;

    err = nil;
    if(argc == 0)
        if(size("8.out"))
            err = "error";
    for(i=0; i<argc; i++)
        if(size(argv[i]))
            err = "error";
    exits(err);
}
@

\section{[[strip]]}
\label{sec:strip}

% see also 5a -s and relevant code in chapter Debugger.



<<function error (linkers/misc/strip.c)>>=
void
error(char* fmt, ...)
{
    va_list arg;
    char *e, s[256];

    va_start(arg, fmt);
    e = seprint(s, s+sizeof(s), "%s: ", argv0);
    e = vseprint(e, s+sizeof(s), fmt, arg);
    e = seprint(e, s+sizeof(s), "\n");
    va_end(arg);

    write(2, s, e-s);
}
@

<<function usage (linkers/misc/strip.c)>>=
static void
usage(void)
{
    error("usage: %s -o ofile file\n\t%s file ...\n", argv0, argv0);
    exits("usage");
}
@

<<function strip>>=
static int
strip(char* file, char* out)
{
    Dir *dir;
    int fd, i;
    Fhdr fhdr;
    Exec *exec;
    ulong mode;
    void *data;
    vlong length;

    if((fd = open(file, OREAD)) < 0){
        error("%s: open: %r", file);
        return 1;
    }

    if(!crackhdr(fd, &fhdr)){
        error("%s: %r", file);
        close(fd);
        return 1;
    }
    for(i = MIN_MAGIC; i <= MAX_MAGIC; i++){
        if(fhdr.magic == _MAGIC(0, i) || fhdr.magic == _MAGIC(HDR_MAGIC, i))
            break;
    }
    if(i > MAX_MAGIC){
        error("%s: not a recognizeable binary", file);
        close(fd);
        return 1;
    }

    if((dir = dirfstat(fd)) == nil){
        error("%s: stat: %r", file);
        close(fd);
        return 1;
    }

    length = fhdr.datoff+fhdr.datsz;
    if(length == dir->length){
        if(out == nil){	/* nothing to do */
            error("%s: already stripped", file);
            free(dir);
            close(fd);
            return 0;
        }
    }
    if(length > dir->length){
        error("%s: strange length", file);
        close(fd);
        free(dir);
        return 1;
    }

    mode = dir->mode;
    free(dir);

    if((data = malloc(length)) == nil){
        error("%s: malloc failure", file);
        close(fd);
        return 1;
    }
    seek(fd, 0LL, 0);
    if(read(fd, data, length) != length){
        error("%s: read: %r", file);
        close(fd);
        free(data);
        return 1;
    }
    close(fd);

    exec = data;
    exec->syms = 0;
    exec->_unused = 0;
    exec->pcsz = 0;

    if(out == nil){
        if(remove(file) < 0) {
            error("%s: remove: %r", file);
            free(data);
            return 1;
        }
        out = file;
    }
    if((fd = create(out, OWRITE, mode)) < 0){
        error("%s: create: %r", out);
        free(data);
        return 1;
    }
    if(write(fd, data, length) != length){
        error("%s: write: %r", out);
        close(fd);
        free(data);
        return 1;
    }
    close(fd);
    free(data);

    return 0;
}
@

<<function main (linkers/misc/strip.c)>>=
void
main(int argc, char* argv[])
{
    int r;
    char *p;

    p = nil;

    ARGBEGIN{
    default:
        usage();
        break;
    case 'o':
        p = ARGF();
        if(p == nil)
            usage();
        break;
    }ARGEND;

    switch(argc){
    case 0:
        usage();
        return;
    case 1:
        if(p != nil){
            r = strip(*argv, p);
            break;
        }
        /*FALLTHROUGH*/
    default:
        r = 0;
        while(argc > 0){
            r |= strip(*argv, nil);
            argc--;
            argv++;
        }
        break;
    }

    if(r)
        exits("error");
    exits(0);
}
@


\section{[[nm]]}
\label{sec:nm-code}

% rely on no-strip!

% see nm(1)
% use libmach!

% table with letter -> definition? (but explained in nm(1) it is true)
% or better do it via the code :)



<<enum _anon_ (linkers/misc/nm.c)>>=
enum{
    CHUNK	=	256	/* must be power of 2 */
};
@

<<global errs>>=
static char	*errs;			/* exit status */
@

<<global filename>>=
static char	*filename;		/* current file */
@

<<global symname>>=
static char	symname[]="__.SYMDEF";	/* table of contents file name */
@

<<global multifile>>=
static bool	multifile;		/* processing multiple files */
@

<<global aflag (linkers/misc/nm.c)>>=
static int	aflag;
@

<<global gflag>>=
static int	gflag;
@

<<global hflag>>=
static int	hflag;
@

<<global nflag>>=
static int	nflag;
@

<<global sflag>>=
static int	sflag;
@

<<global uflag (linkers/misc/nm.c)>>=
static int	uflag;
@

<<global Tflag>>=
static int	Tflag;
@

<<global fnames>>=
static Sym	**fnames;		/* file path translation table */
@

<<global symptr>>=
static Sym	**symptr;
@

<<global nsym>>=
static int	nsym;
@

<<global bout (linkers/misc/nm.c)>>=
static Biobuf	bout;
@

<<function usage (linkers/misc/nm.c)>>=
static void
usage(void)
{
    fprint(2, "usage: nm [-aghnsTu] file ...\n");
    exits("usage");
}
@

<<function main (linkers/misc/nm.c)>>=
void
main(int argc, char *argv[])
{
    int i;
    Biobuf	*bin;

    Binit(&bout, 1, OWRITE);
    argv0 = argv[0];
    ARGBEGIN {
    default:	usage();
    case 'a':	aflag = 1; break;
    case 'g':	gflag = 1; break;
    case 'h':	hflag = 1; break;
    case 'n':	nflag = 1; break;
    case 's':	sflag = 1; break;
    case 'u':	uflag = 1; break;
    case 'T':	Tflag = 1; break;
    } ARGEND
    if (argc == 0)
        usage();
    if (argc > 1)
        multifile = true;
    for(i=0; i<argc; i++){
        filename = argv[i];
        bin = Bopen(filename, OREAD);
        if(bin == 0){
            error("cannot open %s", filename);
            continue;
        }
        if (isar(bin))
            doar(bin);
        else{
            Bseek(bin, 0, 0);
            dofile(bin);
        }
        Bterm(bin);
    }
    exits(errs);
}
@

<<function doar>>=
/*
 * read an archive file,
 * processing the symbols for each intermediate file in it.
 */
void
doar(Biobuf *bp)
{
    int offset, size, obj;
    char membername[SARNAME];

    multifile = true;
    for (offset = Boffset(bp);;offset += size) {
        size = nextar(bp, offset, membername);
        if (size < 0) {
            error("phase error on ar header %ld", offset);
            return;
        }
        if (size == 0)
            return;
        if (strcmp(membername, symname) == 0)
            continue;
        obj = objtype(bp, 0);
        if (obj < 0) {
            error("inconsistent file %s in %s",
                    membername, filename);
            return;
        }
        if (!readar(bp, obj, offset+size, 1)) {
            error("invalid symbol reference in file %s",
                    membername);
            return;
        }
        filename = membername;
        nsym=0;
        objtraverse(psym, 0);
        printsyms(symptr, nsym);
    }
}
@

<<function dofile>>=
/*
 * process symbols in a file
 */
void
dofile(Biobuf *bp)
{
    int obj;

    obj = objtype(bp, 0);
    if (obj < 0)
        execsyms(Bfildes(bp));
    else
    if (readobj(bp, obj)) {
        nsym = 0;
        objtraverse(psym, 0);
        printsyms(symptr, nsym);
    }
}
@

<<function cmp>>=
/*
 * comparison routine for sorting the symbol table
 *	this screws up on 'z' records when aflag == 1
 */
int
cmp(void *vs, void *vt)
{
    Sym **s, **t;

    s = vs;
    t = vt;
    if(nflag)
        if((*s)->value < (*t)->value)
            return -1;
        else
            return (*s)->value > (*t)->value;
    return strcmp((*s)->name, (*t)->name);
}
@

<<function zenter>>=
/*
 * enter a symbol in the table of filename elements
 */
void
zenter(Sym *s)
{
    static int maxf = 0;

    if (s->value > maxf) {
        maxf = (s->value+CHUNK-1) &~ (CHUNK-1);
        fnames = realloc(fnames, (maxf+1)*sizeof(*fnames));
        if(fnames == 0) {
            error("out of memory", argv0);
            exits("memory");
        }
    }
    fnames[s->value] = s;
}
@

<<function execsyms>>=
/*
 * get the symbol table from an executable file, if it has one
 */
void
execsyms(int fd)
{
    Fhdr f;
    Sym *s;
    long n;

    seek(fd, 0, 0);
    if (crackhdr(fd, &f) == 0) {
        error("Can't read header for %s", filename);
        return;
    }
    if (syminit(fd, &f) < 0)
        return;
    s = symbase(&n);
    nsym = 0;
    while(n--)
        psym(s++, 0);

    printsyms(symptr, nsym);
}
@

<<function psym>>=
void
psym(Sym *s, void* p)
{
    USED(p);
    switch(s->type) {
    case 'T':
    case 'L':
    case 'D':
    case 'B':
        if (uflag)
            return;
        if (!aflag && ((s->name[0] == '.' || s->name[0] == '$')))
            return;
        break;
    case 'b':
    case 'd':
    case 'l':
    case 't':
        if (uflag || gflag)
            return;
        if (!aflag && ((s->name[0] == '.' || s->name[0] == '$')))
            return;
        break;
    case 'U':
        if (gflag)
            return;
        break;
    case 'Z':
        if (!aflag)
            return;
        break;
    case 'm':
    case 'f':	/* we only see a 'z' when the following is true*/
        if(!aflag || uflag || gflag)
            return;
        if (strcmp(s->name, ".frame"))
            zenter(s);
        break;
    case 'a':
    case 'p':
    case 'z':
    default:
        if(!aflag || uflag || gflag)
            return;
        break;
    }
    symptr = realloc(symptr, (nsym+1)*sizeof(Sym*));
    if (symptr == 0) {
        error("out of memory");
        exits("memory");
    }
    symptr[nsym++] = s;
}
@

<<function printsyms>>=
void
printsyms(Sym **symptr, long nsym)
{
    int i, wid;
    Sym *s;
    char *cp;
    char path[512];

    if(!sflag)
        qsort(symptr, nsym, sizeof(*symptr), cmp);
    
    wid = 0;
    for (i=0; i<nsym; i++) {
        s = symptr[i];
        if (s->value && wid == 0)
            wid = 8;
        else if (s->value >= 0x100000000LL && wid == 8)
            wid = 16;
    }	
    for (i=0; i<nsym; i++) {
        s = symptr[i];
        if (multifile && !hflag)
            Bprint(&bout, "%s:", filename);
        if (s->type == 'z') {
            fileelem(fnames, (uchar *) s->name, path, 512);
            cp = path;
        } else
            cp = s->name;
        if (Tflag)
            Bprint(&bout, "%8ux ", s->sig);
        if (s->value || s->type == 'a' || s->type == 'p')
            Bprint(&bout, "%*llux ", wid, s->value);
        else
            Bprint(&bout, "%*s ", wid, "");

        Bprint(&bout, "%c %s\n", s->type, cp);
    }
}
@

<<function error>>=
static void
error(char *fmt, ...)
{
    Fmt f;
    char buf[128];
    va_list arg;

    fmtfdinit(&f, 2, buf, sizeof buf);
    fmtprint(&f, "%s: ", argv0);
    va_start(arg, fmt);
    fmtvprint(&f, fmt, arg);
    va_end(arg);
    fmtprint(&f, "\n");
    fmtfdflush(&f);
    errs = "errors";
}
@



\section{[[ar]]}
\label{sec:ar-code}

% see ar(5) and ar(1)

% ar use libmach/ library itself :) bootstrapping.



%/*
% *	The algorithm uses up to 3 temp files.  The "pivot member" is the
% *	archive member specified by and a, b, or i option.  The temp files are
% *	astart - contains existing members up to and including the pivot member.
% *	amiddle - contains new files moved or inserted behind the pivot.
% *	aend - contains the existing members that follow the pivot member.
% *	When all members have been processed, function 'install' streams the
% * 	temp files, in order, back into the archive.
% */

\ifallcode

<<struct Arsymref>>=
typedef struct	Arsymref
{
    char	*name;
    int	type;
    int	len;
    vlong	offset;
    struct	Arsymref *next;
} Arsymref;
@

<<struct Armember>>=
typedef struct	Armember	/* Temp file entry - one per archive member */
{
    struct Armember	*next;
    struct ar_hdr	hdr;
    long		size;
    long		date;
    void		*member;
} Armember;
@

<<struct Arfile>>=
typedef	struct Arfile		/* Temp file control block - one per tempfile */
{
    int	paged;		/* set when some data paged to disk */
    char	*fname;		/* paging file name */
    int	fd;		/* paging file descriptor */
    vlong	size;
    Armember *head;		/* head of member chain */
    Armember *tail;		/* tail of member chain */
    Arsymref *sym;		/* head of defined symbol chain */
} Arfile;
@

<<struct Hashchain>>=
typedef struct Hashchain
{
    char	*name;
    struct Hashchain *next;
} Hashchain;
@

<<constant NHASH>>=
#define	NHASH	1024
@

<<function HEADER_IO>>=
/*
 *	macro to portably read/write archive header.
 *	'cmd' is read/write/Bread/Bwrite, etc.
 */
#define	HEADER_IO(cmd, f, h)	cmd(f, h.name, sizeof(h.name)) != sizeof(h.name)\
                || cmd(f, h.date, sizeof(h.date)) != sizeof(h.date)\
                || cmd(f, h.uid, sizeof(h.uid)) != sizeof(h.uid)\
                || cmd(f, h.gid, sizeof(h.gid)) != sizeof(h.gid)\
                || cmd(f, h.mode, sizeof(h.mode)) != sizeof(h.mode)\
                || cmd(f, h.size, sizeof(h.size)) != sizeof(h.size)\
                || cmd(f, h.fmag, sizeof(h.fmag)) != sizeof(h.fmag)
@

<<global man>>=
char	*man =		"mrxtdpq";
@

<<global opt>>=
char	*opt =		"uvnbailo";
@

<<global artemp>>=
char	artemp[] =	"/tmp/vXXXXX";
@

<<global movtemp>>=
char	movtemp[] =	"/tmp/v1XXXXX";
@

<<global tailtemp>>=
char	tailtemp[] =	"/tmp/v2XXXXX";
@

<<global symdef>>=
char	symdef[] =	"__.SYMDEF";
@

<<global aflag>>=
int	aflag;				/* command line flags */
@

<<global bflag>>=
static int	bflag;
@

<<global cflag>>=
int	cflag;
@

<<global oflag>>=
int	oflag;
@

<<global uflag>>=
int	uflag;
@

<<global vflag>>=
int	vflag;
@

<<global allobj>>=
int	allobj = 1;			/* set when all members are object files of the same type */
@

<<global symdefsize>>=
int	symdefsize;			/* size of symdef file */
@

<<global dupfound>>=
int	dupfound;			/* flag for duplicate symbol */
@

<<global hash>>=
Hashchain	*hash[NHASH];		/* hash table of text symbols */
@

<<constant ARNAMESIZE>>=
#define	ARNAMESIZE	sizeof(astart->tail->hdr.name)
@

<<global poname>>=
char	poname[ARNAMESIZE+1];		/* name of pivot member */
@

<<global file>>=
char	*file;				/* current file or member being worked on */
@

<<global bout>>=
Biobuf	bout;
@

<<global bar>>=
Biobuf bar;
@

<<global comfun>>=
void	(*comfun)(char*, int, char**);
@

<<function main>>=
void
main(int argc, char *argv[])
{
    char *cp;

    Binit(&bout, 1, OWRITE);
    if(argc < 3)
        usage();
    for (cp = argv[1]; *cp; cp++) {
        switch(*cp) {
        case 'a':	aflag = 1;	break;
        case 'b':	bflag = 1;	break;
        case 'c':	cflag = 1;	break;
        case 'd':	setcom(dcmd);	break;
        case 'i':	bflag = 1;	break;
        case 'l':
                strcpy(artemp, "vXXXXX");
                strcpy(movtemp, "v1XXXXX");
                strcpy(tailtemp, "v2XXXXX");
                break;
        case 'm':	setcom(mcmd);	break;
        case 'o':	oflag = 1;	break;
        case 'p':	setcom(pcmd);	break;
        case 'q':	setcom(qcmd);	break;
        case 'r':	setcom(rcmd);	break;
        case 't':	setcom(tcmd);	break;
        case 'u':	uflag = 1;	break;
        case 'v':	vflag = 1;	break;
        case 'x':	setcom(xcmd);	break;
        default:
            fprint(2, "ar: bad option `%c'\n", *cp);
            exits("error");
        }
    }
    if (aflag && bflag) {
        fprint(2, "ar: only one of 'a' and 'b' can be specified\n");
        usage();
    }
    if(aflag || bflag) {
        trim(argv[2], poname, sizeof(poname));
        argv++;
        argc--;
        if(argc < 3)
            usage();
    }
    if(comfun == 0) {
        if(uflag == 0) {
            fprint(2, "ar: one of [%s] must be specified\n", man);
            usage();
        }
        setcom(rcmd);
    }
    cp = argv[2];
    argc -= 3;
    argv += 3;
    (*comfun)(cp, argc, argv);	/* do the command */
    cp = 0;
    while (argc--) {
        if (*argv) {
            fprint(2, "ar: %s not found\n", *argv);
            cp = "error";
        }
        argv++;
    }
    exits(cp);
}
@

<<function setcom>>=
/*
 *	select a command
 */
void
setcom(void (*fun)(char *, int, char**))
{

    if(comfun != 0) {
        fprint(2, "ar: only one of [%s] allowed\n", man);
        usage();
    }
    comfun = fun;
}
@

<<function rcmd>>=
/*
 *	perform the 'r' and 'u' commands
 */
void
rcmd(char *arname, int count, char **files)
{
    int fd;
    int i;
    Arfile *ap;
    Armember *bp;
    Dir *d;
    Biobuf *bfile;

    fd = openar(arname, ORDWR, 1);
    if (fd >= 0) {
        Binit(&bar, fd, OREAD);
        Bseek(&bar,seek(fd,0,1), 1);
    }
    astart = newtempfile(artemp);
    ap = astart;
    aend = 0;
    for(i = 0; fd >= 0; i++) {
        bp = getdir(&bar);
        if (!bp)
            break;
        if (bamatch(file, poname)) {		/* check for pivot */
            aend = newtempfile(tailtemp);
            ap = aend;
        }
            /* pitch symdef file */
        if (i == 0 && strcmp(file, symdef) == 0) {
            skip(&bar, bp->size);
            continue;
        }
        if (count && !match(count, files)) {
            scanobj(&bar, ap, bp->size);
            arcopy(&bar, ap, bp);
            continue;
        }
        bfile = Bopen(file, OREAD);
        if (!bfile) {
            if (count != 0)
                fprint(2, "ar: cannot open %s\n", file);
            scanobj(&bar, ap, bp->size);
            arcopy(&bar, ap, bp);
            continue;
        }
        d = dirfstat(Bfildes(bfile));
        if(d == nil)
            fprint(2, "ar: cannot stat %s: %r\n", file);
        if (uflag && (d==nil || d->mtime <= bp->date)) {
            scanobj(&bar, ap, bp->size);
            arcopy(&bar, ap, bp);
            Bterm(bfile);
            free(d);
            continue;
        }
        mesg('r', file);
        skip(&bar, bp->size);
        scanobj(bfile, ap, d->length);
        free(d);
        armove(bfile, ap, bp);
        Bterm(bfile);
    }
    if(fd >= 0)
        close(fd);
        /* copy in remaining files named on command line */
    for (i = 0; i < count; i++) {
        file = files[i];
        if(file == 0)
            continue;
        files[i] = 0;
        bfile = Bopen(file, OREAD);
        if (!bfile)
            fprint(2, "ar: %s cannot open\n", file);
        else {
            mesg('a', file);
            d = dirfstat(Bfildes(bfile));
            if (d == nil)
                fprint(2, "can't stat %s\n", file);
            else {
                scanobj(bfile, astart, d->length);
                armove(bfile, astart, newmember());
                free(d);
            }
            Bterm(bfile);
        }
    }
    if(fd < 0 && !cflag)
        install(arname, astart, 0, aend, 1);	/* issue 'creating' msg */
    else
        install(arname, astart, 0, aend, 0);
}
@

<<function dcmd>>=
void
dcmd(char *arname, int count, char **files)
{
    Armember *bp;
    int fd, i;

    if (!count)
        return;
    fd = openar(arname, ORDWR, 0);
    Binit(&bar, fd, OREAD);
    Bseek(&bar,seek(fd,0,1), 1);
    astart = newtempfile(artemp);
    for (i = 0; bp = getdir(&bar); i++) {
        if(match(count, files)) {
            mesg('d', file);
            skip(&bar, bp->size);
            if (strcmp(file, symdef) == 0)
                allobj = 0;
        } else if (i == 0 && strcmp(file, symdef) == 0)
                skip(&bar, bp->size);
        else {
            scanobj(&bar, astart, bp->size);
            arcopy(&bar, astart, bp);
        }
    }
    close(fd);
    install(arname, astart, 0, 0, 0);
}
@

<<function xcmd>>=
void
xcmd(char *arname, int count, char **files)
{
    int fd, f, mode, i;
    Armember *bp;
    Dir dx;

    fd = openar(arname, OREAD, 0);
    Binit(&bar, fd, OREAD);
    Bseek(&bar,seek(fd,0,1), 1);
    i = 0;
    while (bp = getdir(&bar)) {
        if(count == 0 || match(count, files)) {
            mode = strtoul(bp->hdr.mode, 0, 8) & 0777;
            f = create(file, OWRITE, mode);
            if(f < 0) {
                fprint(2, "ar: %s cannot create\n", file);
                skip(&bar, bp->size);
            } else {
                mesg('x', file);
                arcopy(&bar, 0, bp);
                if (write(f, bp->member, bp->size) < 0)
                    wrerr();
                if(oflag) {
                    nulldir(&dx);
                    dx.atime = bp->date;
                    dx.mtime = bp->date;
                    if(dirwstat(file, &dx) < 0)
                        perror(file);
                }
                free(bp->member);
                close(f);
            }
            free(bp);
            if (count && ++i >= count)
                break;
        } else {
            skip(&bar, bp->size);
            free(bp);
        }
    }
    close(fd);
}
@

<<function pcmd>>=
void
pcmd(char *arname, int count, char **files)
{
    int fd;
    Armember *bp;

    fd = openar(arname, OREAD, 0);
    Binit(&bar, fd, OREAD);
    Bseek(&bar,seek(fd,0,1), 1);
    while(bp = getdir(&bar)) {
        if(count == 0 || match(count, files)) {
            if(vflag)
                print("\n<%s>\n\n", file);
            arcopy(&bar, 0, bp);
            if (write(1, bp->member, bp->size) < 0)
                wrerr();
        } else
            skip(&bar, bp->size);
        free(bp);
    }
    close(fd);
}
@

<<function mcmd>>=
void
mcmd(char *arname, int count, char **files)
{
    int fd, i;
    Arfile *ap;
    Armember *bp;

    if (count == 0)
        return;
    fd = openar(arname, ORDWR, 0);
    Binit(&bar, fd, OREAD);
    Bseek(&bar,seek(fd,0,1), 1);
    astart = newtempfile(artemp);
    amiddle = newtempfile(movtemp);
    aend = 0;
    ap = astart;
    for (i = 0; bp = getdir(&bar); i++) {
        if (bamatch(file, poname)) {
            aend = newtempfile(tailtemp);
            ap = aend;
        }
        if(match(count, files)) {
            mesg('m', file);
            scanobj(&bar, amiddle, bp->size);
            arcopy(&bar, amiddle, bp);
        } else
            /*
             * pitch the symdef file if it is at the beginning
             * of the archive and we aren't inserting in front
             * of it (ap == astart).
             */
        if (ap == astart && i == 0 && strcmp(file, symdef) == 0)
            skip(&bar, bp->size);
        else {
            scanobj(&bar, ap, bp->size);
            arcopy(&bar, ap, bp);
        }
    }
    close(fd);
    if (poname[0] && aend == 0)
        fprint(2, "ar: %s not found - files moved to end.\n", poname);
    install(arname, astart, amiddle, aend, 0);
}
@

<<function tcmd>>=
void
tcmd(char *arname, int count, char **files)
{
    int fd;
    Armember *bp;
    char name[ARNAMESIZE+1];

    fd = openar(arname, OREAD, 0);
    Binit(&bar, fd, OREAD);
    Bseek(&bar,seek(fd,0,1), 1);
    while(bp = getdir(&bar)) {
        if(count == 0 || match(count, files)) {
            if(vflag)
                longt(bp);
            trim(file, name, ARNAMESIZE);
            Bprint(&bout, "%s\n", name);
        }
        skip(&bar, bp->size);
        free(bp);
    }
    close(fd);
}
@

<<function qcmd>>=
void
qcmd(char *arname, int count, char **files)
{
    int fd, i;
    Armember *bp;
    Biobuf *bfile;

    if(aflag || bflag) {
        fprint(2, "ar: abi not allowed with q\n");
        exits("error");
    }
    fd = openar(arname, ORDWR, 1);
    if (fd < 0) {
        if(!cflag)
            fprint(2, "ar: creating %s\n", arname);
        fd = arcreate(arname);
    }
    Binit(&bar, fd, OREAD);
    Bseek(&bar,seek(fd,0,1), 1);
    /* leave note group behind when writing archive; i.e. sidestep interrupts */
    rfork(RFNOTEG);
    Bseek(&bar, 0, 2);
    bp = newmember();
    for(i=0; i<count && files[i]; i++) {
        file = files[i];
        files[i] = 0;
        bfile = Bopen(file, OREAD);
        if(!bfile)
            fprint(2, "ar: %s cannot open\n", file);
        else {
            mesg('q', file);
            armove(bfile, 0, bp);
            if (!arwrite(fd, bp))
                wrerr();
            free(bp->member);
            bp->member = 0;
            Bterm(bfile);
        }
    }
    free(bp);
    close(fd);
}
@

<<function scanobj>>=
/*
 *	extract the symbol references from an object file
 */
void
scanobj(Biobuf *b, Arfile *ap, long size)
{
    int obj;
    vlong offset;
    Dir *d;
    static int lastobj = -1;

    if (!allobj)			/* non-object file encountered */
        return;
    offset = Boffset(b);
    obj = objtype(b, 0);
    if (obj < 0) {			/* not an object file */
        allobj = 0;
        d = dirfstat(Bfildes(b));
        if (d != nil && d->length == 0)
            fprint(2, "ar: zero length file %s\n", file);
        free(d);
        Bseek(b, offset, 0);
        return;
    }
    if (lastobj >= 0 && obj != lastobj) {
        fprint(2, "ar: inconsistent object file %s\n", file);
        allobj = 0;
        Bseek(b, offset, 0);
        return;
    }
    lastobj = obj;
    if (!readar(b, obj, offset+size, 0)) {
        fprint(2, "ar: invalid symbol reference in file %s\n", file);
        allobj = 0;
        Bseek(b, offset, 0);
        return;
    }
    Bseek(b, offset, 0);
    objtraverse(objsym, ap);
}
@

<<function objsym>>=
/*
 *	add text and data symbols to the symbol list
 */
void
objsym(Sym *s, void *p)
{
    int n;
    Arsymref *as;
    Arfile *ap;

    if (s->type != 'T' &&  s->type != 'D')
        return;
    ap = (Arfile*)p;
    as = (Arsymref*)armalloc(sizeof(Arsymref));
    as->offset = ap->size;
    n = strlen(s->name);
    as->name = armalloc(n+1);
    strcpy(as->name, s->name);
    if(s->type == 'T' && duplicate(as->name)) {
        dupfound = 1;
        fprint(2, "duplicate text symbol: %s\n", as->name);
        free(as->name);
        free(as);
        return;
    }
    as->type = s->type;
    symdefsize += 4+(n+1)+1;
    as->len = n;
    as->next = ap->sym;
    ap->sym = as;
}
@

<<function duplicate>>=
/*
 *	Check the symbol table for duplicate text symbols
 */
int
duplicate(char *name)
{
    Hashchain *p;
    char *cp;
    int h;

    h = 0;
    for(cp = name; *cp; h += *cp++)
        h *= 1119;
    if(h < 0)
        h = ~h;
    h %= NHASH;

    for(p = hash[h]; p; p = p->next)
        if(strcmp(p->name, name) == 0)
            return 1;
    p = (Hashchain*) armalloc(sizeof(Hashchain));
    p->next = hash[h];
    p->name = name;
    hash[h] = p;
    return 0;
}
@

<<function openar>>=
/*
 *	open an archive and validate its header
 */
int
openar(char *arname, int mode, int errok)
{
    int fd;
    char mbuf[SARMAG];

    fd = open(arname, mode);
    if(fd >= 0){
        if(read(fd, mbuf, SARMAG) != SARMAG || strncmp(mbuf, ARMAG, SARMAG)) {
            fprint(2, "ar: %s not in archive format\n", arname);
            exits("error");
        }
    }else if(!errok){
        fprint(2, "ar: cannot open %s: %r\n", arname);
        exits("error");
    }
    return fd;
}
@

<<function arcreate>>=
/*
 *	create an archive and set its header
 */
int
arcreate(char *arname)
{
    int fd;

    fd = create(arname, OWRITE, 0664);
    if(fd < 0){
        fprint(2, "ar: cannot create %s: %r\n", arname);
        exits("error");
    }
    if(write(fd, ARMAG, SARMAG) != SARMAG)
        wrerr();
    return fd;
}
@

<<function wrerr>>=
/*
 *		error handling
 */
void
wrerr(void)
{
    perror("ar: write error");
    exits("error");
}
@

<<function rderr>>=
void
rderr(void)
{
    perror("ar: read error");
    exits("error");
}
@

<<function phaseerr>>=
void
phaseerr(int offset)
{
    fprint(2, "ar: phase error at offset %d\n", offset);
    exits("error");
}
@

<<function usage>>=
static void
usage(void)
{
    fprint(2, "usage: ar [%s][%s] archive files ...\n", opt, man);
    exits("error");
}
@

<<function getdir>>=
/*
 *	read the header for the next archive member
 */
Armember *
getdir(Biobuf *b)
{
    Armember *bp;
    char *cp;
    static char name[ARNAMESIZE+1];

    bp = newmember();
    if(HEADER_IO(Bread, b, bp->hdr)) {
        free(bp);
        return 0;
    }
    if(strncmp(bp->hdr.fmag, ARFMAG, sizeof(bp->hdr.fmag)) != 0)
        phaseerr(Boffset(b));
    strncpy(name, bp->hdr.name, sizeof(bp->hdr.name));
    cp = name+sizeof(name)-1;
    *cp = '\0';
    /* skip trailing spaces and (gnu-produced) slashes */
    while(*--cp == ' ' || *cp == '/')
        ;
    cp[1] = '\0';
    file = name;
    bp->date = strtol(bp->hdr.date, 0, 0);
    bp->size = strtol(bp->hdr.size, 0, 0);
    return bp;
}
@

<<function armove>>=
/*
 *	Copy the file referenced by fd to the temp file
 */
void
armove(Biobuf *b, Arfile *ap, Armember *bp)
{
    char *cp;
    Dir *d;

    d = dirfstat(Bfildes(b));
    if (d == nil) {
        fprint(2, "ar: cannot stat %s\n", file);
        return;
    }
    trim(file, bp->hdr.name, sizeof(bp->hdr.name));
    for (cp = strchr(bp->hdr.name, 0);		/* blank pad on right */
        cp < bp->hdr.name+sizeof(bp->hdr.name); cp++)
            *cp = ' ';
    sprint(bp->hdr.date, "%-12ld", d->mtime);
    sprint(bp->hdr.uid, "%-6d", 0);
    sprint(bp->hdr.gid, "%-6d", 0);
    sprint(bp->hdr.mode, "%-8lo", d->mode);
    sprint(bp->hdr.size, "%-10lld", d->length);
    strncpy(bp->hdr.fmag, ARFMAG, 2);
    bp->size = d->length;
    arread(b, bp, bp->size);
    if (d->length&0x01)
        d->length++;
    if (ap) {
        arinsert(ap, bp);
        ap->size += d->length+SAR_HDR;
    }
    free(d);
}
@

<<function arcopy>>=
/*
 *	Copy the archive member at the current offset into the temp file.
 */
void
arcopy(Biobuf *b, Arfile *ap, Armember *bp)
{
    long n;

    n = bp->size;
    if (n & 01)
        n++;
    arread(b, bp, n);
    if (ap) {
        arinsert(ap, bp);
        ap->size += n+SAR_HDR;
    }
}
@

<<function skip>>=
/*
 *	Skip an archive member
 */
void
skip(Biobuf *bp, vlong len)
{
    if (len & 01)
        len++;
    Bseek(bp, len, 1);
}
@

<<function install>>=
/*
 *	Stream the three temp files to an archive
 */
void
install(char *arname, Arfile *astart, Arfile *amiddle, Arfile *aend, int createflag)
{
    int fd;

    if(allobj && dupfound) {
        fprint(2, "%s not changed\n", arname);
        return;
    }
    /* leave note group behind when copying back; i.e. sidestep interrupts */
    rfork(RFNOTEG);

    if(createflag)
        fprint(2, "ar: creating %s\n", arname);
    fd = arcreate(arname);

    if(allobj)
        rl(fd);

    if (astart) {
        arstream(fd, astart);
        arfree(astart);
    }
    if (amiddle) {
        arstream(fd, amiddle);
        arfree(amiddle);
    }
    if (aend) {
        arstream(fd, aend);
        arfree(aend);
    }
    close(fd);
}
@

<<function rl>>=
void
rl(int fd)
{

    Biobuf b;
    char *cp;
    struct ar_hdr a;
    long len;

    Binit(&b, fd, OWRITE);
    Bseek(&b,seek(fd,0,1), 0);

    len = symdefsize;
    if(len&01)
        len++;
    sprint(a.date, "%-12ld", time(0));
    sprint(a.uid, "%-6d", 0);
    sprint(a.gid, "%-6d", 0);
    sprint(a.mode, "%-8lo", 0644L);
    sprint(a.size, "%-10ld", len);
    strncpy(a.fmag, ARFMAG, 2);
    strcpy(a.name, symdef);
    for (cp = strchr(a.name, 0);		/* blank pad on right */
        cp < a.name+sizeof(a.name); cp++)
            *cp = ' ';
    if(HEADER_IO(Bwrite, &b, a))
            wrerr();

    len += Boffset(&b);
    if (astart) {
        wrsym(&b, len, astart->sym);
        len += astart->size;
    }
    if(amiddle) {
        wrsym(&b, len, amiddle->sym);
        len += amiddle->size;
    }
    if(aend)
        wrsym(&b, len, aend->sym);

    if(symdefsize&0x01)
        Bputc(&b, 0);
    Bterm(&b);
}
@

<<function wrsym>>=
/*
 *	Write the defined symbols to the symdef file
 */
void
wrsym(Biobuf *bp, long offset, Arsymref *as)
{
    int off;

    while(as) {
        Bputc(bp, as->type);
        off = as->offset+offset;
        Bputc(bp, off);
        Bputc(bp, off>>8);
        Bputc(bp, off>>16);
        Bputc(bp, off>>24);
        if (Bwrite(bp, as->name, as->len+1) != as->len+1)
            wrerr();
        as = as->next;
    }
}
@

<<function match>>=
/*
 *	Check if the archive member matches an entry on the command line.
 */
int
match(int count, char **files)
{
    int i;
    char name[ARNAMESIZE+1];

    for(i=0; i<count; i++) {
        if(files[i] == 0)
            continue;
        trim(files[i], name, ARNAMESIZE);
        if(strncmp(name, file, ARNAMESIZE) == 0) {
            file = files[i];
            files[i] = 0;
            return 1;
        }
    }
    return 0;
}
@

<<function bamatch>>=
/*
 *	compare the current member to the name of the pivot member
 */
int
bamatch(char *file, char *pivot)
{
    static int state = 0;

    switch(state)
    {
    case 0:			/* looking for position file */
        if (aflag) {
            if (strncmp(file, pivot, ARNAMESIZE) == 0)
                state = 1;
        } else if (bflag) {
            if (strncmp(file, pivot, ARNAMESIZE) == 0) {
                state = 2;	/* found */
                return 1;
            }
        }
        break;
    case 1:			/* found - after previous file */
        state = 2;
        return 1;
    case 2:			/* already found position file */
        break;
    }
    return 0;
}
@

<<function mesg>>=
/*
 *	output a message, if 'v' option was specified
 */
void
mesg(int c, char *file)
{

    if(vflag)
        Bprint(&bout, "%c - %s\n", c, file);
}
@

<<function trim>>=
/*
 *	isolate file name by stripping leading directories and trailing slashes
 */
void
trim(char *s, char *buf, int n)
{
    char *p;

    for(;;) {
        p = strrchr(s, '/');
        if (!p) {		/* no slash in name */
            strncpy(buf, s, n);
            return;
        }
        if (p[1] != 0) {	/* p+1 is first char of file name */
            strncpy(buf, p+1, n);
            return;
        }
        *p = 0;			/* strip trailing slash */
    }
}
@

<<constant SUID>>=
/*
 *	utilities for printing long form of 't' command
 */
#define	SUID	04000
@

<<constant SGID>>=
#define	SGID	02000
@

<<constant ROWN>>=
#define	ROWN	0400
@

<<constant WOWN>>=
#define	WOWN	0200
@

<<constant XOWN>>=
#define	XOWN	0100
@

<<constant RGRP>>=
#define	RGRP	040
@

<<constant WGRP>>=
#define	WGRP	020
@

<<constant XGRP>>=
#define	XGRP	010
@

<<constant ROTH>>=
#define	ROTH	04
@

<<constant WOTH>>=
#define	WOTH	02
@

<<constant XOTH>>=
#define	XOTH	01
@

<<constant STXT>>=
#define	STXT	01000
@

<<function longt>>=
void
longt(Armember *bp)
{
    char *cp;

    pmode(strtoul(bp->hdr.mode, 0, 8));
    Bprint(&bout, "%3ld/%1ld", strtol(bp->hdr.uid, 0, 0), strtol(bp->hdr.gid, 0, 0));
    Bprint(&bout, "%7ld", bp->size);
    cp = ctime(bp->date);
    Bprint(&bout, " %-12.12s %-4.4s ", cp+4, cp+24);
}
@

<<global m1>>=
int	m1[] = { 1, ROWN, 'r', '-' };
@

<<global m2>>=
int	m2[] = { 1, WOWN, 'w', '-' };
@

<<global m3>>=
int	m3[] = { 2, SUID, 's', XOWN, 'x', '-' };
@

<<global m4>>=
int	m4[] = { 1, RGRP, 'r', '-' };
@

<<global m5>>=
int	m5[] = { 1, WGRP, 'w', '-' };
@

<<global m6>>=
int	m6[] = { 2, SGID, 's', XGRP, 'x', '-' };
@

<<global m7>>=
int	m7[] = { 1, ROTH, 'r', '-' };
@

<<global m8>>=
int	m8[] = { 1, WOTH, 'w', '-' };
@

<<global m9>>=
int	m9[] = { 2, STXT, 't', XOTH, 'x', '-' };
@

<<global m>>=
int	*m[] = { m1, m2, m3, m4, m5, m6, m7, m8, m9};
@

<<function pmode>>=
void
pmode(long mode)
{
    int **mp;

    for(mp = &m[0]; mp < &m[9];)
        select(*mp++, mode);
}
@

<<function select>>=
void
select(int *ap, long mode)
{
    int n;

    n = *ap++;
    while(--n>=0 && (mode & (*ap++))==0)
        ap++;
    Bputc(&bout, *ap);
}
@

<<function newtempfile>>=
/*
 *	Temp file I/O subsystem.  We attempt to cache all three temp files in
 *	core.  When we run out of memory we spill to disk.
 *	The I/O model assumes that temp files:
 *		1) are only written on the end
 *		2) are only read from the beginning
 *		3) are only read after all writing is complete.
 *	The architecture uses one control block per temp file.  Each control
 *	block anchors a chain of buffers, each containing an archive member.
 */
Arfile *
newtempfile(char *name)		/* allocate a file control block */
{
    Arfile *ap;

    ap = (Arfile *) armalloc(sizeof(Arfile));
    ap->fname = name;
    return ap;
}
@

<<function newmember>>=
Armember *
newmember(void)			/* allocate a member buffer */
{
    return (Armember *)armalloc(sizeof(Armember));
}
@

<<function arread>>=
void
arread(Biobuf *b, Armember *bp, int n)	/* read an image into a member buffer */
{
    int i;

    bp->member = armalloc(n);
    i = Bread(b, bp->member, n);
    if (i < 0) {
        free(bp->member);
        bp->member = 0;
        rderr();
    }
}
@

<<function arinsert>>=
/*
 * insert a member buffer into the member chain
 */
void
arinsert(Arfile *ap, Armember *bp)
{
    bp->next = 0;
    if (!ap->tail)
        ap->head = bp;
    else
        ap->tail->next = bp;
    ap->tail = bp;
}
@

<<function arstream>>=
/*
 *	stream the members in a temp file to the file referenced by 'fd'.
 */
void
arstream(int fd, Arfile *ap)
{
    Armember *bp;
    int i;
    char buf[8192];

    if (ap->paged) {		/* copy from disk */
        seek(ap->fd, 0, 0);
        for (;;) {
            i = read(ap->fd, buf, sizeof(buf));
            if (i < 0)
                rderr();
            if (i == 0)
                break;
            if (write(fd, buf, i) != i)
                wrerr();
        }
        close(ap->fd);
        ap->paged = 0;
    }
        /* dump the in-core buffers */
    for (bp = ap->head; bp; bp = bp->next) {
        if (!arwrite(fd, bp))
            wrerr();
    }
}
@

<<function arwrite>>=
/*
 *	write a member to 'fd'.
 */
int
arwrite(int fd, Armember *bp)
{
    int len;

    if(HEADER_IO(write, fd, bp->hdr))
        return 0;
    len = bp->size;
    if (len & 01)
        len++;
    if (write(fd, bp->member, len) != len)
        return 0;
    return 1;
}
@

<<function page>>=
/*
 *	Spill a member to a disk copy of a temp file
 */
int
page(Arfile *ap)
{
    Armember *bp;

    bp = ap->head;
    if (!ap->paged) {		/* not yet paged - create file */
        ap->fname = mktemp(ap->fname);
        ap->fd = create(ap->fname, ORDWR|ORCLOSE, 0600);
        if (ap->fd < 0) {
            fprint(2,"ar: can't create temp file\n");
            return 0;
        }
        ap->paged = 1;
    }
    if (!arwrite(ap->fd, bp))	/* write member and free buffer block */
        return 0;
    ap->head = bp->next;
    if (ap->tail == bp)
        ap->tail = bp->next;
    free(bp->member);
    free(bp);
    return 1;
}
@

<<function getspace>>=
/*
 *	try to reclaim space by paging.  we try to spill the start, middle,
 *	and end files, in that order.  there is no particular reason for the
 *	ordering.
 */
int
getspace(void)
{
    if (astart && astart->head && page(astart))
            return 1;
    if (amiddle && amiddle->head && page(amiddle))
            return 1;
    if (aend && aend->head && page(aend))
            return 1;
    return 0;
}
@

<<function arfree>>=
void
arfree(Arfile *ap)		/* free a member buffer */
{
    Armember *bp, *next;

    for (bp = ap->head; bp; bp = next) {
        next = bp->next;
        if (bp->member)
            free(bp->member);
        free(bp);
    }
    free(ap);
}
@

<<function armalloc>>=
/*
 *	allocate space for a control block or member buffer.  if the malloc
 *	fails we try to reclaim space by spilling previously allocated
 *	member buffers.
 */
char *
armalloc(int n)
{
    char *cp;

    do {
        cp = malloc(n);
        if (cp) {
            memset(cp, 0, n);
            return cp;
        }
    } while (getspace());
    fprint(2, "ar: out of memory\n");
    exits("malloc");
    return 0;
}
@

\fi

%%%\chapter{[[5l]] in OCaml}
%%%\label{chap:5l-ocaml}

% yeah!!

% design decisions (dup partially with Assembler): 
% - no optimisations, space or speed, which guides many of the
%   other decisions below.
% - object file is marshalled form of ocaml AST. Far simpler!
%   (but less open to other languages; could use JSON but no ADT in JSON)
% - TODO symbol table and file/line table in executable are also
%   marshalled data? not efficient enough? bench speed/size?
% This decrements size of code, but also size of needed explanations!








\chapter{Extra Code}

\ifallcode
#include "Linker_extra.nw"
#include "Linker_x86.nw"
\fi

%\chapter{Changelog}
% code via make loc = 9700 LOC
% orig Linker.nw = 11 340, just lpized and few comments, 101 pages pdf
% (but there was not strip/nm/ar code yet. When I did it added 18 pages in pdf)
% now: 21000 LOC so added 10000 LOE (Lines of explanations)
% 5l in ocaml: 1700 LOC (but incomplete, miss debugging/profiling/adv-features)

\chapter*{Glossary}
\addcontentsline{toc}{chapter}{Glossary}
\label{sec:glossary}

\begin{verbatim}
LDR = LoaD Register
STR = STore Register
ARM = Acorn RISC Machine
RISC = Reduced Instruction Set Computer
CISC = Complex Instruction Set Computer
PC = Program Counter
SB = Static Base register
SP = Stack Pointer
FP = Frame Pointer
\end{verbatim}



\chapter*{Indexes}
\addcontentsline{toc}{chapter}{Index}

%\chapter{References} 
\addcontentsline{toc}{chapter}{References}

\bibliography{../docs/latex/Principia}
\bibliographystyle{alpha}

%******************************************************************************
% Postlude
%******************************************************************************

\end{document}
