\section{x86}


% ----------------------------------------------------------
% x86 only now
<<[[Sym]] other fields>>=
// x86 only, dead? can remove though?
short	become;
@
<<[[Sym]] other fields>>=
// x86 only
short	frame;
@

% ----------------------------------------------------------




<<enum headtype(x86)>>=
/*
 *	-H0 -T0x40004C -D0x10000000	is garbage unix
 *	-H1 -T0xd0 -R4			is unix coff
 *	-H2 -T4128 -R4096		is plan9 format
 *	-H3 -Tx -Rx			is MS-DOS .COM
 *	-H4 -Tx -Rx			is fake MS-DOS .EXE
 *	-H5 -T0x80100020 -R4096		is ELF
 */
enum headtype {
    H_GARBAGE = 0,
    H_COFF = 1,
    H_PLAN9 = 2, // default
    H_COM = 3,
    H_EXE = 4,
    H_ELF = 5,
};
@


<<enum sxxx(x86)>>=
enum section
{
    SNONE		= 0,
    STEXT		= 1,
    SDATA,
    SBSS,

    SDATA1,
    SXREF, // means not defined (yet)
    SFILE,
    SCONST,
    SUNDEF,

    SIMPORT,
    SEXPORT,
};
@


<<struct Prog(x86)>>=
struct	Prog
{
    //enum<opcode>
    short	as;

    // operands
    Adr	from;
    Adr	to;

    // [[Prog]] other fields
    // 2 by default in zprg, why?
    byte	back;

    Prog*	forwd;
    long	pc;
    long	line;
    char	width;		/* fake for DATA */
    char	ft;		/* oclass cache */
    char	tt;
    byte	mark;	/* work on these */

    // [[Prog]] Extra fields

    // list<ref<Prog>> from firstp/lastp, or datap/edatap
    Prog*	link;

    // list<ref<Prog>> from textp/etextp, to follow CALL xxx
    Prog*	pcond;	/* work on this */

};
@
% see Pconv, %P




% todo could use a queue data structure, so have fast access to end of list?
<<global edatap(x86)>>=
// ref<Prog>>, end of datap list
Prog*	edatap = P;
@

<<constant TNAME(x86)>>=
#define	TNAME		(curtext ? curtext->from.sym->name : noname)
@


<<struct Adr(x86)>>=
struct	Adr
{
    //enum<operand_kind> (D_NONE by default)
    short	type;

    union
    {
        long	u0offset;
        char	u0scon[8];
        Prog	*u0cond;	/* not used, but should be D_BRANCH */
        Ieee	u0ieee;
    } u0;

    union
    {
        Auto*	u1autom;
        Sym*	u1sym;
    } u1;

    //enum<operand_kind(register-only|D_NONE)>
    byte	index;

    // TODO: abused for NOPROF function attributes
    char	scale; // offset * scale give size of entity?
};
@



% ??
<<constant scon(x86)>>=
#define	scon	u0.u0scon
@

<<constant cond(x86)>>=
#define	cond	u0.u0cond
@


% ???
<<struct Auto(x86)>>=
struct	Auto
{
    Sym*	asym;

    long	aoffset;
    short	type;

    // Extra
    Auto*	link;
};
@

<<struct Optab(x86)>>=
struct	Optab
{
    // enum<as> from 8.out.h
    short	as;

    byte*	ytab;

    // enum<Pxxx>
    byte	prefix;
    // the actual x86 machine code for instruction optab.as
    byte	op[10];
};
@


<<function brloop(x86)>>=
Prog*
brloop(Prog *p)
{
    int c;
    Prog *q;

    c = 0;
    for(q = p; q != P; q = q->pcond) {
        if(q->as != AJMP)
            break;
        c++;
        if(c >= 5000)
            return P;
    }
    return q;
}
@


% unused for ARM
<<function copyp>>=
Prog*
copyp(Prog *q)
{
    Prog *p;

    p = prg();
    *p = *q;
    return p;
}
@

<<function xfol(x86)>>=
void
xfol(Prog *p)
{
    Prog *q;
    int i;
    enum as a;

loop:
    if(p == P)
        return;
    if(p->as == ATEXT)
        curtext = p;
    if(p->as == AJMP)
    if((q = p->pcond) != P) {
        p->mark = 1;
        p = q;
        if(p->mark == 0)
            goto loop;
    }
    if(p->mark) {
        /* copy up to 4 instructions to avoid branch */
        for(i=0,q=p; i<4; i++,q=q->link) {
            if(q == P)
                break;
            if(q == lastp)
                break;
            a = q->as;
            if(a == ANOP) {
                i--;
                continue;
            }
            switch(a) {
            case AJMP:
            case ARET:
            case AIRETL:

            case APUSHL:
            case APUSHFL:
            case APUSHW:
            case APUSHFW:
            case APOPL:
            case APOPFL:
            case APOPW:
            case APOPFW:
                goto brk;
            }
            if(q->pcond == P || q->pcond->mark)
                continue;
            if(a == ACALL || a == ALOOP)
                continue;
            for(;;) {
                if(p->as == ANOP) {
                    p = p->link;
                    continue;
                }
                q = copyp(p);
                p = p->link;
                q->mark = 1;
                lastp->link = q;
                lastp = q;
                if(q->as != a || q->pcond == P || q->pcond->mark)
                    continue;

                q->as = relinv(q->as);
                p = q->pcond;
                q->pcond = q->link;
                q->link = p;
                xfol(q->link);
                p = q->link;
                if(p->mark)
                    return;
                goto loop;
            }
        } /* */
    brk:;
        q = prg();
        q->as = AJMP;
        q->line = p->line;
        q->to.type = D_BRANCH;
        q->to.offset = p->pc;
        q->pcond = p;
        p = q;
    }
    p->mark = 1;
    lastp->link = p;
    lastp = p;
    a = p->as;
    if(a == AJMP || a == ARET || a == AIRETL)
        return;
    if(p->pcond != P)
    if(a != ACALL) {
        q = brchain(p->link);
        if(q != P && q->mark)
        if(a != ALOOP) {
            p->as = relinv(a);
            p->link = p->pcond;
            p->pcond = q;
        }
        xfol(p->link);
        q = brchain(p->pcond);
        if(q->mark) {
            p->pcond = q;
            return;
        }
        p = q;
        goto loop;
    }

    p = p->link;
    goto loop;
}
@

<<function relinv(x86)>>=
int
relinv(int a)
{

    switch(a) {
    case AJEQ:	return AJNE;
    case AJNE:	return AJEQ;
    case AJLE:	return AJGT;
    case AJLS:	return AJHI;
    case AJLT:	return AJGE;
    case AJMI:	return AJPL;
    case AJGE:	return AJLT;
    case AJPL:	return AJMI;
    case AJGT:	return AJLE;
    case AJHI:	return AJLS;
    case AJCS:	return AJCC;
    case AJCC:	return AJCS;
    case AJPS:	return AJPC;
    case AJPC:	return AJPS;
    case AJOS:	return AJOC;
    case AJOC:	return AJOS;
    }
    diag("unknown relation: %s in %s", anames[a], TNAME);
    return a;
}
@

<<function brchain(x86)>>=
Prog*
brchain(Prog *p)
{
    int i;

    for(i=0; i<20; i++) {
        if(p == P || p->as != AJMP)
            return p;
        p = p->pcond;
    }
    return P;
}
@

<<function xdefine(x86)>>=
void
xdefine(char *p, int t, long v)
{
    Sym *s;

    s = lookup(p, 0);
    if(s->type == 0 || s->type == SXREF) {
        s->type = t;
        s->value = v;
    }
    if(s->type == STEXT && s->value == 0)
        s->value = v;
}
@

%\section{[[dostkoff()]]}

% do stack offset?
<<function dostkoff(x86)>>=
void
dostkoff(void)
{
    Prog *p, *q;
    long autoffset, deltasp;
    int a, f, curframe, curbecome, maxbecome;

    curframe = 0;
    curbecome = 0;
    maxbecome = 0;
    curtext = nil;

    for(p = firstp; p != P; p = p->link) {

        /* find out how much arg space is used in this TEXT */
        if(p->to.type == (D_INDIR+D_SP))
            if(p->to.offset > curframe)
                curframe = p->to.offset;

        switch(p->as) {
        case ATEXT:
            if(curtext && curtext->from.sym) {
                curtext->from.sym->frame = curframe;
                curtext->from.sym->become = curbecome;
                if(curbecome > maxbecome)
                    maxbecome = curbecome;
            }
            curframe = 0;
            curbecome = 0;

            curtext = p;
            break;

        case ARET:
            /* special form of RET is BECOME */
            if(p->from.type == D_CONST)
                if(p->from.offset > curbecome)
                    curbecome = p->from.offset;
            break;
        }
    }
    if(curtext && curtext->from.sym) {
        curtext->from.sym->frame = curframe;
        curtext->from.sym->become = curbecome;
        if(curbecome > maxbecome)
            maxbecome = curbecome;
    }

    if(debug['b'])
        print("max become = %d\n", maxbecome);

    xdefine("ALEFbecome", STEXT, maxbecome);

    curtext = nil;

    for(p = firstp; p != P; p = p->link) {
        switch(p->as) {
        case ATEXT:
            curtext = p;
            break;
        case ACALL:
            if(curtext != P && curtext->from.sym != S && curtext->to.offset >= 0) {
                f = maxbecome - curtext->from.sym->frame;
                if(f <= 0)
                    break;
                /* calling a become or calling a variable */
                if(p->to.sym == S || p->to.sym->become) {
                    curtext->to.offset += f;

                    if(debug['b']) {
                        curp = p;
                        print("%D calling %D increase %d\n",
                            &curtext->from, &p->to, f);
                    }
                }
            }
            break;
        }
    }

    autoffset = 0;
    deltasp = 0;
    for(p = firstp; p != P; p = p->link) {
        if(p->as == ATEXT) {
            curtext = p;

            autoffset = p->to.offset;
            if(autoffset < 0)
                autoffset = 0;
            if(autoffset) {
                p = appendp(p);
                p->as = AADJSP;
                p->from.type = D_CONST;
                p->from.offset = autoffset;
            }
            deltasp = autoffset;
        }
        a = p->from.type;
        if(a == D_LOCAL)
            p->from.offset += deltasp;
        if(a == D_PARAM)
            p->from.offset += deltasp + 4;
        a = p->to.type;
        if(a == D_LOCAL)
            p->to.offset += deltasp;
        if(a == D_PARAM)
            p->to.offset += deltasp + 4;

        switch(p->as) {
        default:
            continue;
        case APUSHL:
        case APUSHFL:
            deltasp += 4;
            continue;
        case APUSHW:
        case APUSHFW:
            deltasp += 2;
            continue;
        case APOPL:
        case APOPFL:
            deltasp -= 4;
            continue;
        case APOPW:
        case APOPFW:
            deltasp -= 2;
            continue;
        case ARET:
            break;
        }

        if(autoffset != deltasp)
            diag("unbalanced PUSH/POP");
        if(p->from.type == D_CONST)
            goto become;

        if(autoffset) {
            q = p;
            p = appendp(p);
            p->as = ARET;

            q->as = AADJSP;
            q->from.type = D_CONST;
            q->from.offset = -autoffset;
        }
        continue;

    become:
        q = p;
        p = appendp(p);
        p->as = AJMP;
        p->to = q->to;
        p->pcond = q->pcond;

        q->as = AADJSP;
        q->from = zprg.from;
        q->from.type = D_CONST;
        q->from.offset = -autoffset;
        q->to = zprg.to;
        continue;
    }
}
@

<<function appendp(x86)>>=
Prog*
appendp(Prog *q)
{
    Prog *p;

    p = prg();
    p->link = q->link;
    q->link = p;
    p->line = q->line;
    return p;
}
@

%\section{[[doinit()]]}
% x86 only

% use INITDAT and relocate from there
<<function doinit(x86)>>=
void
doinit(void)
{
    Sym *s;
    Prog *p;
    int x;

    for(p = datap; p != P; p = p->link) {
        x = p->to.type;
        if(x != D_EXTERN && x != D_STATIC)
            continue;
        s = p->to.sym;
        if(s->type == 0 || s->type == SXREF)
            diag("undefined %s initializer of %s",
                s->name, p->from.sym->name);
        p->to.offset += s->value;
        p->to.type = D_CONST;
        if(s->type == SDATA || s->type == SBSS)
            p->to.offset += INITDAT;
    }
}
@

\ifallcode
% dead on 8l, so does not really have to be a global
<<global spsize(x86)>>=
long	spsize = 0;
@
\fi

\ifallcode
<<global pcstr(x86)>>=
char*	pcstr = "%.6lux ";
@
\fi

<<function entryvalue(x86)>>=
long
entryvalue(void)
{
    char *a;
    Sym *s;

    a = INITENTRY;

    <<[[entryvalue()]] if digit INITENTRY>>

    s = lookup(a, 0);
    // no _main found, maybe pure asm, start at beginning of TEXT section (va)
    if(s->type == 0)
        return INITTEXT;

    switch(s->type) {
    case STEXT:
        return s->value;
    <<[[entryvalue()]] if dynamic module case>>
    default:
        diag("entry not text: %s", s->name);
    }
}
@


<<function zaddr(x86)>>=
int
zaddr(byte *p, Adr *a, Sym *h[])
{
    int c, t, i;
    int l;
    Sym *s;
    Auto *u;

    t = p[0];

    c = 1;
    if(t & T_INDEX) {
        a->index = p[c];
        a->scale = p[c+1];
        c += 2;
    } else {
        a->index = D_NONE;
        a->scale = 0;
    }
    a->offset = 0;
    if(t & T_OFFSET) {
        a->offset = p[c] | (p[c+1]<<8) | (p[c+2]<<16) | (p[c+3]<<24);
        c += 4;
        // >> >> >>
    }
    a->sym = S;
    if(t & T_SYM) {
        a->sym = h[p[c]];
        c++;
    }
    a->type = D_NONE;
    if(t & T_FCONST) {
        a->ieee.l = p[c] | (p[c+1]<<8) | (p[c+2]<<16) | (p[c+3]<<24);
        a->ieee.h = p[c+4] | (p[c+5]<<8) | (p[c+6]<<16) | (p[c+7]<<24);
        // >> >> >> >> >> >>
        c += 8;
        a->type = D_FCONST;
    } else
    if(t & T_SCONST) {
        for(i=0; i<NSNAME; i++)
            a->scon[i] = p[c+i];
        c += NSNAME;
        a->type = D_SCONST;
    }
    if(t & T_TYPE) {
        a->type = p[c];
        c++;
    }
    s = a->sym;
    if(s == S)
        return c;

    t = a->type;
    if(t != D_LOCAL && t != D_PARAM)
        return c;
    l = a->offset;
    for(u=curauto; u; u=u->link) {
        if(u->asym == s)
        if(u->type == t) {
            if(u->aoffset > l)
                u->aoffset = l;
            return c;
        }
    }

    // factorize!
    while(nhunk < sizeof(Auto))
        gethunk();
    u = (Auto*)hunk;
    nhunk -= sizeof(Auto);
    hunk += sizeof(Auto);

    u->link = curauto;
    curauto = u;
    u->asym = s;
    u->aoffset = l;
    u->type = t;
    return c;
}
@




<<enum pxxx(x86)>>=
enum pxxx {
    Px		= 0,
    Pe		= 0x66,	/* operand escape */
    Pm		= 0x0f,	/* 2byte opcode escape */
    Pq		= 0xff,	/* both escape */
    Pb		= 0xfe,	/* byte operands */
};


@


<<global optab(x86)>>=
Optab optab[] =
/*	as, ytab, andproto, opcode */
{
    { AXXX },
    { AAAA,		ynone,	Px, 0x37 },
    { AAAD,		ynone,	Px, 0xd5,0x0a },
    { AAAM,		ynone,	Px, 0xd4,0x0a },
    { AAAS,		ynone,	Px, 0x3f },
    { AADCB,	yxorb,	Pb, 0x14,0x80,(02),0x10,0x10 },
    { AADCL,	yxorl,	Px, 0x83,(02),0x15,0x81,(02),0x11,0x13 },
    { AADCW,	yxorl,	Pe, 0x83,(02),0x15,0x81,(02),0x11,0x13 },
    { AADDB,	yxorb,	Px, 0x04,0x80,(00),0x00,0x02 },
    { AADDL,	yaddl,	Px, 0x83,(00),0x05,0x81,(00),0x01,0x03 },
    { AADDW,	yaddl,	Pe, 0x83,(00),0x05,0x81,(00),0x01,0x03 },
    { AADJSP },
    { AANDB,	yxorb,	Pb, 0x24,0x80,(04),0x20,0x22 },
    { AANDL,	yxorl,	Px, 0x83,(04),0x25,0x81,(04),0x21,0x23 },
    { AANDW,	yxorl,	Pe, 0x83,(04),0x25,0x81,(04),0x21,0x23 },
    { AARPL,	yrl_ml,	Px, 0x63 },
    { ABOUNDL,	yrl_m,	Px, 0x62 },
    { ABOUNDW,	yrl_m,	Pe, 0x62 },
    { ABSFL,	yml_rl,	Pm, 0xbc },
    { ABSFW,	yml_rl,	Pq, 0xbc },
    { ABSRL,	yml_rl,	Pm, 0xbd },
    { ABSRW,	yml_rl,	Pq, 0xbd },
    { ABTL,		yml_rl,	Pm, 0xa3 },
    { ABTW,		yml_rl,	Pq, 0xa3 },
    { ABTCL,	yml_rl,	Pm, 0xbb },
    { ABTCW,	yml_rl,	Pq, 0xbb },
    { ABTRL,	yml_rl,	Pm, 0xb3 },
    { ABTRW,	yml_rl,	Pq, 0xb3 },
    { ABTSL,	yml_rl,	Pm, 0xab },
    { ABTSW,	yml_rl,	Pq, 0xab },
    { ABYTE,	ybyte,	Px, 1 },
    { ACALL,	ycall,	Px, 0xff,(02),0xe8 },
    { ACLC,		ynone,	Px, 0xf8 },
    { ACLD,		ynone,	Px, 0xfc },
    { ACLI,		ynone,	Px, 0xfa },
    { ACLTS,	ynone,	Pm, 0x06 },
    { ACMC,		ynone,	Px, 0xf5 },
    { ACMPB,	ycmpb,	Pb, 0x3c,0x80,(07),0x38,0x3a },
    { ACMPL,	ycmpl,	Px, 0x83,(07),0x3d,0x81,(07),0x39,0x3b },
    { ACMPW,	ycmpl,	Pe, 0x83,(07),0x3d,0x81,(07),0x39,0x3b },
    { ACMPSB,	ynone,	Pb, 0xa6 },
    { ACMPSL,	ynone,	Px, 0xa7 },
    { ACMPSW,	ynone,	Pe, 0xa7 },
    { ADAA,		ynone,	Px, 0x27 },
    { ADAS,		ynone,	Px, 0x2f },
    { ADATA },
    { ADECB,	yincb,	Pb, 0xfe,(01) },
    { ADECL,	yincl,	Px, 0x48,0xff,(01) },
    { ADECW,	yincl,	Pe, 0x48,0xff,(01) },
    { ADIVB,	ydivb,	Pb, 0xf6,(06) },
    { ADIVL,	ydivl,	Px, 0xf7,(06) },
    { ADIVW,	ydivl,	Pe, 0xf7,(06) },
    { AENTER },				/* botch */
    { AGLOBL },
    { AGOK },
    { AHISTORY },
    { AHLT,		ynone,	Px, 0xf4 },
    { AIDIVB,	ydivb,	Pb, 0xf6,(07) },
    { AIDIVL,	ydivl,	Px, 0xf7,(07) },
    { AIDIVW,	ydivl,	Pe, 0xf7,(07) },
    { AIMULB,	ydivb,	Pb, 0xf6,(05) },
    { AIMULL,	yimul,	Px, 0xf7,(05),0x6b,0x69 },
    { AIMULW,	yimul,	Pe, 0xf7,(05),0x6b,0x69 },
    { AINB,		yin,	Pb, 0xe4,0xec },
    { AINL,		yin,	Px, 0xe5,0xed },
    { AINW,		yin,	Pe, 0xe5,0xed },
    { AINCB,	yincb,	Pb, 0xfe,(00) },
    { AINCL,	yincl,	Px, 0x40,0xff,(00) },
    { AINCW,	yincl,	Pe, 0x40,0xff,(00) },
    { AINSB,	ynone,	Pb, 0x6c },
    { AINSL,	ynone,	Px, 0x6d },
    { AINSW,	ynone,	Pe, 0x6d },
    { AINT,		yint,	Px, 0xcd },
    { AINTO,	ynone,	Px, 0xce },
    { AIRETL,	ynone,	Px, 0xcf },
    { AIRETW,	ynone,	Pe, 0xcf },
    { AJCC,		yjcond,	Px, 0x73,0x83,(00) },
    { AJCS,		yjcond,	Px, 0x72,0x82 },
    { AJCXZ,	yloop,	Px, 0xe3 },
    { AJEQ,		yjcond,	Px, 0x74,0x84 },
    { AJGE,		yjcond,	Px, 0x7d,0x8d },
    { AJGT,		yjcond,	Px, 0x7f,0x8f },
    { AJHI,		yjcond,	Px, 0x77,0x87 },
    { AJLE,		yjcond,	Px, 0x7e,0x8e },
    { AJLS,		yjcond,	Px, 0x76,0x86 },
    { AJLT,		yjcond,	Px, 0x7c,0x8c },
    { AJMI,		yjcond,	Px, 0x78,0x88 },
    { AJMP,		yjmp,	Px, 0xff,(04),0xeb,0xe9 },
    { AJNE,		yjcond,	Px, 0x75,0x85 },
    { AJOC,		yjcond,	Px, 0x71,0x81,(00) },
    { AJOS,		yjcond,	Px, 0x70,0x80,(00) },
    { AJPC,		yjcond,	Px, 0x7b,0x8b },
    { AJPL,		yjcond,	Px, 0x79,0x89 },
    { AJPS,		yjcond,	Px, 0x7a,0x8a },
    { ALAHF,	ynone,	Px, 0x9f },
    { ALARL,	yml_rl,	Pm, 0x02 },
    { ALARW,	yml_rl,	Pq, 0x02 },
    { ALEAL,	ym_rl,	Px, 0x8d },
    { ALEAW,	ym_rl,	Pe, 0x8d },
    { ALEAVEL,	ynone,	Px, 0xc9 },
    { ALEAVEW,	ynone,	Pe, 0xc9 },
    { ALOCK,	ynone,	Px, 0xf0 },
    { ALODSB,	ynone,	Pb, 0xac },
    { ALODSL,	ynone,	Px, 0xad },
    { ALODSW,	ynone,	Pe, 0xad },
    { ALONG,	ybyte,	Px, 4 },
    { ALOOP,	yloop,	Px, 0xe2 },
    { ALOOPEQ,	yloop,	Px, 0xe1 },
    { ALOOPNE,	yloop,	Px, 0xe0 },
    { ALSLL,	yml_rl,	Pm, 0x03  },
    { ALSLW,	yml_rl,	Pq, 0x03  },
    { AMOVB,	ymovb,	Pb, 0x88,0x8a,0xb0,0xc6,(00) },
    { AMOVL,	ymovl,	Px, 0x89,0x8b,0x31,0x83,(04),0xb8,0xc7,(00) },
    { AMOVW,	ymovl,	Pe, 0x89,0x8b,0x31,0x83,(04),0xb8,0xc7,(00) },
    { AMOVBLSX,	ymb_rl,	Pm, 0xbe },
    { AMOVBLZX,	ymb_rl,	Pm, 0xb6 },
    { AMOVBWSX,	ymb_rl,	Pq, 0xbe },
    { AMOVBWZX,	ymb_rl,	Pq, 0xb6 },
    { AMOVWLSX,	yml_rl,	Pm, 0xbf },
    { AMOVWLZX,	yml_rl,	Pm, 0xb7 },
    { AMOVSB,	ynone,	Pb, 0xa4 },
    { AMOVSL,	ynone,	Px, 0xa5 },
    { AMOVSW,	ynone,	Pe, 0xa5 },
    { AMULB,	ydivb,	Pb, 0xf6,(04) },
    { AMULL,	ydivl,	Px, 0xf7,(04) },
    { AMULW,	ydivl,	Pe, 0xf7,(04) },
    { ANAME },
    { ANEGB,	yscond,	Px, 0xf6,(03) },
    { ANEGL,	yscond,	Px, 0xf7,(03) },
    { ANEGW,	yscond,	Pe, 0xf7,(03) },
    { ANOP,		ynop,	Px,0,0 },
    { ANOTB,	yscond,	Px, 0xf6,(02) },
    { ANOTL,	yscond,	Px, 0xf7,(02) },
    { ANOTW,	yscond,	Pe, 0xf7,(02) },
    { AORB,		yxorb,	Pb, 0x0c,0x80,(01),0x08,0x0a },
    { AORL,		yxorl,	Px, 0x83,(01),0x0d,0x81,(01),0x09,0x0b },
    { AORW,		yxorl,	Pe, 0x83,(01),0x0d,0x81,(01),0x09,0x0b },
    { AOUTB,	yin,	Pb, 0xe6,0xee },
    { AOUTL,	yin,	Px, 0xe7,0xef },
    { AOUTW,	yin,	Pe, 0xe7,0xef },
    { AOUTSB,	ynone,	Pb, 0x6e },
    { AOUTSL,	ynone,	Px, 0x6f },
    { AOUTSW,	ynone,	Pe, 0x6f },
    { APOPAL,	ynone,	Px, 0x61 },
    { APOPAW,	ynone,	Pe, 0x61 },
    { APOPFL,	ynone,	Px, 0x9d },
    { APOPFW,	ynone,	Pe, 0x9d },
    { APOPL,	ypopl,	Px, 0x58,0x8f,(00) },
    { APOPW,	ypopl,	Pe, 0x58,0x8f,(00) },
    { APUSHAL,	ynone,	Px, 0x60 },
    { APUSHAW,	ynone,	Pe, 0x60 },
    { APUSHFL,	ynone,	Px, 0x9c },
    { APUSHFW,	ynone,	Pe, 0x9c },
    { APUSHL,	ypushl,	Px, 0x50,0xff,(06),0x6a,0x68 },
    { APUSHW,	ypushl,	Pe, 0x50,0xff,(06),0x6a,0x68 },
    { ARCLB,	yshb,	Pb, 0xd0,(02),0xc0,(02),0xd2,(02) },
    { ARCLL,	yshl,	Px, 0xd1,(02),0xc1,(02),0xd3,(02),0xd3,(02) },
    { ARCLW,	yshl,	Pe, 0xd1,(02),0xc1,(02),0xd3,(02),0xd3,(02) },
    { ARCRB,	yshb,	Pb, 0xd0,(03),0xc0,(03),0xd2,(03) },
    { ARCRL,	yshl,	Px, 0xd1,(03),0xc1,(03),0xd3,(03),0xd3,(03) },
    { ARCRW,	yshl,	Pe, 0xd1,(03),0xc1,(03),0xd3,(03),0xd3,(03) },
    { AREP,		ynone,	Px, 0xf3 },
    { AREPN,	ynone,	Px, 0xf2 },
    { ARET,		ynone,	Px, 0xc3 },
    { AROLB,	yshb,	Pb, 0xd0,(00),0xc0,(00),0xd2,(00) },
    { AROLL,	yshl,	Px, 0xd1,(00),0xc1,(00),0xd3,(00),0xd3,(00) },
    { AROLW,	yshl,	Pe, 0xd1,(00),0xc1,(00),0xd3,(00),0xd3,(00) },
    { ARORB,	yshb,	Pb, 0xd0,(01),0xc0,(01),0xd2,(01) },
    { ARORL,	yshl,	Px, 0xd1,(01),0xc1,(01),0xd3,(01),0xd3,(01) },
    { ARORW,	yshl,	Pe, 0xd1,(01),0xc1,(01),0xd3,(01),0xd3,(01) },
    { ASAHF,	ynone,	Px, 0x9e },
    { ASALB,	yshb,	Pb, 0xd0,(04),0xc0,(04),0xd2,(04) },
    { ASALL,	yshl,	Px, 0xd1,(04),0xc1,(04),0xd3,(04),0xd3,(04) },
    { ASALW,	yshl,	Pe, 0xd1,(04),0xc1,(04),0xd3,(04),0xd3,(04) },
    { ASARB,	yshb,	Pb, 0xd0,(07),0xc0,(07),0xd2,(07) },
    { ASARL,	yshl,	Px, 0xd1,(07),0xc1,(07),0xd3,(07),0xd3,(07) },
    { ASARW,	yshl,	Pe, 0xd1,(07),0xc1,(07),0xd3,(07),0xd3,(07) },
    { ASBBB,	yxorb,	Pb, 0x1c,0x80,(03),0x18,0x1a },
    { ASBBL,	yxorl,	Px, 0x83,(03),0x1d,0x81,(03),0x19,0x1b },
    { ASBBW,	yxorl,	Pe, 0x83,(03),0x1d,0x81,(03),0x19,0x1b },
    { ASCASB,	ynone,	Pb, 0xae },
    { ASCASL,	ynone,	Px, 0xaf },
    { ASCASW,	ynone,	Pe, 0xaf },
    { ASETCC,	yscond,	Pm, 0x93,(00) },
    { ASETCS,	yscond,	Pm, 0x92,(00) },
    { ASETEQ,	yscond,	Pm, 0x94,(00) },
    { ASETGE,	yscond,	Pm, 0x9d,(00) },
    { ASETGT,	yscond,	Pm, 0x9f,(00) },
    { ASETHI,	yscond,	Pm, 0x97,(00) },
    { ASETLE,	yscond,	Pm, 0x9e,(00) },
    { ASETLS,	yscond,	Pm, 0x96,(00) },
    { ASETLT,	yscond,	Pm, 0x9c,(00) },
    { ASETMI,	yscond,	Pm, 0x98,(00) },
    { ASETNE,	yscond,	Pm, 0x95,(00) },
    { ASETOC,	yscond,	Pm, 0x91,(00) },
    { ASETOS,	yscond,	Pm, 0x90,(00) },
    { ASETPC,	yscond,	Pm, 0x96,(00) },
    { ASETPL,	yscond,	Pm, 0x99,(00) },
    { ASETPS,	yscond,	Pm, 0x9a,(00) },
    { ACDQ,		ynone,	Px, 0x99 },
    { ACWD,		ynone,	Pe, 0x99 },
    { ASHLB,	yshb,	Pb, 0xd0,(04),0xc0,(04),0xd2,(04) },
    { ASHLL,	yshl,	Px, 0xd1,(04),0xc1,(04),0xd3,(04),0xd3,(04) },
    { ASHLW,	yshl,	Pe, 0xd1,(04),0xc1,(04),0xd3,(04),0xd3,(04) },
    { ASHRB,	yshb,	Pb, 0xd0,(05),0xc0,(05),0xd2,(05) },
    { ASHRL,	yshl,	Px, 0xd1,(05),0xc1,(05),0xd3,(05),0xd3,(05) },
    { ASHRW,	yshl,	Pe, 0xd1,(05),0xc1,(05),0xd3,(05),0xd3,(05) },
    { ASTC,		ynone,	Px, 0xf9 },
    { ASTD,		ynone,	Px, 0xfd },
    { ASTI,		ynone,	Px, 0xfb },
    { ASTOSB,	ynone,	Pb, 0xaa },
    { ASTOSL,	ynone,	Px, 0xab },
    { ASTOSW,	ynone,	Pe, 0xab },
    { ASUBB,	yxorb,	Pb, 0x2c,0x80,(05),0x28,0x2a },
    { ASUBL,	yaddl,	Px, 0x83,(05),0x2d,0x81,(05),0x29,0x2b },
    { ASUBW,	yaddl,	Pe, 0x83,(05),0x2d,0x81,(05),0x29,0x2b },
    { ASYSCALL,	ynone,	Px, 0xcd,100 },
    { ATESTB,	ytestb,	Pb, 0xa8,0xf6,(00),0x84,0x84 },
    { ATESTL,	ytestl,	Px, 0xa9,0xf7,(00),0x85,0x85 },
    { ATESTW,	ytestl,	Pe, 0xa9,0xf7,(00),0x85,0x85 },
    { ATEXT,	ytext,	Px },
    { AVERR,	ydivl,	Pm, 0x00,(04) },
    { AVERW,	ydivl,	Pm, 0x00,(05) },
    { AWAIT,	ynone,	Px, 0x9b },
    { AWORD,	ybyte,	Px, 2 },
    { AXCHGB,	yml_mb,	Pb, 0x86,0x86 },
    { AXCHGL,	yml_ml,	Px, 0x87,0x87 },
    { AXCHGW,	yml_ml,	Pe, 0x87,0x87 },
    { AXLAT,	ynone,	Px, 0xd7 },
    { AXORB,	yxorb,	Pb, 0x34,0x80,(06),0x30,0x32 },
    { AXORL,	yxorl,	Px, 0x83,(06),0x35,0x81,(06),0x31,0x33 },
    { AXORW,	yxorl,	Pe, 0x83,(06),0x35,0x81,(06),0x31,0x33 },

    { AFMOVB,	yfmvx,	Px, 0xdf,(04) },
    { AFMOVBP,	yfmvp,	Px, 0xdf,(06) },
    { AFMOVD,	yfmvd,	Px, 0xdd,(00),0xdd,(02),0xd9,(00),0xdd,(02) },
    { AFMOVDP,	yfmvdp,	Px, 0xdd,(03),0xdd,(03) },
    { AFMOVF,	yfmvf,	Px, 0xd9,(00),0xd9,(02) },
    { AFMOVFP,	yfmvp,	Px, 0xd9,(03) },
    { AFMOVL,	yfmvf,	Px, 0xdb,(00),0xdb,(02) },
    { AFMOVLP,	yfmvp,	Px, 0xdb,(03) },
    { AFMOVV,	yfmvx,	Px, 0xdf,(05) },
    { AFMOVVP,	yfmvp,	Px, 0xdf,(07) },
    { AFMOVW,	yfmvf,	Px, 0xdf,(00),0xdf,(02) },
    { AFMOVWP,	yfmvp,	Px, 0xdf,(03) },
    { AFMOVX,	yfmvx,	Px, 0xdb,(05) },
    { AFMOVXP,	yfmvp,	Px, 0xdb,(07) },

    { AFCOMB },
    { AFCOMBP },
    { AFCOMD,	yfadd,	Px, 0xdc,(02),0xd8,(02),0xdc,(02) },	/* botch */
    { AFCOMDP,	yfadd,	Px, 0xdc,(03),0xd8,(03),0xdc,(03) },	/* botch */
    { AFCOMDPP,	ycompp,	Px, 0xde,(03) },
    { AFCOMF,	yfmvx,	Px, 0xd8,(02) },
    { AFCOMFP,	yfmvx,	Px, 0xd8,(03) },
    { AFCOML,	yfmvx,	Px, 0xda,(02) },
    { AFCOMLP,	yfmvx,	Px, 0xda,(03) },
    { AFCOMW,	yfmvx,	Px, 0xde,(02) },
    { AFCOMWP,	yfmvx,	Px, 0xde,(03) },

    { AFUCOM,	ycompp,	Px, 0xdd,(04) },
    { AFUCOMP,	ycompp, Px, 0xdd,(05) },
    { AFUCOMPP,	ycompp,	Px, 0xda,(13) },

    { AFADDDP,	yfaddp,	Px, 0xde,(00) },
    { AFADDW,	yfmvx,	Px, 0xde,(00) },
    { AFADDL,	yfmvx,	Px, 0xda,(00) },
    { AFADDF,	yfmvx,	Px, 0xd8,(00) },
    { AFADDD,	yfadd,	Px, 0xdc,(00),0xd8,(00),0xdc,(00) },

    { AFMULDP,	yfaddp,	Px, 0xde,(01) },
    { AFMULW,	yfmvx,	Px, 0xde,(01) },
    { AFMULL,	yfmvx,	Px, 0xda,(01) },
    { AFMULF,	yfmvx,	Px, 0xd8,(01) },
    { AFMULD,	yfadd,	Px, 0xdc,(01),0xd8,(01),0xdc,(01) },

    { AFSUBDP,	yfaddp,	Px, 0xde,(05) },
    { AFSUBW,	yfmvx,	Px, 0xde,(04) },
    { AFSUBL,	yfmvx,	Px, 0xda,(04) },
    { AFSUBF,	yfmvx,	Px, 0xd8,(04) },
    { AFSUBD,	yfadd,	Px, 0xdc,(04),0xd8,(04),0xdc,(05) },

    { AFSUBRDP,	yfaddp,	Px, 0xde,(04) },
    { AFSUBRW,	yfmvx,	Px, 0xde,(05) },
    { AFSUBRL,	yfmvx,	Px, 0xda,(05) },
    { AFSUBRF,	yfmvx,	Px, 0xd8,(05) },
    { AFSUBRD,	yfadd,	Px, 0xdc,(05),0xd8,(05),0xdc,(04) },

    { AFDIVDP,	yfaddp,	Px, 0xde,(07) },
    { AFDIVW,	yfmvx,	Px, 0xde,(06) },
    { AFDIVL,	yfmvx,	Px, 0xda,(06) },
    { AFDIVF,	yfmvx,	Px, 0xd8,(06) },
    { AFDIVD,	yfadd,	Px, 0xdc,(06),0xd8,(06),0xdc,(07) },

    { AFDIVRDP,	yfaddp,	Px, 0xde,(06) },
    { AFDIVRW,	yfmvx,	Px, 0xde,(07) },
    { AFDIVRL,	yfmvx,	Px, 0xda,(07) },
    { AFDIVRF,	yfmvx,	Px, 0xd8,(07) },
    { AFDIVRD,	yfadd,	Px, 0xdc,(07),0xd8,(07),0xdc,(06) },

    { AFXCHD,	yfxch,	Px, 0xd9,(01),0xd9,(01) },
    { AFFREE },
    { AFLDCW,	ystcw,	Px, 0xd9,(05),0xd9,(05) },
    { AFLDENV,	ystcw,	Px, 0xd9,(04),0xd9,(04) },
    { AFRSTOR,	ysvrs,	Px, 0xdd,(04),0xdd,(04) },
    { AFSAVE,	ysvrs,	Px, 0xdd,(06),0xdd,(06) },
    { AFSTCW,	ystcw,	Px, 0xd9,(07),0xd9,(07) },
    { AFSTENV,	ystcw,	Px, 0xd9,(06),0xd9,(06) },
    { AFSTSW,	ystsw,	Px, 0xdd,(07),0xdf,0xe0 },
    { AF2XM1,	ynone,	Px, 0xd9, 0xf0 },
    { AFABS,	ynone,	Px, 0xd9, 0xe1 },
    { AFCHS,	ynone,	Px, 0xd9, 0xe0 },
    { AFCLEX,	ynone,	Px, 0xdb, 0xe2 },
    { AFCOS,	ynone,	Px, 0xd9, 0xff },
    { AFDECSTP,	ynone,	Px, 0xd9, 0xf6 },
    { AFINCSTP,	ynone,	Px, 0xd9, 0xf7 },
    { AFINIT,	ynone,	Px, 0xdb, 0xe3 },
    { AFLD1,	ynone,	Px, 0xd9, 0xe8 },
    { AFLDL2E,	ynone,	Px, 0xd9, 0xea },
    { AFLDL2T,	ynone,	Px, 0xd9, 0xe9 },
    { AFLDLG2,	ynone,	Px, 0xd9, 0xec },
    { AFLDLN2,	ynone,	Px, 0xd9, 0xed },
    { AFLDPI,	ynone,	Px, 0xd9, 0xeb },
    { AFLDZ,	ynone,	Px, 0xd9, 0xee },
    { AFNOP,	ynone,	Px, 0xd9, 0xd0 },
    { AFPATAN,	ynone,	Px, 0xd9, 0xf3 },
    { AFPREM,	ynone,	Px, 0xd9, 0xf8 },
    { AFPREM1,	ynone,	Px, 0xd9, 0xf5 },
    { AFPTAN,	ynone,	Px, 0xd9, 0xf2 },
    { AFRNDINT,	ynone,	Px, 0xd9, 0xfc },
    { AFSCALE,	ynone,	Px, 0xd9, 0xfd },
    { AFSIN,	ynone,	Px, 0xd9, 0xfe },
    { AFSINCOS,	ynone,	Px, 0xd9, 0xfb },
    { AFSQRT,	ynone,	Px, 0xd9, 0xfa },
    { AFTST,	ynone,	Px, 0xd9, 0xe4 },
    { AFXAM,	ynone,	Px, 0xd9, 0xe5 },
    { AFXTRACT,	ynone,	Px, 0xd9, 0xf4 },
    { AFYL2X,	ynone,	Px, 0xd9, 0xf1 },
    { AFYL2XP1,	ynone,	Px, 0xd9, 0xf9 },
    { AEND },
    0
};
@



%\section{[[Yxxx]]}

<<enum yxxx(x86)>>=
enum yxxx {
    Yxxx		= 0,
    Ynone,
    Yi0,
    Yi1,
    Yi8,
    Yi32,

    Yiauto,

    Yal,
    Ycl,
    Yax,
    Ycx,
    Yrb,
    Yrl,
    Yrf,
    Yf0,
    Yrx,
    Ymb,
    Yml,
    Ym,
    Ybr,
    Ycol,

    Ycs,	Yss,	Yds,	Yes,	Yfs,	Ygs,
    Ygdtr,	Yidtr,	Yldtr,	Ymsw,	Ytask,
    Ycr0,	Ycr1,	Ycr2,	Ycr3,	Ycr4,	Ycr5,	Ycr6,	Ycr7,
    Ydr0,	Ydr1,	Ydr2,	Ydr3,	Ydr4,	Ydr5,	Ydr6,	Ydr7,
    Ytr0,	Ytr1,	Ytr2,	Ytr3,	Ytr4,	Ytr5,	Ytr6,	Ytr7,

    Ymax,
};
@

%\section{[[Zxxx]]}

<<enum zxxx(x86)>>=
enum zxxx {
    Zxxx		= 0,

    Zlit,
    Z_rp,
    Zbr,
    Zcall,
    Zib_,
    Zib_rp,
    Zibo_m,
    Zil_,
    Zil_rp,
    Zilo_m,
    Zjmp,
    Zloop,
    Zm_o,
    Zm_r,
    Zaut_r,
    Zo_m,
    Zpseudo,
    Zr_m,
    Zrp_,
    Z_ib,
    Z_il,
    Zm_ibo,
    Zm_ilo,
    Zib_rr,
    Zil_rr,
    Zclr,
    Zbyte,
    Zmov,
    Zmax,
};
@

%\section{[[yxxx]]}

<<global ynone(x86)>>=
byte	ynone[] =
{
    Ynone,	Ynone,	Zlit,	1,
    0
};
@

<<global ytext(x86)>>=
byte	ytext[] =
{
    Ymb,	Yi32,	Zpseudo,1,
    0
};
@

<<global ynop(x86)>>=
byte	ynop[] =
{
    Ynone,	Ynone,	Zpseudo,1,
    Ynone,	Yml,	Zpseudo,1,
    Ynone,	Yrf,	Zpseudo,1,
    Yml,	Ynone,	Zpseudo,1,
    Yrf,	Ynone,	Zpseudo,1,
    0
};
@

<<global yxorb(x86)>>=
byte	yxorb[] =
{
    Yi32,	Yal,	Zib_,	1,
    Yi32,	Ymb,	Zibo_m,	2,
    Yrb,	Ymb,	Zr_m,	1,
    Ymb,	Yrb,	Zm_r,	1,
    0
};
@

<<global yxorl(x86)>>=
byte	yxorl[] =
{
    Yi8,	Yml,	Zibo_m,	2,
    Yi32,	Yax,	Zil_,	1,
    Yi32,	Yml,	Zilo_m,	2,
    Yrl,	Yml,	Zr_m,	1,
    Yml,	Yrl,	Zm_r,	1,
    0
};
@

<<global yaddl(x86)>>=
byte	yaddl[] =
{
    Yi8,	Yml,	Zibo_m,	2,
    Yi32,	Yax,	Zil_,	1,
    Yi32,	Yml,	Zilo_m,	2,
    Yrl,	Yml,	Zr_m,	1,
    Yml,	Yrl,	Zm_r,	1,
    0
};
@

<<global yincb(x86)>>=
byte	yincb[] =
{
    Ynone,	Ymb,	Zo_m,	2,
    0
};
@

<<global yincl(x86)>>=
byte	yincl[] =
{
    Ynone,	Yrl,	Z_rp,	1,
    Ynone,	Yml,	Zo_m,	2,
    0
};
@

<<global ycmpb(x86)>>=
byte	ycmpb[] =
{
    Yal,	Yi32,	Z_ib,	1,
    Ymb,	Yi32,	Zm_ibo,	2,
    Ymb,	Yrb,	Zm_r,	1,
    Yrb,	Ymb,	Zr_m,	1,
    0
};
@

<<global ycmpl(x86)>>=
byte	ycmpl[] =
{
    Yml,	Yi8,	Zm_ibo,	2,
    Yax,	Yi32,	Z_il,	1,
    Yml,	Yi32,	Zm_ilo,	2,
    Yml,	Yrl,	Zm_r,	1,
    Yrl,	Yml,	Zr_m,	1,
    0
};
@

<<global yshb(x86)>>=
byte	yshb[] =
{
    Yi1,	Ymb,	Zo_m,	2,
    Yi32,	Ymb,	Zibo_m,	2,
    Ycx,	Ymb,	Zo_m,	2,
    0
};
@

<<global yshl(x86)>>=
byte	yshl[] =
{
    Yi1,	Yml,	Zo_m,	2,
    Yi32,	Yml,	Zibo_m,	2,
    Ycl,	Yml,	Zo_m,	2,
    Ycx,	Yml,	Zo_m,	2,
    0
};
@

<<global ytestb(x86)>>=
byte	ytestb[] =
{
    Yi32,	Yal,	Zib_,	1,
    Yi32,	Ymb,	Zibo_m,	2,
    Yrb,	Ymb,	Zr_m,	1,
    Ymb,	Yrb,	Zm_r,	1,
    0
};
@

<<global ytestl(x86)>>=
byte	ytestl[] =
{
    Yi32,	Yax,	Zil_,	1,
    Yi32,	Yml,	Zilo_m,	2,
    Yrl,	Yml,	Zr_m,	1,
    Yml,	Yrl,	Zm_r,	1,
    0
};
@

<<global ymovb(x86)>>=
byte	ymovb[] =
{
    Yrb,	Ymb,	Zr_m,	1,
    Ymb,	Yrb,	Zm_r,	1,
    Yi32,	Yrb,	Zib_rp,	1,
    Yi32,	Ymb,	Zibo_m,	2,
    0
};
@

<<global ymovl(x86)>>=
byte	ymovl[] =
{
    Yrl,	Yml,	Zr_m,	1,
    Yml,	Yrl,	Zm_r,	1,
    Yi0,	Yrl,	Zclr,	1+2,
//	Yi0,	Yml,	Zibo_m,	2,	// shorter but slower AND $0,dst
    Yi32,	Yrl,	Zil_rp,	1,
    Yi32,	Yml,	Zilo_m,	2,
    Yiauto,	Yrl,	Zaut_r,	2,
    0
};
@
%$

<<global ym_rl(x86)>>=
byte	ym_rl[] =
{
    Ym,	Yrl,	Zm_r,	1,
    0
};
@

<<global yrl_m(x86)>>=
byte	yrl_m[] =
{
    Yrl,	Ym,	Zr_m,	1,
    0
};
@

<<global ymb_rl(x86)>>=
byte	ymb_rl[] =
{
    Ymb,	Yrl,	Zm_r,	1,
    0
};
@

<<global yml_rl(x86)>>=
byte	yml_rl[] =
{
    Yml,	Yrl,	Zm_r,	1,
    0
};
@

<<global yrl_ml(x86)>>=
byte	yrl_ml[] =
{
    Yrl,	Yml,	Zr_m,	1,
    0
};
@

<<global yml_mb(x86)>>=
byte	yml_mb[] =
{
    Yrb,	Ymb,	Zr_m,	1,
    Ymb,	Yrb,	Zm_r,	1,
    0
};
@

<<global yml_ml(x86)>>=
byte	yml_ml[] =
{
    Yrl,	Yml,	Zr_m,	1,
    Yml,	Yrl,	Zm_r,	1,
    0
};
@

<<global ydivl(x86)>>=
byte	ydivl[] =
{
    Yml,	Ynone,	Zm_o,	2,
    0
};
@

<<global ydivb(x86)>>=
byte	ydivb[] =
{
    Ymb,	Ynone,	Zm_o,	2,
    0
};
@

<<global yimul(x86)>>=
byte	yimul[] =
{
    Yml,	Ynone,	Zm_o,	2,
    Yi8,	Yrl,	Zib_rr,	1,
    Yi32,	Yrl,	Zil_rr,	1,
    0
};
@

<<global ybyte(x86)>>=
byte	ybyte[] =
{
    Yi32,	Ynone,	Zbyte,	1,
    0
};
@

<<global yin(x86)>>=
byte	yin[] =
{
    Yi32,	Ynone,	Zib_,	1,
    Ynone,	Ynone,	Zlit,	1,
    0
};
@

<<global yint(x86)>>=
byte	yint[] =
{
    Yi32,	Ynone,	Zib_,	1,
    0
};
@

<<global ypushl(x86)>>=
byte	ypushl[] =
{
    Yrl,	Ynone,	Zrp_,	1,
    Ym,	Ynone,	Zm_o,	2,
    Yi8,	Ynone,	Zib_,	1,
    Yi32,	Ynone,	Zil_,	1,
    0
};
@

<<global ypopl(x86)>>=
byte	ypopl[] =
{
    Ynone,	Yrl,	Z_rp,	1,
    Ynone,	Ym,	Zo_m,	2,
    0
};
@

<<global yscond(x86)>>=
byte	yscond[] =
{
    Ynone,	Ymb,	Zo_m,	2,
    0
};
@

<<global yjcond(x86)>>=
byte	yjcond[] =
{
    Ynone,	Ybr,	Zbr,	1,
    0
};
@

<<global yloop(x86)>>=
byte	yloop[] =
{
    Ynone,	Ybr,	Zloop,	1,
    0
};
@

<<global ycall(x86)>>=
byte	ycall[] =
{
    Ynone,	Yml,	Zo_m,	2,
    Ynone,	Ybr,	Zcall,	1,
    0
};
@

<<global yjmp(x86)>>=
byte	yjmp[] =
{
    Ynone,	Yml,	Zo_m,	2,
    Ynone,	Ybr,	Zjmp,	1,
    0
};
@

<<global yfmvd(x86)>>=
byte	yfmvd[] =
{
    Ym,	Yf0,	Zm_o,	2,
    Yf0,	Ym,	Zo_m,	2,
    Yrf,	Yf0,	Zm_o,	2,
    Yf0,	Yrf,	Zo_m,	2,
    0
};
@

<<global yfmvdp(x86)>>=
byte	yfmvdp[] =
{
    Yf0,	Ym,	Zo_m,	2,
    Yf0,	Yrf,	Zo_m,	2,
    0
};
@

<<global yfmvf(x86)>>=
byte	yfmvf[] =
{
    Ym,	Yf0,	Zm_o,	2,
    Yf0,	Ym,	Zo_m,	2,
    0
};
@

<<global yfmvx(x86)>>=
byte	yfmvx[] =
{
    Ym,	Yf0,	Zm_o,	2,
    0
};
@

<<global yfmvp(x86)>>=
byte	yfmvp[] =
{
    Yf0,	Ym,	Zo_m,	2,
    0
};
@

<<global yfadd(x86)>>=
byte	yfadd[] =
{
    Ym,	Yf0,	Zm_o,	2,
    Yrf,	Yf0,	Zm_o,	2,
    Yf0,	Yrf,	Zo_m,	2,
    0
};
@

<<global yfaddp(x86)>>=
byte	yfaddp[] =
{
    Yf0,	Yrf,	Zo_m,	2,
    0
};
@

<<global yfxch(x86)>>=
byte	yfxch[] =
{
    Yf0,	Yrf,	Zo_m,	2,
    Yrf,	Yf0,	Zm_o,	2,
    0
};
@

<<global ycompp(x86)>>=
byte	ycompp[] =
{
    Yf0,	Yrf,	Zo_m,	2,	/* botch is really f0,f1 */
    0
};
@

<<global ystsw(x86)>>=
byte	ystsw[] =
{
    Ynone,	Ym,	Zo_m,	2,
    Ynone,	Yax,	Zlit,	1,
    0
};
@

<<global ystcw(x86)>>=
byte	ystcw[] =
{
    Ynone,	Ym,	Zo_m,	2,
    Ym,	Ynone,	Zm_o,	2,
    0
};
@

<<global ysvrs(x86)>>=
byte	ysvrs[] =
{
    Ynone,	Ym,	Zo_m,	2,
    Ym,	Ynone,	Zm_o,	2,
    0
};
@

%\section{[[ycover]]}

<<global ycover(x86)>>=
char	ycover[Ymax*Ymax];
@

<<[[main()]] set ycover(x86)>>=
for(i=0; i<Ymax; i++)
    ycover[i*Ymax + i] = 1;

ycover[Yi0*Ymax + Yi8] = 1;
ycover[Yi1*Ymax + Yi8] = 1;

ycover[Yi0*Ymax + Yi32] = 1;
ycover[Yi1*Ymax + Yi32] = 1;
ycover[Yi8*Ymax + Yi32] = 1;

ycover[Yal*Ymax + Yrb] = 1;
ycover[Ycl*Ymax + Yrb] = 1;
ycover[Yax*Ymax + Yrb] = 1;
ycover[Ycx*Ymax + Yrb] = 1;
ycover[Yrx*Ymax + Yrb] = 1;

ycover[Yax*Ymax + Yrx] = 1;
ycover[Ycx*Ymax + Yrx] = 1;

ycover[Yax*Ymax + Yrl] = 1;
ycover[Ycx*Ymax + Yrl] = 1;
ycover[Yrx*Ymax + Yrl] = 1;

ycover[Yf0*Ymax + Yrf] = 1;

ycover[Yal*Ymax + Ymb] = 1;
ycover[Ycl*Ymax + Ymb] = 1;
ycover[Yax*Ymax + Ymb] = 1;
ycover[Ycx*Ymax + Ymb] = 1;
ycover[Yrx*Ymax + Ymb] = 1;
ycover[Yrb*Ymax + Ymb] = 1;
ycover[Ym*Ymax + Ymb] = 1;

ycover[Yax*Ymax + Yml] = 1;
ycover[Ycx*Ymax + Yml] = 1;
ycover[Yrx*Ymax + Yml] = 1;
ycover[Yrl*Ymax + Yml] = 1;
ycover[Ym*Ymax + Yml] = 1;
@

%\section{[[reg]]}
<<global reg(x86)>>=
char	reg[D_NONE];
@

<<[[main()]] set reg(x86)>>=
for(i=0; i<D_NONE; i++) {
    reg[i] = -1;
    if(i >= D_AL && i <= D_BH)
        reg[i] = (i-D_AL) & 7;
    if(i >= D_AX && i <= D_DI)
        reg[i] = (i-D_AX) & 7;
    if(i >= D_F0 && i <= D_F0+7)
        reg[i] = (i-D_F0) & 7;
}
@

% asmb -> <>
<<function asmsym(x86)>>=
void
asmsym(void)
{
    Prog *p;
    Auto *a;
    Sym *s;
    int h;

    s = lookup("etext", 0);
    if(s->type == STEXT)
        putsymb(s->name, 'T', s->value, s->version);

    for(h=0; h<NHASH; h++)
        for(s=hash[h]; s!=S; s=s->link)
            switch(s->type) {
            case SCONST:
                putsymb(s->name, 'D', s->value, s->version);
                continue;

            case SDATA:
                putsymb(s->name, 'D', s->value+INITDAT, s->version);
                continue;

            case SBSS:
                putsymb(s->name, 'B', s->value+INITDAT, s->version);
                continue;

            case SFILE:
                putsymb(s->name, 'f', s->value, s->version);
                continue;
            }

    for(p=textp; p!=P; p=p->pcond) {
        s = p->from.sym;
        if(s->type != STEXT)
            continue;

        /* filenames first */
        for(a=p->to.autom; a; a=a->link)
            if(a->type == D_FILE)
                putsymb(a->asym->name, 'z', a->aoffset, 0);
            else
            if(a->type == D_FILE1)
                putsymb(a->asym->name, 'Z', a->aoffset, 0);

        putsymb(s->name, 'T', s->value, s->version);

        /* frame, auto and param after */
        putsymb(".frame", 'm', p->to.offset+4, 0);

        for(a=p->to.autom; a; a=a->link)
            if(a->type == D_LOCAL)
                putsymb(a->asym->name, 'a', -a->aoffset, 0);
            else
            if(a->type == D_PARAM)
                putsymb(a->asym->name, 'p', a->aoffset, 0);
    }

    if(debug['v'] || debug['n'])
        DBG("symsize = %lud\n", symsize);
}
@


<<function doprof1(x86)>>=
void
doprof1(void)
{
    Sym *s;
    long n;
    Prog *p, *q;

    DBG("%5.2f profile 1\n", cputime());

    s = lookup("__mcount", 0);
    n = 1;
    for(p = firstp->link; p != P; p = p->link) {
        if(p->as == ATEXT) {
            q = prg();
            q->line = p->line;

            q->link = datap;
            datap = q;

            //asm: DATA __mcount ??? array? why need to declare it here too?
            q->as = ADATA;
            q->from.type = D_EXTERN;
            q->from.offset = n*4;
            q->from.sym = s; // __mcount
            q->from.scale = 4;  // NOSPLIT?
            q->to = p->from;
            q->to.type = D_CONST;

            q = prg();
            q->line = p->line;
            q->pc = p->pc;

            q->link = p->link;
            p->link = q;
            p = q;

            //asm: ADDL 1, __mcount[n]?
            p->as = AADDL;
            p->from.type = D_CONST;
            p->from.offset = 1;
            p->to.type = D_EXTERN;
            p->to.sym = s;
            p->to.offset = n*4 + 4;

            n += 2;
            continue;
        }
    }

    q = prg();
    q->line = 0;

    q->link = datap;
    datap = q;

    //asm: DATA __mcount ???
    q->as = ADATA;
    q->from.type = D_EXTERN;
    q->from.sym = s;
    q->from.scale = 4;  // NOSPLIT?
    q->to.type = D_CONST;
    q->to.offset = n;

    s->type = SBSS;
    // 4 bytes counter for each functions
    s->value = n*4;
}
@


<<function nuxiinit(x86)>>=
void
nuxiinit(void)
{
    int i, c;

    for(i=0; i<4; i++) {
        c = find1(0x04030201L, i+1);
        if(i < 2)
            inuxi2[i] = c;
        if(i < 1)
            inuxi1[i] = c;
        inuxi4[i] = c;
        fnuxi4[i] = c;
        fnuxi8[i] = c;
        fnuxi8[i+4] = c+4;
    }
    if(debug['v']) {
        Bprint(&bso, "inuxi = ");
        for(i=0; i<1; i++)
            Bprint(&bso, "%d", inuxi1[i]);
        Bprint(&bso, " ");
        for(i=0; i<2; i++)
            Bprint(&bso, "%d", inuxi2[i]);
        Bprint(&bso, " ");
        for(i=0; i<4; i++)
            Bprint(&bso, "%d", inuxi4[i]);
        Bprint(&bso, "\nfnuxi = ");
        for(i=0; i<4; i++)
            Bprint(&bso, "%d", fnuxi4[i]);
        Bprint(&bso, " ");
        for(i=0; i<8; i++)
            Bprint(&bso, "%d", fnuxi8[i]);
        Bprint(&bso, "\n");
    }
    Bflush(&bso);
}
@

%<<function find2(x86)>>=
%//int
%//find2(long l, int c)
%//{
%//    short *p;
%//    int i;
%//
%//    p = (short*)&l;
%//    for(i=0; i<4; i+=2) {
%//        if(((*p >> 8) & 0xff) == c)
%//            return i;
%//        if((*p++ & 0xff) == c)
%//            return i+1;
%//    }
%//    return 0;
%//}
%@



<<function export(x86)>>=
void
export(void)
{
    int i, j, n, off, nb, sv, ne;
    Sym *s, *et, *str, **esyms;
    Prog *p;
    char buf[NSNAME], *t;

    n = 0;
    for(i = 0; i < NHASH; i++)
        for(s = hash[i]; s != S; s = s->link)
            if(s->type != SXREF && s->type != SUNDEF && (nexports == 0 && s->sig != 0 || s->subtype == SEXPORT || allexport))
                n++;
    esyms = malloc(n*sizeof(Sym*));
    ne = n;
    n = 0;
    for(i = 0; i < NHASH; i++)
        for(s = hash[i]; s != S; s = s->link)
            if(s->type != SXREF && s->type != SUNDEF && (nexports == 0 && s->sig != 0 || s->subtype == SEXPORT || allexport))
                esyms[n++] = s;
    for(i = 0; i < ne-1; i++)
        for(j = i+1; j < ne; j++)
            if(strcmp(esyms[i]->name, esyms[j]->name) > 0){
                s = esyms[i];
                esyms[i] = esyms[j];
                esyms[j] = s;
            }

    nb = 0;
    off = 0;
    et = lookup(EXPTAB, 0);
    if(et->type != 0 && et->type != SXREF)
        diag("%s already defined", EXPTAB);
    et->type = SDATA;
    str = lookup(".string", 0);
    if(str->type == 0)
        str->type = SDATA;
    sv = str->value;
    for(i = 0; i < ne; i++){
        s = esyms[i];
        if(debug['S'])
            s->sig = 0;
        /* Bprint(&bso, "EXPORT: %s sig=%lux t=%d\n", s->name, s->sig, s->type); */

        /* signature */
        p = newdata(et, off, sizeof(long), D_EXTERN);
        off += sizeof(long);
        p->to.offset = s->sig;

        /* address */
        p = newdata(et, off, sizeof(long), D_EXTERN);
        off += sizeof(long);
        p->to.type = D_ADDR;
        p->to.index = D_EXTERN;
        p->to.sym = s;

        /* string */
        t = s->name;
        n = strlen(t)+1;
        for(;;){
            buf[nb++] = *t;
            sv++;
            if(nb >= NSNAME){
                p = newdata(str, sv-NSNAME, NSNAME, D_STATIC);
                p->to.type = D_SCONST;
                memmove(p->to.scon, buf, NSNAME);
                nb = 0;
            }
            if(*t++ == 0)
                break;
        }

        /* name */
        p = newdata(et, off, sizeof(long), D_EXTERN);
        off += sizeof(long);
        p->to.type = D_ADDR;
        p->to.index = D_STATIC;
        p->to.sym = str;
        p->to.offset = sv-n;
    }

    if(nb > 0){
        p = newdata(str, sv-nb, nb, D_STATIC);
        p->to.type = D_SCONST;
        memmove(p->to.scon, buf, nb);
    }

    for(i = 0; i < 3; i++){
        newdata(et, off, sizeof(long), D_EXTERN);
        off += sizeof(long);
    }
    et->value = off;
    if(sv == 0)
        sv = 1;
    str->value = sv;
    exports = ne;
    free(esyms);
}
@

<<function newdata(x86)>>=
static Prog*
newdata(Sym *s, int o, int w, int t)
{
    Prog *p;

    p = prg();
    if(edatap == P)
        datap = p;
    else
        edatap->link = p;
    edatap = p;
    p->as = ADATA;
    p->width = w;
    p->from.scale = w;
    p->from.type = t;
    p->from.sym = s;
    p->from.offset = o;
    p->to.type = D_CONST;
    return p;
}
@

<<function import(x86)>>=
void
import(void)
{
    int i;
    Sym *s;

    for(i = 0; i < NHASH; i++)
        for(s = hash[i]; s != S; s = s->link)
            if(s->sig != 0 && s->type == SXREF && (nimports == 0 || s->subtype == SIMPORT)){
                if(s->value != 0)
                    diag("value != 0 on SXREF");
                undefsym(s);
                if(debug['X'])
                    Bprint(&bso, "IMPORT: %s sig=%lux v=%ld\n", s->name, s->sig, s->value);
                if(debug['S'])
                    s->sig = 0;
            }
}
@


<<global reloca(x86)>>=
Adr*	reloca;
@

<<function dynreloc(x86)>>=
void
dynreloc(Sym *s, ulong v, int abs)
{
    int i, k, n;
    byte *m;
    ulong *a;
    Reloc *r;

    if(s->type == SUNDEF)
        k = abs ? ABSU : RELU;
    else
        k = abs ? ABSD : RELD;
    /* Bprint(&bso, "R %s a=%ld(%lx) %d\n", s->name, v, v, k); */
    k = modemap[k];
    r = &rels;
    n = r->n;
    if(n >= r->t)
        grow(r);
    m = r->m;
    a = r->a;
    for(i = n; i > 0; i--){
        if(v < a[i-1]){	/* happens occasionally for data */
            m[i] = m[i-1];
            a[i] = a[i-1];
        }
        else
            break;
    }
    m[i] = k;
    a[i] = v;
    r->n++;
}
@

<<function listinit(x86)>>=
void
listinit(void)
{

    fmtinstall('A', Aconv);
    fmtinstall('R', Rconv);
    fmtinstall('D', Dconv);
    fmtinstall('P', Pconv);
    fmtinstall('S', Sconv);
}
@

<<function Aconv(x86)>>=
// enum<opcode> -> string
int
Aconv(Fmt *fp)
{
    int i;

    i = va_arg(fp->args, int);
    return fmtstrcpy(fp, anames[i]);
}
@

<<global regstr(x86)>>=
// coupling with enum regs in 8.out.h
char*	regstr[] =
{
    "AL",		/* [D_AL] */
    "CL",
    "DL",
    "BL",
    "AH",
    "CH",
    "DH",
    "BH",

    "AX",		/* [D_AX] */
    "CX",
    "DX",
    "BX",
    "SP",
    "BP",
    "SI",
    "DI",

    "F0",		/* [D_F0] */
    "F1",
    "F2",
    "F3",
    "F4",
    "F5",
    "F6",
    "F7",

    "CS",		/* [D_CS] */
    "SS",
    "DS",
    "ES",
    "FS",
    "GS",

    "GDTR",		/* [D_GDTR] */
    "IDTR",		/* [D_IDTR] */
    "LDTR",		/* [D_LDTR] */
    "MSW",		/* [D_MSW] */
    "TASK",		/* [D_TASK] */

    "CR0",		/* [D_CR] */
    "CR1",
    "CR2",
    "CR3",
    "CR4",
    "CR5",
    "CR6",
    "CR7",

    "DR0",		/* [D_DR] */
    "DR1",
    "DR2",
    "DR3",
    "DR4",
    "DR5",
    "DR6",
    "DR7",

    "TR0",		/* [D_TR] */
    "TR1",
    "TR2",
    "TR3",
    "TR4",
    "TR5",
    "TR6",
    "TR7",

    "NONE",		/* [D_NONE] */
};
@
% NONE part of it? this can happen? not more part of enum<operand>?

<<function Rconv(x86)>>=
// enum<operand_kind(register-only)> -> string
int
Rconv(Fmt *fp)
{
    char str[20];
    int r;

    r = va_arg(fp->args, int);
    if(r >= D_AL && r <= D_NONE)
        snprint(str, sizeof(str), "%s", regstr[r-D_AL]);
    else
        snprint(str, sizeof(str), "gok(%d)", r);

    return fmtstrcpy(fp, str);
}
@
%gok??


% used by PConv and Dconv as Dconv need access to enclosing Prog for branch
<<global bigP(x86)>>=
static	Prog	*bigP;
@


<<function Pconv(x86)>>=
// Prog -> string
int
Pconv(Fmt *fp)
{
    char str[STRINGSZ];
    Prog *p;

    p = va_arg(fp->args, Prog*);
    bigP = p;
    switch(p->as) {
    case ATEXT:
        // when this happens?
        if(p->from.scale) {
            snprint(str, sizeof(str), "(%ld)	%A	%D,%d,%D",
                p->line, p->as, &p->from, p->from.scale, &p->to);
        } else {
            snprint(str, sizeof(str), "(%ld)	%A	%D,%D",
                p->line, p->as, &p->from, &p->to);
        }
        break;
    case ADATA:
    case AINIT:
    case ADYNT:
        snprint(str, sizeof(str), "(%ld)	%A	%D/%d,%D",
            p->line, p->as, &p->from, p->from.scale, &p->to);
        break;
    default:
        snprint(str, sizeof(str), "(%ld)	%A	%D,%D",
            p->line, p->as, &p->from, &p->to);
        break;
    }
    bigP = P;
    return fmtstrcpy(fp, str);
}
@



<<function Dconv(x86)>>=
// Adr -> string
int
Dconv(Fmt *fp)
{
    char str[STRINGSZ+40], s[20];
    Adr *a;
    //enum<operand_kind>
    int i;

    a = va_arg(fp->args, Adr*);
    i = a->type;

    <<[[Dconv()]] if i >= D_INDIR(x86)>>

    switch(i) {
    case D_NONE:
        str[0] = '\0';
        break;


    case D_BRANCH:
        if(bigP != P && bigP->pcond != P)
            if(a->sym != S)
                snprint(str, sizeof(str), "%lux+%s", bigP->pcond->pc,
                    a->sym->name);
            else
                snprint(str, sizeof(str), "%lux", bigP->pcond->pc);
        else
            snprint(str, sizeof(str), "%ld(PC)", a->offset);
        break;

    case D_EXTERN:
        snprint(str, sizeof(str), "%s+%ld(SB)", a->sym->name, a->offset);
        break;
    case D_STATIC:
        snprint(str, sizeof(str), "%s<%d>+%ld(SB)", a->sym->name,
            a->sym->version, a->offset);
        break;
    case D_LOCAL:
        snprint(str, sizeof(str), "%s+%ld(SP)", a->sym->name, a->offset);
        break;
    case D_PARAM:
        if(a->sym)
            snprint(str, sizeof(str), "%s+%ld(FP)", a->sym->name, a->offset);
        else
            snprint(str, sizeof(str), "%ld(FP)", a->offset);
        break;

    case D_CONST:
        snprint(str, sizeof(str), "$%ld", a->offset);
        break;
    case D_FCONST:
        snprint(str, sizeof(str), "$(%.8lux,%.8lux)", a->ieee.h, a->ieee.l);
        break;
    case D_SCONST:
        snprint(str, sizeof(str), "$\"%S\"", a->scon);
        break;

    case D_ADDR:
        a->type = a->index;
        a->index = D_NONE;
        snprint(str, sizeof(str), "$%D", a);
        a->index = a->type;
        a->type = D_ADDR;
        goto conv;

    default:
        snprint(str, sizeof(str), "%R", i);
        break;

    }
brk:
    if(a->index != D_NONE) {
        snprint(s, sizeof(s), "(%R*%d)", a->index, a->scale);
        strcat(str, s);
    }
conv:
    return fmtstrcpy(fp, str);
}
@
% todo: could simplify flow, those brk: conv: and goto are ugly,
% copy paste a bit and avoid complex flow instead

%???
<<[[Dconv()]] if i >= D_INDIR(x86)>>=
if(i >= D_INDIR) {
    if(a->offset)
        snprint(str, sizeof(str), "%ld(%R)", a->offset, i-D_INDIR);
    else
        snprint(str, sizeof(str), "(%R)", i-D_INDIR);
    goto brk;
}
@



%????  %S not used that much here, but used a lot in optable, for things
% like MOV%S, means MOVL, MOVB, MOVW?
% for D_SCONST ?? but what is D_SCONST?
<<function Sconv(x86)>>=
// ?? -> string
int
Sconv(Fmt *fp)
{
    int i, c;
    char str[30], *p, *a;

    a = va_arg(fp->args, char*);
    p = str;
    for(i=0; i<sizeof(double); i++) {
        c = a[i] & 0xff;
        if(c >= 'a' && c <= 'z' ||
           c >= 'A' && c <= 'Z' ||
           c >= '0' && c <= '9') {
            *p++ = c;
            continue;
        }
        *p++ = '\\';

        switch(c) {
        default:
            if(c < 040 || c >= 0177)
                break;	/* not portable */
            p[-1] = c;
            continue;
        case 0:
            *p++ = 'z';
            continue;
        case '\\':
        case '"':
            *p++ = c;
            continue;
        case '\n':
            *p++ = 'n';
            continue;
        case '\t':
            *p++ = 't';
            continue;
        }
        *p++ = (c>>6) + '0';
        *p++ = ((c>>3) & 7) + '0';
        *p++ = (c & 7) + '0';
    }
    *p = 0;
    return fmtstrcpy(fp, str);
}
@
% what the fuck is this?

<<function cput(x86)>>=
#define	cput(c)\
    { *cbp++ = c;\
    if(--cbc <= 0)\
        cflush(); }
@


<<function wputl(x86)>>=
/* these need to take long arguments to be compatible with elf.c */
void
wputl(long w)
{
    cput(w);
    cput(w>>8);
}
@


<<function wput(x86)>>=
void
wput(long w)
{
    cput(w>>8);
    cput(w);
}
@

<<function lput(x86)>>=
void
lput(long l)
{
    cput(l>>24);
    cput(l>>16);
    cput(l>>8);
    cput(l);
}
@

<<function lputl(x86)>>=
void
lputl(long l)
{
    cput(l);
    cput(l>>8);
    cput(l>>16);
    cput(l>>24);
}
@

<<function strnput(x86)>>=
void
strnput(char *s, int n)
{
    for(; *s && n > 0; s++){
        cput(*s);
        n--;
    }
    while(n > 0){
        cput(0);
        n--;
    }
}
@


<<function patch(x86)>>=
void
patch(void)
{
    long c;
    Prog *p, *q;
    Sym *s;
    long vexit;

    // could be moved out of patch() in main()?
    DBG("%5.2f mkfwd\n", cputime());
    mkfwd();

    DBG("%5.2f patch\n", cputime());
    s = lookup("exit", 0);
    vexit = s->value;
    for(p = firstp; p != P; p = p->link) {
        if(p->as == ATEXT)
            curtext = p;
        if(p->as == ACALL || p->as == ARET) {
            s = p->to.sym;
            if(s) {
                if(debug['c'])
                    Bprint(&bso, "%s calls %s\n", TNAME, s->name);

                switch(s->type) {
                case STEXT:
                    p->to.offset = s->value;
                    break;
                case SUNDEF:
                    p->pcond = UP;
                    p->to.offset = 0;
                    break;
                default:
                    /* diag prints TNAME first */
                    diag("undefined: %s", s->name);
                    s->type = STEXT;
                    s->value = vexit;
                    break;	/* or fall through to set offset? */
                }
                p->to.type = D_BRANCH;
            }
        }
        if(p->to.type != D_BRANCH || p->pcond == UP)
            continue;

        c = p->to.offset;
        for(q = firstp; q != P;) {
            if(q->forwd != P)
            if(c >= q->forwd->pc) {
                q = q->forwd;
                continue;
            }
            if(c == q->pc)
                break;
            q = q->link;
        }
        if(q == P) {
            diag("branch out of range in %s\n%P", TNAME, p);
            p->to.type = D_NONE;
        }
        p->pcond = q;
    }

    for(p = firstp; p != P; p = p->link) {
        if(p->as == ATEXT)
            curtext = p;
        p->mark = 0;	/* initialization for follow */
        if(p->pcond != P && p->pcond != UP) {
            p->pcond = brloop(p->pcond);
            if(p->pcond != P)
            if(p->to.type == D_BRANCH)
                p->to.offset = p->pcond->pc;
        }
    }
}
@


<<function dodata(x86)>>=
void
dodata(void)
{
    int i;
    Sym *s;
    Prog *p;
    long t, u;

    DBG("%5.2f dodata\n", cputime());

    for(p = datap; p != P; p = p->link) {
        s = p->from.sym;
        if(p->as == ADYNT || p->as == AINIT)
            s->value = dtype;
        if(s->type == SBSS)
            s->type = SDATA;
        if(s->type != SDATA)
            diag("initialize non-data (%d): %s\n%P",
                s->type, s->name, p);
        t = p->from.offset + p->width;
        if(t > s->value)
            diag("initialize bounds (%ld): %s\n%P",
                s->value, s->name, p);
    }
    /* allocate small guys */
    datsize = 0;
    for(i=0; i<NHASH; i++)
    for(s = hash[i]; s != S; s = s->link) {
        if(s->type != SDATA)
        if(s->type != SBSS)
            continue;
        t = s->value;
        if(t == 0) {
            diag("%s: no size", s->name);
            t = 1;
        }
        t = rnd(t, 4);;
        s->value = t;
        if(t > MINSIZ)
            continue;
        s->value = datsize;
        datsize += t;
        s->type = SDATA1;
    }

    /* allocate the rest of the data */
    for(i=0; i<NHASH; i++)
    for(s = hash[i]; s != S; s = s->link) {
        if(s->type != SDATA) {
            if(s->type == SDATA1)
                s->type = SDATA;
            continue;
        }
        t = s->value;
        s->value = datsize;
        datsize += t;
    }

    if(debug['j']) {
        /*
         * pad data with bss that fits up to next
         * 8k boundary, then push data to 8k
         */
        u = rnd(datsize, 8192);
        u -= datsize;
        for(i=0; i<NHASH; i++)
        for(s = hash[i]; s != S; s = s->link) {
            if(s->type != SBSS)
                continue;
            t = s->value;
            if(t > u)
                continue;
            u -= t;
            s->value = datsize;
            s->type = SDATA;
            datsize += t;
        }
        datsize += u;
    }

    /* now the bss */
    bsssize = 0;
    for(i=0; i<NHASH; i++)
    for(s = hash[i]; s != S; s = s->link) {
        if(s->type != SBSS)
            continue;
        t = s->value;
        s->value = bsssize + datsize;
        bsssize += t;
    }
    xdefine("bdata", SDATA, 0L);
    xdefine("edata", SBSS, datsize);
    xdefine("end", SBSS, bsssize + datsize);
    /* etext is defined in span.c */
}
@

<<function span(x86)>>=
void
span(void)
{
    Prog *p, *q;
    long v, c, idat;
    int m, n, again;

    xdefine("etext", STEXT, 0L);
    idat = INITDAT;
    for(p = firstp; p != P; p = p->link) {
        if(p->as == ATEXT)
            curtext = p;
        n = 0;
        if(p->to.type == D_BRANCH)
            if(p->pcond == P)
                p->pcond = p;
        if((q = p->pcond) != P)
            if(q->back != 2)
                n = 1;
        p->back = n;
        if(p->as == AADJSP) {
            p->to.type = D_SP;
            v = -p->from.offset;
            p->from.offset = v;
            p->as = AADDL;
            if(v < 0) {
                p->as = ASUBL;
                v = -v;
                p->from.offset = v;
            }
            if(v == 0)
                p->as = ANOP;
        }
    }
    n = 0;

start:

    DBG("%5.2f span\n", cputime());

    c = INITTEXT;
    for(p = firstp; p != P; p = p->link) {
        if(p->as == ATEXT)
            curtext = p;
        if(p->to.type == D_BRANCH)
            if(p->back)
                p->pc = c;
        asmins(p);
        p->pc = c;
        m = andptr-and;
        p->mark = m;
        c += m;
    }

loop:
    n++;

    DBG("%5.2f span %d\n", cputime(), n);

    if(n > 50) {
        print("span must be looping\n");
        errorexit();
    }
    again = 0;
    c = INITTEXT;
    for(p = firstp; p != P; p = p->link) {
        if(p->as == ATEXT)
            curtext = p;
        if(p->to.type == D_BRANCH) {
            if(p->back)
                p->pc = c;
            asmins(p);
            m = andptr-and;
            if(m != p->mark) {
                p->mark = m;
                again++;
            }
        }
        p->pc = c;
        c += p->mark;
    }
    if(again) {
        textsize = c;
        goto loop;
    }
    if(INITRND) {
        INITDAT = rnd(c, INITRND);
        if(INITDAT != idat) {
            idat = INITDAT;
            goto start;
        }
    }
    xdefine("etext", STEXT, c);

    DBG("etext = %lux\n", c);

    for(p = textp; p != P; p = p->pcond)
        p->from.sym->value = p->pc;
    textsize = c - INITTEXT;
}
@

<<function datblk(x86)>>=
void
datblk(long s, long n)
{
    Prog *p;
    char *cast;
    long l, fl, j;
    int i, c;

    memset(buf.dbuf, 0, n+Dbufslop);
    for(p = datap; p != P; p = p->link) {
        curp = p;
        l = p->from.sym->value + p->from.offset - s;
        c = p->from.scale;
        i = 0;
        if(l < 0) {
            if(l+c <= 0)
                continue;
            while(l < 0) {
                l++;
                i++;
            }
        }
        if(l >= n)
            continue;
        if(p->as != AINIT && p->as != ADYNT) {
            for(j=l+(c-i)-1; j>=l; j--)
                if(buf.dbuf[j]) {
                    print("%P\n", p);
                    diag("multiple initialization");
                    break;
                }
        }
        switch(p->to.type) {
        case D_FCONST:
            switch(c) {
            default:
            case 4:
                fl = ieeedtof(&p->to.ieee);
                cast = (char*)&fl;
                if(debug['a'] && i == 0) {
                    Bprint(&bso, pcstr, l+s+INITDAT);
                    for(j=0; j<c; j++)
                        Bprint(&bso, "%.2ux", cast[fnuxi4[j]] & 0xff);
                    Bprint(&bso, "\t%P\n", curp);
                }
                for(; i<c; i++) {
                    buf.dbuf[l] = cast[fnuxi4[i]];
                    l++;
                }
                break;
            case 8:
                cast = (char*)&p->to.ieee;
                if(debug['a'] && i == 0) {
                    Bprint(&bso, pcstr, l+s+INITDAT);
                    for(j=0; j<c; j++)
                        Bprint(&bso, "%.2ux", cast[fnuxi8[j]] & 0xff);
                    Bprint(&bso, "\t%P\n", curp);
                }
                for(; i<c; i++) {
                    buf.dbuf[l] = cast[fnuxi8[i]];
                    l++;
                }
                break;
            }
            break;

        case D_SCONST:
            if(debug['a'] && i == 0) {
                Bprint(&bso, pcstr, l+s+INITDAT);
                for(j=0; j<c; j++)
                    Bprint(&bso, "%.2ux", p->to.scon[j] & 0xff);
                Bprint(&bso, "\t%P\n", curp);
            }
            for(; i<c; i++) {
                buf.dbuf[l] = p->to.scon[i];
                l++;
            }
            break;

        default:
            fl = p->to.offset;
            if(p->to.type == D_ADDR) {
                if(p->to.index != D_STATIC && p->to.index != D_EXTERN)
                    diag("DADDR type%P", p);
                if(p->to.sym) {
                    if(p->to.sym->type == SUNDEF)
                        ckoff(p->to.sym, fl);
                    fl += p->to.sym->value;
                    if(p->to.sym->type != STEXT && p->to.sym->type != SUNDEF)
                        fl += INITDAT;
                    <<[[datblk()]] if dynamic module(x86)>>
                }
            }
            cast = (char*)&fl;
            switch(c) {
            default:
                diag("bad nuxi %d %d\n%P", c, i, curp);
                break;
            case 1:
                if(debug['a'] && i == 0) {
                    Bprint(&bso, pcstr, l+s+INITDAT);
                    for(j=0; j<c; j++)
                        Bprint(&bso, "%.2ux", cast[inuxi1[j]] & 0xff);
                    Bprint(&bso, "\t%P\n", curp);
                }
                for(; i<c; i++) {
                    buf.dbuf[l] = cast[inuxi1[i]];
                    l++;
                }
                break;
            case 2:
                if(debug['a'] && i == 0) {
                    Bprint(&bso, pcstr, l+s+INITDAT);
                    for(j=0; j<c; j++)
                        Bprint(&bso, "%.2ux", cast[inuxi2[j]] & 0xff);
                    Bprint(&bso, "\t%P\n", curp);
                }
                for(; i<c; i++) {
                    buf.dbuf[l] = cast[inuxi2[i]];
                    l++;
                }
                break;
            case 4:
                if(debug['a'] && i == 0) {
                    Bprint(&bso, pcstr, l+s+INITDAT);
                    for(j=0; j<c; j++)
                        Bprint(&bso, "%.2ux", cast[inuxi4[j]] & 0xff);
                    Bprint(&bso, "\t%P\n", curp);
                }
                for(; i<c; i++) {
                    buf.dbuf[l] = cast[inuxi4[i]];
                    l++;
                }
                break;
            }
            break;
        }
    }
    write(cout, buf.dbuf, n);
}
@



<<[[asmb()]] if dynamic module magic header adjustment(x86)>>=
if(dlm)
    magic |= 0x80000000;
@


<<function asmb(x86)>>=
void
asmb(void)
{
    Prog *p;
    long v, magic;
    int a;
    byte *op1;

    DBG("%5.2f asmb\n", cputime());

    // TEXT SECTION

    seek(cout, HEADR, SEEK__START);
    pc = INITTEXT;
    curp = firstp;

    for(p = firstp; p != P; p = p->link) {
        if(p->as == ATEXT)
            curtext = p;
        if(p->pc != pc) {
            if(!debug['a'])
                print("%P\n", curp);
            diag("phase error %lux sb %lux in %s", p->pc, pc, TNAME);
            pc = p->pc;
        }
        curp = p;

        // generate instruction!
        asmins(p);

        if(cbc < sizeof(and))
            cflush();
        a = (andptr - and);

        if(debug['a']) {
            Bprint(&bso, pcstr, pc);
            for(op1 = and; op1 < andptr; op1++)
                Bprint(&bso, "%.2ux", *op1 & 0xff);
            Bprint(&bso, "\t%P\n", curp);
        }

        <<[[asmb()]] if dynamic module, when iterate from firstp(x86)>>

        memmove(cbp, and, a);
        cbp += a;
        pc += a;
        cbc -= a;
    }
    cflush();

    // DATA SECTION

    switch(HEADTYPE) {
    case H_PLAN9:
        seek(cout, HEADR+textsize, SEEK__START);
        break;
    <<[[asmb()]] switch HEADTYPE (to position after text) cases(x86)>>
    default:
        diag("unknown header type %d", HEADTYPE);
    }

    DBG("%5.2f datblk\n", cputime());

    <<[[asmb()]] if dynamic module, before datblk()>>

    for(v = 0; v < datsize; v += sizeof(buf)-Dbufslop) {
        if(datsize-v > sizeof(buf)-Dbufslop)
            datblk(v, sizeof(buf)-Dbufslop);
        else
            datblk(v, datsize-v);
    }

    // SYMBOL TABLE

    // modified by asmsym()
    symsize = 0;
    // modified by asmlc()
    lcsize = 0;

    if(!debug['s']) {
        DBG("%5.2f sym\n", cputime());

        switch(HEADTYPE) {
        case H_PLAN9:
            seek(cout, HEADR+textsize+datsize, 0);
            break;
        <<[[asmb()]] switch HEADTYPE (for symbol table generation) cases(x86)>>
        default:
            seek(cout, rnd(HEADR+textsize, 8192)+datsize, 0);
            break;
        }

        asmsym();

        DBG("%5.2f sp\n", cputime());
        DBG("%5.2f pc\n", cputime());

        asmlc();

        <<[[asmb()]] if dynamic module, call asmdyn()>>
        cflush();
    } else {
        <<[[asmb()]] if dynamic module and no symbol table generation>>
    }

    // HEADER

    DBG("%5.2f headr\n", cputime());

    seek(cout, 0L, SEEK__START);

    switch(HEADTYPE) {
    // see Exec in a.out.h
    case H_PLAN9:	/* plan9 */
        magic = 4*11*11+7;
        <<[[asmb()]] if dynamic module magic header adjustment(x86)>>
        lput(magic);			/* magic */
        lput(textsize);			/* sizes */
        lput(datsize);
        lput(bsssize);
        lput(symsize);			/* nsyms */

        lput(entryvalue());		/* va of entry */

        lput(spsize);			/* sp offsets */
        lput(lcsize);			/* line offsets */
        break;
    <<[[asmb()]] switch HEADTYPE (for header generation) cases(x86)>>
    }

    cflush();
}
@



<<[[main()]] switch HEADTYPE cases(x86)>>=
case H_GARBAGE:	/* this is garbage */
    HEADR = 20L+56L;
    if(INITTEXT == -1)
        INITTEXT = 0x40004CL;
    if(INITDAT == -1)
        INITDAT = 0x10000000L;
    if(INITRND == -1)
        INITRND = 0;
    break;
case H_COFF:	/* is unix coff */
    HEADR = 0xd0L;
    if(INITTEXT == -1)
        INITTEXT = 0xd0;
    if(INITDAT == -1)
        INITDAT = 0x400000;
    if(INITRND == -1)
        INITRND = 0;
    break;
case H_COM:	/* MS-DOS .COM */
    HEADR = 0;
    if(INITTEXT == -1)
        INITTEXT = 0x0100;
    if(INITDAT == -1)
        INITDAT = 0;
    if(INITRND == -1)
        INITRND = 4;
    break;
case H_EXE:	/* fake MS-DOS .EXE */
    HEADR = 0x200;
    if(INITTEXT == -1)
        INITTEXT = 0x0100;
    if(INITDAT == -1)
        INITDAT = 0;
    if(INITRND == -1)
        INITRND = 4;
    HEADR += (INITTEXT & 0xFFFF);
    DBG("HEADR = 0x%ld\n", HEADR);
    break;
case H_ELF:	/* elf executable */
    HEADR = rnd(Ehdr32sz+3*Phdr32sz, 16);
    if(INITTEXT == -1)
        INITTEXT = 0x80100020L;
    if(INITDAT == -1)
        INITDAT = 0;
    if(INITRND == -1)
        INITRND = 4096;
    break;
@


<<[[asmb()]] switch HEADTYPE (to position after text) cases(x86)>>=
case H_GARBAGE:
    seek(cout, rnd(HEADR+textsize, 8192), 0);
    break;
case H_COFF:
    textsize = rnd(HEADR+textsize, 4096)-HEADR;
    seek(cout, textsize+HEADR, 0);
    break;
case H_ELF: // like H_PLAN9
    seek(cout, HEADR+textsize, 0);
    break;
case H_COM:
case H_EXE:
    seek(cout, HEADR+rnd(textsize, INITRND), 0);
    break;
@

<<[[asmb()]] switch HEADTYPE (for symbol table generation) cases(x86)>>=
case H_GARBAGE:
case H_COFF:
    seek(cout, rnd(HEADR+textsize, INITRND)+datsize, 0);
    break;
//case H_PLAN9:
case H_ELF:
    seek(cout, HEADR+textsize+datsize, 0);
    break;
case H_COM:
case H_EXE:
    debug['s'] = 1;
    break;
@

<<[[asmb()]] switch HEADTYPE (for header generation) cases(x86)>>=
default:
case H_GARBAGE:	/* garbage */
    lput(0x160L<<16);		/* magic and sections */
    lput(0L);			/* time and date */
    lput(rnd(HEADR+textsize, 4096)+datsize);
    lput(symsize);			/* nsyms */
    lput((0x38L<<16)|7L);		/* size of optional hdr and flags */
    lput((0413<<16)|0437L);		/* magic and version */
    lput(rnd(HEADR+textsize, 4096));/* sizes */
    lput(datsize);
    lput(bsssize);
    lput(entryvalue());		/* va of entry */
    lput(INITTEXT-HEADR);		/* va of base of text */
    lput(INITDAT);			/* va of base of data */
    lput(INITDAT+datsize);		/* va of base of bss */
    lput(~0L);			/* gp reg mask */
    lput(0L);
    lput(0L);
    lput(0L);
    lput(0L);
    lput(~0L);			/* gp value ?? */
    break;
case H_COFF:	/* unix coff */
    /*
     * file header
     */
    lputl(0x0004014c);		/* 4 sections, magic */
    lputl(0);			/* unix time stamp */
    lputl(0);			/* symbol table */
    lputl(0);			/* nsyms */
    lputl(0x0003001c);		/* flags, sizeof a.out header */
    /*
     * a.out header
     */
    lputl(0x10b);			/* magic, version stamp */
    lputl(rnd(textsize, INITRND));	/* text sizes */
    lputl(datsize);			/* data sizes */
    lputl(bsssize);			/* bss sizes */
    lput(entryvalue());		/* va of entry */
    lputl(INITTEXT);		/* text start */
    lputl(INITDAT);			/* data start */
    /*
     * text section header
     */
    strnput(".text", 8);
    lputl(HEADR);			/* pa */
    lputl(HEADR);			/* va */
    lputl(textsize);		/* text size */
    lputl(HEADR);			/* file offset */
    lputl(0);			/* relocation */
    lputl(0);			/* line numbers */
    lputl(0);			/* relocation, line numbers */
    lputl(0x20);			/* flags text only */
    /*
     * data section header
     */
    strnput(".data", 8);
    lputl(INITDAT);			/* pa */
    lputl(INITDAT);			/* va */
    lputl(datsize);			/* data size */
    lputl(HEADR+textsize);		/* file offset */
    lputl(0);			/* relocation */
    lputl(0);			/* line numbers */
    lputl(0);			/* relocation, line numbers */
    lputl(0x40);			/* flags data only */
    /*
     * bss section header
     */
    strnput(".bss", 8);
    lputl(INITDAT+datsize);		/* pa */
    lputl(INITDAT+datsize);		/* va */
    lputl(bsssize);			/* bss size */
    lputl(0);			/* file offset */
    lputl(0);			/* relocation */
    lputl(0);			/* line numbers */
    lputl(0);			/* relocation, line numbers */
    lputl(0x80);			/* flags bss only */
    /*
     * comment section header
     */
    strnput(".comment", 8);
    lputl(0);			/* pa */
    lputl(0);			/* va */
    lputl(symsize+lcsize);		/* comment size */
    lputl(HEADR+textsize+datsize);	/* file offset */
    lputl(HEADR+textsize+datsize);	/* offset of syms */
    lputl(HEADR+textsize+datsize+symsize);/* offset of line numbers */
    lputl(0);			/* relocation, line numbers */
    lputl(0x200);			/* flags comment only */
    break;
case H_COM:
    /* MS-DOS .COM */
    break;
case H_EXE:
    /* fake MS-DOS .EXE */
    v = rnd(HEADR+textsize, INITRND)+datsize;
    wputl(0x5A4D);			/* 'MZ' */
    wputl(v % 512);			/* bytes in last page */
    wputl(rnd(v, 512)/512);		/* total number of pages */
    wputl(0x0000);			/* number of reloc items */
    v = rnd(HEADR-(INITTEXT & 0xFFFF), 16);
    wputl(v/16);			/* size of header */
    wputl(0x0000);			/* minimum allocation */
    wputl(0xFFFF);			/* maximum allocation */
    wputl(0x0000);			/* initial ss value */
    wputl(0x0100);			/* initial sp value */
    wputl(0x0000);			/* complemented checksum */
    v = entryvalue();
    wputl(v);			/* initial ip value (!) */
    wputl(0x0000);			/* initial cs value */
    wputl(0x0000);
    wputl(0x0000);
    wputl(0x003E);			/* reloc table offset */
    wputl(0x0000);			/* overlay number */
    break;
case H_ELF:
    elf32(I386, ELFDATA2LSB, 0, nil);
    break;
@




<<function doprof2(x86)>>=
void
doprof2(void)
{
    Sym *s2, *s4;
    Prog *p, *q, *q2;
    Prog *ps2, *ps4;

    DBG("%5.2f profile 2\n", cputime());

    <<[[doprof2()]] if embedded tracing>>
    else{
        s2 = lookup("_profin", 0);
        s4 = lookup("_profout", 0);
    }
    if(s2->type != STEXT || s4->type != STEXT) {
       <<[[doprof2()]] if embedded tracing diag()>>
        else
            diag("_profin/_profout not defined");
        return;
    }

    // finding ps2, ps4 = instruction (Prog) of s2 and s4
    ps2 = P;
    ps4 = P;
    for(p = firstp; p != P; p = p->link) {
        if(p->as == ATEXT) {
            if(p->from.sym == s2) {
                // do not profile the profling function itself ...
                p->from.scale = NOPROF;
                ps2 = p;
            }
            if(p->from.sym == s4) {
                p->from.scale = NOPROF;
                ps4 = p;
            }
        }
    }

    for(p = firstp; p != P; p = p->link) {
        if(p->as == ATEXT) {
            curtext = p;

            <<[[doprof2()]] if NOPROF p(x86)>>

            /*
             * JMPL	profin
             */
            q = prg();
            q->line = p->line;
            q->pc = p->pc;
            q->link = p->link;

            <<[[doprof2()]] if embedded tracing ATEXT instrumentation(x86)>>
             else
                p->link = q;
            p = q;
            //asm: CALL _profin
            p->as = ACALL;
            p->to.type = D_BRANCH;
            p->pcond = ps2;
            p->to.sym = s2;

        }else if(p->as == ARET) {
            <<[[doprof2()]] if embedded tracing ARET instrumentation>>
            /*
             * RET
             */
            q = prg();
            q->as = ARET;
            q->from = p->from;
            q->to = p->to;
            q->link = p->link;

            p->link = q;

            /*
             * JAL	profout
             */
            //asm: CALL _profout
            p->as = ACALL;
            p->from = zprg.from;
            p->to = zprg.to;
            p->to.type = D_BRANCH;
            p->pcond = ps4;
            p->to.sym = s4;

            p = q;
        }
    }
}
@



<<[[doprof2()]] if NOPROF p(x86)>>=
if(p->from.scale & NOPROF) {	/* dont profile */
    for(;;) {
        q = p->link;
        if(q == P)
            break;
        if(q->as == ATEXT)
            break;
        p = q;
    }
    continue;
}
@

<<[[doprof2()]] if embedded tracing ATEXT instrumentation(x86)>>=
if(debug['e']){		/* embedded tracing */
    q2 = prg();
    p->link = q2;
    q2->link = q;

    q2->line = p->line;
    q2->pc = p->pc;

    q2->as = AJMP;
    q2->to.type = D_BRANCH;
    q2->to.sym = p->to.sym;
    q2->pcond = q->link;
}
@


<<[[main()]] cout is ready, LET'S GO(x86)>>=
firstp = prg();
lastp = firstp;

<<[[main()]] set INITENTRY>>

while(*argv)
    objfile(*argv++);

if(load_libs)
    loadlib();

firstp = firstp->link;
if(firstp == P)
    errorexit();

<<[[main()]] if export table or dynamic module(x86)>>

patch();
follow();
dodata();
dostkoff();
<<[[main()]] call doprofxxx() if profiling>>
span();
doinit();

// write to cout, finally
asmb();

// sanity check
undef();
@


<<[[main()]] command line processing(x86)>>=
    case 'o': /* output to (next arg) */
        outfile = ARGF();
        break;
@


<<function main (linkers/8l/obj.c)>>=
void
main(int argc, char *argv[])
{
    <<[[main()]] locals(x86)>>

    thechar = '8';
    thestring = "386";   
    outfile = "8.out";

    <<[[main()]] debug initialization(x86)>>

    ARGBEGIN {
    <<[[main()]] command line processing(x86)>>
    } ARGEND
    USED(argc);
    if(*argv == nil)
        usage();

    <<[[main()]] addlibpath("/{thestring}/lib") or ccroot>>

    <<[[main()]] adjust HEADTYPE if debug flags(x86)>>
    switch(HEADTYPE) {
    <<[[main()]] switch HEADTYPE cases(x86)>>
    default:
        diag("unknown -H option");
        errorexit();

    }
    <<[[main()]] last INITXXX adjustments>>

    DBG("HEADER = -H0x%ld -T0x%lux -D0x%lux -R0x%lux\n",
            HEADTYPE, INITTEXT, INITDAT, INITRND);

    <<[[main()]] sanity check optab(x86)>>
    <<[[main()]] initialize globals(x86)>>

    nuxiinit();

    cout = create(outfile, 1, 0775);
    if(cout < 0) {
        diag("cannot create %s: %r", outfile);
        errorexit();
    }

    // ------ main functions  ------
    <<[[main()]] cout is ready, LET'S GO(x86)>>

    <<[[main()]] profile report>>
    errorexit();
}
@
%$ 


<<[[main()]] command line processing(x86)>>=
case 'H':
    a = ARGF();
    if(a)
        HEADTYPE = atolwhex(a);
    break;
case 'T':
    a = ARGF();
    if(a)
        INITTEXT = atolwhex(a);
    break;
case 'D':
    a = ARGF();
    if(a)
        INITDAT = atolwhex(a);
    break;
case 'E':
    a = ARGF();
    if(a)
        INITENTRY = a;
    break;
case 'R':
    a = ARGF();
    if(a)
        INITRND = atolwhex(a);
    break;
@


<<[[main()]] switch HEADTYPE cases(x86)>>=
case H_PLAN9:	/* plan 9 */
    HEADR = 32L;
    if(INITTEXT == -1)
        INITTEXT = 4096+32;
    if(INITDAT == -1)
        INITDAT = 0;
    if(INITRND == -1)
        INITRND = 4096;
    break;
@

% used locals? move closer the the code that use it then
<<[[main()]] locals(x86)>>=
    int i, c;
    char name[LIBNAMELEN];
    char *a;
@

<<[[main()]] initialize globals(x86)>>=
<<[[main()]] set ycover(x86)>>
<<[[main()]] set reg(x86)>>
<<[[main()]] set zprg(x86)>>
dtype = 4;

cbp = buf.obuf;
cbc = sizeof(buf.obuf);
@

<<[[main()]] set zprg(x86)>>=
zprg.link = P;
zprg.pcond = P;
zprg.back = 2;
zprg.as = AGOK;
zprg.from.type = D_NONE;
zprg.from.index = D_NONE;
zprg.from.scale = 1;
zprg.to = zprg.from;
@

<<[[main()]] locals(x86)>>=
bool load_libs;
@

% -l means no automagic stdlibs
<<[[main()]] initialize globals(x86)>>=
load_libs = !debug['l'];
@


<<[[main()]] command line processing(x86)>>=
case 'L':
    addlibpath(EARGF(usage()));
    break;
@

% was called a
<<[[main()]] locals(x86)>>=
char *root;
@

% starts at 1 because of AXXX (but why need AXXX?)
<<[[main()]] sanity check optab(x86)>>=
for(i=1; optab[i].as; i++)
    if(i != optab[i].as) {
        diag("phase error in optab: %d", i);
        errorexit();
    }
@

<<[[main()]] command line processing(x86)>>=
case 'x':	/* produce export table */
    doexp = true;
    if(argv[1] != nil && argv[1][0] != '-' && !isobjfile(argv[1])){
        a = ARGF();
        if(strcmp(a, "*") == 0)
            allexport = true;
        else
            readundefs(a, SEXPORT);
    }
    break;
@

<<[[main()]] if dynamic module(x86)>>=
if(dlm){
    import();
    HEADTYPE = H_PLAN9;
    INITTEXT = INITDAT = 0;
    INITRND = 8;
    INITENTRY = EXPTAB;
}
@

<<[[main()]] if export table or dynamic module(x86)>>=
if(doexp || dlm){
    EXPTAB = "_exporttab";
    zerosig(EXPTAB);
    zerosig("etext");
    zerosig("edata");
    zerosig("end");

   <<[[main()]] if dynamic module(x86)>>

    export();
}
@

<<[[main()]] command line processing(x86)>>=
case 'u':	/* produce dynamically loadable module */
    dlm = true;
    // do not load standard libraries
    debug['l'] = true;

    if(argv[1] != nil && argv[1][0] != '-' && !isobjfile(argv[1]))
        readundefs(ARGF(), SIMPORT);
    break;
@


<<[[asmb()]] if dynamic module, when iterate from firstp(x86)>>=
if(dlm) {
    if(p->as == ATEXT)
        reloca = nil;
    else if(reloca != nil)
        diag("reloc failure: %P", curp);
}
@

<<[[datblk()]] if dynamic module(x86)>>=
if(dlm)
    dynreloc(p->to.sym, l+s+INITDAT, 1);
@


<<[[main()]] command line processing(x86)>>=
case 'P':
    a = ARGF();
    if(a)
        INITTEXTP = atolwhex(a);
    break;
@

<<[[main()]] debug initialization(x86)>>=
Binit(&bso, 1, OWRITE);
listinit(); // fmtinstall()
memset(debug, false, sizeof(debug));
@

<<[[main()]] command line processing(x86)>>=
default:
    c = ARGC();
    if(c >= 0 && c < sizeof(debug))
        debug[c] = true;
    break;
@

% obsolete?
<<[[main()]] adjust HEADTYPE if debug flags(x86)>>=
if(HEADTYPE == -1) {
  HEADTYPE = DEFAULT;
}
@

<<function ldobj(x86)>>=
void
ldobj(fdt f, long c, char *pn)
{
    <<[[ldobj()]] locals(x86)>>

    <<[[ldobj()]] grow filen if not enough space>>
    filen[files++] = strdup(pn);

    <<[[ldobj()]] bloc and bsize init>>

    di = S;

// can come from AEND
newloop:
    version++;
    memset(h, 0, sizeof(h));
    histfrogp = 0;
    ipc = pc;
    skip = false;

loop:
    if(c <= 0)
        goto eof;

    <<[[ldobj()]] read if needed in loop:, adjust bloc and bsize>>

    // get the opcode
    o = bloc[0] | (bloc[1] << 8); // >>

    <<[[ldobj()]] sanity check opcode in range(x86)>>

    <<[[ldobj()]] if ANAME or ASIGNAME(x86)>>

    //TODO: factorize
    while(nhunk < sizeof(Prog))
        gethunk();
    p = (Prog*)hunk;
    nhunk -= sizeof(Prog);
    hunk += sizeof(Prog);

    p->as = o;
    p->line = bloc[2] | (bloc[3] << 8) | (bloc[4] << 16) | (bloc[5] << 24);
    p->back = 2;
    // >> >> >>

    r = zaddr(bloc+6, &p->from, h) + 6;
    r += zaddr(bloc+r, &p->to, h);

    bloc += r;
    c -= r;

    if(debug['W'])
        print("%P\n", p);

    switch(p->as) {
    <<[[ldobj()]] switch as cases(x86)>>

    default:
    casdef:
        if(skip)
            nopout(p);

        if(p->to.type == D_BRANCH)
            p->to.offset += ipc;

        lastp->link = p;
        lastp = p;

        p->pc = pc;
        pc++;
    }
    goto loop;

eof:
    diag("truncated object file: %s", pn);
}
@

% >> >> >> >>

<<[[ldobj()]] locals(x86)>>=
// enum<as>, the opcode
int o;
Prog *p;
@


% ???
<<[[ldobj()]] locals(x86)>>=
Sym *h[NSYM];
Sym *di;
Sym *s;
long ipc;
bool skip;
@

%???
<<[[ldobj()]] locals(x86)>>=
Prog *t;
byte *stop;
int v;
ulong sig;
@

<<[[ldobj()]] locals(x86)>>=
byte *bloc;
byte *bsize;
int r;
@
% and parameter 'int c'

<<[[ldobj()]] sanity check opcode in range(x86)>>=
if(o <= AXXX || o >= ALAST) {
    if(o < 0)
        goto eof;
    diag("%s: opcode out of range %d", pn, o);
    print("	probably not a .8 file\n");
    errorexit();
}
@

<<[[ldobj()]] locals(x86)>>=
// array<string>, length used = files, extended every 16
static char **filen;
static int files = 0;
char **nfilen;
@

<<[[ldobj()]] if ANAME or ASIGNAME(x86)>>=
if(o == ANAME || o == ASIGNAME) {
    sig = 0;
    if(o == ASIGNAME) {
        sig = bloc[2] | (bloc[3]<<8) | (bloc[4]<<16) | (bloc[5]<<24);
        // >> >> >>
        bloc += 4;
        c -= 4;
    }
    stop = memchr(&bloc[4], 0, bsize-&bloc[4]);
    if(stop == nil){
        bsize = readsome(f, buf.ibuf, bloc, bsize, c);
        if(bsize == 0)
            goto eof;
        bloc = buf.ibuf;
        stop = memchr(&bloc[4], 0, bsize-&bloc[4]);
        if(stop == nil){
            fprint(2, "%s: name too long\n", pn);
            errorexit();
        }
    }

    v = bloc[2];	/* type */
    o = bloc[3];	/* sym */
    bloc += 4;
    c -= 4;

    r = 0;
    if(v == D_STATIC)
        r = version;
    s = lookup((char*)bloc, r);

    c -= &stop[1] - bloc;
    bloc = stop + 1;

    if(debug['S'] && r == 0)
        sig = 1729;
    if(sig != 0){
        if(s->sig != 0 && s->sig != sig)
            diag("incompatible type signatures %lux(%s) and %lux(%s) for %s", s->sig, filen[s->file], sig, pn, s->name);
        s->sig = sig;
        s->file = files-1;
    }

    if(debug['W'])
        print("	ANAME	%s\n", s->name);

    h[o] = s;
    if((v == D_EXTERN || v == D_STATIC) && s->type == 0)
        s->type = SXREF;
    if(v == D_FILE) {
        if(s->type != SFILE) {
            histgen++;
            s->type = SFILE;
            s->value = histgen;
        }
        if(histfrogp < MAXHIST) {
            histfrog[histfrogp] = s;
            histfrogp++;
        } else
            collapsefrog(s);
    }
    goto loop;
}
@
% >> >> >>

<<[[ldobj()]] switch as cases(x86)>>=
case ATEXT:
    if(curtext != P) {
        histtoauto();
        curtext->to.autom = curauto;
        curauto = 0;
    }
    skip = false;
    curtext = p;
    s = p->from.sym;
    if(s == S) {
        diag("%s: no TEXT symbol: %P", pn, p);
        errorexit();
    }
    if(s->type != 0 && s->type != SXREF) {
        if(p->from.scale & DUPOK) {
            skip = true;
            goto casdef;
        }
        diag("%s: redefinition: %s\n%P", pn, s->name, p);
    }
    s->type = STEXT;
    s->value = pc;

    //add_list(firstp, lastp, p)
    lastp->link = p;
    lastp = p;

    p->pc = pc;
    pc++;

    //add_list(textp, etextp, p)
    if(textp == P) {
        textp = p;
        etextp = p;
    } else {
        etextp->pcond = p;
        etextp = p;
    }

    break;
@

<<[[ldobj()]] switch as cases(x86)>>=
case ADATA:
data:
    //add_list(datap, edatap, p)
    if(edatap == P)
        datap = p;
    else
        edatap->link = p;
    edatap = p;
    p->link = P;
    break;
@

<<[[ldobj()]] switch as cases(x86)>>=
case ADYNT:
    if(p->to.sym == S) {
        diag("DYNT without a sym\n%P", p);
        break;
    }
    di = p->to.sym;
    p->from.scale = 4; // NOSPLIT?
    if(di->type == SXREF) {
        if(debug['z'])
            Bprint(&bso, "%P set to %d\n", p, dtype);
        di->type = SCONST;
        di->value = dtype;
        dtype += 4;
    }
    if(p->from.sym == S)
        break;

    p->from.offset = di->value;
    p->from.sym->type = SDATA;
    if(curtext == P) {
        diag("DYNT not in text: %P", p);
        break;
    }
    p->to.sym = curtext->from.sym;
    p->to.type = D_ADDR;
    p->to.index = D_EXTERN;
    goto data;
@

<<[[ldobj()]] switch as cases(x86)>>=
case AINIT:
    if(p->from.sym == S) {
        diag("INIT without a sym\n%P", p);
        break;
    }
    if(di == S) {
        diag("INIT without previous DYNT\n%P", p);
        break;
    }
    p->from.offset = di->value;
    p->from.sym->type = SDATA;
    goto data;
@

<<[[ldobj()]] switch as cases(x86)>>=
case AGLOBL:
    s = p->from.sym;
    if(s->type == 0 || s->type == SXREF) {
        s->type = SBSS;
        s->value = 0;
    }
    if(s->type != SBSS) {
        diag("%s: redefinition: %s in %s",
            pn, s->name, TNAME);
        s->type = SBSS;
        s->value = 0;
    }
    if(p->to.offset > s->value)
        s->value = p->to.offset;
    break;
@

<<[[ldobj()]] switch as cases(x86)>>=
case AHISTORY:
    if(p->to.offset == -1) {
        addlib(pn);
        histfrogp = 0;
        goto loop;
    }
    addhist(p->line, D_FILE);		/* 'z' */
    if(p->to.offset)
        addhist(p->to.offset, D_FILE1);	/* 'Z' */
    histfrogp = 0;
    break;
@

<<[[ldobj()]] switch as cases(x86)>>=
case AEND:
    histtoauto();
    if(curtext != P)
        curtext->to.autom = curauto;
    curauto = 0;
    curtext = P;
    if(c)
        goto newloop;
    return;
@


<<[[ldobj()]] switch as cases(x86)>>=
case AGOK:
    diag("%s: GOK opcode in %s", pn, TNAME);
    pc++;
    break;
@

<<[[ldobj()]] switch as cases(x86)>>=
case AFMOVF:
case AFADDF:
case AFSUBF:
case AFSUBRF:
case AFMULF:
case AFDIVF:
case AFDIVRF:
case AFCOMF:
case AFCOMFP:
    if(skip)
        goto casdef;
    if(p->from.type == D_FCONST) {
        /* size sb 9 max */
        sprint(literal, "$%lux", ieeedtof(&p->from.ieee));
        s = lookup(literal, 0);
        if(s->type == 0) {
            s->type = SBSS;
            s->value = 4;
            t = prg();
            t->as = ADATA;
            t->line = p->line;
            t->from.type = D_EXTERN;
            t->from.sym = s;
            t->from.scale = 4;  // NOSPLIT?
            t->to = p->from;
            if(edatap == P)
                datap = t;
            else
                edatap->link = t;
            edatap = t;
            t->link = P;
        }
        p->from.type = D_EXTERN;
        p->from.sym = s;
        p->from.offset = 0;
    }
    goto casdef;
@
%$

<<[[ldobj()]] switch as cases(x86)>>=
case AFMOVD:
case AFADDD:
case AFSUBD:
case AFSUBRD:
case AFMULD:
case AFDIVD:
case AFDIVRD:
case AFCOMD:
case AFCOMDP:
    if(skip)
        goto casdef;
    if(p->from.type == D_FCONST) {
        /* size sb 18 max */
        sprint(literal, "$%lux.%lux",
            p->from.ieee.l, p->from.ieee.h);
        s = lookup(literal, 0);
        if(s->type == 0) {
            s->type = SBSS;
            s->value = 8;
            t = prg();
            t->as = ADATA;
            t->line = p->line;
            t->from.type = D_EXTERN;
            t->from.sym = s;
            t->from.scale = 8;
            t->to = p->from;
            if(edatap == P)
                datap = t;
            else
                edatap->link = t;
            edatap = t;
            t->link = P;
        }
        p->from.type = D_EXTERN;
        p->from.sym = s;
        p->from.offset = 0;
    }
    goto casdef;
@
%$


\section{[[linkers/8l/]]}

\subsection*{[[linkers/8l/elf.h]]}

%-------------------------------------------------------------

<<linkers/8l/elf.h>>=
#include <elf.h>

// vs include/elf.h? and libmach/elf.h?

<<enum _anon_ (linkers/8l/elf.h)>>

typedef void (*Putl)(long);

void	elf32(int mach, int bo, int addpsects, void (*putpsects)(Putl));
@
%void	elf64(int mach, int bo, int addpsects, void (*putpsects)(Putl));
%
%//void	elf32phdr(void (*putl)(long), ulong type, ulong off, ulong vaddr,
%//    ulong paddr, ulong filesz, ulong memsz, ulong prots, ulong align);
%//void	elf32shdr(void (*putl)(long), ulong name, ulong type, ulong flags,
%//    ulong vaddr, ulong off, ulong sectsz, ulong link, ulong addnl,
%//    ulong align, ulong entsz);
%//void	elf64phdr(void (*putl)(long), void (*putll)(vlong), ulong type,
%//    uvlong off, uvlong vaddr, uvlong paddr, uvlong filesz, uvlong memsz,
%//    ulong prots, uvlong align);
%//void	elf64shdr(void (*putl)(long), void (*putll)(vlong), ulong name,
%//    ulong type, uvlong flags, uvlong vaddr, uvlong off, uvlong sectsz,
%//    ulong link, ulong addnl, uvlong align, uvlong entsz);


\subsection*{[[linkers/8l/l.h]]}




\ifallcode
% can have unamed union that then alleviate the need for those macros!
% this is not used anymore for the arm, but could be used by 8l
% todo: need to adapt graph_code_c to find those fields
<<constant offset>>=
#define	offset	u0.u0offset
@
<<constant ieee>>=
#define	ieee	u0.u0ieee
@
<<constant autom>>=
#define	autom	u1.u1autom
@
<<constant sym>>=
#define	sym	u1.u1sym
@
%<<constant sval(arm)>>=
%#define	sval	u0.u0sval
%@
\fi



<<enum misc1(x86)>>=
enum misc1 {
    <<constant NHASH linker>>
    <<constant NHUNK linker>>

    MINSIZ		= 4,
    <<constant STRINGSZ>>
    MINLC		= 1,
    <<constant MAXIO>>
    MAXHIST		= 20, /* limit of path elements for history symbols */
};
@


%-------------------------------------------------------------

<<linkers/8l/l.h>>=
#include	<u.h>
#include	<libc.h>
#include	<bio.h>

#include	<common.out.h>
#include	<386/8.out.h>
#include	"elf.h"

<<macro DBG>>

<<constant P>>
<<constant S>>

<<constant TNAME(x86)>>

<<function cput(x86)>>

<<constant LIBNAMELEN>>

typedef	struct	Adr	Adr;
typedef	struct	Prog	Prog;
typedef	struct	Sym	Sym;
typedef	struct	Auto	Auto;
typedef	struct	Optab	Optab;

<<struct Adr(x86)>>

<<constant offset>>
<<constant scon(x86)>>
<<constant cond(x86)>>
<<constant ieee>>

<<constant autom>>
<<constant sym>>

<<struct Prog(x86)>>
<<struct Auto(x86)>>
<<struct Sym>>
<<struct Optab(x86)>>

<<enum sxxx(x86)>>
<<enum yxxx(x86)>>
<<enum zxxx(x86)>>
<<enum pxxx(x86)>>
<<enum rxxx>>

<<enum misc1(x86)>>

<<enum headtype(x86)>>

<<struct Buf>>
extern union Buf buf;

#pragma	varargck	type	"A"	int
#pragma	varargck	type	"A"	uint
#pragma	varargck	type	"D"	Adr*
#pragma	varargck	type	"P"	Prog*
#pragma	varargck	type	"R"	int
#pragma	varargck	type	"R"	uint
#pragma	varargck	type	"S"	char*

#pragma	varargck	argpos	diag 1

extern	long	HEADR;
extern	short	HEADTYPE;
extern	long	INITDAT;
extern	long	INITRND;
extern	long	INITTEXT;
extern	long	INITTEXTP;
extern	char*	INITENTRY;		/* entry point */

extern	Biobuf	bso;
extern	long	bsssize;
extern	int	cbc;
extern	char*	cbp;
extern	char*	pcstr;
extern	int	cout;
extern	Prog*	curp;
extern	Prog*	curtext;
extern	Prog*	datap;
extern	Prog*	edatap;
extern	long	datsize;
extern	bool	debug[128];
extern	Prog*	firstp;
extern	char	fnuxi8[8];
extern	char	fnuxi4[4];
extern	Sym*	hash[NHASH];
extern	char*	hunk;
extern	char	inuxi1[1];
extern	char	inuxi2[2];
extern	char	inuxi4[4];
extern	char	ycover[Ymax*Ymax];
extern	uchar*	andptr;
extern	uchar	and[30];
extern	char	reg[D_NONE];
extern	Prog*	lastp;
extern	long	lcsize;
extern	int	nerrors;
extern	long	nhunk;
extern	long	nsymbol;
//@Scheck: used by TName, not useless
extern	char*	noname;
extern	char*	outfile;
extern	long	pc;
extern	long	symsize;
extern	Prog*	textp;
extern	long	textsize;
extern	long	thunk;
extern	Prog	zprg;
extern	int	dtype;

extern	Adr*	reloca;
extern	bool	dlm;
extern	int	imports, nimports;
extern	int	exports, nexports;
bool allexport;
extern	char*	EXPTAB;
extern	Prog	undefp;

<<constant UP>>

extern	Optab	optab[];
//@Scheck: defined in ../8c/enam.c
extern	char*	anames[];


Prog*	appendp(Prog*);
void	asmb(void);
void	asmdyn(void);
void	asmins(Prog*);
void	asmlc(void);

void	asmsym(void);
long	atolwhex(char*);

void	cflush(void);
void	ckoff(Sym*, long);
Prog*	copyp(Prog*);

double	cputime(void); //?


void	diag(char*, ...);
void	dodata(void);
void	doinit(void);
void	dostkoff(void);
void	dynreloc(Sym*, ulong, int);

void	errorexit(void);
void	export(void);
int	fileexists(char*);


void	follow(void);
void	gethunk(void);
long	ieeedtof(Ieee*);
void	import(void);

void	listinit(void);
Sym*	lookup(char*, int);
void	lput(long);
void	lputl(long);
void	llput(vlong v);
void	llputl(vlong v);
void	main(int, char*[]);

void	patch(void);
Prog*	prg(void);


long	rnd(long, long);
void	span(void);
void	strnput(char*, int);
void	undef(void);
void	undefsym(Sym*);

void	wput(long);
void	wputl(long);
void	xdefine(char*, int, long);

void mylog(char*, ...);


#pragma	varargck	type	"D"	Adr*
#pragma	varargck	type	"P"	Prog*
#pragma	varargck	type	"R"	int
#pragma	varargck	type	"A"	int
@


\subsection*{[[linkers/8l/globals.c]]}


<<global literal(x86)>>=
char	literal[32];
@




<<global andptr(x86)>>=
uchar*	andptr;
@

<<global and(x86)>>=
uchar	and[30];
@


<<global dtype(x86)>>=
int	dtype;
@



%-------------------------------------------------------------

<<linkers/8l/globals.c>>=
#include	"l.h"

<<global buf>>

<<global HEADR>>
<<global HEADTYPE>>
<<global INITDAT>>
<<global INITRND>>
<<global INITTEXT>>
<<global INITTEXTP>>
<<global INITENTRY>>

<<global bso>>
<<global bsssize>>

<<global cbc>>
<<global cbp>>

<<global pcstr(x86)>>
<<global cout>>
<<global curp>>
<<global curtext>>
<<global datap>>
<<global edatap(x86)>>
<<global datsize>>
<<global debug>>
<<global firstp>>

<<global fnuxi4>>
<<global fnuxi8>>

<<global hash linker>>
<<global hunk>>

<<global inuxi1>>
<<global inuxi2>>
<<global inuxi4>>

<<global ycover(x86)>>
<<global andptr(x86)>>
<<global and(x86)>>
<<global reg(x86)>>
<<global lastp>>
<<global lcsize>>
<<global nerrors>>
<<global nhunk>>
<<global nsymbol linker>>
<<global outfile>>

<<global pc>>

<<global symsize>>
<<global textp>>
<<global textsize>>
<<global thunk>>
<<global zprg>>
<<global dtype(x86)>>

<<global reloca(x86)>>

<<global dlm>>
<<global nimports>>
<<global nexports>>
<<global imports>>
<<global exports>>

int	allexport;

<<global EXPTAB>>
<<global undefp>>

@


\subsection*{[[linkers/8l/optab.c]]}

%-------------------------------------------------------------

<<linkers/8l/optab.c>>=
#include	"l.h"

<<global ynone(x86)>>
<<global ytext(x86)>>
<<global ynop(x86)>>
<<global yxorb(x86)>>
<<global yxorl(x86)>>
<<global yaddl(x86)>>
<<global yincb(x86)>>
<<global yincl(x86)>>
<<global ycmpb(x86)>>
<<global ycmpl(x86)>>
<<global yshb(x86)>>
<<global yshl(x86)>>
<<global ytestb(x86)>>
<<global ytestl(x86)>>
<<global ymovb(x86)>>
<<global ymovl(x86)>>
<<global ym_rl(x86)>>
<<global yrl_m(x86)>>
<<global ymb_rl(x86)>>
<<global yml_rl(x86)>>
<<global yrl_ml(x86)>>
<<global yml_mb(x86)>>
<<global yml_ml(x86)>>
<<global ydivl(x86)>>
<<global ydivb(x86)>>
<<global yimul(x86)>>
<<global ybyte(x86)>>
<<global yin(x86)>>
<<global yint(x86)>>
<<global ypushl(x86)>>
<<global ypopl(x86)>>
<<global yscond(x86)>>
<<global yjcond(x86)>>
<<global yloop(x86)>>
<<global ycall(x86)>>
<<global yjmp(x86)>>

<<global yfmvd(x86)>>
<<global yfmvdp(x86)>>
<<global yfmvf(x86)>>
<<global yfmvx(x86)>>
<<global yfmvp(x86)>>
<<global yfadd(x86)>>
<<global yfaddp(x86)>>
<<global yfxch(x86)>>
<<global ycompp(x86)>>
<<global ystsw(x86)>>
<<global ystcw(x86)>>
<<global ysvrs(x86)>>

<<global optab(x86)>>
@

\subsection*{[[linkers/8l/utils.c]]}

<<linkers/8l/utils.c>>=
#include "l.h"

<<function log>>

<<function errorexit>>

<<function gethunk>>

<<function lookup>>

<<constructor prg>>

<<function copyp>>

@

\subsection*{[[linkers/8l/list.c]]}

%-------------------------------------------------------------

<<linkers/8l/list.c>>=
#include	"l.h"

int	Aconv(Fmt*);
int	Dconv(Fmt*);
int	Pconv(Fmt*);
int	Rconv(Fmt*);
int	Sconv(Fmt*);

<<function listinit(x86)>>

<<global bigP(x86)>>

<<function Pconv(x86)>>

<<function Aconv(x86)>>

<<function Dconv(x86)>>

<<global regstr(x86)>>

<<function Rconv(x86)>>

<<function Sconv(x86)>>

<<function diag>>
@


\subsection*{[[linkers/8l/compat.c]]}


%-------------------------------------------------------------

<<linkers/8l/compat.c>>=
#include	"l.h"

<<function malloc>>

<<function free>>

<<function setmalloctag>>

<<function fileexists>>
@


\subsection*{[[linkers/8l/pass.c]]}

%-------------------------------------------------------------

<<linkers/8l/pass.c>>=
#include	"l.h"

void	xfol(Prog*);
int	relinv(int);
void	mkfwd(void);
Prog*	brloop(Prog*);

<<function dodata(x86)>>

<<function brchain(x86)>>

<<function follow>>

<<function xfol(x86)>>

<<function relinv(x86)>>

<<function doinit(x86)>>

<<function patch(x86)>>

<<constant LOG>>
<<function mkfwd>>

<<function brloop(x86)>>

<<function dostkoff(x86)>>

<<function atolwhex>>

<<function undef>>

<<function import(x86)>>

<<function ckoff>>

<<function newdata(x86)>>

<<function export(x86)>>
@


\subsection*{[[linkers/8l/asm.c]]}

%-------------------------------------------------------------

<<linkers/8l/asm.c>>=
#include	"l.h"

<<constant Dbufslop>>

<<global spsize(x86)>>

void	datblk(long, long);

<<function entryvalue(x86)>>

<<function wputl(x86)>>

<<function wput(x86)>>

<<function lput(x86)>>

<<function lputl(x86)>>

<<function llput>>

<<function llputl>>

<<function strnput(x86)>>

<<function asmb(x86)>>

<<function cflush>>

<<function datblk(x86)>>

<<function rnd>>
@


\subsection*{[[linkers/8l/span.c]]}


<<function oclass(x86)>>=
int
oclass(Adr *a)
{
    long v;

    if(a->type >= D_INDIR || a->index != D_NONE) {
        if(a->index != D_NONE && a->scale == 0) {
            if(a->type == D_ADDR) {
                switch(a->index) {
                case D_EXTERN:
                case D_STATIC:
                    return Yi32;
                case D_LOCAL:
                case D_PARAM:
                    return Yiauto;
                }
                return Yxxx;
            }
            return Ycol;
        }
        return Ym;
    }
    switch(a->type)
    {
    case D_AL:
        return Yal;

    case D_AX:
        return Yax;

    case D_CL:
        return Ycl;

    case D_DL:
    case D_BL:
    case D_AH:
    case D_CH:
    case D_DH:
    case D_BH:
        return Yrb;

    case D_CX:
        return Ycx;

    case D_DX:
    case D_BX:
        return Yrx;

    case D_SP:
    case D_BP:
    case D_SI:
    case D_DI:
        return Yrl;

    case D_F0+0:
        return	Yf0;

    case D_F0+1:
    case D_F0+2:
    case D_F0+3:
    case D_F0+4:
    case D_F0+5:
    case D_F0+6:
    case D_F0+7:
        return	Yrf;

    case D_NONE:
        return Ynone;

    case D_CS:	return	Ycs;
    case D_SS:	return	Yss;
    case D_DS:	return	Yds;
    case D_ES:	return	Yes;
    case D_FS:	return	Yfs;
    case D_GS:	return	Ygs;

    case D_GDTR:	return	Ygdtr;
    case D_IDTR:	return	Yidtr;
    case D_LDTR:	return	Yldtr;
    case D_MSW:	return	Ymsw;
    case D_TASK:	return	Ytask;

    case D_CR+0:	return	Ycr0;
    case D_CR+1:	return	Ycr1;
    case D_CR+2:	return	Ycr2;
    case D_CR+3:	return	Ycr3;
    case D_CR+4:	return	Ycr4;
    case D_CR+5:	return	Ycr5;
    case D_CR+6:	return	Ycr6;
    case D_CR+7:	return	Ycr7;

    case D_DR+0:	return	Ydr0;
    case D_DR+1:	return	Ydr1;
    case D_DR+2:	return	Ydr2;
    case D_DR+3:	return	Ydr3;
    case D_DR+4:	return	Ydr4;
    case D_DR+5:	return	Ydr5;
    case D_DR+6:	return	Ydr6;
    case D_DR+7:	return	Ydr7;

    case D_TR+0:	return	Ytr0;
    case D_TR+1:	return	Ytr1;
    case D_TR+2:	return	Ytr2;
    case D_TR+3:	return	Ytr3;
    case D_TR+4:	return	Ytr4;
    case D_TR+5:	return	Ytr5;
    case D_TR+6:	return	Ytr6;
    case D_TR+7:	return	Ytr7;

    case D_EXTERN:
    case D_STATIC:
    case D_LOCAL:
    case D_PARAM:
        return Ym;

    case D_CONST:
    case D_ADDR:
        if(a->sym == S) {
            v = a->offset;
            if(v == 0)
                return Yi0;
            if(v == 1)
                return Yi1;
            if(v >= -128 && v <= 127)
                return Yi8;
        }
        return Yi32;

    case D_BRANCH:
        return Ybr;
    }
    return Yxxx;
}
@

<<function asmidx(x86)>>=
void
asmidx(Adr *a, int base)
{
    int i;

    switch(a->index) {
    default:
        goto bad;

    case D_NONE:
        i = 4 << 3;
        goto bas;

    case D_AX:
    case D_CX:
    case D_DX:
    case D_BX:
    case D_BP:
    case D_SI:
    case D_DI:
        i = reg[a->index] << 3;
        break;
    }
    switch(a->scale) {
    default:
        goto bad;
    case 1:
        break;
    case 2:
        i |= (1<<6);
        break;
    case 4:
        i |= (2<<6);
        break;
    case 8:
        i |= (3<<6);
        break;
    }
bas:
    switch(base) {
    default:
        goto bad;
    case D_NONE:	/* must be mod=00 */
        i |= 5;
        break;
    case D_AX:
    case D_CX:
    case D_DX:
    case D_BX:
    case D_SP:
    case D_BP:
    case D_SI:
    case D_DI:
        i |= reg[base];
        break;
    }
    *andptr++ = i;
    return;
bad:
    diag("asmidx: bad address %D", a);
    *andptr++ = 0;
    return;
}
@
%>> >> >> >> >>

<<function put4(x86)>>=
static void
put4(long v)
{
    if(dlm && curp != P && reloca != nil){
        dynreloc(reloca->sym, curp->pc + andptr - &and[0], 1);
        reloca = nil;
    }
    andptr[0] = v;
    andptr[1] = v>>8;
    andptr[2] = v>>16;
    andptr[3] = v>>24;
    andptr += 4;
}
@

<<function vaddr(x86)>>=
long
vaddr(Adr *a)
{
    int t;
    long v;
    Sym *s;

    t = a->type;
    v = a->offset;
    if(t == D_ADDR)
        t = a->index;
    switch(t) {
    case D_STATIC:
    case D_EXTERN:
        s = a->sym;
        if(s != nil) {
            if(dlm && curp != P)
                reloca = a;
            switch(s->type) {
            case SUNDEF:
                ckoff(s, v);
            case STEXT:
            case SCONST:
                v += s->value;
                break;
            default:
                v += INITDAT + s->value;
            }
        }
    }
    return v;
}
@

<<function asmand(x86)>>=
void
asmand(Adr *a, int r)
{
    long v;
    int t;
    Adr aa;

    v = a->offset;
    t = a->type;
    if(a->index != D_NONE) {
        if(t >= D_INDIR) {
            t -= D_INDIR;
            if(t == D_NONE) {
                *andptr++ = (0 << 6) | (4 << 0) | (r << 3);
                asmidx(a, t);
                put4(v);
                return;
            }
            if(v == 0 && t != D_BP) {
                *andptr++ = (0 << 6) | (4 << 0) | (r << 3);
                asmidx(a, t);
                return;
            }
            if(v >= -128 && v < 128) {
                *andptr++ = (1 << 6) | (4 << 0) | (r << 3);
                asmidx(a, t);
                *andptr++ = v;
                return;
            }
            *andptr++ = (2 << 6) | (4 << 0) | (r << 3);
            asmidx(a, t);
            put4(v);
            return;
        }
        switch(t) {
        default:
            goto bad;
        case D_STATIC:
        case D_EXTERN:
            aa.type = D_NONE+D_INDIR;
            break;
        case D_LOCAL:
        case D_PARAM:
            aa.type = D_SP+D_INDIR;
            break;
        }
        aa.offset = vaddr(a);
        aa.index = a->index;
        aa.scale = a->scale;
        asmand(&aa, r);
        return;
    }
    if(t >= D_AL && t <= D_F0+7) {
        if(v)
            goto bad;
        *andptr++ = (3 << 6) | (reg[t] << 0) | (r << 3);
        return;
    }
    if(t >= D_INDIR) {
        t -= D_INDIR;
        if(t == D_NONE || D_CS <= t && t <= D_GS) {
            *andptr++ = (0 << 6) | (5 << 0) | (r << 3);
            put4(v);
            return;
        }
        if(t == D_SP) {
            if(v == 0) {
                *andptr++ = (0 << 6) | (4 << 0) | (r << 3);
                asmidx(a, D_SP);
                return;
            }
            if(v >= -128 && v < 128) {
                *andptr++ = (1 << 6) | (4 << 0) | (r << 3);
                asmidx(a, D_SP);
                *andptr++ = v;
                return;
            }
            *andptr++ = (2 << 6) | (4 << 0) | (r << 3);
            asmidx(a, D_SP);
            put4(v);
            return;
        }
        if(t >= D_AX && t <= D_DI) {
            if(v == 0 && t != D_BP) {
                *andptr++ = (0 << 6) | (reg[t] << 0) | (r << 3);
                return;
            }
            if(v >= -128 && v < 128) {
                andptr[0] = (1 << 6) | (reg[t] << 0) | (r << 3);
                andptr[1] = v;
                andptr += 2;
                return;
            }
            *andptr++ = (2 << 6) | (reg[t] << 0) | (r << 3);
            put4(v);
            return;
        }
        goto bad;
    }
    switch(a->type) {
    default:
        goto bad;
    case D_STATIC:
    case D_EXTERN:
        aa.type = D_NONE+D_INDIR;
        break;
    case D_LOCAL:
    case D_PARAM:
        aa.type = D_SP+D_INDIR;
        break;
    }
    aa.index = D_NONE;
    aa.scale = 1;
    aa.offset = vaddr(a);
    asmand(&aa, r);
    return;
bad:
    diag("asmand: bad address %D", a);
    return;
}
@

<<constant E(x86)>>=
#define	E	0xff
@

<<global ymovtab(x86)>>=
uchar	ymovtab[] =
{
/* push */
    APUSHL,	Ycs,	Ynone,	0,	0x0e,E,0,0,
    APUSHL,	Yss,	Ynone,	0,	0x16,E,0,0,
    APUSHL,	Yds,	Ynone,	0,	0x1e,E,0,0,
    APUSHL,	Yes,	Ynone,	0,	0x06,E,0,0,
    APUSHL,	Yfs,	Ynone,	0,	0x0f,0xa0,E,0,
    APUSHL,	Ygs,	Ynone,	0,	0x0f,0xa8,E,0,

    APUSHW,	Ycs,	Ynone,	0,	Pe,0x0e,E,0,
    APUSHW,	Yss,	Ynone,	0,	Pe,0x16,E,0,
    APUSHW,	Yds,	Ynone,	0,	Pe,0x1e,E,0,
    APUSHW,	Yes,	Ynone,	0,	Pe,0x06,E,0,
    APUSHW,	Yfs,	Ynone,	0,	Pe,0x0f,0xa0,E,
    APUSHW,	Ygs,	Ynone,	0,	Pe,0x0f,0xa8,E,

/* pop */
    APOPL,	Ynone,	Yds,	0,	0x1f,E,0,0,
    APOPL,	Ynone,	Yes,	0,	0x07,E,0,0,
    APOPL,	Ynone,	Yss,	0,	0x17,E,0,0,
    APOPL,	Ynone,	Yfs,	0,	0x0f,0xa1,E,0,
    APOPL,	Ynone,	Ygs,	0,	0x0f,0xa9,E,0,

    APOPW,	Ynone,	Yds,	0,	Pe,0x1f,E,0,
    APOPW,	Ynone,	Yes,	0,	Pe,0x07,E,0,
    APOPW,	Ynone,	Yss,	0,	Pe,0x17,E,0,
    APOPW,	Ynone,	Yfs,	0,	Pe,0x0f,0xa1,E,
    APOPW,	Ynone,	Ygs,	0,	Pe,0x0f,0xa9,E,

/* mov seg */
    AMOVW,	Yes,	Yml,	1,	0x8c,0,0,0,
    AMOVW,	Ycs,	Yml,	1,	0x8c,1,0,0,
    AMOVW,	Yss,	Yml,	1,	0x8c,2,0,0,
    AMOVW,	Yds,	Yml,	1,	0x8c,3,0,0,
    AMOVW,	Yfs,	Yml,	1,	0x8c,4,0,0,
    AMOVW,	Ygs,	Yml,	1,	0x8c,5,0,0,

    AMOVW,	Yml,	Yes,	2,	0x8e,0,0,0,
    AMOVW,	Yml,	Ycs,	2,	0x8e,1,0,0,
    AMOVW,	Yml,	Yss,	2,	0x8e,2,0,0,
    AMOVW,	Yml,	Yds,	2,	0x8e,3,0,0,
    AMOVW,	Yml,	Yfs,	2,	0x8e,4,0,0,
    AMOVW,	Yml,	Ygs,	2,	0x8e,5,0,0,

/* mov cr */
    AMOVL,	Ycr0,	Yml,	3,	0x0f,0x20,0,0,
    AMOVL,	Ycr2,	Yml,	3,	0x0f,0x20,2,0,
    AMOVL,	Ycr3,	Yml,	3,	0x0f,0x20,3,0,
    AMOVL,	Ycr4,	Yml,	3,	0x0f,0x20,4,0,

    AMOVL,	Yml,	Ycr0,	4,	0x0f,0x22,0,0,
    AMOVL,	Yml,	Ycr2,	4,	0x0f,0x22,2,0,
    AMOVL,	Yml,	Ycr3,	4,	0x0f,0x22,3,0,
    AMOVL,	Yml,	Ycr4,	4,	0x0f,0x22,4,0,

/* mov dr */
    AMOVL,	Ydr0,	Yml,	3,	0x0f,0x21,0,0,
    AMOVL,	Ydr6,	Yml,	3,	0x0f,0x21,6,0,
    AMOVL,	Ydr7,	Yml,	3,	0x0f,0x21,7,0,

    AMOVL,	Yml,	Ydr0,	4,	0x0f,0x23,0,0,
    AMOVL,	Yml,	Ydr6,	4,	0x0f,0x23,6,0,
    AMOVL,	Yml,	Ydr7,	4,	0x0f,0x23,7,0,

/* mov tr */
    AMOVL,	Ytr6,	Yml,	3,	0x0f,0x24,6,0,
    AMOVL,	Ytr7,	Yml,	3,	0x0f,0x24,7,0,

    AMOVL,	Yml,	Ytr6,	4,	0x0f,0x26,6,E,
    AMOVL,	Yml,	Ytr7,	4,	0x0f,0x26,7,E,

/* lgdt, sgdt, lidt, sidt */
    AMOVL,	Ym,	Ygdtr,	4,	0x0f,0x01,2,0,
    AMOVL,	Ygdtr,	Ym,	3,	0x0f,0x01,0,0,
    AMOVL,	Ym,	Yidtr,	4,	0x0f,0x01,3,0,
    AMOVL,	Yidtr,	Ym,	3,	0x0f,0x01,1,0,

/* lldt, sldt */
    AMOVW,	Yml,	Yldtr,	4,	0x0f,0x00,2,0,
    AMOVW,	Yldtr,	Yml,	3,	0x0f,0x00,0,0,

/* lmsw, smsw */
    AMOVW,	Yml,	Ymsw,	4,	0x0f,0x01,6,0,
    AMOVW,	Ymsw,	Yml,	3,	0x0f,0x01,4,0,

/* ltr, str */
    AMOVW,	Yml,	Ytask,	4,	0x0f,0x00,3,0,
    AMOVW,	Ytask,	Yml,	3,	0x0f,0x00,1,0,

/* load full pointer */
    AMOVL,	Yml,	Ycol,	5,	0,0,0,0,
    AMOVW,	Yml,	Ycol,	5,	Pe,0,0,0,

/* double shift */
    ASHLL,	Ycol,	Yml,	6,	0xa4,0xa5,0,0,
    ASHRL,	Ycol,	Yml,	6,	0xac,0xad,0,0,

/* extra imul */
    AIMULW,	Yml,	Yrl,	7,	Pq,0xaf,0,0,
    AIMULL,	Yml,	Yrl,	7,	Pm,0xaf,0,0,
    0
};
@

<<function isax(x86)>>=
int
isax(Adr *a)
{

    switch(a->type) {
    case D_AX:
    case D_AL:
    case D_AH:
    case D_INDIR+D_AX:
        return 1;
    }
    if(a->index == D_AX)
        return 1;
    return 0;
}
@

<<function subreg(x86)>>=
void
subreg(Prog *p, int from, int to)
{

    if(debug['Q'])
        print("\n%P	s/%R/%R/\n", p, from, to);

    if(p->from.type == from)
        p->from.type = to;
    if(p->to.type == from)
        p->to.type = to;

    if(p->from.index == from)
        p->from.index = to;
    if(p->to.index == from)
        p->to.index = to;

    from += D_INDIR;
    if(p->from.type == from)
        p->from.type = to+D_INDIR;
    if(p->to.type == from)
        p->to.type = to+D_INDIR;

    if(debug['Q'])
        print("%P\n", p);
}
@

<<function doasm(x86)>>=
void
doasm(Prog *p)
{
    Optab *o;
    Prog *q, pp;
    uchar *t;
    int z, op, ft, tt;
    long v, pre;

    pre = prefixof(&p->from);
    if(pre)
        *andptr++ = pre;
    pre = prefixof(&p->to);
    if(pre)
        *andptr++ = pre;

    o = &optab[p->as];
    ft = oclass(&p->from) * Ymax;
    tt = oclass(&p->to) * Ymax;
    t = o->ytab;
    if(t == 0) {
        diag("asmins: noproto %P", p);
        return;
    }
    for(z=0; *t; z+=t[3],t+=4)
        if(ycover[ft+t[0]])
        if(ycover[tt+t[1]])
            goto found;
    goto domov;

found:
    switch(o->prefix) {
    case Pq:	/* 16 bit escape and opcode escape */
        *andptr++ = Pe;
        *andptr++ = Pm;
        break;

    case Pm:	/* opcode escape */
        *andptr++ = Pm;
        break;

    case Pe:	/* 16 bit escape */
        *andptr++ = Pe;
        break;

    case Pb:	/* botch */
        break;
    }
    v = vaddr(&p->from);
    op = o->op[z];
    switch(t[2]) {
    default:
        diag("asmins: unknown z %d %P", t[2], p);
        return;

    case Zpseudo:
        break;

    case Zlit:
        for(; op = o->op[z]; z++)
            *andptr++ = op;
        break;

    case Zm_r:
        *andptr++ = op;
        asmand(&p->from, reg[p->to.type]);
        break;

    case Zaut_r:
        *andptr++ = 0x8d;	/* leal */
        if(p->from.type != D_ADDR)
            diag("asmins: Zaut sb type ADDR");
        p->from.type = p->from.index;
        p->from.index = D_NONE;
        asmand(&p->from, reg[p->to.type]);
        p->from.index = p->from.type;
        p->from.type = D_ADDR;
        break;

    case Zm_o:
        *andptr++ = op;
        asmand(&p->from, o->op[z+1]);
        break;

    case Zr_m:
        *andptr++ = op;
        asmand(&p->to, reg[p->from.type]);
        break;

    case Zo_m:
        *andptr++ = op;
        asmand(&p->to, o->op[z+1]);
        break;

    case Zm_ibo:
        v = vaddr(&p->to);
        *andptr++ = op;
        asmand(&p->from, o->op[z+1]);
        *andptr++ = v;
        break;

    case Zibo_m:
        *andptr++ = op;
        asmand(&p->to, o->op[z+1]);
        *andptr++ = v;
        break;

    case Z_ib:
        v = vaddr(&p->to);
    case Zib_:
        *andptr++ = op;
        *andptr++ = v;
        break;

    case Zib_rp:
        *andptr++ = op + reg[p->to.type];
        *andptr++ = v;
        break;

    case Zil_rp:
        *andptr++ = op + reg[p->to.type];
        if(o->prefix == Pe) {
            *andptr++ = v;
            *andptr++ = v>>8;
        }
        else
            put4(v);
        break;

    case Zib_rr:
        *andptr++ = op;
        asmand(&p->to, reg[p->to.type]);
        *andptr++ = v;
        break;

    case Z_il:
        v = vaddr(&p->to);
    case Zil_:
        *andptr++ = op;
        if(o->prefix == Pe) {
            *andptr++ = v;
            *andptr++ = v>>8;
        }
        else
            put4(v);
        break;

    case Zm_ilo:
        v = vaddr(&p->to);
        *andptr++ = op;
        asmand(&p->from, o->op[z+1]);
        if(o->prefix == Pe) {
            *andptr++ = v;
            *andptr++ = v>>8;
        }
        else
            put4(v);
        break;

    case Zilo_m:
        *andptr++ = op;
        asmand(&p->to, o->op[z+1]);
        if(o->prefix == Pe) {
            *andptr++ = v;
            *andptr++ = v>>8;
        }
        else
            put4(v);
        break;

    case Zil_rr:
        *andptr++ = op;
        asmand(&p->to, reg[p->to.type]);
        if(o->prefix == Pe) {
            *andptr++ = v;
            *andptr++ = v>>8;
        }
        else
            put4(v);
        break;

    case Z_rp:
        *andptr++ = op + reg[p->to.type];
        break;

    case Zrp_:
        *andptr++ = op + reg[p->from.type];
        break;

    case Zclr:
        *andptr++ = op;
        asmand(&p->to, reg[p->to.type]);
        break;

    case Zbr:
        q = p->pcond;
        if(q) {
            v = q->pc - p->pc - 2;
            if(v >= -128 && v <= 127) {
                *andptr++ = op;
                *andptr++ = v;
            } else {
                v -= 6-2;
                *andptr++ = 0x0f;
                *andptr++ = o->op[z+1];
                *andptr++ = v;
                *andptr++ = v>>8;
                *andptr++ = v>>16;
                *andptr++ = v>>24;
            }
        }
        break;

    case Zcall:
        q = p->pcond;
        if(q) {
            v = q->pc - p->pc - 5;
            if(dlm && curp != P && p->to.sym->type == SUNDEF){
                /* v = 0 - p->pc - 5; */
                v = 0;
                ckoff(p->to.sym, v);
                v += p->to.sym->value;
                dynreloc(p->to.sym, p->pc+1, 0);
            }
            *andptr++ = op;
            *andptr++ = v;
            *andptr++ = v>>8;
            *andptr++ = v>>16;
            *andptr++ = v>>24;
        }
        break;

    case Zjmp:
        q = p->pcond;
        if(q) {
            v = q->pc - p->pc - 2;
            if(v >= -128 && v <= 127) {
                *andptr++ = op;
                *andptr++ = v;
            } else {
                v -= 5-2;
                *andptr++ = o->op[z+1];
                *andptr++ = v;
                *andptr++ = v>>8;
                *andptr++ = v>>16;
                *andptr++ = v>>24;
            }
        }
        break;

    case Zloop:
        q = p->pcond;
        if(q) {
            v = q->pc - p->pc - 2;
            if(v < -128 || v > 127)
                diag("loop too far: %P", p);
            *andptr++ = op;
            *andptr++ = v;
        }
        break;

    case Zbyte:
        *andptr++ = v;
        if(op > 1) {
            *andptr++ = v>>8;
            if(op > 2) {
                *andptr++ = v>>16;
                *andptr++ = v>>24;
            }
        }
        break;

    case Zmov:
        goto domov;
    }
    return;

domov:
    for(t=ymovtab; *t; t+=8)
        if(p->as == t[0])
        if(ycover[ft+t[1]])
        if(ycover[tt+t[2]])
            goto mfound;
bad:
    /*
     * here, the assembly has failed.
     * if its a byte instruction that has
     * unaddressable registers, try to
     * exchange registers and reissue the
     * instruction with the operands renamed.
     */
    pp = *p;
    z = p->from.type;
    if(z >= D_BP && z <= D_DI) {
        if(isax(&p->to)) {
            *andptr++ = 0x87;			/* xchg lhs,bx */
            asmand(&p->from, reg[D_BX]);
            subreg(&pp, z, D_BX);
            doasm(&pp);
            *andptr++ = 0x87;			/* xchg lhs,bx */
            asmand(&p->from, reg[D_BX]);
        } else {
            *andptr++ = 0x90 + reg[z];		/* xchg lsh,ax */
            subreg(&pp, z, D_AX);
            doasm(&pp);
            *andptr++ = 0x90 + reg[z];		/* xchg lsh,ax */
        }
        return;
    }
    z = p->to.type;
    if(z >= D_BP && z <= D_DI) {
        if(isax(&p->from)) {
            *andptr++ = 0x87;			/* xchg rhs,bx */
            asmand(&p->to, reg[D_BX]);
            subreg(&pp, z, D_BX);
            doasm(&pp);
            *andptr++ = 0x87;			/* xchg rhs,bx */
            asmand(&p->to, reg[D_BX]);
        } else {
            *andptr++ = 0x90 + reg[z];		/* xchg rsh,ax */
            subreg(&pp, z, D_AX);
            doasm(&pp);
            *andptr++ = 0x90 + reg[z];		/* xchg rsh,ax */
        }
        return;
    }
    diag("doasm: notfound t2=%ux from=%ux to=%ux %P", t[2], p->from.type, p->to.type, p);
    return;

mfound:
    switch(t[3]) {
    default:
        diag("asmins: unknown mov %d %P", t[3], p);
        break;

    case 0:	/* lit */
        for(z=4; t[z]!=E; z++)
            *andptr++ = t[z];
        break;

    case 1:	/* r,m */
        *andptr++ = t[4];
        asmand(&p->to, t[5]);
        break;

    case 2:	/* m,r */
        *andptr++ = t[4];
        asmand(&p->from, t[5]);
        break;

    case 3:	/* r,m - 2op */
        *andptr++ = t[4];
        *andptr++ = t[5];
        asmand(&p->to, t[6]);
        break;

    case 4:	/* m,r - 2op */
        *andptr++ = t[4];
        *andptr++ = t[5];
        asmand(&p->from, t[6]);
        break;

    case 5:	/* load full pointer, trash heap */
        if(t[4])
            *andptr++ = t[4];
        switch(p->to.index) {
        default:
            goto bad;
        case D_DS:
            *andptr++ = 0xc5;
            break;
        case D_SS:
            *andptr++ = 0x0f;
            *andptr++ = 0xb2;
            break;
        case D_ES:
            *andptr++ = 0xc4;
            break;
        case D_FS:
            *andptr++ = 0x0f;
            *andptr++ = 0xb4;
            break;
        case D_GS:
            *andptr++ = 0x0f;
            *andptr++ = 0xb5;
            break;
        }
        asmand(&p->from, reg[p->to.type]);
        break;

    case 6:	/* double shift */
        z = p->from.type;
        switch(z) {
        default:
            goto bad;
        case D_CONST:
            *andptr++ = 0x0f;
            *andptr++ = t[4];
            asmand(&p->to, reg[p->from.index]);
            *andptr++ = p->from.offset;
            break;
        case D_CL:
        case D_CX:
            *andptr++ = 0x0f;
            *andptr++ = t[5];
            asmand(&p->to, reg[p->from.index]);
            break;
        }
        break;

    case 7: /* imul rm,r */
        *andptr++ = t[4];
        *andptr++ = t[5];
        asmand(&p->from, reg[p->to.type]);
        break;
    }
}
@

<<function prefixof(x86)>>=
int
prefixof(Adr *a)
{
    switch(a->type) {
    case D_INDIR+D_CS:
        return 0x2e;
    case D_INDIR+D_DS:
        return 0x3e;
    case D_INDIR+D_ES:
        return 0x26;
    case D_INDIR+D_FS:
        return 0x64;
    case D_INDIR+D_GS:
        return 0x65;
    }
    return 0;
}
@



<<function asmins(x86)>>=
void
asmins(Prog *p)
{

    andptr = and;
    doasm(p);
}
@

<<enum _anon_ (linkers/8l/span.c)>>=
enum{
    ABSD = 0,
    ABSU = 1,
    RELD = 2,
    RELU = 3,
};
@





%-------------------------------------------------------------

<<linkers/8l/span.c>>=
#include	"l.h"

<<function span(x86)>>

<<function xdefine(x86)>>

<<function putsymb>>

<<function asmsym(x86)>>

<<function asmlc>>

<<function prefixof(x86)>>

<<function oclass(x86)>>

<<function asmidx(x86)>>

<<function put4(x86)>>

<<function vaddr(x86)>>

<<function asmand(x86)>>

<<constant E(x86)>>
<<global ymovtab(x86)>>

<<function isax(x86)>>

<<function subreg(x86)>>

<<function doasm(x86)>>

<<function asmins(x86)>>

<<enum _anon_ (linkers/8l/span.c)>>

<<global modemap>>

typedef struct Reloc Reloc;

<<struct Reloc>>

<<global rels>>

<<function grow>>

<<function dynreloc(x86)>>

<<function sput>>

<<function asmdyn>>
@


\subsection*{[[linkers/8l/elf.c]]}

<<enum _anon_ (linkers/8l/elf.c)>>=
enum {
    /* offsets into string table */
    Stitext		= 1,
    Stidata		= 7,
    Stistrtab	= 13,
};
@

<<function elfident>>=
void
elfident(int bo, int class)
{
    strnput("\177ELF", 4);		/* e_ident */
    cput(class);
    cput(bo);			/* byte order */
    cput(1);			/* version = CURRENT */
    if(debug['k']){			/* boot/embedded/standalone */
        cput(255);
        cput(0);
    }
    else{
        cput(0);		/* osabi = SYSV */
        cput(0);		/* abiversion = 3 */
    }
    strnput("", 7);
}
@

<<function elfstrtab>>=
void
elfstrtab(void)
{
    /* string table */
    cput(0);
    strnput(".text", 5);		/* +1 */
    cput(0);
    strnput(".data", 5);		/* +7 */
    cput(0);
    strnput(".strtab", 7);		/* +13 */
    cput(0);
    cput(0);
}
@

<<function elf32phdr>>=
void
elf32phdr(void (*putl)(long), ulong type, ulong off, ulong vaddr, ulong paddr,
    ulong filesz, ulong memsz, ulong prots, ulong align)
{
    putl(type);
    putl(off);
    putl(vaddr);
    putl(paddr);
    putl(filesz);
    putl(memsz);
    putl(prots);
    putl(align);
}
@

<<function elf32shdr>>=
void
elf32shdr(void (*putl)(long), ulong name, ulong type, ulong flags, ulong vaddr,
    ulong off, ulong sectsz, ulong link, ulong addnl, ulong align,
    ulong entsz)
{
    putl(name);
    putl(type);
    putl(flags);
    putl(vaddr);
    putl(off);
    putl(sectsz);
    putl(link);
    putl(addnl);
    putl(align);
    putl(entsz);
}
@

<<function elf32sectab>>=
static void
elf32sectab(void (*putl)(long))
{
    seek(cout, HEADR+textsize+datsize+symsize, 0);
    elf32shdr(putl, Stitext, Progbits, Salloc|Sexec, INITTEXT,
        HEADR, textsize, 0, 0, 0x10000, 0);
    elf32shdr(putl, Stidata, Progbits, Salloc|SwriteElf, INITDAT,
        HEADR+textsize, datsize, 0, 0, 0x10000, 0);
    elf32shdr(putl, Stistrtab, Strtab, 1 << 5, 0,
        HEADR+textsize+datsize+symsize+3*Shdr32sz, 14, 0, 0, 1, 0);
    elfstrtab();
}
@

<<function elf32>>=
/* if addpsects > 0, putpsects must emit exactly that many psects. */
void
elf32(int mach, int bo, int addpsects, void (*putpsects)(Putl))
{
    ulong phydata;
    void (*putw)(long), (*putl)(long);

    if(bo == ELFDATA2MSB){
        putw = wput;
        putl = lput;
    }else if(bo == ELFDATA2LSB){
        putw = wputl;
        putl = lputl;
    }else{
        print("elf32 byte order is mixed-endian\n");
        errorexit();
        return;
    }

    elfident(bo, ELFCLASS32);
    putw(EXEC);
    putw(mach);
    putl(1L);			/* version = CURRENT */
    putl(entryvalue());		/* entry vaddr */
    putl(Ehdr32sz);			/* offset to first phdr */
    if(debug['S'])
        putl(HEADR+textsize+datsize+symsize); /* offset to first shdr */
    else
        putl(0);
    putl(0L);			/* flags */
    putw(Ehdr32sz);
    putw(Phdr32sz);
    putw(3 + addpsects);		/* # of Phdrs */
    putw(Shdr32sz);
    if(debug['S']){
        putw(3);		/* # of Shdrs */
        putw(2);		/* Shdr table index */
    }else{
        putw(0);
        putw(0);
    }

    /*
     * could include ELF headers in text -- 8l doesn't,
     * but in theory it aids demand loading.
     */
    elf32phdr(putl, PT_LOAD, HEADR, INITTEXT, INITTEXTP,
        textsize, textsize, R|X, INITRND);	/* text */
    /*
     * we need INITDATP, but it has to be computed.
     * assume distance between INITTEXT & INITTEXTP is also
     * correct for INITDAT and INITDATP.
     */
    phydata = INITDAT - (INITTEXT - INITTEXTP);
    elf32phdr(putl, PT_LOAD, HEADR+textsize, INITDAT, phydata,
        datsize, datsize+bsssize, R|W|X, INITRND); /* data */
    elf32phdr(putl, NOPTYPE, HEADR+textsize+datsize, 0, 0,
        symsize, lcsize, R, 4);			/* symbol table */
    if (addpsects > 0)
        putpsects(putl);
    cflush();

    if(debug['S'])
        elf32sectab(putl);
}
@

%<<function elf64phdr>>=
%/*
% * elf64
% */
%void
%elf64phdr(void (*putl)(long), void (*putll)(vlong), ulong type, uvlong off,
%    uvlong vaddr, uvlong paddr, uvlong filesz, uvlong memsz, ulong prots,
%    uvlong align)
%{
%    putl(type);		
%    putl(prots);		
%    putll(off);		
%    putll(vaddr);	
%    putll(paddr);	
%    putll(filesz);	
%    putll(memsz);	
%    putll(align);		
%}
%@
%
%<<function elf64shdr>>=
%void
%elf64shdr(void (*putl)(long), void (*putll)(vlong), ulong name, ulong type,
%    uvlong flags, uvlong vaddr, uvlong off, uvlong sectsz, ulong link,
%    ulong addnl, uvlong align, uvlong entsz)
%{
%    putl(name);
%    putl(type);
%    putll(flags);
%    putll(vaddr);
%    putll(off);
%    putll(sectsz);
%    putl(link);
%    putl(addnl);
%    putll(align);
%    putll(entsz);
%}
%@
%
%<<function elf64sectab>>=
%static void
%elf64sectab(void (*putl)(long), void (*putll)(vlong))
%{
%    seek(cout, HEADR+textsize+datsize+symsize, 0);
%    elf64shdr(putl, putll, Stitext, Progbits, Salloc|Sexec, INITTEXT,
%        HEADR, textsize, 0, 0, 0x10000, 0);
%    elf64shdr(putl, putll, Stidata, Progbits, Salloc|SwriteElf, INITDAT,
%        HEADR+textsize, datsize, 0, 0, 0x10000, 0);
%    elf64shdr(putl, putll, Stistrtab, Strtab, 1 << 5, 0,
%        HEADR+textsize+datsize+symsize+3*Shdr64sz, 14, 0, 0, 1, 0);
%    elfstrtab();
%}
%@
%
%% >>
%
%<<function elf64>>=
%/* if addpsects > 0, putpsects must emit exactly that many psects. */
%//@Scheck: not dead, used by vl/
%void elf64(int mach, int bo, int addpsects, void (*putpsects)(Putl))
%{
%    uvlong phydata;
%    void (*putw)(long), (*putl)(long);
%    void (*putll)(vlong);
%
%    if(bo == ELFDATA2MSB){
%        putw = wput;
%        putl = lput;
%        putll = llput;
%    }else if(bo == ELFDATA2LSB){
%        putw = wputl;
%        putl = lputl;
%        putll = llputl;
%    }else{
%        print("elf64 byte order is mixed-endian\n");
%        errorexit();
%        return;
%    }
%
%    elfident(bo, ELFCLASS64);
%    putw(EXEC);
%    putw(mach);
%    putl(1L);			/* version = CURRENT */
%    putll(entryvalue());		/* entry vaddr */
%    putll(Ehdr64sz);		/* offset to first phdr */
%    if(debug['S'])
%        putll(HEADR+textsize+datsize+symsize); /* offset to 1st shdr */
%    else
%        putll(0);
%    putl(0L);			/* flags */
%    putw(Ehdr64sz);
%    putw(Phdr64sz);
%    putw(3 + addpsects);		/* # of Phdrs */
%    putw(Shdr64sz);
%    if(debug['S']){
%        putw(3);		/* # of Shdrs */
%        putw(2);		/* Shdr table index */
%    }else{
%        putw(0);
%        putw(0);
%    }
%
%    elf64phdr(putl, putll, PT_LOAD, HEADR, INITTEXT, INITTEXTP,
%        textsize, textsize, R|X, INITRND);	/* text */
%    /*
%     * see 32-bit ELF case for physical data address computation.
%     */
%    phydata = INITDAT - (INITTEXT - INITTEXTP);
%    elf64phdr(putl, putll, PT_LOAD, HEADR+textsize, INITDAT, phydata,
%        datsize, datsize+bsssize, R|W, INITRND); /* data */
%    elf64phdr(putl, putll, NOPTYPE, HEADR+textsize+datsize, 0, 0,
%        symsize, lcsize, R, 4);			/* symbol table */
%    if (addpsects > 0)
%        putpsects(putl);
%    cflush();
%
%    if(debug['S'])
%        elf64sectab(putl, putll);
%}
%@


%-------------------------------------------------------------

<<linkers/8l/elf.c>>=
/*
 * emit 32- or 64-bit elf headers for any architecture.
 * this is a component of ?l.
 */
#include "l.h"

long	entryvalue(void);

<<enum _anon_ (linkers/8l/elf.c)>>

<<function elfident>>

<<function elfstrtab>>

<<function elf32phdr>>

<<function elf32shdr>>

<<function elf32sectab>>

<<function elf32>>
@


\subsection*{[[linkers/8l/obj.c]]}




%-------------------------------------------------------------

<<linkers/8l/obj.c>>=
#include	"l.h"
#include	<ar.h>

#ifndef	DEFAULT
<<constant DEFAULT>>
#endif

<<global curauto>>

<<global curhist>>
<<global etextp>>

<<global histfrog>>
<<global histfrogp>>
<<global histgen>>

<<global library>>
<<global libraryobj>>
<<global libraryp>>

<<global xrefresolv>>

<<global version>>
<<global literal(x86)>>
<<global doexp>>

void	addlibpath(char*);
char*	findlib(char*);
void	loadlib(void);
void	objfile(char*);

int	zaddr(uchar*, Adr*, Sym*[]);
long	vaddr(Adr*);

void	addhist(long, int);
void	histtoauto(void);
void	ldobj(int, long, char*);

void	doprof1(void);
void	doprof2(void);
void	nuxiinit(void);

int	find1(long, int);
//int	find2(long, int);

double	ieeedtod(Ieee*);

void	zerosig(char*);
void	readundefs(char*, int);
Prog*	brchain(Prog*);



<<global noname linker>>
<<global symname linker>>
<<global thechar>>
<<global thestring>>

<<global libdir>>
<<global nlibdir>>
<<global maxlibdir>>

<<function usage, linker>>

<<function isobjfile>>

<<function main (linkers/8l/obj.c)>>

<<function addlibpath>>

<<function findlib>>

<<function loadlib>>

<<function objfile>>

<<function zaddr(x86)>>

<<function addlib>>

<<function addhist>>

<<function histtoauto>>

<<function collapsefrog>>

<<function nopout>>

<<function readsome>>

<<function ldobj(x86)>>

<<function appendp(x86)>>

<<function doprof1(x86)>>

<<function doprof2(x86)>>

<<function nuxiinit(x86)>>

<<function find1>>

<<function ieeedtof>>

<<function ieeedtod>>

<<function undefsym>>

<<function zerosig>>

<<function readundefs>>
@


