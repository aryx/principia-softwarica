\section{[[include/]]}

\subsection*{[[include/exec/a.out.h]]}

<<function _MAGIC>>=
#define	_MAGIC(f, b)	((f)|((((4*(b))+0)*(b))+7))
@

<<constant I_MAGIC>>=
#define	I_MAGIC		_MAGIC(0, 11)		/* intel 386 */
@

<<constant E_MAGIC>>=
#define	E_MAGIC		_MAGIC(0, 20)		/* arm */
@

<<constant HDR_MAGIC>>=
#define HDR_MAGIC	0x00008000		/* header expansion */
@
% for 64 bit architecture


%#define	A_MAGIC		_MAGIC(0, 8)		/* 68020 (retired) */
%#define	J_MAGIC		_MAGIC(0, 12)		/* intel 960 (retired) */
%#define	K_MAGIC		_MAGIC(0, 13)		/* sparc */
%#define	V_MAGIC		_MAGIC(0, 16)		/* mips 3000 BE */
%#define	X_MAGIC		_MAGIC(0, 17)		/* att dsp 3210 (retired) */
%#define	M_MAGIC		_MAGIC(0, 18)		/* mips 4000 BE */
%#define	D_MAGIC		_MAGIC(0, 19)		/* amd 29000 (retired) */
%#define	Q_MAGIC		_MAGIC(0, 21)		/* powerpc */
%#define	N_MAGIC		_MAGIC(0, 22)		/* mips 4000 LE */
%#define	L_MAGIC		_MAGIC(0, 23)		/* dec alpha (retired) */
%#define	P_MAGIC		_MAGIC(0, 24)		/* mips 3000 LE */
%#define	U_MAGIC		_MAGIC(0, 25)		/* sparc64 (retired) */

%#define	S_MAGIC		_MAGIC(HDR_MAGIC, 26)	/* amd64 */
%#define	T_MAGIC		_MAGIC(HDR_MAGIC, 27)	/* powerpc64 */
%#define	R_MAGIC		_MAGIC(HDR_MAGIC, 28)	/* arm64 */



<<constant MIN_MAGIC>>=
#define	MIN_MAGIC	11
@

<<constant MAX_MAGIC>>=
#define	MAX_MAGIC	20			/* <= 90 */
@

<<constant DYN_MAGIC>>=
#define	DYN_MAGIC	0x80000000		/* dlm */
@

<<struct Sym a.out.h>>=
struct	Sym
{
    vlong	value;
    uint	sig;
    char	type;
    char	*name;
};
@


%-------------------------------------------------------------

<<include/a.out.h>>=
typedef	struct	Exec	Exec;
typedef	struct	Sym	Sym;

<<struct Exec>>

<<constant HDR_MAGIC>>

<<function _MAGIC>>

<<constant I_MAGIC>>
<<constant E_MAGIC>>

<<constant MIN_MAGIC>>
<<constant MAX_MAGIC>>

<<constant DYN_MAGIC>>

<<struct Sym a.out.h>>
@

\subsection*{[[include/exec/elf.h]]}

<<enum _anon_ (elf.h)>>=
/* was in /sys/src/libmach/elf.h */
enum {
    /* Ehdr codes */
    MAG0 = 0,		/* ident[] indexes */
    MAG1 = 1,
    MAG2 = 2,
    MAG3 = 3,
    CLASS = 4,
    DATA = 5,
    VERSION = 6,

    ELFCLASSNONE = 0,	/* ident[CLASS] */
    ELFCLASS32 = 1,
    ELFCLASS64 = 2,
    ELFCLASSNUM = 3,

    ELFDATANONE = 0,	/* ident[DATA] */
    ELFDATA2LSB = 1,
    ELFDATA2MSB = 2,
    ELFDATANUM = 3,

    NOETYPE = 0,		/* type */
    REL = 1,
    EXEC = 2,
    DYN = 3,
    CORE = 4,

    NONE = 0,		/* machine */
    M32 = 1,		/* AT&T WE 32100 */
    SPARC = 2,		/* Sun SPARC */
    I386 = 3,		/* Intel 80386 */
    M68K = 4,		/* Motorola 68000 */
    M88K = 5,		/* Motorola 88000 */
    I486 = 6,		/* Intel 80486 */
    I860 = 7,		/* Intel i860 */
    MIPS = 8,		/* Mips R2000 */
    S370 = 9,		/* Amdhal	*/
    MIPSR4K = 10,	/* Mips R4000 */
    SPARC64 = 18,	/* Sun SPARC v9 */
    POWER = 20,		/* PowerPC */
    POWER64 = 21,	/* PowerPC64 */
    ARM = 40,		/* ARM */
    AMD64 = 62,		/* Amd64 */
    ARM64 = 183,	/* ARM64 */

    NO_VERSION = 0,		/* version, ident[VERSION] */
    CURRENT = 1,

    /* Phdr Codes */
    NOPTYPE = 0,		/* type */
    PT_LOAD = 1, /* also LOAD */
    DYNAMIC = 2,
    INTERP = 3,
    NOTE = 4,
    SHLIB = 5,
    PHDR = 6,

    R = 0x4,		/* flags */
    W = 0x2,
    X = 0x1,

    /* Shdr Codes */
    Progbits = 1,	/* section types */
    Strtab = 3,
    Nobits = 8,

    SwriteElf = 1,	/* section attributes (flags) */
    Salloc = 2,
    Sexec = 4,
};
@

<<struct Ehdr>>=
/*
 *	Definitions needed for accessing ELF headers
 */
struct Ehdr {
    uchar	ident[16];	/* ident bytes */
    ushort	type;		/* file type */
    ushort	machine;	/* target machine */
    int	version;	/* file version */
    ulong	elfentry;	/* start address */
    ulong	phoff;		/* phdr file offset */
    ulong	shoff;		/* shdr file offset */
    int	flags;		/* file flags */
    ushort	ehsize;		/* sizeof ehdr */
    ushort	phentsize;	/* sizeof phdr */
    ushort	phnum;		/* number phdrs */
    ushort	shentsize;	/* sizeof shdr */
    ushort	shnum;		/* number shdrs */
    ushort	shstrndx;	/* shdr string index */
};
@


<<struct Phdr>>=
struct Phdr {
    int	type;		/* entry type */
    ulong	offset;		/* file offset */
    ulong	vaddr;		/* virtual address */
    ulong	paddr;		/* physical address */
    int	filesz;		/* file size */
    ulong	memsz;		/* memory size */
    int	flags;		/* entry flags */
    int	align;		/* memory/file alignment */
};
@

<<struct Shdr>>=
struct Shdr {
    ulong	name;		/* section name */
    ulong	type;		/* SHT_... */
    ulong	flags;		/* SHF_... */
    ulong	addr;		/* virtual address */
    ulong	offset;		/* file offset */
    ulong	size;		/* section size */
    ulong	link;		/* misc info */
    ulong	info;		/* misc info */
    ulong	addralign;	/* memory alignment */
    ulong	entsize;	/* entry size if table */
};
@

<<constant ELF_MAG>>=
#define	ELF_MAG		((0x7f<<24) | ('E'<<16) | ('L'<<8) | 'F')
@


%struct E64hdr {
%    u8int	ident[16];	/* ident bytes */
%    u16int	type;		/* file type */
%    u16int	machine;	/* target machine */
%    u32int	version;	/* file version */
%    u64int	elfentry;	/* start address */
%    u64int	phoff;		/* phdr file offset */
%    u64int	shoff;		/* shdr file offset */
%    u32int	flags;		/* file flags */
%    u16int	ehsize;		/* sizeof ehdr */
%    u16int	phentsize;	/* sizeof phdr */
%    u16int	phnum;		/* number phdrs */
%    u16int	shentsize;	/* sizeof shdr */
%    u16int	shnum;		/* number shdrs */
%    u16int	shstrndx;	/* shdr string index */
%};



%struct P64hdr {
%    u32int	type;		/* entry type */
%    u32int	flags;		/* entry flags */
%    u64int	offset;		/* file offset */
%    u64int	vaddr;		/* virtual address */
%    u64int	paddr;		/* physical address */
%    u64int	filesz;		/* file size */
%    u64int	memsz;		/* memory size */
%    u64int	align;		/* memory/file alignment */
%}; 



%struct S64hdr {
%    u32int	name;		/* section name */
%    u32int	type;		/* SHT_... */
%    u64int	flags;		/* SHF_... */
%    u64int	addr;		/* virtual address */
%    u64int	offset;		/* file offset */
%    u64int	size;		/* section size */
%    u32int	link;		/* misc info */
%    u32int	info;		/* misc info */
%    u64int	addralign;	/* memory alignment */
%    u64int	entsize;	/* entry size if table */
%};



%-------------------------------------------------------------

<<include/exec/elf.h>>=

<<enum _anon_ (elf.h)>>

typedef struct Ehdr Ehdr;
typedef struct Phdr Phdr;
typedef struct Shdr Shdr;

<<struct Ehdr>>

<<struct Phdr>>

<<struct Shdr>>

<<constant ELF_MAG>>
@



\subsection*{[[include/obj/ar.h]]}

%-------------------------------------------------------------

<<include/ar.h>>=
<<constant ARMAG>>
<<constant SARMAG>>

<<constant ARFMAG>>
<<constant SARNAME>>

<<struct ar_hdr>>
<<constant SAR_HDR>>
@




\section{[[linkers/misc/]]}

\subsection*{[[linkers/misc/ar.c]]}


%-------------------------------------------------------------

<<linkers/misc/ar.c>>=
/*
 * ar - portable (ascii) format version
 */
#include <u.h>
#include <libc.h>
#include <bio.h>
#include <mach.h>
#include <ar.h>

/*
 *	The algorithm uses up to 3 temp files.  The "pivot member" is the
 *	archive member specified by and a, b, or i option.  The temp files are
 *	astart - contains existing members up to and including the pivot member.
 *	amiddle - contains new files moved or inserted behind the pivot.
 *	aend - contains the existing members that follow the pivot member.
 *	When all members have been processed, function 'install' streams the
 * 	temp files, in order, back into the archive.
 */

<<struct Arsymref>>

<<struct Armember>>

<<struct Arfile>>

<<struct Hashchain>>

<<constant NHASH>>

<<function HEADER_IO>>

        /* constants and flags */
<<global man>>
<<global opt>>
<<global artemp>>
<<global movtemp>>
<<global tailtemp>>
<<global symdef>>

<<global aflag>>
<<global bflag>>
<<global cflag>>
<<global oflag>>
<<global uflag>>
<<global vflag>>

Arfile *astart, *amiddle, *aend;	/* Temp file control block pointers */

<<global allobj>>
<<global symdefsize>>
<<global dupfound>>
<<global hash>>
    
<<constant ARNAMESIZE>>

<<global poname>>
<<global file>>
<<global bout>>
<<global bar>>

void	arcopy(Biobuf*, Arfile*, Armember*);
int	arcreate(char*);
void	arfree(Arfile*);
void	arinsert(Arfile*, Armember*);
char	*armalloc(int);
void	armove(Biobuf*, Arfile*, Armember*);
void	arread(Biobuf*, Armember*, int);
void	arstream(int, Arfile*);
int	arwrite(int, Armember*);
int	bamatch(char*, char*);
int	duplicate(char*);
Armember *getdir(Biobuf*);
int	getspace(void);
void	install(char*, Arfile*, Arfile*, Arfile*, int);
void	longt(Armember*);
int	match(int, char**);
void	mesg(int, char*);
Arfile	*newtempfile(char*);
Armember *newmember(void);
void	objsym(Sym*, void*);
int	openar(char*, int, int);
int	page(Arfile*);
void	pmode(long);
void	rl(int);
void	scanobj(Biobuf*, Arfile*, long);
void	select(int*, long);
void	setcom(void(*)(char*, int, char**));
void	skip(Biobuf*, vlong);
int	symcomp(void*, void*);
void	trim(char*, char*, int);
static void	usage(void);
void	wrerr(void);
void	wrsym(Biobuf*, long, Arsymref*);

void	rcmd(char*, int, char**);		/* command processing */
void	dcmd(char*, int, char**);
void	xcmd(char*, int, char**);
void	tcmd(char*, int, char**);
void	pcmd(char*, int, char**);
void	mcmd(char*, int, char**);
void	qcmd(char*, int, char**);

<<global comfun>>

<<function main>>
<<function setcom>>
<<function rcmd>>

<<function dcmd>>

<<function xcmd>>
<<function pcmd>>
<<function mcmd>>
<<function tcmd>>
<<function qcmd>>

<<function scanobj>>

<<function objsym>>

<<function duplicate>>

<<function openar>>

<<function arcreate>>

<<function wrerr>>

<<function rderr>>

<<function phaseerr>>

<<function usage>>

<<function getdir>>

<<function armove>>

<<function arcopy>>

<<function skip>>

<<function install>>

<<function rl>>

<<function wrsym>>

<<function match>>

<<function bamatch>>

<<function mesg>>

<<function trim>>

<<constant SUID>>
<<constant SGID>>
<<constant ROWN>>
<<constant WOWN>>
<<constant XOWN>>
<<constant RGRP>>
<<constant WGRP>>
<<constant XGRP>>
<<constant ROTH>>
<<constant WOTH>>
<<constant XOTH>>
<<constant STXT>>

<<function longt>>

<<global m1>>
<<global m2>>
<<global m3>>
<<global m4>>
<<global m5>>
<<global m6>>
<<global m7>>
<<global m8>>
<<global m9>>

<<global m>>

<<function pmode>>

<<function select>>

<<function newtempfile>>

<<function newmember>>

<<function arread>>

<<function arinsert>>

<<function arstream>>

<<function arwrite>>

<<function page>>

<<function getspace>>

<<function arfree>>

<<function armalloc>>
@


\subsection*{[[linkers/misc/nm.c]]}


%-------------------------------------------------------------

<<linkers/misc/nm.c>>=
/*
 * nm.c -- drive nm
 */
#include <u.h>
#include <libc.h>
#include <bio.h>

#include <mach.h>
#include <ar.h>

<<enum _anon_ (linkers/misc/nm.c)>>

<<global errs>>
<<global filename>>
<<global symname>>
<<global multifile>>
<<global aflag (linkers/misc/nm.c)>>
<<global gflag>>
<<global hflag>>
<<global nflag>>
<<global sflag>>
<<global uflag (linkers/misc/nm.c)>>
<<global Tflag>>

<<global fnames>>
<<global symptr>>
<<global nsym>>
<<global bout (linkers/misc/nm.c)>>

int	cmp(void*, void*);
static void	error(char*, ...);
void	execsyms(int);
void	psym(Sym*, void*);
void	printsyms(Sym**, long);
void	doar(Biobuf*);
void	dofile(Biobuf*);
void	zenter(Sym*);

<<function usage (linkers/misc/nm.c)>>

<<function main (linkers/misc/nm.c)>>

<<function doar>>

<<function dofile>>

<<function cmp>>
<<function zenter>>

<<function execsyms>>

<<function psym>>

<<function printsyms>>

<<function error>>
@


\subsection*{[[linkers/misc/size.c]]}

%-------------------------------------------------------------

<<linkers/misc/size.c>>=
#include	<u.h>
#include	<libc.h>
#include	<bio.h>

#include	<mach.h>

<<function size>>

<<function main (linkers/misc/size.c)>>
@


\subsection*{[[linkers/misc/strip.c]]}


%-------------------------------------------------------------

<<linkers/misc/strip.c>>=
#include <u.h>
#include <libc.h>
#include <bio.h>

#include <mach.h>

<<function error (linkers/misc/strip.c)>>

<<function usage (linkers/misc/strip.c)>>

<<function strip>>

<<function main (linkers/misc/strip.c)>>
@







\section{[[linkers/5l/]]}

\subsection*{[[linkers/5l/l.h]]}

<<enum misc_constant(arm)>>=
enum misc_constants {
    <<constant BIG>>

    <<constant STRINGSZ>>
    <<constant NHASH linker>>
    <<constant NHUNK linker>>

    <<constant MINSIZ>>
    <<constant MAXIO>>
    <<constant MAXHIST>>
};
@
% >>
%dead:    NENT		= 100,



%-------------------------------------------------------------

<<linkers/5l/l.h>>=
#include	<u.h>
#include	<libc.h>
#include	<bio.h>

#include	<common.out.h>
#include	<5.out.h>
#include	"../8l/elf.h"

<<macro DBG>>

<<constant LIBNAMELEN>>

typedef	struct	Adr	Adr;
typedef	struct	Sym	Sym;
typedef	struct	Auto	Auto;
typedef	struct	Prog	Prog;
typedef	struct	Optab	Optab;
typedef	struct	Oprange	Oprange;

<<constant P>>
<<constant S>>
<<constant TNAME(arm)>>

<<struct Adr(arm)>>

<<struct Prog(arm)>>

<<struct Sym>>

<<constant SIGNINTERN(arm)>>

<<struct Auto(arm)>>
<<struct Optab(arm)>>
<<struct Oprange(arm)>>

<<enum Section(arm)>>
<<enum Optab_flag(arm)>>
<<enum Operand_class(arm)>>
<<enum Mark(arm)>>

<<enum misc_constant(arm)>>

<<enum rxxx>>

<<enum headtype(arm)>>

<<struct Buf>>

// globals.c

extern	short	HEADTYPE;		/* type of header */
extern	long	HEADR;			/* length of header */
extern	long	INITTEXT;		/* text location */
extern	long	INITRND;		/* data round above text location */
extern	long	INITDAT;		/* data location */
extern	char*	INITENTRY;		/* entry point */

extern	long	INITTEXTP;		/* text location (physical) */ // ELF

extern union Buf buf;

extern	long	autosize;
extern	Biobuf	bso;
extern	long	bsssize;
extern	int	cbc;
extern	char*	cbp;
extern	int	cout;
extern	Auto*	curauto;
extern	Auto*	curhist;
extern	Prog*	curp;
extern	Prog*	curtext;
extern	Prog*	datap;
extern	long	datsize;
extern	bool	debug[128];
extern	Prog*	etextp;
extern	Prog*	firstp;
extern	char	fnuxi4[4];
extern	char	fnuxi8[8];
extern	char*	noname;
extern	Sym*	hash[NHASH];
extern	Sym*	histfrog[MAXHIST];
extern	int	histfrogp;
extern	int	histgen;
extern	char*	library[50];
extern	char*	libraryobj[50];
extern	int	libraryp;
extern	int	xrefresolv;
extern	char*	hunk;
extern	char	inuxi1[1];
extern	char	inuxi2[2];
extern	char	inuxi4[4];
extern	Prog*	lastp;
extern	long	lcsize;
extern	char	literal[32];
extern	int	nerrors;
extern	long	nhunk;
extern long	nsymbol;
extern	long	instoffset;
extern	Oprange	oprange[ALAST];
extern	char*	outfile;
extern	long	pc;
extern	long	symsize;
extern	Prog*	textp;
extern	long	textsize;
extern	long	thunk;
extern	int	version;
extern	bool	xcmp[C_GOK+1][C_GOK+1];
extern	Prog	zprg;
extern	int	dtype;
extern	int	armv4;
extern	int vfp;

extern	int	doexp, dlm;
extern	int	imports, nimports;
extern	int	exports, nexports;
extern	char*	EXPTAB;
extern	Prog	undefp;

<<constant UP>>

extern	char*	anames[];
extern	Optab	optab[];

void	addpool(Prog*, Adr*);
extern	Prog*	blitrl;
extern	Prog*	elitrl;

void	initdiv(void);
extern	Prog*	prog_div;
extern	Prog*	prog_divu;
extern	Prog*	prog_mod;
extern	Prog*	prog_modu;

<<pragmas varargck type>>
<<pragmas varargck argpos>>


int	Aconv(Fmt*);
int	Cconv(Fmt*);
int	Dconv(Fmt*);
int	Nconv(Fmt*);
int	Pconv(Fmt*);
int	Sconv(Fmt*);

void	addlibpath(char*);
int		fileexists(char*);
char*	findlib(char*);

int	aclass(Adr*);
void	addhist(long, int);
void	addlibpath(char*);
void	append(Prog*, Prog*);
void	asmb(void);
void	asmdyn(void);
void	asmlc(void);
void	asmout(Prog*, Optab*);
void	asmsym(void);
long	atolwhex(char*);
Prog*	brloop(Prog*);
void	buildop(void);
void	buildrep(int, int);
void	cflush(void);
void	ckoff(Sym*, long);
int	chipfloat(Ieee*);
int	cmp(int, int);
int	compound(Prog*);
double	cputime(void);
void	datblk(long, long, int);
void	diag(char*, ...);
void	divsig(void);
void	dodata(void);
void	doprof1(void);
void	doprof2(void);
void	dynreloc(Sym*, long, int);
long	entryvalue(void);
void	errorexit(void);
void	exchange(Prog*);
void	export(void);
int	fileexists(char*);
int	find1(long, int);
char*	findlib(char*);
void	follow(void);
void	gethunk(void);
void	histtoauto(void);
double	ieeedtod(Ieee*);
long	ieeedtof(Ieee*);
void	import(void);
int	isnop(Prog*);
void	ldobj(int, long, char*);
void	loadlib(void);
void	listinit(void);
Sym*	lookup(char*, int);
void	cput(int);
void	llput(vlong);
void	llputl(vlong);
void	lput(long);
void	lputl(long);
void	mkfwd(void);
void*	mysbrk(ulong);
void	names(void);
void	nocache(Prog*);
void	nuxiinit(void);
void	objfile(char*);
int	ocmp(const void*, const void*);
long	opirr(int);
Optab*	oplook(Prog*);

long	oprrr(int, int);

long	omvl(Prog*, Adr*, int);

long	olr(int, int, long, int, int);
long	olrr(int, int, int, int, int);

long	osr(int, int, int, long, int);
long	osrr(int, int, int, int, int);

long	olhr(long, int, int, int);
long	olhrr(int, int, int, int);
long	oshr(int, long, int, int);
long	oshrr(int, int, int, int);

long	opvfprrr(int, int);
long	ofsr(int, int, long, int, int, Prog*);


void	patch(void);
void	prasm(Prog*);
void	prepend(Prog*, Prog*);
Prog*	prg(void);
int	pseudo(Prog*);
void	putsymb(char*, int, long, int);
void	readundefs(char*, int);
long	regoff(Adr*);
int	relinv(int);
long	rnd(long, long);
void	dotext(void);
void	strnput(char*, int);
void	undef(void);
void	undefsym(Sym*);
void	wput(long);
void	wputl(long);
void	xdefine(char*, int, long);
void	xfol(Prog*);
void	zerosig(char*);
void	noops(void);
long	immrot(ulong);
long	immaddr(long);
long	opbra(int, int);

void mylog(char*, ...);

@

%dead: typedef	struct	Count	Count;


\subsection*{[[linkers/5l/globals.c]]}


%-------------------------------------------------------------

<<linkers/5l/globals.c>>=
#include	"l.h"

<<global buf>>


<<global HEADR>>
<<global HEADTYPE>>
<<global INITDAT>>
<<global INITRND>>
<<global INITTEXT>>
<<global INITTEXTP>>
<<global INITENTRY>>

<<global autosize(arm)>>
<<global bso>>
<<global bsssize>>

<<global cbc>>
<<global cbp>>

<<global cout>>
<<global curauto>>
<<global curhist>>
<<global curp>>
<<global curtext>>
<<global datap>>
<<global datsize>>
<<global debug>>
<<global etextp>>
<<global firstp>>

<<global fnuxi4>>
<<global fnuxi8>>

<<global hash linker>>

<<global histfrog>>
<<global histfrogp>>
<<global histgen>>

<<global library>>
<<global libraryobj>>
<<global libraryp>>

<<global xrefresolv>>
<<global hunk>>

<<global inuxi1>>
<<global inuxi2>>
<<global inuxi4>>

<<global lastp>>
<<global lcsize>>
<<global literal(arm)>>
<<global nerrors>>
<<global nhunk>>
<<global nsymbol linker>>
<<global instoffset(arm)>>
<<global oprange(arm)>>
<<global outfile>>
<<global pc>>
<<global symsize>>
<<global textp>>
<<global textsize>>
<<global thunk>>
<<global version>>
<<global xcmp(arm)>>
<<global zprg>>
<<global armv4(arm)>>
<<global vfp(arm)>>

<<global doexp>>
<<global dlm>>

<<global imports>>
<<global nimports>>
<<global exports>>
<<global nexports>>
<<global EXPTAB>>
<<global undefp>>

<<global blitrl(arm)>>
<<global elitrl(arm)>>

<<global prog_div(arm)>>
<<global prog_divu(arm)>>
<<global prog_mod(arm)>>
<<global prog_modu(arm)>>
@

%old: <<global dtype(arm)>>

\subsection*{[[linkers/5l/optab.c]]}

%-------------------------------------------------------------

<<linkers/5l/optab.c>>=
#include	"l.h"

<<global optab (linkers/5l/optab.c)(arm)>>
@


\subsection*{[[linkers/5l/utils.c]]}

<<linkers/5l/utils.c>>=
#include "l.h"

<<function log>>

<<function errorexit>>

<<function gethunk>>

<<function lookup>>

<<constructor prg>>

<<function copyp>>

@
\subsection*{[[linkers/5l/list.c]]}

%-------------------------------------------------------------

<<linkers/5l/list.c>>=
#include "l.h"

<<function listinit(arm)>>

<<function prasm(arm)>>

<<function Pconv(arm)>>

<<function Aconv(arm)>>

<<global strcond(arm)>>

<<function Cconv(arm)>>

<<function Dconv(arm)>>

<<function Nconv(arm)>>

<<function Sconv(arm)>>

<<function diag>>
@

\subsection*{[[linkers/5l/compat.c]]}


%-------------------------------------------------------------

<<linkers/5l/compat.c>>=
#include	"l.h"

<<function malloc>>

<<function free>>

<<function setmalloctag>>

<<function fileexists>>
@


\subsection*{[[linkers/5l/pass.c]]}

%-------------------------------------------------------------

<<linkers/5l/pass.c>>=
#include	"l.h"

<<function dodata(arm)>>

<<function undef>>

<<function brchain(arm)>>

<<function relinv(arm)>>

<<function follow>>

<<function xfol(arm)>>

<<function patch(arm)>>

<<constant LOG>>
<<function mkfwd>>

<<function brloop(arm)>>

<<function atolwhex>>

<<function rnd>>

<<function import(arm)>>

<<function ckoff>>

<<function newdata(arm)>>

<<function export(arm)>>
@

\subsection*{[[linkers/5l/asm.c]]}


%<<struct Count(arm)>>=
%struct	Count
%{
%    long	count;
%    long	outof;
%};
%@

%<<function nopstat(arm)>>=
%void
%nopstat(char *f, Count *c)
%{
%    if(c->outof)
%    Bprint(&bso, "%s delay %ld/%ld (%.2f)\n", f,
%        c->outof - c->count, c->outof,
%        (double)(c->outof - c->count)/c->outof);
%}
%@



%<<global PP(arm)>>

%-------------------------------------------------------------

<<linkers/5l/asm.c>>=
#include	"l.h"

<<constant Dbufslop>>

<<function entryvalue(arm)>>

<<function asmb(arm)>>

<<function strnput(arm)>>

<<function cput(arm)>>

<<function wput(arm)>>

<<function wputl(arm)>>

<<function lput(arm)>>

<<function lputl(arm)>>

<<function llput>>

<<function llputl>>

<<function cflush>>

<<function asmsym(arm)>>

<<function putsymb>>

<<constant MINLC(arm)>>
<<function asmlc>>

<<function datblk(arm)>>

<<function asmout(arm)>>

<<function oprrr(arm)>>

<<function opvfprrr(arm)>>

<<function opbra(arm)>>

<<function olr(arm)>>

<<function olhr(arm)>>

<<function osr(arm)>>

<<function oshr(arm)>>
    

<<function osrr(arm)>>

<<function oshrr(arm)>>

<<function olrr(arm)>>

<<function olhrr(arm)>>

<<function ovfpmem(arm)>>

<<function ofsr(arm)>>

<<function omvl(arm)>>

<<global chipfloats(arm)>>

<<function chipfloat(arm)>>
@


\subsection*{[[linkers/5l/span.c]]}


%-------------------------------------------------------------

<<linkers/5l/span.c>>=
#include	"l.h"

<<global pool(arm)>>

void	checkpool(Prog*);
void 	flushpool(Prog*, int);
typedef struct Reloc Reloc;


<<function span(arm)>>

<<function checkpool(arm)>>

<<function flushpool(arm)>>

<<function addpool(arm)>>

<<function xdefine(arm)>>

<<function regoff(arm)>>

<<function immrot(arm)>>

<<function immaddr(arm)>>

<<function immfloat(arm)>>

<<function immhalf(arm)>>

<<function aclass(arm)>>

<<function oplook(arm)>>

<<function cmp(arm)>>

<<function ocmp(arm)>>

<<function buildop(arm)>>

<<enum _anon_ (linkers/5l/span.c)(arm)>>

<<global modemap>>

<<struct Reloc>>

<<global rels>>

<<function grow>>

<<function dynreloc(arm)>>

<<function sput>>

<<function asmdyn>>
@


\subsection*{[[linkers/5l/obj.c]]}

%old:
%#ifndef	DEFAULT
%<<constant DEFAULT>>
%#endif

%-------------------------------------------------------------

<<linkers/5l/obj.c>>=
#include	"l.h"
#include	<ar.h>


<<global noname linker>>
<<global symname linker>>
<<global thechar>>
<<global thestring>>

<<global libdir>>
<<global nlibdir>>
<<global maxlibdir>>

<<function usage, linker>>

<<function isobjfile>>

<<function main(arm)>>

<<function addlibpath>>

<<function findlib>>

<<function loadlib>>

<<function objfile>>

<<function inopd(arm)>>

<<function addlib>>

<<function addhist>>

<<function histtoauto>>

<<function collapsefrog>>

<<function nopout>>

<<function readsome>>

<<function ldobj(arm)>>

<<function doprof1(arm)>>

<<global brcond(arm)>>

<<function doprof2(arm)>>

<<function nuxiinit(arm)>>

<<function find1>>

<<function ieeedtof>>

<<function ieeedtod>>

<<function undefsym>>

<<function zerosig>>

<<function readundefs>>
@



\subsection*{[[linkers/5l/noop.c]]}


%-------------------------------------------------------------

<<linkers/5l/noop.c>>=
#include	"l.h"

<<global sym_div(arm)>>
<<global sym_divu(arm)>>
<<global sym_mod(arm)>>
<<global sym_modu(arm)>>

<<function noops(arm)>>

<<function sigdiv(arm)>>

<<function divsig(arm)>>

<<function sdiv(arm)>>

<<function initdiv(arm)>>

<<function nocache(arm)>>
@


