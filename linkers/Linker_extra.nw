\section{[[include/]]}

\subsection*{[[include/a.out.h]]}

<<function _MAGIC>>=
#define	_MAGIC(f, b)	((f)|((((4*(b))+0)*(b))+7))
@

<<constant I_MAGIC>>=
#define	I_MAGIC		_MAGIC(0, 11)		/* intel 386 */
@

<<constant E_MAGIC>>=
#define	E_MAGIC		_MAGIC(0, 20)		/* arm */
@

<<constant HDR_MAGIC>>=
#define HDR_MAGIC	0x00008000		/* header expansion */
@
% for 64 bit architecture


%#define	A_MAGIC		_MAGIC(0, 8)		/* 68020 (retired) */
%#define	J_MAGIC		_MAGIC(0, 12)		/* intel 960 (retired) */
%#define	K_MAGIC		_MAGIC(0, 13)		/* sparc */
%#define	V_MAGIC		_MAGIC(0, 16)		/* mips 3000 BE */
%#define	X_MAGIC		_MAGIC(0, 17)		/* att dsp 3210 (retired) */
%#define	M_MAGIC		_MAGIC(0, 18)		/* mips 4000 BE */
%#define	D_MAGIC		_MAGIC(0, 19)		/* amd 29000 (retired) */
%#define	Q_MAGIC		_MAGIC(0, 21)		/* powerpc */
%#define	N_MAGIC		_MAGIC(0, 22)		/* mips 4000 LE */
%#define	L_MAGIC		_MAGIC(0, 23)		/* dec alpha (retired) */
%#define	P_MAGIC		_MAGIC(0, 24)		/* mips 3000 LE */
%#define	U_MAGIC		_MAGIC(0, 25)		/* sparc64 (retired) */

%#define	S_MAGIC		_MAGIC(HDR_MAGIC, 26)	/* amd64 */
%#define	T_MAGIC		_MAGIC(HDR_MAGIC, 27)	/* powerpc64 */
%#define	R_MAGIC		_MAGIC(HDR_MAGIC, 28)	/* arm64 */



<<constant MIN_MAGIC>>=
#define	MIN_MAGIC	11
@

<<constant MAX_MAGIC>>=
#define	MAX_MAGIC	20			/* <= 90 */
@

<<constant DYN_MAGIC>>=
#define	DYN_MAGIC	0x80000000		/* dlm */
@

<<struct Sym a.out.h>>=
struct	Sym
{
    vlong	value;
    uint	sig;
    char	type;
    char	*name;
};
@


%-------------------------------------------------------------

<<include/a.out.h>>=
<<struct Exec>>
typedef	struct	Exec	Exec;

<<constant HDR_MAGIC>>

<<function _MAGIC>>

<<constant I_MAGIC>>
<<constant E_MAGIC>>

<<constant MIN_MAGIC>>
<<constant MAX_MAGIC>>

<<constant DYN_MAGIC>>

typedef	struct	Sym	Sym;
<<struct Sym a.out.h>>
@


\subsection*{[[include/ar.h]]}

%-------------------------------------------------------------

<<include/ar.h>>=
<<constant ARMAG>>
<<constant SARMAG>>

<<constant ARFMAG>>
<<constant SARNAME>>

<<struct ar_hdr>>
<<constant SAR_HDR>>
@


\subsection*{[[include/bootexec.h]]}

<<struct coffsect>>=
struct coffsect
{
    char	name[8];
    ulong	phys;
    ulong	virt;
    ulong	size;
    ulong	fptr;
    ulong	fptrreloc;
    ulong	fptrlineno;
    ulong	nrelocnlineno;
    ulong	flags;
};
@

<<struct i386exec>>=
struct i386exec
{
    struct	i386coff{
        ulong	isectmagic;
        ulong	itime;
        ulong	isyms;
        ulong	insyms;
        ulong	iflags;
    };
    struct	i386hdr{
        ulong	imagic;
        ulong	itextsize;
        ulong	idatasize;
        ulong	ibsssize;
        ulong	ientry;
        ulong	itextstart;
        ulong	idatastart;
    };
    struct coffsect itexts;
    struct coffsect idatas;
    struct coffsect ibsss;
    struct coffsect icomments;
};
@


%-------------------------------------------------------------

<<include/bootexec.h>>=
<<struct coffsect>>

<<struct i386exec>>
@


\subsection*{[[include/elf.h]]}

<<enum _anon_>>=
/* was in /sys/src/libmach/elf.h */
enum {
    /* Ehdr codes */
    MAG0 = 0,		/* ident[] indexes */
    MAG1 = 1,
    MAG2 = 2,
    MAG3 = 3,
    CLASS = 4,
    DATA = 5,
    VERSION = 6,

    ELFCLASSNONE = 0,	/* ident[CLASS] */
    ELFCLASS32 = 1,
    ELFCLASS64 = 2,
    ELFCLASSNUM = 3,

    ELFDATANONE = 0,	/* ident[DATA] */
    ELFDATA2LSB = 1,
    ELFDATA2MSB = 2,
    ELFDATANUM = 3,

    NOETYPE = 0,		/* type */
    REL = 1,
    EXEC = 2,
    DYN = 3,
    CORE = 4,

    NONE = 0,		/* machine */
    M32 = 1,		/* AT&T WE 32100 */
    SPARC = 2,		/* Sun SPARC */
    I386 = 3,		/* Intel 80386 */
    M68K = 4,		/* Motorola 68000 */
    M88K = 5,		/* Motorola 88000 */
    I486 = 6,		/* Intel 80486 */
    I860 = 7,		/* Intel i860 */
    MIPS = 8,		/* Mips R2000 */
    S370 = 9,		/* Amdhal	*/
    MIPSR4K = 10,	/* Mips R4000 */
    SPARC64 = 18,	/* Sun SPARC v9 */
    POWER = 20,		/* PowerPC */
    POWER64 = 21,	/* PowerPC64 */
    ARM = 40,		/* ARM */
    AMD64 = 62,		/* Amd64 */
    ARM64 = 183,	/* ARM64 */

    NO_VERSION = 0,		/* version, ident[VERSION] */
    CURRENT = 1,

    /* Phdr Codes */
    NOPTYPE = 0,		/* type */
    PT_LOAD = 1, /* also LOAD */
    DYNAMIC = 2,
    INTERP = 3,
    NOTE = 4,
    SHLIB = 5,
    PHDR = 6,

    R = 0x4,		/* flags */
    W = 0x2,
    X = 0x1,

    /* Shdr Codes */
    Progbits = 1,	/* section types */
    Strtab = 3,
    Nobits = 8,

    SwriteElf = 1,	/* section attributes (flags) */
    Salloc = 2,
    Sexec = 4,
};
@

<<struct Ehdr>>=
/*
 *	Definitions needed for accessing ELF headers
 */
struct Ehdr {
    uchar	ident[16];	/* ident bytes */
    ushort	type;		/* file type */
    ushort	machine;	/* target machine */
    int	version;	/* file version */
    ulong	elfentry;	/* start address */
    ulong	phoff;		/* phdr file offset */
    ulong	shoff;		/* shdr file offset */
    int	flags;		/* file flags */
    ushort	ehsize;		/* sizeof ehdr */
    ushort	phentsize;	/* sizeof phdr */
    ushort	phnum;		/* number phdrs */
    ushort	shentsize;	/* sizeof shdr */
    ushort	shnum;		/* number shdrs */
    ushort	shstrndx;	/* shdr string index */
};
@

%struct E64hdr {
%    u8int	ident[16];	/* ident bytes */
%    u16int	type;		/* file type */
%    u16int	machine;	/* target machine */
%    u32int	version;	/* file version */
%    u64int	elfentry;	/* start address */
%    u64int	phoff;		/* phdr file offset */
%    u64int	shoff;		/* shdr file offset */
%    u32int	flags;		/* file flags */
%    u16int	ehsize;		/* sizeof ehdr */
%    u16int	phentsize;	/* sizeof phdr */
%    u16int	phnum;		/* number phdrs */
%    u16int	shentsize;	/* sizeof shdr */
%    u16int	shnum;		/* number shdrs */
%    u16int	shstrndx;	/* shdr string index */
%};


<<struct Phdr>>=
struct Phdr {
    int	type;		/* entry type */
    ulong	offset;		/* file offset */
    ulong	vaddr;		/* virtual address */
    ulong	paddr;		/* physical address */
    int	filesz;		/* file size */
    ulong	memsz;		/* memory size */
    int	flags;		/* entry flags */
    int	align;		/* memory/file alignment */
};
@


%struct P64hdr {
%    u32int	type;		/* entry type */
%    u32int	flags;		/* entry flags */
%    u64int	offset;		/* file offset */
%    u64int	vaddr;		/* virtual address */
%    u64int	paddr;		/* physical address */
%    u64int	filesz;		/* file size */
%    u64int	memsz;		/* memory size */
%    u64int	align;		/* memory/file alignment */
%}; 


<<struct Shdr>>=
struct Shdr {
    ulong	name;		/* section name */
    ulong	type;		/* SHT_... */
    ulong	flags;		/* SHF_... */
    ulong	addr;		/* virtual address */
    ulong	offset;		/* file offset */
    ulong	size;		/* section size */
    ulong	link;		/* misc info */
    ulong	info;		/* misc info */
    ulong	addralign;	/* memory alignment */
    ulong	entsize;	/* entry size if table */
};
@

%struct S64hdr {
%    u32int	name;		/* section name */
%    u32int	type;		/* SHT_... */
%    u64int	flags;		/* SHF_... */
%    u64int	addr;		/* virtual address */
%    u64int	offset;		/* file offset */
%    u64int	size;		/* section size */
%    u32int	link;		/* misc info */
%    u32int	info;		/* misc info */
%    u64int	addralign;	/* memory alignment */
%    u64int	entsize;	/* entry size if table */
%};

<<constant ELF_MAG>>=
#define	ELF_MAG		((0x7f<<24) | ('E'<<16) | ('L'<<8) | 'F')
@


%-------------------------------------------------------------

<<include/elf.h>>=

<<enum _anon_>>


<<struct Ehdr>>
typedef struct Ehdr Ehdr;

<<struct Phdr>>
typedef struct Phdr Phdr;

<<struct Shdr>>
typedef struct Shdr Shdr;

<<constant ELF_MAG>>
@


\subsection*{[[include/mach.h]]}

% *		mips,
% *		68020,
% *		amd64,
% *		sparc,
% *		mips2 (R4000)
% *		powerpc,
% *		powerpc64
% *		arm64

%    MMIPS,			
%    MSPARC,
%    M68020,
%    MI960,			/* retired */
%    M3210,			/* retired */
%    MMIPS2,
%    NMIPS2,
%    M29000,			/* retired */
%    MPOWER,
%    MALPHA,			/* retired */
%    NMIPS,
%    MSPARC64,		/* retired */
%    MAMD64,
%    MPOWER64,
%    MARM64,

%    FMIPS,			/* v.out */
%    FMIPSB,			/* mips bootable */
%    FSPARC,			/* k.out */
%    FSPARCB,		/* Sparc bootable */
%    F68020,			/* 2.out */
%    F68020B,		/* 68020 bootable */
%    FNEXTB,			/* Next bootable */
%    FI960,			/* retired */
%    FI960B,			/* retired */
%    F3210,			/* retired */
%    FMIPS2BE,		/* 4.out */
%    F29000,			/* retired */
%    FPOWER,			/* q.out */
%    FPOWERB,		/* power pc bootable */
%    FMIPS2LE,		/* 0.out */
%    FALPHA,			/* retired */
%    FALPHAB,		/* retired DEC Alpha bootable */
%    FMIPSLE,		/* 3k little endian */
%    FSPARC64,		/* retired */
%    FAMD64,			/* 6.out */
%    FAMD64B,		/* 6.out bootable */
%    FPOWER64,		/* 9.out */
%    FPOWER64B,		/* 9.out bootable */
%    FARM64,			/* arm64 */
%    FARM64B,		/* arm64 bootable */
%
%    AMIPS,
%    AMIPSCO,		/* native mips */
%    ASPARC,
%    ASUNSPARC,		/* native sun */
%    A68020,
%    AI960,			/* retired */
%    A29000,			/* retired */
%    APOWER,
%    AALPHA,			/* retired */
%    ASPARC64,		/* retired */
%    AAMD64,
%    APOWER64,
%    AARM64,
%
%    Obj68020 = 0,		/* .2 */
%    ObjSparc,		/* .k */
%    ObjMips,		/* .v */
%    Obj960,			/* retired */
%    Obj3210,		/* retired */
%    ObjMips2,		/* .4 */
%    Obj29000,		/* retired */
%    ObjPower,		/* .q */
%    ObjMips2le,		/* .0 */
%    ObjAlpha,		/* retired */
%    ObjSparc64,		/* retired */
%    ObjAmd64,		/* .6 */
%    ObjSpim,		/* .0 */
%    ObjPower64,		/* .9 */
%    ObjArm64,		/* .4? */

<<enum _anon_ (include/mach.h)>>=
/*
 *	Supported architectures:
 *		i386,
 *		arm
 */
/* machine types */
enum
{
    MI386,
    MARM,

//TODO another enum
/* types of executables */
    FNONE = 0,		/* unidentified */

    FI386,			/* 8.out */
    FI386B,			/* I386 bootable */
    FARM,			/* 5.out */
    FARMB,			/* ARM bootable */

/* dissembler types */
    ANONE = 0,		

    AI386,
    AI8086,			/* oh god */
    AARM,

/* object file types */
    Obj386 = 0,			/* .8 */
    ObjArm,			/* .5 */

    Maxobjtype,

/* symbol table classes */
    CNONE  = 0,	
    CAUTO,
    CPARAM,
    CSTAB,
    CTEXT,
    CDATA,
    CANY,			/* to look for any class */
};
@

<<struct Map>>=
/*
 * 	Structure to map a segment to a position in a file
 */
struct Map {
    int	nsegs;			/* number of segments */
    struct segment {		/* per-segment map */
        char	*name;		/* the segment name */
        int	fd;		/* file descriptor */
        int	inuse;		/* in use - not in use */
        int	cache;		/* should cache reads? */
        uvlong	b;		/* base */
        uvlong	e;		/* end */
        vlong	f;		/* offset within file */
    } seg[1];			/* actually n of these */
};
@

<<struct Symbol>>=
/*
 *	Internal structure describing a symbol table entry
 */
struct Symbol {
    void 	*handle;		/* used internally - owning func */
    struct {
        char	*name;
        vlong	value;		/* address or stack offset */
        char	type;		/* as in a.out.h */
        char	class;		/* as above */
        int	index;		/* in findlocal, globalsym, textsym */
    };
};
@

<<struct Reglist>>=
/*
 *	machine register description
 */
struct Reglist {
    char	*rname;			/* register name */
    short	roffs;			/* offset in u-block */
    char	rflags;			/* INTEGER/FLOAT, WRITABLE */
    char	rformat;		/* print format: 'x', 'X', 'f', '8', '3', 'Y', 'W' */
};
@

<<enum _anon_ (include/mach.h)2>>=
enum {					/* bits in rflags field */
    RINT	= (0<<0),
    RFLT	= (1<<0),
    RRDONLY	= (1<<1),
};
@

<<struct Mach>>=
/*
 *	Machine-dependent data is stored in two structures:
 *		Mach  - miscellaneous general parameters
 *		Machdata - jump vector of service functions used by debuggers
 *
 *	Mach is defined in ?.c and set in executable.c
 *
 *	Machdata is defined in ?db.c
 *		and set in the debugger startup.
 */
struct Mach{
    char	*name;
    int	mtype;			/* machine type code */
    Reglist *reglist;		/* register set */
    long	regsize;		/* sizeof registers in bytes */
    long	fpregsize;		/* sizeof fp registers in bytes */
    char	*pc;			/* pc name */
    char	*sp;			/* sp name */
    char	*link;			/* link register name */
    char	*sbreg;			/* static base register name */
    uvlong	sb;			/* static base register value */
    int	pgsize;			/* page size */
    uvlong	kbase;			/* kernel base address */
    uvlong	ktmask;			/* ktzero = kbase & ~ktmask */
    uvlong	utop;			/* user stack top */
    int	pcquant;		/* quantization of pc */
    int	szaddr;			/* sizeof(void*) */
    int	szreg;			/* sizeof(register) */
    int	szfloat;		/* sizeof(float) */
    int	szdouble;		/* sizeof(double) */
};
@

<<struct Machdata>>=
struct	Machdata {		/* Machine-dependent debugger support */
    uchar	bpinst[4];			/* break point instr. */
    short	bpsize;				/* size of break point instr. */

    ushort	(*swab)(ushort);		/* ushort to local byte order */
    ulong	(*swal)(ulong);			/* ulong to local byte order */
    uvlong	(*swav)(uvlong);		/* uvlong to local byte order */
    int	(*ctrace)(Map*, uvlong, uvlong, uvlong, Tracer); /* C traceback */
    uvlong	(*findframe)(Map*, uvlong, uvlong, uvlong, uvlong);/* frame finder */
    char*	(*excep)(Map*, Rgetter);	/* last exception */
    ulong	(*bpfix)(uvlong);		/* breakpoint fixup */
    int	(*sftos)(char*, int, void*);	/* single precision float */
    int	(*dftos)(char*, int, void*);	/* double precision float */
    int	(*foll)(Map*, uvlong, Rgetter, uvlong*);/* follow set */
    int	(*das)(Map*, uvlong, char, char*, int);	/* symbolic disassembly */
    int	(*hexinst)(Map*, uvlong, char*, int); 	/* hex disassembly */
    int	(*instsize)(Map*, uvlong);	/* instruction size */
};
@



%-------------------------------------------------------------

<<include/mach.h>>=
/*
 *	Architecture-dependent application data
 */
#include "a.out.h"
//TODO: include "elf.h" too? and macho.h?
#pragma	src	"/sys/src/libmach"
#pragma	lib	"libmach.a"

<<enum _anon_ (include/mach.h)>>

typedef	struct	Map	Map;
typedef struct	Symbol	Symbol;
typedef	struct	Reglist	Reglist;
typedef	struct	Mach	Mach;
typedef	struct	Machdata Machdata;

<<struct Map>>

<<struct Symbol>>

<<struct Reglist>>

<<enum _anon_ (include/mach.h)2>>

<<struct Mach>>

extern	Mach	*mach;			/* Current machine */

typedef uvlong	(*Rgetter)(Map*, char*);
typedef	void	(*Tracer)(Map*, uvlong, uvlong, Symbol*);

<<struct Machdata>>

<<struct Fhdr>>

extern	int	asstype;	/* dissembler type - machdata.c */
extern	Machdata *machdata;	/* jump vector - machdata.c */

Map*		attachproc(int, int, int, Fhdr*);
int		beieee80ftos(char*, int, void*);
int		beieeesftos(char*, int, void*);
int		beieeedftos(char*, int, void*);
ushort		beswab(ushort);
ulong		beswal(ulong);
uvlong		beswav(uvlong);
uvlong		ciscframe(Map*, uvlong, uvlong, uvlong, uvlong);
int		cisctrace(Map*, uvlong, uvlong, uvlong, Tracer);
int		crackhdr(int fd, Fhdr*);
uvlong		file2pc(char*, long);
int		fileelem(Sym**, uchar *, char*, int);
long		fileline(char*, int, uvlong);
int		filesym(int, char*, int);
int		findlocal(Symbol*, char*, Symbol*);
int		findseg(Map*, char*);
int		findsym(uvlong, int, Symbol *);
int		fnbound(uvlong, uvlong*);
int		fpformat(Map*, Reglist*, char*, int, int);
int		get1(Map*, uvlong, uchar*, int);
int		get2(Map*, uvlong, ushort*);
int		get4(Map*, uvlong, ulong*);
int		get8(Map*, uvlong, uvlong*);
int		geta(Map*, uvlong, uvlong*);
int		getauto(Symbol*, int, int, Symbol*);
Sym*		getsym(int);
int		globalsym(Symbol *, int);
char*		_hexify(char*, ulong, int);
int		ieeesftos(char*, int, ulong);
int		ieeedftos(char*, int, ulong, ulong);
int		isar(Biobuf*);
int		leieee80ftos(char*, int, void*);
int		leieeesftos(char*, int, void*);
int		leieeedftos(char*, int, void*);
ushort		leswab(ushort);
ulong		leswal(ulong);
uvlong		leswav(uvlong);
uvlong		line2addr(long, uvlong, uvlong);
Map*		loadmap(Map*, int, Fhdr*);
int		localaddr(Map*, char*, char*, uvlong*, Rgetter);
int		localsym(Symbol*, int);
int		lookup(char*, char*, Symbol*);
void		machbytype(int);
int		machbyname(char*);
int		nextar(Biobuf*, int, char*);
Map*		newmap(Map*, int);
void		objtraverse(void(*)(Sym*, void*), void*);
int		objtype(Biobuf*, char**);
uvlong		pc2sp(uvlong);
long		pc2line(uvlong);
int		put1(Map*, uvlong, uchar*, int);
int		put2(Map*, uvlong, ushort);
int		put4(Map*, uvlong, ulong);
int		put8(Map*, uvlong, uvlong);
int		puta(Map*, uvlong, uvlong);
int		readar(Biobuf*, int, vlong, int);
int		readobj(Biobuf*, int);
uvlong		riscframe(Map*, uvlong, uvlong, uvlong, uvlong);
int		risctrace(Map*, uvlong, uvlong, uvlong, Tracer);
int		setmap(Map*, int, uvlong, uvlong, vlong, char*);
Sym*		symbase(long*);
int		syminit(int, Fhdr*);
int		symoff(char*, int, uvlong, int);
void		textseg(uvlong, Fhdr*);
int		textsym(Symbol*, int);
void		unusemap(Map*, int);
@


\section{[[linkers/misc/]]}

\subsection*{[[linkers/misc/ar.c]]}

<<struct Arsymref>>=
typedef struct	Arsymref
{
    char	*name;
    int	type;
    int	len;
    vlong	offset;
    struct	Arsymref *next;
} Arsymref;
@

<<struct Armember>>=
typedef struct	Armember	/* Temp file entry - one per archive member */
{
    struct Armember	*next;
    struct ar_hdr	hdr;
    long		size;
    long		date;
    void		*member;
} Armember;
@

<<struct Arfile>>=
typedef	struct Arfile		/* Temp file control block - one per tempfile */
{
    int	paged;		/* set when some data paged to disk */
    char	*fname;		/* paging file name */
    int	fd;		/* paging file descriptor */
    vlong	size;
    Armember *head;		/* head of member chain */
    Armember *tail;		/* tail of member chain */
    Arsymref *sym;		/* head of defined symbol chain */
} Arfile;
@

<<struct Hashchain>>=
typedef struct Hashchain
{
    char	*name;
    struct Hashchain *next;
} Hashchain;
@

<<constant NHASH>>=
#define	NHASH	1024
@

<<function HEADER_IO>>=
/*
 *	macro to portably read/write archive header.
 *	'cmd' is read/write/Bread/Bwrite, etc.
 */
#define	HEADER_IO(cmd, f, h)	cmd(f, h.name, sizeof(h.name)) != sizeof(h.name)\
                || cmd(f, h.date, sizeof(h.date)) != sizeof(h.date)\
                || cmd(f, h.uid, sizeof(h.uid)) != sizeof(h.uid)\
                || cmd(f, h.gid, sizeof(h.gid)) != sizeof(h.gid)\
                || cmd(f, h.mode, sizeof(h.mode)) != sizeof(h.mode)\
                || cmd(f, h.size, sizeof(h.size)) != sizeof(h.size)\
                || cmd(f, h.fmag, sizeof(h.fmag)) != sizeof(h.fmag)
@

<<global man>>=
char	*man =		"mrxtdpq";
@

<<global opt>>=
char	*opt =		"uvnbailo";
@

<<global artemp>>=
char	artemp[] =	"/tmp/vXXXXX";
@

<<global movtemp>>=
char	movtemp[] =	"/tmp/v1XXXXX";
@

<<global tailtemp>>=
char	tailtemp[] =	"/tmp/v2XXXXX";
@

<<global symdef>>=
char	symdef[] =	"__.SYMDEF";
@

<<global aflag>>=
int	aflag;				/* command line flags */
@

<<global bflag>>=
static int	bflag;
@

<<global cflag>>=
int	cflag;
@

<<global oflag>>=
int	oflag;
@

<<global uflag>>=
int	uflag;
@

<<global vflag>>=
int	vflag;
@

<<global allobj>>=
int	allobj = 1;			/* set when all members are object files of the same type */
@

<<global symdefsize>>=
int	symdefsize;			/* size of symdef file */
@

<<global dupfound>>=
int	dupfound;			/* flag for duplicate symbol */
@

<<global hash>>=
Hashchain	*hash[NHASH];		/* hash table of text symbols */
@

<<constant ARNAMESIZE>>=
#define	ARNAMESIZE	sizeof(astart->tail->hdr.name)
@

<<global poname>>=
char	poname[ARNAMESIZE+1];		/* name of pivot member */
@

<<global file>>=
char	*file;				/* current file or member being worked on */
@

<<global bout>>=
Biobuf	bout;
@

<<global bar>>=
Biobuf bar;
@

<<global comfun>>=
void	(*comfun)(char*, int, char**);
@

<<function main>>=
void
main(int argc, char *argv[])
{
    char *cp;

    Binit(&bout, 1, OWRITE);
    if(argc < 3)
        usage();
    for (cp = argv[1]; *cp; cp++) {
        switch(*cp) {
        case 'a':	aflag = 1;	break;
        case 'b':	bflag = 1;	break;
        case 'c':	cflag = 1;	break;
        case 'd':	setcom(dcmd);	break;
        case 'i':	bflag = 1;	break;
        case 'l':
                strcpy(artemp, "vXXXXX");
                strcpy(movtemp, "v1XXXXX");
                strcpy(tailtemp, "v2XXXXX");
                break;
        case 'm':	setcom(mcmd);	break;
        case 'o':	oflag = 1;	break;
        case 'p':	setcom(pcmd);	break;
        case 'q':	setcom(qcmd);	break;
        case 'r':	setcom(rcmd);	break;
        case 't':	setcom(tcmd);	break;
        case 'u':	uflag = 1;	break;
        case 'v':	vflag = 1;	break;
        case 'x':	setcom(xcmd);	break;
        default:
            fprint(2, "ar: bad option `%c'\n", *cp);
            exits("error");
        }
    }
    if (aflag && bflag) {
        fprint(2, "ar: only one of 'a' and 'b' can be specified\n");
        usage();
    }
    if(aflag || bflag) {
        trim(argv[2], poname, sizeof(poname));
        argv++;
        argc--;
        if(argc < 3)
            usage();
    }
    if(comfun == 0) {
        if(uflag == 0) {
            fprint(2, "ar: one of [%s] must be specified\n", man);
            usage();
        }
        setcom(rcmd);
    }
    cp = argv[2];
    argc -= 3;
    argv += 3;
    (*comfun)(cp, argc, argv);	/* do the command */
    cp = 0;
    while (argc--) {
        if (*argv) {
            fprint(2, "ar: %s not found\n", *argv);
            cp = "error";
        }
        argv++;
    }
    exits(cp);
}
@

<<function setcom>>=
/*
 *	select a command
 */
void
setcom(void (*fun)(char *, int, char**))
{

    if(comfun != 0) {
        fprint(2, "ar: only one of [%s] allowed\n", man);
        usage();
    }
    comfun = fun;
}
@

<<function rcmd>>=
/*
 *	perform the 'r' and 'u' commands
 */
void
rcmd(char *arname, int count, char **files)
{
    int fd;
    int i;
    Arfile *ap;
    Armember *bp;
    Dir *d;
    Biobuf *bfile;

    fd = openar(arname, ORDWR, 1);
    if (fd >= 0) {
        Binit(&bar, fd, OREAD);
        Bseek(&bar,seek(fd,0,1), 1);
    }
    astart = newtempfile(artemp);
    ap = astart;
    aend = 0;
    for(i = 0; fd >= 0; i++) {
        bp = getdir(&bar);
        if (!bp)
            break;
        if (bamatch(file, poname)) {		/* check for pivot */
            aend = newtempfile(tailtemp);
            ap = aend;
        }
            /* pitch symdef file */
        if (i == 0 && strcmp(file, symdef) == 0) {
            skip(&bar, bp->size);
            continue;
        }
        if (count && !match(count, files)) {
            scanobj(&bar, ap, bp->size);
            arcopy(&bar, ap, bp);
            continue;
        }
        bfile = Bopen(file, OREAD);
        if (!bfile) {
            if (count != 0)
                fprint(2, "ar: cannot open %s\n", file);
            scanobj(&bar, ap, bp->size);
            arcopy(&bar, ap, bp);
            continue;
        }
        d = dirfstat(Bfildes(bfile));
        if(d == nil)
            fprint(2, "ar: cannot stat %s: %r\n", file);
        if (uflag && (d==nil || d->mtime <= bp->date)) {
            scanobj(&bar, ap, bp->size);
            arcopy(&bar, ap, bp);
            Bterm(bfile);
            free(d);
            continue;
        }
        mesg('r', file);
        skip(&bar, bp->size);
        scanobj(bfile, ap, d->length);
        free(d);
        armove(bfile, ap, bp);
        Bterm(bfile);
    }
    if(fd >= 0)
        close(fd);
        /* copy in remaining files named on command line */
    for (i = 0; i < count; i++) {
        file = files[i];
        if(file == 0)
            continue;
        files[i] = 0;
        bfile = Bopen(file, OREAD);
        if (!bfile)
            fprint(2, "ar: %s cannot open\n", file);
        else {
            mesg('a', file);
            d = dirfstat(Bfildes(bfile));
            if (d == nil)
                fprint(2, "can't stat %s\n", file);
            else {
                scanobj(bfile, astart, d->length);
                armove(bfile, astart, newmember());
                free(d);
            }
            Bterm(bfile);
        }
    }
    if(fd < 0 && !cflag)
        install(arname, astart, 0, aend, 1);	/* issue 'creating' msg */
    else
        install(arname, astart, 0, aend, 0);
}
@

<<function dcmd>>=
void
dcmd(char *arname, int count, char **files)
{
    Armember *bp;
    int fd, i;

    if (!count)
        return;
    fd = openar(arname, ORDWR, 0);
    Binit(&bar, fd, OREAD);
    Bseek(&bar,seek(fd,0,1), 1);
    astart = newtempfile(artemp);
    for (i = 0; bp = getdir(&bar); i++) {
        if(match(count, files)) {
            mesg('d', file);
            skip(&bar, bp->size);
            if (strcmp(file, symdef) == 0)
                allobj = 0;
        } else if (i == 0 && strcmp(file, symdef) == 0)
                skip(&bar, bp->size);
        else {
            scanobj(&bar, astart, bp->size);
            arcopy(&bar, astart, bp);
        }
    }
    close(fd);
    install(arname, astart, 0, 0, 0);
}
@

<<function xcmd>>=
void
xcmd(char *arname, int count, char **files)
{
    int fd, f, mode, i;
    Armember *bp;
    Dir dx;

    fd = openar(arname, OREAD, 0);
    Binit(&bar, fd, OREAD);
    Bseek(&bar,seek(fd,0,1), 1);
    i = 0;
    while (bp = getdir(&bar)) {
        if(count == 0 || match(count, files)) {
            mode = strtoul(bp->hdr.mode, 0, 8) & 0777;
            f = create(file, OWRITE, mode);
            if(f < 0) {
                fprint(2, "ar: %s cannot create\n", file);
                skip(&bar, bp->size);
            } else {
                mesg('x', file);
                arcopy(&bar, 0, bp);
                if (write(f, bp->member, bp->size) < 0)
                    wrerr();
                if(oflag) {
                    nulldir(&dx);
                    dx.atime = bp->date;
                    dx.mtime = bp->date;
                    if(dirwstat(file, &dx) < 0)
                        perror(file);
                }
                free(bp->member);
                close(f);
            }
            free(bp);
            if (count && ++i >= count)
                break;
        } else {
            skip(&bar, bp->size);
            free(bp);
        }
    }
    close(fd);
}
@

<<function pcmd>>=
void
pcmd(char *arname, int count, char **files)
{
    int fd;
    Armember *bp;

    fd = openar(arname, OREAD, 0);
    Binit(&bar, fd, OREAD);
    Bseek(&bar,seek(fd,0,1), 1);
    while(bp = getdir(&bar)) {
        if(count == 0 || match(count, files)) {
            if(vflag)
                print("\n<%s>\n\n", file);
            arcopy(&bar, 0, bp);
            if (write(1, bp->member, bp->size) < 0)
                wrerr();
        } else
            skip(&bar, bp->size);
        free(bp);
    }
    close(fd);
}
@

<<function mcmd>>=
void
mcmd(char *arname, int count, char **files)
{
    int fd, i;
    Arfile *ap;
    Armember *bp;

    if (count == 0)
        return;
    fd = openar(arname, ORDWR, 0);
    Binit(&bar, fd, OREAD);
    Bseek(&bar,seek(fd,0,1), 1);
    astart = newtempfile(artemp);
    amiddle = newtempfile(movtemp);
    aend = 0;
    ap = astart;
    for (i = 0; bp = getdir(&bar); i++) {
        if (bamatch(file, poname)) {
            aend = newtempfile(tailtemp);
            ap = aend;
        }
        if(match(count, files)) {
            mesg('m', file);
            scanobj(&bar, amiddle, bp->size);
            arcopy(&bar, amiddle, bp);
        } else
            /*
             * pitch the symdef file if it is at the beginning
             * of the archive and we aren't inserting in front
             * of it (ap == astart).
             */
        if (ap == astart && i == 0 && strcmp(file, symdef) == 0)
            skip(&bar, bp->size);
        else {
            scanobj(&bar, ap, bp->size);
            arcopy(&bar, ap, bp);
        }
    }
    close(fd);
    if (poname[0] && aend == 0)
        fprint(2, "ar: %s not found - files moved to end.\n", poname);
    install(arname, astart, amiddle, aend, 0);
}
@

<<function tcmd>>=
void
tcmd(char *arname, int count, char **files)
{
    int fd;
    Armember *bp;
    char name[ARNAMESIZE+1];

    fd = openar(arname, OREAD, 0);
    Binit(&bar, fd, OREAD);
    Bseek(&bar,seek(fd,0,1), 1);
    while(bp = getdir(&bar)) {
        if(count == 0 || match(count, files)) {
            if(vflag)
                longt(bp);
            trim(file, name, ARNAMESIZE);
            Bprint(&bout, "%s\n", name);
        }
        skip(&bar, bp->size);
        free(bp);
    }
    close(fd);
}
@

<<function qcmd>>=
void
qcmd(char *arname, int count, char **files)
{
    int fd, i;
    Armember *bp;
    Biobuf *bfile;

    if(aflag || bflag) {
        fprint(2, "ar: abi not allowed with q\n");
        exits("error");
    }
    fd = openar(arname, ORDWR, 1);
    if (fd < 0) {
        if(!cflag)
            fprint(2, "ar: creating %s\n", arname);
        fd = arcreate(arname);
    }
    Binit(&bar, fd, OREAD);
    Bseek(&bar,seek(fd,0,1), 1);
    /* leave note group behind when writing archive; i.e. sidestep interrupts */
    rfork(RFNOTEG);
    Bseek(&bar, 0, 2);
    bp = newmember();
    for(i=0; i<count && files[i]; i++) {
        file = files[i];
        files[i] = 0;
        bfile = Bopen(file, OREAD);
        if(!bfile)
            fprint(2, "ar: %s cannot open\n", file);
        else {
            mesg('q', file);
            armove(bfile, 0, bp);
            if (!arwrite(fd, bp))
                wrerr();
            free(bp->member);
            bp->member = 0;
            Bterm(bfile);
        }
    }
    free(bp);
    close(fd);
}
@

<<function scanobj>>=
/*
 *	extract the symbol references from an object file
 */
void
scanobj(Biobuf *b, Arfile *ap, long size)
{
    int obj;
    vlong offset;
    Dir *d;
    static int lastobj = -1;

    if (!allobj)			/* non-object file encountered */
        return;
    offset = Boffset(b);
    obj = objtype(b, 0);
    if (obj < 0) {			/* not an object file */
        allobj = 0;
        d = dirfstat(Bfildes(b));
        if (d != nil && d->length == 0)
            fprint(2, "ar: zero length file %s\n", file);
        free(d);
        Bseek(b, offset, 0);
        return;
    }
    if (lastobj >= 0 && obj != lastobj) {
        fprint(2, "ar: inconsistent object file %s\n", file);
        allobj = 0;
        Bseek(b, offset, 0);
        return;
    }
    lastobj = obj;
    if (!readar(b, obj, offset+size, 0)) {
        fprint(2, "ar: invalid symbol reference in file %s\n", file);
        allobj = 0;
        Bseek(b, offset, 0);
        return;
    }
    Bseek(b, offset, 0);
    objtraverse(objsym, ap);
}
@

<<function objsym>>=
/*
 *	add text and data symbols to the symbol list
 */
void
objsym(Sym *s, void *p)
{
    int n;
    Arsymref *as;
    Arfile *ap;

    if (s->type != 'T' &&  s->type != 'D')
        return;
    ap = (Arfile*)p;
    as = (Arsymref*)armalloc(sizeof(Arsymref));
    as->offset = ap->size;
    n = strlen(s->name);
    as->name = armalloc(n+1);
    strcpy(as->name, s->name);
    if(s->type == 'T' && duplicate(as->name)) {
        dupfound = 1;
        fprint(2, "duplicate text symbol: %s\n", as->name);
        free(as->name);
        free(as);
        return;
    }
    as->type = s->type;
    symdefsize += 4+(n+1)+1;
    as->len = n;
    as->next = ap->sym;
    ap->sym = as;
}
@

<<function duplicate>>=
/*
 *	Check the symbol table for duplicate text symbols
 */
int
duplicate(char *name)
{
    Hashchain *p;
    char *cp;
    int h;

    h = 0;
    for(cp = name; *cp; h += *cp++)
        h *= 1119;
    if(h < 0)
        h = ~h;
    h %= NHASH;

    for(p = hash[h]; p; p = p->next)
        if(strcmp(p->name, name) == 0)
            return 1;
    p = (Hashchain*) armalloc(sizeof(Hashchain));
    p->next = hash[h];
    p->name = name;
    hash[h] = p;
    return 0;
}
@

<<function openar>>=
/*
 *	open an archive and validate its header
 */
int
openar(char *arname, int mode, int errok)
{
    int fd;
    char mbuf[SARMAG];

    fd = open(arname, mode);
    if(fd >= 0){
        if(read(fd, mbuf, SARMAG) != SARMAG || strncmp(mbuf, ARMAG, SARMAG)) {
            fprint(2, "ar: %s not in archive format\n", arname);
            exits("error");
        }
    }else if(!errok){
        fprint(2, "ar: cannot open %s: %r\n", arname);
        exits("error");
    }
    return fd;
}
@

<<function arcreate>>=
/*
 *	create an archive and set its header
 */
int
arcreate(char *arname)
{
    int fd;

    fd = create(arname, OWRITE, 0664);
    if(fd < 0){
        fprint(2, "ar: cannot create %s: %r\n", arname);
        exits("error");
    }
    if(write(fd, ARMAG, SARMAG) != SARMAG)
        wrerr();
    return fd;
}
@

<<function wrerr>>=
/*
 *		error handling
 */
void
wrerr(void)
{
    perror("ar: write error");
    exits("error");
}
@

<<function rderr>>=
void
rderr(void)
{
    perror("ar: read error");
    exits("error");
}
@

<<function phaseerr>>=
void
phaseerr(int offset)
{
    fprint(2, "ar: phase error at offset %d\n", offset);
    exits("error");
}
@

<<function usage>>=
static void
usage(void)
{
    fprint(2, "usage: ar [%s][%s] archive files ...\n", opt, man);
    exits("error");
}
@

<<function getdir>>=
/*
 *	read the header for the next archive member
 */
Armember *
getdir(Biobuf *b)
{
    Armember *bp;
    char *cp;
    static char name[ARNAMESIZE+1];

    bp = newmember();
    if(HEADER_IO(Bread, b, bp->hdr)) {
        free(bp);
        return 0;
    }
    if(strncmp(bp->hdr.fmag, ARFMAG, sizeof(bp->hdr.fmag)) != 0)
        phaseerr(Boffset(b));
    strncpy(name, bp->hdr.name, sizeof(bp->hdr.name));
    cp = name+sizeof(name)-1;
    *cp = '\0';
    /* skip trailing spaces and (gnu-produced) slashes */
    while(*--cp == ' ' || *cp == '/')
        ;
    cp[1] = '\0';
    file = name;
    bp->date = strtol(bp->hdr.date, 0, 0);
    bp->size = strtol(bp->hdr.size, 0, 0);
    return bp;
}
@

<<function armove>>=
/*
 *	Copy the file referenced by fd to the temp file
 */
void
armove(Biobuf *b, Arfile *ap, Armember *bp)
{
    char *cp;
    Dir *d;

    d = dirfstat(Bfildes(b));
    if (d == nil) {
        fprint(2, "ar: cannot stat %s\n", file);
        return;
    }
    trim(file, bp->hdr.name, sizeof(bp->hdr.name));
    for (cp = strchr(bp->hdr.name, 0);		/* blank pad on right */
        cp < bp->hdr.name+sizeof(bp->hdr.name); cp++)
            *cp = ' ';
    sprint(bp->hdr.date, "%-12ld", d->mtime);
    sprint(bp->hdr.uid, "%-6d", 0);
    sprint(bp->hdr.gid, "%-6d", 0);
    sprint(bp->hdr.mode, "%-8lo", d->mode);
    sprint(bp->hdr.size, "%-10lld", d->length);
    strncpy(bp->hdr.fmag, ARFMAG, 2);
    bp->size = d->length;
    arread(b, bp, bp->size);
    if (d->length&0x01)
        d->length++;
    if (ap) {
        arinsert(ap, bp);
        ap->size += d->length+SAR_HDR;
    }
    free(d);
}
@

<<function arcopy>>=
/*
 *	Copy the archive member at the current offset into the temp file.
 */
void
arcopy(Biobuf *b, Arfile *ap, Armember *bp)
{
    long n;

    n = bp->size;
    if (n & 01)
        n++;
    arread(b, bp, n);
    if (ap) {
        arinsert(ap, bp);
        ap->size += n+SAR_HDR;
    }
}
@

<<function skip>>=
/*
 *	Skip an archive member
 */
void
skip(Biobuf *bp, vlong len)
{
    if (len & 01)
        len++;
    Bseek(bp, len, 1);
}
@

<<function install>>=
/*
 *	Stream the three temp files to an archive
 */
void
install(char *arname, Arfile *astart, Arfile *amiddle, Arfile *aend, int createflag)
{
    int fd;

    if(allobj && dupfound) {
        fprint(2, "%s not changed\n", arname);
        return;
    }
    /* leave note group behind when copying back; i.e. sidestep interrupts */
    rfork(RFNOTEG);

    if(createflag)
        fprint(2, "ar: creating %s\n", arname);
    fd = arcreate(arname);

    if(allobj)
        rl(fd);

    if (astart) {
        arstream(fd, astart);
        arfree(astart);
    }
    if (amiddle) {
        arstream(fd, amiddle);
        arfree(amiddle);
    }
    if (aend) {
        arstream(fd, aend);
        arfree(aend);
    }
    close(fd);
}
@

<<function rl>>=
void
rl(int fd)
{

    Biobuf b;
    char *cp;
    struct ar_hdr a;
    long len;

    Binit(&b, fd, OWRITE);
    Bseek(&b,seek(fd,0,1), 0);

    len = symdefsize;
    if(len&01)
        len++;
    sprint(a.date, "%-12ld", time(0));
    sprint(a.uid, "%-6d", 0);
    sprint(a.gid, "%-6d", 0);
    sprint(a.mode, "%-8lo", 0644L);
    sprint(a.size, "%-10ld", len);
    strncpy(a.fmag, ARFMAG, 2);
    strcpy(a.name, symdef);
    for (cp = strchr(a.name, 0);		/* blank pad on right */
        cp < a.name+sizeof(a.name); cp++)
            *cp = ' ';
    if(HEADER_IO(Bwrite, &b, a))
            wrerr();

    len += Boffset(&b);
    if (astart) {
        wrsym(&b, len, astart->sym);
        len += astart->size;
    }
    if(amiddle) {
        wrsym(&b, len, amiddle->sym);
        len += amiddle->size;
    }
    if(aend)
        wrsym(&b, len, aend->sym);

    if(symdefsize&0x01)
        Bputc(&b, 0);
    Bterm(&b);
}
@

<<function wrsym>>=
/*
 *	Write the defined symbols to the symdef file
 */
void
wrsym(Biobuf *bp, long offset, Arsymref *as)
{
    int off;

    while(as) {
        Bputc(bp, as->type);
        off = as->offset+offset;
        Bputc(bp, off);
        Bputc(bp, off>>8);
        Bputc(bp, off>>16);
        Bputc(bp, off>>24);
        if (Bwrite(bp, as->name, as->len+1) != as->len+1)
            wrerr();
        as = as->next;
    }
}
@

<<function match>>=
/*
 *	Check if the archive member matches an entry on the command line.
 */
int
match(int count, char **files)
{
    int i;
    char name[ARNAMESIZE+1];

    for(i=0; i<count; i++) {
        if(files[i] == 0)
            continue;
        trim(files[i], name, ARNAMESIZE);
        if(strncmp(name, file, ARNAMESIZE) == 0) {
            file = files[i];
            files[i] = 0;
            return 1;
        }
    }
    return 0;
}
@

<<function bamatch>>=
/*
 *	compare the current member to the name of the pivot member
 */
int
bamatch(char *file, char *pivot)
{
    static int state = 0;

    switch(state)
    {
    case 0:			/* looking for position file */
        if (aflag) {
            if (strncmp(file, pivot, ARNAMESIZE) == 0)
                state = 1;
        } else if (bflag) {
            if (strncmp(file, pivot, ARNAMESIZE) == 0) {
                state = 2;	/* found */
                return 1;
            }
        }
        break;
    case 1:			/* found - after previous file */
        state = 2;
        return 1;
    case 2:			/* already found position file */
        break;
    }
    return 0;
}
@

<<function mesg>>=
/*
 *	output a message, if 'v' option was specified
 */
void
mesg(int c, char *file)
{

    if(vflag)
        Bprint(&bout, "%c - %s\n", c, file);
}
@

<<function trim>>=
/*
 *	isolate file name by stripping leading directories and trailing slashes
 */
void
trim(char *s, char *buf, int n)
{
    char *p;

    for(;;) {
        p = strrchr(s, '/');
        if (!p) {		/* no slash in name */
            strncpy(buf, s, n);
            return;
        }
        if (p[1] != 0) {	/* p+1 is first char of file name */
            strncpy(buf, p+1, n);
            return;
        }
        *p = 0;			/* strip trailing slash */
    }
}
@

<<constant SUID>>=
/*
 *	utilities for printing long form of 't' command
 */
#define	SUID	04000
@

<<constant SGID>>=
#define	SGID	02000
@

<<constant ROWN>>=
#define	ROWN	0400
@

<<constant WOWN>>=
#define	WOWN	0200
@

<<constant XOWN>>=
#define	XOWN	0100
@

<<constant RGRP>>=
#define	RGRP	040
@

<<constant WGRP>>=
#define	WGRP	020
@

<<constant XGRP>>=
#define	XGRP	010
@

<<constant ROTH>>=
#define	ROTH	04
@

<<constant WOTH>>=
#define	WOTH	02
@

<<constant XOTH>>=
#define	XOTH	01
@

<<constant STXT>>=
#define	STXT	01000
@

<<function longt>>=
void
longt(Armember *bp)
{
    char *cp;

    pmode(strtoul(bp->hdr.mode, 0, 8));
    Bprint(&bout, "%3ld/%1ld", strtol(bp->hdr.uid, 0, 0), strtol(bp->hdr.gid, 0, 0));
    Bprint(&bout, "%7ld", bp->size);
    cp = ctime(bp->date);
    Bprint(&bout, " %-12.12s %-4.4s ", cp+4, cp+24);
}
@

<<global m1>>=
int	m1[] = { 1, ROWN, 'r', '-' };
@

<<global m2>>=
int	m2[] = { 1, WOWN, 'w', '-' };
@

<<global m3>>=
int	m3[] = { 2, SUID, 's', XOWN, 'x', '-' };
@

<<global m4>>=
int	m4[] = { 1, RGRP, 'r', '-' };
@

<<global m5>>=
int	m5[] = { 1, WGRP, 'w', '-' };
@

<<global m6>>=
int	m6[] = { 2, SGID, 's', XGRP, 'x', '-' };
@

<<global m7>>=
int	m7[] = { 1, ROTH, 'r', '-' };
@

<<global m8>>=
int	m8[] = { 1, WOTH, 'w', '-' };
@

<<global m9>>=
int	m9[] = { 2, STXT, 't', XOTH, 'x', '-' };
@

<<global m>>=
int	*m[] = { m1, m2, m3, m4, m5, m6, m7, m8, m9};
@

<<function pmode>>=
void
pmode(long mode)
{
    int **mp;

    for(mp = &m[0]; mp < &m[9];)
        select(*mp++, mode);
}
@

<<function select>>=
void
select(int *ap, long mode)
{
    int n;

    n = *ap++;
    while(--n>=0 && (mode & (*ap++))==0)
        ap++;
    Bputc(&bout, *ap);
}
@

<<function newtempfile>>=
/*
 *	Temp file I/O subsystem.  We attempt to cache all three temp files in
 *	core.  When we run out of memory we spill to disk.
 *	The I/O model assumes that temp files:
 *		1) are only written on the end
 *		2) are only read from the beginning
 *		3) are only read after all writing is complete.
 *	The architecture uses one control block per temp file.  Each control
 *	block anchors a chain of buffers, each containing an archive member.
 */
Arfile *
newtempfile(char *name)		/* allocate a file control block */
{
    Arfile *ap;

    ap = (Arfile *) armalloc(sizeof(Arfile));
    ap->fname = name;
    return ap;
}
@

<<function newmember>>=
Armember *
newmember(void)			/* allocate a member buffer */
{
    return (Armember *)armalloc(sizeof(Armember));
}
@

<<function arread>>=
void
arread(Biobuf *b, Armember *bp, int n)	/* read an image into a member buffer */
{
    int i;

    bp->member = armalloc(n);
    i = Bread(b, bp->member, n);
    if (i < 0) {
        free(bp->member);
        bp->member = 0;
        rderr();
    }
}
@

<<function arinsert>>=
/*
 * insert a member buffer into the member chain
 */
void
arinsert(Arfile *ap, Armember *bp)
{
    bp->next = 0;
    if (!ap->tail)
        ap->head = bp;
    else
        ap->tail->next = bp;
    ap->tail = bp;
}
@

<<function arstream>>=
/*
 *	stream the members in a temp file to the file referenced by 'fd'.
 */
void
arstream(int fd, Arfile *ap)
{
    Armember *bp;
    int i;
    char buf[8192];

    if (ap->paged) {		/* copy from disk */
        seek(ap->fd, 0, 0);
        for (;;) {
            i = read(ap->fd, buf, sizeof(buf));
            if (i < 0)
                rderr();
            if (i == 0)
                break;
            if (write(fd, buf, i) != i)
                wrerr();
        }
        close(ap->fd);
        ap->paged = 0;
    }
        /* dump the in-core buffers */
    for (bp = ap->head; bp; bp = bp->next) {
        if (!arwrite(fd, bp))
            wrerr();
    }
}
@

<<function arwrite>>=
/*
 *	write a member to 'fd'.
 */
int
arwrite(int fd, Armember *bp)
{
    int len;

    if(HEADER_IO(write, fd, bp->hdr))
        return 0;
    len = bp->size;
    if (len & 01)
        len++;
    if (write(fd, bp->member, len) != len)
        return 0;
    return 1;
}
@

<<function page>>=
/*
 *	Spill a member to a disk copy of a temp file
 */
int
page(Arfile *ap)
{
    Armember *bp;

    bp = ap->head;
    if (!ap->paged) {		/* not yet paged - create file */
        ap->fname = mktemp(ap->fname);
        ap->fd = create(ap->fname, ORDWR|ORCLOSE, 0600);
        if (ap->fd < 0) {
            fprint(2,"ar: can't create temp file\n");
            return 0;
        }
        ap->paged = 1;
    }
    if (!arwrite(ap->fd, bp))	/* write member and free buffer block */
        return 0;
    ap->head = bp->next;
    if (ap->tail == bp)
        ap->tail = bp->next;
    free(bp->member);
    free(bp);
    return 1;
}
@

<<function getspace>>=
/*
 *	try to reclaim space by paging.  we try to spill the start, middle,
 *	and end files, in that order.  there is no particular reason for the
 *	ordering.
 */
int
getspace(void)
{
    if (astart && astart->head && page(astart))
            return 1;
    if (amiddle && amiddle->head && page(amiddle))
            return 1;
    if (aend && aend->head && page(aend))
            return 1;
    return 0;
}
@

<<function arfree>>=
void
arfree(Arfile *ap)		/* free a member buffer */
{
    Armember *bp, *next;

    for (bp = ap->head; bp; bp = next) {
        next = bp->next;
        if (bp->member)
            free(bp->member);
        free(bp);
    }
    free(ap);
}
@

<<function armalloc>>=
/*
 *	allocate space for a control block or member buffer.  if the malloc
 *	fails we try to reclaim space by spilling previously allocated
 *	member buffers.
 */
char *
armalloc(int n)
{
    char *cp;

    do {
        cp = malloc(n);
        if (cp) {
            memset(cp, 0, n);
            return cp;
        }
    } while (getspace());
    fprint(2, "ar: out of memory\n");
    exits("malloc");
    return 0;
}
@


%-------------------------------------------------------------

<<linkers/misc/ar.c>>=
/*
 * ar - portable (ascii) format version
 */
#include <u.h>
#include <libc.h>
#include <bio.h>
#include <mach.h>
#include <ar.h>

/*
 *	The algorithm uses up to 3 temp files.  The "pivot member" is the
 *	archive member specified by and a, b, or i option.  The temp files are
 *	astart - contains existing members up to and including the pivot member.
 *	amiddle - contains new files moved or inserted behind the pivot.
 *	aend - contains the existing members that follow the pivot member.
 *	When all members have been processed, function 'install' streams the
 * 	temp files, in order, back into the archive.
 */

<<struct Arsymref>>

<<struct Armember>>

<<struct Arfile>>

<<struct Hashchain>>

<<constant NHASH>>

<<function HEADER_IO>>

        /* constants and flags */
<<global man>>
<<global opt>>
<<global artemp>>
<<global movtemp>>
<<global tailtemp>>
<<global symdef>>

<<global aflag>>
<<global bflag>>
<<global cflag>>
<<global oflag>>
<<global uflag>>
<<global vflag>>

Arfile *astart, *amiddle, *aend;	/* Temp file control block pointers */
<<global allobj>>
<<global symdefsize>>
<<global dupfound>>
<<global hash>>
    
<<constant ARNAMESIZE>>

<<global poname>>
<<global file>>
<<global bout>>
<<global bar>>

void	arcopy(Biobuf*, Arfile*, Armember*);
int	arcreate(char*);
void	arfree(Arfile*);
void	arinsert(Arfile*, Armember*);
char	*armalloc(int);
void	armove(Biobuf*, Arfile*, Armember*);
void	arread(Biobuf*, Armember*, int);
void	arstream(int, Arfile*);
int	arwrite(int, Armember*);
int	bamatch(char*, char*);
int	duplicate(char*);
Armember *getdir(Biobuf*);
int	getspace(void);
void	install(char*, Arfile*, Arfile*, Arfile*, int);
void	longt(Armember*);
int	match(int, char**);
void	mesg(int, char*);
Arfile	*newtempfile(char*);
Armember *newmember(void);
void	objsym(Sym*, void*);
int	openar(char*, int, int);
int	page(Arfile*);
void	pmode(long);
void	rl(int);
void	scanobj(Biobuf*, Arfile*, long);
void	select(int*, long);
void	setcom(void(*)(char*, int, char**));
void	skip(Biobuf*, vlong);
int	symcomp(void*, void*);
void	trim(char*, char*, int);
static void	usage(void);
void	wrerr(void);
void	wrsym(Biobuf*, long, Arsymref*);

void	rcmd(char*, int, char**);		/* command processing */
void	dcmd(char*, int, char**);
void	xcmd(char*, int, char**);
void	tcmd(char*, int, char**);
void	pcmd(char*, int, char**);
void	mcmd(char*, int, char**);
void	qcmd(char*, int, char**);
<<global comfun>>

<<function main>>
<<function setcom>>
<<function rcmd>>

<<function dcmd>>

<<function xcmd>>
<<function pcmd>>
<<function mcmd>>
<<function tcmd>>
<<function qcmd>>

<<function scanobj>>

<<function objsym>>

<<function duplicate>>

<<function openar>>

<<function arcreate>>

<<function wrerr>>

<<function rderr>>

<<function phaseerr>>

<<function usage>>

<<function getdir>>

<<function armove>>

<<function arcopy>>

<<function skip>>

<<function install>>

<<function rl>>

<<function wrsym>>

<<function match>>

<<function bamatch>>

<<function mesg>>

<<function trim>>

<<constant SUID>>
<<constant SGID>>
<<constant ROWN>>
<<constant WOWN>>
<<constant XOWN>>
<<constant RGRP>>
<<constant WGRP>>
<<constant XGRP>>
<<constant ROTH>>
<<constant WOTH>>
<<constant XOTH>>
<<constant STXT>>

<<function longt>>

<<global m1>>
<<global m2>>
<<global m3>>
<<global m4>>
<<global m5>>
<<global m6>>
<<global m7>>
<<global m8>>
<<global m9>>

<<global m>>

<<function pmode>>

<<function select>>

<<function newtempfile>>

<<function newmember>>

<<function arread>>

<<function arinsert>>

<<function arstream>>

<<function arwrite>>

<<function page>>

<<function getspace>>

<<function arfree>>

<<function armalloc>>
@


\subsection*{[[linkers/misc/nm.c]]}

<<enum _anon_ (linkers/misc/nm.c)>>=
enum{
    CHUNK	=	256	/* must be power of 2 */
};
@

<<global errs>>=
static char	*errs;			/* exit status */
@

<<global filename>>=
static char	*filename;		/* current file */
@

<<global symname>>=
static char	symname[]="__.SYMDEF";	/* table of contents file name */
@

<<global multifile>>=
static int	multifile;		/* processing multiple files */
@

<<global aflag (linkers/misc/nm.c)>>=
static int	aflag;
@

<<global gflag>>=
static int	gflag;
@

<<global hflag>>=
static int	hflag;
@

<<global nflag>>=
static int	nflag;
@

<<global sflag>>=
static int	sflag;
@

<<global uflag (linkers/misc/nm.c)>>=
static int	uflag;
@

<<global Tflag>>=
static int	Tflag;
@

<<global fnames>>=
static Sym	**fnames;		/* file path translation table */
@

<<global symptr>>=
static Sym	**symptr;
@

<<global nsym>>=
static int	nsym;
@

<<global bout (linkers/misc/nm.c)>>=
static Biobuf	bout;
@

<<function usage (linkers/misc/nm.c)>>=
static void
usage(void)
{
    fprint(2, "usage: nm [-aghnsTu] file ...\n");
    exits("usage");
}
@

<<function main (linkers/misc/nm.c)>>=
void
main(int argc, char *argv[])
{
    int i;
    Biobuf	*bin;

    Binit(&bout, 1, OWRITE);
    argv0 = argv[0];
    ARGBEGIN {
    default:	usage();
    case 'a':	aflag = 1; break;
    case 'g':	gflag = 1; break;
    case 'h':	hflag = 1; break;
    case 'n':	nflag = 1; break;
    case 's':	sflag = 1; break;
    case 'u':	uflag = 1; break;
    case 'T':	Tflag = 1; break;
    } ARGEND
    if (argc == 0)
        usage();
    if (argc > 1)
        multifile++;
    for(i=0; i<argc; i++){
        filename = argv[i];
        bin = Bopen(filename, OREAD);
        if(bin == 0){
            error("cannot open %s", filename);
            continue;
        }
        if (isar(bin))
            doar(bin);
        else{
            Bseek(bin, 0, 0);
            dofile(bin);
        }
        Bterm(bin);
    }
    exits(errs);
}
@

<<function doar>>=
/*
 * read an archive file,
 * processing the symbols for each intermediate file in it.
 */
void
doar(Biobuf *bp)
{
    int offset, size, obj;
    char membername[SARNAME];

    multifile = 1;
    for (offset = Boffset(bp);;offset += size) {
        size = nextar(bp, offset, membername);
        if (size < 0) {
            error("phase error on ar header %ld", offset);
            return;
        }
        if (size == 0)
            return;
        if (strcmp(membername, symname) == 0)
            continue;
        obj = objtype(bp, 0);
        if (obj < 0) {
            error("inconsistent file %s in %s",
                    membername, filename);
            return;
        }
        if (!readar(bp, obj, offset+size, 1)) {
            error("invalid symbol reference in file %s",
                    membername);
            return;
        }
        filename = membername;
        nsym=0;
        objtraverse(psym, 0);
        printsyms(symptr, nsym);
    }
}
@

<<function dofile>>=
/*
 * process symbols in a file
 */
void
dofile(Biobuf *bp)
{
    int obj;

    obj = objtype(bp, 0);
    if (obj < 0)
        execsyms(Bfildes(bp));
    else
    if (readobj(bp, obj)) {
        nsym = 0;
        objtraverse(psym, 0);
        printsyms(symptr, nsym);
    }
}
@

<<function cmp>>=
/*
 * comparison routine for sorting the symbol table
 *	this screws up on 'z' records when aflag == 1
 */
int
cmp(void *vs, void *vt)
{
    Sym **s, **t;

    s = vs;
    t = vt;
    if(nflag)
        if((*s)->value < (*t)->value)
            return -1;
        else
            return (*s)->value > (*t)->value;
    return strcmp((*s)->name, (*t)->name);
}
@

<<function zenter>>=
/*
 * enter a symbol in the table of filename elements
 */
void
zenter(Sym *s)
{
    static int maxf = 0;

    if (s->value > maxf) {
        maxf = (s->value+CHUNK-1) &~ (CHUNK-1);
        fnames = realloc(fnames, (maxf+1)*sizeof(*fnames));
        if(fnames == 0) {
            error("out of memory", argv0);
            exits("memory");
        }
    }
    fnames[s->value] = s;
}
@

<<function execsyms>>=
/*
 * get the symbol table from an executable file, if it has one
 */
void
execsyms(int fd)
{
    Fhdr f;
    Sym *s;
    long n;

    seek(fd, 0, 0);
    if (crackhdr(fd, &f) == 0) {
        error("Can't read header for %s", filename);
        return;
    }
    if (syminit(fd, &f) < 0)
        return;
    s = symbase(&n);
    nsym = 0;
    while(n--)
        psym(s++, 0);

    printsyms(symptr, nsym);
}
@

<<function psym>>=
void
psym(Sym *s, void* p)
{
    USED(p);
    switch(s->type) {
    case 'T':
    case 'L':
    case 'D':
    case 'B':
        if (uflag)
            return;
        if (!aflag && ((s->name[0] == '.' || s->name[0] == '$')))
            return;
        break;
    case 'b':
    case 'd':
    case 'l':
    case 't':
        if (uflag || gflag)
            return;
        if (!aflag && ((s->name[0] == '.' || s->name[0] == '$')))
            return;
        break;
    case 'U':
        if (gflag)
            return;
        break;
    case 'Z':
        if (!aflag)
            return;
        break;
    case 'm':
    case 'f':	/* we only see a 'z' when the following is true*/
        if(!aflag || uflag || gflag)
            return;
        if (strcmp(s->name, ".frame"))
            zenter(s);
        break;
    case 'a':
    case 'p':
    case 'z':
    default:
        if(!aflag || uflag || gflag)
            return;
        break;
    }
    symptr = realloc(symptr, (nsym+1)*sizeof(Sym*));
    if (symptr == 0) {
        error("out of memory");
        exits("memory");
    }
    symptr[nsym++] = s;
}
@

<<function printsyms>>=
void
printsyms(Sym **symptr, long nsym)
{
    int i, wid;
    Sym *s;
    char *cp;
    char path[512];

    if(!sflag)
        qsort(symptr, nsym, sizeof(*symptr), cmp);
    
    wid = 0;
    for (i=0; i<nsym; i++) {
        s = symptr[i];
        if (s->value && wid == 0)
            wid = 8;
        else if (s->value >= 0x100000000LL && wid == 8)
            wid = 16;
    }	
    for (i=0; i<nsym; i++) {
        s = symptr[i];
        if (multifile && !hflag)
            Bprint(&bout, "%s:", filename);
        if (s->type == 'z') {
            fileelem(fnames, (uchar *) s->name, path, 512);
            cp = path;
        } else
            cp = s->name;
        if (Tflag)
            Bprint(&bout, "%8ux ", s->sig);
        if (s->value || s->type == 'a' || s->type == 'p')
            Bprint(&bout, "%*llux ", wid, s->value);
        else
            Bprint(&bout, "%*s ", wid, "");

        Bprint(&bout, "%c %s\n", s->type, cp);
    }
}
@

<<function error>>=
static void
error(char *fmt, ...)
{
    Fmt f;
    char buf[128];
    va_list arg;

    fmtfdinit(&f, 2, buf, sizeof buf);
    fmtprint(&f, "%s: ", argv0);
    va_start(arg, fmt);
    fmtvprint(&f, fmt, arg);
    va_end(arg);
    fmtprint(&f, "\n");
    fmtfdflush(&f);
    errs = "errors";
}
@


%-------------------------------------------------------------

<<linkers/misc/nm.c>>=
/*
 * nm.c -- drive nm
 */
#include <u.h>
#include <libc.h>
#include <ar.h>
#include <bio.h>
#include <mach.h>

<<enum _anon_ (linkers/misc/nm.c)>>

<<global errs>>
<<global filename>>
<<global symname>>
<<global multifile>>
<<global aflag (linkers/misc/nm.c)>>
<<global gflag>>
<<global hflag>>
<<global nflag>>
<<global sflag>>
<<global uflag (linkers/misc/nm.c)>>
<<global Tflag>>

<<global fnames>>
<<global symptr>>
<<global nsym>>
<<global bout (linkers/misc/nm.c)>>

int	cmp(void*, void*);
static void	error(char*, ...);
void	execsyms(int);
void	psym(Sym*, void*);
void	printsyms(Sym**, long);
void	doar(Biobuf*);
void	dofile(Biobuf*);
void	zenter(Sym*);

<<function usage (linkers/misc/nm.c)>>

<<function main (linkers/misc/nm.c)>>

<<function doar>>

<<function dofile>>

<<function cmp>>
<<function zenter>>

<<function execsyms>>

<<function psym>>

<<function printsyms>>

<<function error>>
@


\subsection*{[[linkers/misc/size.c]]}

%-------------------------------------------------------------

<<linkers/misc/size.c>>=
#include	<u.h>
#include	<libc.h>
#include	<bio.h>
#include	<mach.h>

<<function size>>

<<function main (linkers/misc/size.c)>>
@


\subsection*{[[linkers/misc/strip.c]]}

<<function error (linkers/misc/strip.c)>>=
void
error(char* fmt, ...)
{
    va_list arg;
    char *e, s[256];

    va_start(arg, fmt);
    e = seprint(s, s+sizeof(s), "%s: ", argv0);
    e = vseprint(e, s+sizeof(s), fmt, arg);
    e = seprint(e, s+sizeof(s), "\n");
    va_end(arg);

    write(2, s, e-s);
}
@

<<function usage (linkers/misc/strip.c)>>=
static void
usage(void)
{
    error("usage: %s -o ofile file\n\t%s file ...\n", argv0, argv0);
    exits("usage");
}
@

<<function strip>>=
static int
strip(char* file, char* out)
{
    Dir *dir;
    int fd, i;
    Fhdr fhdr;
    Exec *exec;
    ulong mode;
    void *data;
    vlong length;

    if((fd = open(file, OREAD)) < 0){
        error("%s: open: %r", file);
        return 1;
    }

    if(!crackhdr(fd, &fhdr)){
        error("%s: %r", file);
        close(fd);
        return 1;
    }
    for(i = MIN_MAGIC; i <= MAX_MAGIC; i++){
        if(fhdr.magic == _MAGIC(0, i) || fhdr.magic == _MAGIC(HDR_MAGIC, i))
            break;
    }
    if(i > MAX_MAGIC){
        error("%s: not a recognizeable binary", file);
        close(fd);
        return 1;
    }

    if((dir = dirfstat(fd)) == nil){
        error("%s: stat: %r", file);
        close(fd);
        return 1;
    }

    length = fhdr.datoff+fhdr.datsz;
    if(length == dir->length){
        if(out == nil){	/* nothing to do */
            error("%s: already stripped", file);
            free(dir);
            close(fd);
            return 0;
        }
    }
    if(length > dir->length){
        error("%s: strange length", file);
        close(fd);
        free(dir);
        return 1;
    }

    mode = dir->mode;
    free(dir);

    if((data = malloc(length)) == nil){
        error("%s: malloc failure", file);
        close(fd);
        return 1;
    }
    seek(fd, 0LL, 0);
    if(read(fd, data, length) != length){
        error("%s: read: %r", file);
        close(fd);
        free(data);
        return 1;
    }
    close(fd);

    exec = data;
    exec->syms = 0;
    exec->spsz = 0;
    exec->pcsz = 0;

    if(out == nil){
        if(remove(file) < 0) {
            error("%s: remove: %r", file);
            free(data);
            return 1;
        }
        out = file;
    }
    if((fd = create(out, OWRITE, mode)) < 0){
        error("%s: create: %r", out);
        free(data);
        return 1;
    }
    if(write(fd, data, length) != length){
        error("%s: write: %r", out);
        close(fd);
        free(data);
        return 1;
    }
    close(fd);
    free(data);

    return 0;
}
@

<<function main (linkers/misc/strip.c)>>=
void
main(int argc, char* argv[])
{
    int r;
    char *p;

    p = nil;

    ARGBEGIN{
    default:
        usage();
        break;
    case 'o':
        p = ARGF();
        if(p == nil)
            usage();
        break;
    }ARGEND;

    switch(argc){
    case 0:
        usage();
        return;
    case 1:
        if(p != nil){
            r = strip(*argv, p);
            break;
        }
        /*FALLTHROUGH*/
    default:
        r = 0;
        while(argc > 0){
            r |= strip(*argv, nil);
            argc--;
            argv++;
        }
        break;
    }

    if(r)
        exits("error");
    exits(0);
}
@


%-------------------------------------------------------------

<<linkers/misc/strip.c>>=
#include <u.h>
#include <libc.h>
#include <bio.h>
#include <mach.h>

<<function error (linkers/misc/strip.c)>>

<<function usage (linkers/misc/strip.c)>>

<<function strip>>

<<function main (linkers/misc/strip.c)>>
@

\section{[[linkers/5l/]]}

\subsection*{[[linkers/5l/l.h]]}

<<constant SIGNINTERN(arm)>>=
#define SIGNINTERN	(1729*325*1729)
@

%-------------------------------------------------------------

<<linkers/5l/l.h>>=
#include	<u.h>
#include	<libc.h>
#include	<bio.h>

#include	<common.out.h>
#include	<arm/5.out.h>
#include	"../8l/elf.h"

<<macro DBG>>

<<constant LIBNAMELEN>>

void	addlibpath(char*);
int	fileexists(char*);
char*	findlib(char*);

typedef	struct	Adr	Adr;
typedef	struct	Sym	Sym;
typedef	struct	Autom	Auto;
typedef	struct	Prog	Prog;
typedef	struct	Optab	Optab;
typedef	struct	Oprang	Oprang;
typedef	uchar	Opcross[32][2][32];
typedef	struct	Count	Count;

<<constant P>>
<<constant S>>
<<constant TNAME(arm)>>

<<struct Adr(arm)>>

<<constant offset>>
<<constant sval(arm)>>
<<constant ieee>>

<<constant autom>>
<<constant sym>>

<<struct Prog(arm)>>
<<constant regused(arm)>>
<<constant forwd(arm)>>

<<struct Sym>>

<<constant SIGNINTERN(arm)>>

<<struct Autom(arm)>>
<<struct Optab(arm)>>
<<struct Oprang(arm)>>
<<struct Count(arm)>>

<<enum sxxx(arm)>>
<<enum misc(arm)>>

<<enum rxxx>>

<<enum headtype(arm)>>

<<struct Buf>>
extern union Buf buf;

<<constant cbuf>>
<<constant xbuf>>

extern	long	HEADR;			/* length of header */
extern	long	HEADTYPE;		/* type of header */
extern	long	INITDAT;		/* data location */
extern	long	INITRND;		/* data round above text location */
extern	long	INITTEXT;		/* text location */
extern	long	INITTEXTP;		/* text location (physical) */
extern	char*	INITENTRY;		/* entry point */
extern	long	autosize;
extern	Biobuf	bso;
extern	long	bsssize;
extern	int	cbc;
extern	char*	cbp;
extern	int	cout;
extern	Auto*	curauto;
extern	Auto*	curhist;
extern	Prog*	curp;
extern	Prog*	curtext;
extern	Prog*	datap;
extern	long	datsize;
extern	bool	debug[128];
extern	Prog*	etextp;
extern	Prog*	firstp;
extern	char	fnuxi4[4];
extern	char	fnuxi8[8];
extern	char*	noname;
extern	Sym*	hash[NHASH];
extern	Sym*	histfrog[MAXHIST];
extern	int	histfrogp;
extern	int	histgen;
extern	char*	library[50];
extern	char*	libraryobj[50];
extern	int	libraryp;
extern	int	xrefresolv;
extern	char*	hunk;
extern	char	inuxi1[1];
extern	char	inuxi2[2];
extern	char	inuxi4[4];
extern	Prog*	lastp;
extern	long	lcsize;
extern	char	literal[32];
extern	int	nerrors;
extern	long	nhunk;
extern long	nsymbol;
extern	long	instoffset;
extern	Opcross	opcross[8];
extern	Oprang	oprange[ALAST];
extern	char*	outfile;
extern	long	pc;
extern	uchar	repop[ALAST];
extern	long	symsize;
extern	Prog*	textp;
extern	long	textsize;
extern	long	thunk;
extern	int	version;
extern	char	xcmp[C_GOK+1][C_GOK+1];
extern	Prog	zprg;
extern	int	dtype;
extern	int	armv4;
extern	int vfp;

extern	int	doexp, dlm;
extern	int	imports, nimports;
extern	int	exports, nexports;
extern	char*	EXPTAB;
extern	Prog	undefp;

<<constant UP>>

extern	char*	anames[];
extern	Optab	optab[];

void	addpool(Prog*, Adr*);
extern	Prog*	blitrl;
extern	Prog*	elitrl;

void	initdiv(void);
extern	Prog*	prog_div;
extern	Prog*	prog_divu;
extern	Prog*	prog_mod;
extern	Prog*	prog_modu;

#pragma	varargck	type	"A"	int
#pragma	varargck	type	"A"	uint
#pragma	varargck	type	"C"	int
#pragma	varargck	type	"D"	Adr*
#pragma	varargck	type	"N"	Adr*
#pragma	varargck	type	"P"	Prog*
#pragma	varargck	type	"S"	char*

#pragma	varargck	argpos	diag 1

int	Aconv(Fmt*);
int	Cconv(Fmt*);
int	Dconv(Fmt*);
int	Nconv(Fmt*);
int	Pconv(Fmt*);
int	Sconv(Fmt*);
int	aclass(Adr*);
void	addhist(long, int);
void	addlibpath(char*);
void	append(Prog*, Prog*);
void	asmb(void);
void	asmdyn(void);
void	asmlc(void);
void	asmout(Prog*, Optab*);
void	asmsym(void);
long	atolwhex(char*);
Prog*	brloop(Prog*);
void	buildop(void);
void	buildrep(int, int);
void	cflush(void);
void	ckoff(Sym*, long);
int	chipfloat(Ieee*);
int	cmp(int, int);
int	compound(Prog*);
double	cputime(void);
void	datblk(long, long, int);
void	diag(char*, ...);
void	divsig(void);
void	dodata(void);
void	doprof1(void);
void	doprof2(void);
void	dynreloc(Sym*, long, int);
long	entryvalue(void);
void	errorexit(void);
void	exchange(Prog*);
void	export(void);
int	fileexists(char*);
int	find1(long, int);
char*	findlib(char*);
void	follow(void);
void	gethunk(void);
void	histtoauto(void);
double	ieeedtod(Ieee*);
long	ieeedtof(Ieee*);
void	import(void);
int	isnop(Prog*);
void	ldobj(int, long, char*);
void	loadlib(void);
void	listinit(void);
Sym*	lookup(char*, int);
void	cput(int);
void	llput(vlong);
void	llputl(vlong);
void	lput(long);
void	lputl(long);
void	mkfwd(void);
void*	mysbrk(ulong);
void	names(void);
void	nocache(Prog*);
void	nuxiinit(void);
void	objfile(char*);
int	ocmp(const void*, const void*);
long	opirr(int);
Optab*	oplook(Prog*);
long	oprrr(int, int);
long	opvfprrr(int, int);
long	olr(long, int, int, int);
long	olhr(long, int, int, int);
long	olrr(int, int, int, int);
long	olhrr(int, int, int, int);
long	osr(int, int, long, int, int);
long	oshr(int, long, int, int);
long	ofsr(int, int, long, int, int, Prog*);
long	osrr(int, int, int, int);
long	oshrr(int, int, int, int);
long	omvl(Prog*, Adr*, int);
void	patch(void);
void	prasm(Prog*);
void	prepend(Prog*, Prog*);
Prog*	prg(void);
int	pseudo(Prog*);
void	putsymb(char*, int, long, int);
void	readundefs(char*, int);
long	regoff(Adr*);
int	relinv(int);
long	rnd(long, long);
void	span(void);
void	strnput(char*, int);
void	undef(void);
void	undefsym(Sym*);
void	wput(long);
void	wputl(long);
void	xdefine(char*, int, long);
void	xfol(Prog*);
void	zerosig(char*);
void	noops(void);
long	immrot(ulong);
long	immaddr(long);
long	opbra(int, int);

void mylog(char*, ...);

@


\subsection*{[[linkers/5l/globals.c]]}



<<global literal(arm)>>=
char	literal[32];
@



<<global instoffset(arm)>>=
long	instoffset;
@

<<global opcross(arm)>>=
Opcross	opcross[8];
@

<<global oprange(arm)>>=
Oprang	oprange[ALAST];
@


<<global repop(arm)>>=
uchar	repop[ALAST];
@




<<global xcmp(arm)>>=
char	xcmp[C_GOK+1][C_GOK+1];
@





<<global armv4(arm)>>=
int	armv4;
@


<<global vfp(arm)>>=
int vfp;
@










<<global blitrl(arm)>>=
Prog*	blitrl;
@

<<global elitrl(arm)>>=
Prog*	elitrl;
@

<<global prog_div(arm)>>=
Prog*	prog_div;
@

<<global prog_divu(arm)>>=
Prog*	prog_divu;
@

<<global prog_mod(arm)>>=
Prog*	prog_mod;
@

<<global prog_modu(arm)>>=
Prog*	prog_modu;
@


%-------------------------------------------------------------

<<linkers/5l/globals.c>>=
#include	"l.h"

<<global buf>>


<<global HEADR>>
<<global HEADTYPE>>
<<global INITDAT>>
<<global INITRND>>
<<global INITTEXT>>
<<global INITTEXTP>>
<<global INITENTRY>>

<<global autosize(arm)>>
<<global bso>>
<<global bsssize>>

<<global cbc>>
<<global cbp>>

<<global cout>>
<<global curauto>>
<<global curhist>>
<<global curp>>
<<global curtext>>
<<global datap>>
<<global datsize>>
<<global debug>>
<<global etextp>>
<<global firstp>>

<<global fnuxi4>>
<<global fnuxi8>>

<<global hash linker>>

<<global histfrog>>
<<global histfrogp>>
<<global histgen>>

<<global library>>
<<global libraryobj>>
<<global libraryp>>

<<global xrefresolv>>
<<global hunk>>

<<global inuxi1>>
<<global inuxi2>>
<<global inuxi4>>

<<global lastp>>
<<global lcsize>>
<<global literal(arm)>>
<<global nerrors>>
<<global nhunk>>
<<global nsymbol linker>>
<<global instoffset(arm)>>
<<global opcross(arm)>>
<<global oprange(arm)>>
<<global outfile>>
<<global pc>>
<<global repop(arm)>>
<<global symsize>>
<<global textp>>
<<global textsize>>
<<global thunk>>
<<global version>>
<<global xcmp(arm)>>
<<global zprg>>
<<global dtype(arm)>>
<<global armv4(arm)>>
<<global vfp(arm)>>

<<global doexp>>
<<global dlm>>

<<global imports>>
<<global nimports>>
<<global exports>>
<<global nexports>>
<<global EXPTAB>>
<<global undefp>>

<<global blitrl(arm)>>
<<global elitrl(arm)>>

<<global prog_div(arm)>>
<<global prog_divu(arm)>>
<<global prog_mod(arm)>>
<<global prog_modu(arm)>>
@

\subsection*{[[linkers/5l/optab.c]]}

%-------------------------------------------------------------

<<linkers/5l/optab.c>>=
#include	"l.h"

<<global optab (linkers/5l/optab.c)(arm)>>
@


\subsection*{[[linkers/5l/utils.c]]}

<<linkers/5l/utils.c>>=
#include "l.h"

<<function log>>

<<function errorexit>>

<<function gethunk>>

<<function lookup>>

<<constructor prg>>

<<function copyp>>

@
\subsection*{[[linkers/5l/list.c]]}

%-------------------------------------------------------------

<<linkers/5l/list.c>>=
#include "l.h"

<<function listinit(arm)>>

<<function prasm(arm)>>

<<function Pconv(arm)>>

<<function Aconv(arm)>>

<<global strcond(arm)>>

<<function Cconv(arm)>>

<<function Dconv(arm)>>

<<function Nconv(arm)>>

<<function Sconv(arm)>>

<<function diag>>
@

\subsection*{[[linkers/5l/compat.c]]}


%-------------------------------------------------------------

<<linkers/5l/compat.c>>=
#include	"l.h"

<<function malloc>>

<<function free>>

<<function setmalloctag>>

<<function fileexists>>
@


\subsection*{[[linkers/5l/pass.c]]}

%-------------------------------------------------------------

<<linkers/5l/pass.c>>=
#include	"l.h"

<<function dodata(arm)>>

<<function undef>>

<<function brchain(arm)>>

<<function relinv(arm)>>

<<function follow>>

<<function xfol(arm)>>

<<function patch(arm)>>

<<constant LOG>>
<<function mkfwd>>

<<function brloop(arm)>>

<<function atolwhex>>

<<function rnd>>

<<function import(arm)>>

<<function ckoff>>

<<function newdata(arm)>>

<<function export(arm)>>
@

\subsection*{[[linkers/5l/asm.c]]}


<<global PP(arm)>>=
static Prog *PP;
@


<<function nopstat(arm)>>=
void
nopstat(char *f, Count *c)
{
    if(c->outof)
    Bprint(&bso, "%s delay %ld/%ld (%.2f)\n", f,
        c->outof - c->count, c->outof,
        (double)(c->outof - c->count)/c->outof);
}
@



<<constant MINLC(arm)>>=
#define	MINLC	4
@


%-------------------------------------------------------------

<<linkers/5l/asm.c>>=
#include	"l.h"

<<constant Dbufslop>>

<<global OFFSET(arm)>>

<<global PP(arm)>>

<<function entryvalue(arm)>>

<<function asmb(arm)>>

<<function strnput(arm)>>

<<function cput(arm)>>

<<function wput(arm)>>

<<function wputl(arm)>>

<<function lput(arm)>>

<<function lputl(arm)>>

<<function llput>>

<<function llputl>>

<<function cflush>>

<<function nopstat(arm)>>

<<function asmsym(arm)>>

<<function putsymb>>

<<constant MINLC(arm)>>
<<function asmlc>>

<<function datblk(arm)>>

<<function asmout(arm)>>

<<function oprrr(arm)>>

<<function opvfprrr(arm)>>

<<function opbra(arm)>>

<<function olr(arm)>>

<<function olhr(arm)>>

<<function osr(arm)>>

<<function oshr(arm)>>
    

<<function osrr(arm)>>

<<function oshrr(arm)>>

<<function olrr(arm)>>

<<function olhrr(arm)>>

<<function ovfpmem(arm)>>

<<function ofsr(arm)>>

<<function omvl(arm)>>

<<global chipfloats(arm)>>

<<function chipfloat(arm)>>
@


\subsection*{[[linkers/5l/span.c]]}


<<function cmp(arm)>>=
int
cmp(int a, int b)
{

    if(a == b)
        return 1;
    switch(a) {
    case C_LCON:
        if(b == C_RCON || b == C_NCON)
            return 1;
        break;
    case C_LACON:
        if(b == C_RACON)
            return 1;
        break;
    case C_LECON:
        if(b == C_RECON)
            return 1;
        break;

    case C_HFEXT:
        return b == C_HEXT || b == C_FEXT;
    case C_FEXT:
    case C_HEXT:
        return b == C_HFEXT;
    case C_SEXT:
        return cmp(C_HFEXT, b);
    case C_LEXT:
        return cmp(C_SEXT, b);

    case C_HFAUTO:
        return b == C_HAUTO || b == C_FAUTO;
    case C_FAUTO:
    case C_HAUTO:
        return b == C_HFAUTO;
    case C_SAUTO:
        return cmp(C_HFAUTO, b);
    case C_LAUTO:
        return cmp(C_SAUTO, b);

    case C_HFOREG:
        return b == C_HOREG || b == C_FOREG;
    case C_FOREG:
    case C_HOREG:
        return b == C_HFOREG;
    case C_SROREG:
        return cmp(C_SOREG, b) || cmp(C_ROREG, b);
    case C_SOREG:
    case C_ROREG:
        return b == C_SROREG || cmp(C_HFOREG, b);
    case C_LOREG:
        return cmp(C_SROREG, b);

    case C_LBRA:
        if(b == C_SBRA)
            return 1;
        break;
    }
    return 0;
}
@

<<function ocmp(arm)>>=
int
ocmp(const void *a1, const void *a2)
{
    Optab *p1, *p2;
    int n;

    p1 = (Optab*)a1;
    p2 = (Optab*)a2;
    n = p1->as - p2->as;
    if(n)
        return n;
    n = (p2->flag&V4) - (p1->flag&V4);	/* architecture version */
    if(n)
        return n;
    n = (p2->flag&VFP) - (p1->flag&VFP);	/* floating point arch */
    if(n)
        return n;
    n = p1->a1 - p2->a1;
    if(n)
        return n;
    n = p1->a2 - p2->a2;
    if(n)
        return n;
    n = p1->a3 - p2->a3;
    if(n)
        return n;
    return 0;
}
@

<<function buildop(arm)>>=
void
buildop(void)
{
    int i, n, r;

    armv4 = !debug['h'];
    vfp = debug['f'];
    for(i=0; i<C_GOK; i++)
        for(n=0; n<C_GOK; n++)
            xcmp[i][n] = cmp(n, i);
    for(n=0; optab[n].as != AXXX; n++) {
        if((optab[n].flag & VFP) && !vfp)
            optab[n].as = AXXX;
        if((optab[n].flag & V4) && !armv4) {
            optab[n].as = AXXX;
            break;
        }
    }
    qsort(optab, n, sizeof(optab[0]), ocmp);
    for(i=0; i<n; i++) {
        r = optab[i].as;
        oprange[r].start = optab+i;
        while(optab[i].as == r)
            i++;
        oprange[r].stop = optab+i;
        i--;

        switch(r)
        {
        default:
            diag("unknown op in build: %A", r);
            errorexit();
        case AXXX:
            break;
        case AADD:
            oprange[AAND] = oprange[r];
            oprange[AEOR] = oprange[r];
            oprange[ASUB] = oprange[r];
            oprange[ARSB] = oprange[r];
            oprange[AADC] = oprange[r];
            oprange[ASBC] = oprange[r];
            oprange[ARSC] = oprange[r];
            oprange[AORR] = oprange[r];
            oprange[ABIC] = oprange[r];
            break;
        case ACMP:
            oprange[ATST] = oprange[r];
            oprange[ATEQ] = oprange[r];
            oprange[ACMN] = oprange[r];
            break;
        case AMVN:
            break;
        case ABEQ:
            oprange[ABNE] = oprange[r];
            oprange[ABCS] = oprange[r];
            oprange[ABHS] = oprange[r];
            oprange[ABCC] = oprange[r];
            oprange[ABLO] = oprange[r];
            oprange[ABMI] = oprange[r];
            oprange[ABPL] = oprange[r];
            oprange[ABVS] = oprange[r];
            oprange[ABVC] = oprange[r];
            oprange[ABHI] = oprange[r];
            oprange[ABLS] = oprange[r];
            oprange[ABGE] = oprange[r];
            oprange[ABLT] = oprange[r];
            oprange[ABGT] = oprange[r];
            oprange[ABLE] = oprange[r];
            break;
        case ASLL:
            oprange[ASRL] = oprange[r];
            oprange[ASRA] = oprange[r];
            break;
        case AMUL:
            oprange[AMULU] = oprange[r];
            break;
        case ADIV:
            oprange[AMOD] = oprange[r];
            oprange[AMODU] = oprange[r];
            oprange[ADIVU] = oprange[r];
            break;
        case AMOVW:
        case AMOVB:
        case AMOVBU:
        case AMOVH:
        case AMOVHU:
            break;
        case ASWPW:
            oprange[ASWPBU] = oprange[r];
            break;
        case AB:
        case ABL:
//		case ABX:
//		case ABXRET:
        case ASWI:
        case AWORD:
        case AMOVM:
        case ARFE:
        case ATEXT:
        case ACASE:
        case ABCASE:
            break;
        case AADDF:
            oprange[AADDD] = oprange[r];
            oprange[ASUBF] = oprange[r];
            oprange[ASUBD] = oprange[r];
            oprange[AMULF] = oprange[r];
            oprange[AMULD] = oprange[r];
            oprange[ADIVF] = oprange[r];
            oprange[ADIVD] = oprange[r];
            oprange[AMOVFD] = oprange[r];
            oprange[AMOVDF] = oprange[r];
            break;
            
        case ACMPF:
            oprange[ACMPD] = oprange[r];
            break;

        case AMOVF:
            oprange[AMOVD] = oprange[r];
            break;

        case AMOVFW:
            oprange[AMOVWF] = oprange[r];
            oprange[AMOVWD] = oprange[r];
            oprange[AMOVDW] = oprange[r];
            break;

        case AMULL:
            oprange[AMULA] = oprange[r];
            oprange[AMULAL] = oprange[r];
            oprange[AMULLU] = oprange[r];
            oprange[AMULALU] = oprange[r];
            break;
        }
    }
}
@

<<enum _anon_ (linkers/5l/span.c)(arm)>>=
/*
void
buildrep(int x, int as)
{
    Opcross *p;
    Optab *e, *s, *o;
    int a1, a2, a3, n;

    if(C_NONE != 0 || C_REG != 1 || C_GOK >= 32 || x >= nelem(opcross)) {
        diag("assumptions fail in buildrep");
        errorexit();
    }
    repop[as] = x;
    p = (opcross + x);
    s = oprange[as].start;
    e = oprange[as].stop;
    for(o=e-1; o>=s; o--) {
        n = o-optab;
        for(a2=0; a2<2; a2++) {
            if(a2) {
                if(o->a2 == C_NONE)
                    continue;
            } else
                if(o->a2 != C_NONE)
                    continue;
            for(a1=0; a1<32; a1++) {
                if(!xcmp[a1][o->a1])
                    continue;
                for(a3=0; a3<32; a3++)
                    if(xcmp[a3][o->a3])
                        (*p)[a1][a2][a3] = n;
            }
        }
    }
    oprange[as].start = 0;
}
*/

enum{
    ABSD = 0,
    ABSU = 1,
    RELD = 2,
    RELU = 3,
};
@


<<function sput(arm)>>=
static int
sput(char *s)
{
    char *p;

    p = s;
    while(*s)
        cput(*s++);
    cput(0);
    return  s-p+1;
}
@



%-------------------------------------------------------------

<<linkers/5l/span.c>>=
#include	"l.h"

<<global pool(arm)>>

void	checkpool(Prog*);
void 	flushpool(Prog*, int);

<<function span(arm)>>

<<function checkpool(arm)>>

<<function flushpool(arm)>>

<<function addpool(arm)>>

<<function xdefine(arm)>>

<<function regoff(arm)>>

<<function immrot(arm)>>

<<function immaddr(arm)>>

<<function immfloat(arm)>>

<<function immhalf(arm)>>

<<function aclass(arm)>>

<<function oplook(arm)>>

<<function cmp(arm)>>

<<function ocmp(arm)>>

<<function buildop(arm)>>

<<enum _anon_ (linkers/5l/span.c)(arm)>>

<<global modemap>>

typedef struct Reloc Reloc;

<<struct Reloc>>

<<global rels>>

<<function grow>>

<<function dynreloc(arm)>>

<<function sput(arm)>>

<<function asmdyn>>
@


\subsection*{[[linkers/5l/obj.c]]}


%-------------------------------------------------------------

<<linkers/5l/obj.c>>=
#include	"l.h"
#include	<ar.h>

#ifndef	DEFAULT
<<constant DEFAULT>>
#endif

<<global noname linker>>
<<global symname linker>>
<<global thechar>>
<<global thestring>>

<<global libdir>>
<<global nlibdir>>
<<global maxlibdir>>

<<function usage, linker>>

<<function isobjfile>>

<<function main(arm)>>

<<function addlibpath>>

<<function findlib>>

<<function loadlib>>

<<function objfile>>

<<function zaddr(arm)>>

<<function addlib>>

<<function addhist>>

<<function histtoauto>>

<<function collapsefrog>>

<<function nopout>>

<<function readsome>>

<<function ldobj(arm)>>

<<function doprof1(arm)>>

<<global brcond(arm)>>

<<function doprof2(arm)>>

<<function nuxiinit(arm)>>

<<function find1>>

<<function ieeedtof>>

<<function ieeedtod>>

<<function undefsym>>

<<function zerosig>>

<<function readundefs>>
@




\subsection*{[[linkers/5l/noop.c]]}

<<global sym_div(arm)>>=
static	Sym*	sym_div;
@

<<global sym_divu(arm)>>=
static	Sym*	sym_divu;
@

<<global sym_mod(arm)>>=
static	Sym*	sym_mod;
@

<<global sym_modu(arm)>>=
static	Sym*	sym_modu;
@


<<function sigdiv(arm)>>=
static void
sigdiv(char *n)
{
    Sym *s;

    s = lookup(n, 0);
    if(s->type == STEXT){
        if(s->sig == 0)
            s->sig = SIGNINTERN;
    }
    else if(s->type == 0 || s->type == SXREF)
        s->type = SUNDEF;
}
@

<<function divsig(arm)>>=
void
divsig(void)
{
    sigdiv("_div");
    sigdiv("_divu");
    sigdiv("_mod");
    sigdiv("_modu");
}
@

<<function sdiv(arm)>>=
static void
sdiv(Sym *s)
{
    if(s->type == 0 || s->type == SXREF){
        /* undefsym(s); */
        s->type = SXREF;
        if(s->sig == 0)
            s->sig = SIGNINTERN;
        s->subtype = SIMPORT;
    }
    else if(s->type != STEXT)
        diag("undefined: %s", s->name);
}
@

<<function initdiv(arm)>>=
void
initdiv(void)
{
    Sym *s2, *s3, *s4, *s5;
    Prog *p;

    if(prog_div != P)
        return;
    sym_div = s2 = lookup("_div", 0);
    sym_divu = s3 = lookup("_divu", 0);
    sym_mod = s4 = lookup("_mod", 0);
    sym_modu = s5 = lookup("_modu", 0);
    if(dlm) {
        sdiv(s2); if(s2->type == SXREF) prog_div = UP;
        sdiv(s3); if(s3->type == SXREF) prog_divu = UP;
        sdiv(s4); if(s4->type == SXREF) prog_mod = UP;
        sdiv(s5); if(s5->type == SXREF) prog_modu = UP;
    }
    for(p = firstp; p != P; p = p->link)
        if(p->as == ATEXT) {
            if(p->from.sym == s2)
                prog_div = p;
            if(p->from.sym == s3)
                prog_divu = p;
            if(p->from.sym == s4)
                prog_mod = p;
            if(p->from.sym == s5)
                prog_modu = p;
        }
    if(prog_div == P) {
        diag("undefined: %s", s2->name);
        prog_div = curtext;
    }
    if(prog_divu == P) {
        diag("undefined: %s", s3->name);
        prog_divu = curtext;
    }
    if(prog_mod == P) {
        diag("undefined: %s", s4->name);
        prog_mod = curtext;
    }
    if(prog_modu == P) {
        diag("undefined: %s", s5->name);
        prog_modu = curtext;
    }
}
@

<<function nocache(arm)>>=
void
nocache(Prog *p)
{
    p->optab = 0;
    p->from.class = 0;
    p->to.class = 0;
}
@


%-------------------------------------------------------------

<<linkers/5l/noop.c>>=
#include	"l.h"

<<global sym_div(arm)>>
<<global sym_divu(arm)>>
<<global sym_mod(arm)>>
<<global sym_modu(arm)>>

<<function noops(arm)>>

<<function sigdiv(arm)>>

<<function divsig(arm)>>

<<function sdiv(arm)>>

<<function initdiv(arm)>>

<<function nocache(arm)>>
@


\section{[[linkers/libmach/]]}

\subsection*{[[linkers/libmach/5.c]]}

<<function REGOFF(arm)>>=
#define	REGOFF(x)	(ulong) (&((struct Ureg *) 0)->x)
@

<<constant SP(arm)>>=
#define SP		REGOFF(r13)
#define PC		REGOFF(pc)

#define	REGSIZE		sizeof(struct Ureg)

Reglist armreglist[] =
{
    {"TYPE",	REGOFF(type),		RINT|RRDONLY, 'X'},
    {"PSR",		REGOFF(psr),		RINT|RRDONLY, 'X'},
    {"PC",		PC,			RINT, 'X'},
    {"SP",		SP,			RINT, 'X'},
    {"R15",		PC,			RINT, 'X'},
    {"R14",		REGOFF(r14),		RINT, 'X'},
    {"R13",		REGOFF(r13),		RINT, 'X'},
    {"R12",		REGOFF(r12),		RINT, 'X'},
    {"R11",		REGOFF(r11),		RINT, 'X'},
    {"R10",		REGOFF(r10),		RINT, 'X'},
    {"R9",		REGOFF(r9),		RINT, 'X'},
    {"R8",		REGOFF(r8),		RINT, 'X'},
    {"R7",		REGOFF(r7),		RINT, 'X'},
    {"R6",		REGOFF(r6),		RINT, 'X'},
    {"R5",		REGOFF(r5),		RINT, 'X'},
    {"R4",		REGOFF(r4),		RINT, 'X'},
    {"R3",		REGOFF(r3),		RINT, 'X'},
    {"R2",		REGOFF(r2),		RINT, 'X'},
    {"R1",		REGOFF(r1),		RINT, 'X'},
    {"R0",		REGOFF(r0),		RINT, 'X'},
    {  0 }
};

    /* the machine description */
Mach marm =
{
    "arm",
    MARM,		/* machine type */
    armreglist,	/* register set */
    REGSIZE,	/* register set size */
    0,		/* fp register set size */
    "PC",		/* name of PC */
    "SP",		/* name of SP */
    "R14",		/* name of link register */
    "setR12",	/* static base register name */
    0,		/* static base register value */
    0x1000,		/* page size */
    0xC0000000ULL,	/* kernel base */
    0xC0000000ULL,	/* kernel text mask */
    0x3FFFFFFFULL,	/* user stack top */
    4,		/* quantization of pc */
@

<<constant PC(arm)>>=
#define PC		REGOFF(pc)

#define	REGSIZE		sizeof(struct Ureg)

Reglist armreglist[] =
{
    {"TYPE",	REGOFF(type),		RINT|RRDONLY, 'X'},
    {"PSR",		REGOFF(psr),		RINT|RRDONLY, 'X'},
    {"PC",		PC,			RINT, 'X'},
    {"SP",		SP,			RINT, 'X'},
    {"R15",		PC,			RINT, 'X'},
    {"R14",		REGOFF(r14),		RINT, 'X'},
    {"R13",		REGOFF(r13),		RINT, 'X'},
    {"R12",		REGOFF(r12),		RINT, 'X'},
    {"R11",		REGOFF(r11),		RINT, 'X'},
    {"R10",		REGOFF(r10),		RINT, 'X'},
    {"R9",		REGOFF(r9),		RINT, 'X'},
    {"R8",		REGOFF(r8),		RINT, 'X'},
    {"R7",		REGOFF(r7),		RINT, 'X'},
    {"R6",		REGOFF(r6),		RINT, 'X'},
    {"R5",		REGOFF(r5),		RINT, 'X'},
    {"R4",		REGOFF(r4),		RINT, 'X'},
    {"R3",		REGOFF(r3),		RINT, 'X'},
    {"R2",		REGOFF(r2),		RINT, 'X'},
    {"R1",		REGOFF(r1),		RINT, 'X'},
    {"R0",		REGOFF(r0),		RINT, 'X'},
    {  0 }
};

    /* the machine description */
Mach marm =
{
    "arm",
    MARM,		/* machine type */
    armreglist,	/* register set */
    REGSIZE,	/* register set size */
    0,		/* fp register set size */
    "PC",		/* name of PC */
    "SP",		/* name of SP */
    "R14",		/* name of link register */
    "setR12",	/* static base register name */
    0,		/* static base register value */
    0x1000,		/* page size */
    0xC0000000ULL,	/* kernel base */
    0xC0000000ULL,	/* kernel text mask */
    0x3FFFFFFFULL,	/* user stack top */
    4,		/* quantization of pc */
@

<<constant REGSIZE(arm)>>=
#define	REGSIZE		sizeof(struct Ureg)
@

<<global armreglist(arm)>>=
Reglist armreglist[] =
{
    {"TYPE",	REGOFF(type),		RINT|RRDONLY, 'X'},
    {"PSR",		REGOFF(psr),		RINT|RRDONLY, 'X'},
    {"PC",		PC,			RINT, 'X'},
    {"SP",		SP,			RINT, 'X'},
    {"R15",		PC,			RINT, 'X'},
    {"R14",		REGOFF(r14),		RINT, 'X'},
    {"R13",		REGOFF(r13),		RINT, 'X'},
    {"R12",		REGOFF(r12),		RINT, 'X'},
    {"R11",		REGOFF(r11),		RINT, 'X'},
    {"R10",		REGOFF(r10),		RINT, 'X'},
    {"R9",		REGOFF(r9),		RINT, 'X'},
    {"R8",		REGOFF(r8),		RINT, 'X'},
    {"R7",		REGOFF(r7),		RINT, 'X'},
    {"R6",		REGOFF(r6),		RINT, 'X'},
    {"R5",		REGOFF(r5),		RINT, 'X'},
    {"R4",		REGOFF(r4),		RINT, 'X'},
    {"R3",		REGOFF(r3),		RINT, 'X'},
    {"R2",		REGOFF(r2),		RINT, 'X'},
    {"R1",		REGOFF(r1),		RINT, 'X'},
    {"R0",		REGOFF(r0),		RINT, 'X'},
    {  0 }
};
@

<<global marm(arm)>>=
Mach marm =
{
    "arm",
    MARM,		/* machine type */
    armreglist,	/* register set */
    REGSIZE,	/* register set size */
    0,		/* fp register set size */
    "PC",		/* name of PC */
    "SP",		/* name of SP */
    "R14",		/* name of link register */
    "setR12",	/* static base register name */
    0,		/* static base register value */
    0x1000,		/* page size */
    0xC0000000ULL,	/* kernel base */
    0xC0000000ULL,	/* kernel text mask */
    0x3FFFFFFFULL,	/* user stack top */
    4,		/* quantization of pc */
    4,		/* szaddr */
    4,		/* szreg */
    4,		/* szfloat */
    8,		/* szdouble */
};
@


%-------------------------------------------------------------

<<linkers/libmach/5.c>>=
/*
 * arm definition
 */
#include <u.h>
#include <libc.h>
#include <bio.h>
#include "/arm/include/ureg.h"
#include <mach.h>

<<function REGOFF(arm)>>

<<constant SP(arm)>>
<<constant PC(arm)>>
<<constant REGSIZE(arm)>>
<<global armreglist(arm)>>
<<global marm(arm)>>
@


\subsection*{[[linkers/libmach/5db.c]]}

<<global debug (linkers/libmach/5db.c)(arm)>>=
static int debug = 0;
@

<<function BITS(arm)>>=
#define	BITS(a, b)	((1<<(b+1))-(1<<a))
@

<<function LSR(arm)>>=
#define LSR(v, s)	((ulong)(v) >> (s))
@

<<function ASR(arm)>>=
#define ASR(v, s)	((long)(v) >> (s))
@

<<function ROR(arm)>>=
#define ROR(v, s)	(LSR((v), (s)) | (((v) & ((1 << (s))-1)) << (32 - (s))))
@

% >> >> >>

<<struct Instr(arm)>>=
struct	Instr
{
    Map	*map;
    ulong	w;
    uvlong	addr;
    uchar	op;			/* super opcode */

    uchar	cond;			/* bits 28-31 */
    uchar	store;			/* bit 20 */

    uchar	rd;			/* bits 12-15 */
    uchar	rn;			/* bits 16-19 */
    uchar	rs;			/* bits 0-11 (shifter operand) */

    long	imm;			/* rotated imm */
    char*	curr;			/* fill point in buffer */
    char*	end;			/* end of buffer */
    char*	err;			/* error message */
};
@

<<struct Opcode(arm)>>=
struct Opcode
{
    char*	o;
    void	(*fmt)(Opcode*, Instr*);
    uvlong	(*foll)(Map*, Rgetter, Instr*, uvlong);
    char*	a;
};
@

<<global FRAMENAME(arm)>>=
static	char	FRAMENAME[] = ".frame";
@

<<global armmach(arm)>>=
/*
 *	Debugger interface
 */
Machdata armmach =
{
    {0x70, 0x00, 0x20, 0xE1},		/* break point */	/* E1200070 */
    4,			/* break point size */

    leswab,			/* short to local byte order */
    leswal,			/* long to local byte order */
    leswav,			/* long to local byte order */
    risctrace,		/* C traceback */
    riscframe,		/* Frame finder */
    armexcep,			/* print exception */
    0,			/* breakpoint fixup */
    0,			/* single precision float printer */
    0,			/* double precision float printer */
    armfoll,		/* following addresses */
    arminst,		/* print instruction */
    armdas,			/* dissembler */
    arminstlen,		/* instruction size */
};
@

<<function armexcep(arm)>>=
static char*
armexcep(Map *map, Rgetter rget)
{
    uvlong c;

    c = (*rget)(map, "TYPE");
    switch ((int)c&0x1f) {
    case 0x11:
        return "Fiq interrupt";
    case 0x12:
        return "Mirq interrupt";
    case 0x13:
        return "SVC/SWI Exception";
    case 0x17:
        return "Prefetch Abort/Breakpoint";
    case 0x18:
        return "Data Abort";
    case 0x1b:
        return "Undefined instruction/Breakpoint";
    case 0x1f:
        return "Sys trap";
    default:
        return "Undefined trap";
    }
}
@

<<global cond(arm)>>=
static
char*	cond[16] =
{
    "EQ",	"NE",	"CS",	"CC",
    "MI",	"PL",	"VS",	"VC",
    "HI",	"LS",	"GE",	"LT",
    "GT",	"LE",	0,	"NV"
};
@

<<global shtype(arm)>>=
static
char*	shtype[4] =
{
    "<<",	">>",	"->",	"@>"
};
@

<<global hb(arm)>>=
static
char *hb[4] =
{
    "???",	"HU", "B", "H"
};
@

<<global addsub(arm)>>=
static
char*	addsub[2] =
{
    "-",	"+",
};
@

<<function armclass(arm)>>=
int
armclass(long w)
{
    int op, done, cp;

    op = (w >> 25) & 0x7;
    switch(op) {
    case 0:	/* data processing r,r,r */
        if((w & 0x0ff00080) == 0x01200000) {
            op = (w >> 4) & 0x7;
            if(op == 7)
                op = 124;	/* bkpt */
            else if (op > 0 && op < 4)
                op += 124;	/* bx, blx */
            else
                op = 92;	/* unk */
            break;
        }
        op = ((w >> 4) & 0xf);
        if(op == 0x9) {
            op = 48+16;		/* mul, swp or *rex */
            if((w & 0x0ff00fff) == 0x01900f9f) {
                op = 93;	/* ldrex */
                break;
            }
            if((w & 0x0ff00ff0) == 0x01800f90) {
                op = 94;	/* strex */
                break;
            }
            if(w & (1<<24)) {
                op += 2;
                if(w & (1<<22))
                    op++;	/* swpb */
                break;
            }
            if(w & (1<<23)) {	/* mullu */
                op = (48+24+4+4+2+2+4);
                if(w & (1<<22))	/* mull */
                    op += 2;
            }
            if(w & (1<<21))
                op++;		/* mla */
            break;
        }
        if((op & 0x9) == 0x9)		/* ld/st byte/half s/u */
        {
            op = (48+16+4) + ((w >> 22) & 0x1) + ((w >> 19) & 0x2);
            break;
        }
        op = (w >> 21) & 0xf;
        if(w & (1<<4))
            op += 32;
        else
        if((w & (31<<7)) || (w & (1<<5)))
            op += 16;
        break;
    case 1:	/* data processing i,r,r */
        op = (48) + ((w >> 21) & 0xf);
        break;
    case 2:	/* load/store byte/word i(r) */
        if ((w & 0xffffff8f) == 0xf57ff00f) {	/* barriers, clrex */
            done = 1;
            switch ((w >> 4) & 7) {
            case 1:
                op = 95;	/* clrex */
                break;
            case 4:
                op = 96;	/* dsb */
                break;
            case 5:
                op = 97;	/* dmb */
                break;
            case 6:
                op = 98;	/* isb */
                break;
            default:
                done = 0;
                break;
            }
            if (done)
                break;
        }
        op = (48+24) + ((w >> 22) & 0x1) + ((w >> 19) & 0x2);
        break;
    case 3:	/* load/store byte/word (r)(r) */
        op = (48+24+4) + ((w >> 22) & 0x1) + ((w >> 19) & 0x2);
        break;
    case 4:	/* block data transfer (r)(r) */
        if ((w & 0xfe50ffff) == 0xf8100a00) {	/* v7 RFE */
            op = 99;
            break;
        }
        op = (48+24+4+4) + ((w >> 20) & 0x1);
        break;
    case 5:	/* branch / branch link */
        op = (48+24+4+4+2) + ((w >> 24) & 0x1);
        break;
    case 7:	/* coprocessor crap */
        cp = (w >> 8) & 0xF;
        if(cp == 10 || cp == 11){	/* vfp */
            if((w >> 4) & 0x1){
                /* vfp register transfer */
                switch((w >> 21) & 0x7){
                case 0:
                    op = 118 + ((w >> 20) & 0x1);
                    break;
                case 7:
                    op = 118+2 + ((w >> 20) & 0x1);
                    break;
                default:
                    op = (48+24+4+4+2+2+4+4);
                    break;
                }
                break;
            }
            /* vfp data processing */
            if(((w >> 23) & 0x1) == 0){
                op = 100 + ((w >> 19) & 0x6) + ((w >> 6) & 0x1);
                break;
            }
            switch(((w >> 19) & 0x6) + ((w >> 6) & 0x1)){
            case 0:
                op = 108;
                break;
            case 7:
                if(((w >> 19) & 0x1) == 0){
                    if(((w >> 17) & 0x1) == 0)
                        op = 109 + ((w >> 16) & 0x4) +
                            ((w >> 15) & 0x2) +
                            ((w >> 7) & 0x1);
                    else if(((w >> 16) & 0x7) == 0x7)
                        op = 117;
                }else
                    switch((w >> 16) & 0x7){
                    case 0:
                    case 4:
                    case 5:
                        op = 117;
                        break;
                    }
                break;
            }
            if(op == 7)
                op = (48+24+4+4+2+2+4+4);
            break;
        }
        op = (48+24+4+4+2+2) + ((w >> 3) & 0x2) + ((w >> 20) & 0x1);
        break;
    case 6:	/* vfp load / store */
        if(((w >> 21) &0x9) == 0x8){
            op = 122 + ((w >> 20) & 0x1);
            break;
        }
        /* fall through */
    default:	  
        op = (48+24+4+4+2+2+4+4);
        break;
    }
    return op;
}
@

<<function decode(arm)>>=
static int
decode(Map *map, uvlong pc, Instr *i)
{
    ulong w;

    if(get4(map, pc, &w) < 0) {
        werrstr("can't read instruction: %r");
        return -1;
    }
    i->w = w;
    i->addr = pc;
    i->cond = (w >> 28) & 0xF;
    i->op = armclass(w);
    i->map = map;
    return 1;
}
@

<<function bprint(arm)>>=
static void
bprint(Instr *i, char *fmt, ...)
{
    va_list arg;

    va_start(arg, fmt);
    i->curr = vseprint(i->curr, i->end, fmt, arg);
    va_end(arg);
}
@

<<function plocal(arm)>>=
static int
plocal(Instr *i)
{
    char *reg;
    Symbol s;
    char *fn;
    int class;
    int offset;

    if(!findsym(i->addr, CTEXT, &s)) {
        if(debug)fprint(2,"fn not found @%llux: %r\n", i->addr);
        return 0;
    }
    fn = s.name;
    if (!findlocal(&s, FRAMENAME, &s)) {
        if(debug)fprint(2,"%s.%s not found @%s: %r\n", fn, FRAMENAME, s.name);
            return 0;
    }
    if(s.value > i->imm) {
        class = CAUTO;
        offset = s.value-i->imm;
        reg = "(SP)";
    } else {
        class = CPARAM;
        offset = i->imm-s.value-4;
        reg = "(FP)";
    }
    if(!getauto(&s, offset, class, &s)) {
        if(debug)fprint(2,"%s %s not found @%ux: %r\n", fn,
            class == CAUTO ? " auto" : "param", offset);
        return 0;
    }
    bprint(i, "%s%c%lld%s", s.name, class == CPARAM ? '+' : '-', s.value, reg);
    return 1;
}
@

<<function gsymoff(arm)>>=
/*
 * Print value v as name[+offset]
 */
static int
gsymoff(char *buf, int n, ulong v, int space)
{
    Symbol s;
    int r;
    long delta;

    r = delta = 0;		/* to shut compiler up */
    if (v) {
        r = findsym(v, space, &s);
        if (r)
            delta = v-s.value;
        if (delta < 0)
            delta = -delta;
    }
    if (v == 0 || r == 0 || delta >= 4096)
        return snprint(buf, n, "#%lux", v);
    if (strcmp(s.name, ".string") == 0)
        return snprint(buf, n, "#%lux", v);
    if (!delta)
        return snprint(buf, n, "%s", s.name);
    if (s.type != 't' && s.type != 'T')
        return snprint(buf, n, "%s+%llux", s.name, v-s.value);
    else
        return snprint(buf, n, "#%lux", v);
}
@

<<function armdps(arm)>>=
static void
armdps(Opcode *o, Instr *i)
{
    i->store = (i->w >> 20) & 1;
    i->rn = (i->w >> 16) & 0xf;
    i->rd = (i->w >> 12) & 0xf;
    i->rs = (i->w >> 0) & 0xf;
    if(i->rn == 15 && i->rs == 0) {
        if(i->op == 8) {
            format("MOVW", i,"CPSR, R%d");
            return;
        } else
        if(i->op == 10) {
            format("MOVW", i,"SPSR, R%d");
            return;
        }
    } else
    if(i->rn == 9 && i->rd == 15) {
        if(i->op == 9) {
            format("MOVW", i, "R%s, CPSR");
            return;
        } else
        if(i->op == 11) {
            format("MOVW", i, "R%s, SPSR");
            return;
        }
    }
    if(i->rd == 15) {
        if(i->op == 120) {
            format("MOVW", i, "PSR, %x");
            return;
        } else
        if(i->op == 121) {
            format("MOVW", i, "%x, PSR");
            return;
        }
    }
    format(o->o, i, o->a);
}
@

<<function armdpi(arm)>>=
static void
armdpi(Opcode *o, Instr *i)
{
    ulong v;
    int c;

    v = (i->w >> 0) & 0xff;
    c = (i->w >> 8) & 0xf;
    while(c) {
        v = (v<<30) | (v>>2);
        c--;
    }
    i->imm = v;
    i->store = (i->w >> 20) & 1;
    i->rn = (i->w >> 16) & 0xf;
    i->rd = (i->w >> 12) & 0xf;
    i->rs = i->w&0x0f;

        /* RET is encoded as ADD #0,R14,R15 */
    if((i->w & 0x0fffffff) == 0x028ef000){
        format("RET%C", i, "");
        return;
    }
    if((i->w & 0x0ff0ffff) == 0x0280f000){
        format("B%C", i, "0(R%n)");
        return;
    }
    format(o->o, i, o->a);
}
@

<<function armsdti(arm)>>=
static void
armsdti(Opcode *o, Instr *i)
{
    ulong v;

    v = i->w & 0xfff;
    if(!(i->w & (1<<23)))
        v = -v;
    i->store = ((i->w >> 23) & 0x2) | ((i->w >>21) & 0x1);
    i->imm = v;
    i->rn = (i->w >> 16) & 0xf;
    i->rd = (i->w >> 12) & 0xf;
        /* RET is encoded as LW.P x,R13,R15 */
    if ((i->w & 0x0ffff000) == 0x049df000)
    {
        format("RET%C%p", i, "%I");
        return;
    }
    format(o->o, i, o->a);
}
@

<<function armvstdi(arm)>>=
static void
armvstdi(Opcode *o, Instr *i)
{
    ulong v;

    v = (i->w & 0xff) << 2;
    if(!(i->w & (1<<23)))
        v = -v;
    i->imm = v;
    i->rn = (i->w >> 16) & 0xf;
    i->rd = (i->w >> 12) & 0xf;
    format(o->o, i, o->a);
}
@

<<function armhwby(arm)>>=
/* arm V4 ld/st halfword, signed byte */
static void
armhwby(Opcode *o, Instr *i)
{
    i->store = ((i->w >> 23) & 0x2) | ((i->w >>21) & 0x1);
    i->imm = (i->w & 0xf) | ((i->w >> 8) & 0xf);
    if (!(i->w & (1 << 23)))
        i->imm = - i->imm;
    i->rn = (i->w >> 16) & 0xf;
    i->rd = (i->w >> 12) & 0xf;
    i->rs = (i->w >> 0) & 0xf;
    format(o->o, i, o->a);
}
@

<<function armsdts(arm)>>=
static void
armsdts(Opcode *o, Instr *i)
{
    i->store = ((i->w >> 23) & 0x2) | ((i->w >>21) & 0x1);
    i->rs = (i->w >> 0) & 0xf;
    i->rn = (i->w >> 16) & 0xf;
    i->rd = (i->w >> 12) & 0xf;
    format(o->o, i, o->a);
}
@

<<function armbdt(arm)>>=
static void
armbdt(Opcode *o, Instr *i)
{
    i->store = (i->w >> 21) & 0x3;		/* S & W bits */
    i->rn = (i->w >> 16) & 0xf;
    i->imm = i->w & 0xffff;
    if(i->w == 0xe8fd8000)
        format("RFE", i, "");
    else
        format(o->o, i, o->a);
}
@

<<function armund(arm)>>=
static void
armund(Opcode *o, Instr *i)
{
    format(o->o, i, o->a);
}
@

<<function armcdt(arm)>>=
static void
armcdt(Opcode *o, Instr *i)
{
    format(o->o, i, o->a);
}
@

<<function armunk(arm)>>=
static void
armunk(Opcode *o, Instr *i)
{
    format(o->o, i, o->a);
}
@

<<function armb(arm)>>=
static void
armb(Opcode *o, Instr *i)
{
    ulong v;

    v = i->w & 0xffffff;
    if(v & 0x800000)
        v |= ~0xffffff;
    i->imm = (v<<2) + i->addr + 8;
    format(o->o, i, o->a);
}
@

<<function armbpt(arm)>>=
static void
armbpt(Opcode *o, Instr *i)
{
    i->imm = ((i->w >> 4) & 0xfff0) | (i->w &0xf);
    format(o->o, i, o->a);
}
@

<<function armco(arm)>>=
static void
armco(Opcode *o, Instr *i)		/* coprocessor instructions */
{
    int op, p, cp;

    char buf[1024];

    i->rn = (i->w >> 16) & 0xf;
    i->rd = (i->w >> 12) & 0xf;
    i->rs = i->w&0xf;
    cp = (i->w >> 8) & 0xf;
    p = (i->w >> 5) & 0x7;
    if(i->w&(1<<4)) {
        op = (i->w >> 21) & 0x07;
        snprint(buf, sizeof(buf), "#%x, #%x, R%d, C(%d), C(%d), #%x", cp, op, i->rd, i->rn, i->rs, p);
    } else {
        op = (i->w >> 20) & 0x0f;
        snprint(buf, sizeof(buf), "#%x, #%x, C(%d), C(%d), C(%d), #%x", cp, op, i->rd, i->rn, i->rs, p);
    }
    format(o->o, i, buf);
}
@

<<function armcondpass(arm)>>=
static int
armcondpass(Map *map, Rgetter rget, uchar cond)
{
    uvlong psr;
    uchar n;
    uchar z;
    uchar c;
    uchar v;

    psr = rget(map, "PSR");
    n = (psr >> 31) & 1;
    z = (psr >> 30) & 1;
    c = (psr >> 29) & 1;
    v = (psr >> 28) & 1;

    switch(cond) {
    default:
    case 0:		return z;
    case 1:		return !z;
    case 2:		return c;
    case 3:		return !c;
    case 4:		return n;
    case 5:		return !n;
    case 6:		return v;
    case 7:		return !v;
    case 8:		return c && !z;
    case 9:		return !c || z;
    case 10:	return n == v;
    case 11:	return n != v;
    case 12:	return !z && (n == v);
    case 13:	return z || (n != v);
    case 14:	return 1;
    case 15:	return 0;
    }
}
@

<<function armshiftval(arm)>>=
static ulong
armshiftval(Map *map, Rgetter rget, Instr *i)
{
    if(i->w & (1 << 25)) {				/* immediate */
        ulong imm = i->w & BITS(0, 7);
        ulong s = (i->w & BITS(8, 11)) >> 7; /* this contains the *2 */
        return ROR(imm, s);
    } else {
        char buf[8];
        ulong v;
        ulong s = (i->w & BITS(7,11)) >> 7;

        sprint(buf, "R%ld", i->w & 0xf);
        v = rget(map, buf);

        switch((i->w & BITS(4, 6)) >> 4) {
        default:
        case 0:					/* LSLIMM */
            return v << s;
        case 1:					/* LSLREG */
            sprint(buf, "R%lud", s >> 1);
            s = rget(map, buf) & 0xFF;
            if(s >= 32) return 0;
            return v << s;
        case 2:					/* LSRIMM */
            return LSR(v, s);
        case 3:					/* LSRREG */
            sprint(buf, "R%ld", s >> 1);
            s = rget(map, buf) & 0xFF;
            if(s >= 32) return 0;
            return LSR(v, s);
        case 4:					/* ASRIMM */
            if(s == 0) {
                if((v & (1U<<31)) == 0)
                    return 0;
                return 0xFFFFFFFF;
            }
            return ASR(v, s);
        case 5:					/* ASRREG */
            sprint(buf, "R%ld", s >> 1);
            s = rget(map, buf) & 0xFF;
            if(s >= 32) {
                if((v & (1U<<31)) == 0)
                    return 0;
                return 0xFFFFFFFF;
            }
            return ASR(v, s);
        case 6:					/* RORIMM */
            if(s == 0) {
                ulong c = (rget(map, "PSR") >> 29) & 1;

                return (c << 31) | LSR(v, 1);
            }
            return ROR(v, s);
        case 7:					/* RORREG */
            sprint(buf, "R%ld", (s>>1)&0xF);
            s = rget(map, buf);
            if(s == 0 || (s & 0xF) == 0)
                return v;
            return ROR(v, s & 0xF);
        }
    }
}
@

<<function nbits(arm)>>=
static int
nbits(ulong v)
{
    int n = 0;
    int i;

    for(i=0; i < 32 ; i++) {
        if(v & 1) ++n;
        v >>= 1;
    }

    return n;
}
@

<<function armmaddr(arm)>>=
static ulong
armmaddr(Map *map, Rgetter rget, Instr *i)
{
    ulong v;
    ulong nb;
    char buf[8];
    ulong rn;

    rn = (i->w >> 16) & 0xf;
    sprint(buf,"R%ld", rn);

    v = rget(map, buf);
    nb = nbits(i->w & ((1 << 15) - 1));

    switch((i->w >> 23) & 3) {
    default:
    case 0: return (v - (nb*4)) + 4;
    case 1: return v;
    case 2: return v - (nb*4);
    case 3: return v + 4;
    }
}
@

<<function armaddr(arm)>>=
static uvlong
armaddr(Map *map, Rgetter rget, Instr *i)
{
    char buf[8];
    ulong rn;

    snprint(buf, sizeof(buf), "R%ld", (i->w >> 16) & 0xf);
    rn = rget(map, buf);

    if((i->w & (1<<24)) == 0)			/* POSTIDX */
        return rn;

    if((i->w & (1<<25)) == 0) {			/* OFFSET */
        if(i->w & (1U<<23))
            return rn + (i->w & BITS(0,11));
        return rn - (i->w & BITS(0,11));
    } else {					/* REGOFF */
        ulong index = 0;
        uchar c;
        uchar rm;

        sprint(buf, "R%ld", i->w & 0xf);
        rm = rget(map, buf);

        switch((i->w & BITS(5,6)) >> 5) {
        case 0: index = rm << ((i->w & BITS(7,11)) >> 7);	break;
        case 1: index = LSR(rm, ((i->w & BITS(7,11)) >> 7));	break;
        case 2: index = ASR(rm, ((i->w & BITS(7,11)) >> 7));	break;
        case 3:
            if((i->w & BITS(7,11)) == 0) {
                c = (rget(map, "PSR") >> 29) & 1;
                index = c << 31 | LSR(rm, 1);
            } else {
                index = ROR(rm, ((i->w & BITS(7,11)) >> 7));
            }
            break;
        }
        if(i->w & (1<<23))
            return rn + index;
        return rn - index;
    }
}
@

<<function armfadd(arm)>>=
static uvlong
armfadd(Map *map, Rgetter rget, Instr *i, uvlong pc)
{
    char buf[8];
    int r;

    r = (i->w >> 12) & 0xf;
    if(r != 15 || !armcondpass(map, rget, (i->w >> 28) & 0xf))
        return pc+4;

    r = (i->w >> 16) & 0xf;
    sprint(buf, "R%d", r);

    return rget(map, buf) + armshiftval(map, rget, i);
}
@

<<function armfbx(arm)>>=
static uvlong
armfbx(Map *map, Rgetter rget, Instr *i, uvlong pc)
{
    char buf[8];
    int r;

    if(!armcondpass(map, rget, (i->w>>28)&0xf))
        return pc+4;
    r = (i->w >> 0) & 0xf;
    sprint(buf, "R%d", r);
    return rget(map, buf);
}
@

<<function armfmovm(arm)>>=
static uvlong
armfmovm(Map *map, Rgetter rget, Instr *i, uvlong pc)
{
    ulong v;
    ulong addr;

    v = i->w & 1<<15;
    if(!v || !armcondpass(map, rget, (i->w>>28)&0xf))
        return pc+4;

    addr = armmaddr(map, rget, i) + nbits(i->w & BITS(0,15));
    if(get4(map, addr, &v) < 0) {
        werrstr("can't read addr: %r");
        return -1;
    }
    return v;
}
@

<<function armfbranch(arm)>>=
static uvlong
armfbranch(Map *map, Rgetter rget, Instr *i, uvlong pc)
{
    if(!armcondpass(map, rget, (i->w >> 28) & 0xf))
        return pc+4;

    return pc + (((signed long)i->w << 8) >> 6) + 8;
}
@

<<function armfmov(arm)>>=
static uvlong
armfmov(Map *map, Rgetter rget, Instr *i, uvlong pc)
{
    ulong rd, v;

    rd = (i->w >> 12) & 0xf;
    if(rd != 15 || !armcondpass(map, rget, (i->w>>28)&0xf))
        return pc+4;

     /* LDR */
    /* BUG: Needs LDH/B, too */
    if(((i->w>>26)&0x3) == 1) {
        if(get4(map, armaddr(map, rget, i), &v) < 0) {
            werrstr("can't read instruction: %r");
            return pc+4;
        }
        return v;
    }

     /* MOV */
    v = armshiftval(map, rget, i);

    return v;
}
@

<<global opcodes(arm)>>=
static Opcode opcodes[] =
{
    "AND%C%S",	armdps, 0,	"R%s,R%n,R%d",
    "EOR%C%S",	armdps, 0,	"R%s,R%n,R%d",
    "SUB%C%S",	armdps, 0,	"R%s,R%n,R%d",
    "RSB%C%S",	armdps, 0,	"R%s,R%n,R%d",
    "ADD%C%S",	armdps, armfadd,	"R%s,R%n,R%d",
    "ADC%C%S",	armdps, 0,	"R%s,R%n,R%d",
    "SBC%C%S",	armdps, 0,	"R%s,R%n,R%d",
    "RSC%C%S",	armdps, 0,	"R%s,R%n,R%d",
    "TST%C%S",	armdps, 0,	"R%s,R%n",
    "TEQ%C%S",	armdps, 0,	"R%s,R%n",
    "CMP%C%S",	armdps, 0,	"R%s,R%n",
    "CMN%C%S",	armdps, 0,	"R%s,R%n",
    "ORR%C%S",	armdps, 0,	"R%s,R%n,R%d",
    "MOVW%C%S",	armdps, armfmov,	"R%s,R%d",
    "BIC%C%S",	armdps, 0,	"R%s,R%n,R%d",
    "MVN%C%S",	armdps, 0,	"R%s,R%d",

/* 16 */
    "AND%C%S",	armdps, 0,	"(R%s%h%m),R%n,R%d",
    "EOR%C%S",	armdps, 0,	"(R%s%h%m),R%n,R%d",
    "SUB%C%S",	armdps, 0,	"(R%s%h%m),R%n,R%d",
    "RSB%C%S",	armdps, 0,	"(R%s%h%m),R%n,R%d",
    "ADD%C%S",	armdps, armfadd,	"(R%s%h%m),R%n,R%d",
    "ADC%C%S",	armdps, 0,	"(R%s%h%m),R%n,R%d",
    "SBC%C%S",	armdps, 0,	"(R%s%h%m),R%n,R%d",
    "RSC%C%S",	armdps, 0,	"(R%s%h%m),R%n,R%d",
    "TST%C%S",	armdps, 0,	"(R%s%h%m),R%n",
    "TEQ%C%S",	armdps, 0,	"(R%s%h%m),R%n",
    "CMP%C%S",	armdps, 0,	"(R%s%h%m),R%n",
    "CMN%C%S",	armdps, 0,	"(R%s%h%m),R%n",
    "ORR%C%S",	armdps, 0,	"(R%s%h%m),R%n,R%d",
    "MOVW%C%S",	armdps, armfmov,	"(R%s%h%m),R%d",
    "BIC%C%S",	armdps, 0,	"(R%s%h%m),R%n,R%d",
    "MVN%C%S",	armdps, 0,	"(R%s%h%m),R%d",

/* 32 */
    "AND%C%S",	armdps, 0,	"(R%s%hR%M),R%n,R%d",
    "EOR%C%S",	armdps, 0,	"(R%s%hR%M),R%n,R%d",
    "SUB%C%S",	armdps, 0,	"(R%s%hR%M),R%n,R%d",
    "RSB%C%S",	armdps, 0,	"(R%s%hR%M),R%n,R%d",
    "ADD%C%S",	armdps, armfadd,	"(R%s%hR%M),R%n,R%d",
    "ADC%C%S",	armdps, 0,	"(R%s%hR%M),R%n,R%d",
    "SBC%C%S",	armdps, 0,	"(R%s%hR%M),R%n,R%d",
    "RSC%C%S",	armdps, 0,	"(R%s%hR%M),R%n,R%d",
    "TST%C%S",	armdps, 0,	"(R%s%hR%M),R%n",
    "TEQ%C%S",	armdps, 0,	"(R%s%hR%M),R%n",
    "CMP%C%S",	armdps, 0,	"(R%s%hR%M),R%n",
    "CMN%C%S",	armdps, 0,	"(R%s%hR%M),R%n",
    "ORR%C%S",	armdps, 0,	"(R%s%hR%M),R%n,R%d",
    "MOVW%C%S",	armdps, armfmov,	"(R%s%hR%M),R%d",
    "BIC%C%S",	armdps, 0,	"(R%s%hR%M),R%n,R%d",
    "MVN%C%S",	armdps, 0,	"(R%s%hR%M),R%d",

/* 48 */
    "AND%C%S",	armdpi, 0,	"$#%i,R%n,R%d",
    "EOR%C%S",	armdpi, 0,	"$#%i,R%n,R%d",
    "SUB%C%S",	armdpi, 0,	"$#%i,R%n,R%d",
    "RSB%C%S",	armdpi, 0,	"$#%i,R%n,R%d",
    "ADD%C%S",	armdpi, armfadd,	"$#%i,R%n,R%d",
    "ADC%C%S",	armdpi, 0,	"$#%i,R%n,R%d",
    "SBC%C%S",	armdpi, 0,	"$#%i,R%n,R%d",
    "RSC%C%S",	armdpi, 0,	"$#%i,R%n,R%d",
    "TST%C%S",	armdpi, 0,	"$#%i,R%n",
    "TEQ%C%S",	armdpi, 0,	"$#%i,R%n",
    "CMP%C%S",	armdpi, 0,	"$#%i,R%n",
    "CMN%C%S",	armdpi, 0,	"$#%i,R%n",
    "ORR%C%S",	armdpi, 0,	"$#%i,R%n,R%d",
    "MOVW%C%S",	armdpi, armfmov,	"$#%i,R%d",
    "BIC%C%S",	armdpi, 0,	"$#%i,R%n,R%d",
    "MVN%C%S",	armdpi, 0,	"$#%i,R%d",

/* 48+16 */
    "MUL%C%S",	armdpi, 0,	"R%M,R%s,R%n",
    "MULA%C%S",	armdpi, 0,	"R%M,R%s,R%n,R%d",
    "SWPW",		armdpi, 0,	"R%s,(R%n),R%d",
    "SWPB",		armdpi, 0,	"R%s,(R%n),R%d",

/* 48+16+4 */
    "MOV%u%C%p",	armhwby, 0,	"R%d,(R%n%UR%M)",
    "MOV%u%C%p",	armhwby, 0,	"R%d,%I",
    "MOV%u%C%p",	armhwby, armfmov,	"(R%n%UR%M),R%d",
    "MOV%u%C%p",	armhwby, armfmov,	"%I,R%d",

/* 48+24 */
    "MOVW%C%p",	armsdti, 0,	"R%d,%I",
    "MOVB%C%p",	armsdti, 0,	"R%d,%I",
    "MOVW%C%p",	armsdti, armfmov,	"%I,R%d",
    "MOVBU%C%p",	armsdti, armfmov,	"%I,R%d",

    "MOVW%C%p",	armsdts, 0,	"R%d,(R%s%h%m)(R%n)",
    "MOVB%C%p",	armsdts, 0,	"R%d,(R%s%h%m)(R%n)",
    "MOVW%C%p",	armsdts, armfmov,	"(R%s%h%m)(R%n),R%d",
    "MOVBU%C%p",	armsdts, armfmov,	"(R%s%h%m)(R%n),R%d",

    "MOVM%C%P%a",	armbdt, armfmovm,		"[%r],(R%n)",
    "MOVM%C%P%a",	armbdt, armfmovm,		"(R%n),[%r]",

    "B%C",		armb, armfbranch,		"%b",
    "BL%C",		armb, armfbranch,		"%b",

    "CDP%C",	armco, 0,		"",
    "CDP%C",	armco, 0,		"",
    "MCR%C",	armco, 0,		"",
    "MRC%C",	armco, 0,		"",

/* 48+24+4+4+2+2+4 */
    "MULLU%C%S",	armdpi, 0,	"R%M,R%s,(R%n,R%d)",
    "MULALU%C%S",	armdpi, 0,	"R%M,R%s,(R%n,R%d)",
    "MULL%C%S",	armdpi, 0,	"R%M,R%s,(R%n,R%d)",
    "MULAL%C%S",	armdpi, 0,	"R%M,R%s,(R%n,R%d)",

/* 48+24+4+4+2+2+4+4 = 92 */
    "UNK",		armunk, 0,	"",

    /* new v7 arch instructions */
/* 93 */
    "LDREX",	armdpi, 0,	"(R%n),R%d",
    "STREX",	armdpi, 0,	"R%s,(R%n),R%d",
    "CLREX",	armunk, 0,	"",

/* 96 */
    "DSB",		armunk, 0,	"",
    "DMB",		armunk, 0,	"",
    "ISB",		armunk, 0,	"",

/* 99 */
    "RFEV7%P%a",	armbdt, 0,	"(R%n)",

/* 100 */
    "MLA%f%C",	armdps,	0,	"F%s,F%n,F%d",
    "MLS%f%C",	armdps,	0,	"F%s,F%n,F%d",
    "NMLS%f%C",	armdps,	0,	"F%s,F%n,F%d",
    "NMLA%f%C",	armdps,	0,	"F%s,F%n,F%d",
    "MUL%f%C",	armdps,	0,	"F%s,F%n,F%d",
    "NMUL%f%C",	armdps,	0,	"F%s,F%n,F%d",
    "ADD%f%C",	armdps,	0,	"F%s,F%n,F%d",
    "SUB%f%C",	armdps,	0,	"F%s,F%n,F%d",
    "DIV%f%C",	armdps,	0,	"F%s,F%n,F%d",

/* 109 */
    "MOV%f%C",	armdps,	0,	"F%s,F%d",
    "ABS%f%C",	armdps,	0,	"F%s,F%d",
    "NEG%f%C",	armdps,	0,	"F%s,F%d",
    "SQRT%f%C",	armdps,	0,	"F%s,F%d",
    "CMP%f%C",	armdps,	0,	"F%s,F%d",
    "CMPE%f%C",	armdps,	0,	"F%s,F%d",
    "CMP%f%C",	armdps,	0,	"$0.0,F%d",
    "CMPE%f%C",	armdps,	0,	"$0.0,F%d",

/* 117 */
    "MOV%F%R%C",	armdps, 0,	"F%s,F%d",

/* 118 */
    "MOVW%C",	armdps, 0,	"R%d,F%n",
    "MOVW%C",	armdps, 0,	"F%n,R%d",
    "MOVW%C",	armdps, 0,	"R%d,%x",
    "MOVW%C",	armdps, 0,	"%x,R%d",

/* 122 */
    "MOV%f%C",	armvstdi,	0,	"F%d,%I",
    "MOV%f%C",	armvstdi,	0,	"%I,F%d",

/* 124 */
    "BKPT%C",	armbpt,	0,		"$#%i",
    "BX%C",		armdps,	armfbx,	"(R%s)",
    "BXJ%C",	armdps,	armfbx,	"(R%s)",
    "BLX%C",	armdps,	armfbx,	"(R%s)",
};
@

<<function gaddr(arm)>>=
static void
gaddr(Instr *i)
{
    *i->curr++ = '$';
    i->curr += gsymoff(i->curr, i->end-i->curr, i->imm, CANY);
}
@
%$

<<global mode(arm)>>=
static	char *mode[] = { 0, "IA", "DB", "IB" };
@

<<global pw(arm)>>=
static	char *pw[] = { "P", "PW", 0, "W" };
@

<<global sw(arm)>>=
static	char *sw[] = { 0, "W", "S", "SW" };
@

<<function format(arm)>>=
static void
format(char *mnemonic, Instr *i, char *f)
{
    int j, k, m, n;
    int g;
    char *fmt;

    if(mnemonic)
        format(0, i, mnemonic);
    if(f == 0)
        return;
    if(mnemonic)
        if(i->curr < i->end)
            *i->curr++ = '\t';
    for ( ; *f && i->curr < i->end; f++) {
        if(*f != '%') {
            *i->curr++ = *f;
            continue;
        }
        switch (*++f) {

        case 'C':	/* .CONDITION */
            if(cond[i->cond])
                bprint(i, ".%s", cond[i->cond]);
            break;

        case 'S':	/* .STORE */
            if(i->store)
                bprint(i, ".S");
            break;

        case 'P':	/* P & U bits for block move */
            n = (i->w >>23) & 0x3;
            if (mode[n])
                bprint(i, ".%s", mode[n]);
            break;

        case 'p':	/* P & W bits for single data xfer*/
            if (pw[i->store])
                bprint(i, ".%s", pw[i->store]);
            break;

        case 'a':	/* S & W bits for single data xfer*/
            if (sw[i->store])
                bprint(i, ".%s", sw[i->store]);
            break;

        case 's':
            bprint(i, "%d", i->rs & 0xf);
            break;
                
        case 'M':
            bprint(i, "%lud", (i->w>>8) & 0xf);
            break;
                
        case 'm':
            bprint(i, "%lud", (i->w>>7) & 0x1f);
            break;

        case 'h':
            bprint(i, shtype[(i->w>>5) & 0x3]);
            break;

        case 'u':		/* Signed/unsigned Byte/Halfword */
            bprint(i, hb[(i->w>>5) & 0x3]);
            break;

        case 'I':
            if (i->rn == 13) {
                if (plocal(i))
                    break;
            }
            g = 0;
            fmt = "#%lx(R%d)";
            if (i->rn == 15) {
                /* convert load of offset(PC) to a load immediate */
                if (get4(i->map, i->addr+i->imm+8, (ulong*)&i->imm) > 0)
                {
                    g = 1;
                    fmt = "";
                }
            }
            if (mach->sb)
            {
                if (i->rd == 11) {
                    ulong nxti;

                    if (get4(i->map, i->addr+4, &nxti) > 0) {
                        if ((nxti & 0x0e0f0fff) == 0x060c000b) {
                            i->imm += mach->sb;
                            g = 1;
                            fmt = "-SB";
                        }
                    }
                }
                if (i->rn == 12)
                {
                    i->imm += mach->sb;
                    g = 1;
                    fmt = "-SB(SB)";
                }
            }
            if (g)
            {
                gaddr(i);
                bprint(i, fmt, i->rn);
            }
            else
                bprint(i, fmt, i->imm, i->rn);
            break;
        case 'U':		/* Add/subtract from base */
            bprint(i, addsub[(i->w >> 23) & 1]);
            break;

        case 'n':
            bprint(i, "%d", i->rn);
            break;

        case 'd':
            bprint(i, "%d", i->rd);
            break;

        case 'i':
            bprint(i, "%lux", i->imm);
            break;

        case 'b':
            i->curr += symoff(i->curr, i->end-i->curr,
                (ulong)i->imm, CTEXT);
            break;

        case 'g':
            i->curr += gsymoff(i->curr, i->end-i->curr,
                i->imm, CANY);
            break;

        case 'f':
            switch((i->w >> 8) & 0xF){
            case 10:
                bprint(i, "F");
                break;
            case 11:
                bprint(i, "D");
                break;
            }
            break;

        case 'F':
            switch(((i->w >> 15) & 0xE) + ((i->w >> 8) & 0x1)){
            case 0x0:
                bprint(i, ((i->w >> 7) & 0x1)? "WF" : "WF.U");
                break;
            case 0x1:
                bprint(i, ((i->w >> 7) & 0x1)? "WD" : "WD.U");
                break;
            case 0x8:
                bprint(i, "FW.U");
                break;
            case 0x9:
                bprint(i, "DW.U");
                break;
            case 0xA:
                bprint(i, "FW");
                break;
            case 0xB:
                bprint(i, "DW");
                break;
            case 0xE:
                bprint(i, "FD");
                break;
            case 0xF:
                bprint(i, "DF");
                break;
            }
            break;

        case 'R':
            if(((i->w >> 7) & 0x1) == 0)
                bprint(i, "R");
            break;

        case 'x':
            switch(i->rn){
            case 0:
                bprint(i, "FPSID");
                break;
            case 1:
                bprint(i, "FPSCR");
                break;
            case 2:
                bprint(i, "FPEXC");
                break;
            default:
                bprint(i, "FPS(%d)", i->rn);
                break;
            }
            break;

        case 'r':
            n = i->imm&0xffff;
            j = 0;
            k = 0;
            while(n) {
                m = j;
                while(n&0x1) {
                    j++;
                    n >>= 1;
                }
                if(j != m) {
                    if(k)
                        bprint(i, ",");
                    if(j == m+1)
                        bprint(i, "R%d", m);
                    else
                        bprint(i, "R%d-R%d", m, j-1);
                    k = 1;
                }
                j++;
                n >>= 1;
            }
            break;

        case '\0':
            *i->curr++ = '%';
            return;

        default:
            bprint(i, "%%%c", *f);
            break;
        }
    }
    *i->curr = 0;
}
@

<<function printins(arm)>>=
static int
printins(Map *map, uvlong pc, char *buf, int n)
{
    Instr i;

    i.curr = buf;
    i.end = buf+n-1;
    if(decode(map, pc, &i) < 0)
        return -1;

    (*opcodes[i.op].fmt)(&opcodes[i.op], &i);
    return 4;
}
@

<<function arminst(arm)>>=
static int
arminst(Map *map, uvlong pc, char modifier, char *buf, int n)
{
    USED(modifier);
    return printins(map, pc, buf, n);
}
@

<<function armdas(arm)>>=
static int
armdas(Map *map, uvlong pc, char *buf, int n)
{
    Instr i;

    i.curr = buf;
    i.end = buf+n;
    if(decode(map, pc, &i) < 0)
        return -1;
    if(i.end-i.curr > 8)
        i.curr = _hexify(buf, i.w, 7);
    *i.curr = 0;
    return 4;
}
@

<<function arminstlen(arm)>>=
static int
arminstlen(Map *map, uvlong pc)
{
    Instr i;

    if(decode(map, pc, &i) < 0)
        return -1;
    return 4;
}
@

<<function armfoll(arm)>>=
static int
armfoll(Map *map, uvlong pc, Rgetter rget, uvlong *foll)
{
    uvlong d;
    Instr i;

    if(decode(map, pc, &i) < 0)
        return -1;

    if(opcodes[i.op].foll) {
        d = (*opcodes[i.op].foll)(map, rget, &i, pc);
        if(d == -1)
            return -1;
    } else
        d = pc+4;

    foll[0] = d;
    return 1;
}
@


%-------------------------------------------------------------

<<linkers/libmach/5db.c>>=
#include <u.h>
#include <libc.h>
#include <bio.h>
#include <mach.h>

<<global debug (linkers/libmach/5db.c)(arm)>>

<<function BITS(arm)>>

<<function LSR(arm)>>
<<function ASR(arm)>>
<<function ROR(arm)>>



typedef struct	Instr	Instr;
<<struct Instr(arm)>>

typedef struct Opcode Opcode;
<<struct Opcode(arm)>>

static	void	format(char*, Instr*, char*);
<<global FRAMENAME(arm)>>

/*
 * Arm-specific debugger interface
 */

static	char	*armexcep(Map*, Rgetter);
static	int	armfoll(Map*, uvlong, Rgetter, uvlong*);
static	int	arminst(Map*, uvlong, char, char*, int);
static	int	armdas(Map*, uvlong, char*, int);
static	int	arminstlen(Map*, uvlong);

<<global armmach(arm)>>

<<function armexcep(arm)>>

<<global cond(arm)>>

<<global shtype(arm)>>

<<global hb(arm)>>

<<global addsub(arm)>>

<<function armclass(arm)>>

<<function decode(arm)>>

#pragma	varargck	argpos	bprint		2

<<function bprint(arm)>>

<<function plocal(arm)>>

<<function gsymoff(arm)>>

<<function armdps(arm)>>

<<function armdpi(arm)>>

<<function armsdti(arm)>>

<<function armvstdi(arm)>>

<<function armhwby(arm)>>

<<function armsdts(arm)>>

<<function armbdt(arm)>>

<<function armund(arm)>>

<<function armcdt(arm)>>

<<function armunk(arm)>>

<<function armb(arm)>>

<<function armbpt(arm)>>

<<function armco(arm)>>

<<function armcondpass(arm)>>

<<function armshiftval(arm)>>

<<function nbits(arm)>>

<<function armmaddr(arm)>>

<<function armaddr(arm)>>

<<function armfadd(arm)>>

<<function armfbx(arm)>>

<<function armfmovm(arm)>>

<<function armfbranch(arm)>>

<<function armfmov(arm)>>

<<global opcodes(arm)>>

<<function gaddr(arm)>>

<<global mode(arm)>>
<<global pw(arm)>>
<<global sw(arm)>>

<<function format(arm)>>

<<function printins(arm)>>

<<function arminst(arm)>>

<<function armdas(arm)>>

<<function arminstlen(arm)>>

<<function armfoll(arm)>>
@


\subsection*{[[linkers/libmach/5obj.c]]}

<<struct Addr(arm)>>=
struct Addr
{
    char	type;
    char	sym;
    char	name;
};
@

<<function _is5(arm)>>=
int
_is5(char *s)
{
    return  s[0] == ANAME				/* ANAME */
        && s[1] == D_FILE			/* type */
        && s[2] == 1				/* sym */
        && s[3] == '<';				/* name of file */
}
@

<<function _read5(arm)>>=
int
_read5(Biobuf *bp, Prog *p)
{
    int as, n;
    Addr a;

    as = Bgetc(bp);			/* as */
    if(as < 0)
        return 0;
    p->kind = aNone;
    p->sig = 0;
    if(as == ANAME || as == ASIGNAME){
        if(as == ASIGNAME){
            Bread(bp, &p->sig, 4);
            p->sig = leswal(p->sig);
        }
        p->kind = aName;
        p->type = type2char(Bgetc(bp));		/* type */
        p->sym = Bgetc(bp);			/* sym */
        n = 0;
        for(;;) {
            as = Bgetc(bp);
            if(as < 0)
                return 0;
            n++;
            if(as == 0)
                break;
        }
        p->id = malloc(n);
        if(p->id == 0)
            return 0;
        Bseek(bp, -n, 1);
        if(Bread(bp, p->id, n) != n)
            return 0;
        return 1;
    }
    if(as == ATEXT)
        p->kind = aText;
    else if(as == AGLOBL)
        p->kind = aData;
    skip(bp, 6);		/* scond(1), reg(1), lineno(4) */
    a = addr(bp);
    addr(bp);
    if(a.type != D_OREG || a.name != D_STATIC && a.name != D_EXTERN)
        p->kind = aNone;
    p->sym = a.sym;
    return 1;
}
@

<<function addr(arm)>>=
static Addr
addr(Biobuf *bp)
{
    Addr a;
    long off;

    a.type = Bgetc(bp);	/* a.type */
    skip(bp,1);		/* reg */
    a.sym = Bgetc(bp);	/* sym index */
    a.name = Bgetc(bp);	/* sym type */
    switch(a.type){
    default:
    case D_NONE:
    case D_REG:
    case D_FREG:
    case D_PSR:
    case D_FPCR:
        break;
    case D_OREG:
    case D_CONST:
    case D_BRANCH:
    case D_SHIFT:
        off = Bgetc(bp);
        off |= Bgetc(bp) << 8;
        off |= Bgetc(bp) << 16;
        off |= Bgetc(bp) << 24;
        if(off < 0)
            off = -off;
        if(a.sym && (a.name==D_PARAM || a.name==D_AUTO))
            _offset(a.sym, off);
        break;
    case D_SCONST:
        skip(bp, NSNAME);
        break;
    case D_FCONST:
        skip(bp, 8);
        break;
    }
    return a;
}
@

<<function type2char(arm)>>=
static char
type2char(int t)
{
    switch(t){
    case D_EXTERN:		return 'U';
    case D_STATIC:		return 'b';
    case D_AUTO:		return 'a';
    case D_PARAM:		return 'p';
    default:		return UNKNOWN;
    }
}
@

<<function skip(arm)>>=
static void
skip(Biobuf *bp, int n)
{
    while (n-- > 0)
        Bgetc(bp);
}
@


%-------------------------------------------------------------

<<linkers/libmach/5obj.c>>=
/*
 * 5obj.c - identify and parse an arm object file
 */
#include <u.h>
#include <libc.h>
#include <bio.h>
#include <mach.h>

#include "arm/5.out.h"
#include "obj.h"

typedef struct Addr	Addr;
<<struct Addr(arm)>>
static Addr addr(Biobuf*);
static char type2char(int);
static void skip(Biobuf*, int);

<<function _is5(arm)>>

<<function _read5(arm)>>

<<function addr(arm)>>

<<function type2char(arm)>>

<<function skip(arm)>>
@




\subsection*{[[linkers/libmach/elf.h]]}

<<constant LOAD>>=
//TODO: could remove this file?
#define LOAD PT_LOAD
@


%-------------------------------------------------------------

<<linkers/libmach/elf.h>>=
// see include/elf.h
#include <elf.h>

<<constant LOAD>>

@


\subsection*{[[linkers/libmach/obj.h]]}

<<struct Prog (linkers/libmach/obj.h)>>=
struct Prog		/* info from .$O files */
{
    Kind	kind;		/* what kind of symbol */
    char	type;		/* type of the symbol: ie, 'T', 'a', etc. */
    char	sym;		/* index of symbol's name */
    char	*id;		/* name for the symbol, if it introduces one */
    uint	sig;		/* type signature for symbol */
};
@
%$


%-------------------------------------------------------------

<<linkers/libmach/obj.h>>=
/*
 * obj.h -- defs for dealing with object files
 */

typedef enum Kind		/* variable defs and references in obj */
{
    aNone,			/* we don't care about this prog */
    aName,			/* introduces a name */
    aText,			/* starts a function */
    aData,			/* references to a global object */
} Kind;

typedef struct	Prog	Prog;

<<struct Prog (linkers/libmach/obj.h)>>

<<constant UNKNOWN>>

void		_offset(int, vlong);
@


\subsection*{[[linkers/libmach/swap.c]]}

<<function beswab>>=
/*
 * big-endian short
 */
ushort
beswab(ushort s)
{
    uchar *p;

    p = (uchar*)&s;
    return (p[0]<<8) | p[1];
}
@

<<function beswal>>=
/*
 * big-endian long
 */
ulong
beswal(ulong l)
{
    uchar *p;

    p = (uchar*)&l;
    return (p[0]<<24) | (p[1]<<16) | (p[2]<<8) | p[3];
}
@

<<function beswav>>=
/*
 * big-endian vlong
 */
uvlong
beswav(uvlong v)
{
    uchar *p;

    p = (uchar*)&v;
    return ((uvlong)p[0]<<56) | ((uvlong)p[1]<<48) | ((uvlong)p[2]<<40)
                  | ((uvlong)p[3]<<32) | ((uvlong)p[4]<<24)
                  | ((uvlong)p[5]<<16) | ((uvlong)p[6]<<8)
                  | (uvlong)p[7];
}
@

<<function leswab>>=
/*
 * little-endian short
 */
ushort
leswab(ushort s)
{
    uchar *p;

    p = (uchar*)&s;
    return (p[1]<<8) | p[0];
}
@

<<function leswal>>=
/*
 * little-endian long
 */
ulong
leswal(ulong l)
{
    uchar *p;

    p = (uchar*)&l;
    return (p[3]<<24) | (p[2]<<16) | (p[1]<<8) | p[0];
}
@

<<function leswav>>=
/*
 * little-endian vlong
 */
uvlong
leswav(uvlong v)
{
    uchar *p;

    p = (uchar*)&v;
    return ((uvlong)p[7]<<56) | ((uvlong)p[6]<<48) | ((uvlong)p[5]<<40)
                  | ((uvlong)p[4]<<32) | ((uvlong)p[3]<<24)
                  | ((uvlong)p[2]<<16) | ((uvlong)p[1]<<8)
                  | (uvlong)p[0];
}
@


%-------------------------------------------------------------

<<linkers/libmach/swap.c>>=
#include <u.h>

<<function beswab>>

<<function beswal>>

<<function beswav>>

<<function leswab>>

<<function leswal>>

<<function leswav>>
@


\subsection*{[[linkers/libmach/executable.c]]}

<<struct Exectable>>=
/*
 *	definition of per-executable file type structures
 */
typedef struct Exectable{
    long	magic;			/* big-endian magic number of file */
    char	*name;			/* executable identifier */
    char	*dlmname;		/* dynamically loadable module identifier */
    uchar	type;			/* Internal code */
    uchar	_magic;			/* _MAGIC() magic */
    Mach	*mach;			/* Per-machine data */
    long	hsize;			/* header size */
    ulong	(*swal)(ulong);		/* beswal or leswal */
    int	(*hparse)(int, Fhdr*, ExecHdr*);
} ExecTable;
@

<<global exectab>>=
ExecTable exectab[] =
{
    { I_MAGIC,			/* I386 8.out & boot image */
        "386 plan 9 executable",
        "386 plan 9 dlm",
        FI386,
        1,
        &mi386,
        sizeof(Exec),
        beswal,
        common },
    { ELF_MAG,			/* any ELF */
        "elf executable",
        nil,
        FNONE,
        0,
        &mi386,
        sizeof(Ehdr),
        nil,
        elfdotout },
    { E_MAGIC,			/* Arm 5.out and boot image */
        "arm plan 9 executable",
        "arm plan 9 dlm",
        FARM,
        1,
        &marm,
        sizeof(Exec),
        beswal,
        common },

    { 0 },
};
@

<<global mach>>=
Mach	*mach = &mi386;			/* Global current machine table */
@


<<function crackhdr>>=
int
crackhdr(int fd, Fhdr *fp)
{
    ExecTable *mp;
    ExecHdr d;
    int nb, ret;
    ulong magic;

    fp->type = FNONE;
    nb = read(fd, (char *)&d.e, sizeof(d.e));
    if (nb <= 0)
        return 0;

    ret = 0;
    magic = beswal(d.e.magic);		/* big-endian */
    for (mp = exectab; mp->magic; mp++) {
        if (nb < mp->hsize)
            continue;

        /*
         * The magic number has morphed into something
         * with fields (the straw was DYN_MAGIC) so now
         * a flag is needed in Fhdr to distinguish _MAGIC()
         * magic numbers from foreign magic numbers.
         *
         * This code is creaking a bit and if it has to
         * be modified/extended much more it's probably
         * time to step back and redo it all.
         */
        if(mp->_magic){
            if(mp->magic != (magic & ~DYN_MAGIC))
                continue;

//            if(mp->magic == V_MAGIC)
//                mp = couldbe4k(mp);

            if ((magic & DYN_MAGIC) && mp->dlmname != nil)
                fp->name = mp->dlmname;
            else
                fp->name = mp->name;
        }
        else{
            if(mp->magic != magic)
                continue;
            fp->name = mp->name;
        }
        fp->type = mp->type;
        fp->hdrsz = mp->hsize;		/* will be zero on bootables */
        fp->_magic = mp->_magic;
        fp->magic = magic;

        mach = mp->mach;
        if(mp->swal != nil)
            hswal(&d, sizeof(d.e)/sizeof(ulong), mp->swal);
        ret = mp->hparse(fd, fp, &d);
        seek(fd, mp->hsize, 0);		/* seek to end of header */
        break;
    }
    if(mp->magic == 0)
        werrstr("unknown header type");
    return ret;
}
@

<<function hswal>>=
/*
 * Convert header to canonical form
 */
static void
hswal(void *v, int n, ulong (*swap)(ulong))
{
    ulong *ulp;

    for(ulp = v; n--; ulp++)
        *ulp = (*swap)(*ulp);
}
@

<<function adotout>>=
/*
 *	Crack a normal a.out-type header
 */
static int
adotout(int fd, Fhdr *fp, ExecHdr *hp)
{
    long pgsize;

    USED(fd);
    pgsize = mach->pgsize;
    settext(fp, hp->e.entry, pgsize+sizeof(Exec),
            hp->e.text, sizeof(Exec));
    setdata(fp, _round(pgsize+fp->txtsz+sizeof(Exec), pgsize),
        hp->e.data, fp->txtsz+sizeof(Exec), hp->e.bss);
    setsym(fp, hp->e.syms, hp->e.spsz, hp->e.pcsz, fp->datoff+fp->datsz);
    return 1;
}
@

<<function commonboot>>=
static void
commonboot(Fhdr *fp)
{
    if (!(fp->entry & mach->ktmask))
        return;

    switch(fp->type) {				/* boot image */
    case FI386:
        fp->type = FI386B;
        fp->txtaddr = (u32int)fp->entry;
        fp->name = "386 plan 9 boot image";
        fp->dataddr = _round(fp->txtaddr+fp->txtsz, mach->pgsize);
        break;
    case FARM:
        fp->type = FARMB;
        fp->txtaddr = (u32int)fp->entry;
        fp->name = "ARM plan 9 boot image";
        fp->dataddr = _round(fp->txtaddr+fp->txtsz, mach->pgsize);
        return;
    default:
        return;
    }
    fp->hdrsz = 0;			/* header stripped */
}
@

<<function common>>=
/*
 *	_MAGIC() style headers and
 *	alpha plan9-style bootable images for axp "headerless" boot
 *
 */
static int
common(int fd, Fhdr *fp, ExecHdr *hp)
{
    adotout(fd, fp, hp);
    if(hp->e.magic & DYN_MAGIC) {
        fp->txtaddr = 0;
        fp->dataddr = fp->txtsz;
        return 1;
    }
    commonboot(fp);
    return 1;
}
@



<<function elf32dotout>>=
/*
 * ELF32 binaries.
 */
static int
elf32dotout(int fd, Fhdr *fp, ExecHdr *hp)
{
    ulong (*swal)(ulong);
    ushort (*swab)(ushort);
    Ehdr *ep;
    Phdr *ph;
    int i, it, id, is, phsz;

    /* bitswap the header according to the DATA format */
    ep = &hp->e;
    if(ep->ident[DATA] == ELFDATA2LSB) {
        swab = leswab;
        swal = leswal;
    } else if(ep->ident[DATA] == ELFDATA2MSB) {
        swab = beswab;
        swal = beswal;
    } else {
        werrstr("bad ELF32 encoding - not big or little endian");
        return 0;
    }

    ep->type = swab(ep->type);
    ep->machine = swab(ep->machine);
    ep->version = swal(ep->version);
    ep->elfentry = swal(ep->elfentry);
    ep->phoff = swal(ep->phoff);
    ep->shoff = swal(ep->shoff);
    ep->flags = swal(ep->flags);
    ep->ehsize = swab(ep->ehsize);
    ep->phentsize = swab(ep->phentsize);
    ep->phnum = swab(ep->phnum);
    ep->shentsize = swab(ep->shentsize);
    ep->shnum = swab(ep->shnum);
    ep->shstrndx = swab(ep->shstrndx);
    if(ep->type != EXEC || ep->version != CURRENT)
        return 0;

    /* we could definitely support a lot more machines here */
    fp->magic = ELF_MAG;
    fp->hdrsz = (ep->ehsize+ep->phnum*ep->phentsize+16)&~15;
    switch(ep->machine) {
    case I386:
        mach = &mi386;
        fp->type = FI386;
        fp->name = "386 ELF32 executable";
        break;
    case ARM:
        mach = &marm;
        fp->type = FARM;
        fp->name = "arm ELF32 executable";
        break;
    default:
        return 0;
    }

    if(ep->phentsize != sizeof(Phdr)) {
        werrstr("bad ELF32 header size");
        return 0;
    }
    phsz = sizeof(Phdr)*ep->phnum;
    ph = malloc(phsz);
    if(!ph)
        return 0;
    seek(fd, ep->phoff, 0);
    if(read(fd, ph, phsz) < 0) {
        free(ph);
        return 0;
    }
    hswal(ph, phsz/sizeof(ulong), swal);

    /* find text, data and symbols and install them */
    it = id = is = -1;
    for(i = 0; i < ep->phnum; i++) {
        if(ph[i].type == LOAD
        && (ph[i].flags & (R|X)) == (R|X) && it == -1)
            it = i;
        else if(ph[i].type == LOAD
        && (ph[i].flags & (R|W)) == (R|W) && id == -1)
            id = i;
        else if(ph[i].type == NOPTYPE && is == -1)
            is = i;
    }
    if(it == -1 || id == -1) {
        /*
         * The SPARC64 boot image is something of an ELF hack.
         * Text+Data+BSS are represented by ph[0].  Symbols
         * are represented by ph[1]:
         *
         *		filesz, memsz, vaddr, paddr, off
         * ph[0] : txtsz+datsz, txtsz+datsz+bsssz, txtaddr-KZERO, datasize, txtoff
         * ph[1] : symsz, lcsz, 0, 0, symoff
         */
        if(ep->machine == SPARC64 && ep->phnum == 2) {
            ulong txtaddr, txtsz, dataddr, bsssz;

            txtaddr = ph[0].vaddr | 0x80000000;
            txtsz = ph[0].filesz - ph[0].paddr;
            dataddr = txtaddr + txtsz;
            bsssz = ph[0].memsz - ph[0].filesz;
            settext(fp, ep->elfentry | 0x80000000, txtaddr, txtsz, ph[0].offset);
            setdata(fp, dataddr, ph[0].paddr, ph[0].offset + txtsz, bsssz);
            setsym(fp, ph[1].filesz, 0, ph[1].memsz, ph[1].offset);
            free(ph);
            return 1;
        }

        werrstr("No ELF32 TEXT or DATA sections");
        free(ph);
        return 0;
    }

    settext(fp, ep->elfentry, ph[it].vaddr, ph[it].memsz, ph[it].offset);
    setdata(fp, ph[id].vaddr, ph[id].filesz, ph[id].offset, ph[id].memsz - ph[id].filesz);
    if(is != -1)
        setsym(fp, ph[is].filesz, 0, ph[is].memsz, ph[is].offset);
    free(ph);
    return 1;
}
@

<<function elfdotout>>=
/*
 * Elf binaries.
 */
static int
elfdotout(int fd, Fhdr *fp, ExecHdr *hp)
{
    Ehdr *ep;

    /* bitswap the header according to the DATA format */
    ep = &hp->e;
    if(ep->ident[CLASS] == ELFCLASS32)
        return elf32dotout(fd, fp, hp);
    werrstr("bad ELF class - not 32 bit");
    return 0;
}
@
%    //else if(ep->ident[CLASS] == ELFCLASS64)
%    //    return elf64dotout(fd, fp, hp);
%    //werrstr("bad ELF class - not 32- nor 64-bit");


%<<function elf64dotout>>=
%/*
% * ELF64 binaries.
% */
%static int
%elf64dotout(int fd, Fhdr *fp, ExecHdr *hp)
%{
%    E64hdr *ep;
%    P64hdr *ph;
%    ushort (*swab)(ushort);
%    ulong (*swal)(ulong);
%    uvlong (*swav)(uvlong);
%    int i, it, id, is, phsz;
%    uvlong uvl;
%
%    ep = &hp->e;
%    if(ep->ident[DATA] == ELFDATA2LSB) {
%        swab = leswab;
%        swal = leswal;
%        swav = leswav;
%    } else if(ep->ident[DATA] == ELFDATA2MSB) {
%        swab = beswab;
%        swal = beswal;
%        swav = beswav;
%    } else {
%        werrstr("bad ELF64 encoding - not big or little endian");
%        return 0;
%    }
%
%    ep->type = swab(ep->type);
%    ep->machine = swab(ep->machine);
%    ep->version = swal(ep->version);
%    if(ep->type != EXEC || ep->version != CURRENT)
%        return 0;
%    ep->elfentry = swav(ep->elfentry);
%    ep->phoff = swav(ep->phoff);
%    ep->shoff = swav(ep->shoff);
%    ep->flags = swal(ep->flags);
%    ep->ehsize = swab(ep->ehsize);
%    ep->phentsize = swab(ep->phentsize);
%    ep->phnum = swab(ep->phnum);
%    ep->shentsize = swab(ep->shentsize);
%    ep->shnum = swab(ep->shnum);
%    ep->shstrndx = swab(ep->shstrndx);
%
%    fp->magic = ELF_MAG;
%    fp->hdrsz = (ep->ehsize+ep->phnum*ep->phentsize+16)&~15;
%    switch(ep->machine) {
%    default:
%        return 0;
%    }
%
%    if(ep->phentsize != sizeof(P64hdr)) {
%        werrstr("bad ELF64 header size");
%        return 0;
%    }
%    phsz = sizeof(P64hdr)*ep->phnum;
%    ph = malloc(phsz);
%    if(!ph)
%        return 0;
%    seek(fd, ep->phoff, 0);
%    if(read(fd, ph, phsz) < 0) {
%        free(ph);
%        return 0;
%    }
%    for(i = 0; i < ep->phnum; i++) {
%        ph[i].type = swal(ph[i].type);
%        ph[i].flags = swal(ph[i].flags);
%        ph[i].offset = swav(ph[i].offset);
%        ph[i].vaddr = swav(ph[i].vaddr);
%        ph[i].paddr = swav(ph[i].paddr);
%        ph[i].filesz = swav(ph[i].filesz);
%        ph[i].memsz = swav(ph[i].memsz);
%        ph[i].align = swav(ph[i].align);
%    }
%
%    /* find text, data and symbols and install them */
%    it = id = is = -1;
%    for(i = 0; i < ep->phnum; i++) {
%        if(ph[i].type == LOAD
%        && (ph[i].flags & (R|X)) == (R|X) && it == -1)
%            it = i;
%        else if(ph[i].type == LOAD
%        && (ph[i].flags & (R|W)) == (R|W) && id == -1)
%            id = i;
%        else if(ph[i].type == NOPTYPE && is == -1)
%            is = i;
%    }
%    if(it == -1 || id == -1) {
%        werrstr("No ELF64 TEXT or DATA sections");
%        free(ph);
%        return 0;
%    }
%
%    settext(fp, ep->elfentry, ph[it].vaddr, ph[it].memsz, ph[it].offset);
%    /* 8c: out of fixed registers */
%    uvl = ph[id].memsz - ph[id].filesz;
%    setdata(fp, ph[id].vaddr, ph[id].filesz, ph[id].offset, uvl);
%    if(is != -1)
%        setsym(fp, ph[is].filesz, 0, ph[is].memsz, ph[is].offset);
%    free(ph);
%    return 1;
%}
%@


<<function armdotout>>=
/*
 * (Free|Net)BSD ARM header.
 */
static int
armdotout(int fd, Fhdr *fp, ExecHdr *hp)
{
    uvlong kbase;

    USED(fd);
    settext(fp, hp->e.entry, sizeof(Exec), hp->e.text, sizeof(Exec));
    setdata(fp, fp->txtsz, hp->e.data, fp->txtsz, hp->e.bss);
    setsym(fp, hp->e.syms, hp->e.spsz, hp->e.pcsz, fp->datoff+fp->datsz);

    kbase = 0xF0000000;
    if ((fp->entry & kbase) == kbase) {		/* Boot image */
        fp->txtaddr = kbase+sizeof(Exec);
        fp->name = "ARM *BSD boot image";
        fp->hdrsz = 0;		/* header stripped */
        fp->dataddr = kbase+fp->txtsz;
    }
    return 1;
}
@

<<function settext>>=
static void
settext(Fhdr *fp, uvlong e, uvlong a, long s, vlong off)
{
    fp->txtaddr = a;
    fp->entry = e;
    fp->txtsz = s;
    fp->txtoff = off;
}
@

<<function setdata>>=
static void
setdata(Fhdr *fp, uvlong a, long s, vlong off, long bss)
{
    fp->dataddr = a;
    fp->datsz = s;
    fp->datoff = off;
    fp->bsssz = bss;
}
@

<<function setsym>>=
static void
setsym(Fhdr *fp, long symsz, long sppcsz, long lnpcsz, vlong symoff)
{
    fp->symsz = symsz;
    fp->symoff = symoff;
    fp->sppcsz = sppcsz;
    fp->sppcoff = fp->symoff+fp->symsz;
    fp->lnpcsz = lnpcsz;
    fp->lnpcoff = fp->sppcoff+fp->sppcsz;
}
@

<<function _round>>=
static uvlong
_round(uvlong a, ulong b)
{
    uvlong w;

    w = (a/b)*b;
    if (a!=w)
        w += b;
    return(w);
}
@


%-------------------------------------------------------------

<<linkers/libmach/executable.c>>=
#include	<u.h>
#include	<libc.h>
#include	<bio.h>

#include	<bootexec.h>
#include	<mach.h>

#include	"elf.h"

/*
 *	All a.out header types.  The dummy entry allows canonical
 *	processing of the union as a sequence of longs
 */

typedef struct {
    union{
        struct {
            Exec;		/* a.out.h */
            uvlong hdr[1];
        };
        Ehdr;			/* elf.h */
    } e;
    long dummy;			/* padding to ensure extra long */
} ExecHdr;

static	int	common(int, Fhdr*, ExecHdr*);

static	int	adotout(int, Fhdr*, ExecHdr*);
static	int	elfdotout(int, Fhdr*, ExecHdr*);
static	int	armdotout(int, Fhdr*, ExecHdr*);

static	void	setsym(Fhdr*, long, long, long, vlong);
static	void	setdata(Fhdr*, uvlong, long, vlong, long);
static	void	settext(Fhdr*, uvlong, uvlong, long, vlong);
static	void	hswal(void*, int, ulong(*)(ulong));
static	uvlong	_round(uvlong, ulong);

<<struct Exectable>>

//PAD: removed many archi
extern	Mach	mi386;
extern	Mach	marm;

<<global exectab>>

<<global mach>>

<<function crackhdr>>

<<function hswal>>

<<function adotout>>

<<function commonboot>>

<<function common>>

<<function elf32dotout>>

<<function elfdotout>>

<<function armdotout>>

<<function settext>>

<<function setdata>>

<<function setsym>>


<<function _round>>
@


\subsection*{[[linkers/libmach/map.c]]}

<<function newmap>>=
Map *
newmap(Map *map, int n)
{
    int size;

    size = sizeof(Map)+(n-1)*sizeof(struct segment);
    if (map == 0)
        map = malloc(size);
    else
        map = realloc(map, size);
    if (map == 0) {
        werrstr("out of memory: %r");
        return 0;
    }
    memset(map, 0, size);
    map->nsegs = n;
    return map;
}
@

<<function setmap>>=
int
setmap(Map *map, int fd, uvlong b, uvlong e, vlong f, char *name)
{
    int i;

    if (map == 0)
        return 0;
    for (i = 0; i < map->nsegs; i++)
        if (!map->seg[i].inuse)
            break;
    if (i >= map->nsegs)
        return 0;
    map->seg[i].b = b;
    map->seg[i].e = e;
    map->seg[i].f = f;
    map->seg[i].inuse = 1;
    map->seg[i].name = name;
    map->seg[i].fd = fd;
    return 1;
}
@

<<function stacktop>>=
static uvlong
stacktop(int pid)
{
    char buf[64];
    int fd;
    int n;
    char *cp;

    snprint(buf, sizeof(buf), "/proc/%d/segment", pid);
    fd = open(buf, 0);
    if (fd < 0)
        return 0;
    n = read(fd, buf, sizeof(buf)-1);
    close(fd);
    buf[n] = 0;
    if (strncmp(buf, "Stack", 5))
        return 0;
    for (cp = buf+5; *cp && *cp == ' '; cp++)
        ;
    if (!*cp)
        return 0;
    cp = strchr(cp, ' ');
    if (!cp)
        return 0;
    while (*cp && *cp == ' ')
        cp++;
    if (!*cp)
        return 0;
    return strtoull(cp, 0, 16);
}
@

<<function attachproc>>=
Map*
attachproc(int pid, int kflag, int corefd, Fhdr *fp)
{
    char buf[64], *regs;
    int fd;
    Map *map;
    uvlong n;

    map = newmap(0, 4);
    if (!map)
        return 0;
    if(kflag)
        regs = "kregs";
    else
        regs = "regs";
    if (mach->regsize) {
        sprint(buf, "/proc/%d/%s", pid, regs);
        fd = open(buf, ORDWR);
        if(fd < 0)
            fd = open(buf, OREAD);
        if(fd < 0) {
            free(map);
            return 0;
        }
        setmap(map, fd, 0, mach->regsize, 0, "regs");
    }
    if (mach->fpregsize) {
        sprint(buf, "/proc/%d/fpregs", pid);
        fd = open(buf, ORDWR);
        if(fd < 0)
            fd = open(buf, OREAD);
        if(fd < 0) {
            close(map->seg[0].fd);
            free(map);
            return 0;
        }
        setmap(map, fd, mach->regsize, mach->regsize+mach->fpregsize, 0, "fpregs");
    }
    setmap(map, corefd, fp->txtaddr, fp->txtaddr+fp->txtsz, fp->txtaddr, "text");
    if(kflag || fp->dataddr >= mach->utop) {
        setmap(map, corefd, fp->dataddr, ~0, fp->dataddr, "data");
        return map;
    }
    n = stacktop(pid);
    if (n == 0) {
        setmap(map, corefd, fp->dataddr, mach->utop, fp->dataddr, "data");
        return map;
    }
    setmap(map, corefd, fp->dataddr, n, fp->dataddr, "data");
    return map;
}
@

<<function findseg>>=
int
findseg(Map *map, char *name)
{
    int i;

    if (!map)
        return -1;
    for (i = 0; i < map->nsegs; i++)
        if (map->seg[i].inuse && !strcmp(map->seg[i].name, name))
            return i;
    return -1;
}
@

<<function unusemap>>=
void
unusemap(Map *map, int i)
{
    if (map != 0 && 0 <= i && i < map->nsegs)
        map->seg[i].inuse = 0;
}
@

<<function loadmap>>=
Map*
loadmap(Map *map, int fd, Fhdr *fp)
{
    map = newmap(map, 2);
    if (map == 0)
        return 0;

    map->seg[0].b = fp->txtaddr;
    map->seg[0].e = fp->txtaddr+fp->txtsz;
    map->seg[0].f = fp->txtoff;
    map->seg[0].fd = fd;
    map->seg[0].inuse = 1;
    map->seg[0].name = "text";
    map->seg[1].b = fp->dataddr;
    map->seg[1].e = fp->dataddr+fp->datsz;
    map->seg[1].f = fp->datoff;
    map->seg[1].fd = fd;
    map->seg[1].inuse = 1;
    map->seg[1].name = "data";
    return map;
}
@


%-------------------------------------------------------------

<<linkers/libmach/map.c>>=
/*
 * file map routines
 */
#include <u.h>
#include <libc.h>
#include <bio.h>
#include <mach.h>

<<function newmap>>

<<function setmap>>

<<function stacktop>>

<<function attachproc>>
    
<<function findseg>>

<<function unusemap>>

<<function loadmap>>
@


\subsection*{[[linkers/libmach/sym.c]]}

<<constant HUGEINT>>=
#define	HUGEINT	0x7fffffff
@

<<constant NNAME>>=
#define	NNAME	20		/* a relic of the past */
@

<<struct txtsym>>=
struct txtsym {				/* Text Symbol table */
    int 	n;			/* number of local vars */
    Sym	**locals;		/* array of ptrs to autos */
    Sym	*sym;			/* function symbol entry */
};
@

<<struct hist>>=
struct hist {				/* Stack of include files & #line directives */
    char	*name;			/* Assumes names Null terminated in file */
    long	line;			/* line # where it was included */
    long	offset;			/* line # of #line directive */
};
@

<<struct file>>=
struct file {				/* Per input file header to history stack */
    uvlong	addr;			/* address of first text sym */
    union {
        Txtsym	*txt;		/* first text symbol */
        Sym	*sym;		/* only during initilization */
    };
    int	n;			/* size of history stack */
    Hist	*hist;			/* history stack */
};
@

<<global debug (linkers/libmach/sym.c)>>=
static	int	debug = 0;
@

<<global autos>>=
static	Sym	**autos;		/* Base of auto variables */
@

<<global files>>=
static	File	*files;			/* Base of file arena */
@

<<global fmax>>=
static	int	fmax;			/* largest file path index */
@

<<global fnames (linkers/libmach/sym.c)>>=
static	Sym	**fnames;		/* file names path component table */
@

<<global globals>>=
static	Sym	**globals;		/* globals by addr table */
@

<<global hist>>=
static	Hist	*hist;			/* base of history stack */
@

<<global isbuilt>>=
static	int	isbuilt;		/* internal table init flag */
@

<<global nauto>>=
static	long	nauto;			/* number of automatics */
@

<<global nfiles>>=
static	long	nfiles;			/* number of files */
@

<<global nglob>>=
static	long	nglob;			/* number of globals */
@

<<global nhist>>=
static	long	nhist;			/* number of history stack entries */
@

<<global nsym (linkers/libmach/sym.c)>>=
static	long	nsym;			/* number of symbols */
@

<<global ntxt>>=
static	int	ntxt;			/* number of text symbols */
@

<<global pcline>>=
static	uchar	*pcline;		/* start of pc-line state table */
@

<<global pclineend>>=
static	uchar 	*pclineend;		/* end of pc-line table */
@

<<global spoff>>=
static	uchar	*spoff;			/* start of pc-sp state table */
@

<<global spoffend>>=
static	uchar	*spoffend;		/* end of pc-sp offset table */
@

<<global symbols>>=
static	Sym	*symbols;		/* symbol table */
@

<<global txt>>=
static	Txtsym	*txt;			/* Base of text symbol table */
@

<<global txtstart>>=
static	uvlong	txtstart;		/* start of text segment */
@

<<global txtend>>=
static	uvlong	txtend;			/* end of text segment */
@

<<function syminit>>=
/*
 *	initialize the symbol tables
 */
int
syminit(int fd, Fhdr *fp)
{
    Sym *p;
    long i, l, size;
    vlong vl;
    Biobuf b;
    int svalsz;

    if(fp->symsz == 0)
        return 0;
    if(fp->type == FNONE)
        return 0;

    cleansyms();
    textseg(fp->txtaddr, fp);
        /* minimum symbol record size = 4+1+2 bytes */
    symbols = malloc((fp->symsz/(4+1+2)+1)*sizeof(Sym));
    if(symbols == 0) {
        werrstr("can't malloc %ld bytes", fp->symsz);
        return -1;
    }
    Binit(&b, fd, OREAD);
    Bseek(&b, fp->symoff, 0);
    nsym = 0;
    size = 0;
    if((fp->_magic && (fp->magic & HDR_MAGIC)) || mach->szaddr == 8)
        svalsz = 8;
    else
        svalsz = 4;
    for(p = symbols; size < fp->symsz; p++, nsym++) {
        if(svalsz == 8){
            if(Bread(&b, &vl, 8) != 8)
                return symerrmsg(8, "symbol");
            p->value = beswav(vl);
        }
        else{
            if(Bread(&b, &l, 4) != 4)
                return symerrmsg(4, "symbol");
            p->value = (u32int)beswal(l);
        }
        if(Bread(&b, &p->type, sizeof(p->type)) != sizeof(p->type))
            return symerrmsg(sizeof(p->value), "symbol");

        i = decodename(&b, p);
        if(i < 0)
            return -1;
        size += i+svalsz+sizeof(p->type);

        /* count global & auto vars, text symbols, and file names */
        switch (p->type) {
        case 'l':
        case 'L':
        case 't':
        case 'T':
            ntxt++;
            break;
        case 'd':
        case 'D':
        case 'b':
        case 'B':
            nglob++;
            break;
        case 'f':
            if(strcmp(p->name, ".frame") == 0) {
                p->type = 'm';
                nauto++;
            }
            else if(p->value > fmax)
                fmax = p->value;	/* highest path index */
            break;
        case 'a':
        case 'p':
        case 'm':
            nauto++;
            break;
        case 'z':
            if(p->value == 1) {		/* one extra per file */
                nhist++;
                nfiles++;
            }
            nhist++;
            break;
        default:
            break;
        }
    }
    if (debug)
        print("NG: %ld NT: %d NF: %d\n", nglob, ntxt, fmax);
    if (fp->sppcsz) {			/* pc-sp offset table */
        spoff = (uchar *)malloc(fp->sppcsz);
        if(spoff == 0) {
            werrstr("can't malloc %ld bytes", fp->sppcsz);
            return -1;
        }
        Bseek(&b, fp->sppcoff, 0);
        if(Bread(&b, spoff, fp->sppcsz) != fp->sppcsz){
            spoff = 0;
            return symerrmsg(fp->sppcsz, "sp-pc");
        }
        spoffend = spoff+fp->sppcsz;
    }
    if (fp->lnpcsz) {			/* pc-line number table */
        pcline = (uchar *)malloc(fp->lnpcsz);
        if(pcline == 0) {
            werrstr("can't malloc %ld bytes", fp->lnpcsz);
            return -1;
        }
        Bseek(&b, fp->lnpcoff, 0);
        if(Bread(&b, pcline, fp->lnpcsz) != fp->lnpcsz){
            pcline = 0;
            return symerrmsg(fp->lnpcsz, "pc-line");
        }
        pclineend = pcline+fp->lnpcsz;
    }
    return nsym;
}
@

<<function symerrmsg>>=
static int
symerrmsg(int n, char *table)
{
    werrstr("can't read %d bytes of %s table", n, table);
    return -1;
}
@

<<function decodename>>=
static long
decodename(Biobuf *bp, Sym *p)
{
    char *cp;
    int c1, c2;
    long n;
    vlong o;

    if((p->type & 0x80) == 0) {		/* old-style, fixed length names */
        p->name = malloc(NNAME);
        if(p->name == 0) {
            werrstr("can't malloc %d bytes", NNAME);
            return -1;
        }
        if(Bread(bp, p->name, NNAME) != NNAME)
            return symerrmsg(NNAME, "symbol");
        Bseek(bp, 3, 1);
        return NNAME+3;
    }

    p->type &= ~0x80;
    if(p->type == 'z' || p->type == 'Z') {
        o = Bseek(bp, 0, 1);
        if(Bgetc(bp) < 0) {
            werrstr("can't read symbol name");
            return -1;
        }
        for(;;) {
            c1 = Bgetc(bp);
            c2 = Bgetc(bp);
            if(c1 < 0 || c2 < 0) {
                werrstr("can't read symbol name");
                return -1;
            }
            if(c1 == 0 && c2 == 0)
                break;
        }
        n = Bseek(bp, 0, 1)-o;
        p->name = malloc(n);
        if(p->name == 0) {
            werrstr("can't malloc %ld bytes", n);
            return -1;
        }
        Bseek(bp, -n, 1);
        if(Bread(bp, p->name, n) != n) {
            werrstr("can't read %ld bytes of symbol name", n);
            return -1;
        }
    } else {
        cp = Brdline(bp, '\0');
        if(cp == 0) {
            werrstr("can't read symbol name");
            return -1;
        }
        n = Blinelen(bp);
        p->name = malloc(n);
        if(p->name == 0) {
            werrstr("can't malloc %ld bytes", n);
            return -1;
        }
        strcpy(p->name, cp);
    }
    return n;
}
@

<<function cleansyms>>=
/*
 *	free any previously loaded symbol tables
 */
static void
cleansyms(void)
{
    if(globals)
        free(globals);
    globals = 0;
    nglob = 0;
    if(txt)
        free(txt);
    txt = 0;
    ntxt = 0;
    if(fnames)
        free(fnames);
    fnames = 0;
    fmax = 0;

    if(files)
        free(files);
    files = 0;
    nfiles = 0;
    if(hist)
        free(hist);
    hist = 0;
    nhist = 0;
    if(autos)
        free(autos);
    autos = 0;
    nauto = 0;
    isbuilt = 0;
    if(symbols)
        free(symbols);
    symbols = 0;
    nsym = 0;
    if(spoff)
        free(spoff);
    spoff = 0;
    if(pcline)
        free(pcline);
    pcline = 0;
}
@

<<function textseg>>=
/*
 *	delimit the text segment
 */
void
textseg(uvlong base, Fhdr *fp)
{
    txtstart = base;
    txtend = base+fp->txtsz;
}
@

<<function symbase>>=
/*
 *	symbase: return base and size of raw symbol table
 *		(special hack for high access rate operations)
 */
Sym *
symbase(long *n)
{
    *n = nsym;
    return symbols;
}
@

<<function getsym>>=
/*
 *	Get the ith symbol table entry
 */
Sym *
getsym(int index)
{
    if(index >= 0 && index < nsym)
        return &symbols[index];
    return 0;
}
@

<<function buildtbls>>=
/*
 *	initialize internal symbol tables
 */
static int
buildtbls(void)
{
    long i;
    int j, nh, ng, nt;
    File *f;
    Txtsym *tp;
    Hist *hp;
    Sym *p, **ap;

    if(isbuilt)
        return 1;
    isbuilt = 1;
            /* allocate the tables */
    if(nglob) {
        globals = malloc(nglob*sizeof(*globals));
        if(!globals) {
            werrstr("can't malloc global symbol table");
            return 0;
        }
    }
    if(ntxt) {
        txt = malloc(ntxt*sizeof(*txt));
        if (!txt) {
            werrstr("can't malloc text symbol table");
            return 0;
        }
    }
    fnames = malloc((fmax+1)*sizeof(*fnames));
    if (!fnames) {
        werrstr("can't malloc file name table");
        return 0;
    }
    memset(fnames, 0, (fmax+1)*sizeof(*fnames));
    files = malloc(nfiles*sizeof(*files));
    if(!files) {
        werrstr("can't malloc file table");
        return 0;
    }
    hist = malloc(nhist*sizeof(Hist));
    if(hist == 0) {
        werrstr("can't malloc history stack");
        return 0;
    }
    autos = malloc(nauto*sizeof(Sym*));
    if(autos == 0) {
        werrstr("can't malloc auto symbol table");
        return 0;
    }
        /* load the tables */
    ng = nt = nh = 0;
    f = 0;
    tp = 0;
    i = nsym;
    hp = hist;
    ap = autos;
    for(p = symbols; i-- > 0; p++) {
        switch(p->type) {
        case 'D':
        case 'd':
        case 'B':
        case 'b':
            if(debug)
                print("Global: %s %llux\n", p->name, p->value);
            globals[ng++] = p;
            break;
        case 'z':
            if(p->value == 1) {		/* New file */
                if(f) {
                    f->n = nh;
                    f->hist[nh].name = 0;	/* one extra */
                    hp += nh+1;
                    f++;
                }
                else
                    f = files;
                f->hist = hp;
                f->sym = 0;
                f->addr = 0;
                nh = 0;
            }
                /* alloc one slot extra as terminator */
            f->hist[nh].name = p->name;
            f->hist[nh].line = p->value;
            f->hist[nh].offset = 0;
            if(debug)
                printhist("-> ", &f->hist[nh], 1);
            nh++;
            break;
        case 'Z':
            if(f && nh > 0)
                f->hist[nh-1].offset = p->value;
            break;
        case 'T':
        case 't':	/* Text: terminate history if first in file */
        case 'L':
        case 'l':
            tp = &txt[nt++];
            tp->n = 0;
            tp->sym = p;
            tp->locals = ap;
            if(debug)
                print("TEXT: %s at %llux\n", p->name, p->value);
            if(f && !f->sym) {			/* first  */
                f->sym = p;
                f->addr = p->value;
            }
            break;
        case 'a':
        case 'p':
        case 'm':		/* Local Vars */
            if(!tp)
                print("Warning: Free floating local var: %s\n",
                    p->name);
            else {
                if(debug)
                    print("Local: %s %llux\n", p->name, p->value);
                tp->locals[tp->n] = p;
                tp->n++;
                ap++;
            }
            break;
        case 'f':		/* File names */
            if(debug)
                print("Fname: %s\n", p->name);
            fnames[p->value] = p;
            break;
        default:
            break;
        }
    }
        /* sort global and text tables into ascending address order */
    qsort(globals, nglob, sizeof(Sym*), symcomp);
    qsort(txt, ntxt, sizeof(Txtsym), txtcomp);
    qsort(files, nfiles, sizeof(File), filecomp);
    tp = txt;
    for(i = 0, f = files; i < nfiles; i++, f++) {
        for(j = 0; j < ntxt; j++) {
            if(f->sym == tp->sym) {
                if(debug) {
                    print("LINK: %s to at %llux", f->sym->name, f->addr);
                    printhist("... ", f->hist, 1);
                }
                f->txt = tp++;
                break;
            }
            if(++tp >= txt+ntxt)	/* wrap around */
                tp = txt;
        }
    }
    return 1;
}
@

<<function lookup (linkers/libmach/sym.c)>>=
/*
 * find symbol function.var by name.
 *	fn != 0 && var != 0	=> look for fn in text, var in data
 *	fn != 0 && var == 0	=> look for fn in text
 *	fn == 0 && var != 0	=> look for var first in text then in data space.
 */
int
lookup(char *fn, char *var, Symbol *s)
{
    int found;

    if(buildtbls() == 0)
        return 0;
    if(fn) {
        found = findtext(fn, s);
        if(var == 0)		/* case 2: fn not in text */
            return found;
        else if(!found)		/* case 1: fn not found */
            return 0;
    } else if(var) {
        found = findtext(var, s);
        if(found)
            return 1;	/* case 3: var found in text */
    } else return 0;		/* case 4: fn & var == zero */

    if(found)
        return findlocal(s, var, s);	/* case 1: fn found */
    return findglobal(var, s);		/* case 3: var not found */

}
@

<<function findtext>>=
/*
 * find a function by name
 */
static int
findtext(char *name, Symbol *s)
{
    int i;

    for(i = 0; i < ntxt; i++) {
        if(strcmp(txt[i].sym->name, name) == 0) {
            fillsym(txt[i].sym, s);
            s->handle = (void *) &txt[i];
            s->index = i;
            return 1;
        }
    }
    return 0;
}
@

<<function findglobal>>=
/*
 * find global variable by name
 */
static int
findglobal(char *name, Symbol *s)
{
    long i;

    for(i = 0; i < nglob; i++) {
        if(strcmp(globals[i]->name, name) == 0) {
            fillsym(globals[i], s);
            s->index = i;
            return 1;
        }
    }
    return 0;
}
@

<<function findlocal>>=
/*
 *	find the local variable by name within a given function
 */
int
findlocal(Symbol *s1, char *name, Symbol *s2)
{
    if(s1 == 0)
        return 0;
    if(buildtbls() == 0)
        return 0;
    return findlocvar(s1, name, s2);
}
@

<<function findlocvar>>=
/*
 *	find the local variable by name within a given function
 *		(internal function - does no parameter validation)
 */
static int
findlocvar(Symbol *s1, char *name, Symbol *s2)
{
    Txtsym *tp;
    int i;

    tp = (Txtsym *)s1->handle;
    if(tp && tp->locals) {
        for(i = 0; i < tp->n; i++)
            if (strcmp(tp->locals[i]->name, name) == 0) {
                fillsym(tp->locals[i], s2);
                s2->handle = (void *)tp;
                s2->index = tp->n-1 - i;
                return 1;
            }
    }
    return 0;
}
@

<<function textsym>>=
/*
 *	Get ith text symbol
 */
int
textsym(Symbol *s, int index)
{

    if(buildtbls() == 0)
        return 0;
    if(index < 0 || index >= ntxt)
        return 0;
    fillsym(txt[index].sym, s);
    s->handle = (void *)&txt[index];
    s->index = index;
    return 1;
}
@

<<function filesym>>=
/*	
 *	Get ith file name
 */
int
filesym(int index, char *buf, int n)
{
    Hist *hp;

    if(buildtbls() == 0)
        return 0;
    if(index < 0 || index >= nfiles)
        return 0;
    hp = files[index].hist;
    if(!hp || !hp->name)
        return 0;
    return fileelem(fnames, (uchar*)hp->name, buf, n);
}
@

<<function getauto>>=
/*
 *	Lookup name of local variable located at an offset into the frame.
 *	The type selects either a parameter or automatic.
 */
int
getauto(Symbol *s1, int off, int type, Symbol *s2)
{
    Txtsym *tp;
    Sym *p;
    int i, t;

    if(s1 == 0)
        return 0;
    if(type == CPARAM)
        t = 'p';
    else if(type == CAUTO)
        t = 'a';
    else
        return 0;
    if(buildtbls() == 0)
        return 0;
    tp = (Txtsym *)s1->handle;
    if(tp == 0)
        return 0;
    for(i = 0; i < tp->n; i++) {
        p = tp->locals[i];
        if(p->type == t && p->value == off) {
            fillsym(p, s2);
            s2->handle = s1->handle;
            s2->index = tp->n-1 - i;
            return 1;
        }
    }
    return 0;
}
@

<<function srchtext>>=
/*
 * Find text symbol containing addr; binary search assumes text array is sorted by addr
 */
static int
srchtext(uvlong addr)
{
    uvlong val;
    int top, bot, mid;
    Sym *sp;

    val = addr;
    bot = 0;
    top = ntxt;
    for (mid = (bot+top)/2; mid < top; mid = (bot+top)/2) {
        sp = txt[mid].sym;
        if(sp == nil)
            return -1;
        if(val < sp->value)
            top = mid;
        else if(mid != ntxt-1 && val >= txt[mid+1].sym->value)
            bot = mid;
        else
            return mid;
    }
    return -1;
}
@

<<function srchdata>>=
/*
 * Find data symbol containing addr; binary search assumes data array is sorted by addr
 */
static int
srchdata(uvlong addr)
{
    uvlong val;
    int top, bot, mid;
    Sym *sp;

    bot = 0;
    top = nglob;
    val = addr;
    for(mid = (bot+top)/2; mid < top; mid = (bot+top)/2) {
        sp = globals[mid];
        if(sp == nil)
            return -1;
        if(val < sp->value)
            top = mid;
        else if(mid < nglob-1 && val >= globals[mid+1]->value)
            bot = mid;
        else
            return mid;
    }
    return -1;
}
@

<<function findsym>>=
/*
 * Find symbol containing val in specified search space
 * There is a special case when a value falls beyond the end
 * of the text segment; if the search space is CTEXT, that value
 * (usually etext) is returned.  If the search space is CANY, symbols in the
 * data space are searched for a match.
 */
int
findsym(uvlong val, int type, Symbol *s)
{
    int i;

    if(buildtbls() == 0)
        return 0;

    if(type == CTEXT || type == CANY) {
        i = srchtext(val);
        if(i >= 0) {
            if(type == CTEXT || i != ntxt-1) {
                fillsym(txt[i].sym, s);
                s->handle = (void *) &txt[i];
                s->index = i;
                return 1;
            }
        }
    }
    if(type == CDATA || type == CANY) {
        i = srchdata(val);
        if(i >= 0) {
            fillsym(globals[i], s);
            s->index = i;
            return 1;
        }
    }
    return 0;
}
@

<<function fnbound>>=
/*
 *	Find the start and end address of the function containing addr
 */
int
fnbound(uvlong addr, uvlong *bounds)
{
    int i;

    if(buildtbls() == 0)
        return 0;

    i = srchtext(addr);
    if(0 <= i && i < ntxt-1) {
        bounds[0] = txt[i].sym->value;
        bounds[1] = txt[i+1].sym->value;
        return 1;
    }
    return 0;
}
@

<<function localsym>>=
/*
 * get the ith local symbol for a function
 * the input symbol table is reverse ordered, so we reverse
 * accesses here to maintain approx. parameter ordering in a stack trace.
 */
int
localsym(Symbol *s, int index)
{
    Txtsym *tp;

    if(s == 0 || index < 0)
        return 0;
    if(buildtbls() == 0)
        return 0;

    tp = (Txtsym *)s->handle;
    if(tp && tp->locals && index < tp->n) {
        fillsym(tp->locals[tp->n-index-1], s);	/* reverse */
        s->handle = (void *)tp;
        s->index = index;
        return 1;
    }
    return 0;
}
@

<<function globalsym>>=
/*
 * get the ith global symbol
 */
int
globalsym(Symbol *s, int index)
{
    if(s == 0)
        return 0;
    if(buildtbls() == 0)
        return 0;

    if(index >=0 && index < nglob) {
        fillsym(globals[index], s);
        s->index = index;
        return 1;
    }
    return 0;
}
@

<<function file2pc>>=
/*
 *	find the pc given a file name and line offset into it.
 */
uvlong
file2pc(char *file, long line)
{
    File *fp;
    long i;
    uvlong pc, start, end;
    short *name;

    if(buildtbls() == 0 || files == 0)
        return ~0;
    name = encfname(file);
    if(name == 0) {			/* encode the file name */
        werrstr("file %s not found", file);
        return ~0;
    } 
        /* find this history stack */
    for(i = 0, fp = files; i < nfiles; i++, fp++)
        if (hline(fp, name, &line))
            break;
    free(name);
    if(i >= nfiles) {
        werrstr("line %ld in file %s not found", line, file);
        return ~0;
    }
    start = fp->addr;		/* first text addr this file */
    if(i < nfiles-1)
        end = (fp+1)->addr;	/* first text addr next file */
    else
        end = 0;		/* last file in load module */
    /*
     * At this point, line contains the offset into the file.
     * run the state machine to locate the pc closest to that value.
     */
    if(debug)
        print("find pc for %ld - between: %llux and %llux\n", line, start, end);
    pc = line2addr(line, start, end);
    if(pc == ~0) {
        werrstr("line %ld not in file %s", line, file);
        return ~0;
    }
    return pc;
}
@

<<function pathcomp>>=
/*
 *	search for a path component index
 */
static int
pathcomp(char *s, int n)
{
    int i;

    for(i = 0; i <= fmax; i++)
        if(fnames[i] && strncmp(s, fnames[i]->name, n) == 0)
            return i;
    return -1;
}
@

<<function encfname>>=
/*
 *	Encode a char file name as a sequence of short indices
 *	into the file name dictionary.
 */
static short*
encfname(char *file)
{
    int i, j;
    char *cp, *cp2;
    short *dest;

    if(*file == '/')	/* always check first '/' */
        cp2 = file+1;
    else {
        cp2 = strchr(file, '/');
        if(!cp2)
            cp2 = strchr(file, 0);
    }
    cp = file;
    dest = 0;
    for(i = 0; *cp; i++) {
        j = pathcomp(cp, cp2-cp);
        if(j < 0)
            return 0;	/* not found */
        dest = realloc(dest, (i+1)*sizeof(short));
        dest[i] = j;
        cp = cp2;
        while(*cp == '/')	/* skip embedded '/'s */
            cp++;
        cp2 = strchr(cp, '/');
        if(!cp2)
            cp2 = strchr(cp, 0);
    }
    dest = realloc(dest, (i+1)*sizeof(short));
    dest[i] = 0;
    return dest;
}
@

<<function hline>>=
/*
 *	Search a history stack for a matching file name accumulating
 *	the size of intervening files in the stack.
 */
static int
hline(File *fp, short *name, long *line)
{
    Hist *hp;
    int offset, depth;
    long ln;

    for(hp = fp->hist; hp->name; hp++)		/* find name in stack */
        if(hp->name[1] || hp->name[2]) {
            if(hcomp(hp, name))
                break;
        }
    if(!hp->name)		/* match not found */
        return 0;
    if(debug)
        printhist("hline found ... ", hp, 1);
    /*
     * unwind the stack until empty or we hit an entry beyond our line
     */
    ln = *line;
    offset = hp->line-1;
    depth = 1;
    for(hp++; depth && hp->name; hp++) {
        if(debug)
            printhist("hline inspect ... ", hp, 1);
        if(hp->name[1] || hp->name[2]) {
            if(hp->offset){			/* Z record */
                offset = 0;
                if(hcomp(hp, name)) {
                    if(*line <= hp->offset)
                        break;
                    ln = *line+hp->line-hp->offset;
                    depth = 1;	/* implicit pop */
                } else
                    depth = 2;	/* implicit push */
            } else if(depth == 1 && ln < hp->line-offset)
                    break;		/* Beyond our line */
            else if(depth++ == 1)		/* push	*/
                offset -= hp->line;
        } else if(--depth == 1)		/* pop */
            offset += hp->line;	
    }
    *line = ln+offset;
    return 1;
}
@

<<function hcomp>>=
/*
 *	compare two encoded file names
 */
static int
hcomp(Hist *hp, short *sp)
{
    uchar *cp;
    int i, j;
    short *s;

    cp = (uchar *)hp->name;
    s = sp;
    if (*s == 0)
        return 0;
    for (i = 1; j = (cp[i]<<8)|cp[i+1]; i += 2) {
        if(j == 0)
            break;
        if(*s == j)
            s++;
        else
            s = sp;
    }
    return *s == 0;
}
@

<<function fileline>>=
/*
 *	Convert a pc to a "file:line {file:line}" string.
 */
long
fileline(char *str, int n, uvlong dot)
{
    long line, top, bot, mid;
    File *f;

    *str = 0;
    if(buildtbls() == 0)
        return 0;
        /* binary search assumes file list is sorted by addr */
    bot = 0;
    top = nfiles;
    for (mid = (bot+top)/2; mid < top; mid = (bot+top)/2) {
        f = &files[mid];
        if(dot < f->addr)
            top = mid;
        else if(mid < nfiles-1 && dot >= (f+1)->addr)
            bot = mid;
        else {
            line = pc2line(dot);
            if(line > 0 && fline(str, n, line, f->hist, 0) >= 0)
                return 1;
            break;
        }
    }
    return 0;
}
@

<<function fline>>=
/*
 *	Convert a line number within a composite file to relative line
 *	number in a source file.  A composite file is the source
 *	file with included files inserted in line.
 */
static int
fline(char *str, int n, long line, Hist *base, Hist **ret)
{
    Hist *start;			/* start of current level */
    Hist *h;			/* current entry */
    long delta;			/* sum of size of files this level */
    int k;

    start = base;
    h = base;
    delta = h->line;
    while(h && h->name && line > h->line) {
        if(h->name[1] || h->name[2]) {
            if(h->offset != 0) {	/* #line Directive */
                delta = h->line-h->offset+1;
                start = h;
                base = h++;
            } else {		/* beginning of File */
                if(start == base)
                    start = h++;
                else {
                    k = fline(str, n, line, start, &h);
                    if(k <= 0)
                        return k;
                }
            }
        } else {
            if(start == base && ret) {	/* end of recursion level */
                *ret = h;
                return 1;
            } else {			/* end of included file */
                delta += h->line-start->line;
                h++;
                start = base;
            }
        }
    }
    if(!h)
        return -1;
    if(start != base)
        line = line-start->line+1;
    else
        line = line-delta+1;
    if(!h->name)
        strncpy(str, "<eof>", n);
    else {
        k = fileelem(fnames, (uchar*)start->name, str, n);
        if(k+8 < n)
            sprint(str+k, ":%ld", line);
    }
/**********Remove comments for complete back-trace of include sequence
 *	if(start != base) {
 *		k = strlen(str);
 *		if(k+2 < n) {
 *			str[k++] = ' ';
 *			str[k++] = '{';
 *		}
 *		k += fileelem(fnames, (uchar*) base->name, str+k, n-k);
 *		if(k+10 < n)
 *			sprint(str+k, ":%ld}", start->line-delta);
 *	}
 ********************/
    return 0;
}
@

<<function fileelem>>=
/*
 *	convert an encoded file name to a string.
 */
int
fileelem(Sym **fp, uchar *cp, char *buf, int n)
{
    int i, j;
    char *c, *bp, *end;
    Sym *sym;

    bp = buf;
    end = buf+n-1;
    for(i = 1; j = (cp[i]<<8)|cp[i+1]; i+=2){
        sym = fp[j];
        if (sym == nil)
            break;
        c = sym->name;
        if(bp != buf && bp[-1] != '/' && bp < end)
            *bp++ = '/';
        while(bp < end && *c)
            *bp++ = *c++;
    }
    *bp = 0;
    i =  bp-buf;
    if(i > 1) {
        cleanname(buf);
        i = strlen(buf);
    }
    return i;
}
@

<<function symcomp>>=
/*
 *	compare the values of two symbol table entries.
 */
static int
symcomp(void *a, void *b)
{
    int i;

    i = (*(Sym**)a)->value - (*(Sym**)b)->value;
    if (i)
        return i;
    return strcmp((*(Sym**)a)->name, (*(Sym**)b)->name);
}
@

<<function txtcomp>>=
/*
 *	compare the values of the symbols referenced by two text table entries
 */
static int
txtcomp(void *a, void *b)
{
    return ((Txtsym*)a)->sym->value - ((Txtsym*)b)->sym->value;
}
@

<<function filecomp>>=
/*
 *	compare the values of the symbols referenced by two file table entries
 */
static int
filecomp(void *a, void *b)
{
    return ((File*)a)->addr - ((File*)b)->addr;
}
@

<<function fillsym>>=
/*
 *	fill an interface Symbol structure from a symbol table entry
 */
static void
fillsym(Sym *sp, Symbol *s)
{
    s->type = sp->type;
    s->value = sp->value;
    s->name = sp->name;
    s->index = 0;
    switch(sp->type) {
    case 'b':
    case 'B':
    case 'D':
    case 'd':
        s->class = CDATA;
        break;
    case 't':
    case 'T':
    case 'l':
    case 'L':
        s->class = CTEXT;
        break;
    case 'a':
        s->class = CAUTO;
        break;
    case 'p':
        s->class = CPARAM;
        break;
    case 'm':
        s->class = CSTAB;
        break;
    default:
        s->class = CNONE;
        break;
    }
    s->handle = 0;
}
@

<<function pc2sp>>=
/*
 *	find the stack frame, given the pc
 */
uvlong
pc2sp(uvlong pc)
{
    uchar *c, u;
    uvlong currpc, currsp;

    if(spoff == 0)
        return ~0;
    currsp = 0;
    currpc = txtstart - mach->pcquant;

    if(pc<currpc || pc>txtend)
        return ~0;
    for(c = spoff; c < spoffend; c++) {
        if (currpc >= pc)
            return currsp;
        u = *c;
        if (u == 0) {
            currsp += (c[1]<<24)|(c[2]<<16)|(c[3]<<8)|c[4];
            c += 4;
        }
        else if (u < 65)
            currsp += 4*u;
        else if (u < 129)
            currsp -= 4*(u-64);
        else 
            currpc += mach->pcquant*(u-129);
        currpc += mach->pcquant;
    }
    return ~0;
}
@

<<function pc2line>>=
/*
 *	find the source file line number for a given value of the pc
 */
long
pc2line(uvlong pc)
{
    uchar *c, u;
    uvlong currpc;
    long currline;

    if(pcline == 0)
        return -1;
    currline = 0;
    currpc = txtstart-mach->pcquant;
    if(pc<currpc || pc>txtend)
        return ~0;

    for(c = pcline; c < pclineend; c++) {
        if(currpc >= pc)
            return currline;
        u = *c;
        if(u == 0) {
            currline += (c[1]<<24)|(c[2]<<16)|(c[3]<<8)|c[4];
            c += 4;
        }
        else if(u < 65)
            currline += u;
        else if(u < 129)
            currline -= (u-64);
        else 
            currpc += mach->pcquant*(u-129);
        currpc += mach->pcquant;
    }
    return ~0;
}
@

<<function line2addr>>=
/*
 *	find the pc associated with a line number
 *	basepc and endpc are text addresses bounding the search.
 *	if endpc == 0, the end of the table is used (i.e., no upper bound).
 *	usually, basepc and endpc contain the first text address in
 *	a file and the first text address in the following file, respectively.
 */
uvlong
line2addr(long line, uvlong basepc, uvlong endpc)
{
    uchar *c,  u;
    uvlong currpc, pc;
    long currline;
    long delta, d;
    int found;

    if(pcline == 0 || line == 0)
        return ~0;

    currline = 0;
    currpc = txtstart-mach->pcquant;
    pc = ~0;
    found = 0;
    delta = HUGEINT;

    for(c = pcline; c < pclineend; c++) {
        if(endpc && currpc >= endpc)	/* end of file of interest */
            break;
        if(currpc >= basepc) {		/* proper file */
            if(currline >= line) {
                d = currline-line;
                found = 1;
            } else
                d = line-currline;
            if(d < delta) {
                delta = d;
                pc = currpc;
            }
        }
        u = *c;
        if(u == 0) {
            currline += (c[1]<<24)|(c[2]<<16)|(c[3]<<8)|c[4];
            c += 4;
        }
        else if(u < 65)
            currline += u;
        else if(u < 129)
            currline -= (u-64);
        else 
            currpc += mach->pcquant*(u-129);
        currpc += mach->pcquant;
    }
    if(found)
        return pc;
    return ~0;
}
@

<<function printhist>>=
/*
 *	Print a history stack (debug). if count is 0, prints the whole stack
 */
static void
printhist(char *msg, Hist *hp, int count)
{
    int i;
    uchar *cp;
    char buf[128];

    i = 0;
    while(hp->name) {
        if(count && ++i > count)
            break;
        print("%s Line: %lx (%ld)  Offset: %lx (%ld)  Name: ", msg,
            hp->line, hp->line, hp->offset, hp->offset);
        for(cp = (uchar *)hp->name+1; (*cp<<8)|cp[1]; cp += 2) {
            if (cp != (uchar *)hp->name+1)
                print("/");
            print("%x", (*cp<<8)|cp[1]);
        }
        fileelem(fnames, (uchar *) hp->name, buf, sizeof(buf));
        print(" (%s)\n", buf);
        hp++;
    }
}
@

<<function dumphist>>=
/*
 *	print the history stack for a file. (debug only)
 *	if (name == 0) => print all history stacks.
 */
void
dumphist(char *name)
{
    int i;
    File *f;
    short *fname;

    if(buildtbls() == 0)
        return;
    if(name)
        fname = encfname(name);
    for(i = 0, f = files; i < nfiles; i++, f++)
        if(fname == 0 || hcomp(f->hist, fname))
            printhist("> ", f->hist, f->n);

    if(fname)
        free(fname);
}
@


%-------------------------------------------------------------

<<linkers/libmach/sym.c>>=
#include <u.h>
#include <libc.h>
#include <bio.h>
#include <mach.h>

<<constant HUGEINT>>
<<constant NNAME>>

typedef	struct txtsym Txtsym;
typedef	struct file File;
typedef	struct hist Hist;

<<struct txtsym>>

<<struct hist>>

<<struct file>>

<<global debug (linkers/libmach/sym.c)>>

<<global autos>>
<<global files>>
<<global fmax>>
<<global fnames (linkers/libmach/sym.c)>>
<<global globals>>
<<global hist>>
<<global isbuilt>>
<<global nauto>>
<<global nfiles>>
<<global nglob>>
<<global nhist>>
<<global nsym (linkers/libmach/sym.c)>>
<<global ntxt>>
<<global pcline>>
<<global pclineend>>
<<global spoff>>
<<global spoffend>>
<<global symbols>>
<<global txt>>
<<global txtstart>>
<<global txtend>>

static void	cleansyms(void);
static long	decodename(Biobuf*, Sym*);
static short	*encfname(char*);
static int 	fline(char*, int, long, Hist*, Hist**);
static void	fillsym(Sym*, Symbol*);
static int	findglobal(char*, Symbol*);
static int	findlocvar(Symbol*, char *, Symbol*);
static int	findtext(char*, Symbol*);
static int	hcomp(Hist*, short*);
static int	hline(File*, short*, long*);
static void	printhist(char*, Hist*, int);
static int	buildtbls(void);
static int	symcomp(void*, void*);
static int	symerrmsg(int, char*);
static int	txtcomp(void*, void*);
static int	filecomp(void*, void*);

<<function syminit>>

<<function symerrmsg>>

<<function decodename>>

<<function cleansyms>>

<<function textseg>>

<<function symbase>>

<<function getsym>>

<<function buildtbls>>

<<function lookup (linkers/libmach/sym.c)>>

<<function findtext>>
<<function findglobal>>

<<function findlocal>>

<<function findlocvar>>

<<function textsym>>

<<function filesym>>

<<function getauto>>

<<function srchtext>>

<<function srchdata>>

<<function findsym>>

<<function fnbound>>

<<function localsym>>

<<function globalsym>>

<<function file2pc>>

<<function pathcomp>>

<<function encfname>>

<<function hline>>

<<function hcomp>>

<<function fileline>>

<<function fline>>

<<function fileelem>>

<<function symcomp>>

<<function txtcomp>>

<<function filecomp>>

<<function fillsym>>

<<function pc2sp>>

<<function pc2line>>

<<function line2addr>>

<<function printhist>>

#ifdef DEBUG
<<function dumphist>>
#endif
@


\subsection*{[[linkers/libmach/access.c]]}

<<function geta>>=
/*
 * routines to get/put various types
 */
int
geta(Map *map, uvlong addr, uvlong *x)
{
    ulong l;
    uvlong vl;

    if (mach->szaddr == 8){
        if (get8(map, addr, &vl) < 0)
            return -1;
        *x = vl;
        return 1;
    }

    if (get4(map, addr, &l) < 0)
        return -1;
    *x = l;

    return 1;
}
@

<<function get8>>=
int
get8(Map *map, uvlong addr, uvlong *x)
{
    if (!map) {
        werrstr("get8: invalid map");
        return -1;
    }

    if (map->nsegs == 1 && map->seg[0].fd < 0) {
        *x = addr;
        return 1;
    }
    if (mget(map, addr, x, 8) < 0)
        return -1;
    *x = machdata->swav(*x);
    return 1;
}
@

<<function get4>>=
int
get4(Map *map, uvlong addr, ulong *x)
{
    if (!map) {
        werrstr("get4: invalid map");
        return -1;
    }

    if (map->nsegs == 1 && map->seg[0].fd < 0) {
        *x = addr;
        return 1;
    }
    if (mget(map, addr, x, 4) < 0)
        return -1;
    *x = machdata->swal(*x);
    return 1;
}
@

<<function get2>>=
int
get2(Map *map, uvlong addr, ushort *x)
{
    if (!map) {
        werrstr("get2: invalid map");
        return -1;
    }

    if (map->nsegs == 1 && map->seg[0].fd < 0) {
        *x = addr;
        return 1;
    }
    if (mget(map, addr, x, 2) < 0)
        return -1;
    *x = machdata->swab(*x);
    return 1;
}
@

<<function get1>>=
int
get1(Map *map, uvlong addr, uchar *x, int size)
{
    uchar *cp;

    if (!map) {
        werrstr("get1: invalid map");
        return -1;
    }

    if (map->nsegs == 1 && map->seg[0].fd < 0) {
        cp = (uchar*)&addr;
        while (cp < (uchar*)(&addr+1) && size-- > 0)
            *x++ = *cp++;
        while (size-- > 0)
            *x++ = 0;
    } else
        return mget(map, addr, x, size);
    return 1;
}
@

<<function puta>>=
int
puta(Map *map, uvlong addr, uvlong v)
{
    if (mach->szaddr == 8)
        return put8(map, addr, v);

    return put4(map, addr, v);
}
@

<<function put8>>=
int
put8(Map *map, uvlong addr, uvlong v)
{
    if (!map) {
        werrstr("put8: invalid map");
        return -1;
    }
    v = machdata->swav(v);
    return mput(map, addr, &v, 8);
}
@

<<function put4 (linkers/libmach/access.c)>>=
int
put4(Map *map, uvlong addr, ulong v)
{
    if (!map) {
        werrstr("put4: invalid map");
        return -1;
    }
    v = machdata->swal(v);
    return mput(map, addr, &v, 4);
}
@

<<function put2>>=
int
put2(Map *map, uvlong addr, ushort v)
{
    if (!map) {
        werrstr("put2: invalid map");
        return -1;
    }
    v = machdata->swab(v);
    return mput(map, addr, &v, 2);
}
@

<<function put1>>=
int
put1(Map *map, uvlong addr, uchar *v, int size)
{
    if (!map) {
        werrstr("put1: invalid map");
        return -1;
    }
    return mput(map, addr, v, size);
}
@

<<function spread>>=
static int
spread(struct segment *s, void *buf, int n, uvlong off)
{
    uvlong base;

    static struct {
        struct segment *s;
        char a[8192];
        uvlong off;
    } cache;

    if(s->cache){
        base = off&~(sizeof cache.a-1);
        if(cache.s != s || cache.off != base){
            cache.off = ~0;
            if(seek(s->fd, base, 0) >= 0
            && readn(s->fd, cache.a, sizeof cache.a) == sizeof cache.a){
                cache.s = s;
                cache.off = base;
            }
        }
        if(cache.s == s && cache.off == base){
            off &= sizeof cache.a-1;
            if(off+n > sizeof cache.a)
                n = sizeof cache.a - off;
            memmove(buf, cache.a+off, n);
            return n;
        }
    }

    return pread(s->fd, buf, n, off);
}
@

<<function mget>>=
static int
mget(Map *map, uvlong addr, void *buf, int size)
{
    uvlong off;
    int i, j, k;
    struct segment *s;

    s = reloc(map, addr, (vlong*)&off);
    if (!s)
        return -1;
    if (s->fd < 0) {
        werrstr("unreadable map");
        return -1;
    }
    for (i = j = 0; i < 2; i++) {	/* in case read crosses page */
        k = spread(s, (void*)((uchar *)buf+j), size-j, off+j);
        if (k < 0) {
            werrstr("can't read address %llux: %r", addr);
            return -1;
        }
        j += k;
        if (j == size)
            return j;
    }
    werrstr("partial read at address %llux (size %d j %d)", addr, size, j);
    return -1;
}
@

<<function mput>>=
static int
mput(Map *map, uvlong addr, void *buf, int size)
{
    vlong off;
    int i, j, k;
    struct segment *s;

    s = reloc(map, addr, &off);
    if (!s)
        return -1;
    if (s->fd < 0) {
        werrstr("unwritable map");
        return -1;
    }

    seek(s->fd, off, 0);
    for (i = j = 0; i < 2; i++) {	/* in case read crosses page */
        k = write(s->fd, buf, size-j);
        if (k < 0) {
            werrstr("can't write address %llux: %r", addr);
            return -1;
        }
        j += k;
        if (j == size)
            return j;
    }
    werrstr("partial write at address %llux", addr);
    return -1;
}
@

<<function reloc>>=
/*
 *	convert address to file offset; returns nonzero if ok
 */
static struct segment*
reloc(Map *map, uvlong addr, vlong *offp)
{
    int i;

    for (i = 0; i < map->nsegs; i++) {
        if (map->seg[i].inuse)
        if (map->seg[i].b <= addr && addr < map->seg[i].e) {
            *offp = addr + map->seg[i].f - map->seg[i].b;
            return &map->seg[i];
        }
    }
    werrstr("can't translate address %llux", addr);
    return 0;
}
@


%-------------------------------------------------------------

<<linkers/libmach/access.c>>=
/*
 * functions to read and write an executable or file image
 */

#include <u.h>
#include <libc.h>
#include <bio.h>
#include <mach.h>

static	int	mget(Map*, uvlong, void*, int);
static	int	mput(Map*, uvlong, void*, int);
static	struct	segment*	reloc(Map*, uvlong, vlong*);

<<function geta>>

<<function get8>>

<<function get4>>

<<function get2>>

<<function get1>>

<<function puta>>

<<function put8>>

<<function put4 (linkers/libmach/access.c)>>

<<function put2>>

<<function put1>>

<<function spread>>

<<function mget>>

<<function mput>>

<<function reloc>>
@


\subsection*{[[linkers/libmach/machdata.c]]}

<<constant STARTSYM>>=
#define STARTSYM	"_main"
@

<<constant PROFSYM>>=
#define PROFSYM		"_mainp"
@

<<constant FRAMENAME>>=
#define	FRAMENAME	".frame"
@

<<global asstype>>=
int	asstype = AARM;		/* disassembler type */
@

<<global machdata>>=
Machdata *machdata;		/* machine-dependent functions */
@

<<function localaddr>>=
int
localaddr(Map *map, char *fn, char *var, uvlong *r, Rgetter rget)
{
    Symbol s;
    uvlong fp, pc, sp, link;

    if (!lookup(fn, 0, &s)) {
        werrstr("function not found");
        return -1;
    }
    pc = rget(map, mach->pc);
    sp = rget(map, mach->sp);
    if(mach->link)
        link = rget(map, mach->link);
    else
        link = 0;
    fp = machdata->findframe(map, s.value, pc, sp, link);
    if (fp == 0) {
        werrstr("stack frame not found");
        return -1;
    }

    if (!var || !var[0]) {
        *r = fp;
        return 1;
    }

    if (findlocal(&s, var, &s) == 0) {
        werrstr("local variable not found");
        return -1;
    }

    switch (s.class) {
    case CAUTO:
        *r = fp - s.value;
        break;
    case CPARAM:		/* assume address size is stack width */
        *r = fp + s.value + mach->szaddr;
        break;
    default:
        werrstr("local variable not found: %d", s.class);
        return -1;
    }
    return 1;
}
@

<<function symoff>>=
/*
 * Print value v as s.name[+offset] if possible, or just v.
 */
int
symoff(char *buf, int n, uvlong v, int space)
{
    Symbol s;
    int r;
    long delta;

    r = delta = 0;		/* to shut compiler up */
    if (v) {
        r = findsym(v, space, &s);
        if (r)
            delta = v-s.value;
        if (delta < 0)
            delta = -delta;
    }
    if (v == 0 || r == 0)
        return snprint(buf, n, "%llux", v);
    if (s.type != 't' && s.type != 'T' && delta >= 4096)
        return snprint(buf, n, "%llux", v);
    else if (delta)
        return snprint(buf, n, "%s+%lux", s.name, delta);
    else
        return snprint(buf, n, "%s", s.name);
}
@

<<function fpformat>>=
/*
 *	Format floating point registers
 *
 *	Register codes in format field:
 *	'X' - print as 32-bit hexadecimal value
 *	'F' - 64-bit double register when modif == 'F'; else 32-bit single reg
 *	'f' - 32-bit ieee float
 *	'8' - big endian 80-bit ieee extended float
 *	'3' - little endian 80-bit ieee extended float with hole in bytes 8&9
 */
int
fpformat(Map *map, Reglist *rp, char *buf, int n, int modif)
{
    char reg[12];
    ulong r;

    switch(rp->rformat)
    {
    case 'X':
        if (get4(map, rp->roffs, &r) < 0)
            return -1;
        snprint(buf, n, "%lux", r);
        break;
    case 'F':	/* first reg of double reg pair */
        if (modif == 'F')
        if ((rp->rformat=='F') || (((rp+1)->rflags&RFLT) && (rp+1)->rformat == 'f')) {
            if (get1(map, rp->roffs, (uchar *)reg, 8) < 0)
                return -1;
            machdata->dftos(buf, n, reg);
            if (rp->rformat == 'F')
                return 1;
            return 2;
        }	
            /* treat it like 'f' */
        if (get1(map, rp->roffs, (uchar *)reg, 4) < 0)
            return -1;
        machdata->sftos(buf, n, reg);
        break;
    case 'f':	/* 32 bit float */
        if (get1(map, rp->roffs, (uchar *)reg, 4) < 0)
            return -1;
        machdata->sftos(buf, n, reg);
        break;
    case '3':	/* little endian ieee 80 with hole in bytes 8&9 */
        if (get1(map, rp->roffs, (uchar *)reg, 10) < 0)
            return -1;
        memmove(reg+10, reg+8, 2);	/* open hole */
        memset(reg+8, 0, 2);		/* fill it */
        leieee80ftos(buf, n, reg);
        break;
    case '8':	/* big-endian ieee 80 */
        if (get1(map, rp->roffs, (uchar *)reg, 10) < 0)
            return -1;
        beieee80ftos(buf, n, reg);
        break;
    default:	/* unknown */
        break;
    }
    return 1;
}
@

<<function _hexify>>=
char *
_hexify(char *buf, ulong p, int zeros)
{
    ulong d;

    d = p/16;
    if(d)
        buf = _hexify(buf, d, zeros-1);
    else
        while(zeros--)
            *buf++ = '0';
    *buf++ = "0123456789abcdef"[p&0x0f];
    return buf;
}
@

<<function ieeedftos>>=
/*
 * These routines assume that if the number is representable
 * in IEEE floating point, it will be representable in the native
 * double format.  Naive but workable, probably.
 */
int
ieeedftos(char *buf, int n, ulong h, ulong l)
{
    double fr;
    int exp;

    if (n <= 0)
        return 0;


    if(h & (1L<<31)){
        *buf++ = '-';
        h &= ~(1L<<31);
    }else
        *buf++ = ' ';
    n--;
    if(l == 0 && h == 0)
        return snprint(buf, n, "0.");
    exp = (h>>20) & ((1L<<11)-1L);
    if(exp == 0)
        return snprint(buf, n, "DeN(%.8lux%.8lux)", h, l);
    if(exp == ((1L<<11)-1L)){
        if(l==0 && (h&((1L<<20)-1L)) == 0)
            return snprint(buf, n, "Inf");
        else
            return snprint(buf, n, "NaN(%.8lux%.8lux)", h&((1L<<20)-1L), l);
    }
    exp -= (1L<<10) - 2L;
    fr = l & ((1L<<16)-1L);
    fr /= 1L<<16;
    fr += (l>>16) & ((1L<<16)-1L);
    fr /= 1L<<16;
    fr += (h & (1L<<20)-1L) | (1L<<20);
    fr /= 1L<<21;
    fr = ldexp(fr, exp);
    return snprint(buf, n, "%.18g", fr);
}
@

<<function ieeesftos>>=
int
ieeesftos(char *buf, int n, ulong h)
{
    double fr;
    int exp;

    if (n <= 0)
        return 0;

    if(h & (1L<<31)){
        *buf++ = '-';
        h &= ~(1L<<31);
    }else
        *buf++ = ' ';
    n--;
    if(h == 0)
        return snprint(buf, n, "0.");
    exp = (h>>23) & ((1L<<8)-1L);
    if(exp == 0)
        return snprint(buf, n, "DeN(%.8lux)", h);
    if(exp == ((1L<<8)-1L)){
        if((h&((1L<<23)-1L)) == 0)
            return snprint(buf, n, "Inf");
        else
            return snprint(buf, n, "NaN(%.8lux)", h&((1L<<23)-1L));
    }
    exp -= (1L<<7) - 2L;
    fr = (h & ((1L<<23)-1L)) | (1L<<23);
    fr /= 1L<<24;
    fr = ldexp(fr, exp);
    return snprint(buf, n, "%.9g", fr);
}
@

<<function beieeesftos>>=
int
beieeesftos(char *buf, int n, void *s)
{
    return ieeesftos(buf, n, beswal(*(ulong*)s));
}
@

<<function beieeedftos>>=
int
beieeedftos(char *buf, int n, void *s)
{
    return ieeedftos(buf, n, beswal(*(ulong*)s), beswal(((ulong*)(s))[1]));
}
@

<<function leieeesftos>>=
int
leieeesftos(char *buf, int n, void *s)
{
    return ieeesftos(buf, n, leswal(*(ulong*)s));
}
@

<<function leieeedftos>>=
int
leieeedftos(char *buf, int n, void *s)
{
    return ieeedftos(buf, n, leswal(((ulong*)(s))[1]), leswal(*(ulong*)s));
}
@

<<function beieee80ftos>>=
/* packed in 12 bytes, with s[2]==s[3]==0; mantissa starts at s[4]*/
int
beieee80ftos(char *buf, int n, void *s)
{
    uchar *reg = (uchar*)s;
    int i;
    ulong x;
    uchar ieee[8+8];	/* room for slop */
    uchar *p, *q;

    memset(ieee, 0, sizeof(ieee));
    /* sign */
    if(reg[0] & 0x80)
        ieee[0] |= 0x80;

    /* exponent */
    x = ((reg[0]&0x7F)<<8) | reg[1];
    if(x == 0)		/* number is 0 */
        goto done;
    if(x == 0x7FFF){
        if(memcmp(reg+4, ieee+1, 8) == 0){ /* infinity */
            x = 2047;
        }else{				/* NaN */
            x = 2047;
            ieee[7] = 0x1;		/* make sure */
        }
        ieee[0] |= x>>4;
        ieee[1] |= (x&0xF)<<4;
        goto done;
    }
    x -= 0x3FFF;		/* exponent bias */
    x += 1023;
    if(x >= (1<<11) || ((reg[4]&0x80)==0 && x!=0))
        return snprint(buf, n, "not in range");
    ieee[0] |= x>>4;
    ieee[1] |= (x&0xF)<<4;

    /* mantissa */
    p = reg+4;
    q = ieee+1;
    for(i=0; i<56; i+=8, p++, q++){	/* move one byte */
        x = (p[0]&0x7F) << 1;
        if(p[1] & 0x80)
            x |= 1;
        q[0] |= x>>4;
        q[1] |= (x&0xF)<<4;
    }
    done:
    return beieeedftos(buf, n, (void*)ieee);
}
@

<<function leieee80ftos>>=
int
leieee80ftos(char *buf, int n, void *s)
{
    int i;
    char *cp;
    char b[12];

    cp = (char*) s;
    for(i=0; i<12; i++)
        b[11-i] = *cp++;
    return beieee80ftos(buf, n, b);
}
@

<<function cisctrace>>=
int
cisctrace(Map *map, uvlong pc, uvlong sp, uvlong link, Tracer trace)
{
    Symbol s;
    int found, i;
    uvlong opc, moved;

    USED(link);
    i = 0;
    opc = 0;
    while(pc && opc != pc) {
        moved = pc2sp(pc);
        if (moved == ~0)
            break;
        found = findsym(pc, CTEXT, &s);
        if (!found)
            break;
        if(strcmp(STARTSYM, s.name) == 0 || strcmp(PROFSYM, s.name) == 0)
            break;

        sp += moved;
        opc = pc;
        if (geta(map, sp, &pc) < 0)
            break;
        (*trace)(map, pc, sp, &s);
        sp += mach->szaddr;	/*assumes address size = stack width*/
        if(++i > 40)
            break;
    }
    return i;
}
@

<<function risctrace>>=
int
risctrace(Map *map, uvlong pc, uvlong sp, uvlong link, Tracer trace)
{
    int i;
    Symbol s, f;
    uvlong oldpc;

    i = 0;
    while(findsym(pc, CTEXT, &s)) {
        if(strcmp(STARTSYM, s.name) == 0 || strcmp(PROFSYM, s.name) == 0)
            break;

        if(pc == s.value)	/* at first instruction */
            f.value = 0;
        else if(findlocal(&s, FRAMENAME, &f) == 0)
            break;

        oldpc = pc;
        if(s.type == 'L' || s.type == 'l' || pc <= s.value+mach->pcquant)
            pc = link;
        else
            if (geta(map, sp, &pc) < 0)
                break;

        if(pc == 0 || (pc == oldpc && f.value == 0))
            break;

        sp += f.value;
        (*trace)(map, pc-8, sp, &s);

        if(++i > 40)
            break;
    }
    return i;
}
@

<<function ciscframe>>=
uvlong
ciscframe(Map *map, uvlong addr, uvlong pc, uvlong sp, uvlong link)
{
    Symbol s;
    uvlong moved;

    USED(link);
    for(;;) {
        moved = pc2sp(pc);
        if (moved  == ~0)
            break;
        sp += moved;
        findsym(pc, CTEXT, &s);
        if (addr == s.value)
            return sp;
        if (geta(map, sp, &pc) < 0)
            break;
        sp += mach->szaddr;	/*assumes sizeof(addr) = stack width*/
    }
    return 0;
}
@

<<function riscframe>>=
uvlong
riscframe(Map *map, uvlong addr, uvlong pc, uvlong sp, uvlong link)
{
    Symbol s, f;

    while (findsym(pc, CTEXT, &s)) {
        if(strcmp(STARTSYM, s.name) == 0 || strcmp(PROFSYM, s.name) == 0)
            break;

        if(pc == s.value)	/* at first instruction */
            f.value = 0;
        else
        if(findlocal(&s, FRAMENAME, &f) == 0)
            break;

        sp += f.value;
        if (s.value == addr)
            return sp;

        if (s.type == 'L' || s.type == 'l' || pc-s.value <= mach->szaddr*2)
            pc = link;
        else
        if (geta(map, sp-f.value, &pc) < 0)
            break;
    }
    return 0;
}
@


%-------------------------------------------------------------

<<linkers/libmach/machdata.c>>=
/*
 * Debugger utilities shared by at least two architectures
 */

#include <u.h>
#include <libc.h>
#include <bio.h>
#include <mach.h>

<<constant STARTSYM>>
<<constant PROFSYM>>
<<constant FRAMENAME>>

extern	Machdata	mipsmach;

<<global asstype>>
<<global machdata>>

<<function localaddr>>

<<function symoff>>

<<function fpformat>>

<<function _hexify>>

<<function ieeedftos>>

<<function ieeesftos>>

<<function beieeesftos>>

<<function beieeedftos>>

<<function leieeesftos>>

<<function leieeedftos>>

<<function beieee80ftos>>

<<function leieee80ftos>>

<<function cisctrace>>

<<function risctrace>>

<<function ciscframe>>

<<function riscframe>>
@


\subsection*{[[linkers/libmach/obj.c]]}

<<function islocal>>=
#define islocal(t)	((t)=='a' || (t)=='p')
@

<<enum _anon_ (linkers/libmach/obj.c)>>=
enum
{
    NNAMES	= 50,
    MAXIS	= 8,		/* max length to determine if a file is a .? file */
    MAXOFF	= 0x7fffffff,	/* larger than any possible local offset */
    NHASH	= 1024,		/* must be power of two */
    HASHMUL	= 79L,
};
@

<<struct Obj>>=
struct	Obj		/* functions to handle each intermediate (.$O) file */
{
    char	*name;				/* name of each $O file */
    int	(*is)(char*);			/* test for each type of $O file */
    int	(*read)(Biobuf*, Prog*);	/* read for each type of $O file*/
};
@

<<global obj>>=
static Obj	obj[] =
{			/* functions to identify and parse each type of obj */
    [ObjArm]	"arm .5",	_is5, _read5,
    [Obj386]	"386 .8",	_is8, _read8,
    [Maxobjtype]	0, 0
};
@

<<struct Symtab>>=
struct	Symtab
{
    struct	Sym 	s;
    struct	Symtab	*next;
};
@

<<global hash (linkers/libmach/obj.c)>>=
static	Symtab *hash[NHASH];
@

<<global names>>=
static	Sym	*names[NNAMES];	/* working set of active names */
@

<<function objtype>>=
int
objtype(Biobuf *bp, char **name)
{
    int i;
    char buf[MAXIS];

    if(Bread(bp, buf, MAXIS) < MAXIS)
        return -1;
    Bseek(bp, -MAXIS, 1);
    for (i = 0; i < Maxobjtype; i++) {
        if (obj[i].is && (*obj[i].is)(buf)) {
            if (name)
                *name = obj[i].name;
            return i;
        }
    }
    return -1;
}
@

<<function isar>>=
int
isar(Biobuf *bp)
{
    int n;
    char magbuf[SARMAG];

    n = Bread(bp, magbuf, SARMAG);
    if(n == SARMAG && strncmp(magbuf, ARMAG, SARMAG) == 0)
        return 1;
    return 0;
}
@

<<function readobj>>=
/*
 * determine what kind of object file this is and process it.
 * return whether or not this was a recognized intermediate file.
 */
int
readobj(Biobuf *bp, int objtype)
{
    Prog p;

    if (objtype < 0 || objtype >= Maxobjtype || obj[objtype].is == 0)
        return 1;
    objreset();
    while ((*obj[objtype].read)(bp, &p))
        if (!processprog(&p, 1))
            return 0;
    return 1;
}
@

<<function readar>>=
int
readar(Biobuf *bp, int objtype, vlong end, int doautos)
{
    Prog p;

    if (objtype < 0 || objtype >= Maxobjtype || obj[objtype].is == 0)
        return 1;
    objreset();
    while ((*obj[objtype].read)(bp, &p) && Boffset(bp) < end)
        if (!processprog(&p, doautos))
            return 0;
    return 1;
}
@

<<function processprog>>=
/*
 *	decode a symbol reference or definition
 */
static	int
processprog(Prog *p, int doautos)
{
    if(p->kind == aNone)
        return 1;
    if(p->sym < 0 || p->sym >= NNAMES)
        return 0;
    switch(p->kind)
    {
    case aName:
        if (!doautos)
        if(p->type != 'U' && p->type != 'b')
            break;
        objlookup(p->sym, p->id, p->type, p->sig);
        break;
    case aText:
        objupdate(p->sym, 'T');
        break;
    case aData:
        objupdate(p->sym, 'D');
        break;
    default:
        break;
    }
    return 1;
}
@

<<function objlookup>>=
/*
 * find the entry for s in the symbol array.
 * make a new entry if it is not already there.
 */
static void
objlookup(int id, char *name, int type, uint sig)
{
    long h;
    char *cp;
    Sym *s;
    Symtab *sp;

    s = names[id];
    if(s && strcmp(s->name, name) == 0) {
        s->type = type;
        s->sig = sig;
        return;
    }

    h = *name;
    for(cp = name+1; *cp; h += *cp++)
        h *= HASHMUL;
    if(h < 0)
        h = ~h;
    h &= (NHASH-1);
    if (type == 'U' || type == 'b' || islocal(type)) {
        for(sp = hash[h]; sp; sp = sp->next)
            if(strcmp(sp->s.name, name) == 0) {
                switch(sp->s.type) {
                case 'T':
                case 'D':
                case 'U':
                    if (type == 'U') {
                        names[id] = &sp->s;
                        return;
                    }
                    break;
                case 't':
                case 'd':
                case 'b':
                    if (type == 'b') {
                        names[id] = &sp->s;
                        return;
                    }
                    break;
                case 'a':
                case 'p':
                    if (islocal(type)) {
                        names[id] = &sp->s;
                        return;
                    }
                    break;
                default:
                    break;
                }
            }
    }
    sp = malloc(sizeof(Symtab));
    sp->s.name = name;
    sp->s.type = type;
    sp->s.sig = sig;
    sp->s.value = islocal(type) ? MAXOFF : 0;
    names[id] = &sp->s;
    sp->next = hash[h];
    hash[h] = sp;
    return;
}
@

<<function objtraverse>>=
/*
 *	traverse the symbol lists
 */
void
objtraverse(void (*fn)(Sym*, void*), void *pointer)
{
    int i;
    Symtab *s;

    for(i = 0; i < NHASH; i++)
        for(s = hash[i]; s; s = s->next)
            (*fn)(&s->s, pointer);
}
@

<<function _offset>>=
/*
 * update the offset information for a 'a' or 'p' symbol in an intermediate file
 */
void
_offset(int id, vlong off)
{
    Sym *s;

    s = names[id];
    if (s && s->name[0] && islocal(s->type) && s->value > off)
        s->value = off;
}
@

<<function objupdate>>=
/*
 * update the type of a global text or data symbol
 */
static void 
objupdate(int id, int type)
{
    Sym *s;

    s = names[id];
    if (s && s->name[0])
        if (s->type == 'U')
            s->type = type;
        else if (s->type == 'b')
            s->type = tolower(type);
}
@

<<function nextar>>=
/*
 * look for the next file in an archive
 */
int
nextar(Biobuf *bp, int offset, char *buf)
{
    struct ar_hdr a;
    int i, r;
    long arsize;

    if (offset&01)
        offset++;
    Bseek(bp, offset, 0);
    r = Bread(bp, &a, SAR_HDR);
    if(r != SAR_HDR)
        return 0;
    if(strncmp(a.fmag, ARFMAG, sizeof(a.fmag)))
        return -1;
    for(i=0; i<sizeof(a.name) && i<SARNAME && a.name[i] != ' '; i++)
        buf[i] = a.name[i];
    buf[i] = 0;
    arsize = strtol(a.size, 0, 0);
    if (arsize&1)
        arsize++;
    return arsize + SAR_HDR;
}
@

<<function objreset>>=
static void
objreset(void)
{
    int i;
    Symtab *s, *n;

    for(i = 0; i < NHASH; i++) {
        for(s = hash[i]; s; s = n) {
            n = s->next;
            free(s->s.name);
            free(s);
        }
        hash[i] = 0;
    }
    memset(names, 0, sizeof names);
}
@


%-------------------------------------------------------------

<<linkers/libmach/obj.c>>=
/*
 * obj.c
 * routines universal to all object files
 */
#include <u.h>
#include <libc.h>
#include <bio.h>
#include <ar.h>
#include <mach.h>

#include "obj.h"

<<function islocal>>

<<enum _anon_ (linkers/libmach/obj.c)>>

int			/* in [$OS].c */ //$
  _is5(char*),
  _is8(char*),
  _read5(Biobuf*, Prog*),
  _read8(Biobuf*, Prog*);


typedef struct Obj	Obj;
typedef struct Symtab	Symtab;

<<struct Obj>>

<<global obj>>

<<struct Symtab>>

<<global hash (linkers/libmach/obj.c)>>
<<global names>>

static	int	processprog(Prog*,int);	/* decode each symbol reference */
static	void	objreset(void);
static	void	objlookup(int, char *, int, uint);
static	void 	objupdate(int, int);

<<function objtype>>

<<function isar>>

<<function readobj>>

<<function readar>>

<<function processprog>>

<<function objlookup>>
<<function objtraverse>>

<<function _offset>>

<<function objupdate>>

<<function nextar>>

<<function objreset>>
@

%$ 

\subsection*{[[linkers/libmach/setmach.c]]}

<<struct machtab>>=
struct machtab
{
    char	*name;			/* machine name */
    short	type;			/* executable type */
    short	boottype;		/* bootable type */
    int		asstype;		/* disassembler code */
    Mach	*mach;			/* machine description */
    Machdata	*machdata;		/* machine functions */
};
@

<<global machines>>=
/*
 *	machine selection table.  machines with native disassemblers should
 *	follow the plan 9 variant in the table; native modes are selectable
 *	only by name.
 */
Machtab	machines[] =
{
    {	"386",				/*plan 9 386*/
        FI386,
        FI386B,
        AI386,
        &mi386,
        &i386mach,	},
    {	"arm",				/*ARM*/
        FARM,
        FARMB,
        AARM,
        &marm,
        &armmach,	},
    {	0		},		/*the terminator*/
};
@
%    {	"86",				/*8086 - a peach of a machine*/
%        FI386,
%        FI386B,
%        AI8086,
%        &mi386,
%        &i386mach,	},

<<function machbytype>>=
/*
 *	select a machine by executable file type
 */
void
machbytype(int type)
{
    Machtab *mp;

    for (mp = machines; mp->name; mp++){
        if (mp->type == type || mp->boottype == type) {
            asstype = mp->asstype;
            machdata = mp->machdata;
            break;
        }
    }
}
@

<<function machbyname>>=
/*
 *	select a machine by name
 */
int
machbyname(char *name)
{
    Machtab *mp;

    if (!name) {
        asstype = AARM;
        machdata = &armmach;
        mach = &marm;
        return 1;
    }
    for (mp = machines; mp->name; mp++){
        if (strcmp(mp->name, name) == 0) {
            asstype = mp->asstype;
            machdata = mp->machdata;
            mach = mp->mach;
            return 1;
        }
    }
    return 0;
}
@


%-------------------------------------------------------------

<<linkers/libmach/setmach.c>>=
#include	<u.h>
#include	<libc.h>
#include	<bio.h>
#include	<mach.h>
        /* table for selecting machine-dependent parameters */

typedef	struct machtab Machtab;

<<struct machtab>>

extern	Mach		mi386, marm;
extern	Machdata	i386mach, armmach;

<<global machines>>

<<function machbytype>>
<<function machbyname>>
@

\section{x86}

<<enum headtype(x86)>>=
/*
 *	-H0 -T0x40004C -D0x10000000	is garbage unix
 *	-H1 -T0xd0 -R4			is unix coff
 *	-H2 -T4128 -R4096		is plan9 format
 *	-H3 -Tx -Rx			is MS-DOS .COM
 *	-H4 -Tx -Rx			is fake MS-DOS .EXE
 *	-H5 -T0x80100020 -R4096		is ELF
 */
enum headtype {
    H_GARBAGE = 0,
    H_COFF = 1,
    H_PLAN9 = 2, // default
    H_COM = 3,
    H_EXE = 4,
    H_ELF = 5,
};
@


<<enum sxxx(x86)>>=
enum section
{
    STEXT		= 1,
    SDATA,
    SBSS,

    SDATA1,
    SXREF, // means not defined (yet)
    SFILE,
    SCONST,
    SUNDEF,

    SIMPORT,
    SEXPORT,
};
@


<<struct Prog(x86)>>=
struct	Prog
{
    //enum<opcode>
    short	as;

    // operands
    Adr	from;
    Adr	to;

    // [[Prog]] other fields
    // 2 by default in zprg, why?
    byte	back;

    Prog*	forwd;
    long	pc;
    long	line;
    char	width;		/* fake for DATA */
    char	ft;		/* oclass cache */
    char	tt;
    byte	mark;	/* work on these */

    // [[Prog]] Extra fields

    // list<ref<Prog>> from firstp/lastp, or datap/edatap
    Prog*	link;

    // list<ref<Prog>> from textp/etextp, to follow CALL xxx
    Prog*	pcond;	/* work on this */

};
@
% see Pconv, %P




% todo could use a queue data structure, so have fast access to end of list?
<<global edatap(x86)>>=
// ref<Prog>>, end of datap list
Prog*	edatap = P;
@

<<constant TNAME(x86)>>=
#define	TNAME		(curtext ? curtext->from.sym->name : noname)
@


<<struct Adr(x86)>>=
struct	Adr
{
    //enum<operand_kind> (D_NONE by default)
    short	type;

    union
    {
        long	u0offset;
        char	u0scon[8];
        Prog	*u0cond;	/* not used, but should be D_BRANCH */
        Ieee	u0ieee;
    } u0;

    union
    {
        Auto*	u1autom;
        Sym*	u1sym;
    } u1;

    //enum<operand_kind(register-only|D_NONE)>
    byte	index;

    // TODO: abused for NOPROF function attributes
    char	scale; // offset * scale give size of entity?
};
@



% ??
<<constant scon(x86)>>=
#define	scon	u0.u0scon
@

<<constant cond(x86)>>=
#define	cond	u0.u0cond
@


% ???
<<struct Auto(x86)>>=
struct	Auto
{
    Sym*	asym;

    long	aoffset;
    short	type;

    // Extra
    Auto*	link;
};
@

<<struct Optab(x86)>>=
struct	Optab
{
    // enum<as> from 8.out.h
    short	as;

    byte*	ytab;

    // enum<Pxxx>
    byte	prefix;
    // the actual x86 machine code for instruction optab.as
    byte	op[10];
};
@


<<function brloop(x86)>>=
Prog*
brloop(Prog *p)
{
    int c;
    Prog *q;

    c = 0;
    for(q = p; q != P; q = q->pcond) {
        if(q->as != AJMP)
            break;
        c++;
        if(c >= 5000)
            return P;
    }
    return q;
}
@


% unused for ARM
<<function copyp>>=
Prog*
copyp(Prog *q)
{
    Prog *p;

    p = prg();
    *p = *q;
    return p;
}
@

<<function xfol(x86)>>=
void
xfol(Prog *p)
{
    Prog *q;
    int i;
    enum as a;

loop:
    if(p == P)
        return;
    if(p->as == ATEXT)
        curtext = p;
    if(p->as == AJMP)
    if((q = p->pcond) != P) {
        p->mark = 1;
        p = q;
        if(p->mark == 0)
            goto loop;
    }
    if(p->mark) {
        /* copy up to 4 instructions to avoid branch */
        for(i=0,q=p; i<4; i++,q=q->link) {
            if(q == P)
                break;
            if(q == lastp)
                break;
            a = q->as;
            if(a == ANOP) {
                i--;
                continue;
            }
            switch(a) {
            case AJMP:
            case ARET:
            case AIRETL:

            case APUSHL:
            case APUSHFL:
            case APUSHW:
            case APUSHFW:
            case APOPL:
            case APOPFL:
            case APOPW:
            case APOPFW:
                goto brk;
            }
            if(q->pcond == P || q->pcond->mark)
                continue;
            if(a == ACALL || a == ALOOP)
                continue;
            for(;;) {
                if(p->as == ANOP) {
                    p = p->link;
                    continue;
                }
                q = copyp(p);
                p = p->link;
                q->mark = 1;
                lastp->link = q;
                lastp = q;
                if(q->as != a || q->pcond == P || q->pcond->mark)
                    continue;

                q->as = relinv(q->as);
                p = q->pcond;
                q->pcond = q->link;
                q->link = p;
                xfol(q->link);
                p = q->link;
                if(p->mark)
                    return;
                goto loop;
            }
        } /* */
    brk:;
        q = prg();
        q->as = AJMP;
        q->line = p->line;
        q->to.type = D_BRANCH;
        q->to.offset = p->pc;
        q->pcond = p;
        p = q;
    }
    p->mark = 1;
    lastp->link = p;
    lastp = p;
    a = p->as;
    if(a == AJMP || a == ARET || a == AIRETL)
        return;
    if(p->pcond != P)
    if(a != ACALL) {
        q = brchain(p->link);
        if(q != P && q->mark)
        if(a != ALOOP) {
            p->as = relinv(a);
            p->link = p->pcond;
            p->pcond = q;
        }
        xfol(p->link);
        q = brchain(p->pcond);
        if(q->mark) {
            p->pcond = q;
            return;
        }
        p = q;
        goto loop;
    }

    p = p->link;
    goto loop;
}
@

<<function relinv(x86)>>=
int
relinv(int a)
{

    switch(a) {
    case AJEQ:	return AJNE;
    case AJNE:	return AJEQ;
    case AJLE:	return AJGT;
    case AJLS:	return AJHI;
    case AJLT:	return AJGE;
    case AJMI:	return AJPL;
    case AJGE:	return AJLT;
    case AJPL:	return AJMI;
    case AJGT:	return AJLE;
    case AJHI:	return AJLS;
    case AJCS:	return AJCC;
    case AJCC:	return AJCS;
    case AJPS:	return AJPC;
    case AJPC:	return AJPS;
    case AJOS:	return AJOC;
    case AJOC:	return AJOS;
    }
    diag("unknown relation: %s in %s", anames[a], TNAME);
    return a;
}
@

<<function brchain(x86)>>=
Prog*
brchain(Prog *p)
{
    int i;

    for(i=0; i<20; i++) {
        if(p == P || p->as != AJMP)
            return p;
        p = p->pcond;
    }
    return P;
}
@

<<function xdefine(x86)>>=
void
xdefine(char *p, int t, long v)
{
    Sym *s;

    s = lookup(p, 0);
    if(s->type == 0 || s->type == SXREF) {
        s->type = t;
        s->value = v;
    }
    if(s->type == STEXT && s->value == 0)
        s->value = v;
}
@

%\section{[[dostkoff()]]}

<<function dostkoff(x86)>>=
void
dostkoff(void)
{
    Prog *p, *q;
    long autoffset, deltasp;
    int a, f, curframe, curbecome, maxbecome;

    curframe = 0;
    curbecome = 0;
    maxbecome = 0;
    curtext = nil;

    for(p = firstp; p != P; p = p->link) {

        /* find out how much arg space is used in this TEXT */
        if(p->to.type == (D_INDIR+D_SP))
            if(p->to.offset > curframe)
                curframe = p->to.offset;

        switch(p->as) {
        case ATEXT:
            if(curtext && curtext->from.sym) {
                curtext->from.sym->frame = curframe;
                curtext->from.sym->become = curbecome;
                if(curbecome > maxbecome)
                    maxbecome = curbecome;
            }
            curframe = 0;
            curbecome = 0;

            curtext = p;
            break;

        case ARET:
            /* special form of RET is BECOME */
            if(p->from.type == D_CONST)
                if(p->from.offset > curbecome)
                    curbecome = p->from.offset;
            break;
        }
    }
    if(curtext && curtext->from.sym) {
        curtext->from.sym->frame = curframe;
        curtext->from.sym->become = curbecome;
        if(curbecome > maxbecome)
            maxbecome = curbecome;
    }

    if(debug['b'])
        print("max become = %d\n", maxbecome);

    xdefine("ALEFbecome", STEXT, maxbecome);

    curtext = nil;

    for(p = firstp; p != P; p = p->link) {
        switch(p->as) {
        case ATEXT:
            curtext = p;
            break;
        case ACALL:
            if(curtext != P && curtext->from.sym != S && curtext->to.offset >= 0) {
                f = maxbecome - curtext->from.sym->frame;
                if(f <= 0)
                    break;
                /* calling a become or calling a variable */
                if(p->to.sym == S || p->to.sym->become) {
                    curtext->to.offset += f;

                    if(debug['b']) {
                        curp = p;
                        print("%D calling %D increase %d\n",
                            &curtext->from, &p->to, f);
                    }
                }
            }
            break;
        }
    }

    autoffset = 0;
    deltasp = 0;
    for(p = firstp; p != P; p = p->link) {
        if(p->as == ATEXT) {
            curtext = p;

            autoffset = p->to.offset;
            if(autoffset < 0)
                autoffset = 0;
            if(autoffset) {
                p = appendp(p);
                p->as = AADJSP;
                p->from.type = D_CONST;
                p->from.offset = autoffset;
            }
            deltasp = autoffset;
        }
        a = p->from.type;
        if(a == D_AUTO)
            p->from.offset += deltasp;
        if(a == D_PARAM)
            p->from.offset += deltasp + 4;
        a = p->to.type;
        if(a == D_AUTO)
            p->to.offset += deltasp;
        if(a == D_PARAM)
            p->to.offset += deltasp + 4;

        switch(p->as) {
        default:
            continue;
        case APUSHL:
        case APUSHFL:
            deltasp += 4;
            continue;
        case APUSHW:
        case APUSHFW:
            deltasp += 2;
            continue;
        case APOPL:
        case APOPFL:
            deltasp -= 4;
            continue;
        case APOPW:
        case APOPFW:
            deltasp -= 2;
            continue;
        case ARET:
            break;
        }

        if(autoffset != deltasp)
            diag("unbalanced PUSH/POP");
        if(p->from.type == D_CONST)
            goto become;

        if(autoffset) {
            q = p;
            p = appendp(p);
            p->as = ARET;

            q->as = AADJSP;
            q->from.type = D_CONST;
            q->from.offset = -autoffset;
        }
        continue;

    become:
        q = p;
        p = appendp(p);
        p->as = AJMP;
        p->to = q->to;
        p->pcond = q->pcond;

        q->as = AADJSP;
        q->from = zprg.from;
        q->from.type = D_CONST;
        q->from.offset = -autoffset;
        q->to = zprg.to;
        continue;
    }
}
@

<<function appendp(x86)>>=
Prog*
appendp(Prog *q)
{
    Prog *p;

    p = prg();
    p->link = q->link;
    q->link = p;
    p->line = q->line;
    return p;
}
@

%\section{[[doinit()]]}
% x86 only

% use INITDAT and relocate from there
<<function doinit(x86)>>=
void
doinit(void)
{
    Sym *s;
    Prog *p;
    int x;

    for(p = datap; p != P; p = p->link) {
        x = p->to.type;
        if(x != D_EXTERN && x != D_STATIC)
            continue;
        s = p->to.sym;
        if(s->type == 0 || s->type == SXREF)
            diag("undefined %s initializer of %s",
                s->name, p->from.sym->name);
        p->to.offset += s->value;
        p->to.type = D_CONST;
        if(s->type == SDATA || s->type == SBSS)
            p->to.offset += INITDAT;
    }
}
@

\ifallcode
% dead on 8l, so does not really have to be a global
<<global spsize(x86)>>=
long	spsize = 0;
@
\fi

\ifallcode
<<global pcstr(x86)>>=
char*	pcstr = "%.6lux ";
@
\fi

<<function entryvalue(x86)>>=
long
entryvalue(void)
{
    char *a;
    Sym *s;

    a = INITENTRY;

    <<[[entryvalue()]] if digit INITENTRY>>

    s = lookup(a, 0);
    // no _main found, maybe pure asm, start at beginning of TEXT section (va)
    if(s->type == 0)
        return INITTEXT;

    switch(s->type) {
    case STEXT:
        return s->value;
    <<[[entryvalue()]] if dynamic module case>>
    default:
        diag("entry not text: %s", s->name);
    }
}
@


<<function zaddr(x86)>>=
int
zaddr(byte *p, Adr *a, Sym *h[])
{
    int c, t, i;
    int l;
    Sym *s;
    Auto *u;

    t = p[0];

    c = 1;
    if(t & T_INDEX) {
        a->index = p[c];
        a->scale = p[c+1];
        c += 2;
    } else {
        a->index = D_NONE;
        a->scale = 0;
    }
    a->offset = 0;
    if(t & T_OFFSET) {
        a->offset = p[c] | (p[c+1]<<8) | (p[c+2]<<16) | (p[c+3]<<24);
        c += 4;
        // >> >> >>
    }
    a->sym = S;
    if(t & T_SYM) {
        a->sym = h[p[c]];
        c++;
    }
    a->type = D_NONE;
    if(t & T_FCONST) {
        a->ieee.l = p[c] | (p[c+1]<<8) | (p[c+2]<<16) | (p[c+3]<<24);
        a->ieee.h = p[c+4] | (p[c+5]<<8) | (p[c+6]<<16) | (p[c+7]<<24);
        // >> >> >> >> >> >>
        c += 8;
        a->type = D_FCONST;
    } else
    if(t & T_SCONST) {
        for(i=0; i<NSNAME; i++)
            a->scon[i] = p[c+i];
        c += NSNAME;
        a->type = D_SCONST;
    }
    if(t & T_TYPE) {
        a->type = p[c];
        c++;
    }
    s = a->sym;
    if(s == S)
        return c;

    t = a->type;
    if(t != D_AUTO && t != D_PARAM)
        return c;
    l = a->offset;
    for(u=curauto; u; u=u->link) {
        if(u->asym == s)
        if(u->type == t) {
            if(u->aoffset > l)
                u->aoffset = l;
            return c;
        }
    }

    // factorize!
    while(nhunk < sizeof(Auto))
        gethunk();
    u = (Auto*)hunk;
    nhunk -= sizeof(Auto);
    hunk += sizeof(Auto);

    u->link = curauto;
    curauto = u;
    u->asym = s;
    u->aoffset = l;
    u->type = t;
    return c;
}
@




<<enum pxxx(x86)>>=
enum pxxx {
    Px		= 0,
    Pe		= 0x66,	/* operand escape */
    Pm		= 0x0f,	/* 2byte opcode escape */
    Pq		= 0xff,	/* both escape */
    Pb		= 0xfe,	/* byte operands */
};
@


<<global optab(x86)>>=
Optab optab[] =
/*	as, ytab, andproto, opcode */
{
    { AXXX },
    { AAAA,		ynone,	Px, 0x37 },
    { AAAD,		ynone,	Px, 0xd5,0x0a },
    { AAAM,		ynone,	Px, 0xd4,0x0a },
    { AAAS,		ynone,	Px, 0x3f },
    { AADCB,	yxorb,	Pb, 0x14,0x80,(02),0x10,0x10 },
    { AADCL,	yxorl,	Px, 0x83,(02),0x15,0x81,(02),0x11,0x13 },
    { AADCW,	yxorl,	Pe, 0x83,(02),0x15,0x81,(02),0x11,0x13 },
    { AADDB,	yxorb,	Px, 0x04,0x80,(00),0x00,0x02 },
    { AADDL,	yaddl,	Px, 0x83,(00),0x05,0x81,(00),0x01,0x03 },
    { AADDW,	yaddl,	Pe, 0x83,(00),0x05,0x81,(00),0x01,0x03 },
    { AADJSP },
    { AANDB,	yxorb,	Pb, 0x24,0x80,(04),0x20,0x22 },
    { AANDL,	yxorl,	Px, 0x83,(04),0x25,0x81,(04),0x21,0x23 },
    { AANDW,	yxorl,	Pe, 0x83,(04),0x25,0x81,(04),0x21,0x23 },
    { AARPL,	yrl_ml,	Px, 0x63 },
    { ABOUNDL,	yrl_m,	Px, 0x62 },
    { ABOUNDW,	yrl_m,	Pe, 0x62 },
    { ABSFL,	yml_rl,	Pm, 0xbc },
    { ABSFW,	yml_rl,	Pq, 0xbc },
    { ABSRL,	yml_rl,	Pm, 0xbd },
    { ABSRW,	yml_rl,	Pq, 0xbd },
    { ABTL,		yml_rl,	Pm, 0xa3 },
    { ABTW,		yml_rl,	Pq, 0xa3 },
    { ABTCL,	yml_rl,	Pm, 0xbb },
    { ABTCW,	yml_rl,	Pq, 0xbb },
    { ABTRL,	yml_rl,	Pm, 0xb3 },
    { ABTRW,	yml_rl,	Pq, 0xb3 },
    { ABTSL,	yml_rl,	Pm, 0xab },
    { ABTSW,	yml_rl,	Pq, 0xab },
    { ABYTE,	ybyte,	Px, 1 },
    { ACALL,	ycall,	Px, 0xff,(02),0xe8 },
    { ACLC,		ynone,	Px, 0xf8 },
    { ACLD,		ynone,	Px, 0xfc },
    { ACLI,		ynone,	Px, 0xfa },
    { ACLTS,	ynone,	Pm, 0x06 },
    { ACMC,		ynone,	Px, 0xf5 },
    { ACMPB,	ycmpb,	Pb, 0x3c,0x80,(07),0x38,0x3a },
    { ACMPL,	ycmpl,	Px, 0x83,(07),0x3d,0x81,(07),0x39,0x3b },
    { ACMPW,	ycmpl,	Pe, 0x83,(07),0x3d,0x81,(07),0x39,0x3b },
    { ACMPSB,	ynone,	Pb, 0xa6 },
    { ACMPSL,	ynone,	Px, 0xa7 },
    { ACMPSW,	ynone,	Pe, 0xa7 },
    { ADAA,		ynone,	Px, 0x27 },
    { ADAS,		ynone,	Px, 0x2f },
    { ADATA },
    { ADECB,	yincb,	Pb, 0xfe,(01) },
    { ADECL,	yincl,	Px, 0x48,0xff,(01) },
    { ADECW,	yincl,	Pe, 0x48,0xff,(01) },
    { ADIVB,	ydivb,	Pb, 0xf6,(06) },
    { ADIVL,	ydivl,	Px, 0xf7,(06) },
    { ADIVW,	ydivl,	Pe, 0xf7,(06) },
    { AENTER },				/* botch */
    { AGLOBL },
    { AGOK },
    { AHISTORY },
    { AHLT,		ynone,	Px, 0xf4 },
    { AIDIVB,	ydivb,	Pb, 0xf6,(07) },
    { AIDIVL,	ydivl,	Px, 0xf7,(07) },
    { AIDIVW,	ydivl,	Pe, 0xf7,(07) },
    { AIMULB,	ydivb,	Pb, 0xf6,(05) },
    { AIMULL,	yimul,	Px, 0xf7,(05),0x6b,0x69 },
    { AIMULW,	yimul,	Pe, 0xf7,(05),0x6b,0x69 },
    { AINB,		yin,	Pb, 0xe4,0xec },
    { AINL,		yin,	Px, 0xe5,0xed },
    { AINW,		yin,	Pe, 0xe5,0xed },
    { AINCB,	yincb,	Pb, 0xfe,(00) },
    { AINCL,	yincl,	Px, 0x40,0xff,(00) },
    { AINCW,	yincl,	Pe, 0x40,0xff,(00) },
    { AINSB,	ynone,	Pb, 0x6c },
    { AINSL,	ynone,	Px, 0x6d },
    { AINSW,	ynone,	Pe, 0x6d },
    { AINT,		yint,	Px, 0xcd },
    { AINTO,	ynone,	Px, 0xce },
    { AIRETL,	ynone,	Px, 0xcf },
    { AIRETW,	ynone,	Pe, 0xcf },
    { AJCC,		yjcond,	Px, 0x73,0x83,(00) },
    { AJCS,		yjcond,	Px, 0x72,0x82 },
    { AJCXZ,	yloop,	Px, 0xe3 },
    { AJEQ,		yjcond,	Px, 0x74,0x84 },
    { AJGE,		yjcond,	Px, 0x7d,0x8d },
    { AJGT,		yjcond,	Px, 0x7f,0x8f },
    { AJHI,		yjcond,	Px, 0x77,0x87 },
    { AJLE,		yjcond,	Px, 0x7e,0x8e },
    { AJLS,		yjcond,	Px, 0x76,0x86 },
    { AJLT,		yjcond,	Px, 0x7c,0x8c },
    { AJMI,		yjcond,	Px, 0x78,0x88 },
    { AJMP,		yjmp,	Px, 0xff,(04),0xeb,0xe9 },
    { AJNE,		yjcond,	Px, 0x75,0x85 },
    { AJOC,		yjcond,	Px, 0x71,0x81,(00) },
    { AJOS,		yjcond,	Px, 0x70,0x80,(00) },
    { AJPC,		yjcond,	Px, 0x7b,0x8b },
    { AJPL,		yjcond,	Px, 0x79,0x89 },
    { AJPS,		yjcond,	Px, 0x7a,0x8a },
    { ALAHF,	ynone,	Px, 0x9f },
    { ALARL,	yml_rl,	Pm, 0x02 },
    { ALARW,	yml_rl,	Pq, 0x02 },
    { ALEAL,	ym_rl,	Px, 0x8d },
    { ALEAW,	ym_rl,	Pe, 0x8d },
    { ALEAVEL,	ynone,	Px, 0xc9 },
    { ALEAVEW,	ynone,	Pe, 0xc9 },
    { ALOCK,	ynone,	Px, 0xf0 },
    { ALODSB,	ynone,	Pb, 0xac },
    { ALODSL,	ynone,	Px, 0xad },
    { ALODSW,	ynone,	Pe, 0xad },
    { ALONG,	ybyte,	Px, 4 },
    { ALOOP,	yloop,	Px, 0xe2 },
    { ALOOPEQ,	yloop,	Px, 0xe1 },
    { ALOOPNE,	yloop,	Px, 0xe0 },
    { ALSLL,	yml_rl,	Pm, 0x03  },
    { ALSLW,	yml_rl,	Pq, 0x03  },
    { AMOVB,	ymovb,	Pb, 0x88,0x8a,0xb0,0xc6,(00) },
    { AMOVL,	ymovl,	Px, 0x89,0x8b,0x31,0x83,(04),0xb8,0xc7,(00) },
    { AMOVW,	ymovl,	Pe, 0x89,0x8b,0x31,0x83,(04),0xb8,0xc7,(00) },
    { AMOVBLSX,	ymb_rl,	Pm, 0xbe },
    { AMOVBLZX,	ymb_rl,	Pm, 0xb6 },
    { AMOVBWSX,	ymb_rl,	Pq, 0xbe },
    { AMOVBWZX,	ymb_rl,	Pq, 0xb6 },
    { AMOVWLSX,	yml_rl,	Pm, 0xbf },
    { AMOVWLZX,	yml_rl,	Pm, 0xb7 },
    { AMOVSB,	ynone,	Pb, 0xa4 },
    { AMOVSL,	ynone,	Px, 0xa5 },
    { AMOVSW,	ynone,	Pe, 0xa5 },
    { AMULB,	ydivb,	Pb, 0xf6,(04) },
    { AMULL,	ydivl,	Px, 0xf7,(04) },
    { AMULW,	ydivl,	Pe, 0xf7,(04) },
    { ANAME },
    { ANEGB,	yscond,	Px, 0xf6,(03) },
    { ANEGL,	yscond,	Px, 0xf7,(03) },
    { ANEGW,	yscond,	Pe, 0xf7,(03) },
    { ANOP,		ynop,	Px,0,0 },
    { ANOTB,	yscond,	Px, 0xf6,(02) },
    { ANOTL,	yscond,	Px, 0xf7,(02) },
    { ANOTW,	yscond,	Pe, 0xf7,(02) },
    { AORB,		yxorb,	Pb, 0x0c,0x80,(01),0x08,0x0a },
    { AORL,		yxorl,	Px, 0x83,(01),0x0d,0x81,(01),0x09,0x0b },
    { AORW,		yxorl,	Pe, 0x83,(01),0x0d,0x81,(01),0x09,0x0b },
    { AOUTB,	yin,	Pb, 0xe6,0xee },
    { AOUTL,	yin,	Px, 0xe7,0xef },
    { AOUTW,	yin,	Pe, 0xe7,0xef },
    { AOUTSB,	ynone,	Pb, 0x6e },
    { AOUTSL,	ynone,	Px, 0x6f },
    { AOUTSW,	ynone,	Pe, 0x6f },
    { APOPAL,	ynone,	Px, 0x61 },
    { APOPAW,	ynone,	Pe, 0x61 },
    { APOPFL,	ynone,	Px, 0x9d },
    { APOPFW,	ynone,	Pe, 0x9d },
    { APOPL,	ypopl,	Px, 0x58,0x8f,(00) },
    { APOPW,	ypopl,	Pe, 0x58,0x8f,(00) },
    { APUSHAL,	ynone,	Px, 0x60 },
    { APUSHAW,	ynone,	Pe, 0x60 },
    { APUSHFL,	ynone,	Px, 0x9c },
    { APUSHFW,	ynone,	Pe, 0x9c },
    { APUSHL,	ypushl,	Px, 0x50,0xff,(06),0x6a,0x68 },
    { APUSHW,	ypushl,	Pe, 0x50,0xff,(06),0x6a,0x68 },
    { ARCLB,	yshb,	Pb, 0xd0,(02),0xc0,(02),0xd2,(02) },
    { ARCLL,	yshl,	Px, 0xd1,(02),0xc1,(02),0xd3,(02),0xd3,(02) },
    { ARCLW,	yshl,	Pe, 0xd1,(02),0xc1,(02),0xd3,(02),0xd3,(02) },
    { ARCRB,	yshb,	Pb, 0xd0,(03),0xc0,(03),0xd2,(03) },
    { ARCRL,	yshl,	Px, 0xd1,(03),0xc1,(03),0xd3,(03),0xd3,(03) },
    { ARCRW,	yshl,	Pe, 0xd1,(03),0xc1,(03),0xd3,(03),0xd3,(03) },
    { AREP,		ynone,	Px, 0xf3 },
    { AREPN,	ynone,	Px, 0xf2 },
    { ARET,		ynone,	Px, 0xc3 },
    { AROLB,	yshb,	Pb, 0xd0,(00),0xc0,(00),0xd2,(00) },
    { AROLL,	yshl,	Px, 0xd1,(00),0xc1,(00),0xd3,(00),0xd3,(00) },
    { AROLW,	yshl,	Pe, 0xd1,(00),0xc1,(00),0xd3,(00),0xd3,(00) },
    { ARORB,	yshb,	Pb, 0xd0,(01),0xc0,(01),0xd2,(01) },
    { ARORL,	yshl,	Px, 0xd1,(01),0xc1,(01),0xd3,(01),0xd3,(01) },
    { ARORW,	yshl,	Pe, 0xd1,(01),0xc1,(01),0xd3,(01),0xd3,(01) },
    { ASAHF,	ynone,	Px, 0x9e },
    { ASALB,	yshb,	Pb, 0xd0,(04),0xc0,(04),0xd2,(04) },
    { ASALL,	yshl,	Px, 0xd1,(04),0xc1,(04),0xd3,(04),0xd3,(04) },
    { ASALW,	yshl,	Pe, 0xd1,(04),0xc1,(04),0xd3,(04),0xd3,(04) },
    { ASARB,	yshb,	Pb, 0xd0,(07),0xc0,(07),0xd2,(07) },
    { ASARL,	yshl,	Px, 0xd1,(07),0xc1,(07),0xd3,(07),0xd3,(07) },
    { ASARW,	yshl,	Pe, 0xd1,(07),0xc1,(07),0xd3,(07),0xd3,(07) },
    { ASBBB,	yxorb,	Pb, 0x1c,0x80,(03),0x18,0x1a },
    { ASBBL,	yxorl,	Px, 0x83,(03),0x1d,0x81,(03),0x19,0x1b },
    { ASBBW,	yxorl,	Pe, 0x83,(03),0x1d,0x81,(03),0x19,0x1b },
    { ASCASB,	ynone,	Pb, 0xae },
    { ASCASL,	ynone,	Px, 0xaf },
    { ASCASW,	ynone,	Pe, 0xaf },
    { ASETCC,	yscond,	Pm, 0x93,(00) },
    { ASETCS,	yscond,	Pm, 0x92,(00) },
    { ASETEQ,	yscond,	Pm, 0x94,(00) },
    { ASETGE,	yscond,	Pm, 0x9d,(00) },
    { ASETGT,	yscond,	Pm, 0x9f,(00) },
    { ASETHI,	yscond,	Pm, 0x97,(00) },
    { ASETLE,	yscond,	Pm, 0x9e,(00) },
    { ASETLS,	yscond,	Pm, 0x96,(00) },
    { ASETLT,	yscond,	Pm, 0x9c,(00) },
    { ASETMI,	yscond,	Pm, 0x98,(00) },
    { ASETNE,	yscond,	Pm, 0x95,(00) },
    { ASETOC,	yscond,	Pm, 0x91,(00) },
    { ASETOS,	yscond,	Pm, 0x90,(00) },
    { ASETPC,	yscond,	Pm, 0x96,(00) },
    { ASETPL,	yscond,	Pm, 0x99,(00) },
    { ASETPS,	yscond,	Pm, 0x9a,(00) },
    { ACDQ,		ynone,	Px, 0x99 },
    { ACWD,		ynone,	Pe, 0x99 },
    { ASHLB,	yshb,	Pb, 0xd0,(04),0xc0,(04),0xd2,(04) },
    { ASHLL,	yshl,	Px, 0xd1,(04),0xc1,(04),0xd3,(04),0xd3,(04) },
    { ASHLW,	yshl,	Pe, 0xd1,(04),0xc1,(04),0xd3,(04),0xd3,(04) },
    { ASHRB,	yshb,	Pb, 0xd0,(05),0xc0,(05),0xd2,(05) },
    { ASHRL,	yshl,	Px, 0xd1,(05),0xc1,(05),0xd3,(05),0xd3,(05) },
    { ASHRW,	yshl,	Pe, 0xd1,(05),0xc1,(05),0xd3,(05),0xd3,(05) },
    { ASTC,		ynone,	Px, 0xf9 },
    { ASTD,		ynone,	Px, 0xfd },
    { ASTI,		ynone,	Px, 0xfb },
    { ASTOSB,	ynone,	Pb, 0xaa },
    { ASTOSL,	ynone,	Px, 0xab },
    { ASTOSW,	ynone,	Pe, 0xab },
    { ASUBB,	yxorb,	Pb, 0x2c,0x80,(05),0x28,0x2a },
    { ASUBL,	yaddl,	Px, 0x83,(05),0x2d,0x81,(05),0x29,0x2b },
    { ASUBW,	yaddl,	Pe, 0x83,(05),0x2d,0x81,(05),0x29,0x2b },
    { ASYSCALL,	ynone,	Px, 0xcd,100 },
    { ATESTB,	ytestb,	Pb, 0xa8,0xf6,(00),0x84,0x84 },
    { ATESTL,	ytestl,	Px, 0xa9,0xf7,(00),0x85,0x85 },
    { ATESTW,	ytestl,	Pe, 0xa9,0xf7,(00),0x85,0x85 },
    { ATEXT,	ytext,	Px },
    { AVERR,	ydivl,	Pm, 0x00,(04) },
    { AVERW,	ydivl,	Pm, 0x00,(05) },
    { AWAIT,	ynone,	Px, 0x9b },
    { AWORD,	ybyte,	Px, 2 },
    { AXCHGB,	yml_mb,	Pb, 0x86,0x86 },
    { AXCHGL,	yml_ml,	Px, 0x87,0x87 },
    { AXCHGW,	yml_ml,	Pe, 0x87,0x87 },
    { AXLAT,	ynone,	Px, 0xd7 },
    { AXORB,	yxorb,	Pb, 0x34,0x80,(06),0x30,0x32 },
    { AXORL,	yxorl,	Px, 0x83,(06),0x35,0x81,(06),0x31,0x33 },
    { AXORW,	yxorl,	Pe, 0x83,(06),0x35,0x81,(06),0x31,0x33 },

    { AFMOVB,	yfmvx,	Px, 0xdf,(04) },
    { AFMOVBP,	yfmvp,	Px, 0xdf,(06) },
    { AFMOVD,	yfmvd,	Px, 0xdd,(00),0xdd,(02),0xd9,(00),0xdd,(02) },
    { AFMOVDP,	yfmvdp,	Px, 0xdd,(03),0xdd,(03) },
    { AFMOVF,	yfmvf,	Px, 0xd9,(00),0xd9,(02) },
    { AFMOVFP,	yfmvp,	Px, 0xd9,(03) },
    { AFMOVL,	yfmvf,	Px, 0xdb,(00),0xdb,(02) },
    { AFMOVLP,	yfmvp,	Px, 0xdb,(03) },
    { AFMOVV,	yfmvx,	Px, 0xdf,(05) },
    { AFMOVVP,	yfmvp,	Px, 0xdf,(07) },
    { AFMOVW,	yfmvf,	Px, 0xdf,(00),0xdf,(02) },
    { AFMOVWP,	yfmvp,	Px, 0xdf,(03) },
    { AFMOVX,	yfmvx,	Px, 0xdb,(05) },
    { AFMOVXP,	yfmvp,	Px, 0xdb,(07) },

    { AFCOMB },
    { AFCOMBP },
    { AFCOMD,	yfadd,	Px, 0xdc,(02),0xd8,(02),0xdc,(02) },	/* botch */
    { AFCOMDP,	yfadd,	Px, 0xdc,(03),0xd8,(03),0xdc,(03) },	/* botch */
    { AFCOMDPP,	ycompp,	Px, 0xde,(03) },
    { AFCOMF,	yfmvx,	Px, 0xd8,(02) },
    { AFCOMFP,	yfmvx,	Px, 0xd8,(03) },
    { AFCOML,	yfmvx,	Px, 0xda,(02) },
    { AFCOMLP,	yfmvx,	Px, 0xda,(03) },
    { AFCOMW,	yfmvx,	Px, 0xde,(02) },
    { AFCOMWP,	yfmvx,	Px, 0xde,(03) },

    { AFUCOM,	ycompp,	Px, 0xdd,(04) },
    { AFUCOMP,	ycompp, Px, 0xdd,(05) },
    { AFUCOMPP,	ycompp,	Px, 0xda,(13) },

    { AFADDDP,	yfaddp,	Px, 0xde,(00) },
    { AFADDW,	yfmvx,	Px, 0xde,(00) },
    { AFADDL,	yfmvx,	Px, 0xda,(00) },
    { AFADDF,	yfmvx,	Px, 0xd8,(00) },
    { AFADDD,	yfadd,	Px, 0xdc,(00),0xd8,(00),0xdc,(00) },

    { AFMULDP,	yfaddp,	Px, 0xde,(01) },
    { AFMULW,	yfmvx,	Px, 0xde,(01) },
    { AFMULL,	yfmvx,	Px, 0xda,(01) },
    { AFMULF,	yfmvx,	Px, 0xd8,(01) },
    { AFMULD,	yfadd,	Px, 0xdc,(01),0xd8,(01),0xdc,(01) },

    { AFSUBDP,	yfaddp,	Px, 0xde,(05) },
    { AFSUBW,	yfmvx,	Px, 0xde,(04) },
    { AFSUBL,	yfmvx,	Px, 0xda,(04) },
    { AFSUBF,	yfmvx,	Px, 0xd8,(04) },
    { AFSUBD,	yfadd,	Px, 0xdc,(04),0xd8,(04),0xdc,(05) },

    { AFSUBRDP,	yfaddp,	Px, 0xde,(04) },
    { AFSUBRW,	yfmvx,	Px, 0xde,(05) },
    { AFSUBRL,	yfmvx,	Px, 0xda,(05) },
    { AFSUBRF,	yfmvx,	Px, 0xd8,(05) },
    { AFSUBRD,	yfadd,	Px, 0xdc,(05),0xd8,(05),0xdc,(04) },

    { AFDIVDP,	yfaddp,	Px, 0xde,(07) },
    { AFDIVW,	yfmvx,	Px, 0xde,(06) },
    { AFDIVL,	yfmvx,	Px, 0xda,(06) },
    { AFDIVF,	yfmvx,	Px, 0xd8,(06) },
    { AFDIVD,	yfadd,	Px, 0xdc,(06),0xd8,(06),0xdc,(07) },

    { AFDIVRDP,	yfaddp,	Px, 0xde,(06) },
    { AFDIVRW,	yfmvx,	Px, 0xde,(07) },
    { AFDIVRL,	yfmvx,	Px, 0xda,(07) },
    { AFDIVRF,	yfmvx,	Px, 0xd8,(07) },
    { AFDIVRD,	yfadd,	Px, 0xdc,(07),0xd8,(07),0xdc,(06) },

    { AFXCHD,	yfxch,	Px, 0xd9,(01),0xd9,(01) },
    { AFFREE },
    { AFLDCW,	ystcw,	Px, 0xd9,(05),0xd9,(05) },
    { AFLDENV,	ystcw,	Px, 0xd9,(04),0xd9,(04) },
    { AFRSTOR,	ysvrs,	Px, 0xdd,(04),0xdd,(04) },
    { AFSAVE,	ysvrs,	Px, 0xdd,(06),0xdd,(06) },
    { AFSTCW,	ystcw,	Px, 0xd9,(07),0xd9,(07) },
    { AFSTENV,	ystcw,	Px, 0xd9,(06),0xd9,(06) },
    { AFSTSW,	ystsw,	Px, 0xdd,(07),0xdf,0xe0 },
    { AF2XM1,	ynone,	Px, 0xd9, 0xf0 },
    { AFABS,	ynone,	Px, 0xd9, 0xe1 },
    { AFCHS,	ynone,	Px, 0xd9, 0xe0 },
    { AFCLEX,	ynone,	Px, 0xdb, 0xe2 },
    { AFCOS,	ynone,	Px, 0xd9, 0xff },
    { AFDECSTP,	ynone,	Px, 0xd9, 0xf6 },
    { AFINCSTP,	ynone,	Px, 0xd9, 0xf7 },
    { AFINIT,	ynone,	Px, 0xdb, 0xe3 },
    { AFLD1,	ynone,	Px, 0xd9, 0xe8 },
    { AFLDL2E,	ynone,	Px, 0xd9, 0xea },
    { AFLDL2T,	ynone,	Px, 0xd9, 0xe9 },
    { AFLDLG2,	ynone,	Px, 0xd9, 0xec },
    { AFLDLN2,	ynone,	Px, 0xd9, 0xed },
    { AFLDPI,	ynone,	Px, 0xd9, 0xeb },
    { AFLDZ,	ynone,	Px, 0xd9, 0xee },
    { AFNOP,	ynone,	Px, 0xd9, 0xd0 },
    { AFPATAN,	ynone,	Px, 0xd9, 0xf3 },
    { AFPREM,	ynone,	Px, 0xd9, 0xf8 },
    { AFPREM1,	ynone,	Px, 0xd9, 0xf5 },
    { AFPTAN,	ynone,	Px, 0xd9, 0xf2 },
    { AFRNDINT,	ynone,	Px, 0xd9, 0xfc },
    { AFSCALE,	ynone,	Px, 0xd9, 0xfd },
    { AFSIN,	ynone,	Px, 0xd9, 0xfe },
    { AFSINCOS,	ynone,	Px, 0xd9, 0xfb },
    { AFSQRT,	ynone,	Px, 0xd9, 0xfa },
    { AFTST,	ynone,	Px, 0xd9, 0xe4 },
    { AFXAM,	ynone,	Px, 0xd9, 0xe5 },
    { AFXTRACT,	ynone,	Px, 0xd9, 0xf4 },
    { AFYL2X,	ynone,	Px, 0xd9, 0xf1 },
    { AFYL2XP1,	ynone,	Px, 0xd9, 0xf9 },
    { AEND },
    0
};
@



%\section{[[Yxxx]]}

<<enum yxxx(x86)>>=
enum yxxx {
    Yxxx		= 0,
    Ynone,
    Yi0,
    Yi1,
    Yi8,
    Yi32,

    Yiauto,

    Yal,
    Ycl,
    Yax,
    Ycx,
    Yrb,
    Yrl,
    Yrf,
    Yf0,
    Yrx,
    Ymb,
    Yml,
    Ym,
    Ybr,
    Ycol,

    Ycs,	Yss,	Yds,	Yes,	Yfs,	Ygs,
    Ygdtr,	Yidtr,	Yldtr,	Ymsw,	Ytask,
    Ycr0,	Ycr1,	Ycr2,	Ycr3,	Ycr4,	Ycr5,	Ycr6,	Ycr7,
    Ydr0,	Ydr1,	Ydr2,	Ydr3,	Ydr4,	Ydr5,	Ydr6,	Ydr7,
    Ytr0,	Ytr1,	Ytr2,	Ytr3,	Ytr4,	Ytr5,	Ytr6,	Ytr7,

    Ymax,
};
@

%\section{[[Zxxx]]}

<<enum zxxx(x86)>>=
enum zxxx {
    Zxxx		= 0,

    Zlit,
    Z_rp,
    Zbr,
    Zcall,
    Zib_,
    Zib_rp,
    Zibo_m,
    Zil_,
    Zil_rp,
    Zilo_m,
    Zjmp,
    Zloop,
    Zm_o,
    Zm_r,
    Zaut_r,
    Zo_m,
    Zpseudo,
    Zr_m,
    Zrp_,
    Z_ib,
    Z_il,
    Zm_ibo,
    Zm_ilo,
    Zib_rr,
    Zil_rr,
    Zclr,
    Zbyte,
    Zmov,
    Zmax,
};
@

%\section{[[yxxx]]}

<<global ynone(x86)>>=
byte	ynone[] =
{
    Ynone,	Ynone,	Zlit,	1,
    0
};
@

<<global ytext(x86)>>=
byte	ytext[] =
{
    Ymb,	Yi32,	Zpseudo,1,
    0
};
@

<<global ynop(x86)>>=
byte	ynop[] =
{
    Ynone,	Ynone,	Zpseudo,1,
    Ynone,	Yml,	Zpseudo,1,
    Ynone,	Yrf,	Zpseudo,1,
    Yml,	Ynone,	Zpseudo,1,
    Yrf,	Ynone,	Zpseudo,1,
    0
};
@

<<global yxorb(x86)>>=
byte	yxorb[] =
{
    Yi32,	Yal,	Zib_,	1,
    Yi32,	Ymb,	Zibo_m,	2,
    Yrb,	Ymb,	Zr_m,	1,
    Ymb,	Yrb,	Zm_r,	1,
    0
};
@

<<global yxorl(x86)>>=
byte	yxorl[] =
{
    Yi8,	Yml,	Zibo_m,	2,
    Yi32,	Yax,	Zil_,	1,
    Yi32,	Yml,	Zilo_m,	2,
    Yrl,	Yml,	Zr_m,	1,
    Yml,	Yrl,	Zm_r,	1,
    0
};
@

<<global yaddl(x86)>>=
byte	yaddl[] =
{
    Yi8,	Yml,	Zibo_m,	2,
    Yi32,	Yax,	Zil_,	1,
    Yi32,	Yml,	Zilo_m,	2,
    Yrl,	Yml,	Zr_m,	1,
    Yml,	Yrl,	Zm_r,	1,
    0
};
@

<<global yincb(x86)>>=
byte	yincb[] =
{
    Ynone,	Ymb,	Zo_m,	2,
    0
};
@

<<global yincl(x86)>>=
byte	yincl[] =
{
    Ynone,	Yrl,	Z_rp,	1,
    Ynone,	Yml,	Zo_m,	2,
    0
};
@

<<global ycmpb(x86)>>=
byte	ycmpb[] =
{
    Yal,	Yi32,	Z_ib,	1,
    Ymb,	Yi32,	Zm_ibo,	2,
    Ymb,	Yrb,	Zm_r,	1,
    Yrb,	Ymb,	Zr_m,	1,
    0
};
@

<<global ycmpl(x86)>>=
byte	ycmpl[] =
{
    Yml,	Yi8,	Zm_ibo,	2,
    Yax,	Yi32,	Z_il,	1,
    Yml,	Yi32,	Zm_ilo,	2,
    Yml,	Yrl,	Zm_r,	1,
    Yrl,	Yml,	Zr_m,	1,
    0
};
@

<<global yshb(x86)>>=
byte	yshb[] =
{
    Yi1,	Ymb,	Zo_m,	2,
    Yi32,	Ymb,	Zibo_m,	2,
    Ycx,	Ymb,	Zo_m,	2,
    0
};
@

<<global yshl(x86)>>=
byte	yshl[] =
{
    Yi1,	Yml,	Zo_m,	2,
    Yi32,	Yml,	Zibo_m,	2,
    Ycl,	Yml,	Zo_m,	2,
    Ycx,	Yml,	Zo_m,	2,
    0
};
@

<<global ytestb(x86)>>=
byte	ytestb[] =
{
    Yi32,	Yal,	Zib_,	1,
    Yi32,	Ymb,	Zibo_m,	2,
    Yrb,	Ymb,	Zr_m,	1,
    Ymb,	Yrb,	Zm_r,	1,
    0
};
@

<<global ytestl(x86)>>=
byte	ytestl[] =
{
    Yi32,	Yax,	Zil_,	1,
    Yi32,	Yml,	Zilo_m,	2,
    Yrl,	Yml,	Zr_m,	1,
    Yml,	Yrl,	Zm_r,	1,
    0
};
@

<<global ymovb(x86)>>=
byte	ymovb[] =
{
    Yrb,	Ymb,	Zr_m,	1,
    Ymb,	Yrb,	Zm_r,	1,
    Yi32,	Yrb,	Zib_rp,	1,
    Yi32,	Ymb,	Zibo_m,	2,
    0
};
@

<<global ymovl(x86)>>=
byte	ymovl[] =
{
    Yrl,	Yml,	Zr_m,	1,
    Yml,	Yrl,	Zm_r,	1,
    Yi0,	Yrl,	Zclr,	1+2,
//	Yi0,	Yml,	Zibo_m,	2,	// shorter but slower AND $0,dst
    Yi32,	Yrl,	Zil_rp,	1,
    Yi32,	Yml,	Zilo_m,	2,
    Yiauto,	Yrl,	Zaut_r,	2,
    0
};
@
%$

<<global ym_rl(x86)>>=
byte	ym_rl[] =
{
    Ym,	Yrl,	Zm_r,	1,
    0
};
@

<<global yrl_m(x86)>>=
byte	yrl_m[] =
{
    Yrl,	Ym,	Zr_m,	1,
    0
};
@

<<global ymb_rl(x86)>>=
byte	ymb_rl[] =
{
    Ymb,	Yrl,	Zm_r,	1,
    0
};
@

<<global yml_rl(x86)>>=
byte	yml_rl[] =
{
    Yml,	Yrl,	Zm_r,	1,
    0
};
@

<<global yrl_ml(x86)>>=
byte	yrl_ml[] =
{
    Yrl,	Yml,	Zr_m,	1,
    0
};
@

<<global yml_mb(x86)>>=
byte	yml_mb[] =
{
    Yrb,	Ymb,	Zr_m,	1,
    Ymb,	Yrb,	Zm_r,	1,
    0
};
@

<<global yml_ml(x86)>>=
byte	yml_ml[] =
{
    Yrl,	Yml,	Zr_m,	1,
    Yml,	Yrl,	Zm_r,	1,
    0
};
@

<<global ydivl(x86)>>=
byte	ydivl[] =
{
    Yml,	Ynone,	Zm_o,	2,
    0
};
@

<<global ydivb(x86)>>=
byte	ydivb[] =
{
    Ymb,	Ynone,	Zm_o,	2,
    0
};
@

<<global yimul(x86)>>=
byte	yimul[] =
{
    Yml,	Ynone,	Zm_o,	2,
    Yi8,	Yrl,	Zib_rr,	1,
    Yi32,	Yrl,	Zil_rr,	1,
    0
};
@

<<global ybyte(x86)>>=
byte	ybyte[] =
{
    Yi32,	Ynone,	Zbyte,	1,
    0
};
@

<<global yin(x86)>>=
byte	yin[] =
{
    Yi32,	Ynone,	Zib_,	1,
    Ynone,	Ynone,	Zlit,	1,
    0
};
@

<<global yint(x86)>>=
byte	yint[] =
{
    Yi32,	Ynone,	Zib_,	1,
    0
};
@

<<global ypushl(x86)>>=
byte	ypushl[] =
{
    Yrl,	Ynone,	Zrp_,	1,
    Ym,	Ynone,	Zm_o,	2,
    Yi8,	Ynone,	Zib_,	1,
    Yi32,	Ynone,	Zil_,	1,
    0
};
@

<<global ypopl(x86)>>=
byte	ypopl[] =
{
    Ynone,	Yrl,	Z_rp,	1,
    Ynone,	Ym,	Zo_m,	2,
    0
};
@

<<global yscond(x86)>>=
byte	yscond[] =
{
    Ynone,	Ymb,	Zo_m,	2,
    0
};
@

<<global yjcond(x86)>>=
byte	yjcond[] =
{
    Ynone,	Ybr,	Zbr,	1,
    0
};
@

<<global yloop(x86)>>=
byte	yloop[] =
{
    Ynone,	Ybr,	Zloop,	1,
    0
};
@

<<global ycall(x86)>>=
byte	ycall[] =
{
    Ynone,	Yml,	Zo_m,	2,
    Ynone,	Ybr,	Zcall,	1,
    0
};
@

<<global yjmp(x86)>>=
byte	yjmp[] =
{
    Ynone,	Yml,	Zo_m,	2,
    Ynone,	Ybr,	Zjmp,	1,
    0
};
@

<<global yfmvd(x86)>>=
byte	yfmvd[] =
{
    Ym,	Yf0,	Zm_o,	2,
    Yf0,	Ym,	Zo_m,	2,
    Yrf,	Yf0,	Zm_o,	2,
    Yf0,	Yrf,	Zo_m,	2,
    0
};
@

<<global yfmvdp(x86)>>=
byte	yfmvdp[] =
{
    Yf0,	Ym,	Zo_m,	2,
    Yf0,	Yrf,	Zo_m,	2,
    0
};
@

<<global yfmvf(x86)>>=
byte	yfmvf[] =
{
    Ym,	Yf0,	Zm_o,	2,
    Yf0,	Ym,	Zo_m,	2,
    0
};
@

<<global yfmvx(x86)>>=
byte	yfmvx[] =
{
    Ym,	Yf0,	Zm_o,	2,
    0
};
@

<<global yfmvp(x86)>>=
byte	yfmvp[] =
{
    Yf0,	Ym,	Zo_m,	2,
    0
};
@

<<global yfadd(x86)>>=
byte	yfadd[] =
{
    Ym,	Yf0,	Zm_o,	2,
    Yrf,	Yf0,	Zm_o,	2,
    Yf0,	Yrf,	Zo_m,	2,
    0
};
@

<<global yfaddp(x86)>>=
byte	yfaddp[] =
{
    Yf0,	Yrf,	Zo_m,	2,
    0
};
@

<<global yfxch(x86)>>=
byte	yfxch[] =
{
    Yf0,	Yrf,	Zo_m,	2,
    Yrf,	Yf0,	Zm_o,	2,
    0
};
@

<<global ycompp(x86)>>=
byte	ycompp[] =
{
    Yf0,	Yrf,	Zo_m,	2,	/* botch is really f0,f1 */
    0
};
@

<<global ystsw(x86)>>=
byte	ystsw[] =
{
    Ynone,	Ym,	Zo_m,	2,
    Ynone,	Yax,	Zlit,	1,
    0
};
@

<<global ystcw(x86)>>=
byte	ystcw[] =
{
    Ynone,	Ym,	Zo_m,	2,
    Ym,	Ynone,	Zm_o,	2,
    0
};
@

<<global ysvrs(x86)>>=
byte	ysvrs[] =
{
    Ynone,	Ym,	Zo_m,	2,
    Ym,	Ynone,	Zm_o,	2,
    0
};
@

%\section{[[ycover]]}

<<global ycover(x86)>>=
char	ycover[Ymax*Ymax];
@

<<[[main()]] set ycover(x86)>>=
for(i=0; i<Ymax; i++)
    ycover[i*Ymax + i] = 1;

ycover[Yi0*Ymax + Yi8] = 1;
ycover[Yi1*Ymax + Yi8] = 1;

ycover[Yi0*Ymax + Yi32] = 1;
ycover[Yi1*Ymax + Yi32] = 1;
ycover[Yi8*Ymax + Yi32] = 1;

ycover[Yal*Ymax + Yrb] = 1;
ycover[Ycl*Ymax + Yrb] = 1;
ycover[Yax*Ymax + Yrb] = 1;
ycover[Ycx*Ymax + Yrb] = 1;
ycover[Yrx*Ymax + Yrb] = 1;

ycover[Yax*Ymax + Yrx] = 1;
ycover[Ycx*Ymax + Yrx] = 1;

ycover[Yax*Ymax + Yrl] = 1;
ycover[Ycx*Ymax + Yrl] = 1;
ycover[Yrx*Ymax + Yrl] = 1;

ycover[Yf0*Ymax + Yrf] = 1;

ycover[Yal*Ymax + Ymb] = 1;
ycover[Ycl*Ymax + Ymb] = 1;
ycover[Yax*Ymax + Ymb] = 1;
ycover[Ycx*Ymax + Ymb] = 1;
ycover[Yrx*Ymax + Ymb] = 1;
ycover[Yrb*Ymax + Ymb] = 1;
ycover[Ym*Ymax + Ymb] = 1;

ycover[Yax*Ymax + Yml] = 1;
ycover[Ycx*Ymax + Yml] = 1;
ycover[Yrx*Ymax + Yml] = 1;
ycover[Yrl*Ymax + Yml] = 1;
ycover[Ym*Ymax + Yml] = 1;
@

%\section{[[reg]]}
<<global reg(x86)>>=
char	reg[D_NONE];
@

<<[[main()]] set reg(x86)>>=
for(i=0; i<D_NONE; i++) {
    reg[i] = -1;
    if(i >= D_AL && i <= D_BH)
        reg[i] = (i-D_AL) & 7;
    if(i >= D_AX && i <= D_DI)
        reg[i] = (i-D_AX) & 7;
    if(i >= D_F0 && i <= D_F0+7)
        reg[i] = (i-D_F0) & 7;
}
@

% asmb -> <>
<<function asmsym(x86)>>=
void
asmsym(void)
{
    Prog *p;
    Auto *a;
    Sym *s;
    int h;

    s = lookup("etext", 0);
    if(s->type == STEXT)
        putsymb(s->name, 'T', s->value, s->version);

    for(h=0; h<NHASH; h++)
        for(s=hash[h]; s!=S; s=s->link)
            switch(s->type) {
            case SCONST:
                putsymb(s->name, 'D', s->value, s->version);
                continue;

            case SDATA:
                putsymb(s->name, 'D', s->value+INITDAT, s->version);
                continue;

            case SBSS:
                putsymb(s->name, 'B', s->value+INITDAT, s->version);
                continue;

            case SFILE:
                putsymb(s->name, 'f', s->value, s->version);
                continue;
            }

    for(p=textp; p!=P; p=p->pcond) {
        s = p->from.sym;
        if(s->type != STEXT)
            continue;

        /* filenames first */
        for(a=p->to.autom; a; a=a->link)
            if(a->type == D_FILE)
                putsymb(a->asym->name, 'z', a->aoffset, 0);
            else
            if(a->type == D_FILE1)
                putsymb(a->asym->name, 'Z', a->aoffset, 0);

        putsymb(s->name, 'T', s->value, s->version);

        /* frame, auto and param after */
        putsymb(".frame", 'm', p->to.offset+4, 0);

        for(a=p->to.autom; a; a=a->link)
            if(a->type == D_AUTO)
                putsymb(a->asym->name, 'a', -a->aoffset, 0);
            else
            if(a->type == D_PARAM)
                putsymb(a->asym->name, 'p', a->aoffset, 0);
    }

    if(debug['v'] || debug['n'])
        DBG("symsize = %lud\n", symsize);
}
@


<<function doprof1(x86)>>=
void
doprof1(void)
{
    Sym *s;
    long n;
    Prog *p, *q;

    DBG("%5.2f profile 1\n", cputime());

    s = lookup("__mcount", 0);
    n = 1;
    for(p = firstp->link; p != P; p = p->link) {
        if(p->as == ATEXT) {
            q = prg();
            q->line = p->line;

            q->link = datap;
            datap = q;

            //asm: DATA __mcount ??? array? why need to declare it here too?
            q->as = ADATA;
            q->from.type = D_EXTERN;
            q->from.offset = n*4;
            q->from.sym = s; // __mcount
            q->from.scale = 4;  // NOSPLIT?
            q->to = p->from;
            q->to.type = D_CONST;

            q = prg();
            q->line = p->line;
            q->pc = p->pc;

            q->link = p->link;
            p->link = q;
            p = q;

            //asm: ADDL 1, __mcount[n]?
            p->as = AADDL;
            p->from.type = D_CONST;
            p->from.offset = 1;
            p->to.type = D_EXTERN;
            p->to.sym = s;
            p->to.offset = n*4 + 4;

            n += 2;
            continue;
        }
    }

    q = prg();
    q->line = 0;

    q->link = datap;
    datap = q;

    //asm: DATA __mcount ???
    q->as = ADATA;
    q->from.type = D_EXTERN;
    q->from.sym = s;
    q->from.scale = 4;  // NOSPLIT?
    q->to.type = D_CONST;
    q->to.offset = n;

    s->type = SBSS;
    // 4 bytes counter for each functions
    s->value = n*4;
}
@


<<function nuxiinit(x86)>>=
void
nuxiinit(void)
{
    int i, c;

    for(i=0; i<4; i++) {
        c = find1(0x04030201L, i+1);
        if(i < 2)
            inuxi2[i] = c;
        if(i < 1)
            inuxi1[i] = c;
        inuxi4[i] = c;
        fnuxi4[i] = c;
        fnuxi8[i] = c;
        fnuxi8[i+4] = c+4;
    }
    if(debug['v']) {
        Bprint(&bso, "inuxi = ");
        for(i=0; i<1; i++)
            Bprint(&bso, "%d", inuxi1[i]);
        Bprint(&bso, " ");
        for(i=0; i<2; i++)
            Bprint(&bso, "%d", inuxi2[i]);
        Bprint(&bso, " ");
        for(i=0; i<4; i++)
            Bprint(&bso, "%d", inuxi4[i]);
        Bprint(&bso, "\nfnuxi = ");
        for(i=0; i<4; i++)
            Bprint(&bso, "%d", fnuxi4[i]);
        Bprint(&bso, " ");
        for(i=0; i<8; i++)
            Bprint(&bso, "%d", fnuxi8[i]);
        Bprint(&bso, "\n");
    }
    Bflush(&bso);
}
@

%<<function find2(x86)>>=
%//int
%//find2(long l, int c)
%//{
%//    short *p;
%//    int i;
%//
%//    p = (short*)&l;
%//    for(i=0; i<4; i+=2) {
%//        if(((*p >> 8) & 0xff) == c)
%//            return i;
%//        if((*p++ & 0xff) == c)
%//            return i+1;
%//    }
%//    return 0;
%//}
%@



<<function export(x86)>>=
void
export(void)
{
    int i, j, n, off, nb, sv, ne;
    Sym *s, *et, *str, **esyms;
    Prog *p;
    char buf[NSNAME], *t;

    n = 0;
    for(i = 0; i < NHASH; i++)
        for(s = hash[i]; s != S; s = s->link)
            if(s->type != SXREF && s->type != SUNDEF && (nexports == 0 && s->sig != 0 || s->subtype == SEXPORT || allexport))
                n++;
    esyms = malloc(n*sizeof(Sym*));
    ne = n;
    n = 0;
    for(i = 0; i < NHASH; i++)
        for(s = hash[i]; s != S; s = s->link)
            if(s->type != SXREF && s->type != SUNDEF && (nexports == 0 && s->sig != 0 || s->subtype == SEXPORT || allexport))
                esyms[n++] = s;
    for(i = 0; i < ne-1; i++)
        for(j = i+1; j < ne; j++)
            if(strcmp(esyms[i]->name, esyms[j]->name) > 0){
                s = esyms[i];
                esyms[i] = esyms[j];
                esyms[j] = s;
            }

    nb = 0;
    off = 0;
    et = lookup(EXPTAB, 0);
    if(et->type != 0 && et->type != SXREF)
        diag("%s already defined", EXPTAB);
    et->type = SDATA;
    str = lookup(".string", 0);
    if(str->type == 0)
        str->type = SDATA;
    sv = str->value;
    for(i = 0; i < ne; i++){
        s = esyms[i];
        if(debug['S'])
            s->sig = 0;
        /* Bprint(&bso, "EXPORT: %s sig=%lux t=%d\n", s->name, s->sig, s->type); */

        /* signature */
        p = newdata(et, off, sizeof(long), D_EXTERN);
        off += sizeof(long);
        p->to.offset = s->sig;

        /* address */
        p = newdata(et, off, sizeof(long), D_EXTERN);
        off += sizeof(long);
        p->to.type = D_ADDR;
        p->to.index = D_EXTERN;
        p->to.sym = s;

        /* string */
        t = s->name;
        n = strlen(t)+1;
        for(;;){
            buf[nb++] = *t;
            sv++;
            if(nb >= NSNAME){
                p = newdata(str, sv-NSNAME, NSNAME, D_STATIC);
                p->to.type = D_SCONST;
                memmove(p->to.scon, buf, NSNAME);
                nb = 0;
            }
            if(*t++ == 0)
                break;
        }

        /* name */
        p = newdata(et, off, sizeof(long), D_EXTERN);
        off += sizeof(long);
        p->to.type = D_ADDR;
        p->to.index = D_STATIC;
        p->to.sym = str;
        p->to.offset = sv-n;
    }

    if(nb > 0){
        p = newdata(str, sv-nb, nb, D_STATIC);
        p->to.type = D_SCONST;
        memmove(p->to.scon, buf, nb);
    }

    for(i = 0; i < 3; i++){
        newdata(et, off, sizeof(long), D_EXTERN);
        off += sizeof(long);
    }
    et->value = off;
    if(sv == 0)
        sv = 1;
    str->value = sv;
    exports = ne;
    free(esyms);
}
@

<<function newdata(x86)>>=
static Prog*
newdata(Sym *s, int o, int w, int t)
{
    Prog *p;

    p = prg();
    if(edatap == P)
        datap = p;
    else
        edatap->link = p;
    edatap = p;
    p->as = ADATA;
    p->width = w;
    p->from.scale = w;
    p->from.type = t;
    p->from.sym = s;
    p->from.offset = o;
    p->to.type = D_CONST;
    return p;
}
@

<<function import(x86)>>=
void
import(void)
{
    int i;
    Sym *s;

    for(i = 0; i < NHASH; i++)
        for(s = hash[i]; s != S; s = s->link)
            if(s->sig != 0 && s->type == SXREF && (nimports == 0 || s->subtype == SIMPORT)){
                if(s->value != 0)
                    diag("value != 0 on SXREF");
                undefsym(s);
                if(debug['X'])
                    Bprint(&bso, "IMPORT: %s sig=%lux v=%ld\n", s->name, s->sig, s->value);
                if(debug['S'])
                    s->sig = 0;
            }
}
@


<<global reloca(x86)>>=
Adr*	reloca;
@

<<function dynreloc(x86)>>=
void
dynreloc(Sym *s, ulong v, int abs)
{
    int i, k, n;
    byte *m;
    ulong *a;
    Reloc *r;

    if(s->type == SUNDEF)
        k = abs ? ABSU : RELU;
    else
        k = abs ? ABSD : RELD;
    /* Bprint(&bso, "R %s a=%ld(%lx) %d\n", s->name, v, v, k); */
    k = modemap[k];
    r = &rels;
    n = r->n;
    if(n >= r->t)
        grow(r);
    m = r->m;
    a = r->a;
    for(i = n; i > 0; i--){
        if(v < a[i-1]){	/* happens occasionally for data */
            m[i] = m[i-1];
            a[i] = a[i-1];
        }
        else
            break;
    }
    m[i] = k;
    a[i] = v;
    r->n++;
}
@

<<function listinit(x86)>>=
void
listinit(void)
{

    fmtinstall('A', Aconv);
    fmtinstall('R', Rconv);
    fmtinstall('D', Dconv);
    fmtinstall('P', Pconv);
    fmtinstall('S', Sconv);
}
@

<<function Aconv(x86)>>=
// enum<opcode> -> string
int
Aconv(Fmt *fp)
{
    int i;

    i = va_arg(fp->args, int);
    return fmtstrcpy(fp, anames[i]);
}
@

<<global regstr(x86)>>=
// coupling with enum regs in 8.out.h
char*	regstr[] =
{
    "AL",		/* [D_AL] */
    "CL",
    "DL",
    "BL",
    "AH",
    "CH",
    "DH",
    "BH",

    "AX",		/* [D_AX] */
    "CX",
    "DX",
    "BX",
    "SP",
    "BP",
    "SI",
    "DI",

    "F0",		/* [D_F0] */
    "F1",
    "F2",
    "F3",
    "F4",
    "F5",
    "F6",
    "F7",

    "CS",		/* [D_CS] */
    "SS",
    "DS",
    "ES",
    "FS",
    "GS",

    "GDTR",		/* [D_GDTR] */
    "IDTR",		/* [D_IDTR] */
    "LDTR",		/* [D_LDTR] */
    "MSW",		/* [D_MSW] */
    "TASK",		/* [D_TASK] */

    "CR0",		/* [D_CR] */
    "CR1",
    "CR2",
    "CR3",
    "CR4",
    "CR5",
    "CR6",
    "CR7",

    "DR0",		/* [D_DR] */
    "DR1",
    "DR2",
    "DR3",
    "DR4",
    "DR5",
    "DR6",
    "DR7",

    "TR0",		/* [D_TR] */
    "TR1",
    "TR2",
    "TR3",
    "TR4",
    "TR5",
    "TR6",
    "TR7",

    "NONE",		/* [D_NONE] */
};
@
% NONE part of it? this can happen? not more part of enum<operand>?

<<function Rconv(x86)>>=
// enum<operand_kind(register-only)> -> string
int
Rconv(Fmt *fp)
{
    char str[20];
    int r;

    r = va_arg(fp->args, int);
    if(r >= D_AL && r <= D_NONE)
        snprint(str, sizeof(str), "%s", regstr[r-D_AL]);
    else
        snprint(str, sizeof(str), "gok(%d)", r);

    return fmtstrcpy(fp, str);
}
@
%gok??


% used by PConv and Dconv as Dconv need access to enclosing Prog for branch
<<global bigP(x86)>>=
static	Prog	*bigP;
@


<<function Pconv(x86)>>=
// Prog -> string
int
Pconv(Fmt *fp)
{
    char str[STRINGSZ];
    Prog *p;

    p = va_arg(fp->args, Prog*);
    bigP = p;
    switch(p->as) {
    case ATEXT:
        // when this happens?
        if(p->from.scale) {
            snprint(str, sizeof(str), "(%ld)	%A	%D,%d,%D",
                p->line, p->as, &p->from, p->from.scale, &p->to);
        } else {
            snprint(str, sizeof(str), "(%ld)	%A	%D,%D",
                p->line, p->as, &p->from, &p->to);
        }
        break;
    case ADATA:
    case AINIT:
    case ADYNT:
        snprint(str, sizeof(str), "(%ld)	%A	%D/%d,%D",
            p->line, p->as, &p->from, p->from.scale, &p->to);
        break;
    default:
        snprint(str, sizeof(str), "(%ld)	%A	%D,%D",
            p->line, p->as, &p->from, &p->to);
        break;
    }
    bigP = P;
    return fmtstrcpy(fp, str);
}
@



<<function Dconv(x86)>>=
// Adr -> string
int
Dconv(Fmt *fp)
{
    char str[STRINGSZ+40], s[20];
    Adr *a;
    //enum<operand_kind>
    int i;

    a = va_arg(fp->args, Adr*);
    i = a->type;

    <<[[Dconv()]] if i >= D_INDIR(x86)>>

    switch(i) {
    case D_NONE:
        str[0] = '\0';
        break;


    case D_BRANCH:
        if(bigP != P && bigP->pcond != P)
            if(a->sym != S)
                snprint(str, sizeof(str), "%lux+%s", bigP->pcond->pc,
                    a->sym->name);
            else
                snprint(str, sizeof(str), "%lux", bigP->pcond->pc);
        else
            snprint(str, sizeof(str), "%ld(PC)", a->offset);
        break;

    case D_EXTERN:
        snprint(str, sizeof(str), "%s+%ld(SB)", a->sym->name, a->offset);
        break;
    case D_STATIC:
        snprint(str, sizeof(str), "%s<%d>+%ld(SB)", a->sym->name,
            a->sym->version, a->offset);
        break;
    case D_AUTO:
        snprint(str, sizeof(str), "%s+%ld(SP)", a->sym->name, a->offset);
        break;
    case D_PARAM:
        if(a->sym)
            snprint(str, sizeof(str), "%s+%ld(FP)", a->sym->name, a->offset);
        else
            snprint(str, sizeof(str), "%ld(FP)", a->offset);
        break;

    case D_CONST:
        snprint(str, sizeof(str), "$%ld", a->offset);
        break;
    case D_FCONST:
        snprint(str, sizeof(str), "$(%.8lux,%.8lux)", a->ieee.h, a->ieee.l);
        break;
    case D_SCONST:
        snprint(str, sizeof(str), "$\"%S\"", a->scon);
        break;

    case D_ADDR:
        a->type = a->index;
        a->index = D_NONE;
        snprint(str, sizeof(str), "$%D", a);
        a->index = a->type;
        a->type = D_ADDR;
        goto conv;

    default:
        snprint(str, sizeof(str), "%R", i);
        break;

    }
brk:
    if(a->index != D_NONE) {
        snprint(s, sizeof(s), "(%R*%d)", a->index, a->scale);
        strcat(str, s);
    }
conv:
    return fmtstrcpy(fp, str);
}
@
% todo: could simplify flow, those brk: conv: and goto are ugly,
% copy paste a bit and avoid complex flow instead

%???
<<[[Dconv()]] if i >= D_INDIR(x86)>>=
if(i >= D_INDIR) {
    if(a->offset)
        snprint(str, sizeof(str), "%ld(%R)", a->offset, i-D_INDIR);
    else
        snprint(str, sizeof(str), "(%R)", i-D_INDIR);
    goto brk;
}
@



%????  %S not used that much here, but used a lot in optable, for things
% like MOV%S, means MOVL, MOVB, MOVW?
% for D_SCONST ?? but what is D_SCONST?
<<function Sconv(x86)>>=
// ?? -> string
int
Sconv(Fmt *fp)
{
    int i, c;
    char str[30], *p, *a;

    a = va_arg(fp->args, char*);
    p = str;
    for(i=0; i<sizeof(double); i++) {
        c = a[i] & 0xff;
        if(c >= 'a' && c <= 'z' ||
           c >= 'A' && c <= 'Z' ||
           c >= '0' && c <= '9') {
            *p++ = c;
            continue;
        }
        *p++ = '\\';

        switch(c) {
        default:
            if(c < 040 || c >= 0177)
                break;	/* not portable */
            p[-1] = c;
            continue;
        case 0:
            *p++ = 'z';
            continue;
        case '\\':
        case '"':
            *p++ = c;
            continue;
        case '\n':
            *p++ = 'n';
            continue;
        case '\t':
            *p++ = 't';
            continue;
        }
        *p++ = (c>>6) + '0';
        *p++ = ((c>>3) & 7) + '0';
        *p++ = (c & 7) + '0';
    }
    *p = 0;
    return fmtstrcpy(fp, str);
}
@
% what the fuck is this?

<<function cput(x86)>>=
#define	cput(c)\
    { *cbp++ = c;\
    if(--cbc <= 0)\
        cflush(); }
@


<<function wputl(x86)>>=
/* these need to take long arguments to be compatible with elf.c */
void
wputl(long w)
{
    cput(w);
    cput(w>>8);
}
@


<<function wput(x86)>>=
void
wput(long w)
{
    cput(w>>8);
    cput(w);
}
@

<<function lput(x86)>>=
void
lput(long l)
{
    cput(l>>24);
    cput(l>>16);
    cput(l>>8);
    cput(l);
}
@

<<function lputl(x86)>>=
void
lputl(long l)
{
    cput(l);
    cput(l>>8);
    cput(l>>16);
    cput(l>>24);
}
@

<<function strnput(x86)>>=
void
strnput(char *s, int n)
{
    for(; *s && n > 0; s++){
        cput(*s);
        n--;
    }
    while(n > 0){
        cput(0);
        n--;
    }
}
@


<<function patch(x86)>>=
void
patch(void)
{
    long c;
    Prog *p, *q;
    Sym *s;
    long vexit;

    // could be moved out of patch() in main()?
    DBG("%5.2f mkfwd\n", cputime());
    mkfwd();

    DBG("%5.2f patch\n", cputime());
    s = lookup("exit", 0);
    vexit = s->value;
    for(p = firstp; p != P; p = p->link) {
        if(p->as == ATEXT)
            curtext = p;
        if(p->as == ACALL || p->as == ARET) {
            s = p->to.sym;
            if(s) {
                if(debug['c'])
                    Bprint(&bso, "%s calls %s\n", TNAME, s->name);

                switch(s->type) {
                case STEXT:
                    p->to.offset = s->value;
                    break;
                case SUNDEF:
                    p->pcond = UP;
                    p->to.offset = 0;
                    break;
                default:
                    /* diag prints TNAME first */
                    diag("undefined: %s", s->name);
                    s->type = STEXT;
                    s->value = vexit;
                    break;	/* or fall through to set offset? */
                }
                p->to.type = D_BRANCH;
            }
        }
        if(p->to.type != D_BRANCH || p->pcond == UP)
            continue;

        c = p->to.offset;
        for(q = firstp; q != P;) {
            if(q->forwd != P)
            if(c >= q->forwd->pc) {
                q = q->forwd;
                continue;
            }
            if(c == q->pc)
                break;
            q = q->link;
        }
        if(q == P) {
            diag("branch out of range in %s\n%P", TNAME, p);
            p->to.type = D_NONE;
        }
        p->pcond = q;
    }

    for(p = firstp; p != P; p = p->link) {
        if(p->as == ATEXT)
            curtext = p;
        p->mark = 0;	/* initialization for follow */
        if(p->pcond != P && p->pcond != UP) {
            p->pcond = brloop(p->pcond);
            if(p->pcond != P)
            if(p->to.type == D_BRANCH)
                p->to.offset = p->pcond->pc;
        }
    }
}
@


<<function dodata(x86)>>=
void
dodata(void)
{
    int i;
    Sym *s;
    Prog *p;
    long t, u;

    DBG("%5.2f dodata\n", cputime());

    for(p = datap; p != P; p = p->link) {
        s = p->from.sym;
        if(p->as == ADYNT || p->as == AINIT)
            s->value = dtype;
        if(s->type == SBSS)
            s->type = SDATA;
        if(s->type != SDATA)
            diag("initialize non-data (%d): %s\n%P",
                s->type, s->name, p);
        t = p->from.offset + p->width;
        if(t > s->value)
            diag("initialize bounds (%ld): %s\n%P",
                s->value, s->name, p);
    }
    /* allocate small guys */
    datsize = 0;
    for(i=0; i<NHASH; i++)
    for(s = hash[i]; s != S; s = s->link) {
        if(s->type != SDATA)
        if(s->type != SBSS)
            continue;
        t = s->value;
        if(t == 0) {
            diag("%s: no size", s->name);
            t = 1;
        }
        t = rnd(t, 4);;
        s->value = t;
        if(t > MINSIZ)
            continue;
        s->value = datsize;
        datsize += t;
        s->type = SDATA1;
    }

    /* allocate the rest of the data */
    for(i=0; i<NHASH; i++)
    for(s = hash[i]; s != S; s = s->link) {
        if(s->type != SDATA) {
            if(s->type == SDATA1)
                s->type = SDATA;
            continue;
        }
        t = s->value;
        s->value = datsize;
        datsize += t;
    }

    if(debug['j']) {
        /*
         * pad data with bss that fits up to next
         * 8k boundary, then push data to 8k
         */
        u = rnd(datsize, 8192);
        u -= datsize;
        for(i=0; i<NHASH; i++)
        for(s = hash[i]; s != S; s = s->link) {
            if(s->type != SBSS)
                continue;
            t = s->value;
            if(t > u)
                continue;
            u -= t;
            s->value = datsize;
            s->type = SDATA;
            datsize += t;
        }
        datsize += u;
    }

    /* now the bss */
    bsssize = 0;
    for(i=0; i<NHASH; i++)
    for(s = hash[i]; s != S; s = s->link) {
        if(s->type != SBSS)
            continue;
        t = s->value;
        s->value = bsssize + datsize;
        bsssize += t;
    }
    xdefine("bdata", SDATA, 0L);
    xdefine("edata", SBSS, datsize);
    xdefine("end", SBSS, bsssize + datsize);
    /* etext is defined in span.c */
}
@

<<function span(x86)>>=
void
span(void)
{
    Prog *p, *q;
    long v, c, idat;
    int m, n, again;

    xdefine("etext", STEXT, 0L);
    idat = INITDAT;
    for(p = firstp; p != P; p = p->link) {
        if(p->as == ATEXT)
            curtext = p;
        n = 0;
        if(p->to.type == D_BRANCH)
            if(p->pcond == P)
                p->pcond = p;
        if((q = p->pcond) != P)
            if(q->back != 2)
                n = 1;
        p->back = n;
        if(p->as == AADJSP) {
            p->to.type = D_SP;
            v = -p->from.offset;
            p->from.offset = v;
            p->as = AADDL;
            if(v < 0) {
                p->as = ASUBL;
                v = -v;
                p->from.offset = v;
            }
            if(v == 0)
                p->as = ANOP;
        }
    }
    n = 0;

start:

    DBG("%5.2f span\n", cputime());

    c = INITTEXT;
    for(p = firstp; p != P; p = p->link) {
        if(p->as == ATEXT)
            curtext = p;
        if(p->to.type == D_BRANCH)
            if(p->back)
                p->pc = c;
        asmins(p);
        p->pc = c;
        m = andptr-and;
        p->mark = m;
        c += m;
    }

loop:
    n++;

    DBG("%5.2f span %d\n", cputime(), n);

    if(n > 50) {
        print("span must be looping\n");
        errorexit();
    }
    again = 0;
    c = INITTEXT;
    for(p = firstp; p != P; p = p->link) {
        if(p->as == ATEXT)
            curtext = p;
        if(p->to.type == D_BRANCH) {
            if(p->back)
                p->pc = c;
            asmins(p);
            m = andptr-and;
            if(m != p->mark) {
                p->mark = m;
                again++;
            }
        }
        p->pc = c;
        c += p->mark;
    }
    if(again) {
        textsize = c;
        goto loop;
    }
    if(INITRND) {
        INITDAT = rnd(c, INITRND);
        if(INITDAT != idat) {
            idat = INITDAT;
            goto start;
        }
    }
    xdefine("etext", STEXT, c);

    DBG("etext = %lux\n", c);

    for(p = textp; p != P; p = p->pcond)
        p->from.sym->value = p->pc;
    textsize = c - INITTEXT;
}
@

<<function datblk(x86)>>=
void
datblk(long s, long n)
{
    Prog *p;
    char *cast;
    long l, fl, j;
    int i, c;

    memset(buf.dbuf, 0, n+Dbufslop);
    for(p = datap; p != P; p = p->link) {
        curp = p;
        l = p->from.sym->value + p->from.offset - s;
        c = p->from.scale;
        i = 0;
        if(l < 0) {
            if(l+c <= 0)
                continue;
            while(l < 0) {
                l++;
                i++;
            }
        }
        if(l >= n)
            continue;
        if(p->as != AINIT && p->as != ADYNT) {
            for(j=l+(c-i)-1; j>=l; j--)
                if(buf.dbuf[j]) {
                    print("%P\n", p);
                    diag("multiple initialization");
                    break;
                }
        }
        switch(p->to.type) {
        case D_FCONST:
            switch(c) {
            default:
            case 4:
                fl = ieeedtof(&p->to.ieee);
                cast = (char*)&fl;
                if(debug['a'] && i == 0) {
                    Bprint(&bso, pcstr, l+s+INITDAT);
                    for(j=0; j<c; j++)
                        Bprint(&bso, "%.2ux", cast[fnuxi4[j]] & 0xff);
                    Bprint(&bso, "\t%P\n", curp);
                }
                for(; i<c; i++) {
                    buf.dbuf[l] = cast[fnuxi4[i]];
                    l++;
                }
                break;
            case 8:
                cast = (char*)&p->to.ieee;
                if(debug['a'] && i == 0) {
                    Bprint(&bso, pcstr, l+s+INITDAT);
                    for(j=0; j<c; j++)
                        Bprint(&bso, "%.2ux", cast[fnuxi8[j]] & 0xff);
                    Bprint(&bso, "\t%P\n", curp);
                }
                for(; i<c; i++) {
                    buf.dbuf[l] = cast[fnuxi8[i]];
                    l++;
                }
                break;
            }
            break;

        case D_SCONST:
            if(debug['a'] && i == 0) {
                Bprint(&bso, pcstr, l+s+INITDAT);
                for(j=0; j<c; j++)
                    Bprint(&bso, "%.2ux", p->to.scon[j] & 0xff);
                Bprint(&bso, "\t%P\n", curp);
            }
            for(; i<c; i++) {
                buf.dbuf[l] = p->to.scon[i];
                l++;
            }
            break;

        default:
            fl = p->to.offset;
            if(p->to.type == D_ADDR) {
                if(p->to.index != D_STATIC && p->to.index != D_EXTERN)
                    diag("DADDR type%P", p);
                if(p->to.sym) {
                    if(p->to.sym->type == SUNDEF)
                        ckoff(p->to.sym, fl);
                    fl += p->to.sym->value;
                    if(p->to.sym->type != STEXT && p->to.sym->type != SUNDEF)
                        fl += INITDAT;
                    <<[[datblk()]] if dynamic module(x86)>>
                }
            }
            cast = (char*)&fl;
            switch(c) {
            default:
                diag("bad nuxi %d %d\n%P", c, i, curp);
                break;
            case 1:
                if(debug['a'] && i == 0) {
                    Bprint(&bso, pcstr, l+s+INITDAT);
                    for(j=0; j<c; j++)
                        Bprint(&bso, "%.2ux", cast[inuxi1[j]] & 0xff);
                    Bprint(&bso, "\t%P\n", curp);
                }
                for(; i<c; i++) {
                    buf.dbuf[l] = cast[inuxi1[i]];
                    l++;
                }
                break;
            case 2:
                if(debug['a'] && i == 0) {
                    Bprint(&bso, pcstr, l+s+INITDAT);
                    for(j=0; j<c; j++)
                        Bprint(&bso, "%.2ux", cast[inuxi2[j]] & 0xff);
                    Bprint(&bso, "\t%P\n", curp);
                }
                for(; i<c; i++) {
                    buf.dbuf[l] = cast[inuxi2[i]];
                    l++;
                }
                break;
            case 4:
                if(debug['a'] && i == 0) {
                    Bprint(&bso, pcstr, l+s+INITDAT);
                    for(j=0; j<c; j++)
                        Bprint(&bso, "%.2ux", cast[inuxi4[j]] & 0xff);
                    Bprint(&bso, "\t%P\n", curp);
                }
                for(; i<c; i++) {
                    buf.dbuf[l] = cast[inuxi4[i]];
                    l++;
                }
                break;
            }
            break;
        }
    }
    write(cout, buf.dbuf, n);
}
@



<<[[asmb()]] if dynamic module magic header adjustment(x86)>>=
if(dlm)
    magic |= 0x80000000;
@


<<function asmb(x86)>>=
void
asmb(void)
{
    Prog *p;
    long v, magic;
    int a;
    byte *op1;

    DBG("%5.2f asmb\n", cputime());

    // TEXT SECTION

    seek(cout, HEADR, SEEK__START);
    pc = INITTEXT;
    curp = firstp;

    for(p = firstp; p != P; p = p->link) {
        if(p->as == ATEXT)
            curtext = p;
        if(p->pc != pc) {
            if(!debug['a'])
                print("%P\n", curp);
            diag("phase error %lux sb %lux in %s", p->pc, pc, TNAME);
            pc = p->pc;
        }
        curp = p;

        // generate instruction!
        asmins(p);

        if(cbc < sizeof(and))
            cflush();
        a = (andptr - and);

        if(debug['a']) {
            Bprint(&bso, pcstr, pc);
            for(op1 = and; op1 < andptr; op1++)
                Bprint(&bso, "%.2ux", *op1 & 0xff);
            Bprint(&bso, "\t%P\n", curp);
        }

        <<[[asmb()]] if dynamic module, when iterate from firstp(x86)>>

        memmove(cbp, and, a);
        cbp += a;
        pc += a;
        cbc -= a;
    }
    cflush();

    // DATA SECTION

    switch(HEADTYPE) {
    case H_PLAN9:
        seek(cout, HEADR+textsize, SEEK__START);
        break;
    <<[[asmb()]] switch HEADTYPE (to position after text) cases(x86)>>
    default:
        diag("unknown header type %ld", HEADTYPE);
    }

    DBG("%5.2f datblk\n", cputime());

    <<[[asmb()]] if dynamic module, before datblk()>>

    for(v = 0; v < datsize; v += sizeof(buf)-Dbufslop) {
        if(datsize-v > sizeof(buf)-Dbufslop)
            datblk(v, sizeof(buf)-Dbufslop);
        else
            datblk(v, datsize-v);
    }

    // SYMBOL TABLE

    // modified by asmsym()
    symsize = 0;
    // modified by asmlc()
    lcsize = 0;

    if(!debug['s']) {
        DBG("%5.2f sym\n", cputime());

        switch(HEADTYPE) {
        case H_PLAN9:
            seek(cout, HEADR+textsize+datsize, 0);
            break;
        <<[[asmb()]] switch HEADTYPE (for symbol table generation) cases(x86)>>
        default:
            seek(cout, rnd(HEADR+textsize, 8192)+datsize, 0);
            break;
        }

        asmsym();

        DBG("%5.2f sp\n", cputime());
        DBG("%5.2f pc\n", cputime());

        asmlc();

        <<[[asmb()]] if dynamic module, call asmdyn()>>
        cflush();
    } else {
        <<[[asmb()]] if dynamic module and no symbol table generation>>
    }

    // HEADER

    DBG("%5.2f headr\n", cputime());

    seek(cout, 0L, SEEK__START);

    switch(HEADTYPE) {
    // see Exec in a.out.h
    case H_PLAN9:	/* plan9 */
        magic = 4*11*11+7;
        <<[[asmb()]] if dynamic module magic header adjustment(x86)>>
        lput(magic);			/* magic */
        lput(textsize);			/* sizes */
        lput(datsize);
        lput(bsssize);
        lput(symsize);			/* nsyms */

        lput(entryvalue());		/* va of entry */

        lput(spsize);			/* sp offsets */
        lput(lcsize);			/* line offsets */
        break;
    <<[[asmb()]] switch HEADTYPE (for header generation) cases(x86)>>
    }

    cflush();
}
@



<<[[main()]] switch HEADTYPE cases(x86)>>=
case H_GARBAGE:	/* this is garbage */
    HEADR = 20L+56L;
    if(INITTEXT == -1)
        INITTEXT = 0x40004CL;
    if(INITDAT == -1)
        INITDAT = 0x10000000L;
    if(INITRND == -1)
        INITRND = 0;
    break;
case H_COFF:	/* is unix coff */
    HEADR = 0xd0L;
    if(INITTEXT == -1)
        INITTEXT = 0xd0;
    if(INITDAT == -1)
        INITDAT = 0x400000;
    if(INITRND == -1)
        INITRND = 0;
    break;
case H_COM:	/* MS-DOS .COM */
    HEADR = 0;
    if(INITTEXT == -1)
        INITTEXT = 0x0100;
    if(INITDAT == -1)
        INITDAT = 0;
    if(INITRND == -1)
        INITRND = 4;
    break;
case H_EXE:	/* fake MS-DOS .EXE */
    HEADR = 0x200;
    if(INITTEXT == -1)
        INITTEXT = 0x0100;
    if(INITDAT == -1)
        INITDAT = 0;
    if(INITRND == -1)
        INITRND = 4;
    HEADR += (INITTEXT & 0xFFFF);
    DBG("HEADR = 0x%ld\n", HEADR);
    break;
case H_ELF:	/* elf executable */
    HEADR = rnd(Ehdr32sz+3*Phdr32sz, 16);
    if(INITTEXT == -1)
        INITTEXT = 0x80100020L;
    if(INITDAT == -1)
        INITDAT = 0;
    if(INITRND == -1)
        INITRND = 4096;
    break;
@


<<[[asmb()]] switch HEADTYPE (to position after text) cases(x86)>>=
case H_GARBAGE:
    seek(cout, rnd(HEADR+textsize, 8192), 0);
    break;
case H_COFF:
    textsize = rnd(HEADR+textsize, 4096)-HEADR;
    seek(cout, textsize+HEADR, 0);
    break;
case H_ELF: // like H_PLAN9
    seek(cout, HEADR+textsize, 0);
    break;
case H_COM:
case H_EXE:
    seek(cout, HEADR+rnd(textsize, INITRND), 0);
    break;
@

<<[[asmb()]] switch HEADTYPE (for symbol table generation) cases(x86)>>=
case H_GARBAGE:
case H_COFF:
    seek(cout, rnd(HEADR+textsize, INITRND)+datsize, 0);
    break;
//case H_PLAN9:
case H_ELF:
    seek(cout, HEADR+textsize+datsize, 0);
    break;
case H_COM:
case H_EXE:
    debug['s'] = 1;
    break;
@

<<[[asmb()]] switch HEADTYPE (for header generation) cases(x86)>>=
default:
case H_GARBAGE:	/* garbage */
    lput(0x160L<<16);		/* magic and sections */
    lput(0L);			/* time and date */
    lput(rnd(HEADR+textsize, 4096)+datsize);
    lput(symsize);			/* nsyms */
    lput((0x38L<<16)|7L);		/* size of optional hdr and flags */
    lput((0413<<16)|0437L);		/* magic and version */
    lput(rnd(HEADR+textsize, 4096));/* sizes */
    lput(datsize);
    lput(bsssize);
    lput(entryvalue());		/* va of entry */
    lput(INITTEXT-HEADR);		/* va of base of text */
    lput(INITDAT);			/* va of base of data */
    lput(INITDAT+datsize);		/* va of base of bss */
    lput(~0L);			/* gp reg mask */
    lput(0L);
    lput(0L);
    lput(0L);
    lput(0L);
    lput(~0L);			/* gp value ?? */
    break;
case H_COFF:	/* unix coff */
    /*
     * file header
     */
    lputl(0x0004014c);		/* 4 sections, magic */
    lputl(0);			/* unix time stamp */
    lputl(0);			/* symbol table */
    lputl(0);			/* nsyms */
    lputl(0x0003001c);		/* flags, sizeof a.out header */
    /*
     * a.out header
     */
    lputl(0x10b);			/* magic, version stamp */
    lputl(rnd(textsize, INITRND));	/* text sizes */
    lputl(datsize);			/* data sizes */
    lputl(bsssize);			/* bss sizes */
    lput(entryvalue());		/* va of entry */
    lputl(INITTEXT);		/* text start */
    lputl(INITDAT);			/* data start */
    /*
     * text section header
     */
    strnput(".text", 8);
    lputl(HEADR);			/* pa */
    lputl(HEADR);			/* va */
    lputl(textsize);		/* text size */
    lputl(HEADR);			/* file offset */
    lputl(0);			/* relocation */
    lputl(0);			/* line numbers */
    lputl(0);			/* relocation, line numbers */
    lputl(0x20);			/* flags text only */
    /*
     * data section header
     */
    strnput(".data", 8);
    lputl(INITDAT);			/* pa */
    lputl(INITDAT);			/* va */
    lputl(datsize);			/* data size */
    lputl(HEADR+textsize);		/* file offset */
    lputl(0);			/* relocation */
    lputl(0);			/* line numbers */
    lputl(0);			/* relocation, line numbers */
    lputl(0x40);			/* flags data only */
    /*
     * bss section header
     */
    strnput(".bss", 8);
    lputl(INITDAT+datsize);		/* pa */
    lputl(INITDAT+datsize);		/* va */
    lputl(bsssize);			/* bss size */
    lputl(0);			/* file offset */
    lputl(0);			/* relocation */
    lputl(0);			/* line numbers */
    lputl(0);			/* relocation, line numbers */
    lputl(0x80);			/* flags bss only */
    /*
     * comment section header
     */
    strnput(".comment", 8);
    lputl(0);			/* pa */
    lputl(0);			/* va */
    lputl(symsize+lcsize);		/* comment size */
    lputl(HEADR+textsize+datsize);	/* file offset */
    lputl(HEADR+textsize+datsize);	/* offset of syms */
    lputl(HEADR+textsize+datsize+symsize);/* offset of line numbers */
    lputl(0);			/* relocation, line numbers */
    lputl(0x200);			/* flags comment only */
    break;
case H_COM:
    /* MS-DOS .COM */
    break;
case H_EXE:
    /* fake MS-DOS .EXE */
    v = rnd(HEADR+textsize, INITRND)+datsize;
    wputl(0x5A4D);			/* 'MZ' */
    wputl(v % 512);			/* bytes in last page */
    wputl(rnd(v, 512)/512);		/* total number of pages */
    wputl(0x0000);			/* number of reloc items */
    v = rnd(HEADR-(INITTEXT & 0xFFFF), 16);
    wputl(v/16);			/* size of header */
    wputl(0x0000);			/* minimum allocation */
    wputl(0xFFFF);			/* maximum allocation */
    wputl(0x0000);			/* initial ss value */
    wputl(0x0100);			/* initial sp value */
    wputl(0x0000);			/* complemented checksum */
    v = entryvalue();
    wputl(v);			/* initial ip value (!) */
    wputl(0x0000);			/* initial cs value */
    wputl(0x0000);
    wputl(0x0000);
    wputl(0x003E);			/* reloc table offset */
    wputl(0x0000);			/* overlay number */
    break;
case H_ELF:
    elf32(I386, ELFDATA2LSB, 0, nil);
    break;
@




<<function doprof2(x86)>>=
void
doprof2(void)
{
    Sym *s2, *s4;
    Prog *p, *q, *q2;
    Prog *ps2, *ps4;

    DBG("%5.2f profile 2\n", cputime());

    <<[[doprof2()]] if embedded tracing>>
    else{
        s2 = lookup("_profin", 0);
        s4 = lookup("_profout", 0);
    }
    if(s2->type != STEXT || s4->type != STEXT) {
       <<[[doprof2()]] if embedded tracing diag()>>
        else
            diag("_profin/_profout not defined");
        return;
    }

    // finding ps2, ps4 = instruction (Prog) of s2 and s4
    ps2 = P;
    ps4 = P;
    for(p = firstp; p != P; p = p->link) {
        if(p->as == ATEXT) {
            if(p->from.sym == s2) {
                // do not profile the profling function itself ...
                p->from.scale = NOPROF;
                ps2 = p;
            }
            if(p->from.sym == s4) {
                p->from.scale = NOPROF;
                ps4 = p;
            }
        }
    }

    for(p = firstp; p != P; p = p->link) {
        if(p->as == ATEXT) {
            curtext = p;

            <<[[doprof2()]] if NOPROF p(x86)>>

            /*
             * JMPL	profin
             */
            q = prg();
            q->line = p->line;
            q->pc = p->pc;
            q->link = p->link;

            <<[[doprof2()]] if embedded tracing ATEXT instrumentation(x86)>>
             else
                p->link = q;
            p = q;
            //asm: CALL _profin
            p->as = ACALL;
            p->to.type = D_BRANCH;
            p->pcond = ps2;
            p->to.sym = s2;

        }else if(p->as == ARET) {
            <<[[doprof2()]] if embedded tracing ARET instrumentation>>
            /*
             * RET
             */
            q = prg();
            q->as = ARET;
            q->from = p->from;
            q->to = p->to;
            q->link = p->link;

            p->link = q;

            /*
             * JAL	profout
             */
            //asm: CALL _profout
            p->as = ACALL;
            p->from = zprg.from;
            p->to = zprg.to;
            p->to.type = D_BRANCH;
            p->pcond = ps4;
            p->to.sym = s4;

            p = q;
        }
    }
}
@



<<[[doprof2()]] if NOPROF p(x86)>>=
if(p->from.scale & NOPROF) {	/* dont profile */
    for(;;) {
        q = p->link;
        if(q == P)
            break;
        if(q->as == ATEXT)
            break;
        p = q;
    }
    continue;
}
@

<<[[doprof2()]] if embedded tracing ATEXT instrumentation(x86)>>=
if(debug['e']){		/* embedded tracing */
    q2 = prg();
    p->link = q2;
    q2->link = q;

    q2->line = p->line;
    q2->pc = p->pc;

    q2->as = AJMP;
    q2->to.type = D_BRANCH;
    q2->to.sym = p->to.sym;
    q2->pcond = q->link;
}
@


<<[[main()]] cout is ready, LET'S GO(x86)>>=
firstp = prg();
lastp = firstp;

<<[[main()]] set INITENTRY>>

while(*argv)
    objfile(*argv++);

if(load_libs)
    loadlib();

firstp = firstp->link;
if(firstp == P)
    errorexit();

<<[[main()]] if export table or dynamic module(x86)>>

patch();
follow();
dodata();
dostkoff();
<<[[main()]] call doprofxxx() if profiling>>
span();
doinit();

// write to cout, finally
asmb();

// sanity check
undef();
@


<<[[main()]] command line processing(x86)>>=
    case 'o': /* output to (next arg) */
        outfile = ARGF();
        break;
@


<<function main (linkers/8l/obj.c)>>=
void
main(int argc, char *argv[])
{
    <<[[main()]] locals(x86)>>

    thechar = '8';
    thestring = "386";   
    outfile = "8.out";

    <<[[main()]] debug initialization(x86)>>

    ARGBEGIN {
    <<[[main()]] command line processing(x86)>>
    } ARGEND
    USED(argc);
    if(*argv == nil)
        usage();

    <<[[main()]] addlibpath("/{thestring}/lib") or ccroot>>

    <<[[main()]] adjust HEADTYPE if debug flags(x86)>>
    switch(HEADTYPE) {
    <<[[main()]] switch HEADTYPE cases(x86)>>
    default:
        diag("unknown -H option");
        errorexit();

    }
    <<[[main()]] last INITXXX adjustments>>

    DBG("HEADER = -H0x%ld -T0x%lux -D0x%lux -R0x%lux\n",
            HEADTYPE, INITTEXT, INITDAT, INITRND);

    <<[[main()]] sanity check optab(x86)>>
    <<[[main()]] initialize globals(x86)>>

    nuxiinit();

    cout = create(outfile, 1, 0775);
    if(cout < 0) {
        diag("cannot create %s: %r", outfile);
        errorexit();
    }

    // ------ main functions  ------
    <<[[main()]] cout is ready, LET'S GO(x86)>>

    <<[[main()]] profile report>>
    errorexit();
}
@
%$ 


<<[[main()]] command line processing(x86)>>=
case 'H':
    a = ARGF();
    if(a)
        HEADTYPE = atolwhex(a);
    break;
case 'T':
    a = ARGF();
    if(a)
        INITTEXT = atolwhex(a);
    break;
case 'D':
    a = ARGF();
    if(a)
        INITDAT = atolwhex(a);
    break;
case 'E':
    a = ARGF();
    if(a)
        INITENTRY = a;
    break;
case 'R':
    a = ARGF();
    if(a)
        INITRND = atolwhex(a);
    break;
@


<<[[main()]] switch HEADTYPE cases(x86)>>=
case H_PLAN9:	/* plan 9 */
    HEADR = 32L;
    if(INITTEXT == -1)
        INITTEXT = 4096+32;
    if(INITDAT == -1)
        INITDAT = 0;
    if(INITRND == -1)
        INITRND = 4096;
    break;
@

% used locals? move closer the the code that use it then
<<[[main()]] locals(x86)>>=
    int i, c;
    char name[LIBNAMELEN];
    char *a;
@

<<[[main()]] initialize globals(x86)>>=
<<[[main()]] set ycover(x86)>>
<<[[main()]] set reg(x86)>>
<<[[main()]] set zprg(x86)>>
dtype = 4;

cbp = buf.cbuf;
cbc = sizeof(buf.cbuf);
@

<<[[main()]] set zprg(x86)>>=
zprg.link = P;
zprg.pcond = P;
zprg.back = 2;
zprg.as = AGOK;
zprg.from.type = D_NONE;
zprg.from.index = D_NONE;
zprg.from.scale = 1;
zprg.to = zprg.from;
@

<<[[main()]] locals(x86)>>=
bool load_libs;
@

% -l means no automagic stdlibs
<<[[main()]] initialize globals(x86)>>=
load_libs = !debug['l'];
@


<<[[main()]] command line processing(x86)>>=
case 'L':
    addlibpath(EARGF(usage()));
    break;
@

% was called a
<<[[main()]] locals(x86)>>=
char *root;
@

% starts at 1 because of AXXX (but why need AXXX?)
<<[[main()]] sanity check optab(x86)>>=
for(i=1; optab[i].as; i++)
    if(i != optab[i].as) {
        diag("phase error in optab: %d", i);
        errorexit();
    }
@

<<[[main()]] command line processing(x86)>>=
case 'x':	/* produce export table */
    doexp = true;
    if(argv[1] != nil && argv[1][0] != '-' && !isobjfile(argv[1])){
        a = ARGF();
        if(strcmp(a, "*") == 0)
            allexport = true;
        else
            readundefs(a, SEXPORT);
    }
    break;
@

<<[[main()]] if dynamic module(x86)>>=
if(dlm){
    import();
    HEADTYPE = H_PLAN9;
    INITTEXT = INITDAT = 0;
    INITRND = 8;
    INITENTRY = EXPTAB;
}
@

<<[[main()]] if export table or dynamic module(x86)>>=
if(doexp || dlm){
    EXPTAB = "_exporttab";
    zerosig(EXPTAB);
    zerosig("etext");
    zerosig("edata");
    zerosig("end");

   <<[[main()]] if dynamic module(x86)>>

    export();
}
@

<<[[main()]] command line processing(x86)>>=
case 'u':	/* produce dynamically loadable module */
    dlm = true;
    // do not load standard libraries
    debug['l'] = true;

    if(argv[1] != nil && argv[1][0] != '-' && !isobjfile(argv[1]))
        readundefs(ARGF(), SIMPORT);
    break;
@


<<[[asmb()]] if dynamic module, when iterate from firstp(x86)>>=
if(dlm) {
    if(p->as == ATEXT)
        reloca = nil;
    else if(reloca != nil)
        diag("reloc failure: %P", curp);
}
@

<<[[datblk()]] if dynamic module(x86)>>=
if(dlm)
    dynreloc(p->to.sym, l+s+INITDAT, 1);
@


<<[[main()]] command line processing(x86)>>=
case 'P':
    a = ARGF();
    if(a)
        INITTEXTP = atolwhex(a);
    break;
@

<<[[main()]] debug initialization(x86)>>=
Binit(&bso, 1, OWRITE);
listinit(); // fmtinstall()
memset(debug, false, sizeof(debug));
@

<<[[main()]] command line processing(x86)>>=
default:
    c = ARGC();
    if(c >= 0 && c < sizeof(debug))
        debug[c] = true;
    break;
@

% obsolete?
<<[[main()]] adjust HEADTYPE if debug flags(x86)>>=
if(!debug['9'] && !debug['U'] && !debug['B'])
    debug[DEFAULT] = true;

if(HEADTYPE == -1) {
    if(debug['U'])
        HEADTYPE = 1;
    if(debug['B'])
        HEADTYPE = 2;
    if(debug['9'])
        HEADTYPE = 2;
}
@

<<function ldobj(x86)>>=
void
ldobj(fdt f, long c, char *pn)
{
    <<[[ldobj()]] locals(x86)>>

    <<[[ldobj()]] grow filen if not enough space>>
    filen[files++] = strdup(pn);

    <<[[ldobj()]] bloc and bsize init>>

    di = S;

// can come from AEND
newloop:
    version++;
    memset(h, 0, sizeof(h));
    histfrogp = 0;
    ipc = pc;
    skip = false;

loop:
    if(c <= 0)
        goto eof;

    <<[[ldobj()]] read if needed in loop:, adjust block and bsize>>

    // get the opcode
    o = bloc[0] | (bloc[1] << 8); // >>

    <<[[ldobj()]] sanity check opcode in range(x86)>>

    <<[[ldobj()]] if ANAME or ASIGNAME(x86)>>

    //TODO: factorize
    while(nhunk < sizeof(Prog))
        gethunk();
    p = (Prog*)hunk;
    nhunk -= sizeof(Prog);
    hunk += sizeof(Prog);

    p->as = o;
    p->line = bloc[2] | (bloc[3] << 8) | (bloc[4] << 16) | (bloc[5] << 24);
    p->back = 2;
    // >> >> >>

    r = zaddr(bloc+6, &p->from, h) + 6;
    r += zaddr(bloc+r, &p->to, h);

    bloc += r;
    c -= r;

    if(debug['W'])
        print("%P\n", p);

    switch(p->as) {
    <<[[ldobj()]] switch as cases(x86)>>

    default:
    casdef:
        if(skip)
            nopout(p);

        if(p->to.type == D_BRANCH)
            p->to.offset += ipc;

        lastp->link = p;
        lastp = p;

        p->pc = pc;
        pc++;
    }
    goto loop;

eof:
    diag("truncated object file: %s", pn);
}
@

% >> >> >> >>

<<[[ldobj()]] locals(x86)>>=
// enum<as>, the opcode
int o;
Prog *p;
@


% ???
<<[[ldobj()]] locals(x86)>>=
Sym *h[NSYM];
Sym *di;
Sym *s;
long ipc;
bool skip;
@

%???
<<[[ldobj()]] locals(x86)>>=
Prog *t;
byte *stop;
int v;
ulong sig;
@

<<[[ldobj()]] locals(x86)>>=
byte *bloc;
byte *bsize;
int r;
@
% and parameter 'int c'

<<[[ldobj()]] sanity check opcode in range(x86)>>=
if(o <= AXXX || o >= ALAST) {
    if(o < 0)
        goto eof;
    diag("%s: opcode out of range %d", pn, o);
    print("	probably not a .8 file\n");
    errorexit();
}
@

<<[[ldobj()]] locals(x86)>>=
// array<string>, length used = files, extended every 16
static char **filen;
static int files = 0;
char **nfilen;
@

<<[[ldobj()]] if ANAME or ASIGNAME(x86)>>=
if(o == ANAME || o == ASIGNAME) {
    sig = 0;
    if(o == ASIGNAME) {
        sig = bloc[2] | (bloc[3]<<8) | (bloc[4]<<16) | (bloc[5]<<24);
        // >> >> >>
        bloc += 4;
        c -= 4;
    }
    stop = memchr(&bloc[4], 0, bsize-&bloc[4]);
    if(stop == nil){
        bsize = readsome(f, buf.xbuf, bloc, bsize, c);
        if(bsize == 0)
            goto eof;
        bloc = buf.xbuf;
        stop = memchr(&bloc[4], 0, bsize-&bloc[4]);
        if(stop == nil){
            fprint(2, "%s: name too long\n", pn);
            errorexit();
        }
    }

    v = bloc[2];	/* type */
    o = bloc[3];	/* sym */
    bloc += 4;
    c -= 4;

    r = 0;
    if(v == D_STATIC)
        r = version;
    s = lookup((char*)bloc, r);

    c -= &stop[1] - bloc;
    bloc = stop + 1;

    if(debug['S'] && r == 0)
        sig = 1729;
    if(sig != 0){
        if(s->sig != 0 && s->sig != sig)
            diag("incompatible type signatures %lux(%s) and %lux(%s) for %s", s->sig, filen[s->file], sig, pn, s->name);
        s->sig = sig;
        s->file = files-1;
    }

    if(debug['W'])
        print("	ANAME	%s\n", s->name);

    h[o] = s;
    if((v == D_EXTERN || v == D_STATIC) && s->type == 0)
        s->type = SXREF;
    if(v == D_FILE) {
        if(s->type != SFILE) {
            histgen++;
            s->type = SFILE;
            s->value = histgen;
        }
        if(histfrogp < MAXHIST) {
            histfrog[histfrogp] = s;
            histfrogp++;
        } else
            collapsefrog(s);
    }
    goto loop;
}
@
% >> >> >>

<<[[ldobj()]] switch as cases(x86)>>=
case ATEXT:
    if(curtext != P) {
        histtoauto();
        curtext->to.autom = curauto;
        curauto = 0;
    }
    skip = false;
    curtext = p;
    s = p->from.sym;
    if(s == S) {
        diag("%s: no TEXT symbol: %P", pn, p);
        errorexit();
    }
    if(s->type != 0 && s->type != SXREF) {
        if(p->from.scale & DUPOK) {
            skip = true;
            goto casdef;
        }
        diag("%s: redefinition: %s\n%P", pn, s->name, p);
    }
    s->type = STEXT;
    s->value = pc;

    //add_list(firstp, lastp, p)
    lastp->link = p;
    lastp = p;

    p->pc = pc;
    pc++;

    //add_list(textp, etextp, p)
    if(textp == P) {
        textp = p;
        etextp = p;
    } else {
        etextp->pcond = p;
        etextp = p;
    }

    break;
@

<<[[ldobj()]] switch as cases(x86)>>=
case ADATA:
data:
    //add_list(datap, edatap, p)
    if(edatap == P)
        datap = p;
    else
        edatap->link = p;
    edatap = p;
    p->link = P;
    break;
@

<<[[ldobj()]] switch as cases(x86)>>=
case ADYNT:
    if(p->to.sym == S) {
        diag("DYNT without a sym\n%P", p);
        break;
    }
    di = p->to.sym;
    p->from.scale = 4; // NOSPLIT?
    if(di->type == SXREF) {
        if(debug['z'])
            Bprint(&bso, "%P set to %d\n", p, dtype);
        di->type = SCONST;
        di->value = dtype;
        dtype += 4;
    }
    if(p->from.sym == S)
        break;

    p->from.offset = di->value;
    p->from.sym->type = SDATA;
    if(curtext == P) {
        diag("DYNT not in text: %P", p);
        break;
    }
    p->to.sym = curtext->from.sym;
    p->to.type = D_ADDR;
    p->to.index = D_EXTERN;
    goto data;
@

<<[[ldobj()]] switch as cases(x86)>>=
case AINIT:
    if(p->from.sym == S) {
        diag("INIT without a sym\n%P", p);
        break;
    }
    if(di == S) {
        diag("INIT without previous DYNT\n%P", p);
        break;
    }
    p->from.offset = di->value;
    p->from.sym->type = SDATA;
    goto data;
@

<<[[ldobj()]] switch as cases(x86)>>=
case AGLOBL:
    s = p->from.sym;
    if(s->type == 0 || s->type == SXREF) {
        s->type = SBSS;
        s->value = 0;
    }
    if(s->type != SBSS) {
        diag("%s: redefinition: %s in %s",
            pn, s->name, TNAME);
        s->type = SBSS;
        s->value = 0;
    }
    if(p->to.offset > s->value)
        s->value = p->to.offset;
    break;
@

<<[[ldobj()]] switch as cases(x86)>>=
case AHISTORY:
    if(p->to.offset == -1) {
        addlib(pn);
        histfrogp = 0;
        goto loop;
    }
    addhist(p->line, D_FILE);		/* 'z' */
    if(p->to.offset)
        addhist(p->to.offset, D_FILE1);	/* 'Z' */
    histfrogp = 0;
    break;
@

<<[[ldobj()]] switch as cases(x86)>>=
case AEND:
    histtoauto();
    if(curtext != P)
        curtext->to.autom = curauto;
    curauto = 0;
    curtext = P;
    if(c)
        goto newloop;
    return;
@


<<[[ldobj()]] switch as cases(x86)>>=
case AGOK:
    diag("%s: GOK opcode in %s", pn, TNAME);
    pc++;
    break;
@

<<[[ldobj()]] switch as cases(x86)>>=
case AFMOVF:
case AFADDF:
case AFSUBF:
case AFSUBRF:
case AFMULF:
case AFDIVF:
case AFDIVRF:
case AFCOMF:
case AFCOMFP:
    if(skip)
        goto casdef;
    if(p->from.type == D_FCONST) {
        /* size sb 9 max */
        sprint(literal, "$%lux", ieeedtof(&p->from.ieee));
        s = lookup(literal, 0);
        if(s->type == 0) {
            s->type = SBSS;
            s->value = 4;
            t = prg();
            t->as = ADATA;
            t->line = p->line;
            t->from.type = D_EXTERN;
            t->from.sym = s;
            t->from.scale = 4;  // NOSPLIT?
            t->to = p->from;
            if(edatap == P)
                datap = t;
            else
                edatap->link = t;
            edatap = t;
            t->link = P;
        }
        p->from.type = D_EXTERN;
        p->from.sym = s;
        p->from.offset = 0;
    }
    goto casdef;
@
%$

<<[[ldobj()]] switch as cases(x86)>>=
case AFMOVD:
case AFADDD:
case AFSUBD:
case AFSUBRD:
case AFMULD:
case AFDIVD:
case AFDIVRD:
case AFCOMD:
case AFCOMDP:
    if(skip)
        goto casdef;
    if(p->from.type == D_FCONST) {
        /* size sb 18 max */
        sprint(literal, "$%lux.%lux",
            p->from.ieee.l, p->from.ieee.h);
        s = lookup(literal, 0);
        if(s->type == 0) {
            s->type = SBSS;
            s->value = 8;
            t = prg();
            t->as = ADATA;
            t->line = p->line;
            t->from.type = D_EXTERN;
            t->from.sym = s;
            t->from.scale = 8;
            t->to = p->from;
            if(edatap == P)
                datap = t;
            else
                edatap->link = t;
            edatap = t;
            t->link = P;
        }
        p->from.type = D_EXTERN;
        p->from.sym = s;
        p->from.offset = 0;
    }
    goto casdef;
@
%$


\section{[[linkers/8l/]]}

\subsection*{[[linkers/8l/elf.h]]}

%-------------------------------------------------------------

<<linkers/8l/elf.h>>=
#include <elf.h>

// vs include/elf.h? and libmach/elf.h?

<<enum _anon_ (linkers/8l/elf.h)>>

typedef void (*Putl)(long);

void	elf32(int mach, int bo, int addpsects, void (*putpsects)(Putl));
@
%void	elf64(int mach, int bo, int addpsects, void (*putpsects)(Putl));
%
%//void	elf32phdr(void (*putl)(long), ulong type, ulong off, ulong vaddr,
%//    ulong paddr, ulong filesz, ulong memsz, ulong prots, ulong align);
%//void	elf32shdr(void (*putl)(long), ulong name, ulong type, ulong flags,
%//    ulong vaddr, ulong off, ulong sectsz, ulong link, ulong addnl,
%//    ulong align, ulong entsz);
%//void	elf64phdr(void (*putl)(long), void (*putll)(vlong), ulong type,
%//    uvlong off, uvlong vaddr, uvlong paddr, uvlong filesz, uvlong memsz,
%//    ulong prots, uvlong align);
%//void	elf64shdr(void (*putl)(long), void (*putll)(vlong), ulong name,
%//    ulong type, uvlong flags, uvlong vaddr, uvlong off, uvlong sectsz,
%//    ulong link, ulong addnl, uvlong align, uvlong entsz);


\subsection*{[[linkers/8l/l.h]]}





<<enum misc1(x86)>>=
enum misc1 {
    <<constant NHASH linker>>
    <<constant NHUNK linker>>

    MINSIZ		= 4,
    <<constant STRINGSZ>>
    MINLC		= 1,
    <<constant MAXIO>>
    MAXHIST		= 20, /* limit of path elements for history symbols */
};
@


%-------------------------------------------------------------

<<linkers/8l/l.h>>=
#include	<u.h>
#include	<libc.h>
#include	<bio.h>

#include	<common.out.h>
#include	<386/8.out.h>
#include	"elf.h"

<<macro DBG>>

<<constant P>>
<<constant S>>

<<constant TNAME(x86)>>

<<function cput(x86)>>

<<constant LIBNAMELEN>>

typedef	struct	Adr	Adr;
typedef	struct	Prog	Prog;
typedef	struct	Sym	Sym;
typedef	struct	Auto	Auto;
typedef	struct	Optab	Optab;

<<struct Adr(x86)>>

<<constant offset>>
<<constant scon(x86)>>
<<constant cond(x86)>>
<<constant ieee>>

<<constant autom>>
<<constant sym>>

<<struct Prog(x86)>>
<<struct Auto(x86)>>
<<struct Sym>>
<<struct Optab(x86)>>

<<enum sxxx(x86)>>
<<enum yxxx(x86)>>
<<enum zxxx(x86)>>
<<enum pxxx(x86)>>
<<enum rxxx>>

<<enum misc1(x86)>>

<<enum headtype(x86)>>

<<struct Buf>>
extern union Buf buf;

<<constant cbuf>>
<<constant xbuf>>

#pragma	varargck	type	"A"	int
#pragma	varargck	type	"A"	uint
#pragma	varargck	type	"D"	Adr*
#pragma	varargck	type	"P"	Prog*
#pragma	varargck	type	"R"	int
#pragma	varargck	type	"R"	uint
#pragma	varargck	type	"S"	char*

#pragma	varargck	argpos	diag 1

extern	long	HEADR;
extern	long	HEADTYPE;
extern	long	INITDAT;
extern	long	INITRND;
extern	long	INITTEXT;
extern	long	INITTEXTP;
extern	char*	INITENTRY;		/* entry point */

extern	Biobuf	bso;
extern	long	bsssize;
extern	int	cbc;
extern	char*	cbp;
extern	char*	pcstr;
extern	int	cout;
extern	Prog*	curp;
extern	Prog*	curtext;
extern	Prog*	datap;
extern	Prog*	edatap;
extern	long	datsize;
extern	bool	debug[128];
extern	Prog*	firstp;
extern	char	fnuxi8[8];
extern	char	fnuxi4[4];
extern	Sym*	hash[NHASH];
extern	char*	hunk;
extern	char	inuxi1[1];
extern	char	inuxi2[2];
extern	char	inuxi4[4];
extern	char	ycover[Ymax*Ymax];
extern	uchar*	andptr;
extern	uchar	and[30];
extern	char	reg[D_NONE];
extern	Prog*	lastp;
extern	long	lcsize;
extern	int	nerrors;
extern	long	nhunk;
extern	long	nsymbol;
//@Scheck: used by TName, not useless
extern	char*	noname;
extern	char*	outfile;
extern	long	pc;
extern	long	symsize;
extern	Prog*	textp;
extern	long	textsize;
extern	long	thunk;
extern	Prog	zprg;
extern	int	dtype;

extern	Adr*	reloca;
extern	bool	dlm;
extern	int	imports, nimports;
extern	int	exports, nexports;
bool allexport;
extern	char*	EXPTAB;
extern	Prog	undefp;

<<constant UP>>

extern	Optab	optab[];
//@Scheck: defined in ../8c/enam.c
extern	char*	anames[];


Prog*	appendp(Prog*);
void	asmb(void);
void	asmdyn(void);
void	asmins(Prog*);
void	asmlc(void);

void	asmsym(void);
long	atolwhex(char*);

void	cflush(void);
void	ckoff(Sym*, long);
Prog*	copyp(Prog*);

double	cputime(void); //?


void	diag(char*, ...);
void	dodata(void);
void	doinit(void);
void	dostkoff(void);
void	dynreloc(Sym*, ulong, int);

void	errorexit(void);
void	export(void);
int	fileexists(char*);


void	follow(void);
void	gethunk(void);
long	ieeedtof(Ieee*);
void	import(void);

void	listinit(void);
Sym*	lookup(char*, int);
void	lput(long);
void	lputl(long);
void	llput(vlong v);
void	llputl(vlong v);
void	main(int, char*[]);

void	patch(void);
Prog*	prg(void);


long	rnd(long, long);
void	span(void);
void	strnput(char*, int);
void	undef(void);
void	undefsym(Sym*);

void	wput(long);
void	wputl(long);
void	xdefine(char*, int, long);

void mylog(char*, ...);


#pragma	varargck	type	"D"	Adr*
#pragma	varargck	type	"P"	Prog*
#pragma	varargck	type	"R"	int
#pragma	varargck	type	"A"	int
@


\subsection*{[[linkers/8l/globals.c]]}


<<global literal(x86)>>=
char	literal[32];
@




<<global andptr(x86)>>=
uchar*	andptr;
@

<<global and(x86)>>=
uchar	and[30];
@


<<global dtype(x86)>>=
int	dtype;
@



%-------------------------------------------------------------

<<linkers/8l/globals.c>>=
#include	"l.h"

<<global buf>>

<<global HEADR>>
<<global HEADTYPE>>
<<global INITDAT>>
<<global INITRND>>
<<global INITTEXT>>
<<global INITTEXTP>>
<<global INITENTRY>>

<<global bso>>
<<global bsssize>>

<<global cbc>>
<<global cbp>>

<<global pcstr(x86)>>
<<global cout>>
<<global curp>>
<<global curtext>>
<<global datap>>
<<global edatap(x86)>>
<<global datsize>>
<<global debug>>
<<global firstp>>

<<global fnuxi4>>
<<global fnuxi8>>

<<global hash linker>>
<<global hunk>>

<<global inuxi1>>
<<global inuxi2>>
<<global inuxi4>>

<<global ycover(x86)>>
<<global andptr(x86)>>
<<global and(x86)>>
<<global reg(x86)>>
<<global lastp>>
<<global lcsize>>
<<global nerrors>>
<<global nhunk>>
<<global nsymbol linker>>
<<global outfile>>

<<global pc>>

<<global symsize>>
<<global textp>>
<<global textsize>>
<<global thunk>>
<<global zprg>>
<<global dtype(x86)>>

<<global reloca(x86)>>

<<global dlm>>
<<global nimports>>
<<global nexports>>
<<global imports>>
<<global exports>>

int	allexport;

<<global EXPTAB>>
<<global undefp>>

@


\subsection*{[[linkers/8l/optab.c]]}

%-------------------------------------------------------------

<<linkers/8l/optab.c>>=
#include	"l.h"

<<global ynone(x86)>>
<<global ytext(x86)>>
<<global ynop(x86)>>
<<global yxorb(x86)>>
<<global yxorl(x86)>>
<<global yaddl(x86)>>
<<global yincb(x86)>>
<<global yincl(x86)>>
<<global ycmpb(x86)>>
<<global ycmpl(x86)>>
<<global yshb(x86)>>
<<global yshl(x86)>>
<<global ytestb(x86)>>
<<global ytestl(x86)>>
<<global ymovb(x86)>>
<<global ymovl(x86)>>
<<global ym_rl(x86)>>
<<global yrl_m(x86)>>
<<global ymb_rl(x86)>>
<<global yml_rl(x86)>>
<<global yrl_ml(x86)>>
<<global yml_mb(x86)>>
<<global yml_ml(x86)>>
<<global ydivl(x86)>>
<<global ydivb(x86)>>
<<global yimul(x86)>>
<<global ybyte(x86)>>
<<global yin(x86)>>
<<global yint(x86)>>
<<global ypushl(x86)>>
<<global ypopl(x86)>>
<<global yscond(x86)>>
<<global yjcond(x86)>>
<<global yloop(x86)>>
<<global ycall(x86)>>
<<global yjmp(x86)>>

<<global yfmvd(x86)>>
<<global yfmvdp(x86)>>
<<global yfmvf(x86)>>
<<global yfmvx(x86)>>
<<global yfmvp(x86)>>
<<global yfadd(x86)>>
<<global yfaddp(x86)>>
<<global yfxch(x86)>>
<<global ycompp(x86)>>
<<global ystsw(x86)>>
<<global ystcw(x86)>>
<<global ysvrs(x86)>>

<<global optab(x86)>>
@

\subsection*{[[linkers/8l/utils.c]]}

<<linkers/8l/utils.c>>=
#include "l.h"

<<function log>>

<<function errorexit>>

<<function gethunk>>

<<function lookup>>

<<constructor prg>>

<<function copyp>>

@

\subsection*{[[linkers/8l/list.c]]}

%-------------------------------------------------------------

<<linkers/8l/list.c>>=
#include	"l.h"

int	Aconv(Fmt*);
int	Dconv(Fmt*);
int	Pconv(Fmt*);
int	Rconv(Fmt*);
int	Sconv(Fmt*);

<<function listinit(x86)>>

<<global bigP(x86)>>

<<function Pconv(x86)>>

<<function Aconv(x86)>>

<<function Dconv(x86)>>

<<global regstr(x86)>>

<<function Rconv(x86)>>

<<function Sconv(x86)>>

<<function diag>>
@


\subsection*{[[linkers/8l/compat.c]]}


%-------------------------------------------------------------

<<linkers/8l/compat.c>>=
#include	"l.h"

<<function malloc>>

<<function free>>

<<function setmalloctag>>

<<function fileexists>>
@


\subsection*{[[linkers/8l/pass.c]]}

%-------------------------------------------------------------

<<linkers/8l/pass.c>>=
#include	"l.h"

void	xfol(Prog*);
int	relinv(int);
void	mkfwd(void);
Prog*	brloop(Prog*);

<<function dodata(x86)>>

<<function brchain(x86)>>

<<function follow>>

<<function xfol(x86)>>

<<function relinv(x86)>>

<<function doinit(x86)>>

<<function patch(x86)>>

<<constant LOG>>
<<function mkfwd>>

<<function brloop(x86)>>

<<function dostkoff(x86)>>

<<function atolwhex>>

<<function undef>>

<<function import(x86)>>

<<function ckoff>>

<<function newdata(x86)>>

<<function export(x86)>>
@


\subsection*{[[linkers/8l/asm.c]]}

%-------------------------------------------------------------

<<linkers/8l/asm.c>>=
#include	"l.h"

<<constant Dbufslop>>

<<global spsize(x86)>>

void	datblk(long, long);

<<function entryvalue(x86)>>

<<function wputl(x86)>>

<<function wput(x86)>>

<<function lput(x86)>>

<<function lputl(x86)>>

<<function llput>>

<<function llputl>>

<<function strnput(x86)>>

<<function asmb(x86)>>

<<function cflush>>

<<function datblk(x86)>>

<<function rnd>>
@


\subsection*{[[linkers/8l/span.c]]}


<<function oclass(x86)>>=
int
oclass(Adr *a)
{
    long v;

    if(a->type >= D_INDIR || a->index != D_NONE) {
        if(a->index != D_NONE && a->scale == 0) {
            if(a->type == D_ADDR) {
                switch(a->index) {
                case D_EXTERN:
                case D_STATIC:
                    return Yi32;
                case D_AUTO:
                case D_PARAM:
                    return Yiauto;
                }
                return Yxxx;
            }
            return Ycol;
        }
        return Ym;
    }
    switch(a->type)
    {
    case D_AL:
        return Yal;

    case D_AX:
        return Yax;

    case D_CL:
        return Ycl;

    case D_DL:
    case D_BL:
    case D_AH:
    case D_CH:
    case D_DH:
    case D_BH:
        return Yrb;

    case D_CX:
        return Ycx;

    case D_DX:
    case D_BX:
        return Yrx;

    case D_SP:
    case D_BP:
    case D_SI:
    case D_DI:
        return Yrl;

    case D_F0+0:
        return	Yf0;

    case D_F0+1:
    case D_F0+2:
    case D_F0+3:
    case D_F0+4:
    case D_F0+5:
    case D_F0+6:
    case D_F0+7:
        return	Yrf;

    case D_NONE:
        return Ynone;

    case D_CS:	return	Ycs;
    case D_SS:	return	Yss;
    case D_DS:	return	Yds;
    case D_ES:	return	Yes;
    case D_FS:	return	Yfs;
    case D_GS:	return	Ygs;

    case D_GDTR:	return	Ygdtr;
    case D_IDTR:	return	Yidtr;
    case D_LDTR:	return	Yldtr;
    case D_MSW:	return	Ymsw;
    case D_TASK:	return	Ytask;

    case D_CR+0:	return	Ycr0;
    case D_CR+1:	return	Ycr1;
    case D_CR+2:	return	Ycr2;
    case D_CR+3:	return	Ycr3;
    case D_CR+4:	return	Ycr4;
    case D_CR+5:	return	Ycr5;
    case D_CR+6:	return	Ycr6;
    case D_CR+7:	return	Ycr7;

    case D_DR+0:	return	Ydr0;
    case D_DR+1:	return	Ydr1;
    case D_DR+2:	return	Ydr2;
    case D_DR+3:	return	Ydr3;
    case D_DR+4:	return	Ydr4;
    case D_DR+5:	return	Ydr5;
    case D_DR+6:	return	Ydr6;
    case D_DR+7:	return	Ydr7;

    case D_TR+0:	return	Ytr0;
    case D_TR+1:	return	Ytr1;
    case D_TR+2:	return	Ytr2;
    case D_TR+3:	return	Ytr3;
    case D_TR+4:	return	Ytr4;
    case D_TR+5:	return	Ytr5;
    case D_TR+6:	return	Ytr6;
    case D_TR+7:	return	Ytr7;

    case D_EXTERN:
    case D_STATIC:
    case D_AUTO:
    case D_PARAM:
        return Ym;

    case D_CONST:
    case D_ADDR:
        if(a->sym == S) {
            v = a->offset;
            if(v == 0)
                return Yi0;
            if(v == 1)
                return Yi1;
            if(v >= -128 && v <= 127)
                return Yi8;
        }
        return Yi32;

    case D_BRANCH:
        return Ybr;
    }
    return Yxxx;
}
@

<<function asmidx(x86)>>=
void
asmidx(Adr *a, int base)
{
    int i;

    switch(a->index) {
    default:
        goto bad;

    case D_NONE:
        i = 4 << 3;
        goto bas;

    case D_AX:
    case D_CX:
    case D_DX:
    case D_BX:
    case D_BP:
    case D_SI:
    case D_DI:
        i = reg[a->index] << 3;
        break;
    }
    switch(a->scale) {
    default:
        goto bad;
    case 1:
        break;
    case 2:
        i |= (1<<6);
        break;
    case 4:
        i |= (2<<6);
        break;
    case 8:
        i |= (3<<6);
        break;
    }
bas:
    switch(base) {
    default:
        goto bad;
    case D_NONE:	/* must be mod=00 */
        i |= 5;
        break;
    case D_AX:
    case D_CX:
    case D_DX:
    case D_BX:
    case D_SP:
    case D_BP:
    case D_SI:
    case D_DI:
        i |= reg[base];
        break;
    }
    *andptr++ = i;
    return;
bad:
    diag("asmidx: bad address %D", a);
    *andptr++ = 0;
    return;
}
@
%>> >> >> >> >>

<<function put4(x86)>>=
static void
put4(long v)
{
    if(dlm && curp != P && reloca != nil){
        dynreloc(reloca->sym, curp->pc + andptr - &and[0], 1);
        reloca = nil;
    }
    andptr[0] = v;
    andptr[1] = v>>8;
    andptr[2] = v>>16;
    andptr[3] = v>>24;
    andptr += 4;
}
@

<<function vaddr(x86)>>=
long
vaddr(Adr *a)
{
    int t;
    long v;
    Sym *s;

    t = a->type;
    v = a->offset;
    if(t == D_ADDR)
        t = a->index;
    switch(t) {
    case D_STATIC:
    case D_EXTERN:
        s = a->sym;
        if(s != nil) {
            if(dlm && curp != P)
                reloca = a;
            switch(s->type) {
            case SUNDEF:
                ckoff(s, v);
            case STEXT:
            case SCONST:
                v += s->value;
                break;
            default:
                v += INITDAT + s->value;
            }
        }
    }
    return v;
}
@

<<function asmand(x86)>>=
void
asmand(Adr *a, int r)
{
    long v;
    int t;
    Adr aa;

    v = a->offset;
    t = a->type;
    if(a->index != D_NONE) {
        if(t >= D_INDIR) {
            t -= D_INDIR;
            if(t == D_NONE) {
                *andptr++ = (0 << 6) | (4 << 0) | (r << 3);
                asmidx(a, t);
                put4(v);
                return;
            }
            if(v == 0 && t != D_BP) {
                *andptr++ = (0 << 6) | (4 << 0) | (r << 3);
                asmidx(a, t);
                return;
            }
            if(v >= -128 && v < 128) {
                *andptr++ = (1 << 6) | (4 << 0) | (r << 3);
                asmidx(a, t);
                *andptr++ = v;
                return;
            }
            *andptr++ = (2 << 6) | (4 << 0) | (r << 3);
            asmidx(a, t);
            put4(v);
            return;
        }
        switch(t) {
        default:
            goto bad;
        case D_STATIC:
        case D_EXTERN:
            aa.type = D_NONE+D_INDIR;
            break;
        case D_AUTO:
        case D_PARAM:
            aa.type = D_SP+D_INDIR;
            break;
        }
        aa.offset = vaddr(a);
        aa.index = a->index;
        aa.scale = a->scale;
        asmand(&aa, r);
        return;
    }
    if(t >= D_AL && t <= D_F0+7) {
        if(v)
            goto bad;
        *andptr++ = (3 << 6) | (reg[t] << 0) | (r << 3);
        return;
    }
    if(t >= D_INDIR) {
        t -= D_INDIR;
        if(t == D_NONE || D_CS <= t && t <= D_GS) {
            *andptr++ = (0 << 6) | (5 << 0) | (r << 3);
            put4(v);
            return;
        }
        if(t == D_SP) {
            if(v == 0) {
                *andptr++ = (0 << 6) | (4 << 0) | (r << 3);
                asmidx(a, D_SP);
                return;
            }
            if(v >= -128 && v < 128) {
                *andptr++ = (1 << 6) | (4 << 0) | (r << 3);
                asmidx(a, D_SP);
                *andptr++ = v;
                return;
            }
            *andptr++ = (2 << 6) | (4 << 0) | (r << 3);
            asmidx(a, D_SP);
            put4(v);
            return;
        }
        if(t >= D_AX && t <= D_DI) {
            if(v == 0 && t != D_BP) {
                *andptr++ = (0 << 6) | (reg[t] << 0) | (r << 3);
                return;
            }
            if(v >= -128 && v < 128) {
                andptr[0] = (1 << 6) | (reg[t] << 0) | (r << 3);
                andptr[1] = v;
                andptr += 2;
                return;
            }
            *andptr++ = (2 << 6) | (reg[t] << 0) | (r << 3);
            put4(v);
            return;
        }
        goto bad;
    }
    switch(a->type) {
    default:
        goto bad;
    case D_STATIC:
    case D_EXTERN:
        aa.type = D_NONE+D_INDIR;
        break;
    case D_AUTO:
    case D_PARAM:
        aa.type = D_SP+D_INDIR;
        break;
    }
    aa.index = D_NONE;
    aa.scale = 1;
    aa.offset = vaddr(a);
    asmand(&aa, r);
    return;
bad:
    diag("asmand: bad address %D", a);
    return;
}
@

<<constant E(x86)>>=
#define	E	0xff
@

<<global ymovtab(x86)>>=
uchar	ymovtab[] =
{
/* push */
    APUSHL,	Ycs,	Ynone,	0,	0x0e,E,0,0,
    APUSHL,	Yss,	Ynone,	0,	0x16,E,0,0,
    APUSHL,	Yds,	Ynone,	0,	0x1e,E,0,0,
    APUSHL,	Yes,	Ynone,	0,	0x06,E,0,0,
    APUSHL,	Yfs,	Ynone,	0,	0x0f,0xa0,E,0,
    APUSHL,	Ygs,	Ynone,	0,	0x0f,0xa8,E,0,

    APUSHW,	Ycs,	Ynone,	0,	Pe,0x0e,E,0,
    APUSHW,	Yss,	Ynone,	0,	Pe,0x16,E,0,
    APUSHW,	Yds,	Ynone,	0,	Pe,0x1e,E,0,
    APUSHW,	Yes,	Ynone,	0,	Pe,0x06,E,0,
    APUSHW,	Yfs,	Ynone,	0,	Pe,0x0f,0xa0,E,
    APUSHW,	Ygs,	Ynone,	0,	Pe,0x0f,0xa8,E,

/* pop */
    APOPL,	Ynone,	Yds,	0,	0x1f,E,0,0,
    APOPL,	Ynone,	Yes,	0,	0x07,E,0,0,
    APOPL,	Ynone,	Yss,	0,	0x17,E,0,0,
    APOPL,	Ynone,	Yfs,	0,	0x0f,0xa1,E,0,
    APOPL,	Ynone,	Ygs,	0,	0x0f,0xa9,E,0,

    APOPW,	Ynone,	Yds,	0,	Pe,0x1f,E,0,
    APOPW,	Ynone,	Yes,	0,	Pe,0x07,E,0,
    APOPW,	Ynone,	Yss,	0,	Pe,0x17,E,0,
    APOPW,	Ynone,	Yfs,	0,	Pe,0x0f,0xa1,E,
    APOPW,	Ynone,	Ygs,	0,	Pe,0x0f,0xa9,E,

/* mov seg */
    AMOVW,	Yes,	Yml,	1,	0x8c,0,0,0,
    AMOVW,	Ycs,	Yml,	1,	0x8c,1,0,0,
    AMOVW,	Yss,	Yml,	1,	0x8c,2,0,0,
    AMOVW,	Yds,	Yml,	1,	0x8c,3,0,0,
    AMOVW,	Yfs,	Yml,	1,	0x8c,4,0,0,
    AMOVW,	Ygs,	Yml,	1,	0x8c,5,0,0,

    AMOVW,	Yml,	Yes,	2,	0x8e,0,0,0,
    AMOVW,	Yml,	Ycs,	2,	0x8e,1,0,0,
    AMOVW,	Yml,	Yss,	2,	0x8e,2,0,0,
    AMOVW,	Yml,	Yds,	2,	0x8e,3,0,0,
    AMOVW,	Yml,	Yfs,	2,	0x8e,4,0,0,
    AMOVW,	Yml,	Ygs,	2,	0x8e,5,0,0,

/* mov cr */
    AMOVL,	Ycr0,	Yml,	3,	0x0f,0x20,0,0,
    AMOVL,	Ycr2,	Yml,	3,	0x0f,0x20,2,0,
    AMOVL,	Ycr3,	Yml,	3,	0x0f,0x20,3,0,
    AMOVL,	Ycr4,	Yml,	3,	0x0f,0x20,4,0,

    AMOVL,	Yml,	Ycr0,	4,	0x0f,0x22,0,0,
    AMOVL,	Yml,	Ycr2,	4,	0x0f,0x22,2,0,
    AMOVL,	Yml,	Ycr3,	4,	0x0f,0x22,3,0,
    AMOVL,	Yml,	Ycr4,	4,	0x0f,0x22,4,0,

/* mov dr */
    AMOVL,	Ydr0,	Yml,	3,	0x0f,0x21,0,0,
    AMOVL,	Ydr6,	Yml,	3,	0x0f,0x21,6,0,
    AMOVL,	Ydr7,	Yml,	3,	0x0f,0x21,7,0,

    AMOVL,	Yml,	Ydr0,	4,	0x0f,0x23,0,0,
    AMOVL,	Yml,	Ydr6,	4,	0x0f,0x23,6,0,
    AMOVL,	Yml,	Ydr7,	4,	0x0f,0x23,7,0,

/* mov tr */
    AMOVL,	Ytr6,	Yml,	3,	0x0f,0x24,6,0,
    AMOVL,	Ytr7,	Yml,	3,	0x0f,0x24,7,0,

    AMOVL,	Yml,	Ytr6,	4,	0x0f,0x26,6,E,
    AMOVL,	Yml,	Ytr7,	4,	0x0f,0x26,7,E,

/* lgdt, sgdt, lidt, sidt */
    AMOVL,	Ym,	Ygdtr,	4,	0x0f,0x01,2,0,
    AMOVL,	Ygdtr,	Ym,	3,	0x0f,0x01,0,0,
    AMOVL,	Ym,	Yidtr,	4,	0x0f,0x01,3,0,
    AMOVL,	Yidtr,	Ym,	3,	0x0f,0x01,1,0,

/* lldt, sldt */
    AMOVW,	Yml,	Yldtr,	4,	0x0f,0x00,2,0,
    AMOVW,	Yldtr,	Yml,	3,	0x0f,0x00,0,0,

/* lmsw, smsw */
    AMOVW,	Yml,	Ymsw,	4,	0x0f,0x01,6,0,
    AMOVW,	Ymsw,	Yml,	3,	0x0f,0x01,4,0,

/* ltr, str */
    AMOVW,	Yml,	Ytask,	4,	0x0f,0x00,3,0,
    AMOVW,	Ytask,	Yml,	3,	0x0f,0x00,1,0,

/* load full pointer */
    AMOVL,	Yml,	Ycol,	5,	0,0,0,0,
    AMOVW,	Yml,	Ycol,	5,	Pe,0,0,0,

/* double shift */
    ASHLL,	Ycol,	Yml,	6,	0xa4,0xa5,0,0,
    ASHRL,	Ycol,	Yml,	6,	0xac,0xad,0,0,

/* extra imul */
    AIMULW,	Yml,	Yrl,	7,	Pq,0xaf,0,0,
    AIMULL,	Yml,	Yrl,	7,	Pm,0xaf,0,0,
    0
};
@

<<function isax(x86)>>=
int
isax(Adr *a)
{

    switch(a->type) {
    case D_AX:
    case D_AL:
    case D_AH:
    case D_INDIR+D_AX:
        return 1;
    }
    if(a->index == D_AX)
        return 1;
    return 0;
}
@

<<function subreg(x86)>>=
void
subreg(Prog *p, int from, int to)
{

    if(debug['Q'])
        print("\n%P	s/%R/%R/\n", p, from, to);

    if(p->from.type == from)
        p->from.type = to;
    if(p->to.type == from)
        p->to.type = to;

    if(p->from.index == from)
        p->from.index = to;
    if(p->to.index == from)
        p->to.index = to;

    from += D_INDIR;
    if(p->from.type == from)
        p->from.type = to+D_INDIR;
    if(p->to.type == from)
        p->to.type = to+D_INDIR;

    if(debug['Q'])
        print("%P\n", p);
}
@

<<function doasm(x86)>>=
void
doasm(Prog *p)
{
    Optab *o;
    Prog *q, pp;
    uchar *t;
    int z, op, ft, tt;
    long v, pre;

    pre = prefixof(&p->from);
    if(pre)
        *andptr++ = pre;
    pre = prefixof(&p->to);
    if(pre)
        *andptr++ = pre;

    o = &optab[p->as];
    ft = oclass(&p->from) * Ymax;
    tt = oclass(&p->to) * Ymax;
    t = o->ytab;
    if(t == 0) {
        diag("asmins: noproto %P", p);
        return;
    }
    for(z=0; *t; z+=t[3],t+=4)
        if(ycover[ft+t[0]])
        if(ycover[tt+t[1]])
            goto found;
    goto domov;

found:
    switch(o->prefix) {
    case Pq:	/* 16 bit escape and opcode escape */
        *andptr++ = Pe;
        *andptr++ = Pm;
        break;

    case Pm:	/* opcode escape */
        *andptr++ = Pm;
        break;

    case Pe:	/* 16 bit escape */
        *andptr++ = Pe;
        break;

    case Pb:	/* botch */
        break;
    }
    v = vaddr(&p->from);
    op = o->op[z];
    switch(t[2]) {
    default:
        diag("asmins: unknown z %d %P", t[2], p);
        return;

    case Zpseudo:
        break;

    case Zlit:
        for(; op = o->op[z]; z++)
            *andptr++ = op;
        break;

    case Zm_r:
        *andptr++ = op;
        asmand(&p->from, reg[p->to.type]);
        break;

    case Zaut_r:
        *andptr++ = 0x8d;	/* leal */
        if(p->from.type != D_ADDR)
            diag("asmins: Zaut sb type ADDR");
        p->from.type = p->from.index;
        p->from.index = D_NONE;
        asmand(&p->from, reg[p->to.type]);
        p->from.index = p->from.type;
        p->from.type = D_ADDR;
        break;

    case Zm_o:
        *andptr++ = op;
        asmand(&p->from, o->op[z+1]);
        break;

    case Zr_m:
        *andptr++ = op;
        asmand(&p->to, reg[p->from.type]);
        break;

    case Zo_m:
        *andptr++ = op;
        asmand(&p->to, o->op[z+1]);
        break;

    case Zm_ibo:
        v = vaddr(&p->to);
        *andptr++ = op;
        asmand(&p->from, o->op[z+1]);
        *andptr++ = v;
        break;

    case Zibo_m:
        *andptr++ = op;
        asmand(&p->to, o->op[z+1]);
        *andptr++ = v;
        break;

    case Z_ib:
        v = vaddr(&p->to);
    case Zib_:
        *andptr++ = op;
        *andptr++ = v;
        break;

    case Zib_rp:
        *andptr++ = op + reg[p->to.type];
        *andptr++ = v;
        break;

    case Zil_rp:
        *andptr++ = op + reg[p->to.type];
        if(o->prefix == Pe) {
            *andptr++ = v;
            *andptr++ = v>>8;
        }
        else
            put4(v);
        break;

    case Zib_rr:
        *andptr++ = op;
        asmand(&p->to, reg[p->to.type]);
        *andptr++ = v;
        break;

    case Z_il:
        v = vaddr(&p->to);
    case Zil_:
        *andptr++ = op;
        if(o->prefix == Pe) {
            *andptr++ = v;
            *andptr++ = v>>8;
        }
        else
            put4(v);
        break;

    case Zm_ilo:
        v = vaddr(&p->to);
        *andptr++ = op;
        asmand(&p->from, o->op[z+1]);
        if(o->prefix == Pe) {
            *andptr++ = v;
            *andptr++ = v>>8;
        }
        else
            put4(v);
        break;

    case Zilo_m:
        *andptr++ = op;
        asmand(&p->to, o->op[z+1]);
        if(o->prefix == Pe) {
            *andptr++ = v;
            *andptr++ = v>>8;
        }
        else
            put4(v);
        break;

    case Zil_rr:
        *andptr++ = op;
        asmand(&p->to, reg[p->to.type]);
        if(o->prefix == Pe) {
            *andptr++ = v;
            *andptr++ = v>>8;
        }
        else
            put4(v);
        break;

    case Z_rp:
        *andptr++ = op + reg[p->to.type];
        break;

    case Zrp_:
        *andptr++ = op + reg[p->from.type];
        break;

    case Zclr:
        *andptr++ = op;
        asmand(&p->to, reg[p->to.type]);
        break;

    case Zbr:
        q = p->pcond;
        if(q) {
            v = q->pc - p->pc - 2;
            if(v >= -128 && v <= 127) {
                *andptr++ = op;
                *andptr++ = v;
            } else {
                v -= 6-2;
                *andptr++ = 0x0f;
                *andptr++ = o->op[z+1];
                *andptr++ = v;
                *andptr++ = v>>8;
                *andptr++ = v>>16;
                *andptr++ = v>>24;
            }
        }
        break;

    case Zcall:
        q = p->pcond;
        if(q) {
            v = q->pc - p->pc - 5;
            if(dlm && curp != P && p->to.sym->type == SUNDEF){
                /* v = 0 - p->pc - 5; */
                v = 0;
                ckoff(p->to.sym, v);
                v += p->to.sym->value;
                dynreloc(p->to.sym, p->pc+1, 0);
            }
            *andptr++ = op;
            *andptr++ = v;
            *andptr++ = v>>8;
            *andptr++ = v>>16;
            *andptr++ = v>>24;
        }
        break;

    case Zjmp:
        q = p->pcond;
        if(q) {
            v = q->pc - p->pc - 2;
            if(v >= -128 && v <= 127) {
                *andptr++ = op;
                *andptr++ = v;
            } else {
                v -= 5-2;
                *andptr++ = o->op[z+1];
                *andptr++ = v;
                *andptr++ = v>>8;
                *andptr++ = v>>16;
                *andptr++ = v>>24;
            }
        }
        break;

    case Zloop:
        q = p->pcond;
        if(q) {
            v = q->pc - p->pc - 2;
            if(v < -128 || v > 127)
                diag("loop too far: %P", p);
            *andptr++ = op;
            *andptr++ = v;
        }
        break;

    case Zbyte:
        *andptr++ = v;
        if(op > 1) {
            *andptr++ = v>>8;
            if(op > 2) {
                *andptr++ = v>>16;
                *andptr++ = v>>24;
            }
        }
        break;

    case Zmov:
        goto domov;
    }
    return;

domov:
    for(t=ymovtab; *t; t+=8)
        if(p->as == t[0])
        if(ycover[ft+t[1]])
        if(ycover[tt+t[2]])
            goto mfound;
bad:
    /*
     * here, the assembly has failed.
     * if its a byte instruction that has
     * unaddressable registers, try to
     * exchange registers and reissue the
     * instruction with the operands renamed.
     */
    pp = *p;
    z = p->from.type;
    if(z >= D_BP && z <= D_DI) {
        if(isax(&p->to)) {
            *andptr++ = 0x87;			/* xchg lhs,bx */
            asmand(&p->from, reg[D_BX]);
            subreg(&pp, z, D_BX);
            doasm(&pp);
            *andptr++ = 0x87;			/* xchg lhs,bx */
            asmand(&p->from, reg[D_BX]);
        } else {
            *andptr++ = 0x90 + reg[z];		/* xchg lsh,ax */
            subreg(&pp, z, D_AX);
            doasm(&pp);
            *andptr++ = 0x90 + reg[z];		/* xchg lsh,ax */
        }
        return;
    }
    z = p->to.type;
    if(z >= D_BP && z <= D_DI) {
        if(isax(&p->from)) {
            *andptr++ = 0x87;			/* xchg rhs,bx */
            asmand(&p->to, reg[D_BX]);
            subreg(&pp, z, D_BX);
            doasm(&pp);
            *andptr++ = 0x87;			/* xchg rhs,bx */
            asmand(&p->to, reg[D_BX]);
        } else {
            *andptr++ = 0x90 + reg[z];		/* xchg rsh,ax */
            subreg(&pp, z, D_AX);
            doasm(&pp);
            *andptr++ = 0x90 + reg[z];		/* xchg rsh,ax */
        }
        return;
    }
    diag("doasm: notfound t2=%ux from=%ux to=%ux %P", t[2], p->from.type, p->to.type, p);
    return;

mfound:
    switch(t[3]) {
    default:
        diag("asmins: unknown mov %d %P", t[3], p);
        break;

    case 0:	/* lit */
        for(z=4; t[z]!=E; z++)
            *andptr++ = t[z];
        break;

    case 1:	/* r,m */
        *andptr++ = t[4];
        asmand(&p->to, t[5]);
        break;

    case 2:	/* m,r */
        *andptr++ = t[4];
        asmand(&p->from, t[5]);
        break;

    case 3:	/* r,m - 2op */
        *andptr++ = t[4];
        *andptr++ = t[5];
        asmand(&p->to, t[6]);
        break;

    case 4:	/* m,r - 2op */
        *andptr++ = t[4];
        *andptr++ = t[5];
        asmand(&p->from, t[6]);
        break;

    case 5:	/* load full pointer, trash heap */
        if(t[4])
            *andptr++ = t[4];
        switch(p->to.index) {
        default:
            goto bad;
        case D_DS:
            *andptr++ = 0xc5;
            break;
        case D_SS:
            *andptr++ = 0x0f;
            *andptr++ = 0xb2;
            break;
        case D_ES:
            *andptr++ = 0xc4;
            break;
        case D_FS:
            *andptr++ = 0x0f;
            *andptr++ = 0xb4;
            break;
        case D_GS:
            *andptr++ = 0x0f;
            *andptr++ = 0xb5;
            break;
        }
        asmand(&p->from, reg[p->to.type]);
        break;

    case 6:	/* double shift */
        z = p->from.type;
        switch(z) {
        default:
            goto bad;
        case D_CONST:
            *andptr++ = 0x0f;
            *andptr++ = t[4];
            asmand(&p->to, reg[p->from.index]);
            *andptr++ = p->from.offset;
            break;
        case D_CL:
        case D_CX:
            *andptr++ = 0x0f;
            *andptr++ = t[5];
            asmand(&p->to, reg[p->from.index]);
            break;
        }
        break;

    case 7: /* imul rm,r */
        *andptr++ = t[4];
        *andptr++ = t[5];
        asmand(&p->from, reg[p->to.type]);
        break;
    }
}
@

<<function prefixof(x86)>>=
int
prefixof(Adr *a)
{
    switch(a->type) {
    case D_INDIR+D_CS:
        return 0x2e;
    case D_INDIR+D_DS:
        return 0x3e;
    case D_INDIR+D_ES:
        return 0x26;
    case D_INDIR+D_FS:
        return 0x64;
    case D_INDIR+D_GS:
        return 0x65;
    }
    return 0;
}
@



<<function asmins(x86)>>=
void
asmins(Prog *p)
{

    andptr = and;
    doasm(p);
}
@

<<enum _anon_ (linkers/8l/span.c)>>=
enum{
    ABSD = 0,
    ABSU = 1,
    RELD = 2,
    RELU = 3,
};
@


<<function sput(x86)>>=
static int
sput(char *s)
{
    char *p;

    p = s;
    while(*s)
        cput(*s++);
    cput(0);
    return s-p+1;
}
@



%-------------------------------------------------------------

<<linkers/8l/span.c>>=
#include	"l.h"

<<function span(x86)>>

<<function xdefine(x86)>>

<<function putsymb>>

<<function asmsym(x86)>>

<<function asmlc>>

<<function prefixof(x86)>>

<<function oclass(x86)>>

<<function asmidx(x86)>>

<<function put4(x86)>>

<<function vaddr(x86)>>

<<function asmand(x86)>>

<<constant E(x86)>>
<<global ymovtab(x86)>>

<<function isax(x86)>>

<<function subreg(x86)>>

<<function doasm(x86)>>

<<function asmins(x86)>>

<<enum _anon_ (linkers/8l/span.c)>>

<<global modemap>>

typedef struct Reloc Reloc;

<<struct Reloc>>

<<global rels>>

<<function grow>>

<<function dynreloc(x86)>>

<<function sput(x86)>>

<<function asmdyn>>
@


\subsection*{[[linkers/8l/elf.c]]}

<<enum _anon_ (linkers/8l/elf.c)>>=
enum {
    /* offsets into string table */
    Stitext		= 1,
    Stidata		= 7,
    Stistrtab	= 13,
};
@

<<function elfident>>=
void
elfident(int bo, int class)
{
    strnput("\177ELF", 4);		/* e_ident */
    cput(class);
    cput(bo);			/* byte order */
    cput(1);			/* version = CURRENT */
    if(debug['k']){			/* boot/embedded/standalone */
        cput(255);
        cput(0);
    }
    else{
        cput(0);		/* osabi = SYSV */
        cput(0);		/* abiversion = 3 */
    }
    strnput("", 7);
}
@

<<function elfstrtab>>=
void
elfstrtab(void)
{
    /* string table */
    cput(0);
    strnput(".text", 5);		/* +1 */
    cput(0);
    strnput(".data", 5);		/* +7 */
    cput(0);
    strnput(".strtab", 7);		/* +13 */
    cput(0);
    cput(0);
}
@

<<function elf32phdr>>=
void
elf32phdr(void (*putl)(long), ulong type, ulong off, ulong vaddr, ulong paddr,
    ulong filesz, ulong memsz, ulong prots, ulong align)
{
    putl(type);
    putl(off);
    putl(vaddr);
    putl(paddr);
    putl(filesz);
    putl(memsz);
    putl(prots);
    putl(align);
}
@

<<function elf32shdr>>=
void
elf32shdr(void (*putl)(long), ulong name, ulong type, ulong flags, ulong vaddr,
    ulong off, ulong sectsz, ulong link, ulong addnl, ulong align,
    ulong entsz)
{
    putl(name);
    putl(type);
    putl(flags);
    putl(vaddr);
    putl(off);
    putl(sectsz);
    putl(link);
    putl(addnl);
    putl(align);
    putl(entsz);
}
@

<<function elf32sectab>>=
static void
elf32sectab(void (*putl)(long))
{
    seek(cout, HEADR+textsize+datsize+symsize, 0);
    elf32shdr(putl, Stitext, Progbits, Salloc|Sexec, INITTEXT,
        HEADR, textsize, 0, 0, 0x10000, 0);
    elf32shdr(putl, Stidata, Progbits, Salloc|SwriteElf, INITDAT,
        HEADR+textsize, datsize, 0, 0, 0x10000, 0);
    elf32shdr(putl, Stistrtab, Strtab, 1 << 5, 0,
        HEADR+textsize+datsize+symsize+3*Shdr32sz, 14, 0, 0, 1, 0);
    elfstrtab();
}
@

<<function elf32>>=
/* if addpsects > 0, putpsects must emit exactly that many psects. */
void
elf32(int mach, int bo, int addpsects, void (*putpsects)(Putl))
{
    ulong phydata;
    void (*putw)(long), (*putl)(long);

    if(bo == ELFDATA2MSB){
        putw = wput;
        putl = lput;
    }else if(bo == ELFDATA2LSB){
        putw = wputl;
        putl = lputl;
    }else{
        print("elf32 byte order is mixed-endian\n");
        errorexit();
        return;
    }

    elfident(bo, ELFCLASS32);
    putw(EXEC);
    putw(mach);
    putl(1L);			/* version = CURRENT */
    putl(entryvalue());		/* entry vaddr */
    putl(Ehdr32sz);			/* offset to first phdr */
    if(debug['S'])
        putl(HEADR+textsize+datsize+symsize); /* offset to first shdr */
    else
        putl(0);
    putl(0L);			/* flags */
    putw(Ehdr32sz);
    putw(Phdr32sz);
    putw(3 + addpsects);		/* # of Phdrs */
    putw(Shdr32sz);
    if(debug['S']){
        putw(3);		/* # of Shdrs */
        putw(2);		/* Shdr table index */
    }else{
        putw(0);
        putw(0);
    }

    /*
     * could include ELF headers in text -- 8l doesn't,
     * but in theory it aids demand loading.
     */
    elf32phdr(putl, PT_LOAD, HEADR, INITTEXT, INITTEXTP,
        textsize, textsize, R|X, INITRND);	/* text */
    /*
     * we need INITDATP, but it has to be computed.
     * assume distance between INITTEXT & INITTEXTP is also
     * correct for INITDAT and INITDATP.
     */
    phydata = INITDAT - (INITTEXT - INITTEXTP);
    elf32phdr(putl, PT_LOAD, HEADR+textsize, INITDAT, phydata,
        datsize, datsize+bsssize, R|W|X, INITRND); /* data */
    elf32phdr(putl, NOPTYPE, HEADR+textsize+datsize, 0, 0,
        symsize, lcsize, R, 4);			/* symbol table */
    if (addpsects > 0)
        putpsects(putl);
    cflush();

    if(debug['S'])
        elf32sectab(putl);
}
@

%<<function elf64phdr>>=
%/*
% * elf64
% */
%void
%elf64phdr(void (*putl)(long), void (*putll)(vlong), ulong type, uvlong off,
%    uvlong vaddr, uvlong paddr, uvlong filesz, uvlong memsz, ulong prots,
%    uvlong align)
%{
%    putl(type);		
%    putl(prots);		
%    putll(off);		
%    putll(vaddr);	
%    putll(paddr);	
%    putll(filesz);	
%    putll(memsz);	
%    putll(align);		
%}
%@
%
%<<function elf64shdr>>=
%void
%elf64shdr(void (*putl)(long), void (*putll)(vlong), ulong name, ulong type,
%    uvlong flags, uvlong vaddr, uvlong off, uvlong sectsz, ulong link,
%    ulong addnl, uvlong align, uvlong entsz)
%{
%    putl(name);
%    putl(type);
%    putll(flags);
%    putll(vaddr);
%    putll(off);
%    putll(sectsz);
%    putl(link);
%    putl(addnl);
%    putll(align);
%    putll(entsz);
%}
%@
%
%<<function elf64sectab>>=
%static void
%elf64sectab(void (*putl)(long), void (*putll)(vlong))
%{
%    seek(cout, HEADR+textsize+datsize+symsize, 0);
%    elf64shdr(putl, putll, Stitext, Progbits, Salloc|Sexec, INITTEXT,
%        HEADR, textsize, 0, 0, 0x10000, 0);
%    elf64shdr(putl, putll, Stidata, Progbits, Salloc|SwriteElf, INITDAT,
%        HEADR+textsize, datsize, 0, 0, 0x10000, 0);
%    elf64shdr(putl, putll, Stistrtab, Strtab, 1 << 5, 0,
%        HEADR+textsize+datsize+symsize+3*Shdr64sz, 14, 0, 0, 1, 0);
%    elfstrtab();
%}
%@
%
%% >>
%
%<<function elf64>>=
%/* if addpsects > 0, putpsects must emit exactly that many psects. */
%//@Scheck: not dead, used by vl/
%void elf64(int mach, int bo, int addpsects, void (*putpsects)(Putl))
%{
%    uvlong phydata;
%    void (*putw)(long), (*putl)(long);
%    void (*putll)(vlong);
%
%    if(bo == ELFDATA2MSB){
%        putw = wput;
%        putl = lput;
%        putll = llput;
%    }else if(bo == ELFDATA2LSB){
%        putw = wputl;
%        putl = lputl;
%        putll = llputl;
%    }else{
%        print("elf64 byte order is mixed-endian\n");
%        errorexit();
%        return;
%    }
%
%    elfident(bo, ELFCLASS64);
%    putw(EXEC);
%    putw(mach);
%    putl(1L);			/* version = CURRENT */
%    putll(entryvalue());		/* entry vaddr */
%    putll(Ehdr64sz);		/* offset to first phdr */
%    if(debug['S'])
%        putll(HEADR+textsize+datsize+symsize); /* offset to 1st shdr */
%    else
%        putll(0);
%    putl(0L);			/* flags */
%    putw(Ehdr64sz);
%    putw(Phdr64sz);
%    putw(3 + addpsects);		/* # of Phdrs */
%    putw(Shdr64sz);
%    if(debug['S']){
%        putw(3);		/* # of Shdrs */
%        putw(2);		/* Shdr table index */
%    }else{
%        putw(0);
%        putw(0);
%    }
%
%    elf64phdr(putl, putll, PT_LOAD, HEADR, INITTEXT, INITTEXTP,
%        textsize, textsize, R|X, INITRND);	/* text */
%    /*
%     * see 32-bit ELF case for physical data address computation.
%     */
%    phydata = INITDAT - (INITTEXT - INITTEXTP);
%    elf64phdr(putl, putll, PT_LOAD, HEADR+textsize, INITDAT, phydata,
%        datsize, datsize+bsssize, R|W, INITRND); /* data */
%    elf64phdr(putl, putll, NOPTYPE, HEADR+textsize+datsize, 0, 0,
%        symsize, lcsize, R, 4);			/* symbol table */
%    if (addpsects > 0)
%        putpsects(putl);
%    cflush();
%
%    if(debug['S'])
%        elf64sectab(putl, putll);
%}
%@


%-------------------------------------------------------------

<<linkers/8l/elf.c>>=
/*
 * emit 32- or 64-bit elf headers for any architecture.
 * this is a component of ?l.
 */
#include "l.h"

long	entryvalue(void);

<<enum _anon_ (linkers/8l/elf.c)>>

<<function elfident>>

<<function elfstrtab>>

<<function elf32phdr>>

<<function elf32shdr>>

<<function elf32sectab>>

<<function elf32>>
@


\subsection*{[[linkers/8l/obj.c]]}




%-------------------------------------------------------------

<<linkers/8l/obj.c>>=
#include	"l.h"
#include	<ar.h>

#ifndef	DEFAULT
<<constant DEFAULT>>
#endif

<<global curauto>>

<<global curhist>>
<<global etextp>>

<<global histfrog>>
<<global histfrogp>>
<<global histgen>>

<<global library>>
<<global libraryobj>>
<<global libraryp>>

<<global xrefresolv>>

<<global version>>
<<global literal(x86)>>
<<global doexp>>

void	addlibpath(char*);
char*	findlib(char*);
void	loadlib(void);
void	objfile(char*);

int	zaddr(uchar*, Adr*, Sym*[]);
long	vaddr(Adr*);

void	addhist(long, int);
void	histtoauto(void);
void	ldobj(int, long, char*);

void	doprof1(void);
void	doprof2(void);
void	nuxiinit(void);

int	find1(long, int);
//int	find2(long, int);

double	ieeedtod(Ieee*);

void	zerosig(char*);
void	readundefs(char*, int);
Prog*	brchain(Prog*);



<<global noname linker>>
<<global symname linker>>
<<global thechar>>
<<global thestring>>

<<global libdir>>
<<global nlibdir>>
<<global maxlibdir>>

<<function usage, linker>>

<<function isobjfile>>

<<function main (linkers/8l/obj.c)>>

<<function addlibpath>>

<<function findlib>>

<<function loadlib>>

<<function objfile>>

<<function zaddr(x86)>>

<<function addlib>>

<<function addhist>>

<<function histtoauto>>

<<function collapsefrog>>

<<function nopout>>

<<function readsome>>

<<function ldobj(x86)>>

<<function appendp(x86)>>

<<function doprof1(x86)>>

<<function doprof2(x86)>>

<<function nuxiinit(x86)>>

<<function find1>>

<<function ieeedtof>>

<<function ieeedtod>>

<<function undefsym>>

<<function zerosig>>

<<function readundefs>>
@


\section{[[linkers/libmach/]]}
\subsection*{[[linkers/libmach/8.c]]}

<<function REGOFF(x86)>>=
#define	REGOFF(x)	(ulong)(&((struct Ureg *) 0)->x)
@

<<constant PC(x86)>>=
#define PC		REGOFF(pc)
@

<<constant SP(x86)>>=
#define SP		REGOFF(sp)
@

<<constant AX(x86)>>=
#define	AX		REGOFF(ax)
@

<<constant REGSIZE(x86)>>=
#define	REGSIZE		sizeof(struct Ureg)
@

<<function FP_CTL(x86)>>=
#define FP_CTL(x)	(REGSIZE+4*(x))
@

<<function FP_REG(x86)>>=
#define FP_REG(x)	(FP_CTL(7)+10*(x))
@

<<constant FPREGSIZE(x86)>>=
#define	FPREGSIZE	(7*4+8*10)
@

<<global i386reglist>>=
Reglist i386reglist[] = {
    {"DI",		REGOFF(di),	RINT, 'X'},
    {"SI",		REGOFF(si),	RINT, 'X'},
    {"BP",		REGOFF(bp),	RINT, 'X'},
    {"BX",		REGOFF(bx),	RINT, 'X'},
    {"DX",		REGOFF(dx),	RINT, 'X'},
    {"CX",		REGOFF(cx),	RINT, 'X'},
    {"AX",		REGOFF(ax),	RINT, 'X'},
    {"GS",		REGOFF(gs),	RINT, 'X'},
    {"FS",		REGOFF(fs),	RINT, 'X'},
    {"ES",		REGOFF(es),	RINT, 'X'},
    {"DS",		REGOFF(ds),	RINT, 'X'},
    {"TRAP",	REGOFF(trap), 	RINT, 'X'},
    {"ECODE",	REGOFF(ecode),	RINT, 'X'},
    {"PC",		PC,		RINT, 'X'},
    {"CS",		REGOFF(cs),	RINT, 'X'},
    {"EFLAGS",	REGOFF(flags),	RINT, 'X'},
    {"SP",		SP,		RINT, 'X'},
    {"SS",		REGOFF(ss),	RINT, 'X'},

    {"E0",		FP_CTL(0),	RFLT, 'X'},
    {"E1",		FP_CTL(1),	RFLT, 'X'},
    {"E2",		FP_CTL(2),	RFLT, 'X'},
    {"E3",		FP_CTL(3),	RFLT, 'X'},
    {"E4",		FP_CTL(4),	RFLT, 'X'},
    {"E5",		FP_CTL(5),	RFLT, 'X'},
    {"E6",		FP_CTL(6),	RFLT, 'X'},
    {"F0",		FP_REG(0),	RFLT, '3'},
    {"F1",		FP_REG(1),	RFLT, '3'},
    {"F2",		FP_REG(2),	RFLT, '3'},
    {"F3",		FP_REG(3),	RFLT, '3'},
    {"F4",		FP_REG(4),	RFLT, '3'},
    {"F5",		FP_REG(5),	RFLT, '3'},
    {"F6",		FP_REG(6),	RFLT, '3'},
    {"F7",		FP_REG(7),	RFLT, '3'},
    {  0 }
};
@

<<global mi386>>=
Mach mi386 =
{
    "386",
    MI386,		/* machine type */
    i386reglist,	/* register list */
    REGSIZE,	/* size of registers in bytes */
    FPREGSIZE,	/* size of fp registers in bytes */
    "PC",		/* name of PC */
    "SP",		/* name of SP */
    0,		/* link register */
    "setSB",	/* static base register name (bogus anyways) */
    0,		/* static base register value */
    0x1000,		/* page size */
    0xF0100000ULL,	/* kernel base */
    0xF0000000ULL,	/* kernel text mask */
    0x7FFFFFFFULL,	/* user stack top */
    1,		/* quantization of pc */
    4,		/* szaddr */
    4,		/* szreg */
    4,		/* szfloat */
    8,		/* szdouble */
};
@


%-------------------------------------------------------------

<<linkers/libmach/8.c>>=
/*
 * 386 definition
 */
#include <u.h>
#include <libc.h>
#include <bio.h>
#include "/386/include/ureg.h"
#include <mach.h>

<<function REGOFF(x86)>>

<<constant PC(x86)>>
<<constant SP(x86)>>
<<constant AX(x86)>>

<<constant REGSIZE(x86)>>
<<function FP_CTL(x86)>>
<<function FP_REG(x86)>>
<<constant FPREGSIZE(x86)>>

<<global i386reglist>>

<<global mi386>>
@


\subsection*{[[linkers/libmach/8obj.c]]}

<<struct Addr(x86)>>=
struct Addr
{
    char	sym;
    char	flags;
};
@

<<function _is8(x86)>>=
int
_is8(char *t)
{
    byte *s = (byte*)t;

    return  s[0] == (ANAME&0xff)			/* aslo = ANAME */
        && s[1] == ((ANAME>>8)&0xff)
        && s[2] == D_FILE			/* type */
        && s[3] == 1				/* sym */
        && s[4] == '<';				/* name of file */
}
@

<<function _read8(x86)>>=
int
_read8(Biobuf *bp, Prog* p)
{
    int as, n, c;
    Addr a;

    as = Bgetc(bp);		/* as(low) */
    if(as < 0)
        return 0;
    c = Bgetc(bp);		/* as(high) */
    if(c < 0)
        return 0;
    as |= ((c & 0xff) << 8);
    p->kind = aNone;
    p->sig = 0;
    if(as == ANAME || as == ASIGNAME){
        if(as == ASIGNAME){
            Bread(bp, &p->sig, 4);
            p->sig = leswal(p->sig);
        }
        p->kind = aName;
        p->type = type2char(Bgetc(bp));		/* type */
        p->sym = Bgetc(bp);			/* sym */
        n = 0;
        for(;;) {
            as = Bgetc(bp);
            if(as < 0)
                return 0;
            n++;
            if(as == 0)
                break;
        }
        p->id = malloc(n);
        if(p->id == 0)
            return 0;
        Bseek(bp, -n, 1);
        if(Bread(bp, p->id, n) != n)
            return 0;
        return 1;
    }
    if(as == ATEXT)
        p->kind = aText;
    if(as == AGLOBL)
        p->kind = aData;
    skip(bp, 4);		/* lineno(4) */
    a = addr(bp);
    addr(bp);
    if(!(a.flags & T_SYM))
        p->kind = aNone;
    p->sym = a.sym;
    return 1;
}
@


<<function type2char(x86)>>=
static char
type2char(int t)
{
    switch(t){
    case D_EXTERN:		return 'U';
    case D_STATIC:		return 'b';
    case D_AUTO:		return 'a';
    case D_PARAM:		return 'p';
    default:		return UNKNOWN;
    }
}
@

<<constant UNKNOWN>>=
#define UNKNOWN	'?'
@

<<function addr(x86)>>=
static Addr
addr(Biobuf *bp)
{
    Addr a;
    int t;
    long off;

    off = 0;
    a.sym = -1;
    a.flags = Bgetc(bp);			/* flags */
    if(a.flags & T_INDEX)
        skip(bp, 2);
    if(a.flags & T_OFFSET){
        off = Bgetc(bp);
        off |= Bgetc(bp) << 8;
        off |= Bgetc(bp) << 16;
        off |= Bgetc(bp) << 24;
        if(off < 0)
            off = -off;
    }
    if(a.flags & T_SYM)
        a.sym = Bgetc(bp);
    if(a.flags & T_FCONST)
        skip(bp, 8);
    else
    if(a.flags & T_SCONST)
        skip(bp, NSNAME);
    if(a.flags & T_TYPE) {
        t = Bgetc(bp);
        if(a.sym > 0 && (t==D_PARAM || t==D_AUTO))
            _offset(a.sym, off);
    }
    return a;
}
@


<<function skip (linkers/libmach/8obj.c)(x86)>>=
static void
skip(Biobuf *bp, int n)
{
    while (n-- > 0)
        Bgetc(bp);
}
@


%-------------------------------------------------------------

<<linkers/libmach/8obj.c>>=
/*
 * 8obj.c - identify and parse a 386 object file
 */
#include <u.h>
#include <libc.h>
#include <bio.h>
#include <mach.h>

#include <386/8.out.h>
#include "obj.h"

typedef struct Addr	Addr;
<<struct Addr(x86)>>
static	Addr	addr(Biobuf*);
static	char	type2char(int);
static	void	skip(Biobuf*, int);

<<function _is8(x86)>>

<<function _read8(x86)>>

<<function addr(x86)>>

<<function type2char(x86)>>

<<function skip (linkers/libmach/8obj.c)(x86)>>
@


\subsection*{[[linkers/libmach/8db.c]]}

<<global STARTSYM(x86)>>=
static	char	STARTSYM[] =	"_main";
@

<<global PROFSYM(x86)>>=
static	char	PROFSYM[] =	"_mainp";
@

<<global FRAMENAME(x86)>>=
static	char	FRAMENAME[] =	".frame";
@

<<global excname(x86)>>=
static char *excname[] =
{
[0]	"divide error",
[1]	"debug exception",
[4]	"overflow",
[5]	"bounds check",
[6]	"invalid opcode",
[7]	"math coprocessor emulation",
[8]	"double fault",
[9]	"math coprocessor overrun",
[10]	"invalid TSS",
[11]	"segment not present",
[12]	"stack exception",
[13]	"general protection violation",
[14]	"page fault",
[16]	"math coprocessor error",
[17]	"alignment check",
[18]	"machine check",
[19]	"floating-point exception",
[24]	"clock",
[25]	"keyboard",
[27]	"modem status",
[28]	"serial line status",
[30]	"floppy disk",
[36]	"mouse",
[37]	"math coprocessor",
[38]	"hard disk",
[64]	"system call",
};
@

<<global i386mach>>=
Machdata i386mach =
{
    {0xCC, 0, 0, 0},	/* break point: INT 3 */
    1,			/* break point size */

    leswab,			/* convert short to local byte order */
    leswal,			/* convert long to local byte order */
    leswav,			/* convert vlong to local byte order */
    i386trace,		/* C traceback */
    i386frame,		/* frame finder */
    i386excep,		/* print exception */
    0,			/* breakpoint fixup */
    leieeesftos,		/* single precision float printer */
    leieeedftos,		/* double precision float printer */
    i386foll,		/* following addresses */
    i386inst,		/* print instruction */
    i386das,		/* dissembler */
    i386instlen,		/* instruction size calculation */
};
@

<<function i386excep>>=
static char*
i386excep(Map *map, Rgetter rget)
{
    ulong c;
    uvlong pc;
    static char buf[16];

    c = (*rget)(map, "TRAP");
    if(c > 64 || excname[c] == 0) {
        if (c == 3) {
            pc = (*rget)(map, "PC");
            if (get1(map, pc, (uchar*)buf, machdata->bpsize) > 0)
            if (memcmp(buf, machdata->bpinst, machdata->bpsize) == 0)
                return "breakpoint";
        }
        snprint(buf, sizeof(buf), "exception %ld", c);
        return buf;
    } else
        return excname[c];
}
@

<<function i386trace>>=
static int
i386trace(Map *map, uvlong pc, uvlong sp, uvlong link, Tracer trace)
{
    int i;
    uvlong osp;
    Symbol s, f;

    USED(link);
    i = 0;
    osp = 0;
    while(findsym(pc, CTEXT, &s)) {
        if (osp == sp)
            break;
        osp = sp;

        if(strcmp(STARTSYM, s.name) == 0 || strcmp(PROFSYM, s.name) == 0)
            break;

        if(pc != s.value) {	/* not at first instruction */
            if(findlocal(&s, FRAMENAME, &f) == 0)
                break;
            sp += f.value-mach->szaddr;
        }

        if (geta(map, sp, &pc) < 0)
            break;

        if(pc == 0)
            break;

        (*trace)(map, pc, sp, &s);
        sp += mach->szaddr;

        if(++i > 1000)
            break;
    }
    return i;
}
@

<<function i386frame>>=
static uvlong
i386frame(Map *map, uvlong addr, uvlong pc, uvlong sp, uvlong link)
{
    Symbol s, f;

    USED(link);
    while (findsym(pc, CTEXT, &s)) {
        if(strcmp(STARTSYM, s.name) == 0 || strcmp(PROFSYM, s.name) == 0)
            break;

        if(pc != s.value) {	/* not first instruction */
            if(findlocal(&s, FRAMENAME, &f) == 0)
                break;
            sp += f.value-mach->szaddr;
        }

        if (s.value == addr)
            return sp;

        if (geta(map, sp, &pc) < 0)
            break;
        sp += mach->szaddr;
    }
    return 0;
}
@

<<struct Instr(x86)>>=
struct	Instr
{
    uchar	mem[1+1+1+1+2+1+1+4+4];		/* raw instruction */
    uvlong	addr;		/* address of start of instruction */
    int	n;		/* number of bytes in instruction */
    char	*prefix;	/* instr prefix */
    char	*segment;	/* segment override */
    uchar	jumptype;	/* set to the operand type for jump/ret/call */
    uchar	amd64;
    uchar	rex;		/* REX prefix (or zero) */
    char	osize;		/* 'W' or 'L' (or 'Q' on amd64) */
    char	asize;		/* address size 'W' or 'L' (or 'Q' or amd64) */
    uchar	mod;		/* bits 6-7 of mod r/m field */
    uchar	reg;		/* bits 3-5 of mod r/m field */
    char	ss;		/* bits 6-7 of SIB */
    char	index;		/* bits 3-5 of SIB */
    char	base;		/* bits 0-2 of SIB */
    char	rip;		/* RIP-relative in amd64 mode */
    uchar	opre;		/* f2/f3 could introduce media */
    short	seg;		/* segment of far address */
    ulong	disp;		/* displacement */
    ulong 	imm;		/* immediate */
    ulong 	imm2;		/* second immediate operand */
    uvlong	imm64;		/* big immediate */
    char	*curr;		/* fill level in output buffer */
    char	*end;		/* end of output buffer */
    char	*err;		/* error message */
};
@

<<enum _anon_ (linkers/libmach/8db.c)(x86)>>=
enum{
    AX=0,
    CX,
    DX,
    BX,
    SP,
    BP,
    SI,
    DI,

    /* amd64 */
    R8,
    R9,
    R10,
    R11,
    R12,
    R13,
    R14,
    R15
};
@

<<enum _anon_ (linkers/libmach/8db.c)2(x86)>>=
enum{
    REXW		= 1<<3,	/* =1, 64-bit operand size */
    REXR		= 1<<2,	/* extend modrm reg */
    REXX		= 1<<1,	/* extend sib index */
    REXB		= 1<<0	/* extend modrm r/m, sib base, or opcode reg */
};
@

<<struct Optable(x86)>>=
struct Optable
{
    char	operand[2];
    void	*proto;		/* actually either (char*) or (Optable*) */
};
@

<<enum _anon_ (linkers/libmach/8db.c)3(x86)>>=
enum {
    Ib = 1,			/* 8-bit immediate - (no sign extension)*/
    Ibs,			/* 8-bit immediate (sign extended) */
    Jbs,			/* 8-bit sign-extended immediate in jump or call */
    Iw,			/* 16-bit immediate -> imm */
    Iw2,			/* 16-bit immediate -> imm2 */
    Iwd,			/* Operand-sized immediate (no sign extension)*/
    Iwdq,			/* Operand-sized immediate, possibly 64 bits */
    Awd,			/* Address offset */
    Iwds,			/* Operand-sized immediate (sign extended) */
    RM,			/* Word or long R/M field with register (/r) */
    RMB,			/* Byte R/M field with register (/r) */
    RMOP,			/* Word or long R/M field with op code (/digit) */
    RMOPB,			/* Byte R/M field with op code (/digit) */
    RMR,			/* R/M register only (mod = 11) */
    RMM,			/* R/M memory only (mod = 0/1/2) */
    R0,			/* Base reg of Mod R/M is literal 0x00 */
    R1,			/* Base reg of Mod R/M is literal 0x01 */
    FRMOP,			/* Floating point R/M field with opcode */
    FRMEX,			/* Extended floating point R/M field with opcode */
    JUMP,			/* Jump or Call flag - no operand */
    RET,			/* Return flag - no operand */
    OA,			/* literal 0x0a byte */
    PTR,			/* Seg:Displacement addr (ptr16:16 or ptr16:32) */
    AUX,			/* Multi-byte op code - Auxiliary table */
    AUXMM,			/* multi-byte op code - auxiliary table chosen by prefix */
    PRE,			/* Instr Prefix */
    OPRE,			/* Instr Prefix or media op extension */
    SEG,			/* Segment Prefix */
    OPOVER,			/* Operand size override */
    ADDOVER,		/* Address size override */
};
@

<<global optab0F00(x86)>>=
static Optable optab0F00[8]=
{
[0x00]	0,0,		"MOVW	LDT,%e",
[0x01]	0,0,		"MOVW	TR,%e",
[0x02]	0,0,		"MOVW	%e,LDT",
[0x03]	0,0,		"MOVW	%e,TR",
[0x04]	0,0,		"VERR	%e",
[0x05]	0,0,		"VERW	%e",
};
@

<<global optab0F01(x86)>>=
static Optable optab0F01[8]=
{
[0x00]	0,0,		"MOVL	GDTR,%e",
[0x01]	0,0,		"MOVL	IDTR,%e",
[0x02]	0,0,		"MOVL	%e,GDTR",
[0x03]	0,0,		"MOVL	%e,IDTR",
[0x04]	0,0,		"MOVW	MSW,%e",	/* word */
[0x06]	0,0,		"MOVW	%e,MSW",	/* word */
[0x07]	0,0,		"INVLPG	%e",		/* or SWAPGS */
};
@

<<global optab0F01F8(x86)>>=
static Optable optab0F01F8[1]=
{
[0x00]	0,0,		"SWAPGS",
};
@

<<global optab0FAE(x86)>>=
/* 0F73 */

static Optable optab0FAE[8]=
{
[0x00]	0,0,		"FXSAVE	%e",
[0x01]	0,0,		"FXRSTOR	%e",
[0x02]	0,0,		"LDMXCSR	%e",
[0x03]	0,0,		"STMXCSR	%e",
[0x05]	0,0,		"LFENCE",
[0x06]	0,0,		"MFENCE",
[0x07]	0,0,		"SFENCE",
};
@

<<global optab0FBA(x86)>>=
/* 0F0D */

static Optable optab0FBA[8]=
{
[0x04]	Ib,0,		"BT%S	%i,%e",
[0x05]	Ib,0,		"BTS%S	%i,%e",
[0x06]	Ib,0,		"BTR%S	%i,%e",
[0x07]	Ib,0,		"BTC%S	%i,%e",
};
@

<<global optab0F0F(x86)>>=
static Optable optab0F0F[256]=
{
[0x0c]	0,0,		"PI2FW	%m,%M",
[0x0d]	0,0,		"PI2L	%m,%M",
[0x1c]	0,0,		"PF2IW	%m,%M",
[0x1d]	0,0,		"PF2IL	%m,%M",
[0x8a]	0,0,		"PFNACC	%m,%M",
[0x8e]	0,0,		"PFPNACC	%m,%M",
[0x90]	0,0,		"PFCMPGE	%m,%M",
[0x94]	0,0,		"PFMIN	%m,%M",
[0x96]	0,0,		"PFRCP	%m,%M",
[0x97]	0,0,		"PFRSQRT	%m,%M",
[0x9a]	0,0,		"PFSUB	%m,%M",
[0x9e]	0,0,		"PFADD	%m,%M",
[0xa0]	0,0,		"PFCMPGT	%m,%M",
[0xa4]	0,0,		"PFMAX	%m,%M",
[0xa6]	0,0,		"PFRCPIT1	%m,%M",
[0xa7]	0,0,		"PFRSQIT1	%m,%M",
[0xaa]	0,0,		"PFSUBR	%m,%M",
[0xae]	0,0,		"PFACC	%m,%M",
[0xb0]	0,0,		"PFCMPEQ	%m,%M",
[0xb4]	0,0,		"PFMUL	%m,%M",
[0xb6]	0,0,		"PFRCPI2T	%m,%M",
[0xb7]	0,0,		"PMULHRW	%m,%M",
[0xbb]	0,0,		"PSWAPL	%m,%M",
};
@

<<global optab0FC7(x86)>>=
static Optable optab0FC7[8]=
{
[0x01]	0,0,		"CMPXCHG8B	%e",
};
@

<<global optab660F71(x86)>>=
static Optable optab660F71[8]=
{
[0x02]	Ib,0,		"PSRLW	%i,%X",
[0x04]	Ib,0,		"PSRAW	%i,%X",
[0x06]	Ib,0,		"PSLLW	%i,%X",
};
@

<<global optab660F72(x86)>>=
static Optable optab660F72[8]=
{
[0x02]	Ib,0,		"PSRLL	%i,%X",
[0x04]	Ib,0,		"PSRAL	%i,%X",
[0x06]	Ib,0,		"PSLLL	%i,%X",
};
@

<<global optab660F73(x86)>>=
static Optable optab660F73[8]=
{
[0x02]	Ib,0,		"PSRLQ	%i,%X",
[0x03]	Ib,0,		"PSRLO	%i,%X",
[0x06]	Ib,0,		"PSLLQ	%i,%X",
[0x07]	Ib,0,		"PSLLO	%i,%X",
};
@

<<global optab660F(x86)>>=
static Optable optab660F[256]=
{
[0x2B]	RM,0,		"MOVNTPD	%x,%e",
[0x2E]	RM,0,		"UCOMISD	%x,%X",
[0x2F]	RM,0,		"COMISD	%x,%X",
[0x5A]	RM,0,		"CVTPD2PS	%x,%X",
[0x5B]	RM,0,		"CVTPS2PL	%x,%X",
[0x6A]	RM,0,		"PUNPCKHLQ %x,%X",
[0x6B]	RM,0,		"PACKSSLW %x,%X",
[0x6C]	RM,0,		"PUNPCKLQDQ %x,%X",
[0x6D]	RM,0,		"PUNPCKHQDQ %x,%X",
[0x6E]	RM,0,		"MOV%S	%e,%X",
[0x6F]	RM,0,		"MOVO	%x,%X",		/* MOVDQA */
[0x70]	RM,Ib,		"PSHUFL	%i,%x,%X",
[0x71]	RMOP,0,		optab660F71,
[0x72]	RMOP,0,		optab660F72,
[0x73]	RMOP,0,		optab660F73,
[0x7E]	RM,0,		"MOV%S	%X,%e",
[0x7F]	RM,0,		"MOVO	%X,%x",
[0xC4]	RM,Ib,		"PINSRW	%i,%e,%X",
[0xC5]	RMR,Ib,		"PEXTRW	%i,%X,%e",
[0xD4]	RM,0,		"PADDQ	%x,%X",
[0xD5]	RM,0,		"PMULLW	%x,%X",
[0xD6]	RM,0,		"MOVQ	%X,%x",
[0xE6]	RM,0,		"CVTTPD2PL	%x,%X",
[0xE7]	RM,0,		"MOVNTO	%X,%e",
[0xF7]	RM,0,		"MASKMOVOU	%x,%X",
};
@

<<global optabF20F(x86)>>=
static Optable optabF20F[256]=
{
[0x10]	RM,0,		"MOVSD	%x,%X",
[0x11]	RM,0,		"MOVSD	%X,%x",
[0x2A]	RM,0,		"CVTS%S2SD	%e,%X",
[0x2C]	RM,0,		"CVTTSD2S%S	%x,%r",
[0x2D]	RM,0,		"CVTSD2S%S	%x,%r",
[0x5A]	RM,0,		"CVTSD2SS	%x,%X",
[0x6F]	RM,0,		"MOVOU	%x,%X",
[0x70]	RM,Ib,		"PSHUFLW	%i,%x,%X",
[0x7F]	RM,0,		"MOVOU	%X,%x",
[0xD6]	RM,0,		"MOVQOZX	%M,%X",
[0xE6]	RM,0,		"CVTPD2PL	%x,%X",
};
@

<<global optabF30F(x86)>>=
static Optable optabF30F[256]=
{
[0x10]	RM,0,		"MOVSS	%x,%X",
[0x11]	RM,0,		"MOVSS	%X,%x",
[0x2A]	RM,0,		"CVTS%S2SS	%e,%X",
[0x2C]	RM,0,		"CVTTSS2S%S	%x,%r",
[0x2D]	RM,0,		"CVTSS2S%S	%x,%r",
[0x5A]	RM,0,		"CVTSS2SD	%x,%X",
[0x5B]	RM,0,		"CVTTPS2PL	%x,%X",
[0x6F]	RM,0,		"MOVOU	%x,%X",
[0x70]	RM,Ib,		"PSHUFHW	%i,%x,%X",
[0x7E]	RM,0,		"MOVQOZX	%x,%X",
[0x7F]	RM,0,		"MOVOU	%X,%x",
[0xD6]	RM,0,		"MOVQOZX	%m*,%X",
[0xE6]	RM,0,		"CVTPL2PD	%x,%X",
};
@

<<global optab0F(x86)>>=
static Optable optab0F[256]=
{
[0x00]	RMOP,0,		optab0F00,
[0x01]	RMOP,0,		optab0F01,
[0x02]	RM,0,		"LAR	%e,%r",
[0x03]	RM,0,		"LSL	%e,%r",
[0x05]	0,0,		"SYSCALL",
[0x06]	0,0,		"CLTS",
[0x07]	0,0,		"SYSRET",
[0x08]	0,0,		"INVD",
[0x09]	0,0,		"WBINVD",
[0x0B]	0,0,		"UD2",
[0x0F]	RM,AUX,		optab0F0F,		/* 3DNow! */
[0x10]	RM,0,		"MOVU%s	%x,%X",
[0x11]	RM,0,		"MOVU%s	%X,%x",
[0x12]	RM,0,		"MOV[H]L%s	%x,%X",	/* TO DO: H if source is XMM */
[0x13]	RM,0,		"MOVL%s	%X,%e",
[0x14]	RM,0,		"UNPCKL%s	%x,%X",
[0x15]	RM,0,		"UNPCKH%s	%x,%X",
[0x16]	RM,0,		"MOV[L]H%s	%x,%X",	/* TO DO: L if source is XMM */
[0x17]	RM,0,		"MOVH%s	%X,%x",
[0x20]	RMR,0,		"MOVL	%C,%e",
[0x21]	RMR,0,		"MOVL	%D,%e",
[0x22]	RMR,0,		"MOVL	%e,%C",
[0x23]	RMR,0,		"MOVL	%e,%D",
[0x24]	RMR,0,		"MOVL	%T,%e",
[0x26]	RMR,0,		"MOVL	%e,%T",
[0x28]	RM,0,		"MOVA%s	%x,%X",
[0x29]	RM,0,		"MOVA%s	%X,%x",
[0x2A]	RM,0,		"CVTPL2%s	%m*,%X",
[0x2B]	RM,0,		"MOVNT%s	%X,%e",
[0x2C]	RM,0,		"CVTT%s2PL	%x,%M",
[0x2D]	RM,0,		"CVT%s2PL	%x,%M",
[0x2E]	RM,0,		"UCOMISS	%x,%X",
[0x2F]	RM,0,		"COMISS	%x,%X",
[0x30]	0,0,		"WRMSR",
[0x31]	0,0,		"RDTSC",
[0x32]	0,0,		"RDMSR",
[0x33]	0,0,		"RDPMC",
[0x42]	RM,0,		"CMOVC	%e,%r",		/* CF */
[0x43]	RM,0,		"CMOVNC	%e,%r",		/*  CF */
[0x44]	RM,0,		"CMOVZ	%e,%r",		/* ZF */
[0x45]	RM,0,		"CMOVNZ	%e,%r",		/*  ZF */
[0x46]	RM,0,		"CMOVBE	%e,%r",		/* CF  ZF */
[0x47]	RM,0,		"CMOVA	%e,%r",		/* CF  ZF */
[0x48]	RM,0,		"CMOVS	%e,%r",		/* SF */
[0x49]	RM,0,		"CMOVNS	%e,%r",		/*  SF */
[0x4A]	RM,0,		"CMOVP	%e,%r",		/* PF */
[0x4B]	RM,0,		"CMOVNP	%e,%r",		/*  PF */
[0x4C]	RM,0,		"CMOVLT	%e,%r",		/* LT  OF  SF */
[0x4D]	RM,0,		"CMOVGE	%e,%r",		/* GE  ZF  SF */
[0x4E]	RM,0,		"CMOVLE	%e,%r",		/* LE  ZF  LT */
[0x4F]	RM,0,		"CMOVGT	%e,%r",		/* GT  ZF  GE */
[0x50]	RM,0,		"MOVMSK%s	%X,%r",	/* TO DO: check */
[0x51]	RM,0,		"SQRT%s	%x,%X",
[0x52]	RM,0,		"RSQRT%s	%x,%X",
[0x53]	RM,0,		"RCP%s	%x,%X",
[0x54]	RM,0,		"AND%s	%x,%X",
[0x55]	RM,0,		"ANDN%s	%x,%X",
[0x56]	RM,0,		"OR%s	%x,%X",		/* TO DO: S/D */
[0x57]	RM,0,		"XOR%s	%x,%X",		/* S/D */
[0x58]	RM,0,		"ADD%s	%x,%X",		/* S/P S/D */
[0x59]	RM,0,		"MUL%s	%x,%X",
[0x5A]	RM,0,		"CVTPS2PD	%x,%X",
[0x5B]	RM,0,		"CVTPL2PS	%x,%X",
[0x5C]	RM,0,		"SUB%s	%x,%X",
[0x5D]	RM,0,		"MIN%s	%x,%X",
[0x5E]	RM,0,		"DIV%s	%x,%X",		/* TO DO: S/P S/D */
[0x5F]	RM,0,		"MAX%s	%x,%X",
[0x60]	RM,0,		"PUNPCKLBW %m,%M",
[0x61]	RM,0,		"PUNPCKLWL %m,%M",
[0x62]	RM,0,		"PUNPCKLLQ %m,%M",
[0x63]	RM,0,		"PACKSSWB %m,%M",
[0x64]	RM,0,		"PCMPGTB %m,%M",
[0x65]	RM,0,		"PCMPGTW %m,%M",
[0x66]	RM,0,		"PCMPGTL %m,%M",
[0x67]	RM,0,		"PACKUSWB %m,%M",
[0x68]	RM,0,		"PUNPCKHBW %m,%M",
[0x69]	RM,0,		"PUNPCKHWL %m,%M",
[0x6A]	RM,0,		"PUNPCKHLQ %m,%M",
[0x6B]	RM,0,		"PACKSSLW %m,%M",
[0x6E]	RM,0,		"MOV%S %e,%M",
[0x6F]	RM,0,		"MOVQ %m,%M",
[0x70]	RM,Ib,		"PSHUFW	%i,%m,%M",
[0x74]	RM,0,		"PCMPEQB %m,%M",
[0x75]	RM,0,		"PCMPEQW %m,%M",
[0x76]	RM,0,		"PCMPEQL %m,%M",
[0x7E]	RM,0,		"MOV%S %M,%e",
[0x7F]	RM,0,		"MOVQ %M,%m",
[0xAE]	RMOP,0,		optab0FAE,
[0xAA]	0,0,		"RSM",
[0xB0]	RM,0,		"CMPXCHGB	%r,%e",
[0xB1]	RM,0,		"CMPXCHG%S	%r,%e",
[0xC0]	RMB,0,		"XADDB	%r,%e",
[0xC1]	RM,0,		"XADD%S	%r,%e",
[0xC2]	RM,Ib,		"CMP%s	%i,%x,%X",
[0xC3]	RM,0,		"MOVNTI%S	%r,%e",
[0xC6]	RM,Ib,		"SHUF%s	%i,%x,%X",
[0xC8]	0,0,		"BSWAP	AX",
[0xC9]	0,0,		"BSWAP	CX",
[0xCA]	0,0,		"BSWAP	DX",
[0xCB]	0,0,		"BSWAP	BX",
[0xCC]	0,0,		"BSWAP	SP",
[0xCD]	0,0,		"BSWAP	BP",
[0xCE]	0,0,		"BSWAP	SI",
[0xCF]	0,0,		"BSWAP	DI",
[0xD1]	RM,0,		"PSRLW %m,%M",
[0xD2]	RM,0,		"PSRLL %m,%M",
[0xD3]	RM,0,		"PSRLQ %m,%M",
[0xD5]	RM,0,		"PMULLW %m,%M",
[0xD6]	RM,0,		"MOVQOZX	%m*,%X",
[0xD7]	RM,0,		"PMOVMSKB %m,%r",
[0xD8]	RM,0,		"PSUBUSB %m,%M",
[0xD9]	RM,0,		"PSUBUSW %m,%M",
[0xDA]	RM,0,		"PMINUB %m,%M",
[0xDB]	RM,0,		"PAND %m,%M",
[0xDC]	RM,0,		"PADDUSB %m,%M",
[0xDD]	RM,0,		"PADDUSW %m,%M",
[0xDE]	RM,0,		"PMAXUB %m,%M",
[0xDF]	RM,0,		"PANDN %m,%M",
[0xE0]	RM,0,		"PAVGB %m,%M",
[0xE1]	RM,0,		"PSRAW %m,%M",
[0xE2]	RM,0,		"PSRAL %m,%M",
[0xE3]	RM,0,		"PAVGW %m,%M",
[0xE4]	RM,0,		"PMULHUW %m,%M",
[0xE5]	RM,0,		"PMULHW %m,%M",
[0xE7]	RM,0,		"MOVNTQ	%M,%e",
[0xE8]	RM,0,		"PSUBSB %m,%M",
[0xE9]	RM,0,		"PSUBSW %m,%M",
[0xEA]	RM,0,		"PMINSW %m,%M",
[0xEB]	RM,0,		"POR %m,%M",
[0xEC]	RM,0,		"PADDSB %m,%M",
[0xED]	RM,0,		"PADDSW %m,%M",
[0xEE]	RM,0,		"PMAXSW %m,%M",
[0xEF]	RM,0,		"PXOR %m,%M",
[0xF1]	RM,0,		"PSLLW %m,%M",
[0xF2]	RM,0,		"PSLLL %m,%M",
[0xF3]	RM,0,		"PSLLQ %m,%M",
[0xF4]	RM,0,		"PMULULQ	%m,%M",
[0xF5]	RM,0,		"PMADDWL %m,%M",
[0xF6]	RM,0,		"PSADBW %m,%M",
[0xF7]	RMR,0,		"MASKMOVQ	%m,%M",
[0xF8]	RM,0,		"PSUBB %m,%M",
[0xF9]	RM,0,		"PSUBW %m,%M",
[0xFA]	RM,0,		"PSUBL %m,%M",
[0xFC]	RM,0,		"PADDB %m,%M",
[0xFD]	RM,0,		"PADDW %m,%M",
[0xFE]	RM,0,		"PADDL %m,%M",

[0x80]	Iwds,0,		"JOS	%p",
[0x81]	Iwds,0,		"JOC	%p",
[0x82]	Iwds,0,		"JCS	%p",
[0x83]	Iwds,0,		"JCC	%p",
[0x84]	Iwds,0,		"JEQ	%p",
[0x85]	Iwds,0,		"JNE	%p",
[0x86]	Iwds,0,		"JLS	%p",
[0x87]	Iwds,0,		"JHI	%p",
[0x88]	Iwds,0,		"JMI	%p",
[0x89]	Iwds,0,		"JPL	%p",
[0x8a]	Iwds,0,		"JPS	%p",
[0x8b]	Iwds,0,		"JPC	%p",
[0x8c]	Iwds,0,		"JLT	%p",
[0x8d]	Iwds,0,		"JGE	%p",
[0x8e]	Iwds,0,		"JLE	%p",
[0x8f]	Iwds,0,		"JGT	%p",
[0x90]	RMB,0,		"SETOS	%e",
[0x91]	RMB,0,		"SETOC	%e",
[0x92]	RMB,0,		"SETCS	%e",
[0x93]	RMB,0,		"SETCC	%e",
[0x94]	RMB,0,		"SETEQ	%e",
[0x95]	RMB,0,		"SETNE	%e",
[0x96]	RMB,0,		"SETLS	%e",
[0x97]	RMB,0,		"SETHI	%e",
[0x98]	RMB,0,		"SETMI	%e",
[0x99]	RMB,0,		"SETPL	%e",
[0x9a]	RMB,0,		"SETPS	%e",
[0x9b]	RMB,0,		"SETPC	%e",
[0x9c]	RMB,0,		"SETLT	%e",
[0x9d]	RMB,0,		"SETGE	%e",
[0x9e]	RMB,0,		"SETLE	%e",
[0x9f]	RMB,0,		"SETGT	%e",
[0xa0]	0,0,		"PUSHL	FS",
[0xa1]	0,0,		"POPL	FS",
[0xa2]	0,0,		"CPUID",
[0xa3]	RM,0,		"BT%S	%r,%e",
[0xa4]	RM,Ib,		"SHLD%S	%r,%i,%e",
[0xa5]	RM,0,		"SHLD%S	%r,CL,%e",
[0xa8]	0,0,		"PUSHL	GS",
[0xa9]	0,0,		"POPL	GS",
[0xab]	RM,0,		"BTS%S	%r,%e",
[0xac]	RM,Ib,		"SHRD%S	%r,%i,%e",
[0xad]	RM,0,		"SHRD%S	%r,CL,%e",
[0xaf]	RM,0,		"IMUL%S	%e,%r",
[0xb2]	RMM,0,		"LSS	%e,%r",
[0xb3]	RM,0,		"BTR%S	%r,%e",
[0xb4]	RMM,0,		"LFS	%e,%r",
[0xb5]	RMM,0,		"LGS	%e,%r",
[0xb6]	RMB,0,		"MOVBZX	%e,%R",
[0xb7]	RM,0,		"MOVWZX	%e,%R",
[0xba]	RMOP,0,		optab0FBA,
[0xbb]	RM,0,		"BTC%S	%e,%r",
[0xbc]	RM,0,		"BSF%S	%e,%r",
[0xbd]	RM,0,		"BSR%S	%e,%r",
[0xbe]	RMB,0,		"MOVBSX	%e,%R",
[0xbf]	RM,0,		"MOVWSX	%e,%R",
[0xc7]	RMOP,0,		optab0FC7,
};
@

<<global optab80(x86)>>=
static Optable optab80[8]=
{
[0x00]	Ib,0,		"ADDB	%i,%e",
[0x01]	Ib,0,		"ORB	%i,%e",
[0x02]	Ib,0,		"ADCB	%i,%e",
[0x03]	Ib,0,		"SBBB	%i,%e",
[0x04]	Ib,0,		"ANDB	%i,%e",
[0x05]	Ib,0,		"SUBB	%i,%e",
[0x06]	Ib,0,		"XORB	%i,%e",
[0x07]	Ib,0,		"CMPB	%e,%i",
};
@

<<global optab81(x86)>>=
static Optable optab81[8]=
{
[0x00]	Iwd,0,		"ADD%S	%i,%e",
[0x01]	Iwd,0,		"OR%S	%i,%e",
[0x02]	Iwd,0,		"ADC%S	%i,%e",
[0x03]	Iwd,0,		"SBB%S	%i,%e",
[0x04]	Iwd,0,		"AND%S	%i,%e",
[0x05]	Iwd,0,		"SUB%S	%i,%e",
[0x06]	Iwd,0,		"XOR%S	%i,%e",
[0x07]	Iwd,0,		"CMP%S	%e,%i",
};
@

<<global optab83(x86)>>=
static Optable optab83[8]=
{
[0x00]	Ibs,0,		"ADD%S	%i,%e",
[0x01]	Ibs,0,		"OR%S	%i,%e",
[0x02]	Ibs,0,		"ADC%S	%i,%e",
[0x03]	Ibs,0,		"SBB%S	%i,%e",
[0x04]	Ibs,0,		"AND%S	%i,%e",
[0x05]	Ibs,0,		"SUB%S	%i,%e",
[0x06]	Ibs,0,		"XOR%S	%i,%e",
[0x07]	Ibs,0,		"CMP%S	%e,%i",
};
@

<<global optabC0(x86)>>=
static Optable optabC0[8] =
{
[0x00]	Ib,0,		"ROLB	%i,%e",
[0x01]	Ib,0,		"RORB	%i,%e",
[0x02]	Ib,0,		"RCLB	%i,%e",
[0x03]	Ib,0,		"RCRB	%i,%e",
[0x04]	Ib,0,		"SHLB	%i,%e",
[0x05]	Ib,0,		"SHRB	%i,%e",
[0x07]	Ib,0,		"SARB	%i,%e",
};
@

<<global optabC1(x86)>>=
static Optable optabC1[8] =
{
[0x00]	Ib,0,		"ROL%S	%i,%e",
[0x01]	Ib,0,		"ROR%S	%i,%e",
[0x02]	Ib,0,		"RCL%S	%i,%e",
[0x03]	Ib,0,		"RCR%S	%i,%e",
[0x04]	Ib,0,		"SHL%S	%i,%e",
[0x05]	Ib,0,		"SHR%S	%i,%e",
[0x07]	Ib,0,		"SAR%S	%i,%e",
};
@

<<global optabD0(x86)>>=
static Optable optabD0[8] =
{
[0x00]	0,0,		"ROLB	%e",
[0x01]	0,0,		"RORB	%e",
[0x02]	0,0,		"RCLB	%e",
[0x03]	0,0,		"RCRB	%e",
[0x04]	0,0,		"SHLB	%e",
[0x05]	0,0,		"SHRB	%e",
[0x07]	0,0,		"SARB	%e",
};
@

<<global optabD1(x86)>>=
static Optable optabD1[8] =
{
[0x00]	0,0,		"ROL%S	%e",
[0x01]	0,0,		"ROR%S	%e",
[0x02]	0,0,		"RCL%S	%e",
[0x03]	0,0,		"RCR%S	%e",
[0x04]	0,0,		"SHL%S	%e",
[0x05]	0,0,		"SHR%S	%e",
[0x07]	0,0,		"SAR%S	%e",
};
@

<<global optabD2(x86)>>=
static Optable optabD2[8] =
{
[0x00]	0,0,		"ROLB	CL,%e",
[0x01]	0,0,		"RORB	CL,%e",
[0x02]	0,0,		"RCLB	CL,%e",
[0x03]	0,0,		"RCRB	CL,%e",
[0x04]	0,0,		"SHLB	CL,%e",
[0x05]	0,0,		"SHRB	CL,%e",
[0x07]	0,0,		"SARB	CL,%e",
};
@

<<global optabD3(x86)>>=
static Optable optabD3[8] =
{
[0x00]	0,0,		"ROL%S	CL,%e",
[0x01]	0,0,		"ROR%S	CL,%e",
[0x02]	0,0,		"RCL%S	CL,%e",
[0x03]	0,0,		"RCR%S	CL,%e",
[0x04]	0,0,		"SHL%S	CL,%e",
[0x05]	0,0,		"SHR%S	CL,%e",
[0x07]	0,0,		"SAR%S	CL,%e",
};
@

<<global optabD8(x86)>>=
static Optable optabD8[8+8] =
{
[0x00]	0,0,		"FADDF	%e,F0",
[0x01]	0,0,		"FMULF	%e,F0",
[0x02]	0,0,		"FCOMF	%e,F0",
[0x03]	0,0,		"FCOMFP	%e,F0",
[0x04]	0,0,		"FSUBF	%e,F0",
[0x05]	0,0,		"FSUBRF	%e,F0",
[0x06]	0,0,		"FDIVF	%e,F0",
[0x07]	0,0,		"FDIVRF	%e,F0",
[0x08]	0,0,		"FADDD	%f,F0",
[0x09]	0,0,		"FMULD	%f,F0",
[0x0a]	0,0,		"FCOMD	%f,F0",
[0x0b]	0,0,		"FCOMPD	%f,F0",
[0x0c]	0,0,		"FSUBD	%f,F0",
[0x0d]	0,0,		"FSUBRD	%f,F0",
[0x0e]	0,0,		"FDIVD	%f,F0",
[0x0f]	0,0,		"FDIVRD	%f,F0",
};
@

<<global optabD9(x86)>>=
/*
 *	optabD9 and optabDB use the following encoding: 
 *	if (0 <= modrm <= 2) instruction = optabDx[modrm&0x07];
 *	else instruction = optabDx[(modrm&0x3f)+8];
 *
 *	the instructions for MOD == 3, follow the 8 instructions
 *	for the other MOD values stored at the front of the table.
 */
static Optable optabD9[64+8] =
{
[0x00]	0,0,		"FMOVF	%e,F0",
[0x02]	0,0,		"FMOVF	F0,%e",
[0x03]	0,0,		"FMOVFP	F0,%e",
[0x04]	0,0,		"FLDENV%S %e",
[0x05]	0,0,		"FLDCW	%e",
[0x06]	0,0,		"FSTENV%S %e",
[0x07]	0,0,		"FSTCW	%e",
[0x08]	0,0,		"FMOVD	F0,F0",		/* Mod R/M = 11xx xxxx*/
[0x09]	0,0,		"FMOVD	F1,F0",
[0x0a]	0,0,		"FMOVD	F2,F0",
[0x0b]	0,0,		"FMOVD	F3,F0",
[0x0c]	0,0,		"FMOVD	F4,F0",
[0x0d]	0,0,		"FMOVD	F5,F0",
[0x0e]	0,0,		"FMOVD	F6,F0",
[0x0f]	0,0,		"FMOVD	F7,F0",
[0x10]	0,0,		"FXCHD	F0,F0",
[0x11]	0,0,		"FXCHD	F1,F0",
[0x12]	0,0,		"FXCHD	F2,F0",
[0x13]	0,0,		"FXCHD	F3,F0",
[0x14]	0,0,		"FXCHD	F4,F0",
[0x15]	0,0,		"FXCHD	F5,F0",
[0x16]	0,0,		"FXCHD	F6,F0",
[0x17]	0,0,		"FXCHD	F7,F0",
[0x18]	0,0,		"FNOP",
[0x28]	0,0,		"FCHS",
[0x29]	0,0,		"FABS",
[0x2c]	0,0,		"FTST",
[0x2d]	0,0,		"FXAM",
[0x30]	0,0,		"FLD1",
[0x31]	0,0,		"FLDL2T",
[0x32]	0,0,		"FLDL2E",
[0x33]	0,0,		"FLDPI",
[0x34]	0,0,		"FLDLG2",
[0x35]	0,0,		"FLDLN2",
[0x36]	0,0,		"FLDZ",
[0x38]	0,0,		"F2XM1",
[0x39]	0,0,		"FYL2X",
[0x3a]	0,0,		"FPTAN",
[0x3b]	0,0,		"FPATAN",
[0x3c]	0,0,		"FXTRACT",
[0x3d]	0,0,		"FPREM1",
[0x3e]	0,0,		"FDECSTP",
[0x3f]	0,0,		"FNCSTP",
[0x40]	0,0,		"FPREM",
[0x41]	0,0,		"FYL2XP1",
[0x42]	0,0,		"FSQRT",
[0x43]	0,0,		"FSINCOS",
[0x44]	0,0,		"FRNDINT",
[0x45]	0,0,		"FSCALE",
[0x46]	0,0,		"FSIN",
[0x47]	0,0,		"FCOS",
};
@

<<global optabDA(x86)>>=
static Optable optabDA[8+8] =
{
[0x00]	0,0,		"FADDL	%e,F0",
[0x01]	0,0,		"FMULL	%e,F0",
[0x02]	0,0,		"FCOML	%e,F0",
[0x03]	0,0,		"FCOMLP	%e,F0",
[0x04]	0,0,		"FSUBL	%e,F0",
[0x05]	0,0,		"FSUBRL	%e,F0",
[0x06]	0,0,		"FDIVL	%e,F0",
[0x07]	0,0,		"FDIVRL	%e,F0",
[0x0d]	R1,0,		"FUCOMPP",
};
@

<<global optabDB(x86)>>=
static Optable optabDB[8+64] =
{
[0x00]	0,0,		"FMOVL	%e,F0",
[0x02]	0,0,		"FMOVL	F0,%e",
[0x03]	0,0,		"FMOVLP	F0,%e",
[0x05]	0,0,		"FMOVX	%e,F0",
[0x07]	0,0,		"FMOVXP	F0,%e",
[0x2a]	0,0,		"FCLEX",
[0x2b]	0,0,		"FINIT",
};
@

<<global optabDC(x86)>>=
static Optable optabDC[8+8] =
{
[0x00]	0,0,		"FADDD	%e,F0",
[0x01]	0,0,		"FMULD	%e,F0",
[0x02]	0,0,		"FCOMD	%e,F0",
[0x03]	0,0,		"FCOMDP	%e,F0",
[0x04]	0,0,		"FSUBD	%e,F0",
[0x05]	0,0,		"FSUBRD	%e,F0",
[0x06]	0,0,		"FDIVD	%e,F0",
[0x07]	0,0,		"FDIVRD	%e,F0",
[0x08]	0,0,		"FADDD	F0,%f",
[0x09]	0,0,		"FMULD	F0,%f",
[0x0c]	0,0,		"FSUBRD	F0,%f",
[0x0d]	0,0,		"FSUBD	F0,%f",
[0x0e]	0,0,		"FDIVRD	F0,%f",
[0x0f]	0,0,		"FDIVD	F0,%f",
};
@

<<global optabDD(x86)>>=
static Optable optabDD[8+8] =
{
[0x00]	0,0,		"FMOVD	%e,F0",
[0x02]	0,0,		"FMOVD	F0,%e",
[0x03]	0,0,		"FMOVDP	F0,%e",
[0x04]	0,0,		"FRSTOR%S %e",
[0x06]	0,0,		"FSAVE%S %e",
[0x07]	0,0,		"FSTSW	%e",
[0x08]	0,0,		"FFREED	%f",
[0x0a]	0,0,		"FMOVD	%f,F0",
[0x0b]	0,0,		"FMOVDP	%f,F0",
[0x0c]	0,0,		"FUCOMD	%f,F0",
[0x0d]	0,0,		"FUCOMDP %f,F0",
};
@

<<global optabDE(x86)>>=
static Optable optabDE[8+8] =
{
[0x00]	0,0,		"FADDW	%e,F0",
[0x01]	0,0,		"FMULW	%e,F0",
[0x02]	0,0,		"FCOMW	%e,F0",
[0x03]	0,0,		"FCOMWP	%e,F0",
[0x04]	0,0,		"FSUBW	%e,F0",
[0x05]	0,0,		"FSUBRW	%e,F0",
[0x06]	0,0,		"FDIVW	%e,F0",
[0x07]	0,0,		"FDIVRW	%e,F0",
[0x08]	0,0,		"FADDDP	F0,%f",
[0x09]	0,0,		"FMULDP	F0,%f",
[0x0b]	R1,0,		"FCOMPDP",
[0x0c]	0,0,		"FSUBRDP F0,%f",
[0x0d]	0,0,		"FSUBDP	F0,%f",
[0x0e]	0,0,		"FDIVRDP F0,%f",
[0x0f]	0,0,		"FDIVDP	F0,%f",
};
@

<<global optabDF(x86)>>=
static Optable optabDF[8+8] =
{
[0x00]	0,0,		"FMOVW	%e,F0",
[0x02]	0,0,		"FMOVW	F0,%e",
[0x03]	0,0,		"FMOVWP	F0,%e",
[0x04]	0,0,		"FBLD	%e",
[0x05]	0,0,		"FMOVL	%e,F0",
[0x06]	0,0,		"FBSTP	%e",
[0x07]	0,0,		"FMOVLP	F0,%e",
[0x0c]	R0,0,		"FSTSW	%OAX",
};
@

<<global optabF6(x86)>>=
static Optable optabF6[8] =
{
[0x00]	Ib,0,		"TESTB	%i,%e",
[0x02]	0,0,		"NOTB	%e",
[0x03]	0,0,		"NEGB	%e",
[0x04]	0,0,		"MULB	AL,%e",
[0x05]	0,0,		"IMULB	AL,%e",
[0x06]	0,0,		"DIVB	AL,%e",
[0x07]	0,0,		"IDIVB	AL,%e",
};
@

<<global optabF7(x86)>>=
static Optable optabF7[8] =
{
[0x00]	Iwd,0,		"TEST%S	%i,%e",
[0x02]	0,0,		"NOT%S	%e",
[0x03]	0,0,		"NEG%S	%e",
[0x04]	0,0,		"MUL%S	%OAX,%e",
[0x05]	0,0,		"IMUL%S	%OAX,%e",
[0x06]	0,0,		"DIV%S	%OAX,%e",
[0x07]	0,0,		"IDIV%S	%OAX,%e",
};
@

<<global optabFE(x86)>>=
static Optable optabFE[8] =
{
[0x00]	0,0,		"INCB	%e",
[0x01]	0,0,		"DECB	%e",
};
@

<<global optabFF(x86)>>=
static Optable optabFF[8] =
{
[0x00]	0,0,		"INC%S	%e",
[0x01]	0,0,		"DEC%S	%e",
[0x02]	JUMP,0,		"CALL*	%e",
[0x03]	JUMP,0,		"CALLF*	%e",
[0x04]	JUMP,0,		"JMP*	%e",
[0x05]	JUMP,0,		"JMPF*	%e",
[0x06]	0,0,		"PUSHL	%e",
};
@

<<global optable(x86)>>=
static Optable optable[256+1] =
{
[0x00]	RMB,0,		"ADDB	%r,%e",
[0x01]	RM,0,		"ADD%S	%r,%e",
[0x02]	RMB,0,		"ADDB	%e,%r",
[0x03]	RM,0,		"ADD%S	%e,%r",
[0x04]	Ib,0,		"ADDB	%i,AL",
[0x05]	Iwd,0,		"ADD%S	%i,%OAX",
[0x06]	0,0,		"PUSHL	ES",
[0x07]	0,0,		"POPL	ES",
[0x08]	RMB,0,		"ORB	%r,%e",
[0x09]	RM,0,		"OR%S	%r,%e",
[0x0a]	RMB,0,		"ORB	%e,%r",
[0x0b]	RM,0,		"OR%S	%e,%r",
[0x0c]	Ib,0,		"ORB	%i,AL",
[0x0d]	Iwd,0,		"OR%S	%i,%OAX",
[0x0e]	0,0,		"PUSHL	CS",
[0x0f]	AUXMM,0,	optab0F,
[0x10]	RMB,0,		"ADCB	%r,%e",
[0x11]	RM,0,		"ADC%S	%r,%e",
[0x12]	RMB,0,		"ADCB	%e,%r",
[0x13]	RM,0,		"ADC%S	%e,%r",
[0x14]	Ib,0,		"ADCB	%i,AL",
[0x15]	Iwd,0,		"ADC%S	%i,%OAX",
[0x16]	0,0,		"PUSHL	SS",
[0x17]	0,0,		"POPL	SS",
[0x18]	RMB,0,		"SBBB	%r,%e",
[0x19]	RM,0,		"SBB%S	%r,%e",
[0x1a]	RMB,0,		"SBBB	%e,%r",
[0x1b]	RM,0,		"SBB%S	%e,%r",
[0x1c]	Ib,0,		"SBBB	%i,AL",
[0x1d]	Iwd,0,		"SBB%S	%i,%OAX",
[0x1e]	0,0,		"PUSHL	DS",
[0x1f]	0,0,		"POPL	DS",
[0x20]	RMB,0,		"ANDB	%r,%e",
[0x21]	RM,0,		"AND%S	%r,%e",
[0x22]	RMB,0,		"ANDB	%e,%r",
[0x23]	RM,0,		"AND%S	%e,%r",
[0x24]	Ib,0,		"ANDB	%i,AL",
[0x25]	Iwd,0,		"AND%S	%i,%OAX",
[0x26]	SEG,0,		"ES:",
[0x27]	0,0,		"DAA",
[0x28]	RMB,0,		"SUBB	%r,%e",
[0x29]	RM,0,		"SUB%S	%r,%e",
[0x2a]	RMB,0,		"SUBB	%e,%r",
[0x2b]	RM,0,		"SUB%S	%e,%r",
[0x2c]	Ib,0,		"SUBB	%i,AL",
[0x2d]	Iwd,0,		"SUB%S	%i,%OAX",
[0x2e]	SEG,0,		"CS:",
[0x2f]	0,0,		"DAS",
[0x30]	RMB,0,		"XORB	%r,%e",
[0x31]	RM,0,		"XOR%S	%r,%e",
[0x32]	RMB,0,		"XORB	%e,%r",
[0x33]	RM,0,		"XOR%S	%e,%r",
[0x34]	Ib,0,		"XORB	%i,AL",
[0x35]	Iwd,0,		"XOR%S	%i,%OAX",
[0x36]	SEG,0,		"SS:",
[0x37]	0,0,		"AAA",
[0x38]	RMB,0,		"CMPB	%r,%e",
[0x39]	RM,0,		"CMP%S	%r,%e",
[0x3a]	RMB,0,		"CMPB	%e,%r",
[0x3b]	RM,0,		"CMP%S	%e,%r",
[0x3c]	Ib,0,		"CMPB	%i,AL",
[0x3d]	Iwd,0,		"CMP%S	%i,%OAX",
[0x3e]	SEG,0,		"DS:",
[0x3f]	0,0,		"AAS",
[0x40]	0,0,		"INC%S	%OAX",
[0x41]	0,0,		"INC%S	%OCX",
[0x42]	0,0,		"INC%S	%ODX",
[0x43]	0,0,		"INC%S	%OBX",
[0x44]	0,0,		"INC%S	%OSP",
[0x45]	0,0,		"INC%S	%OBP",
[0x46]	0,0,		"INC%S	%OSI",
[0x47]	0,0,		"INC%S	%ODI",
[0x48]	0,0,		"DEC%S	%OAX",
[0x49]	0,0,		"DEC%S	%OCX",
[0x4a]	0,0,		"DEC%S	%ODX",
[0x4b]	0,0,		"DEC%S	%OBX",
[0x4c]	0,0,		"DEC%S	%OSP",
[0x4d]	0,0,		"DEC%S	%OBP",
[0x4e]	0,0,		"DEC%S	%OSI",
[0x4f]	0,0,		"DEC%S	%ODI",
[0x50]	0,0,		"PUSH%S	%OAX",
[0x51]	0,0,		"PUSH%S	%OCX",
[0x52]	0,0,		"PUSH%S	%ODX",
[0x53]	0,0,		"PUSH%S	%OBX",
[0x54]	0,0,		"PUSH%S	%OSP",
[0x55]	0,0,		"PUSH%S	%OBP",
[0x56]	0,0,		"PUSH%S	%OSI",
[0x57]	0,0,		"PUSH%S	%ODI",
[0x58]	0,0,		"POP%S	%OAX",
[0x59]	0,0,		"POP%S	%OCX",
[0x5a]	0,0,		"POP%S	%ODX",
[0x5b]	0,0,		"POP%S	%OBX",
[0x5c]	0,0,		"POP%S	%OSP",
[0x5d]	0,0,		"POP%S	%OBP",
[0x5e]	0,0,		"POP%S	%OSI",
[0x5f]	0,0,		"POP%S	%ODI",
[0x60]	0,0,		"PUSHA%S",
[0x61]	0,0,		"POPA%S",
[0x62]	RMM,0,		"BOUND	%e,%r",
[0x63]	RM,0,		"ARPL	%r,%e",
[0x64]	SEG,0,		"FS:",
[0x65]	SEG,0,		"GS:",
[0x66]	OPOVER,0,	"",
[0x67]	ADDOVER,0,	"",
[0x68]	Iwd,0,		"PUSH%S	%i",
[0x69]	RM,Iwd,		"IMUL%S	%e,%i,%r",
[0x6a]	Ib,0,		"PUSH%S	%i",
[0x6b]	RM,Ibs,		"IMUL%S	%e,%i,%r",
[0x6c]	0,0,		"INSB	DX,(%ODI)",
[0x6d]	0,0,		"INS%S	DX,(%ODI)",
[0x6e]	0,0,		"OUTSB	(%ASI),DX",
[0x6f]	0,0,		"OUTS%S	(%ASI),DX",
[0x70]	Jbs,0,		"JOS	%p",
[0x71]	Jbs,0,		"JOC	%p",
[0x72]	Jbs,0,		"JCS	%p",
[0x73]	Jbs,0,		"JCC	%p",
[0x74]	Jbs,0,		"JEQ	%p",
[0x75]	Jbs,0,		"JNE	%p",
[0x76]	Jbs,0,		"JLS	%p",
[0x77]	Jbs,0,		"JHI	%p",
[0x78]	Jbs,0,		"JMI	%p",
[0x79]	Jbs,0,		"JPL	%p",
[0x7a]	Jbs,0,		"JPS	%p",
[0x7b]	Jbs,0,		"JPC	%p",
[0x7c]	Jbs,0,		"JLT	%p",
[0x7d]	Jbs,0,		"JGE	%p",
[0x7e]	Jbs,0,		"JLE	%p",
[0x7f]	Jbs,0,		"JGT	%p",
[0x80]	RMOPB,0,	optab80,
[0x81]	RMOP,0,		optab81,
[0x83]	RMOP,0,		optab83,
[0x84]	RMB,0,		"TESTB	%r,%e",
[0x85]	RM,0,		"TEST%S	%r,%e",
[0x86]	RMB,0,		"XCHGB	%r,%e",
[0x87]	RM,0,		"XCHG%S	%r,%e",
[0x88]	RMB,0,		"MOVB	%r,%e",
[0x89]	RM,0,		"MOV%S	%r,%e",
[0x8a]	RMB,0,		"MOVB	%e,%r",
[0x8b]	RM,0,		"MOV%S	%e,%r",
[0x8c]	RM,0,		"MOVW	%g,%e",
[0x8d]	RM,0,		"LEA%S	%e,%r",
[0x8e]	RM,0,		"MOVW	%e,%g",
[0x8f]	RM,0,		"POP%S	%e",
[0x90]	0,0,		"NOP",
[0x91]	0,0,		"XCHG	%OCX,%OAX",
[0x92]	0,0,		"XCHG	%ODX,%OAX",
[0x93]	0,0,		"XCHG	%OBX,%OAX",
[0x94]	0,0,		"XCHG	%OSP,%OAX",
[0x95]	0,0,		"XCHG	%OBP,%OAX",
[0x96]	0,0,		"XCHG	%OSI,%OAX",
[0x97]	0,0,		"XCHG	%ODI,%OAX",
[0x98]	0,0,		"%W",			/* miserable CBW or CWDE */
[0x99]	0,0,		"%w",			/* idiotic CWD or CDQ */
[0x9a]	PTR,0,		"CALL%S	%d",
[0x9b]	0,0,		"WAIT",
[0x9c]	0,0,		"PUSHF",
[0x9d]	0,0,		"POPF",
[0x9e]	0,0,		"SAHF",
[0x9f]	0,0,		"LAHF",
[0xa0]	Awd,0,		"MOVB	%i,AL",
[0xa1]	Awd,0,		"MOV%S	%i,%OAX",
[0xa2]	Awd,0,		"MOVB	AL,%i",
[0xa3]	Awd,0,		"MOV%S	%OAX,%i",
[0xa4]	0,0,		"MOVSB	(%ASI),(%ADI)",
[0xa5]	0,0,		"MOVS%S	(%ASI),(%ADI)",
[0xa6]	0,0,		"CMPSB	(%ASI),(%ADI)",
[0xa7]	0,0,		"CMPS%S	(%ASI),(%ADI)",
[0xa8]	Ib,0,		"TESTB	%i,AL",
[0xa9]	Iwd,0,		"TEST%S	%i,%OAX",
[0xaa]	0,0,		"STOSB	AL,(%ADI)",
[0xab]	0,0,		"STOS%S	%OAX,(%ADI)",
[0xac]	0,0,		"LODSB	(%ASI),AL",
[0xad]	0,0,		"LODS%S	(%ASI),%OAX",
[0xae]	0,0,		"SCASB	(%ADI),AL",
[0xaf]	0,0,		"SCAS%S	(%ADI),%OAX",
[0xb0]	Ib,0,		"MOVB	%i,AL",
[0xb1]	Ib,0,		"MOVB	%i,CL",
[0xb2]	Ib,0,		"MOVB	%i,DL",
[0xb3]	Ib,0,		"MOVB	%i,BL",
[0xb4]	Ib,0,		"MOVB	%i,AH",
[0xb5]	Ib,0,		"MOVB	%i,CH",
[0xb6]	Ib,0,		"MOVB	%i,DH",
[0xb7]	Ib,0,		"MOVB	%i,BH",
[0xb8]	Iwdq,0,		"MOV%S	%i,%OAX",
[0xb9]	Iwdq,0,		"MOV%S	%i,%OCX",
[0xba]	Iwdq,0,		"MOV%S	%i,%ODX",
[0xbb]	Iwdq,0,		"MOV%S	%i,%OBX",
[0xbc]	Iwdq,0,		"MOV%S	%i,%OSP",
[0xbd]	Iwdq,0,		"MOV%S	%i,%OBP",
[0xbe]	Iwdq,0,		"MOV%S	%i,%OSI",
[0xbf]	Iwdq,0,		"MOV%S	%i,%ODI",
[0xc0]	RMOPB,0,	optabC0,
[0xc1]	RMOP,0,		optabC1,
[0xc2]	Iw,0,		"RET	%i",
[0xc3]	RET,0,		"RET",
[0xc4]	RM,0,		"LES	%e,%r",
[0xc5]	RM,0,		"LDS	%e,%r",
[0xc6]	RMB,Ib,		"MOVB	%i,%e",
[0xc7]	RM,Iwd,		"MOV%S	%i,%e",
[0xc8]	Iw2,Ib,		"ENTER	%i,%I",		/* loony ENTER */
[0xc9]	RET,0,		"LEAVE",		/* bizarre LEAVE */
[0xca]	Iw,0,		"RETF	%i",
[0xcb]	RET,0,		"RETF",
[0xcc]	0,0,		"INT	3",
[0xcd]	Ib,0,		"INTB	%i",
[0xce]	0,0,		"INTO",
[0xcf]	0,0,		"IRET",
[0xd0]	RMOPB,0,	optabD0,
[0xd1]	RMOP,0,		optabD1,
[0xd2]	RMOPB,0,	optabD2,
[0xd3]	RMOP,0,		optabD3,
[0xd4]	OA,0,		"AAM",
[0xd5]	OA,0,		"AAD",
[0xd7]	0,0,		"XLAT",
[0xd8]	FRMOP,0,	optabD8,
[0xd9]	FRMEX,0,	optabD9,
[0xda]	FRMOP,0,	optabDA,
[0xdb]	FRMEX,0,	optabDB,
[0xdc]	FRMOP,0,	optabDC,
[0xdd]	FRMOP,0,	optabDD,
[0xde]	FRMOP,0,	optabDE,
[0xdf]	FRMOP,0,	optabDF,
[0xe0]	Jbs,0,		"LOOPNE	%p",
[0xe1]	Jbs,0,		"LOOPE	%p",
[0xe2]	Jbs,0,		"LOOP	%p",
[0xe3]	Jbs,0,		"JCXZ	%p",
[0xe4]	Ib,0,		"INB	%i,AL",
[0xe5]	Ib,0,		"IN%S	%i,%OAX",
[0xe6]	Ib,0,		"OUTB	AL,%i",
[0xe7]	Ib,0,		"OUT%S	%OAX,%i",
[0xe8]	Iwds,0,		"CALL	%p",
[0xe9]	Iwds,0,		"JMP	%p",
[0xea]	PTR,0,		"JMP	%d",
[0xeb]	Jbs,0,		"JMP	%p",
[0xec]	0,0,		"INB	DX,AL",
[0xed]	0,0,		"IN%S	DX,%OAX",
[0xee]	0,0,		"OUTB	AL,DX",
[0xef]	0,0,		"OUT%S	%OAX,DX",
[0xf0]	PRE,0,		"LOCK",
[0xf2]	OPRE,0,		"REPNE",
[0xf3]	OPRE,0,		"REP",
[0xf4]	0,0,		"HLT",
[0xf5]	0,0,		"CMC",
[0xf6]	RMOPB,0,	optabF6,
[0xf7]	RMOP,0,		optabF7,
[0xf8]	0,0,		"CLC",
[0xf9]	0,0,		"STC",
[0xfa]	0,0,		"CLI",
[0xfb]	0,0,		"STI",
[0xfc]	0,0,		"CLD",
[0xfd]	0,0,		"STD",
[0xfe]	RMOPB,0,	optabFE,
[0xff]	RMOP,0,		optabFF,
[0x100]	RM,0,		"MOVLQSX	%r,%e",
};
@

<<function igetc(x86)>>=
/*
 *  get a byte of the instruction
 */
static int
igetc(Map *map, Instr *ip, uchar *c)
{
    if(ip->n+1 > sizeof(ip->mem)){
        werrstr("instruction too long");
        return -1;
    }
    if (get1(map, ip->addr+ip->n, c, 1) < 0) {
        werrstr("can't read instruction: %r");
        return -1;
    }
    ip->mem[ip->n++] = *c;
    return 1;
}
@

<<function igets(x86)>>=
/*
 *  get two bytes of the instruction
 */
static int
igets(Map *map, Instr *ip, ushort *sp)
{
    uchar c;
    ushort s;

    if (igetc(map, ip, &c) < 0)
        return -1;
    s = c;
    if (igetc(map, ip, &c) < 0)
        return -1;
    s |= (c<<8);
    *sp = s;
    return 1;
}
@
% >>

<<function igetl(x86)>>=
/*
 *  get 4 bytes of the instruction
 */
static int
igetl(Map *map, Instr *ip, ulong *lp)
{
    ushort s;
    long	l;

    if (igets(map, ip, &s) < 0)
        return -1;
    l = s;
    if (igets(map, ip, &s) < 0)
        return -1;
    l |= (s<<16);
    *lp = l;
    return 1;
}
@

% >>

<<function igetq(x86)>>=
/*
 *  get 8 bytes of the instruction
 */
static int
igetq(Map *map, Instr *ip, vlong *qp)
{
    ulong	l;
    uvlong q;

    if (igetl(map, ip, &l) < 0)
        return -1;
    q = l;
    if (igetl(map, ip, &l) < 0)
        return -1;
    q |= ((uvlong)l<<32);
    *qp = q;
    return 1;
}
@

% >>

<<function getdisp(x86)>>=
static int
getdisp(Map *map, Instr *ip, int mod, int rm, int code, int pcrel)
{
    uchar c;
    ushort s;

    if (mod > 2)
        return 1;
    if (mod == 1) {
        if (igetc(map, ip, &c) < 0)
            return -1;
        if (c&0x80)
            ip->disp = c|0xffffff00;
        else
            ip->disp = c&0xff;
    } else if (mod == 2 || rm == code) {
        if (ip->asize == 'E') {
            if (igetl(map, ip, &ip->disp) < 0)
                return -1;
            if (mod == 0)
                ip->rip = pcrel;
        } else {
            if (igets(map, ip, &s) < 0)
                return -1;
            if (s&0x8000)
                ip->disp = s|0xffff0000;
            else
                ip->disp = s;
        }
        if (mod == 0)
            ip->base = -1;
    }
    return 1;
}
@

<<function modrm(x86)>>=
static int
modrm(Map *map, Instr *ip, uchar c)
{
    uchar rm, mod;

    mod = (c>>6)&3;
    rm = c&7;
    ip->mod = mod;
    ip->base = rm;
    ip->reg = (c>>3)&7;
    ip->rip = 0;
    if (mod == 3)			/* register */
        return 1;
    if (ip->asize == 0) {		/* 16-bit mode */
        switch(rm) {
        case 0:
            ip->base = BX; ip->index = SI;
            break;
        case 1:
            ip->base = BX; ip->index = DI;
            break;
        case 2:
            ip->base = BP; ip->index = SI;
            break;
        case 3:
            ip->base = BP; ip->index = DI;
            break;
        case 4:
            ip->base = SI;
            break;
        case 5:
            ip->base = DI;
            break;
        case 6:
            ip->base = BP;
            break;
        case 7:
            ip->base = BX;
            break;
        default:
            break;
        }
        return getdisp(map, ip, mod, rm, 6, 0);
    }
    if (rm == 4) {	/* scummy sib byte */
        if (igetc(map, ip, &c) < 0)
            return -1;
        ip->ss = (c>>6)&0x03;
        ip->index = (c>>3)&0x07;
        if (ip->index == 4)
            ip->index = -1;
        ip->base = c&0x07;
        return getdisp(map, ip, mod, ip->base, 5, 0);
    }
    return getdisp(map, ip, mod, rm, 5, ip->amd64);
}
@

<<function mkinstr(x86)>>=
static Optable *
mkinstr(Map *map, Instr *ip, uvlong pc)
{
    int i, n, norex;
    uchar c;
    ushort s;
    Optable *op, *obase;
    char buf[128];

    memset(ip, 0, sizeof(*ip));
    norex = 1;
    ip->base = -1;
    ip->index = -1;
    if(asstype == AI8086)
        ip->osize = 'W';
    else {
        ip->osize = 'L';
        ip->asize = 'E';
        ip->amd64 = asstype != AI386;
        norex = 0;
    }
    ip->addr = pc;
    if (igetc(map, ip, &c) < 0)
        return 0;
    obase = optable;
newop:
    if(ip->amd64 && !norex){
        if(c >= 0x40 && c <= 0x4f) {
            ip->rex = c;
            if(igetc(map, ip, &c) < 0)
                return 0;
        }
        if(c == 0x63){
            op = &obase[0x100];	/* MOVLQSX */
            goto hack;
        }
    }
    op = &obase[c];
hack:
    if (op->proto == 0) {
badop:
        n = snprint(buf, sizeof(buf), "opcode: ??");
        for (i = 0; i < ip->n && n < sizeof(buf)-3; i++, n+=2)
            _hexify(buf+n, ip->mem[i], 1);
        strcpy(buf+n, "??");
        werrstr(buf);
        return 0;
    }
    for(i = 0; i < 2 && op->operand[i]; i++) {
        switch(op->operand[i]) {
        case Ib:	/* 8-bit immediate - (no sign extension)*/
            if (igetc(map, ip, &c) < 0)
                return 0;
            ip->imm = c&0xff;
            ip->imm64 = ip->imm;
            break;
        case Jbs:	/* 8-bit jump immediate (sign extended) */
            if (igetc(map, ip, &c) < 0)
                return 0;
            if (c&0x80)
                ip->imm = c|0xffffff00;
            else
                ip->imm = c&0xff;
            ip->imm64 = (long)ip->imm;
            ip->jumptype = Jbs;
            break;
        case Ibs:	/* 8-bit immediate (sign extended) */
            if (igetc(map, ip, &c) < 0)
                return 0;
            if (c&0x80)
                if (ip->osize == 'L')
                    ip->imm = c|0xffffff00;
                else
                    ip->imm = c|0xff00;
            else
                ip->imm = c&0xff;
            ip->imm64 = (long)ip->imm;
            break;
        case Iw:	/* 16-bit immediate -> imm */
            if (igets(map, ip, &s) < 0)
                return 0;
            ip->imm = s&0xffff;
            ip->imm64 = ip->imm;
            ip->jumptype = Iw;
            break;
        case Iw2:	/* 16-bit immediate -> in imm2*/
            if (igets(map, ip, &s) < 0)
                return 0;
            ip->imm2 = s&0xffff;
            break;
        case Iwd:	/* Operand-sized immediate (no sign extension unless 64 bits)*/
            if (ip->osize == 'L') {
                if (igetl(map, ip, &ip->imm) < 0)
                    return 0;
                ip->imm64 = ip->imm;
                if(ip->rex&REXW && (ip->imm & (1<<31)) != 0)
                    ip->imm64 |= (vlong)~0 << 32;
            } else {
                if (igets(map, ip, &s)< 0)
                    return 0;
                ip->imm = s&0xffff;
                ip->imm64 = ip->imm;
            }
            break;
        case Iwdq:	/* Operand-sized immediate, possibly big */
            if (ip->osize == 'L') {
                if (igetl(map, ip, &ip->imm) < 0)
                    return 0;
                ip->imm64 = ip->imm;
                if (ip->rex & REXW) {
                    ulong l;
                    if (igetl(map, ip, &l) < 0)
                        return 0;
                    ip->imm64 |= (uvlong)l << 32;
                }
            } else {
                if (igets(map, ip, &s)< 0)
                    return 0;
                ip->imm = s&0xffff;
            }
            break;
        case Awd:	/* Address-sized immediate (no sign extension)*/
            if (ip->asize == 'E') {
                if (igetl(map, ip, &ip->imm) < 0)
                    return 0;
                /* TO DO: REX */
            } else {
                if (igets(map, ip, &s)< 0)
                    return 0;
                ip->imm = s&0xffff;
            }
            break;
        case Iwds:	/* Operand-sized immediate (sign extended) */
            if (ip->osize == 'L') {
                if (igetl(map, ip, &ip->imm) < 0)
                    return 0;
            } else {
                if (igets(map, ip, &s)< 0)
                    return 0;
                if (s&0x8000)
                    ip->imm = s|0xffff0000;
                else
                    ip->imm = s&0xffff;
            }
            ip->jumptype = Iwds;
            break;
        case OA:	/* literal 0x0a byte */
            if (igetc(map, ip, &c) < 0)
                return 0;
            if (c != 0x0a)
                goto badop;
            break;
        case R0:	/* base register must be R0 */
            if (ip->base != 0)
                goto badop;
            break;
        case R1:	/* base register must be R1 */
            if (ip->base != 1)
                goto badop;
            break;
        case RMB:	/* R/M field with byte register (/r)*/
            if (igetc(map, ip, &c) < 0)
                return 0;
            if (modrm(map, ip, c) < 0)
                return 0;
            ip->osize = 'B';
            break;
        case RM:	/* R/M field with register (/r) */
            if (igetc(map, ip, &c) < 0)
                return 0;
            if (modrm(map, ip, c) < 0)
                return 0;
            break;
        case RMOPB:	/* R/M field with op code (/digit) */
            if (igetc(map, ip, &c) < 0)
                return 0;
            if (modrm(map, ip, c) < 0)
                return 0;
            c = ip->reg;		/* secondary op code */
            obase = (Optable*)op->proto;
            ip->osize = 'B';
            goto newop;
        case RMOP:	/* R/M field with op code (/digit) */
            if (igetc(map, ip, &c) < 0)
                return 0;
            if (modrm(map, ip, c) < 0)
                return 0;
            obase = (Optable*)op->proto;
            if(ip->amd64 && obase == optab0F01 && c == 0xF8)
                return optab0F01F8;
            c = ip->reg;
            goto newop;
        case FRMOP:	/* FP R/M field with op code (/digit) */
            if (igetc(map, ip, &c) < 0)
                return 0;
            if (modrm(map, ip, c) < 0)
                return 0;
            if ((c&0xc0) == 0xc0)
                c = ip->reg+8;		/* 16 entry table */
            else
                c = ip->reg;
            obase = (Optable*)op->proto;
            goto newop;
        case FRMEX:	/* Extended FP R/M field with op code (/digit) */
            if (igetc(map, ip, &c) < 0)
                return 0;
            if (modrm(map, ip, c) < 0)
                return 0;
            if ((c&0xc0) == 0xc0)
                c = (c&0x3f)+8;		/* 64-entry table */
            else
                c = ip->reg;
            obase = (Optable*)op->proto;
            goto newop;
        case RMR:	/* R/M register only (mod = 11) */
            if (igetc(map, ip, &c) < 0)
                return 0;
            if ((c&0xc0) != 0xc0) {
                werrstr("invalid R/M register: %x", c);
                return 0;
            }
            if (modrm(map, ip, c) < 0)
                return 0;
            break;
        case RMM:	/* R/M register only (mod = 11) */
            if (igetc(map, ip, &c) < 0)
                return 0;
            if ((c&0xc0) == 0xc0) {
                werrstr("invalid R/M memory mode: %x", c);
                return 0;
            }
            if (modrm(map, ip, c) < 0)
                return 0;
            break;
        case PTR:	/* Seg:Displacement addr (ptr16:16 or ptr16:32) */
            if (ip->osize == 'L') {
                if (igetl(map, ip, &ip->disp) < 0)
                    return 0;
            } else {
                if (igets(map, ip, &s)< 0)
                    return 0;
                ip->disp = s&0xffff;
            }
            if (igets(map, ip, (ushort*)&ip->seg) < 0)
                return 0;
            ip->jumptype = PTR;
            break;
        case AUXMM:	/* Multi-byte op code; prefix determines table selection */
            if (igetc(map, ip, &c) < 0)
                return 0;
            obase = (Optable*)op->proto;
            switch (ip->opre) {
            case 0x66:	op = optab660F; break;
            case 0xF2:	op = optabF20F; break;
            case 0xF3:	op = optabF30F; break;
            default:	op = nil; break;
            }
            if(op != nil && op[c].proto != nil)
                obase = op;
            norex = 1;	/* no more rex prefixes */
            /* otherwise the optab entry captures it */
            goto newop;
        case AUX:	/* Multi-byte op code - Auxiliary table */
            obase = (Optable*)op->proto;
            if (igetc(map, ip, &c) < 0)
                return 0;
            goto newop;
        case OPRE:	/* Instr Prefix or media op */
            ip->opre = c;
            /* fall through */
        case PRE:	/* Instr Prefix */
            ip->prefix = (char*)op->proto;
            if (igetc(map, ip, &c) < 0)
                return 0;
            if (ip->opre && c == 0x0F)
                ip->prefix = 0;
            goto newop;
        case SEG:	/* Segment Prefix */
            ip->segment = (char*)op->proto;
            if (igetc(map, ip, &c) < 0)
                return 0;
            goto newop;
        case OPOVER:	/* Operand size override */
            ip->opre = c;
            ip->osize = 'W';
            if (igetc(map, ip, &c) < 0)
                return 0;
            if (c == 0x0F)
                ip->osize = 'L';
            else if (ip->amd64 && (c&0xF0) == 0x40)
                ip->osize = 'Q';
            goto newop;
        case ADDOVER:	/* Address size override */
            ip->asize = 0;
            if (igetc(map, ip, &c) < 0)
                return 0;
            goto newop;
        case JUMP:	/* mark instruction as JUMP or RET */
        case RET:
            ip->jumptype = op->operand[i];
            break;
        default:
            werrstr("bad operand type %d", op->operand[i]);
            return 0;
        }
    }
    return op;
}
@

<<function bprint(x86)>>=
static void
bprint(Instr *ip, char *fmt, ...)
{
    va_list arg;

    va_start(arg, fmt);
    ip->curr = vseprint(ip->curr, ip->end, fmt, arg);
    va_end(arg);
}
@

<<function ANAME(x86)>>=
/*
 *  if we want to call 16 bit regs AX,BX,CX,...
 *  and 32 bit regs EAX,EBX,ECX,... then
 *  change the defs of ANAME and ONAME to:
 *  #define	ANAME(ip)	((ip->asize == 'E' ? "E" : "")
 *  #define	ONAME(ip)	((ip)->osize == 'L' ? "E" : "")
 */
#define	ANAME(ip)	""
@

<<function ONAME(x86)>>=
#define	ONAME(ip)	""
@

<<global reg (linkers/libmach/8db.c)(x86)>>=
static char *reg[] =  {
[AX]	"AX",
[CX]	"CX",
[DX]	"DX",
[BX]	"BX",
[SP]	"SP",
[BP]	"BP",
[SI]	"SI",
[DI]	"DI",

    /* amd64 */
[R8]	"R8",
[R9]	"R9",
[R10]	"R10",
[R11]	"R11",
[R12]	"R12",
[R13]	"R13",
[R14]	"R14",
[R15]	"R15",
};
@

<<global breg(x86)>>=
static char *breg[] = { "AL", "CL", "DL", "BL", "AH", "CH", "DH", "BH" };
@

<<global breg64(x86)>>=
static char *breg64[] = { "AL", "CL", "DL", "BL", "SPB", "BPB", "SIB", "DIB",
    "R8B", "R9B", "R10B", "R11B", "R12B", "R13B", "R14B", "R15B" };
@

<<global sreg(x86)>>=
static char *sreg[] = { "ES", "CS", "SS", "DS", "FS", "GS" };
@

<<function plocal(x86)>>=
static void
plocal(Instr *ip)
{
    int ret;
    long offset;
    Symbol s;
    char *reg;

    offset = ip->disp;
    if (!findsym(ip->addr, CTEXT, &s) || !findlocal(&s, FRAMENAME, &s)) {
        bprint(ip, "%lux(SP)", offset);
        return;
    }

    if (s.value > ip->disp) {
        ret = getauto(&s, s.value-ip->disp-mach->szaddr, CAUTO, &s);
        reg = "(SP)";
    } else {
        offset -= s.value;
        ret = getauto(&s, offset, CPARAM, &s);
        reg = "(FP)";
    }
    if (ret)
        bprint(ip, "%s+", s.name);
    else
        offset = ip->disp;
    bprint(ip, "%lux%s", offset, reg);
}
@

<<function isjmp(x86)>>=
static int
isjmp(Instr *ip)
{
    switch(ip->jumptype){
    case Iwds:
    case Jbs:
    case JUMP:
        return 1;
    default:
        return 0;
    }
}
@

<<function issymref(x86)>>=
/*
 * This is too smart for its own good, but it really is nice
 * to have accurate translations when debugging, and it
 * helps us identify which code is different in binaries that
 * are changed on sources.
 */
static int
issymref(Instr *ip, Symbol *s, long w, long val)
{
    Symbol next, tmp;
    long isstring, size;

    if (isjmp(ip))
        return 1;
    if (s->class==CTEXT && w==0)
        return 1;
    if (s->class==CDATA) {
        /* use first bss symbol (or "end") rather than edata */
        if (s->name[0]=='e' && strcmp(s->name, "edata") == 0){
            if((s ->index >= 0 && globalsym(&tmp, s->index+1) && tmp.value==s->value)
            || (s->index > 0 && globalsym(&tmp, s->index-1) && tmp.value==s->value))
                *s = tmp;
        }
        if (w == 0)
            return 1;
        for (next=*s; next.value==s->value; next=tmp)
            if (!globalsym(&tmp, next.index+1))
                break;
        size = next.value - s->value;
        if (w >= size)
            return 0;
        if (w > size-w)
            w = size-w;
        /* huge distances are usually wrong except in .string */
        isstring = (s->name[0]=='.' && strcmp(s->name, ".string") == 0);
        if (w > 8192 && !isstring)
            return 0;
        /* medium distances are tricky - look for constants */
        /* near powers of two */
        if ((val&(val-1)) == 0 || (val&(val+1)) == 0)
            return 0;
        return 1;
    }
    return 0;
}
@

<<function immediate(x86)>>=
static void
immediate(Instr *ip, vlong val)
{
    Symbol s;
    long w;

    if (findsym(val, CANY, &s)) {		/* TO DO */
        w = val - s.value;
        if (w < 0)
            w = -w;
        if (issymref(ip, &s, w, val)) {
            if (w)
                bprint(ip, "%s+%lux(SB)", s.name, w);
            else
                bprint(ip, "%s(SB)", s.name);
            return;
        }
/*
        if (s.class==CDATA && globalsym(&s, s.index+1)) {
            w = s.value - val;
            if (w < 0)
                w = -w;
            if (w < 4096) {
                bprint(ip, "%s-%lux(SB)", s.name, w);
                return;
            }
        }
*/
    }
    if((ip->rex & REXW) == 0)
        bprint(ip, "%lux", (long)val);
    else
        bprint(ip, "%llux", val);
}
@

<<function pea(x86)>>=
static void
pea(Instr *ip)
{
    if (ip->mod == 3) {
        if (ip->osize == 'B')
            bprint(ip, (ip->rex & REXB? breg64: breg)[ip->base]);
        else if(ip->rex & REXB)
            bprint(ip, "%s%s", ANAME(ip), reg[ip->base+8]);
        else
            bprint(ip, "%s%s", ANAME(ip), reg[ip->base]);
        return;
    }
    if (ip->segment)
        bprint(ip, ip->segment);
    if (ip->asize == 'E' && ip->base == SP)
        plocal(ip);
    else {
        if (ip->base < 0)
            immediate(ip, ip->disp);
        else {
            bprint(ip, "%lux", ip->disp);
            if(ip->rip)
                bprint(ip, "(RIP)");
            bprint(ip,"(%s%s)", ANAME(ip), reg[ip->rex&REXB? ip->base+8: ip->base]);
        }
    }
    if (ip->index >= 0)
        bprint(ip,"(%s%s*%d)", ANAME(ip), reg[ip->rex&REXX? ip->index+8: ip->index], 1<<ip->ss);
}
@

<<function prinstr(x86)>>=
static void
prinstr(Instr *ip, char *fmt)
{
    vlong v;

    if (ip->prefix)
        bprint(ip, "%s ", ip->prefix);
    for (; *fmt && ip->curr < ip->end; fmt++) {
        if (*fmt != '%'){
            *ip->curr++ = *fmt;
            continue;
        }
        switch(*++fmt){
        case '%':
            *ip->curr++ = '%';
            break;
        case 'A':
            bprint(ip, "%s", ANAME(ip));
            break;
        case 'C':
            bprint(ip, "CR%d", ip->reg);
            break;
        case 'D':
            if (ip->reg < 4 || ip->reg == 6 || ip->reg == 7)
                bprint(ip, "DR%d",ip->reg);
            else
                bprint(ip, "???");
            break;
        case 'I':
            bprint(ip, "$");
            immediate(ip, ip->imm2);
            break;
        case 'O':
            bprint(ip,"%s", ONAME(ip));
            break;
        case 'i':
            bprint(ip, "$");
            v = ip->imm;
            if(ip->rex & REXW)
                v = ip->imm64;
            immediate(ip, v);
            break;
        case 'R':
            bprint(ip, "%s%s", ONAME(ip), reg[ip->rex&REXR? ip->reg+8: ip->reg]);
            break;
        case 'S':
            if(ip->osize == 'Q' || ip->osize == 'L' && ip->rex & REXW)
                bprint(ip, "Q");
            else
                bprint(ip, "%c", ip->osize);
            break;
        case 's':
            if(ip->opre == 0 || ip->opre == 0x66)
                bprint(ip, "P");
            else
                bprint(ip, "S");
            if(ip->opre == 0xf2 || ip->opre == 0x66)
                bprint(ip, "D");
            else
                bprint(ip, "S");
            break;
        case 'T':
            if (ip->reg == 6 || ip->reg == 7)
                bprint(ip, "TR%d",ip->reg);
            else
                bprint(ip, "???");
            break;
        case 'W':
            if (ip->osize == 'Q' || ip->osize == 'L' && ip->rex & REXW)
                bprint(ip, "CDQE");
            else if (ip->osize == 'L')
                bprint(ip,"CWDE");
            else
                bprint(ip, "CBW");
            break;
        case 'd':
            bprint(ip,"%ux:%lux",ip->seg,ip->disp);
            break;
        case 'm':
            if (ip->mod == 3 && ip->osize != 'B') {
                if(fmt[1] != '*'){
                    if(ip->opre != 0) {
                        bprint(ip, "X%d", ip->rex&REXB? ip->base+8: ip->base);
                        break;
                    }
                } else
                    fmt++;
                bprint(ip, "M%d", ip->base);
                break;
            }
            pea(ip);
            break;
        case 'e':
            pea(ip);
            break;
        case 'f':
            bprint(ip, "F%d", ip->base);
            break;
        case 'g':
            if (ip->reg < 6)
                bprint(ip,"%s",sreg[ip->reg]);
            else
                bprint(ip,"???");
            break;
        case 'p':
            /*
             * signed immediate in the ulong ip->imm.
             */
            v = (long)ip->imm;
            immediate(ip, v+ip->addr+ip->n);
            break;
        case 'r':
            if (ip->osize == 'B')
                bprint(ip,"%s", (ip->rex? breg64: breg)[ip->rex&REXR? ip->reg+8: ip->reg]);
            else
                bprint(ip, reg[ip->rex&REXR? ip->reg+8: ip->reg]);
            break;
        case 'w':
            if (ip->osize == 'Q' || ip->rex & REXW)
                bprint(ip, "CQO");
            else if (ip->osize == 'L')
                bprint(ip,"CDQ");
            else
                bprint(ip, "CWD");
            break;
        case 'M':
            if(ip->opre != 0)
                bprint(ip, "X%d", ip->rex&REXR? ip->reg+8: ip->reg);
            else
                bprint(ip, "M%d", ip->reg);
            break;
        case 'x':
            if (ip->mod == 3 && ip->osize != 'B') {
                bprint(ip, "X%d", ip->rex&REXB? ip->base+8: ip->base);
                break;
            }
            pea(ip);
            break;
        case 'X':
            bprint(ip, "X%d", ip->rex&REXR? ip->reg+8: ip->reg);
            break;
        default:
            bprint(ip, "%%%c", *fmt);
            break;
        }
    }
    *ip->curr = 0;		/* there's always room for 1 byte */
}
@

<<function i386inst>>=
static int
i386inst(Map *map, uvlong pc, char modifier, char *buf, int n)
{
    Instr instr;
    Optable *op;

    USED(modifier);
    op = mkinstr(map, &instr, pc);
    if (op == 0) {
        errstr(buf, n);
        return -1;
    }
    instr.curr = buf;
    instr.end = buf+n-1;
    prinstr(&instr, op->proto);
    return instr.n;
}
@

<<function i386das>>=
static int
i386das(Map *map, uvlong pc, char *buf, int n)
{
    Instr instr;
    int i;

    if (mkinstr(map, &instr, pc) == 0) {
        errstr(buf, n);
        return -1;
    }
    for(i = 0; i < instr.n && n > 2; i++) {
        _hexify(buf, instr.mem[i], 1);
        buf += 2;
        n -= 2;
    }
    *buf = 0;
    return instr.n;
}
@

<<function i386instlen>>=
static int
i386instlen(Map *map, uvlong pc)
{
    Instr i;

    if (mkinstr(map, &i, pc))
        return i.n;
    return -1;
}
@

<<function i386foll>>=
static int
i386foll(Map *map, uvlong pc, Rgetter rget, uvlong *foll)
{
    Instr i;
    Optable *op;
    ushort s;
    uvlong l, addr;
    vlong v;
    int n;

    op = mkinstr(map, &i, pc);
    if (!op)
        return -1;

    n = 0;

    switch(i.jumptype) {
    case RET:		/* RETURN or LEAVE */
    case Iw:		/* RETURN */
        if (strcmp(op->proto, "LEAVE") == 0) {
            if (geta(map, (*rget)(map, "BP"), &l) < 0)
                return -1;
        } else if (geta(map, (*rget)(map, mach->sp), &l) < 0)
            return -1;
        foll[0] = l;
        return 1;
    case Iwds:		/* pc relative JUMP or CALL*/
    case Jbs:		/* pc relative JUMP or CALL */
        v = (long)i.imm;
        foll[0] = pc+v+i.n;
        n = 1;
        break;
    case PTR:		/* seg:displacement JUMP or CALL */
        foll[0] = (i.seg<<4)+i.disp;
        return 1;
    case JUMP:		/* JUMP or CALL EA */

        if(i.mod == 3) {
            foll[0] = (*rget)(map, reg[i.rex&REXB? i.base+8: i.base]);
            return 1;
        }
            /* calculate the effective address */
        addr = i.disp;
        if (i.base >= 0) {
            if (geta(map, (*rget)(map, reg[i.rex&REXB? i.base+8: i.base]), &l) < 0)
                return -1;
            addr += l;
        }
        if (i.index >= 0) {
            if (geta(map, (*rget)(map, reg[i.rex&REXX? i.index+8: i.index]), &l) < 0)
                return -1;
            addr += l*(1<<i.ss);
        }
            /* now retrieve a seg:disp value at that address */
        if (get2(map, addr, &s) < 0)			/* seg */
            return -1;
        foll[0] = s<<4;
        addr += 2;
        if (i.asize == 'L') {
            if (geta(map, addr, &l) < 0)		/* disp32 */
                return -1;
            foll[0] += l;
        } else {					/* disp16 */
            if (get2(map, addr, &s) < 0)
                return -1;
            foll[0] += s;
        }
        return 1;
    default:
        break;
    }		
    if (strncmp(op->proto,"JMP", 3) == 0 || strncmp(op->proto,"CALL", 4) == 0)
        return 1;
    foll[n++] = pc+i.n;
    return n;
}
@


%-------------------------------------------------------------

<<linkers/libmach/8db.c>>=
#include <u.h>
#include <libc.h>
#include <bio.h>
#include <mach.h>

/*
 * i386-specific debugger interface
 * also amd64 extensions
 */

static	char	*i386excep(Map*, Rgetter);

static	int	i386trace(Map*, uvlong, uvlong, uvlong, Tracer);
static	uvlong	i386frame(Map*, uvlong, uvlong, uvlong, uvlong);
static	int	i386foll(Map*, uvlong, Rgetter, uvlong*);
static	int	i386inst(Map*, uvlong, char, char*, int);
static	int	i386das(Map*, uvlong, char*, int);
static	int	i386instlen(Map*, uvlong);

<<global STARTSYM(x86)>>
<<global PROFSYM(x86)>>
<<global FRAMENAME(x86)>>
<<global excname(x86)>>

<<global i386mach>>

<<function i386excep>>

<<function i386trace>>

<<function i386frame>>

/* I386/486 - Disassembler and related functions */

/*
 *  an instruction
 */
typedef struct Instr Instr;
<<struct Instr(x86)>>

    /* 386 register (ha!) set */
<<enum _anon_ (linkers/libmach/8db.c)(x86)>>

    /* amd64 rex extension byte */
<<enum _anon_ (linkers/libmach/8db.c)2(x86)>>
    
    /* Operand Format codes */
/*
%A	-	address size register modifier (!asize -> 'E')
%C	-	Control register CR0/CR1/CR2
%D	-	Debug register DR0/DR1/DR2/DR3/DR6/DR7
%I	-	second immediate operand
%O	-	Operand size register modifier (!osize -> 'E')
%T	-	Test register TR6/TR7
%S	-	size code ('W' or 'L')
%W	-	Weird opcode: OSIZE == 'W' => "CBW"; else => "CWDE"
%d	-	displacement 16-32 bits
%e	-	effective address - Mod R/M value
%f	-	floating point register F0-F7 - from Mod R/M register
%g	-	segment register
%i	-	immediate operand 8-32 bits
%p	-	PC-relative - signed displacement in immediate field
%r	-	Reg from Mod R/M
%w	-	Weird opcode: OSIZE == 'W' => "CWD"; else => "CDQ"
*/

typedef struct Optable Optable;
<<struct Optable(x86)>>
    /* Operand decoding codes */
<<enum _anon_ (linkers/libmach/8db.c)3(x86)>>
    
<<global optab0F00(x86)>>

<<global optab0F01(x86)>>

<<global optab0F01F8(x86)>>

/* 0F71 */
/* 0F72 */
<<global optab0FAE(x86)>>

/* 0F18 */
<<global optab0FBA(x86)>>

<<global optab0F0F(x86)>>

<<global optab0FC7(x86)>>

<<global optab660F71(x86)>>

<<global optab660F72(x86)>>

<<global optab660F73(x86)>>

<<global optab660F(x86)>>

<<global optabF20F(x86)>>

<<global optabF30F(x86)>>

<<global optab0F(x86)>>

<<global optab80(x86)>>

<<global optab81(x86)>>

<<global optab83(x86)>>

<<global optabC0(x86)>>

<<global optabC1(x86)>>

<<global optabD0(x86)>>

<<global optabD1(x86)>>

<<global optabD2(x86)>>

<<global optabD3(x86)>>

<<global optabD8(x86)>>
<<global optabD9(x86)>>

<<global optabDA(x86)>>

<<global optabDB(x86)>>

<<global optabDC(x86)>>

<<global optabDD(x86)>>

<<global optabDE(x86)>>

<<global optabDF(x86)>>

<<global optabF6(x86)>>

<<global optabF7(x86)>>

<<global optabFE(x86)>>

<<global optabFF(x86)>>

<<global optable(x86)>>

<<function igetc(x86)>>

<<function igets(x86)>>

<<function igetl(x86)>>

<<function igetq(x86)>>

<<function getdisp(x86)>>

<<function modrm(x86)>>

<<function mkinstr(x86)>>

#pragma	varargck	argpos	bprint		2

<<function bprint(x86)>>

<<function ANAME(x86)>>
<<function ONAME(x86)>>

<<global reg (linkers/libmach/8db.c)(x86)>>

<<global breg(x86)>>
<<global breg64(x86)>>
<<global sreg(x86)>>

<<function plocal(x86)>>

<<function isjmp(x86)>>

<<function issymref(x86)>>

<<function immediate(x86)>>

<<function pea(x86)>>

<<function prinstr(x86)>>

<<function i386inst>>

<<function i386das>>

<<function i386instlen>>

<<function i386foll>>
@


