\section{[[include/]]}

\subsection*{[[include/a.out.h]]}

<<function _MAGIC>>=
#define	_MAGIC(f, b)	((f)|((((4*(b))+0)*(b))+7))
@

<<constant I_MAGIC>>=
#define	I_MAGIC		_MAGIC(0, 11)		/* intel 386 */
@

<<constant E_MAGIC>>=
#define	E_MAGIC		_MAGIC(0, 20)		/* arm */
@

<<constant HDR_MAGIC>>=
#define HDR_MAGIC	0x00008000		/* header expansion */
@
% for 64 bit architecture


%#define	A_MAGIC		_MAGIC(0, 8)		/* 68020 (retired) */
%#define	J_MAGIC		_MAGIC(0, 12)		/* intel 960 (retired) */
%#define	K_MAGIC		_MAGIC(0, 13)		/* sparc */
%#define	V_MAGIC		_MAGIC(0, 16)		/* mips 3000 BE */
%#define	X_MAGIC		_MAGIC(0, 17)		/* att dsp 3210 (retired) */
%#define	M_MAGIC		_MAGIC(0, 18)		/* mips 4000 BE */
%#define	D_MAGIC		_MAGIC(0, 19)		/* amd 29000 (retired) */
%#define	Q_MAGIC		_MAGIC(0, 21)		/* powerpc */
%#define	N_MAGIC		_MAGIC(0, 22)		/* mips 4000 LE */
%#define	L_MAGIC		_MAGIC(0, 23)		/* dec alpha (retired) */
%#define	P_MAGIC		_MAGIC(0, 24)		/* mips 3000 LE */
%#define	U_MAGIC		_MAGIC(0, 25)		/* sparc64 (retired) */

%#define	S_MAGIC		_MAGIC(HDR_MAGIC, 26)	/* amd64 */
%#define	T_MAGIC		_MAGIC(HDR_MAGIC, 27)	/* powerpc64 */
%#define	R_MAGIC		_MAGIC(HDR_MAGIC, 28)	/* arm64 */



<<constant MIN_MAGIC>>=
#define	MIN_MAGIC	11
@

<<constant MAX_MAGIC>>=
#define	MAX_MAGIC	20			/* <= 90 */
@

<<constant DYN_MAGIC>>=
#define	DYN_MAGIC	0x80000000		/* dlm */
@

<<struct Sym a.out.h>>=
struct	Sym
{
    vlong	value;
    uint	sig;
    char	type;
    char	*name;
};
@


%-------------------------------------------------------------

<<include/a.out.h>>=
<<struct Exec>>
typedef	struct	Exec	Exec;

<<constant HDR_MAGIC>>

<<function _MAGIC>>

<<constant I_MAGIC>>
<<constant E_MAGIC>>

<<constant MIN_MAGIC>>
<<constant MAX_MAGIC>>

<<constant DYN_MAGIC>>

typedef	struct	Sym	Sym;
<<struct Sym a.out.h>>
@

\subsection*{[[include/elf.h]]}

<<enum _anon_ (elf.h)>>=
/* was in /sys/src/libmach/elf.h */
enum {
    /* Ehdr codes */
    MAG0 = 0,		/* ident[] indexes */
    MAG1 = 1,
    MAG2 = 2,
    MAG3 = 3,
    CLASS = 4,
    DATA = 5,
    VERSION = 6,

    ELFCLASSNONE = 0,	/* ident[CLASS] */
    ELFCLASS32 = 1,
    ELFCLASS64 = 2,
    ELFCLASSNUM = 3,

    ELFDATANONE = 0,	/* ident[DATA] */
    ELFDATA2LSB = 1,
    ELFDATA2MSB = 2,
    ELFDATANUM = 3,

    NOETYPE = 0,		/* type */
    REL = 1,
    EXEC = 2,
    DYN = 3,
    CORE = 4,

    NONE = 0,		/* machine */
    M32 = 1,		/* AT&T WE 32100 */
    SPARC = 2,		/* Sun SPARC */
    I386 = 3,		/* Intel 80386 */
    M68K = 4,		/* Motorola 68000 */
    M88K = 5,		/* Motorola 88000 */
    I486 = 6,		/* Intel 80486 */
    I860 = 7,		/* Intel i860 */
    MIPS = 8,		/* Mips R2000 */
    S370 = 9,		/* Amdhal	*/
    MIPSR4K = 10,	/* Mips R4000 */
    SPARC64 = 18,	/* Sun SPARC v9 */
    POWER = 20,		/* PowerPC */
    POWER64 = 21,	/* PowerPC64 */
    ARM = 40,		/* ARM */
    AMD64 = 62,		/* Amd64 */
    ARM64 = 183,	/* ARM64 */

    NO_VERSION = 0,		/* version, ident[VERSION] */
    CURRENT = 1,

    /* Phdr Codes */
    NOPTYPE = 0,		/* type */
    PT_LOAD = 1, /* also LOAD */
    DYNAMIC = 2,
    INTERP = 3,
    NOTE = 4,
    SHLIB = 5,
    PHDR = 6,

    R = 0x4,		/* flags */
    W = 0x2,
    X = 0x1,

    /* Shdr Codes */
    Progbits = 1,	/* section types */
    Strtab = 3,
    Nobits = 8,

    SwriteElf = 1,	/* section attributes (flags) */
    Salloc = 2,
    Sexec = 4,
};
@

<<struct Ehdr>>=
/*
 *	Definitions needed for accessing ELF headers
 */
struct Ehdr {
    uchar	ident[16];	/* ident bytes */
    ushort	type;		/* file type */
    ushort	machine;	/* target machine */
    int	version;	/* file version */
    ulong	elfentry;	/* start address */
    ulong	phoff;		/* phdr file offset */
    ulong	shoff;		/* shdr file offset */
    int	flags;		/* file flags */
    ushort	ehsize;		/* sizeof ehdr */
    ushort	phentsize;	/* sizeof phdr */
    ushort	phnum;		/* number phdrs */
    ushort	shentsize;	/* sizeof shdr */
    ushort	shnum;		/* number shdrs */
    ushort	shstrndx;	/* shdr string index */
};
@


<<struct Phdr>>=
struct Phdr {
    int	type;		/* entry type */
    ulong	offset;		/* file offset */
    ulong	vaddr;		/* virtual address */
    ulong	paddr;		/* physical address */
    int	filesz;		/* file size */
    ulong	memsz;		/* memory size */
    int	flags;		/* entry flags */
    int	align;		/* memory/file alignment */
};
@

<<struct Shdr>>=
struct Shdr {
    ulong	name;		/* section name */
    ulong	type;		/* SHT_... */
    ulong	flags;		/* SHF_... */
    ulong	addr;		/* virtual address */
    ulong	offset;		/* file offset */
    ulong	size;		/* section size */
    ulong	link;		/* misc info */
    ulong	info;		/* misc info */
    ulong	addralign;	/* memory alignment */
    ulong	entsize;	/* entry size if table */
};
@

<<constant ELF_MAG>>=
#define	ELF_MAG		((0x7f<<24) | ('E'<<16) | ('L'<<8) | 'F')
@


%struct E64hdr {
%    u8int	ident[16];	/* ident bytes */
%    u16int	type;		/* file type */
%    u16int	machine;	/* target machine */
%    u32int	version;	/* file version */
%    u64int	elfentry;	/* start address */
%    u64int	phoff;		/* phdr file offset */
%    u64int	shoff;		/* shdr file offset */
%    u32int	flags;		/* file flags */
%    u16int	ehsize;		/* sizeof ehdr */
%    u16int	phentsize;	/* sizeof phdr */
%    u16int	phnum;		/* number phdrs */
%    u16int	shentsize;	/* sizeof shdr */
%    u16int	shnum;		/* number shdrs */
%    u16int	shstrndx;	/* shdr string index */
%};



%struct P64hdr {
%    u32int	type;		/* entry type */
%    u32int	flags;		/* entry flags */
%    u64int	offset;		/* file offset */
%    u64int	vaddr;		/* virtual address */
%    u64int	paddr;		/* physical address */
%    u64int	filesz;		/* file size */
%    u64int	memsz;		/* memory size */
%    u64int	align;		/* memory/file alignment */
%}; 



%struct S64hdr {
%    u32int	name;		/* section name */
%    u32int	type;		/* SHT_... */
%    u64int	flags;		/* SHF_... */
%    u64int	addr;		/* virtual address */
%    u64int	offset;		/* file offset */
%    u64int	size;		/* section size */
%    u32int	link;		/* misc info */
%    u32int	info;		/* misc info */
%    u64int	addralign;	/* memory alignment */
%    u64int	entsize;	/* entry size if table */
%};



%-------------------------------------------------------------

<<include/exec/elf.h>>=

<<enum _anon_ (elf.h)>>

typedef struct Ehdr Ehdr;
typedef struct Phdr Phdr;
typedef struct Shdr Shdr;

<<struct Ehdr>>

<<struct Phdr>>

<<struct Shdr>>

<<constant ELF_MAG>>
@



\subsection*{[[include/ar.h]]}

%-------------------------------------------------------------

<<include/ar.h>>=
<<constant ARMAG>>
<<constant SARMAG>>

<<constant ARFMAG>>
<<constant SARNAME>>

<<struct ar_hdr>>
<<constant SAR_HDR>>
@


\subsection*{[[include/bootexec.h]]}

<<struct coffsect>>=
struct coffsect
{
    char	name[8];
    ulong	phys;
    ulong	virt;
    ulong	size;
    ulong	fptr;
    ulong	fptrreloc;
    ulong	fptrlineno;
    ulong	nrelocnlineno;
    ulong	flags;
};
@

<<struct i386exec>>=
struct i386exec
{
    struct	i386coff{
        ulong	isectmagic;
        ulong	itime;
        ulong	isyms;
        ulong	insyms;
        ulong	iflags;
    };
    struct	i386hdr{
        ulong	imagic;
        ulong	itextsize;
        ulong	idatasize;
        ulong	ibsssize;
        ulong	ientry;
        ulong	itextstart;
        ulong	idatastart;
    };
    struct coffsect itexts;
    struct coffsect idatas;
    struct coffsect ibsss;
    struct coffsect icomments;
};
@


%-------------------------------------------------------------

<<include/bootexec.h>>=
<<struct coffsect>>

<<struct i386exec>>
@



\section{[[linkers/misc/]]}

\subsection*{[[linkers/misc/ar.c]]}

<<struct Arsymref>>=
typedef struct	Arsymref
{
    char	*name;
    int	type;
    int	len;
    vlong	offset;
    struct	Arsymref *next;
} Arsymref;
@

<<struct Armember>>=
typedef struct	Armember	/* Temp file entry - one per archive member */
{
    struct Armember	*next;
    struct ar_hdr	hdr;
    long		size;
    long		date;
    void		*member;
} Armember;
@

<<struct Arfile>>=
typedef	struct Arfile		/* Temp file control block - one per tempfile */
{
    int	paged;		/* set when some data paged to disk */
    char	*fname;		/* paging file name */
    int	fd;		/* paging file descriptor */
    vlong	size;
    Armember *head;		/* head of member chain */
    Armember *tail;		/* tail of member chain */
    Arsymref *sym;		/* head of defined symbol chain */
} Arfile;
@

<<struct Hashchain>>=
typedef struct Hashchain
{
    char	*name;
    struct Hashchain *next;
} Hashchain;
@

<<constant NHASH>>=
#define	NHASH	1024
@

<<function HEADER_IO>>=
/*
 *	macro to portably read/write archive header.
 *	'cmd' is read/write/Bread/Bwrite, etc.
 */
#define	HEADER_IO(cmd, f, h)	cmd(f, h.name, sizeof(h.name)) != sizeof(h.name)\
                || cmd(f, h.date, sizeof(h.date)) != sizeof(h.date)\
                || cmd(f, h.uid, sizeof(h.uid)) != sizeof(h.uid)\
                || cmd(f, h.gid, sizeof(h.gid)) != sizeof(h.gid)\
                || cmd(f, h.mode, sizeof(h.mode)) != sizeof(h.mode)\
                || cmd(f, h.size, sizeof(h.size)) != sizeof(h.size)\
                || cmd(f, h.fmag, sizeof(h.fmag)) != sizeof(h.fmag)
@

<<global man>>=
char	*man =		"mrxtdpq";
@

<<global opt>>=
char	*opt =		"uvnbailo";
@

<<global artemp>>=
char	artemp[] =	"/tmp/vXXXXX";
@

<<global movtemp>>=
char	movtemp[] =	"/tmp/v1XXXXX";
@

<<global tailtemp>>=
char	tailtemp[] =	"/tmp/v2XXXXX";
@

<<global symdef>>=
char	symdef[] =	"__.SYMDEF";
@

<<global aflag>>=
int	aflag;				/* command line flags */
@

<<global bflag>>=
static int	bflag;
@

<<global cflag>>=
int	cflag;
@

<<global oflag>>=
int	oflag;
@

<<global uflag>>=
int	uflag;
@

<<global vflag>>=
int	vflag;
@

<<global allobj>>=
int	allobj = 1;			/* set when all members are object files of the same type */
@

<<global symdefsize>>=
int	symdefsize;			/* size of symdef file */
@

<<global dupfound>>=
int	dupfound;			/* flag for duplicate symbol */
@

<<global hash>>=
Hashchain	*hash[NHASH];		/* hash table of text symbols */
@

<<constant ARNAMESIZE>>=
#define	ARNAMESIZE	sizeof(astart->tail->hdr.name)
@

<<global poname>>=
char	poname[ARNAMESIZE+1];		/* name of pivot member */
@

<<global file>>=
char	*file;				/* current file or member being worked on */
@

<<global bout>>=
Biobuf	bout;
@

<<global bar>>=
Biobuf bar;
@

<<global comfun>>=
void	(*comfun)(char*, int, char**);
@

<<function main>>=
void
main(int argc, char *argv[])
{
    char *cp;

    Binit(&bout, 1, OWRITE);
    if(argc < 3)
        usage();
    for (cp = argv[1]; *cp; cp++) {
        switch(*cp) {
        case 'a':	aflag = 1;	break;
        case 'b':	bflag = 1;	break;
        case 'c':	cflag = 1;	break;
        case 'd':	setcom(dcmd);	break;
        case 'i':	bflag = 1;	break;
        case 'l':
                strcpy(artemp, "vXXXXX");
                strcpy(movtemp, "v1XXXXX");
                strcpy(tailtemp, "v2XXXXX");
                break;
        case 'm':	setcom(mcmd);	break;
        case 'o':	oflag = 1;	break;
        case 'p':	setcom(pcmd);	break;
        case 'q':	setcom(qcmd);	break;
        case 'r':	setcom(rcmd);	break;
        case 't':	setcom(tcmd);	break;
        case 'u':	uflag = 1;	break;
        case 'v':	vflag = 1;	break;
        case 'x':	setcom(xcmd);	break;
        default:
            fprint(2, "ar: bad option `%c'\n", *cp);
            exits("error");
        }
    }
    if (aflag && bflag) {
        fprint(2, "ar: only one of 'a' and 'b' can be specified\n");
        usage();
    }
    if(aflag || bflag) {
        trim(argv[2], poname, sizeof(poname));
        argv++;
        argc--;
        if(argc < 3)
            usage();
    }
    if(comfun == 0) {
        if(uflag == 0) {
            fprint(2, "ar: one of [%s] must be specified\n", man);
            usage();
        }
        setcom(rcmd);
    }
    cp = argv[2];
    argc -= 3;
    argv += 3;
    (*comfun)(cp, argc, argv);	/* do the command */
    cp = 0;
    while (argc--) {
        if (*argv) {
            fprint(2, "ar: %s not found\n", *argv);
            cp = "error";
        }
        argv++;
    }
    exits(cp);
}
@

<<function setcom>>=
/*
 *	select a command
 */
void
setcom(void (*fun)(char *, int, char**))
{

    if(comfun != 0) {
        fprint(2, "ar: only one of [%s] allowed\n", man);
        usage();
    }
    comfun = fun;
}
@

<<function rcmd>>=
/*
 *	perform the 'r' and 'u' commands
 */
void
rcmd(char *arname, int count, char **files)
{
    int fd;
    int i;
    Arfile *ap;
    Armember *bp;
    Dir *d;
    Biobuf *bfile;

    fd = openar(arname, ORDWR, 1);
    if (fd >= 0) {
        Binit(&bar, fd, OREAD);
        Bseek(&bar,seek(fd,0,1), 1);
    }
    astart = newtempfile(artemp);
    ap = astart;
    aend = 0;
    for(i = 0; fd >= 0; i++) {
        bp = getdir(&bar);
        if (!bp)
            break;
        if (bamatch(file, poname)) {		/* check for pivot */
            aend = newtempfile(tailtemp);
            ap = aend;
        }
            /* pitch symdef file */
        if (i == 0 && strcmp(file, symdef) == 0) {
            skip(&bar, bp->size);
            continue;
        }
        if (count && !match(count, files)) {
            scanobj(&bar, ap, bp->size);
            arcopy(&bar, ap, bp);
            continue;
        }
        bfile = Bopen(file, OREAD);
        if (!bfile) {
            if (count != 0)
                fprint(2, "ar: cannot open %s\n", file);
            scanobj(&bar, ap, bp->size);
            arcopy(&bar, ap, bp);
            continue;
        }
        d = dirfstat(Bfildes(bfile));
        if(d == nil)
            fprint(2, "ar: cannot stat %s: %r\n", file);
        if (uflag && (d==nil || d->mtime <= bp->date)) {
            scanobj(&bar, ap, bp->size);
            arcopy(&bar, ap, bp);
            Bterm(bfile);
            free(d);
            continue;
        }
        mesg('r', file);
        skip(&bar, bp->size);
        scanobj(bfile, ap, d->length);
        free(d);
        armove(bfile, ap, bp);
        Bterm(bfile);
    }
    if(fd >= 0)
        close(fd);
        /* copy in remaining files named on command line */
    for (i = 0; i < count; i++) {
        file = files[i];
        if(file == 0)
            continue;
        files[i] = 0;
        bfile = Bopen(file, OREAD);
        if (!bfile)
            fprint(2, "ar: %s cannot open\n", file);
        else {
            mesg('a', file);
            d = dirfstat(Bfildes(bfile));
            if (d == nil)
                fprint(2, "can't stat %s\n", file);
            else {
                scanobj(bfile, astart, d->length);
                armove(bfile, astart, newmember());
                free(d);
            }
            Bterm(bfile);
        }
    }
    if(fd < 0 && !cflag)
        install(arname, astart, 0, aend, 1);	/* issue 'creating' msg */
    else
        install(arname, astart, 0, aend, 0);
}
@

<<function dcmd>>=
void
dcmd(char *arname, int count, char **files)
{
    Armember *bp;
    int fd, i;

    if (!count)
        return;
    fd = openar(arname, ORDWR, 0);
    Binit(&bar, fd, OREAD);
    Bseek(&bar,seek(fd,0,1), 1);
    astart = newtempfile(artemp);
    for (i = 0; bp = getdir(&bar); i++) {
        if(match(count, files)) {
            mesg('d', file);
            skip(&bar, bp->size);
            if (strcmp(file, symdef) == 0)
                allobj = 0;
        } else if (i == 0 && strcmp(file, symdef) == 0)
                skip(&bar, bp->size);
        else {
            scanobj(&bar, astart, bp->size);
            arcopy(&bar, astart, bp);
        }
    }
    close(fd);
    install(arname, astart, 0, 0, 0);
}
@

<<function xcmd>>=
void
xcmd(char *arname, int count, char **files)
{
    int fd, f, mode, i;
    Armember *bp;
    Dir dx;

    fd = openar(arname, OREAD, 0);
    Binit(&bar, fd, OREAD);
    Bseek(&bar,seek(fd,0,1), 1);
    i = 0;
    while (bp = getdir(&bar)) {
        if(count == 0 || match(count, files)) {
            mode = strtoul(bp->hdr.mode, 0, 8) & 0777;
            f = create(file, OWRITE, mode);
            if(f < 0) {
                fprint(2, "ar: %s cannot create\n", file);
                skip(&bar, bp->size);
            } else {
                mesg('x', file);
                arcopy(&bar, 0, bp);
                if (write(f, bp->member, bp->size) < 0)
                    wrerr();
                if(oflag) {
                    nulldir(&dx);
                    dx.atime = bp->date;
                    dx.mtime = bp->date;
                    if(dirwstat(file, &dx) < 0)
                        perror(file);
                }
                free(bp->member);
                close(f);
            }
            free(bp);
            if (count && ++i >= count)
                break;
        } else {
            skip(&bar, bp->size);
            free(bp);
        }
    }
    close(fd);
}
@

<<function pcmd>>=
void
pcmd(char *arname, int count, char **files)
{
    int fd;
    Armember *bp;

    fd = openar(arname, OREAD, 0);
    Binit(&bar, fd, OREAD);
    Bseek(&bar,seek(fd,0,1), 1);
    while(bp = getdir(&bar)) {
        if(count == 0 || match(count, files)) {
            if(vflag)
                print("\n<%s>\n\n", file);
            arcopy(&bar, 0, bp);
            if (write(1, bp->member, bp->size) < 0)
                wrerr();
        } else
            skip(&bar, bp->size);
        free(bp);
    }
    close(fd);
}
@

<<function mcmd>>=
void
mcmd(char *arname, int count, char **files)
{
    int fd, i;
    Arfile *ap;
    Armember *bp;

    if (count == 0)
        return;
    fd = openar(arname, ORDWR, 0);
    Binit(&bar, fd, OREAD);
    Bseek(&bar,seek(fd,0,1), 1);
    astart = newtempfile(artemp);
    amiddle = newtempfile(movtemp);
    aend = 0;
    ap = astart;
    for (i = 0; bp = getdir(&bar); i++) {
        if (bamatch(file, poname)) {
            aend = newtempfile(tailtemp);
            ap = aend;
        }
        if(match(count, files)) {
            mesg('m', file);
            scanobj(&bar, amiddle, bp->size);
            arcopy(&bar, amiddle, bp);
        } else
            /*
             * pitch the symdef file if it is at the beginning
             * of the archive and we aren't inserting in front
             * of it (ap == astart).
             */
        if (ap == astart && i == 0 && strcmp(file, symdef) == 0)
            skip(&bar, bp->size);
        else {
            scanobj(&bar, ap, bp->size);
            arcopy(&bar, ap, bp);
        }
    }
    close(fd);
    if (poname[0] && aend == 0)
        fprint(2, "ar: %s not found - files moved to end.\n", poname);
    install(arname, astart, amiddle, aend, 0);
}
@

<<function tcmd>>=
void
tcmd(char *arname, int count, char **files)
{
    int fd;
    Armember *bp;
    char name[ARNAMESIZE+1];

    fd = openar(arname, OREAD, 0);
    Binit(&bar, fd, OREAD);
    Bseek(&bar,seek(fd,0,1), 1);
    while(bp = getdir(&bar)) {
        if(count == 0 || match(count, files)) {
            if(vflag)
                longt(bp);
            trim(file, name, ARNAMESIZE);
            Bprint(&bout, "%s\n", name);
        }
        skip(&bar, bp->size);
        free(bp);
    }
    close(fd);
}
@

<<function qcmd>>=
void
qcmd(char *arname, int count, char **files)
{
    int fd, i;
    Armember *bp;
    Biobuf *bfile;

    if(aflag || bflag) {
        fprint(2, "ar: abi not allowed with q\n");
        exits("error");
    }
    fd = openar(arname, ORDWR, 1);
    if (fd < 0) {
        if(!cflag)
            fprint(2, "ar: creating %s\n", arname);
        fd = arcreate(arname);
    }
    Binit(&bar, fd, OREAD);
    Bseek(&bar,seek(fd,0,1), 1);
    /* leave note group behind when writing archive; i.e. sidestep interrupts */
    rfork(RFNOTEG);
    Bseek(&bar, 0, 2);
    bp = newmember();
    for(i=0; i<count && files[i]; i++) {
        file = files[i];
        files[i] = 0;
        bfile = Bopen(file, OREAD);
        if(!bfile)
            fprint(2, "ar: %s cannot open\n", file);
        else {
            mesg('q', file);
            armove(bfile, 0, bp);
            if (!arwrite(fd, bp))
                wrerr();
            free(bp->member);
            bp->member = 0;
            Bterm(bfile);
        }
    }
    free(bp);
    close(fd);
}
@

<<function scanobj>>=
/*
 *	extract the symbol references from an object file
 */
void
scanobj(Biobuf *b, Arfile *ap, long size)
{
    int obj;
    vlong offset;
    Dir *d;
    static int lastobj = -1;

    if (!allobj)			/* non-object file encountered */
        return;
    offset = Boffset(b);
    obj = objtype(b, 0);
    if (obj < 0) {			/* not an object file */
        allobj = 0;
        d = dirfstat(Bfildes(b));
        if (d != nil && d->length == 0)
            fprint(2, "ar: zero length file %s\n", file);
        free(d);
        Bseek(b, offset, 0);
        return;
    }
    if (lastobj >= 0 && obj != lastobj) {
        fprint(2, "ar: inconsistent object file %s\n", file);
        allobj = 0;
        Bseek(b, offset, 0);
        return;
    }
    lastobj = obj;
    if (!readar(b, obj, offset+size, 0)) {
        fprint(2, "ar: invalid symbol reference in file %s\n", file);
        allobj = 0;
        Bseek(b, offset, 0);
        return;
    }
    Bseek(b, offset, 0);
    objtraverse(objsym, ap);
}
@

<<function objsym>>=
/*
 *	add text and data symbols to the symbol list
 */
void
objsym(Sym *s, void *p)
{
    int n;
    Arsymref *as;
    Arfile *ap;

    if (s->type != 'T' &&  s->type != 'D')
        return;
    ap = (Arfile*)p;
    as = (Arsymref*)armalloc(sizeof(Arsymref));
    as->offset = ap->size;
    n = strlen(s->name);
    as->name = armalloc(n+1);
    strcpy(as->name, s->name);
    if(s->type == 'T' && duplicate(as->name)) {
        dupfound = 1;
        fprint(2, "duplicate text symbol: %s\n", as->name);
        free(as->name);
        free(as);
        return;
    }
    as->type = s->type;
    symdefsize += 4+(n+1)+1;
    as->len = n;
    as->next = ap->sym;
    ap->sym = as;
}
@

<<function duplicate>>=
/*
 *	Check the symbol table for duplicate text symbols
 */
int
duplicate(char *name)
{
    Hashchain *p;
    char *cp;
    int h;

    h = 0;
    for(cp = name; *cp; h += *cp++)
        h *= 1119;
    if(h < 0)
        h = ~h;
    h %= NHASH;

    for(p = hash[h]; p; p = p->next)
        if(strcmp(p->name, name) == 0)
            return 1;
    p = (Hashchain*) armalloc(sizeof(Hashchain));
    p->next = hash[h];
    p->name = name;
    hash[h] = p;
    return 0;
}
@

<<function openar>>=
/*
 *	open an archive and validate its header
 */
int
openar(char *arname, int mode, int errok)
{
    int fd;
    char mbuf[SARMAG];

    fd = open(arname, mode);
    if(fd >= 0){
        if(read(fd, mbuf, SARMAG) != SARMAG || strncmp(mbuf, ARMAG, SARMAG)) {
            fprint(2, "ar: %s not in archive format\n", arname);
            exits("error");
        }
    }else if(!errok){
        fprint(2, "ar: cannot open %s: %r\n", arname);
        exits("error");
    }
    return fd;
}
@

<<function arcreate>>=
/*
 *	create an archive and set its header
 */
int
arcreate(char *arname)
{
    int fd;

    fd = create(arname, OWRITE, 0664);
    if(fd < 0){
        fprint(2, "ar: cannot create %s: %r\n", arname);
        exits("error");
    }
    if(write(fd, ARMAG, SARMAG) != SARMAG)
        wrerr();
    return fd;
}
@

<<function wrerr>>=
/*
 *		error handling
 */
void
wrerr(void)
{
    perror("ar: write error");
    exits("error");
}
@

<<function rderr>>=
void
rderr(void)
{
    perror("ar: read error");
    exits("error");
}
@

<<function phaseerr>>=
void
phaseerr(int offset)
{
    fprint(2, "ar: phase error at offset %d\n", offset);
    exits("error");
}
@

<<function usage>>=
static void
usage(void)
{
    fprint(2, "usage: ar [%s][%s] archive files ...\n", opt, man);
    exits("error");
}
@

<<function getdir>>=
/*
 *	read the header for the next archive member
 */
Armember *
getdir(Biobuf *b)
{
    Armember *bp;
    char *cp;
    static char name[ARNAMESIZE+1];

    bp = newmember();
    if(HEADER_IO(Bread, b, bp->hdr)) {
        free(bp);
        return 0;
    }
    if(strncmp(bp->hdr.fmag, ARFMAG, sizeof(bp->hdr.fmag)) != 0)
        phaseerr(Boffset(b));
    strncpy(name, bp->hdr.name, sizeof(bp->hdr.name));
    cp = name+sizeof(name)-1;
    *cp = '\0';
    /* skip trailing spaces and (gnu-produced) slashes */
    while(*--cp == ' ' || *cp == '/')
        ;
    cp[1] = '\0';
    file = name;
    bp->date = strtol(bp->hdr.date, 0, 0);
    bp->size = strtol(bp->hdr.size, 0, 0);
    return bp;
}
@

<<function armove>>=
/*
 *	Copy the file referenced by fd to the temp file
 */
void
armove(Biobuf *b, Arfile *ap, Armember *bp)
{
    char *cp;
    Dir *d;

    d = dirfstat(Bfildes(b));
    if (d == nil) {
        fprint(2, "ar: cannot stat %s\n", file);
        return;
    }
    trim(file, bp->hdr.name, sizeof(bp->hdr.name));
    for (cp = strchr(bp->hdr.name, 0);		/* blank pad on right */
        cp < bp->hdr.name+sizeof(bp->hdr.name); cp++)
            *cp = ' ';
    sprint(bp->hdr.date, "%-12ld", d->mtime);
    sprint(bp->hdr.uid, "%-6d", 0);
    sprint(bp->hdr.gid, "%-6d", 0);
    sprint(bp->hdr.mode, "%-8lo", d->mode);
    sprint(bp->hdr.size, "%-10lld", d->length);
    strncpy(bp->hdr.fmag, ARFMAG, 2);
    bp->size = d->length;
    arread(b, bp, bp->size);
    if (d->length&0x01)
        d->length++;
    if (ap) {
        arinsert(ap, bp);
        ap->size += d->length+SAR_HDR;
    }
    free(d);
}
@

<<function arcopy>>=
/*
 *	Copy the archive member at the current offset into the temp file.
 */
void
arcopy(Biobuf *b, Arfile *ap, Armember *bp)
{
    long n;

    n = bp->size;
    if (n & 01)
        n++;
    arread(b, bp, n);
    if (ap) {
        arinsert(ap, bp);
        ap->size += n+SAR_HDR;
    }
}
@

<<function skip>>=
/*
 *	Skip an archive member
 */
void
skip(Biobuf *bp, vlong len)
{
    if (len & 01)
        len++;
    Bseek(bp, len, 1);
}
@

<<function install>>=
/*
 *	Stream the three temp files to an archive
 */
void
install(char *arname, Arfile *astart, Arfile *amiddle, Arfile *aend, int createflag)
{
    int fd;

    if(allobj && dupfound) {
        fprint(2, "%s not changed\n", arname);
        return;
    }
    /* leave note group behind when copying back; i.e. sidestep interrupts */
    rfork(RFNOTEG);

    if(createflag)
        fprint(2, "ar: creating %s\n", arname);
    fd = arcreate(arname);

    if(allobj)
        rl(fd);

    if (astart) {
        arstream(fd, astart);
        arfree(astart);
    }
    if (amiddle) {
        arstream(fd, amiddle);
        arfree(amiddle);
    }
    if (aend) {
        arstream(fd, aend);
        arfree(aend);
    }
    close(fd);
}
@

<<function rl>>=
void
rl(int fd)
{

    Biobuf b;
    char *cp;
    struct ar_hdr a;
    long len;

    Binit(&b, fd, OWRITE);
    Bseek(&b,seek(fd,0,1), 0);

    len = symdefsize;
    if(len&01)
        len++;
    sprint(a.date, "%-12ld", time(0));
    sprint(a.uid, "%-6d", 0);
    sprint(a.gid, "%-6d", 0);
    sprint(a.mode, "%-8lo", 0644L);
    sprint(a.size, "%-10ld", len);
    strncpy(a.fmag, ARFMAG, 2);
    strcpy(a.name, symdef);
    for (cp = strchr(a.name, 0);		/* blank pad on right */
        cp < a.name+sizeof(a.name); cp++)
            *cp = ' ';
    if(HEADER_IO(Bwrite, &b, a))
            wrerr();

    len += Boffset(&b);
    if (astart) {
        wrsym(&b, len, astart->sym);
        len += astart->size;
    }
    if(amiddle) {
        wrsym(&b, len, amiddle->sym);
        len += amiddle->size;
    }
    if(aend)
        wrsym(&b, len, aend->sym);

    if(symdefsize&0x01)
        Bputc(&b, 0);
    Bterm(&b);
}
@

<<function wrsym>>=
/*
 *	Write the defined symbols to the symdef file
 */
void
wrsym(Biobuf *bp, long offset, Arsymref *as)
{
    int off;

    while(as) {
        Bputc(bp, as->type);
        off = as->offset+offset;
        Bputc(bp, off);
        Bputc(bp, off>>8);
        Bputc(bp, off>>16);
        Bputc(bp, off>>24);
        if (Bwrite(bp, as->name, as->len+1) != as->len+1)
            wrerr();
        as = as->next;
    }
}
@

<<function match>>=
/*
 *	Check if the archive member matches an entry on the command line.
 */
int
match(int count, char **files)
{
    int i;
    char name[ARNAMESIZE+1];

    for(i=0; i<count; i++) {
        if(files[i] == 0)
            continue;
        trim(files[i], name, ARNAMESIZE);
        if(strncmp(name, file, ARNAMESIZE) == 0) {
            file = files[i];
            files[i] = 0;
            return 1;
        }
    }
    return 0;
}
@

<<function bamatch>>=
/*
 *	compare the current member to the name of the pivot member
 */
int
bamatch(char *file, char *pivot)
{
    static int state = 0;

    switch(state)
    {
    case 0:			/* looking for position file */
        if (aflag) {
            if (strncmp(file, pivot, ARNAMESIZE) == 0)
                state = 1;
        } else if (bflag) {
            if (strncmp(file, pivot, ARNAMESIZE) == 0) {
                state = 2;	/* found */
                return 1;
            }
        }
        break;
    case 1:			/* found - after previous file */
        state = 2;
        return 1;
    case 2:			/* already found position file */
        break;
    }
    return 0;
}
@

<<function mesg>>=
/*
 *	output a message, if 'v' option was specified
 */
void
mesg(int c, char *file)
{

    if(vflag)
        Bprint(&bout, "%c - %s\n", c, file);
}
@

<<function trim>>=
/*
 *	isolate file name by stripping leading directories and trailing slashes
 */
void
trim(char *s, char *buf, int n)
{
    char *p;

    for(;;) {
        p = strrchr(s, '/');
        if (!p) {		/* no slash in name */
            strncpy(buf, s, n);
            return;
        }
        if (p[1] != 0) {	/* p+1 is first char of file name */
            strncpy(buf, p+1, n);
            return;
        }
        *p = 0;			/* strip trailing slash */
    }
}
@

<<constant SUID>>=
/*
 *	utilities for printing long form of 't' command
 */
#define	SUID	04000
@

<<constant SGID>>=
#define	SGID	02000
@

<<constant ROWN>>=
#define	ROWN	0400
@

<<constant WOWN>>=
#define	WOWN	0200
@

<<constant XOWN>>=
#define	XOWN	0100
@

<<constant RGRP>>=
#define	RGRP	040
@

<<constant WGRP>>=
#define	WGRP	020
@

<<constant XGRP>>=
#define	XGRP	010
@

<<constant ROTH>>=
#define	ROTH	04
@

<<constant WOTH>>=
#define	WOTH	02
@

<<constant XOTH>>=
#define	XOTH	01
@

<<constant STXT>>=
#define	STXT	01000
@

<<function longt>>=
void
longt(Armember *bp)
{
    char *cp;

    pmode(strtoul(bp->hdr.mode, 0, 8));
    Bprint(&bout, "%3ld/%1ld", strtol(bp->hdr.uid, 0, 0), strtol(bp->hdr.gid, 0, 0));
    Bprint(&bout, "%7ld", bp->size);
    cp = ctime(bp->date);
    Bprint(&bout, " %-12.12s %-4.4s ", cp+4, cp+24);
}
@

<<global m1>>=
int	m1[] = { 1, ROWN, 'r', '-' };
@

<<global m2>>=
int	m2[] = { 1, WOWN, 'w', '-' };
@

<<global m3>>=
int	m3[] = { 2, SUID, 's', XOWN, 'x', '-' };
@

<<global m4>>=
int	m4[] = { 1, RGRP, 'r', '-' };
@

<<global m5>>=
int	m5[] = { 1, WGRP, 'w', '-' };
@

<<global m6>>=
int	m6[] = { 2, SGID, 's', XGRP, 'x', '-' };
@

<<global m7>>=
int	m7[] = { 1, ROTH, 'r', '-' };
@

<<global m8>>=
int	m8[] = { 1, WOTH, 'w', '-' };
@

<<global m9>>=
int	m9[] = { 2, STXT, 't', XOTH, 'x', '-' };
@

<<global m>>=
int	*m[] = { m1, m2, m3, m4, m5, m6, m7, m8, m9};
@

<<function pmode>>=
void
pmode(long mode)
{
    int **mp;

    for(mp = &m[0]; mp < &m[9];)
        select(*mp++, mode);
}
@

<<function select>>=
void
select(int *ap, long mode)
{
    int n;

    n = *ap++;
    while(--n>=0 && (mode & (*ap++))==0)
        ap++;
    Bputc(&bout, *ap);
}
@

<<function newtempfile>>=
/*
 *	Temp file I/O subsystem.  We attempt to cache all three temp files in
 *	core.  When we run out of memory we spill to disk.
 *	The I/O model assumes that temp files:
 *		1) are only written on the end
 *		2) are only read from the beginning
 *		3) are only read after all writing is complete.
 *	The architecture uses one control block per temp file.  Each control
 *	block anchors a chain of buffers, each containing an archive member.
 */
Arfile *
newtempfile(char *name)		/* allocate a file control block */
{
    Arfile *ap;

    ap = (Arfile *) armalloc(sizeof(Arfile));
    ap->fname = name;
    return ap;
}
@

<<function newmember>>=
Armember *
newmember(void)			/* allocate a member buffer */
{
    return (Armember *)armalloc(sizeof(Armember));
}
@

<<function arread>>=
void
arread(Biobuf *b, Armember *bp, int n)	/* read an image into a member buffer */
{
    int i;

    bp->member = armalloc(n);
    i = Bread(b, bp->member, n);
    if (i < 0) {
        free(bp->member);
        bp->member = 0;
        rderr();
    }
}
@

<<function arinsert>>=
/*
 * insert a member buffer into the member chain
 */
void
arinsert(Arfile *ap, Armember *bp)
{
    bp->next = 0;
    if (!ap->tail)
        ap->head = bp;
    else
        ap->tail->next = bp;
    ap->tail = bp;
}
@

<<function arstream>>=
/*
 *	stream the members in a temp file to the file referenced by 'fd'.
 */
void
arstream(int fd, Arfile *ap)
{
    Armember *bp;
    int i;
    char buf[8192];

    if (ap->paged) {		/* copy from disk */
        seek(ap->fd, 0, 0);
        for (;;) {
            i = read(ap->fd, buf, sizeof(buf));
            if (i < 0)
                rderr();
            if (i == 0)
                break;
            if (write(fd, buf, i) != i)
                wrerr();
        }
        close(ap->fd);
        ap->paged = 0;
    }
        /* dump the in-core buffers */
    for (bp = ap->head; bp; bp = bp->next) {
        if (!arwrite(fd, bp))
            wrerr();
    }
}
@

<<function arwrite>>=
/*
 *	write a member to 'fd'.
 */
int
arwrite(int fd, Armember *bp)
{
    int len;

    if(HEADER_IO(write, fd, bp->hdr))
        return 0;
    len = bp->size;
    if (len & 01)
        len++;
    if (write(fd, bp->member, len) != len)
        return 0;
    return 1;
}
@

<<function page>>=
/*
 *	Spill a member to a disk copy of a temp file
 */
int
page(Arfile *ap)
{
    Armember *bp;

    bp = ap->head;
    if (!ap->paged) {		/* not yet paged - create file */
        ap->fname = mktemp(ap->fname);
        ap->fd = create(ap->fname, ORDWR|ORCLOSE, 0600);
        if (ap->fd < 0) {
            fprint(2,"ar: can't create temp file\n");
            return 0;
        }
        ap->paged = 1;
    }
    if (!arwrite(ap->fd, bp))	/* write member and free buffer block */
        return 0;
    ap->head = bp->next;
    if (ap->tail == bp)
        ap->tail = bp->next;
    free(bp->member);
    free(bp);
    return 1;
}
@

<<function getspace>>=
/*
 *	try to reclaim space by paging.  we try to spill the start, middle,
 *	and end files, in that order.  there is no particular reason for the
 *	ordering.
 */
int
getspace(void)
{
    if (astart && astart->head && page(astart))
            return 1;
    if (amiddle && amiddle->head && page(amiddle))
            return 1;
    if (aend && aend->head && page(aend))
            return 1;
    return 0;
}
@

<<function arfree>>=
void
arfree(Arfile *ap)		/* free a member buffer */
{
    Armember *bp, *next;

    for (bp = ap->head; bp; bp = next) {
        next = bp->next;
        if (bp->member)
            free(bp->member);
        free(bp);
    }
    free(ap);
}
@

<<function armalloc>>=
/*
 *	allocate space for a control block or member buffer.  if the malloc
 *	fails we try to reclaim space by spilling previously allocated
 *	member buffers.
 */
char *
armalloc(int n)
{
    char *cp;

    do {
        cp = malloc(n);
        if (cp) {
            memset(cp, 0, n);
            return cp;
        }
    } while (getspace());
    fprint(2, "ar: out of memory\n");
    exits("malloc");
    return 0;
}
@


%-------------------------------------------------------------

<<linkers/misc/ar.c>>=
/*
 * ar - portable (ascii) format version
 */
#include <u.h>
#include <libc.h>
#include <bio.h>
#include <mach.h>
#include <ar.h>

/*
 *	The algorithm uses up to 3 temp files.  The "pivot member" is the
 *	archive member specified by and a, b, or i option.  The temp files are
 *	astart - contains existing members up to and including the pivot member.
 *	amiddle - contains new files moved or inserted behind the pivot.
 *	aend - contains the existing members that follow the pivot member.
 *	When all members have been processed, function 'install' streams the
 * 	temp files, in order, back into the archive.
 */

<<struct Arsymref>>

<<struct Armember>>

<<struct Arfile>>

<<struct Hashchain>>

<<constant NHASH>>

<<function HEADER_IO>>

        /* constants and flags */
<<global man>>
<<global opt>>
<<global artemp>>
<<global movtemp>>
<<global tailtemp>>
<<global symdef>>

<<global aflag>>
<<global bflag>>
<<global cflag>>
<<global oflag>>
<<global uflag>>
<<global vflag>>

Arfile *astart, *amiddle, *aend;	/* Temp file control block pointers */
<<global allobj>>
<<global symdefsize>>
<<global dupfound>>
<<global hash>>
    
<<constant ARNAMESIZE>>

<<global poname>>
<<global file>>
<<global bout>>
<<global bar>>

void	arcopy(Biobuf*, Arfile*, Armember*);
int	arcreate(char*);
void	arfree(Arfile*);
void	arinsert(Arfile*, Armember*);
char	*armalloc(int);
void	armove(Biobuf*, Arfile*, Armember*);
void	arread(Biobuf*, Armember*, int);
void	arstream(int, Arfile*);
int	arwrite(int, Armember*);
int	bamatch(char*, char*);
int	duplicate(char*);
Armember *getdir(Biobuf*);
int	getspace(void);
void	install(char*, Arfile*, Arfile*, Arfile*, int);
void	longt(Armember*);
int	match(int, char**);
void	mesg(int, char*);
Arfile	*newtempfile(char*);
Armember *newmember(void);
void	objsym(Sym*, void*);
int	openar(char*, int, int);
int	page(Arfile*);
void	pmode(long);
void	rl(int);
void	scanobj(Biobuf*, Arfile*, long);
void	select(int*, long);
void	setcom(void(*)(char*, int, char**));
void	skip(Biobuf*, vlong);
int	symcomp(void*, void*);
void	trim(char*, char*, int);
static void	usage(void);
void	wrerr(void);
void	wrsym(Biobuf*, long, Arsymref*);

void	rcmd(char*, int, char**);		/* command processing */
void	dcmd(char*, int, char**);
void	xcmd(char*, int, char**);
void	tcmd(char*, int, char**);
void	pcmd(char*, int, char**);
void	mcmd(char*, int, char**);
void	qcmd(char*, int, char**);
<<global comfun>>

<<function main>>
<<function setcom>>
<<function rcmd>>

<<function dcmd>>

<<function xcmd>>
<<function pcmd>>
<<function mcmd>>
<<function tcmd>>
<<function qcmd>>

<<function scanobj>>

<<function objsym>>

<<function duplicate>>

<<function openar>>

<<function arcreate>>

<<function wrerr>>

<<function rderr>>

<<function phaseerr>>

<<function usage>>

<<function getdir>>

<<function armove>>

<<function arcopy>>

<<function skip>>

<<function install>>

<<function rl>>

<<function wrsym>>

<<function match>>

<<function bamatch>>

<<function mesg>>

<<function trim>>

<<constant SUID>>
<<constant SGID>>
<<constant ROWN>>
<<constant WOWN>>
<<constant XOWN>>
<<constant RGRP>>
<<constant WGRP>>
<<constant XGRP>>
<<constant ROTH>>
<<constant WOTH>>
<<constant XOTH>>
<<constant STXT>>

<<function longt>>

<<global m1>>
<<global m2>>
<<global m3>>
<<global m4>>
<<global m5>>
<<global m6>>
<<global m7>>
<<global m8>>
<<global m9>>

<<global m>>

<<function pmode>>

<<function select>>

<<function newtempfile>>

<<function newmember>>

<<function arread>>

<<function arinsert>>

<<function arstream>>

<<function arwrite>>

<<function page>>

<<function getspace>>

<<function arfree>>

<<function armalloc>>
@


\subsection*{[[linkers/misc/nm.c]]}

<<enum _anon_ (linkers/misc/nm.c)>>=
enum{
    CHUNK	=	256	/* must be power of 2 */
};
@

<<global errs>>=
static char	*errs;			/* exit status */
@

<<global filename>>=
static char	*filename;		/* current file */
@

<<global symname>>=
static char	symname[]="__.SYMDEF";	/* table of contents file name */
@

<<global multifile>>=
static bool	multifile;		/* processing multiple files */
@

<<global aflag (linkers/misc/nm.c)>>=
static int	aflag;
@

<<global gflag>>=
static int	gflag;
@

<<global hflag>>=
static int	hflag;
@

<<global nflag>>=
static int	nflag;
@

<<global sflag>>=
static int	sflag;
@

<<global uflag (linkers/misc/nm.c)>>=
static int	uflag;
@

<<global Tflag>>=
static int	Tflag;
@

<<global fnames>>=
static Sym	**fnames;		/* file path translation table */
@

<<global symptr>>=
static Sym	**symptr;
@

<<global nsym>>=
static int	nsym;
@

<<global bout (linkers/misc/nm.c)>>=
static Biobuf	bout;
@

<<function usage (linkers/misc/nm.c)>>=
static void
usage(void)
{
    fprint(2, "usage: nm [-aghnsTu] file ...\n");
    exits("usage");
}
@

<<function main (linkers/misc/nm.c)>>=
void
main(int argc, char *argv[])
{
    int i;
    Biobuf	*bin;

    Binit(&bout, 1, OWRITE);
    argv0 = argv[0];
    ARGBEGIN {
    default:	usage();
    case 'a':	aflag = 1; break;
    case 'g':	gflag = 1; break;
    case 'h':	hflag = 1; break;
    case 'n':	nflag = 1; break;
    case 's':	sflag = 1; break;
    case 'u':	uflag = 1; break;
    case 'T':	Tflag = 1; break;
    } ARGEND
    if (argc == 0)
        usage();
    if (argc > 1)
        multifile = true;
    for(i=0; i<argc; i++){
        filename = argv[i];
        bin = Bopen(filename, OREAD);
        if(bin == 0){
            error("cannot open %s", filename);
            continue;
        }
        if (isar(bin))
            doar(bin);
        else{
            Bseek(bin, 0, 0);
            dofile(bin);
        }
        Bterm(bin);
    }
    exits(errs);
}
@

<<function doar>>=
/*
 * read an archive file,
 * processing the symbols for each intermediate file in it.
 */
void
doar(Biobuf *bp)
{
    int offset, size, obj;
    char membername[SARNAME];

    multifile = true;
    for (offset = Boffset(bp);;offset += size) {
        size = nextar(bp, offset, membername);
        if (size < 0) {
            error("phase error on ar header %ld", offset);
            return;
        }
        if (size == 0)
            return;
        if (strcmp(membername, symname) == 0)
            continue;
        obj = objtype(bp, 0);
        if (obj < 0) {
            error("inconsistent file %s in %s",
                    membername, filename);
            return;
        }
        if (!readar(bp, obj, offset+size, 1)) {
            error("invalid symbol reference in file %s",
                    membername);
            return;
        }
        filename = membername;
        nsym=0;
        objtraverse(psym, 0);
        printsyms(symptr, nsym);
    }
}
@

<<function dofile>>=
/*
 * process symbols in a file
 */
void
dofile(Biobuf *bp)
{
    int obj;

    obj = objtype(bp, 0);
    if (obj < 0)
        execsyms(Bfildes(bp));
    else
    if (readobj(bp, obj)) {
        nsym = 0;
        objtraverse(psym, 0);
        printsyms(symptr, nsym);
    }
}
@

<<function cmp>>=
/*
 * comparison routine for sorting the symbol table
 *	this screws up on 'z' records when aflag == 1
 */
int
cmp(void *vs, void *vt)
{
    Sym **s, **t;

    s = vs;
    t = vt;
    if(nflag)
        if((*s)->value < (*t)->value)
            return -1;
        else
            return (*s)->value > (*t)->value;
    return strcmp((*s)->name, (*t)->name);
}
@

<<function zenter>>=
/*
 * enter a symbol in the table of filename elements
 */
void
zenter(Sym *s)
{
    static int maxf = 0;

    if (s->value > maxf) {
        maxf = (s->value+CHUNK-1) &~ (CHUNK-1);
        fnames = realloc(fnames, (maxf+1)*sizeof(*fnames));
        if(fnames == 0) {
            error("out of memory", argv0);
            exits("memory");
        }
    }
    fnames[s->value] = s;
}
@

<<function execsyms>>=
/*
 * get the symbol table from an executable file, if it has one
 */
void
execsyms(int fd)
{
    Fhdr f;
    Sym *s;
    long n;

    seek(fd, 0, 0);
    if (crackhdr(fd, &f) == 0) {
        error("Can't read header for %s", filename);
        return;
    }
    if (syminit(fd, &f) < 0)
        return;
    s = symbase(&n);
    nsym = 0;
    while(n--)
        psym(s++, 0);

    printsyms(symptr, nsym);
}
@

<<function psym>>=
void
psym(Sym *s, void* p)
{
    USED(p);
    switch(s->type) {
    case 'T':
    case 'L':
    case 'D':
    case 'B':
        if (uflag)
            return;
        if (!aflag && ((s->name[0] == '.' || s->name[0] == '$')))
            return;
        break;
    case 'b':
    case 'd':
    case 'l':
    case 't':
        if (uflag || gflag)
            return;
        if (!aflag && ((s->name[0] == '.' || s->name[0] == '$')))
            return;
        break;
    case 'U':
        if (gflag)
            return;
        break;
    case 'Z':
        if (!aflag)
            return;
        break;
    case 'm':
    case 'f':	/* we only see a 'z' when the following is true*/
        if(!aflag || uflag || gflag)
            return;
        if (strcmp(s->name, ".frame"))
            zenter(s);
        break;
    case 'a':
    case 'p':
    case 'z':
    default:
        if(!aflag || uflag || gflag)
            return;
        break;
    }
    symptr = realloc(symptr, (nsym+1)*sizeof(Sym*));
    if (symptr == 0) {
        error("out of memory");
        exits("memory");
    }
    symptr[nsym++] = s;
}
@

<<function printsyms>>=
void
printsyms(Sym **symptr, long nsym)
{
    int i, wid;
    Sym *s;
    char *cp;
    char path[512];

    if(!sflag)
        qsort(symptr, nsym, sizeof(*symptr), cmp);
    
    wid = 0;
    for (i=0; i<nsym; i++) {
        s = symptr[i];
        if (s->value && wid == 0)
            wid = 8;
        else if (s->value >= 0x100000000LL && wid == 8)
            wid = 16;
    }	
    for (i=0; i<nsym; i++) {
        s = symptr[i];
        if (multifile && !hflag)
            Bprint(&bout, "%s:", filename);
        if (s->type == 'z') {
            fileelem(fnames, (uchar *) s->name, path, 512);
            cp = path;
        } else
            cp = s->name;
        if (Tflag)
            Bprint(&bout, "%8ux ", s->sig);
        if (s->value || s->type == 'a' || s->type == 'p')
            Bprint(&bout, "%*llux ", wid, s->value);
        else
            Bprint(&bout, "%*s ", wid, "");

        Bprint(&bout, "%c %s\n", s->type, cp);
    }
}
@

<<function error>>=
static void
error(char *fmt, ...)
{
    Fmt f;
    char buf[128];
    va_list arg;

    fmtfdinit(&f, 2, buf, sizeof buf);
    fmtprint(&f, "%s: ", argv0);
    va_start(arg, fmt);
    fmtvprint(&f, fmt, arg);
    va_end(arg);
    fmtprint(&f, "\n");
    fmtfdflush(&f);
    errs = "errors";
}
@


%-------------------------------------------------------------

<<linkers/misc/nm.c>>=
/*
 * nm.c -- drive nm
 */
#include <u.h>
#include <libc.h>
#include <ar.h>
#include <bio.h>
#include <mach.h>

<<enum _anon_ (linkers/misc/nm.c)>>

<<global errs>>
<<global filename>>
<<global symname>>
<<global multifile>>
<<global aflag (linkers/misc/nm.c)>>
<<global gflag>>
<<global hflag>>
<<global nflag>>
<<global sflag>>
<<global uflag (linkers/misc/nm.c)>>
<<global Tflag>>

<<global fnames>>
<<global symptr>>
<<global nsym>>
<<global bout (linkers/misc/nm.c)>>

int	cmp(void*, void*);
static void	error(char*, ...);
void	execsyms(int);
void	psym(Sym*, void*);
void	printsyms(Sym**, long);
void	doar(Biobuf*);
void	dofile(Biobuf*);
void	zenter(Sym*);

<<function usage (linkers/misc/nm.c)>>

<<function main (linkers/misc/nm.c)>>

<<function doar>>

<<function dofile>>

<<function cmp>>
<<function zenter>>

<<function execsyms>>

<<function psym>>

<<function printsyms>>

<<function error>>
@


\subsection*{[[linkers/misc/size.c]]}

%-------------------------------------------------------------

<<linkers/misc/size.c>>=
#include	<u.h>
#include	<libc.h>
#include	<bio.h>
#include	<mach.h>

<<function size>>

<<function main (linkers/misc/size.c)>>
@


\subsection*{[[linkers/misc/strip.c]]}

<<function error (linkers/misc/strip.c)>>=
void
error(char* fmt, ...)
{
    va_list arg;
    char *e, s[256];

    va_start(arg, fmt);
    e = seprint(s, s+sizeof(s), "%s: ", argv0);
    e = vseprint(e, s+sizeof(s), fmt, arg);
    e = seprint(e, s+sizeof(s), "\n");
    va_end(arg);

    write(2, s, e-s);
}
@

<<function usage (linkers/misc/strip.c)>>=
static void
usage(void)
{
    error("usage: %s -o ofile file\n\t%s file ...\n", argv0, argv0);
    exits("usage");
}
@

<<function strip>>=
static int
strip(char* file, char* out)
{
    Dir *dir;
    int fd, i;
    Fhdr fhdr;
    Exec *exec;
    ulong mode;
    void *data;
    vlong length;

    if((fd = open(file, OREAD)) < 0){
        error("%s: open: %r", file);
        return 1;
    }

    if(!crackhdr(fd, &fhdr)){
        error("%s: %r", file);
        close(fd);
        return 1;
    }
    for(i = MIN_MAGIC; i <= MAX_MAGIC; i++){
        if(fhdr.magic == _MAGIC(0, i) || fhdr.magic == _MAGIC(HDR_MAGIC, i))
            break;
    }
    if(i > MAX_MAGIC){
        error("%s: not a recognizeable binary", file);
        close(fd);
        return 1;
    }

    if((dir = dirfstat(fd)) == nil){
        error("%s: stat: %r", file);
        close(fd);
        return 1;
    }

    length = fhdr.datoff+fhdr.datsz;
    if(length == dir->length){
        if(out == nil){	/* nothing to do */
            error("%s: already stripped", file);
            free(dir);
            close(fd);
            return 0;
        }
    }
    if(length > dir->length){
        error("%s: strange length", file);
        close(fd);
        free(dir);
        return 1;
    }

    mode = dir->mode;
    free(dir);

    if((data = malloc(length)) == nil){
        error("%s: malloc failure", file);
        close(fd);
        return 1;
    }
    seek(fd, 0LL, 0);
    if(read(fd, data, length) != length){
        error("%s: read: %r", file);
        close(fd);
        free(data);
        return 1;
    }
    close(fd);

    exec = data;
    exec->syms = 0;
    exec->_unused = 0;
    exec->pcsz = 0;

    if(out == nil){
        if(remove(file) < 0) {
            error("%s: remove: %r", file);
            free(data);
            return 1;
        }
        out = file;
    }
    if((fd = create(out, OWRITE, mode)) < 0){
        error("%s: create: %r", out);
        free(data);
        return 1;
    }
    if(write(fd, data, length) != length){
        error("%s: write: %r", out);
        close(fd);
        free(data);
        return 1;
    }
    close(fd);
    free(data);

    return 0;
}
@

<<function main (linkers/misc/strip.c)>>=
void
main(int argc, char* argv[])
{
    int r;
    char *p;

    p = nil;

    ARGBEGIN{
    default:
        usage();
        break;
    case 'o':
        p = ARGF();
        if(p == nil)
            usage();
        break;
    }ARGEND;

    switch(argc){
    case 0:
        usage();
        return;
    case 1:
        if(p != nil){
            r = strip(*argv, p);
            break;
        }
        /*FALLTHROUGH*/
    default:
        r = 0;
        while(argc > 0){
            r |= strip(*argv, nil);
            argc--;
            argv++;
        }
        break;
    }

    if(r)
        exits("error");
    exits(0);
}
@


%-------------------------------------------------------------

<<linkers/misc/strip.c>>=
#include <u.h>
#include <libc.h>
#include <bio.h>
#include <mach.h>

<<function error (linkers/misc/strip.c)>>

<<function usage (linkers/misc/strip.c)>>

<<function strip>>

<<function main (linkers/misc/strip.c)>>
@







\section{[[linkers/5l/]]}

\subsection*{[[linkers/5l/l.h]]}

<<enum misc_constant(arm)>>=
enum misc_constants {
    <<constant BIG>>

    <<constant STRINGSZ>>
    <<constant NHASH linker>>
    <<constant NHUNK linker>>

    <<constant MINSIZ>>
    NENT		= 100,
    <<constant MAXIO>>
    <<constant MAXHIST>>
};
@
% >>



%-------------------------------------------------------------

<<linkers/5l/l.h>>=
#include	<u.h>
#include	<libc.h>
#include	<bio.h>

#include	<common.out.h>
#include	<arm/5.out.h>

#include	"../8l/elf.h"

<<macro DBG>>

<<constant LIBNAMELEN>>

void	addlibpath(char*);
int		fileexists(char*);
char*	findlib(char*);

typedef	struct	Adr	Adr;
typedef	struct	Sym	Sym;
typedef	struct	Auto	Auto;
typedef	struct	Prog	Prog;
typedef	struct	Optab	Optab;
typedef	struct	Oprang	Oprang;
typedef	struct	Count	Count;

<<constant P>>
<<constant S>>
<<constant TNAME(arm)>>

<<struct Adr(arm)>>

<<struct Prog(arm)>>

<<struct Sym>>

<<constant SIGNINTERN(arm)>>

<<struct Auto(arm)>>
<<struct Optab(arm)>>
<<struct Oprang(arm)>>

<<enum sxxx(arm)>>
<<enum optab_flag(arm)>>
<<enum cxxx(arm)>>
<<enum mark(arm)>>

<<enum misc_constant(arm)>>

<<enum rxxx>>

<<enum headtype(arm)>>

<<struct Buf>>
extern union Buf buf;

extern	long	HEADR;			/* length of header */
extern	short	HEADTYPE;		/* type of header */
extern	long	INITDAT;		/* data location */
extern	long	INITRND;		/* data round above text location */
extern	long	INITTEXT;		/* text location */
extern	long	INITTEXTP;		/* text location (physical) */
extern	char*	INITENTRY;		/* entry point */
extern	long	autosize;
extern	Biobuf	bso;
extern	long	bsssize;
extern	int	cbc;
extern	char*	cbp;
extern	int	cout;
extern	Auto*	curauto;
extern	Auto*	curhist;
extern	Prog*	curp;
extern	Prog*	curtext;
extern	Prog*	datap;
extern	long	datsize;
extern	bool	debug[128];
extern	Prog*	etextp;
extern	Prog*	firstp;
extern	char	fnuxi4[4];
extern	char	fnuxi8[8];
extern	char*	noname;
extern	Sym*	hash[NHASH];
extern	Sym*	histfrog[MAXHIST];
extern	int	histfrogp;
extern	int	histgen;
extern	char*	library[50];
extern	char*	libraryobj[50];
extern	int	libraryp;
extern	int	xrefresolv;
extern	char*	hunk;
extern	char	inuxi1[1];
extern	char	inuxi2[2];
extern	char	inuxi4[4];
extern	Prog*	lastp;
extern	long	lcsize;
extern	char	literal[32];
extern	int	nerrors;
extern	long	nhunk;
extern long	nsymbol;
extern	long	instoffset;
extern	Oprang	oprange[ALAST];
extern	char*	outfile;
extern	long	pc;
extern	long	symsize;
extern	Prog*	textp;
extern	long	textsize;
extern	long	thunk;
extern	int	version;
extern	char	xcmp[C_GOK+1][C_GOK+1];
extern	Prog	zprg;
extern	int	dtype;
extern	int	armv4;
extern	int vfp;

extern	int	doexp, dlm;
extern	int	imports, nimports;
extern	int	exports, nexports;
extern	char*	EXPTAB;
extern	Prog	undefp;

<<constant UP>>

extern	char*	anames[];
extern	Optab	optab[];

void	addpool(Prog*, Adr*);
extern	Prog*	blitrl;
extern	Prog*	elitrl;

void	initdiv(void);
extern	Prog*	prog_div;
extern	Prog*	prog_divu;
extern	Prog*	prog_mod;
extern	Prog*	prog_modu;

#pragma	varargck	type	"A"	int
#pragma	varargck	type	"A"	uint
#pragma	varargck	type	"C"	int
#pragma	varargck	type	"D"	Adr*
#pragma	varargck	type	"N"	Adr*
#pragma	varargck	type	"P"	Prog*
#pragma	varargck	type	"S"	char*

#pragma	varargck	argpos	diag 1

int	Aconv(Fmt*);
int	Cconv(Fmt*);
int	Dconv(Fmt*);
int	Nconv(Fmt*);
int	Pconv(Fmt*);
int	Sconv(Fmt*);

int	aclass(Adr*);
void	addhist(long, int);
void	addlibpath(char*);
void	append(Prog*, Prog*);
void	asmb(void);
void	asmdyn(void);
void	asmlc(void);
void	asmout(Prog*, Optab*);
void	asmsym(void);
long	atolwhex(char*);
Prog*	brloop(Prog*);
void	buildop(void);
void	buildrep(int, int);
void	cflush(void);
void	ckoff(Sym*, long);
int	chipfloat(Ieee*);
int	cmp(int, int);
int	compound(Prog*);
double	cputime(void);
void	datblk(long, long, int);
void	diag(char*, ...);
void	divsig(void);
void	dodata(void);
void	doprof1(void);
void	doprof2(void);
void	dynreloc(Sym*, long, int);
long	entryvalue(void);
void	errorexit(void);
void	exchange(Prog*);
void	export(void);
int	fileexists(char*);
int	find1(long, int);
char*	findlib(char*);
void	follow(void);
void	gethunk(void);
void	histtoauto(void);
double	ieeedtod(Ieee*);
long	ieeedtof(Ieee*);
void	import(void);
int	isnop(Prog*);
void	ldobj(int, long, char*);
void	loadlib(void);
void	listinit(void);
Sym*	lookup(char*, int);
void	cput(int);
void	llput(vlong);
void	llputl(vlong);
void	lput(long);
void	lputl(long);
void	mkfwd(void);
void*	mysbrk(ulong);
void	names(void);
void	nocache(Prog*);
void	nuxiinit(void);
void	objfile(char*);
int	ocmp(const void*, const void*);
long	opirr(int);
Optab*	oplook(Prog*);
long	oprrr(int, int);
long	opvfprrr(int, int);
long	olr(long, int, int, int);
long	olhr(long, int, int, int);
long	olrr(int, int, int, int);
long	olhrr(int, int, int, int);
long	osr(int, int, long, int, int);
long	oshr(int, long, int, int);
long	ofsr(int, int, long, int, int, Prog*);
long	osrr(int, int, int, int);
long	oshrr(int, int, int, int);
long	omvl(Prog*, Adr*, int);
void	patch(void);
void	prasm(Prog*);
void	prepend(Prog*, Prog*);
Prog*	prg(void);
int	pseudo(Prog*);
void	putsymb(char*, int, long, int);
void	readundefs(char*, int);
long	regoff(Adr*);
int	relinv(int);
long	rnd(long, long);
void	dotext(void);
void	strnput(char*, int);
void	undef(void);
void	undefsym(Sym*);
void	wput(long);
void	wputl(long);
void	xdefine(char*, int, long);
void	xfol(Prog*);
void	zerosig(char*);
void	noops(void);
long	immrot(ulong);
long	immaddr(long);
long	opbra(int, int);

void mylog(char*, ...);

@


\subsection*{[[linkers/5l/globals.c]]}


<<global literal(arm)>>=
char	literal[32];
@





%-------------------------------------------------------------

<<linkers/5l/globals.c>>=
#include	"l.h"

<<global buf>>


<<global HEADR>>
<<global HEADTYPE>>
<<global INITDAT>>
<<global INITRND>>
<<global INITTEXT>>
<<global INITTEXTP>>
<<global INITENTRY>>

<<global autosize(arm)>>
<<global bso>>
<<global bsssize>>

<<global cbc>>
<<global cbp>>

<<global cout>>
<<global curauto>>
<<global curhist>>
<<global curp>>
<<global curtext>>
<<global datap>>
<<global datsize>>
<<global debug>>
<<global etextp>>
<<global firstp>>

<<global fnuxi4>>
<<global fnuxi8>>

<<global hash linker>>

<<global histfrog>>
<<global histfrogp>>
<<global histgen>>

<<global library>>
<<global libraryobj>>
<<global libraryp>>

<<global xrefresolv>>
<<global hunk>>

<<global inuxi1>>
<<global inuxi2>>
<<global inuxi4>>

<<global lastp>>
<<global lcsize>>
<<global literal(arm)>>
<<global nerrors>>
<<global nhunk>>
<<global nsymbol linker>>
<<global instoffset(arm)>>
<<global oprange(arm)>>
<<global outfile>>
<<global pc>>
<<global symsize>>
<<global textp>>
<<global textsize>>
<<global thunk>>
<<global version>>
<<global xcmp(arm)>>
<<global zprg>>
<<global dtype(arm)>>
<<global armv4(arm)>>
<<global vfp(arm)>>

<<global doexp>>
<<global dlm>>

<<global imports>>
<<global nimports>>
<<global exports>>
<<global nexports>>
<<global EXPTAB>>
<<global undefp>>

<<global blitrl(arm)>>
<<global elitrl(arm)>>

<<global prog_div(arm)>>
<<global prog_divu(arm)>>
<<global prog_mod(arm)>>
<<global prog_modu(arm)>>
@

\subsection*{[[linkers/5l/optab.c]]}

%-------------------------------------------------------------

<<linkers/5l/optab.c>>=
#include	"l.h"

<<global optab (linkers/5l/optab.c)(arm)>>
@


\subsection*{[[linkers/5l/utils.c]]}

<<linkers/5l/utils.c>>=
#include "l.h"

<<function log>>

<<function errorexit>>

<<function gethunk>>

<<function lookup>>

<<constructor prg>>

<<function copyp>>

@
\subsection*{[[linkers/5l/list.c]]}

%-------------------------------------------------------------

<<linkers/5l/list.c>>=
#include "l.h"

<<function listinit(arm)>>

<<function prasm(arm)>>

<<function Pconv(arm)>>

<<function Aconv(arm)>>

<<global strcond(arm)>>

<<function Cconv(arm)>>

<<function Dconv(arm)>>

<<function Nconv(arm)>>

<<function Sconv(arm)>>

<<function diag>>
@

\subsection*{[[linkers/5l/compat.c]]}


%-------------------------------------------------------------

<<linkers/5l/compat.c>>=
#include	"l.h"

<<function malloc>>

<<function free>>

<<function setmalloctag>>

<<function fileexists>>
@


\subsection*{[[linkers/5l/pass.c]]}

%-------------------------------------------------------------

<<linkers/5l/pass.c>>=
#include	"l.h"

<<function dodata(arm)>>

<<function undef>>

<<function brchain(arm)>>

<<function relinv(arm)>>

<<function follow>>

<<function xfol(arm)>>

<<function patch(arm)>>

<<constant LOG>>
<<function mkfwd>>

<<function brloop(arm)>>

<<function atolwhex>>

<<function rnd>>

<<function import(arm)>>

<<function ckoff>>

<<function newdata(arm)>>

<<function export(arm)>>
@

\subsection*{[[linkers/5l/asm.c]]}


%<<struct Count(arm)>>=
%struct	Count
%{
%    long	count;
%    long	outof;
%};
%@

%<<function nopstat(arm)>>=
%void
%nopstat(char *f, Count *c)
%{
%    if(c->outof)
%    Bprint(&bso, "%s delay %ld/%ld (%.2f)\n", f,
%        c->outof - c->count, c->outof,
%        (double)(c->outof - c->count)/c->outof);
%}
%@




%-------------------------------------------------------------

<<linkers/5l/asm.c>>=
#include	"l.h"

<<constant Dbufslop>>

<<global PP(arm)>>

<<function entryvalue(arm)>>

<<function asmb(arm)>>

<<function strnput(arm)>>

<<function cput(arm)>>

<<function wput(arm)>>

<<function wputl(arm)>>

<<function lput(arm)>>

<<function lputl(arm)>>

<<function llput>>

<<function llputl>>

<<function cflush>>

<<function asmsym(arm)>>

<<function putsymb>>

<<constant MINLC(arm)>>
<<function asmlc>>

<<function datblk(arm)>>

<<function asmout(arm)>>

<<function oprrr(arm)>>

<<function opvfprrr(arm)>>

<<function opbra(arm)>>

<<function olr(arm)>>

<<function olhr(arm)>>

<<function osr(arm)>>

<<function oshr(arm)>>
    

<<function osrr(arm)>>

<<function oshrr(arm)>>

<<function olrr(arm)>>

<<function olhrr(arm)>>

<<function ovfpmem(arm)>>

<<function ofsr(arm)>>

<<function omvl(arm)>>

<<global chipfloats(arm)>>

<<function chipfloat(arm)>>
@


\subsection*{[[linkers/5l/span.c]]}


%-------------------------------------------------------------

<<linkers/5l/span.c>>=
#include	"l.h"

<<global pool(arm)>>

void	checkpool(Prog*);
void 	flushpool(Prog*, int);
typedef struct Reloc Reloc;


<<function span(arm)>>

<<function checkpool(arm)>>

<<function flushpool(arm)>>

<<function addpool(arm)>>

<<function xdefine(arm)>>

<<function regoff(arm)>>

<<function immrot(arm)>>

<<function immaddr(arm)>>

<<function immfloat(arm)>>

<<function immhalf(arm)>>

<<function aclass(arm)>>

<<function oplook(arm)>>

<<function cmp(arm)>>

<<function ocmp(arm)>>

<<function buildop(arm)>>

<<enum _anon_ (linkers/5l/span.c)(arm)>>

<<global modemap>>

<<struct Reloc>>

<<global rels>>

<<function grow>>

<<function dynreloc(arm)>>

<<function sput>>

<<function asmdyn>>
@


\subsection*{[[linkers/5l/obj.c]]}

%-------------------------------------------------------------

<<linkers/5l/obj.c>>=
#include	"l.h"
#include	<ar.h>

#ifndef	DEFAULT
<<constant DEFAULT>>
#endif

<<global noname linker>>
<<global symname linker>>
<<global thechar>>
<<global thestring>>

<<global libdir>>
<<global nlibdir>>
<<global maxlibdir>>

<<function usage, linker>>

<<function isobjfile>>

<<function main(arm)>>

<<function addlibpath>>

<<function findlib>>

<<function loadlib>>

<<function objfile>>

<<function zaddr(arm)>>

<<function addlib>>

<<function addhist>>

<<function histtoauto>>

<<function collapsefrog>>

<<function nopout>>

<<function readsome>>

<<function ldobj(arm)>>

<<function doprof1(arm)>>

<<global brcond(arm)>>

<<function doprof2(arm)>>

<<function nuxiinit(arm)>>

<<function find1>>

<<function ieeedtof>>

<<function ieeedtod>>

<<function undefsym>>

<<function zerosig>>

<<function readundefs>>
@



\subsection*{[[linkers/5l/noop.c]]}


%-------------------------------------------------------------

<<linkers/5l/noop.c>>=
#include	"l.h"

<<global sym_div(arm)>>
<<global sym_divu(arm)>>
<<global sym_mod(arm)>>
<<global sym_modu(arm)>>

<<function noops(arm)>>

<<function sigdiv(arm)>>

<<function divsig(arm)>>

<<function sdiv(arm)>>

<<function initdiv(arm)>>

<<function nocache(arm)>>
@


\section{x86}


% ----------------------------------------------------------
% x86 only now
<<[[Sym]] other fields>>=
short	become;
@
<<[[Sym]] other fields>>=
short	frame;
@

% ----------------------------------------------------------




<<enum headtype(x86)>>=
/*
 *	-H0 -T0x40004C -D0x10000000	is garbage unix
 *	-H1 -T0xd0 -R4			is unix coff
 *	-H2 -T4128 -R4096		is plan9 format
 *	-H3 -Tx -Rx			is MS-DOS .COM
 *	-H4 -Tx -Rx			is fake MS-DOS .EXE
 *	-H5 -T0x80100020 -R4096		is ELF
 */
enum headtype {
    H_GARBAGE = 0,
    H_COFF = 1,
    H_PLAN9 = 2, // default
    H_COM = 3,
    H_EXE = 4,
    H_ELF = 5,
};
@


<<enum sxxx(x86)>>=
enum section
{
    SNONE		= 0,
    STEXT		= 1,
    SDATA,
    SBSS,

    SDATA1,
    SXREF, // means not defined (yet)
    SFILE,
    SCONST,
    SUNDEF,

    SIMPORT,
    SEXPORT,
};
@


<<struct Prog(x86)>>=
struct	Prog
{
    //enum<opcode>
    short	as;

    // operands
    Adr	from;
    Adr	to;

    // [[Prog]] other fields
    // 2 by default in zprg, why?
    byte	back;

    Prog*	forwd;
    long	pc;
    long	line;
    char	width;		/* fake for DATA */
    char	ft;		/* oclass cache */
    char	tt;
    byte	mark;	/* work on these */

    // [[Prog]] Extra fields

    // list<ref<Prog>> from firstp/lastp, or datap/edatap
    Prog*	link;

    // list<ref<Prog>> from textp/etextp, to follow CALL xxx
    Prog*	pcond;	/* work on this */

};
@
% see Pconv, %P




% todo could use a queue data structure, so have fast access to end of list?
<<global edatap(x86)>>=
// ref<Prog>>, end of datap list
Prog*	edatap = P;
@

<<constant TNAME(x86)>>=
#define	TNAME		(curtext ? curtext->from.sym->name : noname)
@


<<struct Adr(x86)>>=
struct	Adr
{
    //enum<operand_kind> (D_NONE by default)
    short	type;

    union
    {
        long	u0offset;
        char	u0scon[8];
        Prog	*u0cond;	/* not used, but should be D_BRANCH */
        Ieee	u0ieee;
    } u0;

    union
    {
        Auto*	u1autom;
        Sym*	u1sym;
    } u1;

    //enum<operand_kind(register-only|D_NONE)>
    byte	index;

    // TODO: abused for NOPROF function attributes
    char	scale; // offset * scale give size of entity?
};
@



% ??
<<constant scon(x86)>>=
#define	scon	u0.u0scon
@

<<constant cond(x86)>>=
#define	cond	u0.u0cond
@


% ???
<<struct Auto(x86)>>=
struct	Auto
{
    Sym*	asym;

    long	aoffset;
    short	type;

    // Extra
    Auto*	link;
};
@

<<struct Optab(x86)>>=
struct	Optab
{
    // enum<as> from 8.out.h
    short	as;

    byte*	ytab;

    // enum<Pxxx>
    byte	prefix;
    // the actual x86 machine code for instruction optab.as
    byte	op[10];
};
@


<<function brloop(x86)>>=
Prog*
brloop(Prog *p)
{
    int c;
    Prog *q;

    c = 0;
    for(q = p; q != P; q = q->pcond) {
        if(q->as != AJMP)
            break;
        c++;
        if(c >= 5000)
            return P;
    }
    return q;
}
@


% unused for ARM
<<function copyp>>=
Prog*
copyp(Prog *q)
{
    Prog *p;

    p = prg();
    *p = *q;
    return p;
}
@

<<function xfol(x86)>>=
void
xfol(Prog *p)
{
    Prog *q;
    int i;
    enum as a;

loop:
    if(p == P)
        return;
    if(p->as == ATEXT)
        curtext = p;
    if(p->as == AJMP)
    if((q = p->pcond) != P) {
        p->mark = 1;
        p = q;
        if(p->mark == 0)
            goto loop;
    }
    if(p->mark) {
        /* copy up to 4 instructions to avoid branch */
        for(i=0,q=p; i<4; i++,q=q->link) {
            if(q == P)
                break;
            if(q == lastp)
                break;
            a = q->as;
            if(a == ANOP) {
                i--;
                continue;
            }
            switch(a) {
            case AJMP:
            case ARET:
            case AIRETL:

            case APUSHL:
            case APUSHFL:
            case APUSHW:
            case APUSHFW:
            case APOPL:
            case APOPFL:
            case APOPW:
            case APOPFW:
                goto brk;
            }
            if(q->pcond == P || q->pcond->mark)
                continue;
            if(a == ACALL || a == ALOOP)
                continue;
            for(;;) {
                if(p->as == ANOP) {
                    p = p->link;
                    continue;
                }
                q = copyp(p);
                p = p->link;
                q->mark = 1;
                lastp->link = q;
                lastp = q;
                if(q->as != a || q->pcond == P || q->pcond->mark)
                    continue;

                q->as = relinv(q->as);
                p = q->pcond;
                q->pcond = q->link;
                q->link = p;
                xfol(q->link);
                p = q->link;
                if(p->mark)
                    return;
                goto loop;
            }
        } /* */
    brk:;
        q = prg();
        q->as = AJMP;
        q->line = p->line;
        q->to.type = D_BRANCH;
        q->to.offset = p->pc;
        q->pcond = p;
        p = q;
    }
    p->mark = 1;
    lastp->link = p;
    lastp = p;
    a = p->as;
    if(a == AJMP || a == ARET || a == AIRETL)
        return;
    if(p->pcond != P)
    if(a != ACALL) {
        q = brchain(p->link);
        if(q != P && q->mark)
        if(a != ALOOP) {
            p->as = relinv(a);
            p->link = p->pcond;
            p->pcond = q;
        }
        xfol(p->link);
        q = brchain(p->pcond);
        if(q->mark) {
            p->pcond = q;
            return;
        }
        p = q;
        goto loop;
    }

    p = p->link;
    goto loop;
}
@

<<function relinv(x86)>>=
int
relinv(int a)
{

    switch(a) {
    case AJEQ:	return AJNE;
    case AJNE:	return AJEQ;
    case AJLE:	return AJGT;
    case AJLS:	return AJHI;
    case AJLT:	return AJGE;
    case AJMI:	return AJPL;
    case AJGE:	return AJLT;
    case AJPL:	return AJMI;
    case AJGT:	return AJLE;
    case AJHI:	return AJLS;
    case AJCS:	return AJCC;
    case AJCC:	return AJCS;
    case AJPS:	return AJPC;
    case AJPC:	return AJPS;
    case AJOS:	return AJOC;
    case AJOC:	return AJOS;
    }
    diag("unknown relation: %s in %s", anames[a], TNAME);
    return a;
}
@

<<function brchain(x86)>>=
Prog*
brchain(Prog *p)
{
    int i;

    for(i=0; i<20; i++) {
        if(p == P || p->as != AJMP)
            return p;
        p = p->pcond;
    }
    return P;
}
@

<<function xdefine(x86)>>=
void
xdefine(char *p, int t, long v)
{
    Sym *s;

    s = lookup(p, 0);
    if(s->type == 0 || s->type == SXREF) {
        s->type = t;
        s->value = v;
    }
    if(s->type == STEXT && s->value == 0)
        s->value = v;
}
@

%\section{[[dostkoff()]]}

% do stack offset?
<<function dostkoff(x86)>>=
void
dostkoff(void)
{
    Prog *p, *q;
    long autoffset, deltasp;
    int a, f, curframe, curbecome, maxbecome;

    curframe = 0;
    curbecome = 0;
    maxbecome = 0;
    curtext = nil;

    for(p = firstp; p != P; p = p->link) {

        /* find out how much arg space is used in this TEXT */
        if(p->to.type == (D_INDIR+D_SP))
            if(p->to.offset > curframe)
                curframe = p->to.offset;

        switch(p->as) {
        case ATEXT:
            if(curtext && curtext->from.sym) {
                curtext->from.sym->frame = curframe;
                curtext->from.sym->become = curbecome;
                if(curbecome > maxbecome)
                    maxbecome = curbecome;
            }
            curframe = 0;
            curbecome = 0;

            curtext = p;
            break;

        case ARET:
            /* special form of RET is BECOME */
            if(p->from.type == D_CONST)
                if(p->from.offset > curbecome)
                    curbecome = p->from.offset;
            break;
        }
    }
    if(curtext && curtext->from.sym) {
        curtext->from.sym->frame = curframe;
        curtext->from.sym->become = curbecome;
        if(curbecome > maxbecome)
            maxbecome = curbecome;
    }

    if(debug['b'])
        print("max become = %d\n", maxbecome);

    xdefine("ALEFbecome", STEXT, maxbecome);

    curtext = nil;

    for(p = firstp; p != P; p = p->link) {
        switch(p->as) {
        case ATEXT:
            curtext = p;
            break;
        case ACALL:
            if(curtext != P && curtext->from.sym != S && curtext->to.offset >= 0) {
                f = maxbecome - curtext->from.sym->frame;
                if(f <= 0)
                    break;
                /* calling a become or calling a variable */
                if(p->to.sym == S || p->to.sym->become) {
                    curtext->to.offset += f;

                    if(debug['b']) {
                        curp = p;
                        print("%D calling %D increase %d\n",
                            &curtext->from, &p->to, f);
                    }
                }
            }
            break;
        }
    }

    autoffset = 0;
    deltasp = 0;
    for(p = firstp; p != P; p = p->link) {
        if(p->as == ATEXT) {
            curtext = p;

            autoffset = p->to.offset;
            if(autoffset < 0)
                autoffset = 0;
            if(autoffset) {
                p = appendp(p);
                p->as = AADJSP;
                p->from.type = D_CONST;
                p->from.offset = autoffset;
            }
            deltasp = autoffset;
        }
        a = p->from.type;
        if(a == D_LOCAL)
            p->from.offset += deltasp;
        if(a == D_PARAM)
            p->from.offset += deltasp + 4;
        a = p->to.type;
        if(a == D_LOCAL)
            p->to.offset += deltasp;
        if(a == D_PARAM)
            p->to.offset += deltasp + 4;

        switch(p->as) {
        default:
            continue;
        case APUSHL:
        case APUSHFL:
            deltasp += 4;
            continue;
        case APUSHW:
        case APUSHFW:
            deltasp += 2;
            continue;
        case APOPL:
        case APOPFL:
            deltasp -= 4;
            continue;
        case APOPW:
        case APOPFW:
            deltasp -= 2;
            continue;
        case ARET:
            break;
        }

        if(autoffset != deltasp)
            diag("unbalanced PUSH/POP");
        if(p->from.type == D_CONST)
            goto become;

        if(autoffset) {
            q = p;
            p = appendp(p);
            p->as = ARET;

            q->as = AADJSP;
            q->from.type = D_CONST;
            q->from.offset = -autoffset;
        }
        continue;

    become:
        q = p;
        p = appendp(p);
        p->as = AJMP;
        p->to = q->to;
        p->pcond = q->pcond;

        q->as = AADJSP;
        q->from = zprg.from;
        q->from.type = D_CONST;
        q->from.offset = -autoffset;
        q->to = zprg.to;
        continue;
    }
}
@

<<function appendp(x86)>>=
Prog*
appendp(Prog *q)
{
    Prog *p;

    p = prg();
    p->link = q->link;
    q->link = p;
    p->line = q->line;
    return p;
}
@

%\section{[[doinit()]]}
% x86 only

% use INITDAT and relocate from there
<<function doinit(x86)>>=
void
doinit(void)
{
    Sym *s;
    Prog *p;
    int x;

    for(p = datap; p != P; p = p->link) {
        x = p->to.type;
        if(x != D_EXTERN && x != D_STATIC)
            continue;
        s = p->to.sym;
        if(s->type == 0 || s->type == SXREF)
            diag("undefined %s initializer of %s",
                s->name, p->from.sym->name);
        p->to.offset += s->value;
        p->to.type = D_CONST;
        if(s->type == SDATA || s->type == SBSS)
            p->to.offset += INITDAT;
    }
}
@

\ifallcode
% dead on 8l, so does not really have to be a global
<<global spsize(x86)>>=
long	spsize = 0;
@
\fi

\ifallcode
<<global pcstr(x86)>>=
char*	pcstr = "%.6lux ";
@
\fi

<<function entryvalue(x86)>>=
long
entryvalue(void)
{
    char *a;
    Sym *s;

    a = INITENTRY;

    <<[[entryvalue()]] if digit INITENTRY>>

    s = lookup(a, 0);
    // no _main found, maybe pure asm, start at beginning of TEXT section (va)
    if(s->type == 0)
        return INITTEXT;

    switch(s->type) {
    case STEXT:
        return s->value;
    <<[[entryvalue()]] if dynamic module case>>
    default:
        diag("entry not text: %s", s->name);
    }
}
@


<<function zaddr(x86)>>=
int
zaddr(byte *p, Adr *a, Sym *h[])
{
    int c, t, i;
    int l;
    Sym *s;
    Auto *u;

    t = p[0];

    c = 1;
    if(t & T_INDEX) {
        a->index = p[c];
        a->scale = p[c+1];
        c += 2;
    } else {
        a->index = D_NONE;
        a->scale = 0;
    }
    a->offset = 0;
    if(t & T_OFFSET) {
        a->offset = p[c] | (p[c+1]<<8) | (p[c+2]<<16) | (p[c+3]<<24);
        c += 4;
        // >> >> >>
    }
    a->sym = S;
    if(t & T_SYM) {
        a->sym = h[p[c]];
        c++;
    }
    a->type = D_NONE;
    if(t & T_FCONST) {
        a->ieee.l = p[c] | (p[c+1]<<8) | (p[c+2]<<16) | (p[c+3]<<24);
        a->ieee.h = p[c+4] | (p[c+5]<<8) | (p[c+6]<<16) | (p[c+7]<<24);
        // >> >> >> >> >> >>
        c += 8;
        a->type = D_FCONST;
    } else
    if(t & T_SCONST) {
        for(i=0; i<NSNAME; i++)
            a->scon[i] = p[c+i];
        c += NSNAME;
        a->type = D_SCONST;
    }
    if(t & T_TYPE) {
        a->type = p[c];
        c++;
    }
    s = a->sym;
    if(s == S)
        return c;

    t = a->type;
    if(t != D_LOCAL && t != D_PARAM)
        return c;
    l = a->offset;
    for(u=curauto; u; u=u->link) {
        if(u->asym == s)
        if(u->type == t) {
            if(u->aoffset > l)
                u->aoffset = l;
            return c;
        }
    }

    // factorize!
    while(nhunk < sizeof(Auto))
        gethunk();
    u = (Auto*)hunk;
    nhunk -= sizeof(Auto);
    hunk += sizeof(Auto);

    u->link = curauto;
    curauto = u;
    u->asym = s;
    u->aoffset = l;
    u->type = t;
    return c;
}
@




<<enum pxxx(x86)>>=
enum pxxx {
    Px		= 0,
    Pe		= 0x66,	/* operand escape */
    Pm		= 0x0f,	/* 2byte opcode escape */
    Pq		= 0xff,	/* both escape */
    Pb		= 0xfe,	/* byte operands */
};


@


<<global optab(x86)>>=
Optab optab[] =
/*	as, ytab, andproto, opcode */
{
    { AXXX },
    { AAAA,		ynone,	Px, 0x37 },
    { AAAD,		ynone,	Px, 0xd5,0x0a },
    { AAAM,		ynone,	Px, 0xd4,0x0a },
    { AAAS,		ynone,	Px, 0x3f },
    { AADCB,	yxorb,	Pb, 0x14,0x80,(02),0x10,0x10 },
    { AADCL,	yxorl,	Px, 0x83,(02),0x15,0x81,(02),0x11,0x13 },
    { AADCW,	yxorl,	Pe, 0x83,(02),0x15,0x81,(02),0x11,0x13 },
    { AADDB,	yxorb,	Px, 0x04,0x80,(00),0x00,0x02 },
    { AADDL,	yaddl,	Px, 0x83,(00),0x05,0x81,(00),0x01,0x03 },
    { AADDW,	yaddl,	Pe, 0x83,(00),0x05,0x81,(00),0x01,0x03 },
    { AADJSP },
    { AANDB,	yxorb,	Pb, 0x24,0x80,(04),0x20,0x22 },
    { AANDL,	yxorl,	Px, 0x83,(04),0x25,0x81,(04),0x21,0x23 },
    { AANDW,	yxorl,	Pe, 0x83,(04),0x25,0x81,(04),0x21,0x23 },
    { AARPL,	yrl_ml,	Px, 0x63 },
    { ABOUNDL,	yrl_m,	Px, 0x62 },
    { ABOUNDW,	yrl_m,	Pe, 0x62 },
    { ABSFL,	yml_rl,	Pm, 0xbc },
    { ABSFW,	yml_rl,	Pq, 0xbc },
    { ABSRL,	yml_rl,	Pm, 0xbd },
    { ABSRW,	yml_rl,	Pq, 0xbd },
    { ABTL,		yml_rl,	Pm, 0xa3 },
    { ABTW,		yml_rl,	Pq, 0xa3 },
    { ABTCL,	yml_rl,	Pm, 0xbb },
    { ABTCW,	yml_rl,	Pq, 0xbb },
    { ABTRL,	yml_rl,	Pm, 0xb3 },
    { ABTRW,	yml_rl,	Pq, 0xb3 },
    { ABTSL,	yml_rl,	Pm, 0xab },
    { ABTSW,	yml_rl,	Pq, 0xab },
    { ABYTE,	ybyte,	Px, 1 },
    { ACALL,	ycall,	Px, 0xff,(02),0xe8 },
    { ACLC,		ynone,	Px, 0xf8 },
    { ACLD,		ynone,	Px, 0xfc },
    { ACLI,		ynone,	Px, 0xfa },
    { ACLTS,	ynone,	Pm, 0x06 },
    { ACMC,		ynone,	Px, 0xf5 },
    { ACMPB,	ycmpb,	Pb, 0x3c,0x80,(07),0x38,0x3a },
    { ACMPL,	ycmpl,	Px, 0x83,(07),0x3d,0x81,(07),0x39,0x3b },
    { ACMPW,	ycmpl,	Pe, 0x83,(07),0x3d,0x81,(07),0x39,0x3b },
    { ACMPSB,	ynone,	Pb, 0xa6 },
    { ACMPSL,	ynone,	Px, 0xa7 },
    { ACMPSW,	ynone,	Pe, 0xa7 },
    { ADAA,		ynone,	Px, 0x27 },
    { ADAS,		ynone,	Px, 0x2f },
    { ADATA },
    { ADECB,	yincb,	Pb, 0xfe,(01) },
    { ADECL,	yincl,	Px, 0x48,0xff,(01) },
    { ADECW,	yincl,	Pe, 0x48,0xff,(01) },
    { ADIVB,	ydivb,	Pb, 0xf6,(06) },
    { ADIVL,	ydivl,	Px, 0xf7,(06) },
    { ADIVW,	ydivl,	Pe, 0xf7,(06) },
    { AENTER },				/* botch */
    { AGLOBL },
    { AGOK },
    { AHISTORY },
    { AHLT,		ynone,	Px, 0xf4 },
    { AIDIVB,	ydivb,	Pb, 0xf6,(07) },
    { AIDIVL,	ydivl,	Px, 0xf7,(07) },
    { AIDIVW,	ydivl,	Pe, 0xf7,(07) },
    { AIMULB,	ydivb,	Pb, 0xf6,(05) },
    { AIMULL,	yimul,	Px, 0xf7,(05),0x6b,0x69 },
    { AIMULW,	yimul,	Pe, 0xf7,(05),0x6b,0x69 },
    { AINB,		yin,	Pb, 0xe4,0xec },
    { AINL,		yin,	Px, 0xe5,0xed },
    { AINW,		yin,	Pe, 0xe5,0xed },
    { AINCB,	yincb,	Pb, 0xfe,(00) },
    { AINCL,	yincl,	Px, 0x40,0xff,(00) },
    { AINCW,	yincl,	Pe, 0x40,0xff,(00) },
    { AINSB,	ynone,	Pb, 0x6c },
    { AINSL,	ynone,	Px, 0x6d },
    { AINSW,	ynone,	Pe, 0x6d },
    { AINT,		yint,	Px, 0xcd },
    { AINTO,	ynone,	Px, 0xce },
    { AIRETL,	ynone,	Px, 0xcf },
    { AIRETW,	ynone,	Pe, 0xcf },
    { AJCC,		yjcond,	Px, 0x73,0x83,(00) },
    { AJCS,		yjcond,	Px, 0x72,0x82 },
    { AJCXZ,	yloop,	Px, 0xe3 },
    { AJEQ,		yjcond,	Px, 0x74,0x84 },
    { AJGE,		yjcond,	Px, 0x7d,0x8d },
    { AJGT,		yjcond,	Px, 0x7f,0x8f },
    { AJHI,		yjcond,	Px, 0x77,0x87 },
    { AJLE,		yjcond,	Px, 0x7e,0x8e },
    { AJLS,		yjcond,	Px, 0x76,0x86 },
    { AJLT,		yjcond,	Px, 0x7c,0x8c },
    { AJMI,		yjcond,	Px, 0x78,0x88 },
    { AJMP,		yjmp,	Px, 0xff,(04),0xeb,0xe9 },
    { AJNE,		yjcond,	Px, 0x75,0x85 },
    { AJOC,		yjcond,	Px, 0x71,0x81,(00) },
    { AJOS,		yjcond,	Px, 0x70,0x80,(00) },
    { AJPC,		yjcond,	Px, 0x7b,0x8b },
    { AJPL,		yjcond,	Px, 0x79,0x89 },
    { AJPS,		yjcond,	Px, 0x7a,0x8a },
    { ALAHF,	ynone,	Px, 0x9f },
    { ALARL,	yml_rl,	Pm, 0x02 },
    { ALARW,	yml_rl,	Pq, 0x02 },
    { ALEAL,	ym_rl,	Px, 0x8d },
    { ALEAW,	ym_rl,	Pe, 0x8d },
    { ALEAVEL,	ynone,	Px, 0xc9 },
    { ALEAVEW,	ynone,	Pe, 0xc9 },
    { ALOCK,	ynone,	Px, 0xf0 },
    { ALODSB,	ynone,	Pb, 0xac },
    { ALODSL,	ynone,	Px, 0xad },
    { ALODSW,	ynone,	Pe, 0xad },
    { ALONG,	ybyte,	Px, 4 },
    { ALOOP,	yloop,	Px, 0xe2 },
    { ALOOPEQ,	yloop,	Px, 0xe1 },
    { ALOOPNE,	yloop,	Px, 0xe0 },
    { ALSLL,	yml_rl,	Pm, 0x03  },
    { ALSLW,	yml_rl,	Pq, 0x03  },
    { AMOVB,	ymovb,	Pb, 0x88,0x8a,0xb0,0xc6,(00) },
    { AMOVL,	ymovl,	Px, 0x89,0x8b,0x31,0x83,(04),0xb8,0xc7,(00) },
    { AMOVW,	ymovl,	Pe, 0x89,0x8b,0x31,0x83,(04),0xb8,0xc7,(00) },
    { AMOVBLSX,	ymb_rl,	Pm, 0xbe },
    { AMOVBLZX,	ymb_rl,	Pm, 0xb6 },
    { AMOVBWSX,	ymb_rl,	Pq, 0xbe },
    { AMOVBWZX,	ymb_rl,	Pq, 0xb6 },
    { AMOVWLSX,	yml_rl,	Pm, 0xbf },
    { AMOVWLZX,	yml_rl,	Pm, 0xb7 },
    { AMOVSB,	ynone,	Pb, 0xa4 },
    { AMOVSL,	ynone,	Px, 0xa5 },
    { AMOVSW,	ynone,	Pe, 0xa5 },
    { AMULB,	ydivb,	Pb, 0xf6,(04) },
    { AMULL,	ydivl,	Px, 0xf7,(04) },
    { AMULW,	ydivl,	Pe, 0xf7,(04) },
    { ANAME },
    { ANEGB,	yscond,	Px, 0xf6,(03) },
    { ANEGL,	yscond,	Px, 0xf7,(03) },
    { ANEGW,	yscond,	Pe, 0xf7,(03) },
    { ANOP,		ynop,	Px,0,0 },
    { ANOTB,	yscond,	Px, 0xf6,(02) },
    { ANOTL,	yscond,	Px, 0xf7,(02) },
    { ANOTW,	yscond,	Pe, 0xf7,(02) },
    { AORB,		yxorb,	Pb, 0x0c,0x80,(01),0x08,0x0a },
    { AORL,		yxorl,	Px, 0x83,(01),0x0d,0x81,(01),0x09,0x0b },
    { AORW,		yxorl,	Pe, 0x83,(01),0x0d,0x81,(01),0x09,0x0b },
    { AOUTB,	yin,	Pb, 0xe6,0xee },
    { AOUTL,	yin,	Px, 0xe7,0xef },
    { AOUTW,	yin,	Pe, 0xe7,0xef },
    { AOUTSB,	ynone,	Pb, 0x6e },
    { AOUTSL,	ynone,	Px, 0x6f },
    { AOUTSW,	ynone,	Pe, 0x6f },
    { APOPAL,	ynone,	Px, 0x61 },
    { APOPAW,	ynone,	Pe, 0x61 },
    { APOPFL,	ynone,	Px, 0x9d },
    { APOPFW,	ynone,	Pe, 0x9d },
    { APOPL,	ypopl,	Px, 0x58,0x8f,(00) },
    { APOPW,	ypopl,	Pe, 0x58,0x8f,(00) },
    { APUSHAL,	ynone,	Px, 0x60 },
    { APUSHAW,	ynone,	Pe, 0x60 },
    { APUSHFL,	ynone,	Px, 0x9c },
    { APUSHFW,	ynone,	Pe, 0x9c },
    { APUSHL,	ypushl,	Px, 0x50,0xff,(06),0x6a,0x68 },
    { APUSHW,	ypushl,	Pe, 0x50,0xff,(06),0x6a,0x68 },
    { ARCLB,	yshb,	Pb, 0xd0,(02),0xc0,(02),0xd2,(02) },
    { ARCLL,	yshl,	Px, 0xd1,(02),0xc1,(02),0xd3,(02),0xd3,(02) },
    { ARCLW,	yshl,	Pe, 0xd1,(02),0xc1,(02),0xd3,(02),0xd3,(02) },
    { ARCRB,	yshb,	Pb, 0xd0,(03),0xc0,(03),0xd2,(03) },
    { ARCRL,	yshl,	Px, 0xd1,(03),0xc1,(03),0xd3,(03),0xd3,(03) },
    { ARCRW,	yshl,	Pe, 0xd1,(03),0xc1,(03),0xd3,(03),0xd3,(03) },
    { AREP,		ynone,	Px, 0xf3 },
    { AREPN,	ynone,	Px, 0xf2 },
    { ARET,		ynone,	Px, 0xc3 },
    { AROLB,	yshb,	Pb, 0xd0,(00),0xc0,(00),0xd2,(00) },
    { AROLL,	yshl,	Px, 0xd1,(00),0xc1,(00),0xd3,(00),0xd3,(00) },
    { AROLW,	yshl,	Pe, 0xd1,(00),0xc1,(00),0xd3,(00),0xd3,(00) },
    { ARORB,	yshb,	Pb, 0xd0,(01),0xc0,(01),0xd2,(01) },
    { ARORL,	yshl,	Px, 0xd1,(01),0xc1,(01),0xd3,(01),0xd3,(01) },
    { ARORW,	yshl,	Pe, 0xd1,(01),0xc1,(01),0xd3,(01),0xd3,(01) },
    { ASAHF,	ynone,	Px, 0x9e },
    { ASALB,	yshb,	Pb, 0xd0,(04),0xc0,(04),0xd2,(04) },
    { ASALL,	yshl,	Px, 0xd1,(04),0xc1,(04),0xd3,(04),0xd3,(04) },
    { ASALW,	yshl,	Pe, 0xd1,(04),0xc1,(04),0xd3,(04),0xd3,(04) },
    { ASARB,	yshb,	Pb, 0xd0,(07),0xc0,(07),0xd2,(07) },
    { ASARL,	yshl,	Px, 0xd1,(07),0xc1,(07),0xd3,(07),0xd3,(07) },
    { ASARW,	yshl,	Pe, 0xd1,(07),0xc1,(07),0xd3,(07),0xd3,(07) },
    { ASBBB,	yxorb,	Pb, 0x1c,0x80,(03),0x18,0x1a },
    { ASBBL,	yxorl,	Px, 0x83,(03),0x1d,0x81,(03),0x19,0x1b },
    { ASBBW,	yxorl,	Pe, 0x83,(03),0x1d,0x81,(03),0x19,0x1b },
    { ASCASB,	ynone,	Pb, 0xae },
    { ASCASL,	ynone,	Px, 0xaf },
    { ASCASW,	ynone,	Pe, 0xaf },
    { ASETCC,	yscond,	Pm, 0x93,(00) },
    { ASETCS,	yscond,	Pm, 0x92,(00) },
    { ASETEQ,	yscond,	Pm, 0x94,(00) },
    { ASETGE,	yscond,	Pm, 0x9d,(00) },
    { ASETGT,	yscond,	Pm, 0x9f,(00) },
    { ASETHI,	yscond,	Pm, 0x97,(00) },
    { ASETLE,	yscond,	Pm, 0x9e,(00) },
    { ASETLS,	yscond,	Pm, 0x96,(00) },
    { ASETLT,	yscond,	Pm, 0x9c,(00) },
    { ASETMI,	yscond,	Pm, 0x98,(00) },
    { ASETNE,	yscond,	Pm, 0x95,(00) },
    { ASETOC,	yscond,	Pm, 0x91,(00) },
    { ASETOS,	yscond,	Pm, 0x90,(00) },
    { ASETPC,	yscond,	Pm, 0x96,(00) },
    { ASETPL,	yscond,	Pm, 0x99,(00) },
    { ASETPS,	yscond,	Pm, 0x9a,(00) },
    { ACDQ,		ynone,	Px, 0x99 },
    { ACWD,		ynone,	Pe, 0x99 },
    { ASHLB,	yshb,	Pb, 0xd0,(04),0xc0,(04),0xd2,(04) },
    { ASHLL,	yshl,	Px, 0xd1,(04),0xc1,(04),0xd3,(04),0xd3,(04) },
    { ASHLW,	yshl,	Pe, 0xd1,(04),0xc1,(04),0xd3,(04),0xd3,(04) },
    { ASHRB,	yshb,	Pb, 0xd0,(05),0xc0,(05),0xd2,(05) },
    { ASHRL,	yshl,	Px, 0xd1,(05),0xc1,(05),0xd3,(05),0xd3,(05) },
    { ASHRW,	yshl,	Pe, 0xd1,(05),0xc1,(05),0xd3,(05),0xd3,(05) },
    { ASTC,		ynone,	Px, 0xf9 },
    { ASTD,		ynone,	Px, 0xfd },
    { ASTI,		ynone,	Px, 0xfb },
    { ASTOSB,	ynone,	Pb, 0xaa },
    { ASTOSL,	ynone,	Px, 0xab },
    { ASTOSW,	ynone,	Pe, 0xab },
    { ASUBB,	yxorb,	Pb, 0x2c,0x80,(05),0x28,0x2a },
    { ASUBL,	yaddl,	Px, 0x83,(05),0x2d,0x81,(05),0x29,0x2b },
    { ASUBW,	yaddl,	Pe, 0x83,(05),0x2d,0x81,(05),0x29,0x2b },
    { ASYSCALL,	ynone,	Px, 0xcd,100 },
    { ATESTB,	ytestb,	Pb, 0xa8,0xf6,(00),0x84,0x84 },
    { ATESTL,	ytestl,	Px, 0xa9,0xf7,(00),0x85,0x85 },
    { ATESTW,	ytestl,	Pe, 0xa9,0xf7,(00),0x85,0x85 },
    { ATEXT,	ytext,	Px },
    { AVERR,	ydivl,	Pm, 0x00,(04) },
    { AVERW,	ydivl,	Pm, 0x00,(05) },
    { AWAIT,	ynone,	Px, 0x9b },
    { AWORD,	ybyte,	Px, 2 },
    { AXCHGB,	yml_mb,	Pb, 0x86,0x86 },
    { AXCHGL,	yml_ml,	Px, 0x87,0x87 },
    { AXCHGW,	yml_ml,	Pe, 0x87,0x87 },
    { AXLAT,	ynone,	Px, 0xd7 },
    { AXORB,	yxorb,	Pb, 0x34,0x80,(06),0x30,0x32 },
    { AXORL,	yxorl,	Px, 0x83,(06),0x35,0x81,(06),0x31,0x33 },
    { AXORW,	yxorl,	Pe, 0x83,(06),0x35,0x81,(06),0x31,0x33 },

    { AFMOVB,	yfmvx,	Px, 0xdf,(04) },
    { AFMOVBP,	yfmvp,	Px, 0xdf,(06) },
    { AFMOVD,	yfmvd,	Px, 0xdd,(00),0xdd,(02),0xd9,(00),0xdd,(02) },
    { AFMOVDP,	yfmvdp,	Px, 0xdd,(03),0xdd,(03) },
    { AFMOVF,	yfmvf,	Px, 0xd9,(00),0xd9,(02) },
    { AFMOVFP,	yfmvp,	Px, 0xd9,(03) },
    { AFMOVL,	yfmvf,	Px, 0xdb,(00),0xdb,(02) },
    { AFMOVLP,	yfmvp,	Px, 0xdb,(03) },
    { AFMOVV,	yfmvx,	Px, 0xdf,(05) },
    { AFMOVVP,	yfmvp,	Px, 0xdf,(07) },
    { AFMOVW,	yfmvf,	Px, 0xdf,(00),0xdf,(02) },
    { AFMOVWP,	yfmvp,	Px, 0xdf,(03) },
    { AFMOVX,	yfmvx,	Px, 0xdb,(05) },
    { AFMOVXP,	yfmvp,	Px, 0xdb,(07) },

    { AFCOMB },
    { AFCOMBP },
    { AFCOMD,	yfadd,	Px, 0xdc,(02),0xd8,(02),0xdc,(02) },	/* botch */
    { AFCOMDP,	yfadd,	Px, 0xdc,(03),0xd8,(03),0xdc,(03) },	/* botch */
    { AFCOMDPP,	ycompp,	Px, 0xde,(03) },
    { AFCOMF,	yfmvx,	Px, 0xd8,(02) },
    { AFCOMFP,	yfmvx,	Px, 0xd8,(03) },
    { AFCOML,	yfmvx,	Px, 0xda,(02) },
    { AFCOMLP,	yfmvx,	Px, 0xda,(03) },
    { AFCOMW,	yfmvx,	Px, 0xde,(02) },
    { AFCOMWP,	yfmvx,	Px, 0xde,(03) },

    { AFUCOM,	ycompp,	Px, 0xdd,(04) },
    { AFUCOMP,	ycompp, Px, 0xdd,(05) },
    { AFUCOMPP,	ycompp,	Px, 0xda,(13) },

    { AFADDDP,	yfaddp,	Px, 0xde,(00) },
    { AFADDW,	yfmvx,	Px, 0xde,(00) },
    { AFADDL,	yfmvx,	Px, 0xda,(00) },
    { AFADDF,	yfmvx,	Px, 0xd8,(00) },
    { AFADDD,	yfadd,	Px, 0xdc,(00),0xd8,(00),0xdc,(00) },

    { AFMULDP,	yfaddp,	Px, 0xde,(01) },
    { AFMULW,	yfmvx,	Px, 0xde,(01) },
    { AFMULL,	yfmvx,	Px, 0xda,(01) },
    { AFMULF,	yfmvx,	Px, 0xd8,(01) },
    { AFMULD,	yfadd,	Px, 0xdc,(01),0xd8,(01),0xdc,(01) },

    { AFSUBDP,	yfaddp,	Px, 0xde,(05) },
    { AFSUBW,	yfmvx,	Px, 0xde,(04) },
    { AFSUBL,	yfmvx,	Px, 0xda,(04) },
    { AFSUBF,	yfmvx,	Px, 0xd8,(04) },
    { AFSUBD,	yfadd,	Px, 0xdc,(04),0xd8,(04),0xdc,(05) },

    { AFSUBRDP,	yfaddp,	Px, 0xde,(04) },
    { AFSUBRW,	yfmvx,	Px, 0xde,(05) },
    { AFSUBRL,	yfmvx,	Px, 0xda,(05) },
    { AFSUBRF,	yfmvx,	Px, 0xd8,(05) },
    { AFSUBRD,	yfadd,	Px, 0xdc,(05),0xd8,(05),0xdc,(04) },

    { AFDIVDP,	yfaddp,	Px, 0xde,(07) },
    { AFDIVW,	yfmvx,	Px, 0xde,(06) },
    { AFDIVL,	yfmvx,	Px, 0xda,(06) },
    { AFDIVF,	yfmvx,	Px, 0xd8,(06) },
    { AFDIVD,	yfadd,	Px, 0xdc,(06),0xd8,(06),0xdc,(07) },

    { AFDIVRDP,	yfaddp,	Px, 0xde,(06) },
    { AFDIVRW,	yfmvx,	Px, 0xde,(07) },
    { AFDIVRL,	yfmvx,	Px, 0xda,(07) },
    { AFDIVRF,	yfmvx,	Px, 0xd8,(07) },
    { AFDIVRD,	yfadd,	Px, 0xdc,(07),0xd8,(07),0xdc,(06) },

    { AFXCHD,	yfxch,	Px, 0xd9,(01),0xd9,(01) },
    { AFFREE },
    { AFLDCW,	ystcw,	Px, 0xd9,(05),0xd9,(05) },
    { AFLDENV,	ystcw,	Px, 0xd9,(04),0xd9,(04) },
    { AFRSTOR,	ysvrs,	Px, 0xdd,(04),0xdd,(04) },
    { AFSAVE,	ysvrs,	Px, 0xdd,(06),0xdd,(06) },
    { AFSTCW,	ystcw,	Px, 0xd9,(07),0xd9,(07) },
    { AFSTENV,	ystcw,	Px, 0xd9,(06),0xd9,(06) },
    { AFSTSW,	ystsw,	Px, 0xdd,(07),0xdf,0xe0 },
    { AF2XM1,	ynone,	Px, 0xd9, 0xf0 },
    { AFABS,	ynone,	Px, 0xd9, 0xe1 },
    { AFCHS,	ynone,	Px, 0xd9, 0xe0 },
    { AFCLEX,	ynone,	Px, 0xdb, 0xe2 },
    { AFCOS,	ynone,	Px, 0xd9, 0xff },
    { AFDECSTP,	ynone,	Px, 0xd9, 0xf6 },
    { AFINCSTP,	ynone,	Px, 0xd9, 0xf7 },
    { AFINIT,	ynone,	Px, 0xdb, 0xe3 },
    { AFLD1,	ynone,	Px, 0xd9, 0xe8 },
    { AFLDL2E,	ynone,	Px, 0xd9, 0xea },
    { AFLDL2T,	ynone,	Px, 0xd9, 0xe9 },
    { AFLDLG2,	ynone,	Px, 0xd9, 0xec },
    { AFLDLN2,	ynone,	Px, 0xd9, 0xed },
    { AFLDPI,	ynone,	Px, 0xd9, 0xeb },
    { AFLDZ,	ynone,	Px, 0xd9, 0xee },
    { AFNOP,	ynone,	Px, 0xd9, 0xd0 },
    { AFPATAN,	ynone,	Px, 0xd9, 0xf3 },
    { AFPREM,	ynone,	Px, 0xd9, 0xf8 },
    { AFPREM1,	ynone,	Px, 0xd9, 0xf5 },
    { AFPTAN,	ynone,	Px, 0xd9, 0xf2 },
    { AFRNDINT,	ynone,	Px, 0xd9, 0xfc },
    { AFSCALE,	ynone,	Px, 0xd9, 0xfd },
    { AFSIN,	ynone,	Px, 0xd9, 0xfe },
    { AFSINCOS,	ynone,	Px, 0xd9, 0xfb },
    { AFSQRT,	ynone,	Px, 0xd9, 0xfa },
    { AFTST,	ynone,	Px, 0xd9, 0xe4 },
    { AFXAM,	ynone,	Px, 0xd9, 0xe5 },
    { AFXTRACT,	ynone,	Px, 0xd9, 0xf4 },
    { AFYL2X,	ynone,	Px, 0xd9, 0xf1 },
    { AFYL2XP1,	ynone,	Px, 0xd9, 0xf9 },
    { AEND },
    0
};
@



%\section{[[Yxxx]]}

<<enum yxxx(x86)>>=
enum yxxx {
    Yxxx		= 0,
    Ynone,
    Yi0,
    Yi1,
    Yi8,
    Yi32,

    Yiauto,

    Yal,
    Ycl,
    Yax,
    Ycx,
    Yrb,
    Yrl,
    Yrf,
    Yf0,
    Yrx,
    Ymb,
    Yml,
    Ym,
    Ybr,
    Ycol,

    Ycs,	Yss,	Yds,	Yes,	Yfs,	Ygs,
    Ygdtr,	Yidtr,	Yldtr,	Ymsw,	Ytask,
    Ycr0,	Ycr1,	Ycr2,	Ycr3,	Ycr4,	Ycr5,	Ycr6,	Ycr7,
    Ydr0,	Ydr1,	Ydr2,	Ydr3,	Ydr4,	Ydr5,	Ydr6,	Ydr7,
    Ytr0,	Ytr1,	Ytr2,	Ytr3,	Ytr4,	Ytr5,	Ytr6,	Ytr7,

    Ymax,
};
@

%\section{[[Zxxx]]}

<<enum zxxx(x86)>>=
enum zxxx {
    Zxxx		= 0,

    Zlit,
    Z_rp,
    Zbr,
    Zcall,
    Zib_,
    Zib_rp,
    Zibo_m,
    Zil_,
    Zil_rp,
    Zilo_m,
    Zjmp,
    Zloop,
    Zm_o,
    Zm_r,
    Zaut_r,
    Zo_m,
    Zpseudo,
    Zr_m,
    Zrp_,
    Z_ib,
    Z_il,
    Zm_ibo,
    Zm_ilo,
    Zib_rr,
    Zil_rr,
    Zclr,
    Zbyte,
    Zmov,
    Zmax,
};
@

%\section{[[yxxx]]}

<<global ynone(x86)>>=
byte	ynone[] =
{
    Ynone,	Ynone,	Zlit,	1,
    0
};
@

<<global ytext(x86)>>=
byte	ytext[] =
{
    Ymb,	Yi32,	Zpseudo,1,
    0
};
@

<<global ynop(x86)>>=
byte	ynop[] =
{
    Ynone,	Ynone,	Zpseudo,1,
    Ynone,	Yml,	Zpseudo,1,
    Ynone,	Yrf,	Zpseudo,1,
    Yml,	Ynone,	Zpseudo,1,
    Yrf,	Ynone,	Zpseudo,1,
    0
};
@

<<global yxorb(x86)>>=
byte	yxorb[] =
{
    Yi32,	Yal,	Zib_,	1,
    Yi32,	Ymb,	Zibo_m,	2,
    Yrb,	Ymb,	Zr_m,	1,
    Ymb,	Yrb,	Zm_r,	1,
    0
};
@

<<global yxorl(x86)>>=
byte	yxorl[] =
{
    Yi8,	Yml,	Zibo_m,	2,
    Yi32,	Yax,	Zil_,	1,
    Yi32,	Yml,	Zilo_m,	2,
    Yrl,	Yml,	Zr_m,	1,
    Yml,	Yrl,	Zm_r,	1,
    0
};
@

<<global yaddl(x86)>>=
byte	yaddl[] =
{
    Yi8,	Yml,	Zibo_m,	2,
    Yi32,	Yax,	Zil_,	1,
    Yi32,	Yml,	Zilo_m,	2,
    Yrl,	Yml,	Zr_m,	1,
    Yml,	Yrl,	Zm_r,	1,
    0
};
@

<<global yincb(x86)>>=
byte	yincb[] =
{
    Ynone,	Ymb,	Zo_m,	2,
    0
};
@

<<global yincl(x86)>>=
byte	yincl[] =
{
    Ynone,	Yrl,	Z_rp,	1,
    Ynone,	Yml,	Zo_m,	2,
    0
};
@

<<global ycmpb(x86)>>=
byte	ycmpb[] =
{
    Yal,	Yi32,	Z_ib,	1,
    Ymb,	Yi32,	Zm_ibo,	2,
    Ymb,	Yrb,	Zm_r,	1,
    Yrb,	Ymb,	Zr_m,	1,
    0
};
@

<<global ycmpl(x86)>>=
byte	ycmpl[] =
{
    Yml,	Yi8,	Zm_ibo,	2,
    Yax,	Yi32,	Z_il,	1,
    Yml,	Yi32,	Zm_ilo,	2,
    Yml,	Yrl,	Zm_r,	1,
    Yrl,	Yml,	Zr_m,	1,
    0
};
@

<<global yshb(x86)>>=
byte	yshb[] =
{
    Yi1,	Ymb,	Zo_m,	2,
    Yi32,	Ymb,	Zibo_m,	2,
    Ycx,	Ymb,	Zo_m,	2,
    0
};
@

<<global yshl(x86)>>=
byte	yshl[] =
{
    Yi1,	Yml,	Zo_m,	2,
    Yi32,	Yml,	Zibo_m,	2,
    Ycl,	Yml,	Zo_m,	2,
    Ycx,	Yml,	Zo_m,	2,
    0
};
@

<<global ytestb(x86)>>=
byte	ytestb[] =
{
    Yi32,	Yal,	Zib_,	1,
    Yi32,	Ymb,	Zibo_m,	2,
    Yrb,	Ymb,	Zr_m,	1,
    Ymb,	Yrb,	Zm_r,	1,
    0
};
@

<<global ytestl(x86)>>=
byte	ytestl[] =
{
    Yi32,	Yax,	Zil_,	1,
    Yi32,	Yml,	Zilo_m,	2,
    Yrl,	Yml,	Zr_m,	1,
    Yml,	Yrl,	Zm_r,	1,
    0
};
@

<<global ymovb(x86)>>=
byte	ymovb[] =
{
    Yrb,	Ymb,	Zr_m,	1,
    Ymb,	Yrb,	Zm_r,	1,
    Yi32,	Yrb,	Zib_rp,	1,
    Yi32,	Ymb,	Zibo_m,	2,
    0
};
@

<<global ymovl(x86)>>=
byte	ymovl[] =
{
    Yrl,	Yml,	Zr_m,	1,
    Yml,	Yrl,	Zm_r,	1,
    Yi0,	Yrl,	Zclr,	1+2,
//	Yi0,	Yml,	Zibo_m,	2,	// shorter but slower AND $0,dst
    Yi32,	Yrl,	Zil_rp,	1,
    Yi32,	Yml,	Zilo_m,	2,
    Yiauto,	Yrl,	Zaut_r,	2,
    0
};
@
%$

<<global ym_rl(x86)>>=
byte	ym_rl[] =
{
    Ym,	Yrl,	Zm_r,	1,
    0
};
@

<<global yrl_m(x86)>>=
byte	yrl_m[] =
{
    Yrl,	Ym,	Zr_m,	1,
    0
};
@

<<global ymb_rl(x86)>>=
byte	ymb_rl[] =
{
    Ymb,	Yrl,	Zm_r,	1,
    0
};
@

<<global yml_rl(x86)>>=
byte	yml_rl[] =
{
    Yml,	Yrl,	Zm_r,	1,
    0
};
@

<<global yrl_ml(x86)>>=
byte	yrl_ml[] =
{
    Yrl,	Yml,	Zr_m,	1,
    0
};
@

<<global yml_mb(x86)>>=
byte	yml_mb[] =
{
    Yrb,	Ymb,	Zr_m,	1,
    Ymb,	Yrb,	Zm_r,	1,
    0
};
@

<<global yml_ml(x86)>>=
byte	yml_ml[] =
{
    Yrl,	Yml,	Zr_m,	1,
    Yml,	Yrl,	Zm_r,	1,
    0
};
@

<<global ydivl(x86)>>=
byte	ydivl[] =
{
    Yml,	Ynone,	Zm_o,	2,
    0
};
@

<<global ydivb(x86)>>=
byte	ydivb[] =
{
    Ymb,	Ynone,	Zm_o,	2,
    0
};
@

<<global yimul(x86)>>=
byte	yimul[] =
{
    Yml,	Ynone,	Zm_o,	2,
    Yi8,	Yrl,	Zib_rr,	1,
    Yi32,	Yrl,	Zil_rr,	1,
    0
};
@

<<global ybyte(x86)>>=
byte	ybyte[] =
{
    Yi32,	Ynone,	Zbyte,	1,
    0
};
@

<<global yin(x86)>>=
byte	yin[] =
{
    Yi32,	Ynone,	Zib_,	1,
    Ynone,	Ynone,	Zlit,	1,
    0
};
@

<<global yint(x86)>>=
byte	yint[] =
{
    Yi32,	Ynone,	Zib_,	1,
    0
};
@

<<global ypushl(x86)>>=
byte	ypushl[] =
{
    Yrl,	Ynone,	Zrp_,	1,
    Ym,	Ynone,	Zm_o,	2,
    Yi8,	Ynone,	Zib_,	1,
    Yi32,	Ynone,	Zil_,	1,
    0
};
@

<<global ypopl(x86)>>=
byte	ypopl[] =
{
    Ynone,	Yrl,	Z_rp,	1,
    Ynone,	Ym,	Zo_m,	2,
    0
};
@

<<global yscond(x86)>>=
byte	yscond[] =
{
    Ynone,	Ymb,	Zo_m,	2,
    0
};
@

<<global yjcond(x86)>>=
byte	yjcond[] =
{
    Ynone,	Ybr,	Zbr,	1,
    0
};
@

<<global yloop(x86)>>=
byte	yloop[] =
{
    Ynone,	Ybr,	Zloop,	1,
    0
};
@

<<global ycall(x86)>>=
byte	ycall[] =
{
    Ynone,	Yml,	Zo_m,	2,
    Ynone,	Ybr,	Zcall,	1,
    0
};
@

<<global yjmp(x86)>>=
byte	yjmp[] =
{
    Ynone,	Yml,	Zo_m,	2,
    Ynone,	Ybr,	Zjmp,	1,
    0
};
@

<<global yfmvd(x86)>>=
byte	yfmvd[] =
{
    Ym,	Yf0,	Zm_o,	2,
    Yf0,	Ym,	Zo_m,	2,
    Yrf,	Yf0,	Zm_o,	2,
    Yf0,	Yrf,	Zo_m,	2,
    0
};
@

<<global yfmvdp(x86)>>=
byte	yfmvdp[] =
{
    Yf0,	Ym,	Zo_m,	2,
    Yf0,	Yrf,	Zo_m,	2,
    0
};
@

<<global yfmvf(x86)>>=
byte	yfmvf[] =
{
    Ym,	Yf0,	Zm_o,	2,
    Yf0,	Ym,	Zo_m,	2,
    0
};
@

<<global yfmvx(x86)>>=
byte	yfmvx[] =
{
    Ym,	Yf0,	Zm_o,	2,
    0
};
@

<<global yfmvp(x86)>>=
byte	yfmvp[] =
{
    Yf0,	Ym,	Zo_m,	2,
    0
};
@

<<global yfadd(x86)>>=
byte	yfadd[] =
{
    Ym,	Yf0,	Zm_o,	2,
    Yrf,	Yf0,	Zm_o,	2,
    Yf0,	Yrf,	Zo_m,	2,
    0
};
@

<<global yfaddp(x86)>>=
byte	yfaddp[] =
{
    Yf0,	Yrf,	Zo_m,	2,
    0
};
@

<<global yfxch(x86)>>=
byte	yfxch[] =
{
    Yf0,	Yrf,	Zo_m,	2,
    Yrf,	Yf0,	Zm_o,	2,
    0
};
@

<<global ycompp(x86)>>=
byte	ycompp[] =
{
    Yf0,	Yrf,	Zo_m,	2,	/* botch is really f0,f1 */
    0
};
@

<<global ystsw(x86)>>=
byte	ystsw[] =
{
    Ynone,	Ym,	Zo_m,	2,
    Ynone,	Yax,	Zlit,	1,
    0
};
@

<<global ystcw(x86)>>=
byte	ystcw[] =
{
    Ynone,	Ym,	Zo_m,	2,
    Ym,	Ynone,	Zm_o,	2,
    0
};
@

<<global ysvrs(x86)>>=
byte	ysvrs[] =
{
    Ynone,	Ym,	Zo_m,	2,
    Ym,	Ynone,	Zm_o,	2,
    0
};
@

%\section{[[ycover]]}

<<global ycover(x86)>>=
char	ycover[Ymax*Ymax];
@

<<[[main()]] set ycover(x86)>>=
for(i=0; i<Ymax; i++)
    ycover[i*Ymax + i] = 1;

ycover[Yi0*Ymax + Yi8] = 1;
ycover[Yi1*Ymax + Yi8] = 1;

ycover[Yi0*Ymax + Yi32] = 1;
ycover[Yi1*Ymax + Yi32] = 1;
ycover[Yi8*Ymax + Yi32] = 1;

ycover[Yal*Ymax + Yrb] = 1;
ycover[Ycl*Ymax + Yrb] = 1;
ycover[Yax*Ymax + Yrb] = 1;
ycover[Ycx*Ymax + Yrb] = 1;
ycover[Yrx*Ymax + Yrb] = 1;

ycover[Yax*Ymax + Yrx] = 1;
ycover[Ycx*Ymax + Yrx] = 1;

ycover[Yax*Ymax + Yrl] = 1;
ycover[Ycx*Ymax + Yrl] = 1;
ycover[Yrx*Ymax + Yrl] = 1;

ycover[Yf0*Ymax + Yrf] = 1;

ycover[Yal*Ymax + Ymb] = 1;
ycover[Ycl*Ymax + Ymb] = 1;
ycover[Yax*Ymax + Ymb] = 1;
ycover[Ycx*Ymax + Ymb] = 1;
ycover[Yrx*Ymax + Ymb] = 1;
ycover[Yrb*Ymax + Ymb] = 1;
ycover[Ym*Ymax + Ymb] = 1;

ycover[Yax*Ymax + Yml] = 1;
ycover[Ycx*Ymax + Yml] = 1;
ycover[Yrx*Ymax + Yml] = 1;
ycover[Yrl*Ymax + Yml] = 1;
ycover[Ym*Ymax + Yml] = 1;
@

%\section{[[reg]]}
<<global reg(x86)>>=
char	reg[D_NONE];
@

<<[[main()]] set reg(x86)>>=
for(i=0; i<D_NONE; i++) {
    reg[i] = -1;
    if(i >= D_AL && i <= D_BH)
        reg[i] = (i-D_AL) & 7;
    if(i >= D_AX && i <= D_DI)
        reg[i] = (i-D_AX) & 7;
    if(i >= D_F0 && i <= D_F0+7)
        reg[i] = (i-D_F0) & 7;
}
@

% asmb -> <>
<<function asmsym(x86)>>=
void
asmsym(void)
{
    Prog *p;
    Auto *a;
    Sym *s;
    int h;

    s = lookup("etext", 0);
    if(s->type == STEXT)
        putsymb(s->name, 'T', s->value, s->version);

    for(h=0; h<NHASH; h++)
        for(s=hash[h]; s!=S; s=s->link)
            switch(s->type) {
            case SCONST:
                putsymb(s->name, 'D', s->value, s->version);
                continue;

            case SDATA:
                putsymb(s->name, 'D', s->value+INITDAT, s->version);
                continue;

            case SBSS:
                putsymb(s->name, 'B', s->value+INITDAT, s->version);
                continue;

            case SFILE:
                putsymb(s->name, 'f', s->value, s->version);
                continue;
            }

    for(p=textp; p!=P; p=p->pcond) {
        s = p->from.sym;
        if(s->type != STEXT)
            continue;

        /* filenames first */
        for(a=p->to.autom; a; a=a->link)
            if(a->type == D_FILE)
                putsymb(a->asym->name, 'z', a->aoffset, 0);
            else
            if(a->type == D_FILE1)
                putsymb(a->asym->name, 'Z', a->aoffset, 0);

        putsymb(s->name, 'T', s->value, s->version);

        /* frame, auto and param after */
        putsymb(".frame", 'm', p->to.offset+4, 0);

        for(a=p->to.autom; a; a=a->link)
            if(a->type == D_LOCAL)
                putsymb(a->asym->name, 'a', -a->aoffset, 0);
            else
            if(a->type == D_PARAM)
                putsymb(a->asym->name, 'p', a->aoffset, 0);
    }

    if(debug['v'] || debug['n'])
        DBG("symsize = %lud\n", symsize);
}
@


<<function doprof1(x86)>>=
void
doprof1(void)
{
    Sym *s;
    long n;
    Prog *p, *q;

    DBG("%5.2f profile 1\n", cputime());

    s = lookup("__mcount", 0);
    n = 1;
    for(p = firstp->link; p != P; p = p->link) {
        if(p->as == ATEXT) {
            q = prg();
            q->line = p->line;

            q->link = datap;
            datap = q;

            //asm: DATA __mcount ??? array? why need to declare it here too?
            q->as = ADATA;
            q->from.type = D_EXTERN;
            q->from.offset = n*4;
            q->from.sym = s; // __mcount
            q->from.scale = 4;  // NOSPLIT?
            q->to = p->from;
            q->to.type = D_CONST;

            q = prg();
            q->line = p->line;
            q->pc = p->pc;

            q->link = p->link;
            p->link = q;
            p = q;

            //asm: ADDL 1, __mcount[n]?
            p->as = AADDL;
            p->from.type = D_CONST;
            p->from.offset = 1;
            p->to.type = D_EXTERN;
            p->to.sym = s;
            p->to.offset = n*4 + 4;

            n += 2;
            continue;
        }
    }

    q = prg();
    q->line = 0;

    q->link = datap;
    datap = q;

    //asm: DATA __mcount ???
    q->as = ADATA;
    q->from.type = D_EXTERN;
    q->from.sym = s;
    q->from.scale = 4;  // NOSPLIT?
    q->to.type = D_CONST;
    q->to.offset = n;

    s->type = SBSS;
    // 4 bytes counter for each functions
    s->value = n*4;
}
@


<<function nuxiinit(x86)>>=
void
nuxiinit(void)
{
    int i, c;

    for(i=0; i<4; i++) {
        c = find1(0x04030201L, i+1);
        if(i < 2)
            inuxi2[i] = c;
        if(i < 1)
            inuxi1[i] = c;
        inuxi4[i] = c;
        fnuxi4[i] = c;
        fnuxi8[i] = c;
        fnuxi8[i+4] = c+4;
    }
    if(debug['v']) {
        Bprint(&bso, "inuxi = ");
        for(i=0; i<1; i++)
            Bprint(&bso, "%d", inuxi1[i]);
        Bprint(&bso, " ");
        for(i=0; i<2; i++)
            Bprint(&bso, "%d", inuxi2[i]);
        Bprint(&bso, " ");
        for(i=0; i<4; i++)
            Bprint(&bso, "%d", inuxi4[i]);
        Bprint(&bso, "\nfnuxi = ");
        for(i=0; i<4; i++)
            Bprint(&bso, "%d", fnuxi4[i]);
        Bprint(&bso, " ");
        for(i=0; i<8; i++)
            Bprint(&bso, "%d", fnuxi8[i]);
        Bprint(&bso, "\n");
    }
    Bflush(&bso);
}
@

%<<function find2(x86)>>=
%//int
%//find2(long l, int c)
%//{
%//    short *p;
%//    int i;
%//
%//    p = (short*)&l;
%//    for(i=0; i<4; i+=2) {
%//        if(((*p >> 8) & 0xff) == c)
%//            return i;
%//        if((*p++ & 0xff) == c)
%//            return i+1;
%//    }
%//    return 0;
%//}
%@



<<function export(x86)>>=
void
export(void)
{
    int i, j, n, off, nb, sv, ne;
    Sym *s, *et, *str, **esyms;
    Prog *p;
    char buf[NSNAME], *t;

    n = 0;
    for(i = 0; i < NHASH; i++)
        for(s = hash[i]; s != S; s = s->link)
            if(s->type != SXREF && s->type != SUNDEF && (nexports == 0 && s->sig != 0 || s->subtype == SEXPORT || allexport))
                n++;
    esyms = malloc(n*sizeof(Sym*));
    ne = n;
    n = 0;
    for(i = 0; i < NHASH; i++)
        for(s = hash[i]; s != S; s = s->link)
            if(s->type != SXREF && s->type != SUNDEF && (nexports == 0 && s->sig != 0 || s->subtype == SEXPORT || allexport))
                esyms[n++] = s;
    for(i = 0; i < ne-1; i++)
        for(j = i+1; j < ne; j++)
            if(strcmp(esyms[i]->name, esyms[j]->name) > 0){
                s = esyms[i];
                esyms[i] = esyms[j];
                esyms[j] = s;
            }

    nb = 0;
    off = 0;
    et = lookup(EXPTAB, 0);
    if(et->type != 0 && et->type != SXREF)
        diag("%s already defined", EXPTAB);
    et->type = SDATA;
    str = lookup(".string", 0);
    if(str->type == 0)
        str->type = SDATA;
    sv = str->value;
    for(i = 0; i < ne; i++){
        s = esyms[i];
        if(debug['S'])
            s->sig = 0;
        /* Bprint(&bso, "EXPORT: %s sig=%lux t=%d\n", s->name, s->sig, s->type); */

        /* signature */
        p = newdata(et, off, sizeof(long), D_EXTERN);
        off += sizeof(long);
        p->to.offset = s->sig;

        /* address */
        p = newdata(et, off, sizeof(long), D_EXTERN);
        off += sizeof(long);
        p->to.type = D_ADDR;
        p->to.index = D_EXTERN;
        p->to.sym = s;

        /* string */
        t = s->name;
        n = strlen(t)+1;
        for(;;){
            buf[nb++] = *t;
            sv++;
            if(nb >= NSNAME){
                p = newdata(str, sv-NSNAME, NSNAME, D_STATIC);
                p->to.type = D_SCONST;
                memmove(p->to.scon, buf, NSNAME);
                nb = 0;
            }
            if(*t++ == 0)
                break;
        }

        /* name */
        p = newdata(et, off, sizeof(long), D_EXTERN);
        off += sizeof(long);
        p->to.type = D_ADDR;
        p->to.index = D_STATIC;
        p->to.sym = str;
        p->to.offset = sv-n;
    }

    if(nb > 0){
        p = newdata(str, sv-nb, nb, D_STATIC);
        p->to.type = D_SCONST;
        memmove(p->to.scon, buf, nb);
    }

    for(i = 0; i < 3; i++){
        newdata(et, off, sizeof(long), D_EXTERN);
        off += sizeof(long);
    }
    et->value = off;
    if(sv == 0)
        sv = 1;
    str->value = sv;
    exports = ne;
    free(esyms);
}
@

<<function newdata(x86)>>=
static Prog*
newdata(Sym *s, int o, int w, int t)
{
    Prog *p;

    p = prg();
    if(edatap == P)
        datap = p;
    else
        edatap->link = p;
    edatap = p;
    p->as = ADATA;
    p->width = w;
    p->from.scale = w;
    p->from.type = t;
    p->from.sym = s;
    p->from.offset = o;
    p->to.type = D_CONST;
    return p;
}
@

<<function import(x86)>>=
void
import(void)
{
    int i;
    Sym *s;

    for(i = 0; i < NHASH; i++)
        for(s = hash[i]; s != S; s = s->link)
            if(s->sig != 0 && s->type == SXREF && (nimports == 0 || s->subtype == SIMPORT)){
                if(s->value != 0)
                    diag("value != 0 on SXREF");
                undefsym(s);
                if(debug['X'])
                    Bprint(&bso, "IMPORT: %s sig=%lux v=%ld\n", s->name, s->sig, s->value);
                if(debug['S'])
                    s->sig = 0;
            }
}
@


<<global reloca(x86)>>=
Adr*	reloca;
@

<<function dynreloc(x86)>>=
void
dynreloc(Sym *s, ulong v, int abs)
{
    int i, k, n;
    byte *m;
    ulong *a;
    Reloc *r;

    if(s->type == SUNDEF)
        k = abs ? ABSU : RELU;
    else
        k = abs ? ABSD : RELD;
    /* Bprint(&bso, "R %s a=%ld(%lx) %d\n", s->name, v, v, k); */
    k = modemap[k];
    r = &rels;
    n = r->n;
    if(n >= r->t)
        grow(r);
    m = r->m;
    a = r->a;
    for(i = n; i > 0; i--){
        if(v < a[i-1]){	/* happens occasionally for data */
            m[i] = m[i-1];
            a[i] = a[i-1];
        }
        else
            break;
    }
    m[i] = k;
    a[i] = v;
    r->n++;
}
@

<<function listinit(x86)>>=
void
listinit(void)
{

    fmtinstall('A', Aconv);
    fmtinstall('R', Rconv);
    fmtinstall('D', Dconv);
    fmtinstall('P', Pconv);
    fmtinstall('S', Sconv);
}
@

<<function Aconv(x86)>>=
// enum<opcode> -> string
int
Aconv(Fmt *fp)
{
    int i;

    i = va_arg(fp->args, int);
    return fmtstrcpy(fp, anames[i]);
}
@

<<global regstr(x86)>>=
// coupling with enum regs in 8.out.h
char*	regstr[] =
{
    "AL",		/* [D_AL] */
    "CL",
    "DL",
    "BL",
    "AH",
    "CH",
    "DH",
    "BH",

    "AX",		/* [D_AX] */
    "CX",
    "DX",
    "BX",
    "SP",
    "BP",
    "SI",
    "DI",

    "F0",		/* [D_F0] */
    "F1",
    "F2",
    "F3",
    "F4",
    "F5",
    "F6",
    "F7",

    "CS",		/* [D_CS] */
    "SS",
    "DS",
    "ES",
    "FS",
    "GS",

    "GDTR",		/* [D_GDTR] */
    "IDTR",		/* [D_IDTR] */
    "LDTR",		/* [D_LDTR] */
    "MSW",		/* [D_MSW] */
    "TASK",		/* [D_TASK] */

    "CR0",		/* [D_CR] */
    "CR1",
    "CR2",
    "CR3",
    "CR4",
    "CR5",
    "CR6",
    "CR7",

    "DR0",		/* [D_DR] */
    "DR1",
    "DR2",
    "DR3",
    "DR4",
    "DR5",
    "DR6",
    "DR7",

    "TR0",		/* [D_TR] */
    "TR1",
    "TR2",
    "TR3",
    "TR4",
    "TR5",
    "TR6",
    "TR7",

    "NONE",		/* [D_NONE] */
};
@
% NONE part of it? this can happen? not more part of enum<operand>?

<<function Rconv(x86)>>=
// enum<operand_kind(register-only)> -> string
int
Rconv(Fmt *fp)
{
    char str[20];
    int r;

    r = va_arg(fp->args, int);
    if(r >= D_AL && r <= D_NONE)
        snprint(str, sizeof(str), "%s", regstr[r-D_AL]);
    else
        snprint(str, sizeof(str), "gok(%d)", r);

    return fmtstrcpy(fp, str);
}
@
%gok??


% used by PConv and Dconv as Dconv need access to enclosing Prog for branch
<<global bigP(x86)>>=
static	Prog	*bigP;
@


<<function Pconv(x86)>>=
// Prog -> string
int
Pconv(Fmt *fp)
{
    char str[STRINGSZ];
    Prog *p;

    p = va_arg(fp->args, Prog*);
    bigP = p;
    switch(p->as) {
    case ATEXT:
        // when this happens?
        if(p->from.scale) {
            snprint(str, sizeof(str), "(%ld)	%A	%D,%d,%D",
                p->line, p->as, &p->from, p->from.scale, &p->to);
        } else {
            snprint(str, sizeof(str), "(%ld)	%A	%D,%D",
                p->line, p->as, &p->from, &p->to);
        }
        break;
    case ADATA:
    case AINIT:
    case ADYNT:
        snprint(str, sizeof(str), "(%ld)	%A	%D/%d,%D",
            p->line, p->as, &p->from, p->from.scale, &p->to);
        break;
    default:
        snprint(str, sizeof(str), "(%ld)	%A	%D,%D",
            p->line, p->as, &p->from, &p->to);
        break;
    }
    bigP = P;
    return fmtstrcpy(fp, str);
}
@



<<function Dconv(x86)>>=
// Adr -> string
int
Dconv(Fmt *fp)
{
    char str[STRINGSZ+40], s[20];
    Adr *a;
    //enum<operand_kind>
    int i;

    a = va_arg(fp->args, Adr*);
    i = a->type;

    <<[[Dconv()]] if i >= D_INDIR(x86)>>

    switch(i) {
    case D_NONE:
        str[0] = '\0';
        break;


    case D_BRANCH:
        if(bigP != P && bigP->pcond != P)
            if(a->sym != S)
                snprint(str, sizeof(str), "%lux+%s", bigP->pcond->pc,
                    a->sym->name);
            else
                snprint(str, sizeof(str), "%lux", bigP->pcond->pc);
        else
            snprint(str, sizeof(str), "%ld(PC)", a->offset);
        break;

    case D_EXTERN:
        snprint(str, sizeof(str), "%s+%ld(SB)", a->sym->name, a->offset);
        break;
    case D_STATIC:
        snprint(str, sizeof(str), "%s<%d>+%ld(SB)", a->sym->name,
            a->sym->version, a->offset);
        break;
    case D_LOCAL:
        snprint(str, sizeof(str), "%s+%ld(SP)", a->sym->name, a->offset);
        break;
    case D_PARAM:
        if(a->sym)
            snprint(str, sizeof(str), "%s+%ld(FP)", a->sym->name, a->offset);
        else
            snprint(str, sizeof(str), "%ld(FP)", a->offset);
        break;

    case D_CONST:
        snprint(str, sizeof(str), "$%ld", a->offset);
        break;
    case D_FCONST:
        snprint(str, sizeof(str), "$(%.8lux,%.8lux)", a->ieee.h, a->ieee.l);
        break;
    case D_SCONST:
        snprint(str, sizeof(str), "$\"%S\"", a->scon);
        break;

    case D_ADDR:
        a->type = a->index;
        a->index = D_NONE;
        snprint(str, sizeof(str), "$%D", a);
        a->index = a->type;
        a->type = D_ADDR;
        goto conv;

    default:
        snprint(str, sizeof(str), "%R", i);
        break;

    }
brk:
    if(a->index != D_NONE) {
        snprint(s, sizeof(s), "(%R*%d)", a->index, a->scale);
        strcat(str, s);
    }
conv:
    return fmtstrcpy(fp, str);
}
@
% todo: could simplify flow, those brk: conv: and goto are ugly,
% copy paste a bit and avoid complex flow instead

%???
<<[[Dconv()]] if i >= D_INDIR(x86)>>=
if(i >= D_INDIR) {
    if(a->offset)
        snprint(str, sizeof(str), "%ld(%R)", a->offset, i-D_INDIR);
    else
        snprint(str, sizeof(str), "(%R)", i-D_INDIR);
    goto brk;
}
@



%????  %S not used that much here, but used a lot in optable, for things
% like MOV%S, means MOVL, MOVB, MOVW?
% for D_SCONST ?? but what is D_SCONST?
<<function Sconv(x86)>>=
// ?? -> string
int
Sconv(Fmt *fp)
{
    int i, c;
    char str[30], *p, *a;

    a = va_arg(fp->args, char*);
    p = str;
    for(i=0; i<sizeof(double); i++) {
        c = a[i] & 0xff;
        if(c >= 'a' && c <= 'z' ||
           c >= 'A' && c <= 'Z' ||
           c >= '0' && c <= '9') {
            *p++ = c;
            continue;
        }
        *p++ = '\\';

        switch(c) {
        default:
            if(c < 040 || c >= 0177)
                break;	/* not portable */
            p[-1] = c;
            continue;
        case 0:
            *p++ = 'z';
            continue;
        case '\\':
        case '"':
            *p++ = c;
            continue;
        case '\n':
            *p++ = 'n';
            continue;
        case '\t':
            *p++ = 't';
            continue;
        }
        *p++ = (c>>6) + '0';
        *p++ = ((c>>3) & 7) + '0';
        *p++ = (c & 7) + '0';
    }
    *p = 0;
    return fmtstrcpy(fp, str);
}
@
% what the fuck is this?

<<function cput(x86)>>=
#define	cput(c)\
    { *cbp++ = c;\
    if(--cbc <= 0)\
        cflush(); }
@


<<function wputl(x86)>>=
/* these need to take long arguments to be compatible with elf.c */
void
wputl(long w)
{
    cput(w);
    cput(w>>8);
}
@


<<function wput(x86)>>=
void
wput(long w)
{
    cput(w>>8);
    cput(w);
}
@

<<function lput(x86)>>=
void
lput(long l)
{
    cput(l>>24);
    cput(l>>16);
    cput(l>>8);
    cput(l);
}
@

<<function lputl(x86)>>=
void
lputl(long l)
{
    cput(l);
    cput(l>>8);
    cput(l>>16);
    cput(l>>24);
}
@

<<function strnput(x86)>>=
void
strnput(char *s, int n)
{
    for(; *s && n > 0; s++){
        cput(*s);
        n--;
    }
    while(n > 0){
        cput(0);
        n--;
    }
}
@


<<function patch(x86)>>=
void
patch(void)
{
    long c;
    Prog *p, *q;
    Sym *s;
    long vexit;

    // could be moved out of patch() in main()?
    DBG("%5.2f mkfwd\n", cputime());
    mkfwd();

    DBG("%5.2f patch\n", cputime());
    s = lookup("exit", 0);
    vexit = s->value;
    for(p = firstp; p != P; p = p->link) {
        if(p->as == ATEXT)
            curtext = p;
        if(p->as == ACALL || p->as == ARET) {
            s = p->to.sym;
            if(s) {
                if(debug['c'])
                    Bprint(&bso, "%s calls %s\n", TNAME, s->name);

                switch(s->type) {
                case STEXT:
                    p->to.offset = s->value;
                    break;
                case SUNDEF:
                    p->pcond = UP;
                    p->to.offset = 0;
                    break;
                default:
                    /* diag prints TNAME first */
                    diag("undefined: %s", s->name);
                    s->type = STEXT;
                    s->value = vexit;
                    break;	/* or fall through to set offset? */
                }
                p->to.type = D_BRANCH;
            }
        }
        if(p->to.type != D_BRANCH || p->pcond == UP)
            continue;

        c = p->to.offset;
        for(q = firstp; q != P;) {
            if(q->forwd != P)
            if(c >= q->forwd->pc) {
                q = q->forwd;
                continue;
            }
            if(c == q->pc)
                break;
            q = q->link;
        }
        if(q == P) {
            diag("branch out of range in %s\n%P", TNAME, p);
            p->to.type = D_NONE;
        }
        p->pcond = q;
    }

    for(p = firstp; p != P; p = p->link) {
        if(p->as == ATEXT)
            curtext = p;
        p->mark = 0;	/* initialization for follow */
        if(p->pcond != P && p->pcond != UP) {
            p->pcond = brloop(p->pcond);
            if(p->pcond != P)
            if(p->to.type == D_BRANCH)
                p->to.offset = p->pcond->pc;
        }
    }
}
@


<<function dodata(x86)>>=
void
dodata(void)
{
    int i;
    Sym *s;
    Prog *p;
    long t, u;

    DBG("%5.2f dodata\n", cputime());

    for(p = datap; p != P; p = p->link) {
        s = p->from.sym;
        if(p->as == ADYNT || p->as == AINIT)
            s->value = dtype;
        if(s->type == SBSS)
            s->type = SDATA;
        if(s->type != SDATA)
            diag("initialize non-data (%d): %s\n%P",
                s->type, s->name, p);
        t = p->from.offset + p->width;
        if(t > s->value)
            diag("initialize bounds (%ld): %s\n%P",
                s->value, s->name, p);
    }
    /* allocate small guys */
    datsize = 0;
    for(i=0; i<NHASH; i++)
    for(s = hash[i]; s != S; s = s->link) {
        if(s->type != SDATA)
        if(s->type != SBSS)
            continue;
        t = s->value;
        if(t == 0) {
            diag("%s: no size", s->name);
            t = 1;
        }
        t = rnd(t, 4);;
        s->value = t;
        if(t > MINSIZ)
            continue;
        s->value = datsize;
        datsize += t;
        s->type = SDATA1;
    }

    /* allocate the rest of the data */
    for(i=0; i<NHASH; i++)
    for(s = hash[i]; s != S; s = s->link) {
        if(s->type != SDATA) {
            if(s->type == SDATA1)
                s->type = SDATA;
            continue;
        }
        t = s->value;
        s->value = datsize;
        datsize += t;
    }

    if(debug['j']) {
        /*
         * pad data with bss that fits up to next
         * 8k boundary, then push data to 8k
         */
        u = rnd(datsize, 8192);
        u -= datsize;
        for(i=0; i<NHASH; i++)
        for(s = hash[i]; s != S; s = s->link) {
            if(s->type != SBSS)
                continue;
            t = s->value;
            if(t > u)
                continue;
            u -= t;
            s->value = datsize;
            s->type = SDATA;
            datsize += t;
        }
        datsize += u;
    }

    /* now the bss */
    bsssize = 0;
    for(i=0; i<NHASH; i++)
    for(s = hash[i]; s != S; s = s->link) {
        if(s->type != SBSS)
            continue;
        t = s->value;
        s->value = bsssize + datsize;
        bsssize += t;
    }
    xdefine("bdata", SDATA, 0L);
    xdefine("edata", SBSS, datsize);
    xdefine("end", SBSS, bsssize + datsize);
    /* etext is defined in span.c */
}
@

<<function span(x86)>>=
void
span(void)
{
    Prog *p, *q;
    long v, c, idat;
    int m, n, again;

    xdefine("etext", STEXT, 0L);
    idat = INITDAT;
    for(p = firstp; p != P; p = p->link) {
        if(p->as == ATEXT)
            curtext = p;
        n = 0;
        if(p->to.type == D_BRANCH)
            if(p->pcond == P)
                p->pcond = p;
        if((q = p->pcond) != P)
            if(q->back != 2)
                n = 1;
        p->back = n;
        if(p->as == AADJSP) {
            p->to.type = D_SP;
            v = -p->from.offset;
            p->from.offset = v;
            p->as = AADDL;
            if(v < 0) {
                p->as = ASUBL;
                v = -v;
                p->from.offset = v;
            }
            if(v == 0)
                p->as = ANOP;
        }
    }
    n = 0;

start:

    DBG("%5.2f span\n", cputime());

    c = INITTEXT;
    for(p = firstp; p != P; p = p->link) {
        if(p->as == ATEXT)
            curtext = p;
        if(p->to.type == D_BRANCH)
            if(p->back)
                p->pc = c;
        asmins(p);
        p->pc = c;
        m = andptr-and;
        p->mark = m;
        c += m;
    }

loop:
    n++;

    DBG("%5.2f span %d\n", cputime(), n);

    if(n > 50) {
        print("span must be looping\n");
        errorexit();
    }
    again = 0;
    c = INITTEXT;
    for(p = firstp; p != P; p = p->link) {
        if(p->as == ATEXT)
            curtext = p;
        if(p->to.type == D_BRANCH) {
            if(p->back)
                p->pc = c;
            asmins(p);
            m = andptr-and;
            if(m != p->mark) {
                p->mark = m;
                again++;
            }
        }
        p->pc = c;
        c += p->mark;
    }
    if(again) {
        textsize = c;
        goto loop;
    }
    if(INITRND) {
        INITDAT = rnd(c, INITRND);
        if(INITDAT != idat) {
            idat = INITDAT;
            goto start;
        }
    }
    xdefine("etext", STEXT, c);

    DBG("etext = %lux\n", c);

    for(p = textp; p != P; p = p->pcond)
        p->from.sym->value = p->pc;
    textsize = c - INITTEXT;
}
@

<<function datblk(x86)>>=
void
datblk(long s, long n)
{
    Prog *p;
    char *cast;
    long l, fl, j;
    int i, c;

    memset(buf.dbuf, 0, n+Dbufslop);
    for(p = datap; p != P; p = p->link) {
        curp = p;
        l = p->from.sym->value + p->from.offset - s;
        c = p->from.scale;
        i = 0;
        if(l < 0) {
            if(l+c <= 0)
                continue;
            while(l < 0) {
                l++;
                i++;
            }
        }
        if(l >= n)
            continue;
        if(p->as != AINIT && p->as != ADYNT) {
            for(j=l+(c-i)-1; j>=l; j--)
                if(buf.dbuf[j]) {
                    print("%P\n", p);
                    diag("multiple initialization");
                    break;
                }
        }
        switch(p->to.type) {
        case D_FCONST:
            switch(c) {
            default:
            case 4:
                fl = ieeedtof(&p->to.ieee);
                cast = (char*)&fl;
                if(debug['a'] && i == 0) {
                    Bprint(&bso, pcstr, l+s+INITDAT);
                    for(j=0; j<c; j++)
                        Bprint(&bso, "%.2ux", cast[fnuxi4[j]] & 0xff);
                    Bprint(&bso, "\t%P\n", curp);
                }
                for(; i<c; i++) {
                    buf.dbuf[l] = cast[fnuxi4[i]];
                    l++;
                }
                break;
            case 8:
                cast = (char*)&p->to.ieee;
                if(debug['a'] && i == 0) {
                    Bprint(&bso, pcstr, l+s+INITDAT);
                    for(j=0; j<c; j++)
                        Bprint(&bso, "%.2ux", cast[fnuxi8[j]] & 0xff);
                    Bprint(&bso, "\t%P\n", curp);
                }
                for(; i<c; i++) {
                    buf.dbuf[l] = cast[fnuxi8[i]];
                    l++;
                }
                break;
            }
            break;

        case D_SCONST:
            if(debug['a'] && i == 0) {
                Bprint(&bso, pcstr, l+s+INITDAT);
                for(j=0; j<c; j++)
                    Bprint(&bso, "%.2ux", p->to.scon[j] & 0xff);
                Bprint(&bso, "\t%P\n", curp);
            }
            for(; i<c; i++) {
                buf.dbuf[l] = p->to.scon[i];
                l++;
            }
            break;

        default:
            fl = p->to.offset;
            if(p->to.type == D_ADDR) {
                if(p->to.index != D_STATIC && p->to.index != D_EXTERN)
                    diag("DADDR type%P", p);
                if(p->to.sym) {
                    if(p->to.sym->type == SUNDEF)
                        ckoff(p->to.sym, fl);
                    fl += p->to.sym->value;
                    if(p->to.sym->type != STEXT && p->to.sym->type != SUNDEF)
                        fl += INITDAT;
                    <<[[datblk()]] if dynamic module(x86)>>
                }
            }
            cast = (char*)&fl;
            switch(c) {
            default:
                diag("bad nuxi %d %d\n%P", c, i, curp);
                break;
            case 1:
                if(debug['a'] && i == 0) {
                    Bprint(&bso, pcstr, l+s+INITDAT);
                    for(j=0; j<c; j++)
                        Bprint(&bso, "%.2ux", cast[inuxi1[j]] & 0xff);
                    Bprint(&bso, "\t%P\n", curp);
                }
                for(; i<c; i++) {
                    buf.dbuf[l] = cast[inuxi1[i]];
                    l++;
                }
                break;
            case 2:
                if(debug['a'] && i == 0) {
                    Bprint(&bso, pcstr, l+s+INITDAT);
                    for(j=0; j<c; j++)
                        Bprint(&bso, "%.2ux", cast[inuxi2[j]] & 0xff);
                    Bprint(&bso, "\t%P\n", curp);
                }
                for(; i<c; i++) {
                    buf.dbuf[l] = cast[inuxi2[i]];
                    l++;
                }
                break;
            case 4:
                if(debug['a'] && i == 0) {
                    Bprint(&bso, pcstr, l+s+INITDAT);
                    for(j=0; j<c; j++)
                        Bprint(&bso, "%.2ux", cast[inuxi4[j]] & 0xff);
                    Bprint(&bso, "\t%P\n", curp);
                }
                for(; i<c; i++) {
                    buf.dbuf[l] = cast[inuxi4[i]];
                    l++;
                }
                break;
            }
            break;
        }
    }
    write(cout, buf.dbuf, n);
}
@



<<[[asmb()]] if dynamic module magic header adjustment(x86)>>=
if(dlm)
    magic |= 0x80000000;
@


<<function asmb(x86)>>=
void
asmb(void)
{
    Prog *p;
    long v, magic;
    int a;
    byte *op1;

    DBG("%5.2f asmb\n", cputime());

    // TEXT SECTION

    seek(cout, HEADR, SEEK__START);
    pc = INITTEXT;
    curp = firstp;

    for(p = firstp; p != P; p = p->link) {
        if(p->as == ATEXT)
            curtext = p;
        if(p->pc != pc) {
            if(!debug['a'])
                print("%P\n", curp);
            diag("phase error %lux sb %lux in %s", p->pc, pc, TNAME);
            pc = p->pc;
        }
        curp = p;

        // generate instruction!
        asmins(p);

        if(cbc < sizeof(and))
            cflush();
        a = (andptr - and);

        if(debug['a']) {
            Bprint(&bso, pcstr, pc);
            for(op1 = and; op1 < andptr; op1++)
                Bprint(&bso, "%.2ux", *op1 & 0xff);
            Bprint(&bso, "\t%P\n", curp);
        }

        <<[[asmb()]] if dynamic module, when iterate from firstp(x86)>>

        memmove(cbp, and, a);
        cbp += a;
        pc += a;
        cbc -= a;
    }
    cflush();

    // DATA SECTION

    switch(HEADTYPE) {
    case H_PLAN9:
        seek(cout, HEADR+textsize, SEEK__START);
        break;
    <<[[asmb()]] switch HEADTYPE (to position after text) cases(x86)>>
    default:
        diag("unknown header type %d", HEADTYPE);
    }

    DBG("%5.2f datblk\n", cputime());

    <<[[asmb()]] if dynamic module, before datblk()>>

    for(v = 0; v < datsize; v += sizeof(buf)-Dbufslop) {
        if(datsize-v > sizeof(buf)-Dbufslop)
            datblk(v, sizeof(buf)-Dbufslop);
        else
            datblk(v, datsize-v);
    }

    // SYMBOL TABLE

    // modified by asmsym()
    symsize = 0;
    // modified by asmlc()
    lcsize = 0;

    if(!debug['s']) {
        DBG("%5.2f sym\n", cputime());

        switch(HEADTYPE) {
        case H_PLAN9:
            seek(cout, HEADR+textsize+datsize, 0);
            break;
        <<[[asmb()]] switch HEADTYPE (for symbol table generation) cases(x86)>>
        default:
            seek(cout, rnd(HEADR+textsize, 8192)+datsize, 0);
            break;
        }

        asmsym();

        DBG("%5.2f sp\n", cputime());
        DBG("%5.2f pc\n", cputime());

        asmlc();

        <<[[asmb()]] if dynamic module, call asmdyn()>>
        cflush();
    } else {
        <<[[asmb()]] if dynamic module and no symbol table generation>>
    }

    // HEADER

    DBG("%5.2f headr\n", cputime());

    seek(cout, 0L, SEEK__START);

    switch(HEADTYPE) {
    // see Exec in a.out.h
    case H_PLAN9:	/* plan9 */
        magic = 4*11*11+7;
        <<[[asmb()]] if dynamic module magic header adjustment(x86)>>
        lput(magic);			/* magic */
        lput(textsize);			/* sizes */
        lput(datsize);
        lput(bsssize);
        lput(symsize);			/* nsyms */

        lput(entryvalue());		/* va of entry */

        lput(spsize);			/* sp offsets */
        lput(lcsize);			/* line offsets */
        break;
    <<[[asmb()]] switch HEADTYPE (for header generation) cases(x86)>>
    }

    cflush();
}
@



<<[[main()]] switch HEADTYPE cases(x86)>>=
case H_GARBAGE:	/* this is garbage */
    HEADR = 20L+56L;
    if(INITTEXT == -1)
        INITTEXT = 0x40004CL;
    if(INITDAT == -1)
        INITDAT = 0x10000000L;
    if(INITRND == -1)
        INITRND = 0;
    break;
case H_COFF:	/* is unix coff */
    HEADR = 0xd0L;
    if(INITTEXT == -1)
        INITTEXT = 0xd0;
    if(INITDAT == -1)
        INITDAT = 0x400000;
    if(INITRND == -1)
        INITRND = 0;
    break;
case H_COM:	/* MS-DOS .COM */
    HEADR = 0;
    if(INITTEXT == -1)
        INITTEXT = 0x0100;
    if(INITDAT == -1)
        INITDAT = 0;
    if(INITRND == -1)
        INITRND = 4;
    break;
case H_EXE:	/* fake MS-DOS .EXE */
    HEADR = 0x200;
    if(INITTEXT == -1)
        INITTEXT = 0x0100;
    if(INITDAT == -1)
        INITDAT = 0;
    if(INITRND == -1)
        INITRND = 4;
    HEADR += (INITTEXT & 0xFFFF);
    DBG("HEADR = 0x%ld\n", HEADR);
    break;
case H_ELF:	/* elf executable */
    HEADR = rnd(Ehdr32sz+3*Phdr32sz, 16);
    if(INITTEXT == -1)
        INITTEXT = 0x80100020L;
    if(INITDAT == -1)
        INITDAT = 0;
    if(INITRND == -1)
        INITRND = 4096;
    break;
@


<<[[asmb()]] switch HEADTYPE (to position after text) cases(x86)>>=
case H_GARBAGE:
    seek(cout, rnd(HEADR+textsize, 8192), 0);
    break;
case H_COFF:
    textsize = rnd(HEADR+textsize, 4096)-HEADR;
    seek(cout, textsize+HEADR, 0);
    break;
case H_ELF: // like H_PLAN9
    seek(cout, HEADR+textsize, 0);
    break;
case H_COM:
case H_EXE:
    seek(cout, HEADR+rnd(textsize, INITRND), 0);
    break;
@

<<[[asmb()]] switch HEADTYPE (for symbol table generation) cases(x86)>>=
case H_GARBAGE:
case H_COFF:
    seek(cout, rnd(HEADR+textsize, INITRND)+datsize, 0);
    break;
//case H_PLAN9:
case H_ELF:
    seek(cout, HEADR+textsize+datsize, 0);
    break;
case H_COM:
case H_EXE:
    debug['s'] = 1;
    break;
@

<<[[asmb()]] switch HEADTYPE (for header generation) cases(x86)>>=
default:
case H_GARBAGE:	/* garbage */
    lput(0x160L<<16);		/* magic and sections */
    lput(0L);			/* time and date */
    lput(rnd(HEADR+textsize, 4096)+datsize);
    lput(symsize);			/* nsyms */
    lput((0x38L<<16)|7L);		/* size of optional hdr and flags */
    lput((0413<<16)|0437L);		/* magic and version */
    lput(rnd(HEADR+textsize, 4096));/* sizes */
    lput(datsize);
    lput(bsssize);
    lput(entryvalue());		/* va of entry */
    lput(INITTEXT-HEADR);		/* va of base of text */
    lput(INITDAT);			/* va of base of data */
    lput(INITDAT+datsize);		/* va of base of bss */
    lput(~0L);			/* gp reg mask */
    lput(0L);
    lput(0L);
    lput(0L);
    lput(0L);
    lput(~0L);			/* gp value ?? */
    break;
case H_COFF:	/* unix coff */
    /*
     * file header
     */
    lputl(0x0004014c);		/* 4 sections, magic */
    lputl(0);			/* unix time stamp */
    lputl(0);			/* symbol table */
    lputl(0);			/* nsyms */
    lputl(0x0003001c);		/* flags, sizeof a.out header */
    /*
     * a.out header
     */
    lputl(0x10b);			/* magic, version stamp */
    lputl(rnd(textsize, INITRND));	/* text sizes */
    lputl(datsize);			/* data sizes */
    lputl(bsssize);			/* bss sizes */
    lput(entryvalue());		/* va of entry */
    lputl(INITTEXT);		/* text start */
    lputl(INITDAT);			/* data start */
    /*
     * text section header
     */
    strnput(".text", 8);
    lputl(HEADR);			/* pa */
    lputl(HEADR);			/* va */
    lputl(textsize);		/* text size */
    lputl(HEADR);			/* file offset */
    lputl(0);			/* relocation */
    lputl(0);			/* line numbers */
    lputl(0);			/* relocation, line numbers */
    lputl(0x20);			/* flags text only */
    /*
     * data section header
     */
    strnput(".data", 8);
    lputl(INITDAT);			/* pa */
    lputl(INITDAT);			/* va */
    lputl(datsize);			/* data size */
    lputl(HEADR+textsize);		/* file offset */
    lputl(0);			/* relocation */
    lputl(0);			/* line numbers */
    lputl(0);			/* relocation, line numbers */
    lputl(0x40);			/* flags data only */
    /*
     * bss section header
     */
    strnput(".bss", 8);
    lputl(INITDAT+datsize);		/* pa */
    lputl(INITDAT+datsize);		/* va */
    lputl(bsssize);			/* bss size */
    lputl(0);			/* file offset */
    lputl(0);			/* relocation */
    lputl(0);			/* line numbers */
    lputl(0);			/* relocation, line numbers */
    lputl(0x80);			/* flags bss only */
    /*
     * comment section header
     */
    strnput(".comment", 8);
    lputl(0);			/* pa */
    lputl(0);			/* va */
    lputl(symsize+lcsize);		/* comment size */
    lputl(HEADR+textsize+datsize);	/* file offset */
    lputl(HEADR+textsize+datsize);	/* offset of syms */
    lputl(HEADR+textsize+datsize+symsize);/* offset of line numbers */
    lputl(0);			/* relocation, line numbers */
    lputl(0x200);			/* flags comment only */
    break;
case H_COM:
    /* MS-DOS .COM */
    break;
case H_EXE:
    /* fake MS-DOS .EXE */
    v = rnd(HEADR+textsize, INITRND)+datsize;
    wputl(0x5A4D);			/* 'MZ' */
    wputl(v % 512);			/* bytes in last page */
    wputl(rnd(v, 512)/512);		/* total number of pages */
    wputl(0x0000);			/* number of reloc items */
    v = rnd(HEADR-(INITTEXT & 0xFFFF), 16);
    wputl(v/16);			/* size of header */
    wputl(0x0000);			/* minimum allocation */
    wputl(0xFFFF);			/* maximum allocation */
    wputl(0x0000);			/* initial ss value */
    wputl(0x0100);			/* initial sp value */
    wputl(0x0000);			/* complemented checksum */
    v = entryvalue();
    wputl(v);			/* initial ip value (!) */
    wputl(0x0000);			/* initial cs value */
    wputl(0x0000);
    wputl(0x0000);
    wputl(0x003E);			/* reloc table offset */
    wputl(0x0000);			/* overlay number */
    break;
case H_ELF:
    elf32(I386, ELFDATA2LSB, 0, nil);
    break;
@




<<function doprof2(x86)>>=
void
doprof2(void)
{
    Sym *s2, *s4;
    Prog *p, *q, *q2;
    Prog *ps2, *ps4;

    DBG("%5.2f profile 2\n", cputime());

    <<[[doprof2()]] if embedded tracing>>
    else{
        s2 = lookup("_profin", 0);
        s4 = lookup("_profout", 0);
    }
    if(s2->type != STEXT || s4->type != STEXT) {
       <<[[doprof2()]] if embedded tracing diag()>>
        else
            diag("_profin/_profout not defined");
        return;
    }

    // finding ps2, ps4 = instruction (Prog) of s2 and s4
    ps2 = P;
    ps4 = P;
    for(p = firstp; p != P; p = p->link) {
        if(p->as == ATEXT) {
            if(p->from.sym == s2) {
                // do not profile the profling function itself ...
                p->from.scale = NOPROF;
                ps2 = p;
            }
            if(p->from.sym == s4) {
                p->from.scale = NOPROF;
                ps4 = p;
            }
        }
    }

    for(p = firstp; p != P; p = p->link) {
        if(p->as == ATEXT) {
            curtext = p;

            <<[[doprof2()]] if NOPROF p(x86)>>

            /*
             * JMPL	profin
             */
            q = prg();
            q->line = p->line;
            q->pc = p->pc;
            q->link = p->link;

            <<[[doprof2()]] if embedded tracing ATEXT instrumentation(x86)>>
             else
                p->link = q;
            p = q;
            //asm: CALL _profin
            p->as = ACALL;
            p->to.type = D_BRANCH;
            p->pcond = ps2;
            p->to.sym = s2;

        }else if(p->as == ARET) {
            <<[[doprof2()]] if embedded tracing ARET instrumentation>>
            /*
             * RET
             */
            q = prg();
            q->as = ARET;
            q->from = p->from;
            q->to = p->to;
            q->link = p->link;

            p->link = q;

            /*
             * JAL	profout
             */
            //asm: CALL _profout
            p->as = ACALL;
            p->from = zprg.from;
            p->to = zprg.to;
            p->to.type = D_BRANCH;
            p->pcond = ps4;
            p->to.sym = s4;

            p = q;
        }
    }
}
@



<<[[doprof2()]] if NOPROF p(x86)>>=
if(p->from.scale & NOPROF) {	/* dont profile */
    for(;;) {
        q = p->link;
        if(q == P)
            break;
        if(q->as == ATEXT)
            break;
        p = q;
    }
    continue;
}
@

<<[[doprof2()]] if embedded tracing ATEXT instrumentation(x86)>>=
if(debug['e']){		/* embedded tracing */
    q2 = prg();
    p->link = q2;
    q2->link = q;

    q2->line = p->line;
    q2->pc = p->pc;

    q2->as = AJMP;
    q2->to.type = D_BRANCH;
    q2->to.sym = p->to.sym;
    q2->pcond = q->link;
}
@


<<[[main()]] cout is ready, LET'S GO(x86)>>=
firstp = prg();
lastp = firstp;

<<[[main()]] set INITENTRY>>

while(*argv)
    objfile(*argv++);

if(load_libs)
    loadlib();

firstp = firstp->link;
if(firstp == P)
    errorexit();

<<[[main()]] if export table or dynamic module(x86)>>

patch();
follow();
dodata();
dostkoff();
<<[[main()]] call doprofxxx() if profiling>>
span();
doinit();

// write to cout, finally
asmb();

// sanity check
undef();
@


<<[[main()]] command line processing(x86)>>=
    case 'o': /* output to (next arg) */
        outfile = ARGF();
        break;
@


<<function main (linkers/8l/obj.c)>>=
void
main(int argc, char *argv[])
{
    <<[[main()]] locals(x86)>>

    thechar = '8';
    thestring = "386";   
    outfile = "8.out";

    <<[[main()]] debug initialization(x86)>>

    ARGBEGIN {
    <<[[main()]] command line processing(x86)>>
    } ARGEND
    USED(argc);
    if(*argv == nil)
        usage();

    <<[[main()]] addlibpath("/{thestring}/lib") or ccroot>>

    <<[[main()]] adjust HEADTYPE if debug flags(x86)>>
    switch(HEADTYPE) {
    <<[[main()]] switch HEADTYPE cases(x86)>>
    default:
        diag("unknown -H option");
        errorexit();

    }
    <<[[main()]] last INITXXX adjustments>>

    DBG("HEADER = -H0x%ld -T0x%lux -D0x%lux -R0x%lux\n",
            HEADTYPE, INITTEXT, INITDAT, INITRND);

    <<[[main()]] sanity check optab(x86)>>
    <<[[main()]] initialize globals(x86)>>

    nuxiinit();

    cout = create(outfile, 1, 0775);
    if(cout < 0) {
        diag("cannot create %s: %r", outfile);
        errorexit();
    }

    // ------ main functions  ------
    <<[[main()]] cout is ready, LET'S GO(x86)>>

    <<[[main()]] profile report>>
    errorexit();
}
@
%$ 


<<[[main()]] command line processing(x86)>>=
case 'H':
    a = ARGF();
    if(a)
        HEADTYPE = atolwhex(a);
    break;
case 'T':
    a = ARGF();
    if(a)
        INITTEXT = atolwhex(a);
    break;
case 'D':
    a = ARGF();
    if(a)
        INITDAT = atolwhex(a);
    break;
case 'E':
    a = ARGF();
    if(a)
        INITENTRY = a;
    break;
case 'R':
    a = ARGF();
    if(a)
        INITRND = atolwhex(a);
    break;
@


<<[[main()]] switch HEADTYPE cases(x86)>>=
case H_PLAN9:	/* plan 9 */
    HEADR = 32L;
    if(INITTEXT == -1)
        INITTEXT = 4096+32;
    if(INITDAT == -1)
        INITDAT = 0;
    if(INITRND == -1)
        INITRND = 4096;
    break;
@

% used locals? move closer the the code that use it then
<<[[main()]] locals(x86)>>=
    int i, c;
    char name[LIBNAMELEN];
    char *a;
@

<<[[main()]] initialize globals(x86)>>=
<<[[main()]] set ycover(x86)>>
<<[[main()]] set reg(x86)>>
<<[[main()]] set zprg(x86)>>
dtype = 4;

cbp = buf.obuf;
cbc = sizeof(buf.obuf);
@

<<[[main()]] set zprg(x86)>>=
zprg.link = P;
zprg.pcond = P;
zprg.back = 2;
zprg.as = AGOK;
zprg.from.type = D_NONE;
zprg.from.index = D_NONE;
zprg.from.scale = 1;
zprg.to = zprg.from;
@

<<[[main()]] locals(x86)>>=
bool load_libs;
@

% -l means no automagic stdlibs
<<[[main()]] initialize globals(x86)>>=
load_libs = !debug['l'];
@


<<[[main()]] command line processing(x86)>>=
case 'L':
    addlibpath(EARGF(usage()));
    break;
@

% was called a
<<[[main()]] locals(x86)>>=
char *root;
@

% starts at 1 because of AXXX (but why need AXXX?)
<<[[main()]] sanity check optab(x86)>>=
for(i=1; optab[i].as; i++)
    if(i != optab[i].as) {
        diag("phase error in optab: %d", i);
        errorexit();
    }
@

<<[[main()]] command line processing(x86)>>=
case 'x':	/* produce export table */
    doexp = true;
    if(argv[1] != nil && argv[1][0] != '-' && !isobjfile(argv[1])){
        a = ARGF();
        if(strcmp(a, "*") == 0)
            allexport = true;
        else
            readundefs(a, SEXPORT);
    }
    break;
@

<<[[main()]] if dynamic module(x86)>>=
if(dlm){
    import();
    HEADTYPE = H_PLAN9;
    INITTEXT = INITDAT = 0;
    INITRND = 8;
    INITENTRY = EXPTAB;
}
@

<<[[main()]] if export table or dynamic module(x86)>>=
if(doexp || dlm){
    EXPTAB = "_exporttab";
    zerosig(EXPTAB);
    zerosig("etext");
    zerosig("edata");
    zerosig("end");

   <<[[main()]] if dynamic module(x86)>>

    export();
}
@

<<[[main()]] command line processing(x86)>>=
case 'u':	/* produce dynamically loadable module */
    dlm = true;
    // do not load standard libraries
    debug['l'] = true;

    if(argv[1] != nil && argv[1][0] != '-' && !isobjfile(argv[1]))
        readundefs(ARGF(), SIMPORT);
    break;
@


<<[[asmb()]] if dynamic module, when iterate from firstp(x86)>>=
if(dlm) {
    if(p->as == ATEXT)
        reloca = nil;
    else if(reloca != nil)
        diag("reloc failure: %P", curp);
}
@

<<[[datblk()]] if dynamic module(x86)>>=
if(dlm)
    dynreloc(p->to.sym, l+s+INITDAT, 1);
@


<<[[main()]] command line processing(x86)>>=
case 'P':
    a = ARGF();
    if(a)
        INITTEXTP = atolwhex(a);
    break;
@

<<[[main()]] debug initialization(x86)>>=
Binit(&bso, 1, OWRITE);
listinit(); // fmtinstall()
memset(debug, false, sizeof(debug));
@

<<[[main()]] command line processing(x86)>>=
default:
    c = ARGC();
    if(c >= 0 && c < sizeof(debug))
        debug[c] = true;
    break;
@

% obsolete?
<<[[main()]] adjust HEADTYPE if debug flags(x86)>>=
if(HEADTYPE == -1) {
  HEADTYPE = DEFAULT;
}
@

<<function ldobj(x86)>>=
void
ldobj(fdt f, long c, char *pn)
{
    <<[[ldobj()]] locals(x86)>>

    <<[[ldobj()]] grow filen if not enough space>>
    filen[files++] = strdup(pn);

    <<[[ldobj()]] bloc and bsize init>>

    di = S;

// can come from AEND
newloop:
    version++;
    memset(h, 0, sizeof(h));
    histfrogp = 0;
    ipc = pc;
    skip = false;

loop:
    if(c <= 0)
        goto eof;

    <<[[ldobj()]] read if needed in loop:, adjust bloc and bsize>>

    // get the opcode
    o = bloc[0] | (bloc[1] << 8); // >>

    <<[[ldobj()]] sanity check opcode in range(x86)>>

    <<[[ldobj()]] if ANAME or ASIGNAME(x86)>>

    //TODO: factorize
    while(nhunk < sizeof(Prog))
        gethunk();
    p = (Prog*)hunk;
    nhunk -= sizeof(Prog);
    hunk += sizeof(Prog);

    p->as = o;
    p->line = bloc[2] | (bloc[3] << 8) | (bloc[4] << 16) | (bloc[5] << 24);
    p->back = 2;
    // >> >> >>

    r = zaddr(bloc+6, &p->from, h) + 6;
    r += zaddr(bloc+r, &p->to, h);

    bloc += r;
    c -= r;

    if(debug['W'])
        print("%P\n", p);

    switch(p->as) {
    <<[[ldobj()]] switch as cases(x86)>>

    default:
    casdef:
        if(skip)
            nopout(p);

        if(p->to.type == D_BRANCH)
            p->to.offset += ipc;

        lastp->link = p;
        lastp = p;

        p->pc = pc;
        pc++;
    }
    goto loop;

eof:
    diag("truncated object file: %s", pn);
}
@

% >> >> >> >>

<<[[ldobj()]] locals(x86)>>=
// enum<as>, the opcode
int o;
Prog *p;
@


% ???
<<[[ldobj()]] locals(x86)>>=
Sym *h[NSYM];
Sym *di;
Sym *s;
long ipc;
bool skip;
@

%???
<<[[ldobj()]] locals(x86)>>=
Prog *t;
byte *stop;
int v;
ulong sig;
@

<<[[ldobj()]] locals(x86)>>=
byte *bloc;
byte *bsize;
int r;
@
% and parameter 'int c'

<<[[ldobj()]] sanity check opcode in range(x86)>>=
if(o <= AXXX || o >= ALAST) {
    if(o < 0)
        goto eof;
    diag("%s: opcode out of range %d", pn, o);
    print("	probably not a .8 file\n");
    errorexit();
}
@

<<[[ldobj()]] locals(x86)>>=
// array<string>, length used = files, extended every 16
static char **filen;
static int files = 0;
char **nfilen;
@

<<[[ldobj()]] if ANAME or ASIGNAME(x86)>>=
if(o == ANAME || o == ASIGNAME) {
    sig = 0;
    if(o == ASIGNAME) {
        sig = bloc[2] | (bloc[3]<<8) | (bloc[4]<<16) | (bloc[5]<<24);
        // >> >> >>
        bloc += 4;
        c -= 4;
    }
    stop = memchr(&bloc[4], 0, bsize-&bloc[4]);
    if(stop == nil){
        bsize = readsome(f, buf.ibuf, bloc, bsize, c);
        if(bsize == 0)
            goto eof;
        bloc = buf.ibuf;
        stop = memchr(&bloc[4], 0, bsize-&bloc[4]);
        if(stop == nil){
            fprint(2, "%s: name too long\n", pn);
            errorexit();
        }
    }

    v = bloc[2];	/* type */
    o = bloc[3];	/* sym */
    bloc += 4;
    c -= 4;

    r = 0;
    if(v == D_STATIC)
        r = version;
    s = lookup((char*)bloc, r);

    c -= &stop[1] - bloc;
    bloc = stop + 1;

    if(debug['S'] && r == 0)
        sig = 1729;
    if(sig != 0){
        if(s->sig != 0 && s->sig != sig)
            diag("incompatible type signatures %lux(%s) and %lux(%s) for %s", s->sig, filen[s->file], sig, pn, s->name);
        s->sig = sig;
        s->file = files-1;
    }

    if(debug['W'])
        print("	ANAME	%s\n", s->name);

    h[o] = s;
    if((v == D_EXTERN || v == D_STATIC) && s->type == 0)
        s->type = SXREF;
    if(v == D_FILE) {
        if(s->type != SFILE) {
            histgen++;
            s->type = SFILE;
            s->value = histgen;
        }
        if(histfrogp < MAXHIST) {
            histfrog[histfrogp] = s;
            histfrogp++;
        } else
            collapsefrog(s);
    }
    goto loop;
}
@
% >> >> >>

<<[[ldobj()]] switch as cases(x86)>>=
case ATEXT:
    if(curtext != P) {
        histtoauto();
        curtext->to.autom = curauto;
        curauto = 0;
    }
    skip = false;
    curtext = p;
    s = p->from.sym;
    if(s == S) {
        diag("%s: no TEXT symbol: %P", pn, p);
        errorexit();
    }
    if(s->type != 0 && s->type != SXREF) {
        if(p->from.scale & DUPOK) {
            skip = true;
            goto casdef;
        }
        diag("%s: redefinition: %s\n%P", pn, s->name, p);
    }
    s->type = STEXT;
    s->value = pc;

    //add_list(firstp, lastp, p)
    lastp->link = p;
    lastp = p;

    p->pc = pc;
    pc++;

    //add_list(textp, etextp, p)
    if(textp == P) {
        textp = p;
        etextp = p;
    } else {
        etextp->pcond = p;
        etextp = p;
    }

    break;
@

<<[[ldobj()]] switch as cases(x86)>>=
case ADATA:
data:
    //add_list(datap, edatap, p)
    if(edatap == P)
        datap = p;
    else
        edatap->link = p;
    edatap = p;
    p->link = P;
    break;
@

<<[[ldobj()]] switch as cases(x86)>>=
case ADYNT:
    if(p->to.sym == S) {
        diag("DYNT without a sym\n%P", p);
        break;
    }
    di = p->to.sym;
    p->from.scale = 4; // NOSPLIT?
    if(di->type == SXREF) {
        if(debug['z'])
            Bprint(&bso, "%P set to %d\n", p, dtype);
        di->type = SCONST;
        di->value = dtype;
        dtype += 4;
    }
    if(p->from.sym == S)
        break;

    p->from.offset = di->value;
    p->from.sym->type = SDATA;
    if(curtext == P) {
        diag("DYNT not in text: %P", p);
        break;
    }
    p->to.sym = curtext->from.sym;
    p->to.type = D_ADDR;
    p->to.index = D_EXTERN;
    goto data;
@

<<[[ldobj()]] switch as cases(x86)>>=
case AINIT:
    if(p->from.sym == S) {
        diag("INIT without a sym\n%P", p);
        break;
    }
    if(di == S) {
        diag("INIT without previous DYNT\n%P", p);
        break;
    }
    p->from.offset = di->value;
    p->from.sym->type = SDATA;
    goto data;
@

<<[[ldobj()]] switch as cases(x86)>>=
case AGLOBL:
    s = p->from.sym;
    if(s->type == 0 || s->type == SXREF) {
        s->type = SBSS;
        s->value = 0;
    }
    if(s->type != SBSS) {
        diag("%s: redefinition: %s in %s",
            pn, s->name, TNAME);
        s->type = SBSS;
        s->value = 0;
    }
    if(p->to.offset > s->value)
        s->value = p->to.offset;
    break;
@

<<[[ldobj()]] switch as cases(x86)>>=
case AHISTORY:
    if(p->to.offset == -1) {
        addlib(pn);
        histfrogp = 0;
        goto loop;
    }
    addhist(p->line, D_FILE);		/* 'z' */
    if(p->to.offset)
        addhist(p->to.offset, D_FILE1);	/* 'Z' */
    histfrogp = 0;
    break;
@

<<[[ldobj()]] switch as cases(x86)>>=
case AEND:
    histtoauto();
    if(curtext != P)
        curtext->to.autom = curauto;
    curauto = 0;
    curtext = P;
    if(c)
        goto newloop;
    return;
@


<<[[ldobj()]] switch as cases(x86)>>=
case AGOK:
    diag("%s: GOK opcode in %s", pn, TNAME);
    pc++;
    break;
@

<<[[ldobj()]] switch as cases(x86)>>=
case AFMOVF:
case AFADDF:
case AFSUBF:
case AFSUBRF:
case AFMULF:
case AFDIVF:
case AFDIVRF:
case AFCOMF:
case AFCOMFP:
    if(skip)
        goto casdef;
    if(p->from.type == D_FCONST) {
        /* size sb 9 max */
        sprint(literal, "$%lux", ieeedtof(&p->from.ieee));
        s = lookup(literal, 0);
        if(s->type == 0) {
            s->type = SBSS;
            s->value = 4;
            t = prg();
            t->as = ADATA;
            t->line = p->line;
            t->from.type = D_EXTERN;
            t->from.sym = s;
            t->from.scale = 4;  // NOSPLIT?
            t->to = p->from;
            if(edatap == P)
                datap = t;
            else
                edatap->link = t;
            edatap = t;
            t->link = P;
        }
        p->from.type = D_EXTERN;
        p->from.sym = s;
        p->from.offset = 0;
    }
    goto casdef;
@
%$

<<[[ldobj()]] switch as cases(x86)>>=
case AFMOVD:
case AFADDD:
case AFSUBD:
case AFSUBRD:
case AFMULD:
case AFDIVD:
case AFDIVRD:
case AFCOMD:
case AFCOMDP:
    if(skip)
        goto casdef;
    if(p->from.type == D_FCONST) {
        /* size sb 18 max */
        sprint(literal, "$%lux.%lux",
            p->from.ieee.l, p->from.ieee.h);
        s = lookup(literal, 0);
        if(s->type == 0) {
            s->type = SBSS;
            s->value = 8;
            t = prg();
            t->as = ADATA;
            t->line = p->line;
            t->from.type = D_EXTERN;
            t->from.sym = s;
            t->from.scale = 8;
            t->to = p->from;
            if(edatap == P)
                datap = t;
            else
                edatap->link = t;
            edatap = t;
            t->link = P;
        }
        p->from.type = D_EXTERN;
        p->from.sym = s;
        p->from.offset = 0;
    }
    goto casdef;
@
%$


\section{[[linkers/8l/]]}

\subsection*{[[linkers/8l/elf.h]]}

%-------------------------------------------------------------

<<linkers/8l/elf.h>>=
#include <elf.h>

// vs include/elf.h? and libmach/elf.h?

<<enum _anon_ (linkers/8l/elf.h)>>

typedef void (*Putl)(long);

void	elf32(int mach, int bo, int addpsects, void (*putpsects)(Putl));
@
%void	elf64(int mach, int bo, int addpsects, void (*putpsects)(Putl));
%
%//void	elf32phdr(void (*putl)(long), ulong type, ulong off, ulong vaddr,
%//    ulong paddr, ulong filesz, ulong memsz, ulong prots, ulong align);
%//void	elf32shdr(void (*putl)(long), ulong name, ulong type, ulong flags,
%//    ulong vaddr, ulong off, ulong sectsz, ulong link, ulong addnl,
%//    ulong align, ulong entsz);
%//void	elf64phdr(void (*putl)(long), void (*putll)(vlong), ulong type,
%//    uvlong off, uvlong vaddr, uvlong paddr, uvlong filesz, uvlong memsz,
%//    ulong prots, uvlong align);
%//void	elf64shdr(void (*putl)(long), void (*putll)(vlong), ulong name,
%//    ulong type, uvlong flags, uvlong vaddr, uvlong off, uvlong sectsz,
%//    ulong link, ulong addnl, uvlong align, uvlong entsz);


\subsection*{[[linkers/8l/l.h]]}




\ifallcode
% can have unamed union that then alleviate the need for those macros!
% this is not used anymore for the arm, but could be used by 8l
% todo: need to adapt graph_code_c to find those fields
<<constant offset>>=
#define	offset	u0.u0offset
@
<<constant ieee>>=
#define	ieee	u0.u0ieee
@
<<constant autom>>=
#define	autom	u1.u1autom
@
<<constant sym>>=
#define	sym	u1.u1sym
@
%<<constant sval(arm)>>=
%#define	sval	u0.u0sval
%@
\fi



<<enum misc1(x86)>>=
enum misc1 {
    <<constant NHASH linker>>
    <<constant NHUNK linker>>

    MINSIZ		= 4,
    <<constant STRINGSZ>>
    MINLC		= 1,
    <<constant MAXIO>>
    MAXHIST		= 20, /* limit of path elements for history symbols */
};
@


%-------------------------------------------------------------

<<linkers/8l/l.h>>=
#include	<u.h>
#include	<libc.h>
#include	<bio.h>

#include	<common.out.h>
#include	<386/8.out.h>
#include	"elf.h"

<<macro DBG>>

<<constant P>>
<<constant S>>

<<constant TNAME(x86)>>

<<function cput(x86)>>

<<constant LIBNAMELEN>>

typedef	struct	Adr	Adr;
typedef	struct	Prog	Prog;
typedef	struct	Sym	Sym;
typedef	struct	Auto	Auto;
typedef	struct	Optab	Optab;

<<struct Adr(x86)>>

<<constant offset>>
<<constant scon(x86)>>
<<constant cond(x86)>>
<<constant ieee>>

<<constant autom>>
<<constant sym>>

<<struct Prog(x86)>>
<<struct Auto(x86)>>
<<struct Sym>>
<<struct Optab(x86)>>

<<enum sxxx(x86)>>
<<enum yxxx(x86)>>
<<enum zxxx(x86)>>
<<enum pxxx(x86)>>
<<enum rxxx>>

<<enum misc1(x86)>>

<<enum headtype(x86)>>

<<struct Buf>>
extern union Buf buf;

#pragma	varargck	type	"A"	int
#pragma	varargck	type	"A"	uint
#pragma	varargck	type	"D"	Adr*
#pragma	varargck	type	"P"	Prog*
#pragma	varargck	type	"R"	int
#pragma	varargck	type	"R"	uint
#pragma	varargck	type	"S"	char*

#pragma	varargck	argpos	diag 1

extern	long	HEADR;
extern	short	HEADTYPE;
extern	long	INITDAT;
extern	long	INITRND;
extern	long	INITTEXT;
extern	long	INITTEXTP;
extern	char*	INITENTRY;		/* entry point */

extern	Biobuf	bso;
extern	long	bsssize;
extern	int	cbc;
extern	char*	cbp;
extern	char*	pcstr;
extern	int	cout;
extern	Prog*	curp;
extern	Prog*	curtext;
extern	Prog*	datap;
extern	Prog*	edatap;
extern	long	datsize;
extern	bool	debug[128];
extern	Prog*	firstp;
extern	char	fnuxi8[8];
extern	char	fnuxi4[4];
extern	Sym*	hash[NHASH];
extern	char*	hunk;
extern	char	inuxi1[1];
extern	char	inuxi2[2];
extern	char	inuxi4[4];
extern	char	ycover[Ymax*Ymax];
extern	uchar*	andptr;
extern	uchar	and[30];
extern	char	reg[D_NONE];
extern	Prog*	lastp;
extern	long	lcsize;
extern	int	nerrors;
extern	long	nhunk;
extern	long	nsymbol;
//@Scheck: used by TName, not useless
extern	char*	noname;
extern	char*	outfile;
extern	long	pc;
extern	long	symsize;
extern	Prog*	textp;
extern	long	textsize;
extern	long	thunk;
extern	Prog	zprg;
extern	int	dtype;

extern	Adr*	reloca;
extern	bool	dlm;
extern	int	imports, nimports;
extern	int	exports, nexports;
bool allexport;
extern	char*	EXPTAB;
extern	Prog	undefp;

<<constant UP>>

extern	Optab	optab[];
//@Scheck: defined in ../8c/enam.c
extern	char*	anames[];


Prog*	appendp(Prog*);
void	asmb(void);
void	asmdyn(void);
void	asmins(Prog*);
void	asmlc(void);

void	asmsym(void);
long	atolwhex(char*);

void	cflush(void);
void	ckoff(Sym*, long);
Prog*	copyp(Prog*);

double	cputime(void); //?


void	diag(char*, ...);
void	dodata(void);
void	doinit(void);
void	dostkoff(void);
void	dynreloc(Sym*, ulong, int);

void	errorexit(void);
void	export(void);
int	fileexists(char*);


void	follow(void);
void	gethunk(void);
long	ieeedtof(Ieee*);
void	import(void);

void	listinit(void);
Sym*	lookup(char*, int);
void	lput(long);
void	lputl(long);
void	llput(vlong v);
void	llputl(vlong v);
void	main(int, char*[]);

void	patch(void);
Prog*	prg(void);


long	rnd(long, long);
void	span(void);
void	strnput(char*, int);
void	undef(void);
void	undefsym(Sym*);

void	wput(long);
void	wputl(long);
void	xdefine(char*, int, long);

void mylog(char*, ...);


#pragma	varargck	type	"D"	Adr*
#pragma	varargck	type	"P"	Prog*
#pragma	varargck	type	"R"	int
#pragma	varargck	type	"A"	int
@


\subsection*{[[linkers/8l/globals.c]]}


<<global literal(x86)>>=
char	literal[32];
@




<<global andptr(x86)>>=
uchar*	andptr;
@

<<global and(x86)>>=
uchar	and[30];
@


<<global dtype(x86)>>=
int	dtype;
@



%-------------------------------------------------------------

<<linkers/8l/globals.c>>=
#include	"l.h"

<<global buf>>

<<global HEADR>>
<<global HEADTYPE>>
<<global INITDAT>>
<<global INITRND>>
<<global INITTEXT>>
<<global INITTEXTP>>
<<global INITENTRY>>

<<global bso>>
<<global bsssize>>

<<global cbc>>
<<global cbp>>

<<global pcstr(x86)>>
<<global cout>>
<<global curp>>
<<global curtext>>
<<global datap>>
<<global edatap(x86)>>
<<global datsize>>
<<global debug>>
<<global firstp>>

<<global fnuxi4>>
<<global fnuxi8>>

<<global hash linker>>
<<global hunk>>

<<global inuxi1>>
<<global inuxi2>>
<<global inuxi4>>

<<global ycover(x86)>>
<<global andptr(x86)>>
<<global and(x86)>>
<<global reg(x86)>>
<<global lastp>>
<<global lcsize>>
<<global nerrors>>
<<global nhunk>>
<<global nsymbol linker>>
<<global outfile>>

<<global pc>>

<<global symsize>>
<<global textp>>
<<global textsize>>
<<global thunk>>
<<global zprg>>
<<global dtype(x86)>>

<<global reloca(x86)>>

<<global dlm>>
<<global nimports>>
<<global nexports>>
<<global imports>>
<<global exports>>

int	allexport;

<<global EXPTAB>>
<<global undefp>>

@


\subsection*{[[linkers/8l/optab.c]]}

%-------------------------------------------------------------

<<linkers/8l/optab.c>>=
#include	"l.h"

<<global ynone(x86)>>
<<global ytext(x86)>>
<<global ynop(x86)>>
<<global yxorb(x86)>>
<<global yxorl(x86)>>
<<global yaddl(x86)>>
<<global yincb(x86)>>
<<global yincl(x86)>>
<<global ycmpb(x86)>>
<<global ycmpl(x86)>>
<<global yshb(x86)>>
<<global yshl(x86)>>
<<global ytestb(x86)>>
<<global ytestl(x86)>>
<<global ymovb(x86)>>
<<global ymovl(x86)>>
<<global ym_rl(x86)>>
<<global yrl_m(x86)>>
<<global ymb_rl(x86)>>
<<global yml_rl(x86)>>
<<global yrl_ml(x86)>>
<<global yml_mb(x86)>>
<<global yml_ml(x86)>>
<<global ydivl(x86)>>
<<global ydivb(x86)>>
<<global yimul(x86)>>
<<global ybyte(x86)>>
<<global yin(x86)>>
<<global yint(x86)>>
<<global ypushl(x86)>>
<<global ypopl(x86)>>
<<global yscond(x86)>>
<<global yjcond(x86)>>
<<global yloop(x86)>>
<<global ycall(x86)>>
<<global yjmp(x86)>>

<<global yfmvd(x86)>>
<<global yfmvdp(x86)>>
<<global yfmvf(x86)>>
<<global yfmvx(x86)>>
<<global yfmvp(x86)>>
<<global yfadd(x86)>>
<<global yfaddp(x86)>>
<<global yfxch(x86)>>
<<global ycompp(x86)>>
<<global ystsw(x86)>>
<<global ystcw(x86)>>
<<global ysvrs(x86)>>

<<global optab(x86)>>
@

\subsection*{[[linkers/8l/utils.c]]}

<<linkers/8l/utils.c>>=
#include "l.h"

<<function log>>

<<function errorexit>>

<<function gethunk>>

<<function lookup>>

<<constructor prg>>

<<function copyp>>

@

\subsection*{[[linkers/8l/list.c]]}

%-------------------------------------------------------------

<<linkers/8l/list.c>>=
#include	"l.h"

int	Aconv(Fmt*);
int	Dconv(Fmt*);
int	Pconv(Fmt*);
int	Rconv(Fmt*);
int	Sconv(Fmt*);

<<function listinit(x86)>>

<<global bigP(x86)>>

<<function Pconv(x86)>>

<<function Aconv(x86)>>

<<function Dconv(x86)>>

<<global regstr(x86)>>

<<function Rconv(x86)>>

<<function Sconv(x86)>>

<<function diag>>
@


\subsection*{[[linkers/8l/compat.c]]}


%-------------------------------------------------------------

<<linkers/8l/compat.c>>=
#include	"l.h"

<<function malloc>>

<<function free>>

<<function setmalloctag>>

<<function fileexists>>
@


\subsection*{[[linkers/8l/pass.c]]}

%-------------------------------------------------------------

<<linkers/8l/pass.c>>=
#include	"l.h"

void	xfol(Prog*);
int	relinv(int);
void	mkfwd(void);
Prog*	brloop(Prog*);

<<function dodata(x86)>>

<<function brchain(x86)>>

<<function follow>>

<<function xfol(x86)>>

<<function relinv(x86)>>

<<function doinit(x86)>>

<<function patch(x86)>>

<<constant LOG>>
<<function mkfwd>>

<<function brloop(x86)>>

<<function dostkoff(x86)>>

<<function atolwhex>>

<<function undef>>

<<function import(x86)>>

<<function ckoff>>

<<function newdata(x86)>>

<<function export(x86)>>
@


\subsection*{[[linkers/8l/asm.c]]}

%-------------------------------------------------------------

<<linkers/8l/asm.c>>=
#include	"l.h"

<<constant Dbufslop>>

<<global spsize(x86)>>

void	datblk(long, long);

<<function entryvalue(x86)>>

<<function wputl(x86)>>

<<function wput(x86)>>

<<function lput(x86)>>

<<function lputl(x86)>>

<<function llput>>

<<function llputl>>

<<function strnput(x86)>>

<<function asmb(x86)>>

<<function cflush>>

<<function datblk(x86)>>

<<function rnd>>
@


\subsection*{[[linkers/8l/span.c]]}


<<function oclass(x86)>>=
int
oclass(Adr *a)
{
    long v;

    if(a->type >= D_INDIR || a->index != D_NONE) {
        if(a->index != D_NONE && a->scale == 0) {
            if(a->type == D_ADDR) {
                switch(a->index) {
                case D_EXTERN:
                case D_STATIC:
                    return Yi32;
                case D_LOCAL:
                case D_PARAM:
                    return Yiauto;
                }
                return Yxxx;
            }
            return Ycol;
        }
        return Ym;
    }
    switch(a->type)
    {
    case D_AL:
        return Yal;

    case D_AX:
        return Yax;

    case D_CL:
        return Ycl;

    case D_DL:
    case D_BL:
    case D_AH:
    case D_CH:
    case D_DH:
    case D_BH:
        return Yrb;

    case D_CX:
        return Ycx;

    case D_DX:
    case D_BX:
        return Yrx;

    case D_SP:
    case D_BP:
    case D_SI:
    case D_DI:
        return Yrl;

    case D_F0+0:
        return	Yf0;

    case D_F0+1:
    case D_F0+2:
    case D_F0+3:
    case D_F0+4:
    case D_F0+5:
    case D_F0+6:
    case D_F0+7:
        return	Yrf;

    case D_NONE:
        return Ynone;

    case D_CS:	return	Ycs;
    case D_SS:	return	Yss;
    case D_DS:	return	Yds;
    case D_ES:	return	Yes;
    case D_FS:	return	Yfs;
    case D_GS:	return	Ygs;

    case D_GDTR:	return	Ygdtr;
    case D_IDTR:	return	Yidtr;
    case D_LDTR:	return	Yldtr;
    case D_MSW:	return	Ymsw;
    case D_TASK:	return	Ytask;

    case D_CR+0:	return	Ycr0;
    case D_CR+1:	return	Ycr1;
    case D_CR+2:	return	Ycr2;
    case D_CR+3:	return	Ycr3;
    case D_CR+4:	return	Ycr4;
    case D_CR+5:	return	Ycr5;
    case D_CR+6:	return	Ycr6;
    case D_CR+7:	return	Ycr7;

    case D_DR+0:	return	Ydr0;
    case D_DR+1:	return	Ydr1;
    case D_DR+2:	return	Ydr2;
    case D_DR+3:	return	Ydr3;
    case D_DR+4:	return	Ydr4;
    case D_DR+5:	return	Ydr5;
    case D_DR+6:	return	Ydr6;
    case D_DR+7:	return	Ydr7;

    case D_TR+0:	return	Ytr0;
    case D_TR+1:	return	Ytr1;
    case D_TR+2:	return	Ytr2;
    case D_TR+3:	return	Ytr3;
    case D_TR+4:	return	Ytr4;
    case D_TR+5:	return	Ytr5;
    case D_TR+6:	return	Ytr6;
    case D_TR+7:	return	Ytr7;

    case D_EXTERN:
    case D_STATIC:
    case D_LOCAL:
    case D_PARAM:
        return Ym;

    case D_CONST:
    case D_ADDR:
        if(a->sym == S) {
            v = a->offset;
            if(v == 0)
                return Yi0;
            if(v == 1)
                return Yi1;
            if(v >= -128 && v <= 127)
                return Yi8;
        }
        return Yi32;

    case D_BRANCH:
        return Ybr;
    }
    return Yxxx;
}
@

<<function asmidx(x86)>>=
void
asmidx(Adr *a, int base)
{
    int i;

    switch(a->index) {
    default:
        goto bad;

    case D_NONE:
        i = 4 << 3;
        goto bas;

    case D_AX:
    case D_CX:
    case D_DX:
    case D_BX:
    case D_BP:
    case D_SI:
    case D_DI:
        i = reg[a->index] << 3;
        break;
    }
    switch(a->scale) {
    default:
        goto bad;
    case 1:
        break;
    case 2:
        i |= (1<<6);
        break;
    case 4:
        i |= (2<<6);
        break;
    case 8:
        i |= (3<<6);
        break;
    }
bas:
    switch(base) {
    default:
        goto bad;
    case D_NONE:	/* must be mod=00 */
        i |= 5;
        break;
    case D_AX:
    case D_CX:
    case D_DX:
    case D_BX:
    case D_SP:
    case D_BP:
    case D_SI:
    case D_DI:
        i |= reg[base];
        break;
    }
    *andptr++ = i;
    return;
bad:
    diag("asmidx: bad address %D", a);
    *andptr++ = 0;
    return;
}
@
%>> >> >> >> >>

<<function put4(x86)>>=
static void
put4(long v)
{
    if(dlm && curp != P && reloca != nil){
        dynreloc(reloca->sym, curp->pc + andptr - &and[0], 1);
        reloca = nil;
    }
    andptr[0] = v;
    andptr[1] = v>>8;
    andptr[2] = v>>16;
    andptr[3] = v>>24;
    andptr += 4;
}
@

<<function vaddr(x86)>>=
long
vaddr(Adr *a)
{
    int t;
    long v;
    Sym *s;

    t = a->type;
    v = a->offset;
    if(t == D_ADDR)
        t = a->index;
    switch(t) {
    case D_STATIC:
    case D_EXTERN:
        s = a->sym;
        if(s != nil) {
            if(dlm && curp != P)
                reloca = a;
            switch(s->type) {
            case SUNDEF:
                ckoff(s, v);
            case STEXT:
            case SCONST:
                v += s->value;
                break;
            default:
                v += INITDAT + s->value;
            }
        }
    }
    return v;
}
@

<<function asmand(x86)>>=
void
asmand(Adr *a, int r)
{
    long v;
    int t;
    Adr aa;

    v = a->offset;
    t = a->type;
    if(a->index != D_NONE) {
        if(t >= D_INDIR) {
            t -= D_INDIR;
            if(t == D_NONE) {
                *andptr++ = (0 << 6) | (4 << 0) | (r << 3);
                asmidx(a, t);
                put4(v);
                return;
            }
            if(v == 0 && t != D_BP) {
                *andptr++ = (0 << 6) | (4 << 0) | (r << 3);
                asmidx(a, t);
                return;
            }
            if(v >= -128 && v < 128) {
                *andptr++ = (1 << 6) | (4 << 0) | (r << 3);
                asmidx(a, t);
                *andptr++ = v;
                return;
            }
            *andptr++ = (2 << 6) | (4 << 0) | (r << 3);
            asmidx(a, t);
            put4(v);
            return;
        }
        switch(t) {
        default:
            goto bad;
        case D_STATIC:
        case D_EXTERN:
            aa.type = D_NONE+D_INDIR;
            break;
        case D_LOCAL:
        case D_PARAM:
            aa.type = D_SP+D_INDIR;
            break;
        }
        aa.offset = vaddr(a);
        aa.index = a->index;
        aa.scale = a->scale;
        asmand(&aa, r);
        return;
    }
    if(t >= D_AL && t <= D_F0+7) {
        if(v)
            goto bad;
        *andptr++ = (3 << 6) | (reg[t] << 0) | (r << 3);
        return;
    }
    if(t >= D_INDIR) {
        t -= D_INDIR;
        if(t == D_NONE || D_CS <= t && t <= D_GS) {
            *andptr++ = (0 << 6) | (5 << 0) | (r << 3);
            put4(v);
            return;
        }
        if(t == D_SP) {
            if(v == 0) {
                *andptr++ = (0 << 6) | (4 << 0) | (r << 3);
                asmidx(a, D_SP);
                return;
            }
            if(v >= -128 && v < 128) {
                *andptr++ = (1 << 6) | (4 << 0) | (r << 3);
                asmidx(a, D_SP);
                *andptr++ = v;
                return;
            }
            *andptr++ = (2 << 6) | (4 << 0) | (r << 3);
            asmidx(a, D_SP);
            put4(v);
            return;
        }
        if(t >= D_AX && t <= D_DI) {
            if(v == 0 && t != D_BP) {
                *andptr++ = (0 << 6) | (reg[t] << 0) | (r << 3);
                return;
            }
            if(v >= -128 && v < 128) {
                andptr[0] = (1 << 6) | (reg[t] << 0) | (r << 3);
                andptr[1] = v;
                andptr += 2;
                return;
            }
            *andptr++ = (2 << 6) | (reg[t] << 0) | (r << 3);
            put4(v);
            return;
        }
        goto bad;
    }
    switch(a->type) {
    default:
        goto bad;
    case D_STATIC:
    case D_EXTERN:
        aa.type = D_NONE+D_INDIR;
        break;
    case D_LOCAL:
    case D_PARAM:
        aa.type = D_SP+D_INDIR;
        break;
    }
    aa.index = D_NONE;
    aa.scale = 1;
    aa.offset = vaddr(a);
    asmand(&aa, r);
    return;
bad:
    diag("asmand: bad address %D", a);
    return;
}
@

<<constant E(x86)>>=
#define	E	0xff
@

<<global ymovtab(x86)>>=
uchar	ymovtab[] =
{
/* push */
    APUSHL,	Ycs,	Ynone,	0,	0x0e,E,0,0,
    APUSHL,	Yss,	Ynone,	0,	0x16,E,0,0,
    APUSHL,	Yds,	Ynone,	0,	0x1e,E,0,0,
    APUSHL,	Yes,	Ynone,	0,	0x06,E,0,0,
    APUSHL,	Yfs,	Ynone,	0,	0x0f,0xa0,E,0,
    APUSHL,	Ygs,	Ynone,	0,	0x0f,0xa8,E,0,

    APUSHW,	Ycs,	Ynone,	0,	Pe,0x0e,E,0,
    APUSHW,	Yss,	Ynone,	0,	Pe,0x16,E,0,
    APUSHW,	Yds,	Ynone,	0,	Pe,0x1e,E,0,
    APUSHW,	Yes,	Ynone,	0,	Pe,0x06,E,0,
    APUSHW,	Yfs,	Ynone,	0,	Pe,0x0f,0xa0,E,
    APUSHW,	Ygs,	Ynone,	0,	Pe,0x0f,0xa8,E,

/* pop */
    APOPL,	Ynone,	Yds,	0,	0x1f,E,0,0,
    APOPL,	Ynone,	Yes,	0,	0x07,E,0,0,
    APOPL,	Ynone,	Yss,	0,	0x17,E,0,0,
    APOPL,	Ynone,	Yfs,	0,	0x0f,0xa1,E,0,
    APOPL,	Ynone,	Ygs,	0,	0x0f,0xa9,E,0,

    APOPW,	Ynone,	Yds,	0,	Pe,0x1f,E,0,
    APOPW,	Ynone,	Yes,	0,	Pe,0x07,E,0,
    APOPW,	Ynone,	Yss,	0,	Pe,0x17,E,0,
    APOPW,	Ynone,	Yfs,	0,	Pe,0x0f,0xa1,E,
    APOPW,	Ynone,	Ygs,	0,	Pe,0x0f,0xa9,E,

/* mov seg */
    AMOVW,	Yes,	Yml,	1,	0x8c,0,0,0,
    AMOVW,	Ycs,	Yml,	1,	0x8c,1,0,0,
    AMOVW,	Yss,	Yml,	1,	0x8c,2,0,0,
    AMOVW,	Yds,	Yml,	1,	0x8c,3,0,0,
    AMOVW,	Yfs,	Yml,	1,	0x8c,4,0,0,
    AMOVW,	Ygs,	Yml,	1,	0x8c,5,0,0,

    AMOVW,	Yml,	Yes,	2,	0x8e,0,0,0,
    AMOVW,	Yml,	Ycs,	2,	0x8e,1,0,0,
    AMOVW,	Yml,	Yss,	2,	0x8e,2,0,0,
    AMOVW,	Yml,	Yds,	2,	0x8e,3,0,0,
    AMOVW,	Yml,	Yfs,	2,	0x8e,4,0,0,
    AMOVW,	Yml,	Ygs,	2,	0x8e,5,0,0,

/* mov cr */
    AMOVL,	Ycr0,	Yml,	3,	0x0f,0x20,0,0,
    AMOVL,	Ycr2,	Yml,	3,	0x0f,0x20,2,0,
    AMOVL,	Ycr3,	Yml,	3,	0x0f,0x20,3,0,
    AMOVL,	Ycr4,	Yml,	3,	0x0f,0x20,4,0,

    AMOVL,	Yml,	Ycr0,	4,	0x0f,0x22,0,0,
    AMOVL,	Yml,	Ycr2,	4,	0x0f,0x22,2,0,
    AMOVL,	Yml,	Ycr3,	4,	0x0f,0x22,3,0,
    AMOVL,	Yml,	Ycr4,	4,	0x0f,0x22,4,0,

/* mov dr */
    AMOVL,	Ydr0,	Yml,	3,	0x0f,0x21,0,0,
    AMOVL,	Ydr6,	Yml,	3,	0x0f,0x21,6,0,
    AMOVL,	Ydr7,	Yml,	3,	0x0f,0x21,7,0,

    AMOVL,	Yml,	Ydr0,	4,	0x0f,0x23,0,0,
    AMOVL,	Yml,	Ydr6,	4,	0x0f,0x23,6,0,
    AMOVL,	Yml,	Ydr7,	4,	0x0f,0x23,7,0,

/* mov tr */
    AMOVL,	Ytr6,	Yml,	3,	0x0f,0x24,6,0,
    AMOVL,	Ytr7,	Yml,	3,	0x0f,0x24,7,0,

    AMOVL,	Yml,	Ytr6,	4,	0x0f,0x26,6,E,
    AMOVL,	Yml,	Ytr7,	4,	0x0f,0x26,7,E,

/* lgdt, sgdt, lidt, sidt */
    AMOVL,	Ym,	Ygdtr,	4,	0x0f,0x01,2,0,
    AMOVL,	Ygdtr,	Ym,	3,	0x0f,0x01,0,0,
    AMOVL,	Ym,	Yidtr,	4,	0x0f,0x01,3,0,
    AMOVL,	Yidtr,	Ym,	3,	0x0f,0x01,1,0,

/* lldt, sldt */
    AMOVW,	Yml,	Yldtr,	4,	0x0f,0x00,2,0,
    AMOVW,	Yldtr,	Yml,	3,	0x0f,0x00,0,0,

/* lmsw, smsw */
    AMOVW,	Yml,	Ymsw,	4,	0x0f,0x01,6,0,
    AMOVW,	Ymsw,	Yml,	3,	0x0f,0x01,4,0,

/* ltr, str */
    AMOVW,	Yml,	Ytask,	4,	0x0f,0x00,3,0,
    AMOVW,	Ytask,	Yml,	3,	0x0f,0x00,1,0,

/* load full pointer */
    AMOVL,	Yml,	Ycol,	5,	0,0,0,0,
    AMOVW,	Yml,	Ycol,	5,	Pe,0,0,0,

/* double shift */
    ASHLL,	Ycol,	Yml,	6,	0xa4,0xa5,0,0,
    ASHRL,	Ycol,	Yml,	6,	0xac,0xad,0,0,

/* extra imul */
    AIMULW,	Yml,	Yrl,	7,	Pq,0xaf,0,0,
    AIMULL,	Yml,	Yrl,	7,	Pm,0xaf,0,0,
    0
};
@

<<function isax(x86)>>=
int
isax(Adr *a)
{

    switch(a->type) {
    case D_AX:
    case D_AL:
    case D_AH:
    case D_INDIR+D_AX:
        return 1;
    }
    if(a->index == D_AX)
        return 1;
    return 0;
}
@

<<function subreg(x86)>>=
void
subreg(Prog *p, int from, int to)
{

    if(debug['Q'])
        print("\n%P	s/%R/%R/\n", p, from, to);

    if(p->from.type == from)
        p->from.type = to;
    if(p->to.type == from)
        p->to.type = to;

    if(p->from.index == from)
        p->from.index = to;
    if(p->to.index == from)
        p->to.index = to;

    from += D_INDIR;
    if(p->from.type == from)
        p->from.type = to+D_INDIR;
    if(p->to.type == from)
        p->to.type = to+D_INDIR;

    if(debug['Q'])
        print("%P\n", p);
}
@

<<function doasm(x86)>>=
void
doasm(Prog *p)
{
    Optab *o;
    Prog *q, pp;
    uchar *t;
    int z, op, ft, tt;
    long v, pre;

    pre = prefixof(&p->from);
    if(pre)
        *andptr++ = pre;
    pre = prefixof(&p->to);
    if(pre)
        *andptr++ = pre;

    o = &optab[p->as];
    ft = oclass(&p->from) * Ymax;
    tt = oclass(&p->to) * Ymax;
    t = o->ytab;
    if(t == 0) {
        diag("asmins: noproto %P", p);
        return;
    }
    for(z=0; *t; z+=t[3],t+=4)
        if(ycover[ft+t[0]])
        if(ycover[tt+t[1]])
            goto found;
    goto domov;

found:
    switch(o->prefix) {
    case Pq:	/* 16 bit escape and opcode escape */
        *andptr++ = Pe;
        *andptr++ = Pm;
        break;

    case Pm:	/* opcode escape */
        *andptr++ = Pm;
        break;

    case Pe:	/* 16 bit escape */
        *andptr++ = Pe;
        break;

    case Pb:	/* botch */
        break;
    }
    v = vaddr(&p->from);
    op = o->op[z];
    switch(t[2]) {
    default:
        diag("asmins: unknown z %d %P", t[2], p);
        return;

    case Zpseudo:
        break;

    case Zlit:
        for(; op = o->op[z]; z++)
            *andptr++ = op;
        break;

    case Zm_r:
        *andptr++ = op;
        asmand(&p->from, reg[p->to.type]);
        break;

    case Zaut_r:
        *andptr++ = 0x8d;	/* leal */
        if(p->from.type != D_ADDR)
            diag("asmins: Zaut sb type ADDR");
        p->from.type = p->from.index;
        p->from.index = D_NONE;
        asmand(&p->from, reg[p->to.type]);
        p->from.index = p->from.type;
        p->from.type = D_ADDR;
        break;

    case Zm_o:
        *andptr++ = op;
        asmand(&p->from, o->op[z+1]);
        break;

    case Zr_m:
        *andptr++ = op;
        asmand(&p->to, reg[p->from.type]);
        break;

    case Zo_m:
        *andptr++ = op;
        asmand(&p->to, o->op[z+1]);
        break;

    case Zm_ibo:
        v = vaddr(&p->to);
        *andptr++ = op;
        asmand(&p->from, o->op[z+1]);
        *andptr++ = v;
        break;

    case Zibo_m:
        *andptr++ = op;
        asmand(&p->to, o->op[z+1]);
        *andptr++ = v;
        break;

    case Z_ib:
        v = vaddr(&p->to);
    case Zib_:
        *andptr++ = op;
        *andptr++ = v;
        break;

    case Zib_rp:
        *andptr++ = op + reg[p->to.type];
        *andptr++ = v;
        break;

    case Zil_rp:
        *andptr++ = op + reg[p->to.type];
        if(o->prefix == Pe) {
            *andptr++ = v;
            *andptr++ = v>>8;
        }
        else
            put4(v);
        break;

    case Zib_rr:
        *andptr++ = op;
        asmand(&p->to, reg[p->to.type]);
        *andptr++ = v;
        break;

    case Z_il:
        v = vaddr(&p->to);
    case Zil_:
        *andptr++ = op;
        if(o->prefix == Pe) {
            *andptr++ = v;
            *andptr++ = v>>8;
        }
        else
            put4(v);
        break;

    case Zm_ilo:
        v = vaddr(&p->to);
        *andptr++ = op;
        asmand(&p->from, o->op[z+1]);
        if(o->prefix == Pe) {
            *andptr++ = v;
            *andptr++ = v>>8;
        }
        else
            put4(v);
        break;

    case Zilo_m:
        *andptr++ = op;
        asmand(&p->to, o->op[z+1]);
        if(o->prefix == Pe) {
            *andptr++ = v;
            *andptr++ = v>>8;
        }
        else
            put4(v);
        break;

    case Zil_rr:
        *andptr++ = op;
        asmand(&p->to, reg[p->to.type]);
        if(o->prefix == Pe) {
            *andptr++ = v;
            *andptr++ = v>>8;
        }
        else
            put4(v);
        break;

    case Z_rp:
        *andptr++ = op + reg[p->to.type];
        break;

    case Zrp_:
        *andptr++ = op + reg[p->from.type];
        break;

    case Zclr:
        *andptr++ = op;
        asmand(&p->to, reg[p->to.type]);
        break;

    case Zbr:
        q = p->pcond;
        if(q) {
            v = q->pc - p->pc - 2;
            if(v >= -128 && v <= 127) {
                *andptr++ = op;
                *andptr++ = v;
            } else {
                v -= 6-2;
                *andptr++ = 0x0f;
                *andptr++ = o->op[z+1];
                *andptr++ = v;
                *andptr++ = v>>8;
                *andptr++ = v>>16;
                *andptr++ = v>>24;
            }
        }
        break;

    case Zcall:
        q = p->pcond;
        if(q) {
            v = q->pc - p->pc - 5;
            if(dlm && curp != P && p->to.sym->type == SUNDEF){
                /* v = 0 - p->pc - 5; */
                v = 0;
                ckoff(p->to.sym, v);
                v += p->to.sym->value;
                dynreloc(p->to.sym, p->pc+1, 0);
            }
            *andptr++ = op;
            *andptr++ = v;
            *andptr++ = v>>8;
            *andptr++ = v>>16;
            *andptr++ = v>>24;
        }
        break;

    case Zjmp:
        q = p->pcond;
        if(q) {
            v = q->pc - p->pc - 2;
            if(v >= -128 && v <= 127) {
                *andptr++ = op;
                *andptr++ = v;
            } else {
                v -= 5-2;
                *andptr++ = o->op[z+1];
                *andptr++ = v;
                *andptr++ = v>>8;
                *andptr++ = v>>16;
                *andptr++ = v>>24;
            }
        }
        break;

    case Zloop:
        q = p->pcond;
        if(q) {
            v = q->pc - p->pc - 2;
            if(v < -128 || v > 127)
                diag("loop too far: %P", p);
            *andptr++ = op;
            *andptr++ = v;
        }
        break;

    case Zbyte:
        *andptr++ = v;
        if(op > 1) {
            *andptr++ = v>>8;
            if(op > 2) {
                *andptr++ = v>>16;
                *andptr++ = v>>24;
            }
        }
        break;

    case Zmov:
        goto domov;
    }
    return;

domov:
    for(t=ymovtab; *t; t+=8)
        if(p->as == t[0])
        if(ycover[ft+t[1]])
        if(ycover[tt+t[2]])
            goto mfound;
bad:
    /*
     * here, the assembly has failed.
     * if its a byte instruction that has
     * unaddressable registers, try to
     * exchange registers and reissue the
     * instruction with the operands renamed.
     */
    pp = *p;
    z = p->from.type;
    if(z >= D_BP && z <= D_DI) {
        if(isax(&p->to)) {
            *andptr++ = 0x87;			/* xchg lhs,bx */
            asmand(&p->from, reg[D_BX]);
            subreg(&pp, z, D_BX);
            doasm(&pp);
            *andptr++ = 0x87;			/* xchg lhs,bx */
            asmand(&p->from, reg[D_BX]);
        } else {
            *andptr++ = 0x90 + reg[z];		/* xchg lsh,ax */
            subreg(&pp, z, D_AX);
            doasm(&pp);
            *andptr++ = 0x90 + reg[z];		/* xchg lsh,ax */
        }
        return;
    }
    z = p->to.type;
    if(z >= D_BP && z <= D_DI) {
        if(isax(&p->from)) {
            *andptr++ = 0x87;			/* xchg rhs,bx */
            asmand(&p->to, reg[D_BX]);
            subreg(&pp, z, D_BX);
            doasm(&pp);
            *andptr++ = 0x87;			/* xchg rhs,bx */
            asmand(&p->to, reg[D_BX]);
        } else {
            *andptr++ = 0x90 + reg[z];		/* xchg rsh,ax */
            subreg(&pp, z, D_AX);
            doasm(&pp);
            *andptr++ = 0x90 + reg[z];		/* xchg rsh,ax */
        }
        return;
    }
    diag("doasm: notfound t2=%ux from=%ux to=%ux %P", t[2], p->from.type, p->to.type, p);
    return;

mfound:
    switch(t[3]) {
    default:
        diag("asmins: unknown mov %d %P", t[3], p);
        break;

    case 0:	/* lit */
        for(z=4; t[z]!=E; z++)
            *andptr++ = t[z];
        break;

    case 1:	/* r,m */
        *andptr++ = t[4];
        asmand(&p->to, t[5]);
        break;

    case 2:	/* m,r */
        *andptr++ = t[4];
        asmand(&p->from, t[5]);
        break;

    case 3:	/* r,m - 2op */
        *andptr++ = t[4];
        *andptr++ = t[5];
        asmand(&p->to, t[6]);
        break;

    case 4:	/* m,r - 2op */
        *andptr++ = t[4];
        *andptr++ = t[5];
        asmand(&p->from, t[6]);
        break;

    case 5:	/* load full pointer, trash heap */
        if(t[4])
            *andptr++ = t[4];
        switch(p->to.index) {
        default:
            goto bad;
        case D_DS:
            *andptr++ = 0xc5;
            break;
        case D_SS:
            *andptr++ = 0x0f;
            *andptr++ = 0xb2;
            break;
        case D_ES:
            *andptr++ = 0xc4;
            break;
        case D_FS:
            *andptr++ = 0x0f;
            *andptr++ = 0xb4;
            break;
        case D_GS:
            *andptr++ = 0x0f;
            *andptr++ = 0xb5;
            break;
        }
        asmand(&p->from, reg[p->to.type]);
        break;

    case 6:	/* double shift */
        z = p->from.type;
        switch(z) {
        default:
            goto bad;
        case D_CONST:
            *andptr++ = 0x0f;
            *andptr++ = t[4];
            asmand(&p->to, reg[p->from.index]);
            *andptr++ = p->from.offset;
            break;
        case D_CL:
        case D_CX:
            *andptr++ = 0x0f;
            *andptr++ = t[5];
            asmand(&p->to, reg[p->from.index]);
            break;
        }
        break;

    case 7: /* imul rm,r */
        *andptr++ = t[4];
        *andptr++ = t[5];
        asmand(&p->from, reg[p->to.type]);
        break;
    }
}
@

<<function prefixof(x86)>>=
int
prefixof(Adr *a)
{
    switch(a->type) {
    case D_INDIR+D_CS:
        return 0x2e;
    case D_INDIR+D_DS:
        return 0x3e;
    case D_INDIR+D_ES:
        return 0x26;
    case D_INDIR+D_FS:
        return 0x64;
    case D_INDIR+D_GS:
        return 0x65;
    }
    return 0;
}
@



<<function asmins(x86)>>=
void
asmins(Prog *p)
{

    andptr = and;
    doasm(p);
}
@

<<enum _anon_ (linkers/8l/span.c)>>=
enum{
    ABSD = 0,
    ABSU = 1,
    RELD = 2,
    RELU = 3,
};
@





%-------------------------------------------------------------

<<linkers/8l/span.c>>=
#include	"l.h"

<<function span(x86)>>

<<function xdefine(x86)>>

<<function putsymb>>

<<function asmsym(x86)>>

<<function asmlc>>

<<function prefixof(x86)>>

<<function oclass(x86)>>

<<function asmidx(x86)>>

<<function put4(x86)>>

<<function vaddr(x86)>>

<<function asmand(x86)>>

<<constant E(x86)>>
<<global ymovtab(x86)>>

<<function isax(x86)>>

<<function subreg(x86)>>

<<function doasm(x86)>>

<<function asmins(x86)>>

<<enum _anon_ (linkers/8l/span.c)>>

<<global modemap>>

typedef struct Reloc Reloc;

<<struct Reloc>>

<<global rels>>

<<function grow>>

<<function dynreloc(x86)>>

<<function sput>>

<<function asmdyn>>
@


\subsection*{[[linkers/8l/elf.c]]}

<<enum _anon_ (linkers/8l/elf.c)>>=
enum {
    /* offsets into string table */
    Stitext		= 1,
    Stidata		= 7,
    Stistrtab	= 13,
};
@

<<function elfident>>=
void
elfident(int bo, int class)
{
    strnput("\177ELF", 4);		/* e_ident */
    cput(class);
    cput(bo);			/* byte order */
    cput(1);			/* version = CURRENT */
    if(debug['k']){			/* boot/embedded/standalone */
        cput(255);
        cput(0);
    }
    else{
        cput(0);		/* osabi = SYSV */
        cput(0);		/* abiversion = 3 */
    }
    strnput("", 7);
}
@

<<function elfstrtab>>=
void
elfstrtab(void)
{
    /* string table */
    cput(0);
    strnput(".text", 5);		/* +1 */
    cput(0);
    strnput(".data", 5);		/* +7 */
    cput(0);
    strnput(".strtab", 7);		/* +13 */
    cput(0);
    cput(0);
}
@

<<function elf32phdr>>=
void
elf32phdr(void (*putl)(long), ulong type, ulong off, ulong vaddr, ulong paddr,
    ulong filesz, ulong memsz, ulong prots, ulong align)
{
    putl(type);
    putl(off);
    putl(vaddr);
    putl(paddr);
    putl(filesz);
    putl(memsz);
    putl(prots);
    putl(align);
}
@

<<function elf32shdr>>=
void
elf32shdr(void (*putl)(long), ulong name, ulong type, ulong flags, ulong vaddr,
    ulong off, ulong sectsz, ulong link, ulong addnl, ulong align,
    ulong entsz)
{
    putl(name);
    putl(type);
    putl(flags);
    putl(vaddr);
    putl(off);
    putl(sectsz);
    putl(link);
    putl(addnl);
    putl(align);
    putl(entsz);
}
@

<<function elf32sectab>>=
static void
elf32sectab(void (*putl)(long))
{
    seek(cout, HEADR+textsize+datsize+symsize, 0);
    elf32shdr(putl, Stitext, Progbits, Salloc|Sexec, INITTEXT,
        HEADR, textsize, 0, 0, 0x10000, 0);
    elf32shdr(putl, Stidata, Progbits, Salloc|SwriteElf, INITDAT,
        HEADR+textsize, datsize, 0, 0, 0x10000, 0);
    elf32shdr(putl, Stistrtab, Strtab, 1 << 5, 0,
        HEADR+textsize+datsize+symsize+3*Shdr32sz, 14, 0, 0, 1, 0);
    elfstrtab();
}
@

<<function elf32>>=
/* if addpsects > 0, putpsects must emit exactly that many psects. */
void
elf32(int mach, int bo, int addpsects, void (*putpsects)(Putl))
{
    ulong phydata;
    void (*putw)(long), (*putl)(long);

    if(bo == ELFDATA2MSB){
        putw = wput;
        putl = lput;
    }else if(bo == ELFDATA2LSB){
        putw = wputl;
        putl = lputl;
    }else{
        print("elf32 byte order is mixed-endian\n");
        errorexit();
        return;
    }

    elfident(bo, ELFCLASS32);
    putw(EXEC);
    putw(mach);
    putl(1L);			/* version = CURRENT */
    putl(entryvalue());		/* entry vaddr */
    putl(Ehdr32sz);			/* offset to first phdr */
    if(debug['S'])
        putl(HEADR+textsize+datsize+symsize); /* offset to first shdr */
    else
        putl(0);
    putl(0L);			/* flags */
    putw(Ehdr32sz);
    putw(Phdr32sz);
    putw(3 + addpsects);		/* # of Phdrs */
    putw(Shdr32sz);
    if(debug['S']){
        putw(3);		/* # of Shdrs */
        putw(2);		/* Shdr table index */
    }else{
        putw(0);
        putw(0);
    }

    /*
     * could include ELF headers in text -- 8l doesn't,
     * but in theory it aids demand loading.
     */
    elf32phdr(putl, PT_LOAD, HEADR, INITTEXT, INITTEXTP,
        textsize, textsize, R|X, INITRND);	/* text */
    /*
     * we need INITDATP, but it has to be computed.
     * assume distance between INITTEXT & INITTEXTP is also
     * correct for INITDAT and INITDATP.
     */
    phydata = INITDAT - (INITTEXT - INITTEXTP);
    elf32phdr(putl, PT_LOAD, HEADR+textsize, INITDAT, phydata,
        datsize, datsize+bsssize, R|W|X, INITRND); /* data */
    elf32phdr(putl, NOPTYPE, HEADR+textsize+datsize, 0, 0,
        symsize, lcsize, R, 4);			/* symbol table */
    if (addpsects > 0)
        putpsects(putl);
    cflush();

    if(debug['S'])
        elf32sectab(putl);
}
@

%<<function elf64phdr>>=
%/*
% * elf64
% */
%void
%elf64phdr(void (*putl)(long), void (*putll)(vlong), ulong type, uvlong off,
%    uvlong vaddr, uvlong paddr, uvlong filesz, uvlong memsz, ulong prots,
%    uvlong align)
%{
%    putl(type);		
%    putl(prots);		
%    putll(off);		
%    putll(vaddr);	
%    putll(paddr);	
%    putll(filesz);	
%    putll(memsz);	
%    putll(align);		
%}
%@
%
%<<function elf64shdr>>=
%void
%elf64shdr(void (*putl)(long), void (*putll)(vlong), ulong name, ulong type,
%    uvlong flags, uvlong vaddr, uvlong off, uvlong sectsz, ulong link,
%    ulong addnl, uvlong align, uvlong entsz)
%{
%    putl(name);
%    putl(type);
%    putll(flags);
%    putll(vaddr);
%    putll(off);
%    putll(sectsz);
%    putl(link);
%    putl(addnl);
%    putll(align);
%    putll(entsz);
%}
%@
%
%<<function elf64sectab>>=
%static void
%elf64sectab(void (*putl)(long), void (*putll)(vlong))
%{
%    seek(cout, HEADR+textsize+datsize+symsize, 0);
%    elf64shdr(putl, putll, Stitext, Progbits, Salloc|Sexec, INITTEXT,
%        HEADR, textsize, 0, 0, 0x10000, 0);
%    elf64shdr(putl, putll, Stidata, Progbits, Salloc|SwriteElf, INITDAT,
%        HEADR+textsize, datsize, 0, 0, 0x10000, 0);
%    elf64shdr(putl, putll, Stistrtab, Strtab, 1 << 5, 0,
%        HEADR+textsize+datsize+symsize+3*Shdr64sz, 14, 0, 0, 1, 0);
%    elfstrtab();
%}
%@
%
%% >>
%
%<<function elf64>>=
%/* if addpsects > 0, putpsects must emit exactly that many psects. */
%//@Scheck: not dead, used by vl/
%void elf64(int mach, int bo, int addpsects, void (*putpsects)(Putl))
%{
%    uvlong phydata;
%    void (*putw)(long), (*putl)(long);
%    void (*putll)(vlong);
%
%    if(bo == ELFDATA2MSB){
%        putw = wput;
%        putl = lput;
%        putll = llput;
%    }else if(bo == ELFDATA2LSB){
%        putw = wputl;
%        putl = lputl;
%        putll = llputl;
%    }else{
%        print("elf64 byte order is mixed-endian\n");
%        errorexit();
%        return;
%    }
%
%    elfident(bo, ELFCLASS64);
%    putw(EXEC);
%    putw(mach);
%    putl(1L);			/* version = CURRENT */
%    putll(entryvalue());		/* entry vaddr */
%    putll(Ehdr64sz);		/* offset to first phdr */
%    if(debug['S'])
%        putll(HEADR+textsize+datsize+symsize); /* offset to 1st shdr */
%    else
%        putll(0);
%    putl(0L);			/* flags */
%    putw(Ehdr64sz);
%    putw(Phdr64sz);
%    putw(3 + addpsects);		/* # of Phdrs */
%    putw(Shdr64sz);
%    if(debug['S']){
%        putw(3);		/* # of Shdrs */
%        putw(2);		/* Shdr table index */
%    }else{
%        putw(0);
%        putw(0);
%    }
%
%    elf64phdr(putl, putll, PT_LOAD, HEADR, INITTEXT, INITTEXTP,
%        textsize, textsize, R|X, INITRND);	/* text */
%    /*
%     * see 32-bit ELF case for physical data address computation.
%     */
%    phydata = INITDAT - (INITTEXT - INITTEXTP);
%    elf64phdr(putl, putll, PT_LOAD, HEADR+textsize, INITDAT, phydata,
%        datsize, datsize+bsssize, R|W, INITRND); /* data */
%    elf64phdr(putl, putll, NOPTYPE, HEADR+textsize+datsize, 0, 0,
%        symsize, lcsize, R, 4);			/* symbol table */
%    if (addpsects > 0)
%        putpsects(putl);
%    cflush();
%
%    if(debug['S'])
%        elf64sectab(putl, putll);
%}
%@


%-------------------------------------------------------------

<<linkers/8l/elf.c>>=
/*
 * emit 32- or 64-bit elf headers for any architecture.
 * this is a component of ?l.
 */
#include "l.h"

long	entryvalue(void);

<<enum _anon_ (linkers/8l/elf.c)>>

<<function elfident>>

<<function elfstrtab>>

<<function elf32phdr>>

<<function elf32shdr>>

<<function elf32sectab>>

<<function elf32>>
@


\subsection*{[[linkers/8l/obj.c]]}




%-------------------------------------------------------------

<<linkers/8l/obj.c>>=
#include	"l.h"
#include	<ar.h>

#ifndef	DEFAULT
<<constant DEFAULT>>
#endif

<<global curauto>>

<<global curhist>>
<<global etextp>>

<<global histfrog>>
<<global histfrogp>>
<<global histgen>>

<<global library>>
<<global libraryobj>>
<<global libraryp>>

<<global xrefresolv>>

<<global version>>
<<global literal(x86)>>
<<global doexp>>

void	addlibpath(char*);
char*	findlib(char*);
void	loadlib(void);
void	objfile(char*);

int	zaddr(uchar*, Adr*, Sym*[]);
long	vaddr(Adr*);

void	addhist(long, int);
void	histtoauto(void);
void	ldobj(int, long, char*);

void	doprof1(void);
void	doprof2(void);
void	nuxiinit(void);

int	find1(long, int);
//int	find2(long, int);

double	ieeedtod(Ieee*);

void	zerosig(char*);
void	readundefs(char*, int);
Prog*	brchain(Prog*);



<<global noname linker>>
<<global symname linker>>
<<global thechar>>
<<global thestring>>

<<global libdir>>
<<global nlibdir>>
<<global maxlibdir>>

<<function usage, linker>>

<<function isobjfile>>

<<function main (linkers/8l/obj.c)>>

<<function addlibpath>>

<<function findlib>>

<<function loadlib>>

<<function objfile>>

<<function zaddr(x86)>>

<<function addlib>>

<<function addhist>>

<<function histtoauto>>

<<function collapsefrog>>

<<function nopout>>

<<function readsome>>

<<function ldobj(x86)>>

<<function appendp(x86)>>

<<function doprof1(x86)>>

<<function doprof2(x86)>>

<<function nuxiinit(x86)>>

<<function find1>>

<<function ieeedtof>>

<<function ieeedtod>>

<<function undefsym>>

<<function zerosig>>

<<function readundefs>>
@


