\section{[[include/]]}

\subsection*{[[include/a.out.h]]}

% used by strip, libmach, but not 8l
<<struct Exec>>=
struct	Exec
{
    long	magic;		/* magic number */

    long	text;	 	/* size of text segment */
    long	data;	 	/* size of initialized data */
    long	bss;	  	/* size of uninitialized data */
    long	syms;	 	/* size of symbol table */

    // virtual address in [UTZERO+sizeof(Exec)..UTZERO+sizeof(Exec)+text]
    long	entry;	 	/* entry point */ 
    long	spsz;		/* size of pc/sp offset table */
    long	pcsz;		/* size of pc/line number table */
};
@

<<constant HDR_MAGIC>>=
#define HDR_MAGIC	0x00008000		/* header expansion */
@

<<function _MAGIC>>=
#define	_MAGIC(f, b)	((f)|((((4*(b))+0)*(b))+7))
@

<<constant A_MAGIC>>=
#define	A_MAGIC		_MAGIC(0, 8)		/* 68020 (retired) */
@

<<constant I_MAGIC>>=
#define	I_MAGIC		_MAGIC(0, 11)		/* intel 386 */
@

<<constant J_MAGIC>>=
#define	J_MAGIC		_MAGIC(0, 12)		/* intel 960 (retired) */
@

<<constant K_MAGIC>>=
#define	K_MAGIC		_MAGIC(0, 13)		/* sparc */
@

<<constant V_MAGIC>>=
#define	V_MAGIC		_MAGIC(0, 16)		/* mips 3000 BE */
@

<<constant X_MAGIC>>=
#define	X_MAGIC		_MAGIC(0, 17)		/* att dsp 3210 (retired) */
@

<<constant M_MAGIC>>=
#define	M_MAGIC		_MAGIC(0, 18)		/* mips 4000 BE */
@

<<constant D_MAGIC>>=
#define	D_MAGIC		_MAGIC(0, 19)		/* amd 29000 (retired) */
@

<<constant E_MAGIC>>=
#define	E_MAGIC		_MAGIC(0, 20)		/* arm */
@

<<constant Q_MAGIC>>=
#define	Q_MAGIC		_MAGIC(0, 21)		/* powerpc */
@

<<constant N_MAGIC>>=
#define	N_MAGIC		_MAGIC(0, 22)		/* mips 4000 LE */
@

<<constant L_MAGIC>>=
#define	L_MAGIC		_MAGIC(0, 23)		/* dec alpha (retired) */
@

<<constant P_MAGIC>>=
#define	P_MAGIC		_MAGIC(0, 24)		/* mips 3000 LE */
@

<<constant U_MAGIC>>=
#define	U_MAGIC		_MAGIC(0, 25)		/* sparc64 (retired) */
@

<<constant S_MAGIC>>=
#define	S_MAGIC		_MAGIC(HDR_MAGIC, 26)	/* amd64 */
@

<<constant T_MAGIC>>=
#define	T_MAGIC		_MAGIC(HDR_MAGIC, 27)	/* powerpc64 */
@

<<constant R_MAGIC>>=
#define	R_MAGIC		_MAGIC(HDR_MAGIC, 28)	/* arm64 */
@

<<constant MIN_MAGIC>>=
#define	MIN_MAGIC	8
@

<<constant MAX_MAGIC>>=
#define	MAX_MAGIC	28			/* <= 90 */
@

<<constant DYN_MAGIC>>=
#define	DYN_MAGIC	0x80000000		/* dlm */
@

<<struct Sym a.out.h>>=
struct	Sym
{
    vlong	value;
    uint	sig;
    char	type;
    char	*name;
};
@


%-------------------------------------------------------------

<<include/a.out.h>>=
<<struct Exec>>
typedef	struct	Exec	Exec;

<<constant HDR_MAGIC>>

<<function _MAGIC>>

<<constant A_MAGIC>>
<<constant I_MAGIC>>
<<constant J_MAGIC>>
<<constant K_MAGIC>>
<<constant V_MAGIC>>
<<constant X_MAGIC>>
<<constant M_MAGIC>>
<<constant D_MAGIC>>
<<constant E_MAGIC>>
<<constant Q_MAGIC>>
<<constant N_MAGIC>>
<<constant L_MAGIC>>
<<constant P_MAGIC>>
<<constant U_MAGIC>>
<<constant S_MAGIC>>
<<constant T_MAGIC>>
<<constant R_MAGIC>>

<<constant MIN_MAGIC>>
<<constant MAX_MAGIC>>

<<constant DYN_MAGIC>>

typedef	struct	Sym	Sym;
<<struct Sym a.out.h>>
@


\subsection*{[[include/ar.h]]}

%-------------------------------------------------------------

<<include/ar.h>>=
<<constant ARMAG>>
<<constant SARMAG>>

<<constant ARFMAG>>
<<constant SARNAME>>

<<struct ar_hdr>>
<<constant SAR_HDR>>
@


\subsection*{[[include/bootexec.h]]}

<<struct coffsect>>=
struct coffsect
{
    char	name[8];
    ulong	phys;
    ulong	virt;
    ulong	size;
    ulong	fptr;
    ulong	fptrreloc;
    ulong	fptrlineno;
    ulong	nrelocnlineno;
    ulong	flags;
};
@

<<struct mipsexec>>=
/*
 * proprietary exec headers, needed to bootstrap various machines
 */
struct mipsexec
{
    short	mmagic;		/* (0x160) mips magic number */
    short	nscns;		/* (unused) number of sections */
    long	timdat;		/* (unused) time & date stamp */
    long	symptr;		/* offset to symbol table */
    long	nsyms;		/* size of symbol table */
    short	opthdr;		/* (0x38) sizeof(optional hdr) */
    short	pcszs;		/* flags */
    short	amagic;		/* see above */
    short	vstamp;		/* version stamp */
    long	tsize;		/* text size in bytes */
    long	dsize;		/* initialized data */
    long	bsize;		/* uninitialized data */
    long	mentry;		/* entry pt.				*/
    long	text_start;	/* base of text used for this file	*/
    long	data_start;	/* base of data used for this file	*/
    long	bss_start;	/* base of bss used for this file	*/
    long	gprmask;	/* general purpose register mask	*/
union{
    long	cprmask[4];	/* co-processor register masks		*/
    long	pcsize;
};
    long	gp_value;	/* the gp value used for this object    */
};
@

<<struct mips4kexec>>=
struct mips4kexec
{
    struct mipsexec	h;
    struct coffsect	itexts;
    struct coffsect idatas;
    struct coffsect ibsss;
};
@

<<struct sparcexec>>=
struct sparcexec
{
    short	sjunk;		/* dynamic bit and version number */
    short	smagic;		/* 0407 */
    ulong	stext;
    ulong	sdata;
    ulong	sbss;
    ulong	ssyms;
    ulong	sentry;
    ulong	strsize;
    ulong	sdrsize;
};
@

<<struct nextexec>>=
struct nextexec
{
    struct	nexthdr{
        ulong	nmagic;
        ulong	ncputype;
        ulong	ncpusubtype;
        ulong	nfiletype;
        ulong	ncmds;
        ulong	nsizeofcmds;
        ulong	nflags;
    };

    struct nextcmd{
        ulong	cmd;
        ulong	cmdsize;
        uchar	segname[16];
        ulong	vmaddr;
        ulong	vmsize;
        ulong	fileoff;
        ulong	filesize;
        ulong	maxprot;
        ulong	initprot;
        ulong	nsects;
        ulong	flags;
    }textc;
    struct nextsect{
        char	sectname[16];
        char	segname[16];
        ulong	addr;
        ulong	size;
        ulong	offset;
        ulong	align;
        ulong	reloff;
        ulong	nreloc;
        ulong	flags;
        ulong	reserved1;
        ulong	reserved2;
    }texts;
    struct nextcmd	datac;
    struct nextsect	datas;
    struct nextsect	bsss;
    struct nextsym{
        ulong	cmd;
        ulong	cmdsize;
        ulong	symoff;
        ulong	nsyms;
        ulong	spoff;
        ulong	pcoff;
    }symc;
};
@

<<struct i386exec>>=
struct i386exec
{
    struct	i386coff{
        ulong	isectmagic;
        ulong	itime;
        ulong	isyms;
        ulong	insyms;
        ulong	iflags;
    };
    struct	i386hdr{
        ulong	imagic;
        ulong	itextsize;
        ulong	idatasize;
        ulong	ibsssize;
        ulong	ientry;
        ulong	itextstart;
        ulong	idatastart;
    };
    struct coffsect	itexts;
    struct coffsect idatas;
    struct coffsect ibsss;
    struct coffsect icomments;
};
@


%-------------------------------------------------------------

<<include/bootexec.h>>=
<<struct coffsect>>

<<struct mipsexec>>

<<struct mips4kexec>>

<<struct sparcexec>>

<<struct nextexec>>

<<struct i386exec>>
@


\subsection*{[[include/elf.h]]}

<<enum _anon_>>=
/* was in /sys/src/libmach/elf.h */
enum {
    /* Ehdr codes */
    MAG0 = 0,		/* ident[] indexes */
    MAG1 = 1,
    MAG2 = 2,
    MAG3 = 3,
    CLASS = 4,
    DATA = 5,
    VERSION = 6,

    ELFCLASSNONE = 0,	/* ident[CLASS] */
    ELFCLASS32 = 1,
    ELFCLASS64 = 2,
    ELFCLASSNUM = 3,

    ELFDATANONE = 0,	/* ident[DATA] */
    ELFDATA2LSB = 1,
    ELFDATA2MSB = 2,
    ELFDATANUM = 3,

    NOETYPE = 0,		/* type */
    REL = 1,
    EXEC = 2,
    DYN = 3,
    CORE = 4,

    NONE = 0,		/* machine */
    M32 = 1,		/* AT&T WE 32100 */
    SPARC = 2,		/* Sun SPARC */
    I386 = 3,		/* Intel 80386 */
    M68K = 4,		/* Motorola 68000 */
    M88K = 5,		/* Motorola 88000 */
    I486 = 6,		/* Intel 80486 */
    I860 = 7,		/* Intel i860 */
    MIPS = 8,		/* Mips R2000 */
    S370 = 9,		/* Amdhal	*/
    MIPSR4K = 10,		/* Mips R4000 */
    SPARC64 = 18,		/* Sun SPARC v9 */
    POWER = 20,		/* PowerPC */
    POWER64 = 21,		/* PowerPC64 */
    ARM = 40,		/* ARM */
    AMD64 = 62,		/* Amd64 */
    ARM64 = 183,		/* ARM64 */

    NO_VERSION = 0,		/* version, ident[VERSION] */
    CURRENT = 1,

    /* Phdr Codes */
    NOPTYPE = 0,		/* type */
    PT_LOAD = 1, /* also LOAD */
    DYNAMIC = 2,
    INTERP = 3,
    NOTE = 4,
    SHLIB = 5,
    PHDR = 6,

    R = 0x4,		/* flags */
    W = 0x2,
    X = 0x1,

    /* Shdr Codes */
    Progbits = 1,	/* section types */
    Strtab = 3,
    Nobits = 8,

    SwriteElf = 1,	/* section attributes (flags) */
    Salloc = 2,
    Sexec = 4,
};
@

<<struct Ehdr>>=
/*
 *	Definitions needed for accessing ELF headers
 */
struct Ehdr {
    uchar	ident[16];	/* ident bytes */
    ushort	type;		/* file type */
    ushort	machine;	/* target machine */
    int	version;	/* file version */
    ulong	elfentry;	/* start address */
    ulong	phoff;		/* phdr file offset */
    ulong	shoff;		/* shdr file offset */
    int	flags;		/* file flags */
    ushort	ehsize;		/* sizeof ehdr */
    ushort	phentsize;	/* sizeof phdr */
    ushort	phnum;		/* number phdrs */
    ushort	shentsize;	/* sizeof shdr */
    ushort	shnum;		/* number shdrs */
    ushort	shstrndx;	/* shdr string index */
};
@

<<struct E64hdr>>=
struct E64hdr {
    u8int	ident[16];	/* ident bytes */
    u16int	type;		/* file type */
    u16int	machine;	/* target machine */
    u32int	version;	/* file version */
    u64int	elfentry;	/* start address */
    u64int	phoff;		/* phdr file offset */
    u64int	shoff;		/* shdr file offset */
    u32int	flags;		/* file flags */
    u16int	ehsize;		/* sizeof ehdr */
    u16int	phentsize;	/* sizeof phdr */
    u16int	phnum;		/* number phdrs */
    u16int	shentsize;	/* sizeof shdr */
    u16int	shnum;		/* number shdrs */
    u16int	shstrndx;	/* shdr string index */
};
@

<<struct Phdr>>=
struct Phdr {
    int	type;		/* entry type */
    ulong	offset;		/* file offset */
    ulong	vaddr;		/* virtual address */
    ulong	paddr;		/* physical address */
    int	filesz;		/* file size */
    ulong	memsz;		/* memory size */
    int	flags;		/* entry flags */
    int	align;		/* memory/file alignment */
};
@

<<struct P64hdr>>=
struct P64hdr {
    u32int	type;		/* entry type */
    u32int	flags;		/* entry flags */
    u64int	offset;		/* file offset */
    u64int	vaddr;		/* virtual address */
    u64int	paddr;		/* physical address */
    u64int	filesz;		/* file size */
    u64int	memsz;		/* memory size */
    u64int	align;		/* memory/file alignment */
}; 
@

<<struct Shdr>>=
struct Shdr {
    ulong	name;		/* section name */
    ulong	type;		/* SHT_... */
    ulong	flags;		/* SHF_... */
    ulong	addr;		/* virtual address */
    ulong	offset;		/* file offset */
    ulong	size;		/* section size */
    ulong	link;		/* misc info */
    ulong	info;		/* misc info */
    ulong	addralign;	/* memory alignment */
    ulong	entsize;	/* entry size if table */
};
@

<<struct S64hdr>>=
struct S64hdr {
    u32int	name;		/* section name */
    u32int	type;		/* SHT_... */
    u64int	flags;		/* SHF_... */
    u64int	addr;		/* virtual address */
    u64int	offset;		/* file offset */
    u64int	size;		/* section size */
    u32int	link;		/* misc info */
    u32int	info;		/* misc info */
    u64int	addralign;	/* memory alignment */
    u64int	entsize;	/* entry size if table */
};
@

<<constant ELF_MAG>>=
#define	ELF_MAG		((0x7f<<24) | ('E'<<16) | ('L'<<8) | 'F')
@


%-------------------------------------------------------------

<<include/elf.h>>=

<<enum _anon_>>


<<struct Ehdr>>
typedef struct Ehdr Ehdr;

<<struct E64hdr>>
typedef struct E64hdr E64hdr;

<<struct Phdr>>
typedef struct Phdr Phdr;

<<struct P64hdr>>
typedef struct P64hdr P64hdr;

<<struct Shdr>>
typedef struct Shdr Shdr;

<<struct S64hdr>>
typedef struct S64hdr S64hdr;

<<constant ELF_MAG>>
@


\subsection*{[[include/mach.h]]}

<<enum _anon_ (include/mach.h)>>=
/*
 *	Supported architectures:
 *		mips,
 *		68020,
 *		i386,
 *		amd64,
 *		sparc,
 *		mips2 (R4000)
 *		arm
 *		powerpc,
 *		powerpc64
 *		arm64
 */
enum
{
    MMIPS,			/* machine types */
    MSPARC,
    M68020,
    MI386,
    MI960,			/* retired */
    M3210,			/* retired */
    MMIPS2,
    NMIPS2,
    M29000,			/* retired */
    MARM,
    MPOWER,
    MALPHA,			/* retired */
    NMIPS,
    MSPARC64,		/* retired */
    MAMD64,
    MPOWER64,
    MARM64,
                /* types of executables */
    FNONE = 0,		/* unidentified */
    FMIPS,			/* v.out */
    FMIPSB,			/* mips bootable */
    FSPARC,			/* k.out */
    FSPARCB,		/* Sparc bootable */
    F68020,			/* 2.out */
    F68020B,		/* 68020 bootable */
    FNEXTB,			/* Next bootable */
    FI386,			/* 8.out */
    FI386B,			/* I386 bootable */
    FI960,			/* retired */
    FI960B,			/* retired */
    F3210,			/* retired */
    FMIPS2BE,		/* 4.out */
    F29000,			/* retired */
    FARM,			/* 5.out */
    FARMB,			/* ARM bootable */
    FPOWER,			/* q.out */
    FPOWERB,		/* power pc bootable */
    FMIPS2LE,		/* 0.out */
    FALPHA,			/* retired */
    FALPHAB,		/* retired DEC Alpha bootable */
    FMIPSLE,		/* 3k little endian */
    FSPARC64,		/* retired */
    FAMD64,			/* 6.out */
    FAMD64B,		/* 6.out bootable */
    FPOWER64,		/* 9.out */
    FPOWER64B,		/* 9.out bootable */
    FARM64,			/* arm64 */
    FARM64B,		/* arm64 bootable */

    ANONE = 0,		/* dissembler types */
    AMIPS,
    AMIPSCO,		/* native mips */
    ASPARC,
    ASUNSPARC,		/* native sun */
    A68020,
    AI386,
    AI8086,			/* oh god */
    AI960,			/* retired */
    A29000,			/* retired */
    AARM,
    APOWER,
    AALPHA,			/* retired */
    ASPARC64,		/* retired */
    AAMD64,
    APOWER64,
    AARM64,
                /* object file types */
    Obj68020 = 0,		/* .2 */
    ObjSparc,		/* .k */
    ObjMips,		/* .v */
    Obj386,			/* .8 */
    Obj960,			/* retired */
    Obj3210,		/* retired */
    ObjMips2,		/* .4 */
    Obj29000,		/* retired */
    ObjArm,			/* .5 */
    ObjPower,		/* .q */
    ObjMips2le,		/* .0 */
    ObjAlpha,		/* retired */
    ObjSparc64,		/* retired */
    ObjAmd64,		/* .6 */
    ObjSpim,		/* .0 */
    ObjPower64,		/* .9 */
    ObjArm64,		/* .4? */
    Maxobjtype,

    CNONE  = 0,		/* symbol table classes */
    CAUTO,
    CPARAM,
    CSTAB,
    CTEXT,
    CDATA,
    CANY,			/* to look for any class */
};
@

<<struct Map>>=
/*
 * 	Structure to map a segment to a position in a file
 */
struct Map {
    int	nsegs;			/* number of segments */
    struct segment {		/* per-segment map */
        char	*name;		/* the segment name */
        int	fd;		/* file descriptor */
        int	inuse;		/* in use - not in use */
        int	cache;		/* should cache reads? */
        uvlong	b;		/* base */
        uvlong	e;		/* end */
        vlong	f;		/* offset within file */
    } seg[1];			/* actually n of these */
};
@

<<struct Symbol>>=
/*
 *	Internal structure describing a symbol table entry
 */
struct Symbol {
    void 	*handle;		/* used internally - owning func */
    struct {
        char	*name;
        vlong	value;		/* address or stack offset */
        char	type;		/* as in a.out.h */
        char	class;		/* as above */
        int	index;		/* in findlocal, globalsym, textsym */
    };
};
@

<<struct Reglist>>=
/*
 *	machine register description
 */
struct Reglist {
    char	*rname;			/* register name */
    short	roffs;			/* offset in u-block */
    char	rflags;			/* INTEGER/FLOAT, WRITABLE */
    char	rformat;		/* print format: 'x', 'X', 'f', '8', '3', 'Y', 'W' */
};
@

<<enum _anon_ (include/mach.h)2>>=
enum {					/* bits in rflags field */
    RINT	= (0<<0),
    RFLT	= (1<<0),
    RRDONLY	= (1<<1),
};
@

<<struct Mach>>=
/*
 *	Machine-dependent data is stored in two structures:
 *		Mach  - miscellaneous general parameters
 *		Machdata - jump vector of service functions used by debuggers
 *
 *	Mach is defined in ?.c and set in executable.c
 *
 *	Machdata is defined in ?db.c
 *		and set in the debugger startup.
 */
struct Mach{
    char	*name;
    int	mtype;			/* machine type code */
    Reglist *reglist;		/* register set */
    long	regsize;		/* sizeof registers in bytes */
    long	fpregsize;		/* sizeof fp registers in bytes */
    char	*pc;			/* pc name */
    char	*sp;			/* sp name */
    char	*link;			/* link register name */
    char	*sbreg;			/* static base register name */
    uvlong	sb;			/* static base register value */
    int	pgsize;			/* page size */
    uvlong	kbase;			/* kernel base address */
    uvlong	ktmask;			/* ktzero = kbase & ~ktmask */
    uvlong	utop;			/* user stack top */
    int	pcquant;		/* quantization of pc */
    int	szaddr;			/* sizeof(void*) */
    int	szreg;			/* sizeof(register) */
    int	szfloat;		/* sizeof(float) */
    int	szdouble;		/* sizeof(double) */
};
@

<<struct Machdata>>=
struct	Machdata {		/* Machine-dependent debugger support */
    uchar	bpinst[4];			/* break point instr. */
    short	bpsize;				/* size of break point instr. */

    ushort	(*swab)(ushort);		/* ushort to local byte order */
    ulong	(*swal)(ulong);			/* ulong to local byte order */
    uvlong	(*swav)(uvlong);		/* uvlong to local byte order */
    int	(*ctrace)(Map*, uvlong, uvlong, uvlong, Tracer); /* C traceback */
    uvlong	(*findframe)(Map*, uvlong, uvlong, uvlong, uvlong);/* frame finder */
    char*	(*excep)(Map*, Rgetter);	/* last exception */
    ulong	(*bpfix)(uvlong);		/* breakpoint fixup */
    int	(*sftos)(char*, int, void*);	/* single precision float */
    int	(*dftos)(char*, int, void*);	/* double precision float */
    int	(*foll)(Map*, uvlong, Rgetter, uvlong*);/* follow set */
    int	(*das)(Map*, uvlong, char, char*, int);	/* symbolic disassembly */
    int	(*hexinst)(Map*, uvlong, char*, int); 	/* hex disassembly */
    int	(*instsize)(Map*, uvlong);	/* instruction size */
};
@

<<struct Fhdr>>=
/*
 *	Common a.out header describing all architectures
 */
typedef struct Fhdr
{
    char	*name;		/* identifier of executable */
    uchar	type;		/* file type - see codes above */
    uchar	hdrsz;		/* header size */
    uchar	_magic;		/* _MAGIC() magic */
    uchar	spare;
    long	magic;		/* magic number */
    uvlong	txtaddr;	/* text address */
    vlong	txtoff;		/* start of text in file */
    uvlong	dataddr;	/* start of data segment */
    vlong	datoff;		/* offset to data seg in file */
    vlong	symoff;		/* offset of symbol table in file */
    uvlong	entry;		/* entry point */
    vlong	sppcoff;	/* offset of sp-pc table in file */
    vlong	lnpcoff;	/* offset of line number-pc table in file */
    long	txtsz;		/* text size */
    long	datsz;		/* size of data seg */
    long	bsssz;		/* size of bss */
    long	symsz;		/* size of symbol table */
    long	sppcsz;		/* size of sp-pc table */
    long	lnpcsz;		/* size of line number-pc table */
} Fhdr;
@


%-------------------------------------------------------------

<<include/mach.h>>=
/*
 *	Architecture-dependent application data
 */
#include "a.out.h"
//TODO: include "elf.h" too?
#pragma	src	"/sys/src/libmach"
#pragma	lib	"libmach.a"

<<enum _anon_ (include/mach.h)>>

typedef	struct	Map	Map;
typedef struct	Symbol	Symbol;
typedef	struct	Reglist	Reglist;
typedef	struct	Mach	Mach;
typedef	struct	Machdata Machdata;

<<struct Map>>

<<struct Symbol>>

<<struct Reglist>>

<<enum _anon_ (include/mach.h)2>>

<<struct Mach>>

extern	Mach	*mach;			/* Current machine */

typedef uvlong	(*Rgetter)(Map*, char*);
typedef	void	(*Tracer)(Map*, uvlong, uvlong, Symbol*);

<<struct Machdata>>

<<struct Fhdr>>

extern	int	asstype;	/* dissembler type - machdata.c */
extern	Machdata *machdata;	/* jump vector - machdata.c */

Map*		attachproc(int, int, int, Fhdr*);
int		beieee80ftos(char*, int, void*);
int		beieeesftos(char*, int, void*);
int		beieeedftos(char*, int, void*);
ushort		beswab(ushort);
ulong		beswal(ulong);
uvlong		beswav(uvlong);
uvlong		ciscframe(Map*, uvlong, uvlong, uvlong, uvlong);
int		cisctrace(Map*, uvlong, uvlong, uvlong, Tracer);
int		crackhdr(int fd, Fhdr*);
uvlong		file2pc(char*, long);
int		fileelem(Sym**, uchar *, char*, int);
long		fileline(char*, int, uvlong);
int		filesym(int, char*, int);
int		findlocal(Symbol*, char*, Symbol*);
int		findseg(Map*, char*);
int		findsym(uvlong, int, Symbol *);
int		fnbound(uvlong, uvlong*);
int		fpformat(Map*, Reglist*, char*, int, int);
int		get1(Map*, uvlong, uchar*, int);
int		get2(Map*, uvlong, ushort*);
int		get4(Map*, uvlong, ulong*);
int		get8(Map*, uvlong, uvlong*);
int		geta(Map*, uvlong, uvlong*);
int		getauto(Symbol*, int, int, Symbol*);
Sym*		getsym(int);
int		globalsym(Symbol *, int);
char*		_hexify(char*, ulong, int);
int		ieeesftos(char*, int, ulong);
int		ieeedftos(char*, int, ulong, ulong);
int		isar(Biobuf*);
int		leieee80ftos(char*, int, void*);
int		leieeesftos(char*, int, void*);
int		leieeedftos(char*, int, void*);
ushort		leswab(ushort);
ulong		leswal(ulong);
uvlong		leswav(uvlong);
uvlong		line2addr(long, uvlong, uvlong);
Map*		loadmap(Map*, int, Fhdr*);
int		localaddr(Map*, char*, char*, uvlong*, Rgetter);
int		localsym(Symbol*, int);
int		lookup(char*, char*, Symbol*);
void		machbytype(int);
int		machbyname(char*);
int		nextar(Biobuf*, int, char*);
Map*		newmap(Map*, int);
void		objtraverse(void(*)(Sym*, void*), void*);
int		objtype(Biobuf*, char**);
uvlong		pc2sp(uvlong);
long		pc2line(uvlong);
int		put1(Map*, uvlong, uchar*, int);
int		put2(Map*, uvlong, ushort);
int		put4(Map*, uvlong, ulong);
int		put8(Map*, uvlong, uvlong);
int		puta(Map*, uvlong, uvlong);
int		readar(Biobuf*, int, vlong, int);
int		readobj(Biobuf*, int);
uvlong		riscframe(Map*, uvlong, uvlong, uvlong, uvlong);
int		risctrace(Map*, uvlong, uvlong, uvlong, Tracer);
int		setmap(Map*, int, uvlong, uvlong, vlong, char*);
Sym*		symbase(long*);
int		syminit(int, Fhdr*);
int		symoff(char*, int, uvlong, int);
void		textseg(uvlong, Fhdr*);
int		textsym(Symbol*, int);
void		unusemap(Map*, int);
@


\section{[[linkers/misc/]]}

\subsection*{[[linkers/misc/ar.c]]}

<<struct Arsymref>>=
/*
 *	The algorithm uses up to 3 temp files.  The "pivot member" is the
 *	archive member specified by and a, b, or i option.  The temp files are
 *	astart - contains existing members up to and including the pivot member.
 *	amiddle - contains new files moved or inserted behind the pivot.
 *	aend - contains the existing members that follow the pivot member.
 *	When all members have been processed, function 'install' streams the
 * 	temp files, in order, back into the archive.
 */

typedef struct	Arsymref
{
    char	*name;
    int	type;
    int	len;
    vlong	offset;
    struct	Arsymref *next;
} Arsymref;
@

<<struct Armember>>=
typedef struct	Armember	/* Temp file entry - one per archive member */
{
    struct Armember	*next;
    struct ar_hdr	hdr;
    long		size;
    long		date;
    void		*member;
} Armember;
@

<<struct Arfile>>=
typedef	struct Arfile		/* Temp file control block - one per tempfile */
{
    int	paged;		/* set when some data paged to disk */
    char	*fname;		/* paging file name */
    int	fd;		/* paging file descriptor */
    vlong	size;
    Armember *head;		/* head of member chain */
    Armember *tail;		/* tail of member chain */
    Arsymref *sym;		/* head of defined symbol chain */
} Arfile;
@

<<struct Hashchain>>=
typedef struct Hashchain
{
    char	*name;
    struct Hashchain *next;
} Hashchain;
@

<<constant NHASH>>=
#define	NHASH	1024
@

<<function HEADER_IO>>=
/*
 *	macro to portably read/write archive header.
 *	'cmd' is read/write/Bread/Bwrite, etc.
 */
#define	HEADER_IO(cmd, f, h)	cmd(f, h.name, sizeof(h.name)) != sizeof(h.name)\
                || cmd(f, h.date, sizeof(h.date)) != sizeof(h.date)\
                || cmd(f, h.uid, sizeof(h.uid)) != sizeof(h.uid)\
                || cmd(f, h.gid, sizeof(h.gid)) != sizeof(h.gid)\
                || cmd(f, h.mode, sizeof(h.mode)) != sizeof(h.mode)\
                || cmd(f, h.size, sizeof(h.size)) != sizeof(h.size)\
                || cmd(f, h.fmag, sizeof(h.fmag)) != sizeof(h.fmag)
@

<<global man>>=
char	*man =		"mrxtdpq";
@

<<global opt>>=
char	*opt =		"uvnbailo";
@

<<global artemp>>=
char	artemp[] =	"/tmp/vXXXXX";
@

<<global movtemp>>=
char	movtemp[] =	"/tmp/v1XXXXX";
@

<<global tailtemp>>=
char	tailtemp[] =	"/tmp/v2XXXXX";
@

<<global symdef>>=
char	symdef[] =	"__.SYMDEF";
@

<<global aflag>>=
int	aflag;				/* command line flags */
@

<<global bflag>>=
static int	bflag;
@

<<global cflag>>=
int	cflag;
@

<<global oflag>>=
int	oflag;
@

<<global uflag>>=
int	uflag;
@

<<global vflag>>=
int	vflag;
@

<<global allobj>>=
int	allobj = 1;			/* set when all members are object files of the same type */
@

<<global symdefsize>>=
int	symdefsize;			/* size of symdef file */
@

<<global dupfound>>=
int	dupfound;			/* flag for duplicate symbol */
@

<<global hash>>=
Hashchain	*hash[NHASH];		/* hash table of text symbols */
@

<<constant ARNAMESIZE>>=
#define	ARNAMESIZE	sizeof(astart->tail->hdr.name)
@

<<global poname>>=
char	poname[ARNAMESIZE+1];		/* name of pivot member */
@

<<global file>>=
char	*file;				/* current file or member being worked on */
@

<<global bout>>=
Biobuf	bout;
@

<<global bar>>=
Biobuf bar;
@

<<global comfun>>=
void	(*comfun)(char*, int, char**);
@

<<function main>>=
void
main(int argc, char *argv[])
{
    char *cp;

    Binit(&bout, 1, OWRITE);
    if(argc < 3)
        usage();
    for (cp = argv[1]; *cp; cp++) {
        switch(*cp) {
        case 'a':	aflag = 1;	break;
        case 'b':	bflag = 1;	break;
        case 'c':	cflag = 1;	break;
        case 'd':	setcom(dcmd);	break;
        case 'i':	bflag = 1;	break;
        case 'l':
                strcpy(artemp, "vXXXXX");
                strcpy(movtemp, "v1XXXXX");
                strcpy(tailtemp, "v2XXXXX");
                break;
        case 'm':	setcom(mcmd);	break;
        case 'o':	oflag = 1;	break;
        case 'p':	setcom(pcmd);	break;
        case 'q':	setcom(qcmd);	break;
        case 'r':	setcom(rcmd);	break;
        case 't':	setcom(tcmd);	break;
        case 'u':	uflag = 1;	break;
        case 'v':	vflag = 1;	break;
        case 'x':	setcom(xcmd);	break;
        default:
            fprint(2, "ar: bad option `%c'\n", *cp);
            exits("error");
        }
    }
    if (aflag && bflag) {
        fprint(2, "ar: only one of 'a' and 'b' can be specified\n");
        usage();
    }
    if(aflag || bflag) {
        trim(argv[2], poname, sizeof(poname));
        argv++;
        argc--;
        if(argc < 3)
            usage();
    }
    if(comfun == 0) {
        if(uflag == 0) {
            fprint(2, "ar: one of [%s] must be specified\n", man);
            usage();
        }
        setcom(rcmd);
    }
    cp = argv[2];
    argc -= 3;
    argv += 3;
    (*comfun)(cp, argc, argv);	/* do the command */
    cp = 0;
    while (argc--) {
        if (*argv) {
            fprint(2, "ar: %s not found\n", *argv);
            cp = "error";
        }
        argv++;
    }
    exits(cp);
}
@

<<function setcom>>=
/*
 *	select a command
 */
void
setcom(void (*fun)(char *, int, char**))
{

    if(comfun != 0) {
        fprint(2, "ar: only one of [%s] allowed\n", man);
        usage();
    }
    comfun = fun;
}
@

<<function rcmd>>=
/*
 *	perform the 'r' and 'u' commands
 */
void
rcmd(char *arname, int count, char **files)
{
    int fd;
    int i;
    Arfile *ap;
    Armember *bp;
    Dir *d;
    Biobuf *bfile;

    fd = openar(arname, ORDWR, 1);
    if (fd >= 0) {
        Binit(&bar, fd, OREAD);
        Bseek(&bar,seek(fd,0,1), 1);
    }
    astart = newtempfile(artemp);
    ap = astart;
    aend = 0;
    for(i = 0; fd >= 0; i++) {
        bp = getdir(&bar);
        if (!bp)
            break;
        if (bamatch(file, poname)) {		/* check for pivot */
            aend = newtempfile(tailtemp);
            ap = aend;
        }
            /* pitch symdef file */
        if (i == 0 && strcmp(file, symdef) == 0) {
            skip(&bar, bp->size);
            continue;
        }
        if (count && !match(count, files)) {
            scanobj(&bar, ap, bp->size);
            arcopy(&bar, ap, bp);
            continue;
        }
        bfile = Bopen(file, OREAD);
        if (!bfile) {
            if (count != 0)
                fprint(2, "ar: cannot open %s\n", file);
            scanobj(&bar, ap, bp->size);
            arcopy(&bar, ap, bp);
            continue;
        }
        d = dirfstat(Bfildes(bfile));
        if(d == nil)
            fprint(2, "ar: cannot stat %s: %r\n", file);
        if (uflag && (d==nil || d->mtime <= bp->date)) {
            scanobj(&bar, ap, bp->size);
            arcopy(&bar, ap, bp);
            Bterm(bfile);
            free(d);
            continue;
        }
        mesg('r', file);
        skip(&bar, bp->size);
        scanobj(bfile, ap, d->length);
        free(d);
        armove(bfile, ap, bp);
        Bterm(bfile);
    }
    if(fd >= 0)
        close(fd);
        /* copy in remaining files named on command line */
    for (i = 0; i < count; i++) {
        file = files[i];
        if(file == 0)
            continue;
        files[i] = 0;
        bfile = Bopen(file, OREAD);
        if (!bfile)
            fprint(2, "ar: %s cannot open\n", file);
        else {
            mesg('a', file);
            d = dirfstat(Bfildes(bfile));
            if (d == nil)
                fprint(2, "can't stat %s\n", file);
            else {
                scanobj(bfile, astart, d->length);
                armove(bfile, astart, newmember());
                free(d);
            }
            Bterm(bfile);
        }
    }
    if(fd < 0 && !cflag)
        install(arname, astart, 0, aend, 1);	/* issue 'creating' msg */
    else
        install(arname, astart, 0, aend, 0);
}
@

<<function dcmd>>=
void
dcmd(char *arname, int count, char **files)
{
    Armember *bp;
    int fd, i;

    if (!count)
        return;
    fd = openar(arname, ORDWR, 0);
    Binit(&bar, fd, OREAD);
    Bseek(&bar,seek(fd,0,1), 1);
    astart = newtempfile(artemp);
    for (i = 0; bp = getdir(&bar); i++) {
        if(match(count, files)) {
            mesg('d', file);
            skip(&bar, bp->size);
            if (strcmp(file, symdef) == 0)
                allobj = 0;
        } else if (i == 0 && strcmp(file, symdef) == 0)
                skip(&bar, bp->size);
        else {
            scanobj(&bar, astart, bp->size);
            arcopy(&bar, astart, bp);
        }
    }
    close(fd);
    install(arname, astart, 0, 0, 0);
}
@

<<function xcmd>>=
void
xcmd(char *arname, int count, char **files)
{
    int fd, f, mode, i;
    Armember *bp;
    Dir dx;

    fd = openar(arname, OREAD, 0);
    Binit(&bar, fd, OREAD);
    Bseek(&bar,seek(fd,0,1), 1);
    i = 0;
    while (bp = getdir(&bar)) {
        if(count == 0 || match(count, files)) {
            mode = strtoul(bp->hdr.mode, 0, 8) & 0777;
            f = create(file, OWRITE, mode);
            if(f < 0) {
                fprint(2, "ar: %s cannot create\n", file);
                skip(&bar, bp->size);
            } else {
                mesg('x', file);
                arcopy(&bar, 0, bp);
                if (write(f, bp->member, bp->size) < 0)
                    wrerr();
                if(oflag) {
                    nulldir(&dx);
                    dx.atime = bp->date;
                    dx.mtime = bp->date;
                    if(dirwstat(file, &dx) < 0)
                        perror(file);
                }
                free(bp->member);
                close(f);
            }
            free(bp);
            if (count && ++i >= count)
                break;
        } else {
            skip(&bar, bp->size);
            free(bp);
        }
    }
    close(fd);
}
@

<<function pcmd>>=
void
pcmd(char *arname, int count, char **files)
{
    int fd;
    Armember *bp;

    fd = openar(arname, OREAD, 0);
    Binit(&bar, fd, OREAD);
    Bseek(&bar,seek(fd,0,1), 1);
    while(bp = getdir(&bar)) {
        if(count == 0 || match(count, files)) {
            if(vflag)
                print("\n<%s>\n\n", file);
            arcopy(&bar, 0, bp);
            if (write(1, bp->member, bp->size) < 0)
                wrerr();
        } else
            skip(&bar, bp->size);
        free(bp);
    }
    close(fd);
}
@

<<function mcmd>>=
void
mcmd(char *arname, int count, char **files)
{
    int fd, i;
    Arfile *ap;
    Armember *bp;

    if (count == 0)
        return;
    fd = openar(arname, ORDWR, 0);
    Binit(&bar, fd, OREAD);
    Bseek(&bar,seek(fd,0,1), 1);
    astart = newtempfile(artemp);
    amiddle = newtempfile(movtemp);
    aend = 0;
    ap = astart;
    for (i = 0; bp = getdir(&bar); i++) {
        if (bamatch(file, poname)) {
            aend = newtempfile(tailtemp);
            ap = aend;
        }
        if(match(count, files)) {
            mesg('m', file);
            scanobj(&bar, amiddle, bp->size);
            arcopy(&bar, amiddle, bp);
        } else
            /*
             * pitch the symdef file if it is at the beginning
             * of the archive and we aren't inserting in front
             * of it (ap == astart).
             */
        if (ap == astart && i == 0 && strcmp(file, symdef) == 0)
            skip(&bar, bp->size);
        else {
            scanobj(&bar, ap, bp->size);
            arcopy(&bar, ap, bp);
        }
    }
    close(fd);
    if (poname[0] && aend == 0)
        fprint(2, "ar: %s not found - files moved to end.\n", poname);
    install(arname, astart, amiddle, aend, 0);
}
@

<<function tcmd>>=
void
tcmd(char *arname, int count, char **files)
{
    int fd;
    Armember *bp;
    char name[ARNAMESIZE+1];

    fd = openar(arname, OREAD, 0);
    Binit(&bar, fd, OREAD);
    Bseek(&bar,seek(fd,0,1), 1);
    while(bp = getdir(&bar)) {
        if(count == 0 || match(count, files)) {
            if(vflag)
                longt(bp);
            trim(file, name, ARNAMESIZE);
            Bprint(&bout, "%s\n", name);
        }
        skip(&bar, bp->size);
        free(bp);
    }
    close(fd);
}
@

<<function qcmd>>=
void
qcmd(char *arname, int count, char **files)
{
    int fd, i;
    Armember *bp;
    Biobuf *bfile;

    if(aflag || bflag) {
        fprint(2, "ar: abi not allowed with q\n");
        exits("error");
    }
    fd = openar(arname, ORDWR, 1);
    if (fd < 0) {
        if(!cflag)
            fprint(2, "ar: creating %s\n", arname);
        fd = arcreate(arname);
    }
    Binit(&bar, fd, OREAD);
    Bseek(&bar,seek(fd,0,1), 1);
    /* leave note group behind when writing archive; i.e. sidestep interrupts */
    rfork(RFNOTEG);
    Bseek(&bar, 0, 2);
    bp = newmember();
    for(i=0; i<count && files[i]; i++) {
        file = files[i];
        files[i] = 0;
        bfile = Bopen(file, OREAD);
        if(!bfile)
            fprint(2, "ar: %s cannot open\n", file);
        else {
            mesg('q', file);
            armove(bfile, 0, bp);
            if (!arwrite(fd, bp))
                wrerr();
            free(bp->member);
            bp->member = 0;
            Bterm(bfile);
        }
    }
    free(bp);
    close(fd);
}
@

<<function scanobj>>=
/*
 *	extract the symbol references from an object file
 */
void
scanobj(Biobuf *b, Arfile *ap, long size)
{
    int obj;
    vlong offset;
    Dir *d;
    static int lastobj = -1;

    if (!allobj)			/* non-object file encountered */
        return;
    offset = Boffset(b);
    obj = objtype(b, 0);
    if (obj < 0) {			/* not an object file */
        allobj = 0;
        d = dirfstat(Bfildes(b));
        if (d != nil && d->length == 0)
            fprint(2, "ar: zero length file %s\n", file);
        free(d);
        Bseek(b, offset, 0);
        return;
    }
    if (lastobj >= 0 && obj != lastobj) {
        fprint(2, "ar: inconsistent object file %s\n", file);
        allobj = 0;
        Bseek(b, offset, 0);
        return;
    }
    lastobj = obj;
    if (!readar(b, obj, offset+size, 0)) {
        fprint(2, "ar: invalid symbol reference in file %s\n", file);
        allobj = 0;
        Bseek(b, offset, 0);
        return;
    }
    Bseek(b, offset, 0);
    objtraverse(objsym, ap);
}
@

<<function objsym>>=
/*
 *	add text and data symbols to the symbol list
 */
void
objsym(Sym *s, void *p)
{
    int n;
    Arsymref *as;
    Arfile *ap;

    if (s->type != 'T' &&  s->type != 'D')
        return;
    ap = (Arfile*)p;
    as = (Arsymref*)armalloc(sizeof(Arsymref));
    as->offset = ap->size;
    n = strlen(s->name);
    as->name = armalloc(n+1);
    strcpy(as->name, s->name);
    if(s->type == 'T' && duplicate(as->name)) {
        dupfound = 1;
        fprint(2, "duplicate text symbol: %s\n", as->name);
        free(as->name);
        free(as);
        return;
    }
    as->type = s->type;
    symdefsize += 4+(n+1)+1;
    as->len = n;
    as->next = ap->sym;
    ap->sym = as;
}
@

<<function duplicate>>=
/*
 *	Check the symbol table for duplicate text symbols
 */
int
duplicate(char *name)
{
    Hashchain *p;
    char *cp;
    int h;

    h = 0;
    for(cp = name; *cp; h += *cp++)
        h *= 1119;
    if(h < 0)
        h = ~h;
    h %= NHASH;

    for(p = hash[h]; p; p = p->next)
        if(strcmp(p->name, name) == 0)
            return 1;
    p = (Hashchain*) armalloc(sizeof(Hashchain));
    p->next = hash[h];
    p->name = name;
    hash[h] = p;
    return 0;
}
@

<<function openar>>=
/*
 *	open an archive and validate its header
 */
int
openar(char *arname, int mode, int errok)
{
    int fd;
    char mbuf[SARMAG];

    fd = open(arname, mode);
    if(fd >= 0){
        if(read(fd, mbuf, SARMAG) != SARMAG || strncmp(mbuf, ARMAG, SARMAG)) {
            fprint(2, "ar: %s not in archive format\n", arname);
            exits("error");
        }
    }else if(!errok){
        fprint(2, "ar: cannot open %s: %r\n", arname);
        exits("error");
    }
    return fd;
}
@

<<function arcreate>>=
/*
 *	create an archive and set its header
 */
int
arcreate(char *arname)
{
    int fd;

    fd = create(arname, OWRITE, 0664);
    if(fd < 0){
        fprint(2, "ar: cannot create %s: %r\n", arname);
        exits("error");
    }
    if(write(fd, ARMAG, SARMAG) != SARMAG)
        wrerr();
    return fd;
}
@

<<function wrerr>>=
/*
 *		error handling
 */
void
wrerr(void)
{
    perror("ar: write error");
    exits("error");
}
@

<<function rderr>>=
void
rderr(void)
{
    perror("ar: read error");
    exits("error");
}
@

<<function phaseerr>>=
void
phaseerr(int offset)
{
    fprint(2, "ar: phase error at offset %d\n", offset);
    exits("error");
}
@

<<function usage>>=
static void
usage(void)
{
    fprint(2, "usage: ar [%s][%s] archive files ...\n", opt, man);
    exits("error");
}
@

<<function getdir>>=
/*
 *	read the header for the next archive member
 */
Armember *
getdir(Biobuf *b)
{
    Armember *bp;
    char *cp;
    static char name[ARNAMESIZE+1];

    bp = newmember();
    if(HEADER_IO(Bread, b, bp->hdr)) {
        free(bp);
        return 0;
    }
    if(strncmp(bp->hdr.fmag, ARFMAG, sizeof(bp->hdr.fmag)) != 0)
        phaseerr(Boffset(b));
    strncpy(name, bp->hdr.name, sizeof(bp->hdr.name));
    cp = name+sizeof(name)-1;
    *cp = '\0';
    /* skip trailing spaces and (gnu-produced) slashes */
    while(*--cp == ' ' || *cp == '/')
        ;
    cp[1] = '\0';
    file = name;
    bp->date = strtol(bp->hdr.date, 0, 0);
    bp->size = strtol(bp->hdr.size, 0, 0);
    return bp;
}
@

<<function armove>>=
/*
 *	Copy the file referenced by fd to the temp file
 */
void
armove(Biobuf *b, Arfile *ap, Armember *bp)
{
    char *cp;
    Dir *d;

    d = dirfstat(Bfildes(b));
    if (d == nil) {
        fprint(2, "ar: cannot stat %s\n", file);
        return;
    }
    trim(file, bp->hdr.name, sizeof(bp->hdr.name));
    for (cp = strchr(bp->hdr.name, 0);		/* blank pad on right */
        cp < bp->hdr.name+sizeof(bp->hdr.name); cp++)
            *cp = ' ';
    sprint(bp->hdr.date, "%-12ld", d->mtime);
    sprint(bp->hdr.uid, "%-6d", 0);
    sprint(bp->hdr.gid, "%-6d", 0);
    sprint(bp->hdr.mode, "%-8lo", d->mode);
    sprint(bp->hdr.size, "%-10lld", d->length);
    strncpy(bp->hdr.fmag, ARFMAG, 2);
    bp->size = d->length;
    arread(b, bp, bp->size);
    if (d->length&0x01)
        d->length++;
    if (ap) {
        arinsert(ap, bp);
        ap->size += d->length+SAR_HDR;
    }
    free(d);
}
@

<<function arcopy>>=
/*
 *	Copy the archive member at the current offset into the temp file.
 */
void
arcopy(Biobuf *b, Arfile *ap, Armember *bp)
{
    long n;

    n = bp->size;
    if (n & 01)
        n++;
    arread(b, bp, n);
    if (ap) {
        arinsert(ap, bp);
        ap->size += n+SAR_HDR;
    }
}
@

<<function skip>>=
/*
 *	Skip an archive member
 */
void
skip(Biobuf *bp, vlong len)
{
    if (len & 01)
        len++;
    Bseek(bp, len, 1);
}
@

<<function install>>=
/*
 *	Stream the three temp files to an archive
 */
void
install(char *arname, Arfile *astart, Arfile *amiddle, Arfile *aend, int createflag)
{
    int fd;

    if(allobj && dupfound) {
        fprint(2, "%s not changed\n", arname);
        return;
    }
    /* leave note group behind when copying back; i.e. sidestep interrupts */
    rfork(RFNOTEG);

    if(createflag)
        fprint(2, "ar: creating %s\n", arname);
    fd = arcreate(arname);

    if(allobj)
        rl(fd);

    if (astart) {
        arstream(fd, astart);
        arfree(astart);
    }
    if (amiddle) {
        arstream(fd, amiddle);
        arfree(amiddle);
    }
    if (aend) {
        arstream(fd, aend);
        arfree(aend);
    }
    close(fd);
}
@

<<function rl>>=
void
rl(int fd)
{

    Biobuf b;
    char *cp;
    struct ar_hdr a;
    long len;

    Binit(&b, fd, OWRITE);
    Bseek(&b,seek(fd,0,1), 0);

    len = symdefsize;
    if(len&01)
        len++;
    sprint(a.date, "%-12ld", time(0));
    sprint(a.uid, "%-6d", 0);
    sprint(a.gid, "%-6d", 0);
    sprint(a.mode, "%-8lo", 0644L);
    sprint(a.size, "%-10ld", len);
    strncpy(a.fmag, ARFMAG, 2);
    strcpy(a.name, symdef);
    for (cp = strchr(a.name, 0);		/* blank pad on right */
        cp < a.name+sizeof(a.name); cp++)
            *cp = ' ';
    if(HEADER_IO(Bwrite, &b, a))
            wrerr();

    len += Boffset(&b);
    if (astart) {
        wrsym(&b, len, astart->sym);
        len += astart->size;
    }
    if(amiddle) {
        wrsym(&b, len, amiddle->sym);
        len += amiddle->size;
    }
    if(aend)
        wrsym(&b, len, aend->sym);

    if(symdefsize&0x01)
        Bputc(&b, 0);
    Bterm(&b);
}
@

<<function wrsym>>=
/*
 *	Write the defined symbols to the symdef file
 */
void
wrsym(Biobuf *bp, long offset, Arsymref *as)
{
    int off;

    while(as) {
        Bputc(bp, as->type);
        off = as->offset+offset;
        Bputc(bp, off);
        Bputc(bp, off>>8);
        Bputc(bp, off>>16);
        Bputc(bp, off>>24);
        if (Bwrite(bp, as->name, as->len+1) != as->len+1)
            wrerr();
        as = as->next;
    }
}
@

<<function match>>=
/*
 *	Check if the archive member matches an entry on the command line.
 */
int
match(int count, char **files)
{
    int i;
    char name[ARNAMESIZE+1];

    for(i=0; i<count; i++) {
        if(files[i] == 0)
            continue;
        trim(files[i], name, ARNAMESIZE);
        if(strncmp(name, file, ARNAMESIZE) == 0) {
            file = files[i];
            files[i] = 0;
            return 1;
        }
    }
    return 0;
}
@

<<function bamatch>>=
/*
 *	compare the current member to the name of the pivot member
 */
int
bamatch(char *file, char *pivot)
{
    static int state = 0;

    switch(state)
    {
    case 0:			/* looking for position file */
        if (aflag) {
            if (strncmp(file, pivot, ARNAMESIZE) == 0)
                state = 1;
        } else if (bflag) {
            if (strncmp(file, pivot, ARNAMESIZE) == 0) {
                state = 2;	/* found */
                return 1;
            }
        }
        break;
    case 1:			/* found - after previous file */
        state = 2;
        return 1;
    case 2:			/* already found position file */
        break;
    }
    return 0;
}
@

<<function mesg>>=
/*
 *	output a message, if 'v' option was specified
 */
void
mesg(int c, char *file)
{

    if(vflag)
        Bprint(&bout, "%c - %s\n", c, file);
}
@

<<function trim>>=
/*
 *	isolate file name by stripping leading directories and trailing slashes
 */
void
trim(char *s, char *buf, int n)
{
    char *p;

    for(;;) {
        p = strrchr(s, '/');
        if (!p) {		/* no slash in name */
            strncpy(buf, s, n);
            return;
        }
        if (p[1] != 0) {	/* p+1 is first char of file name */
            strncpy(buf, p+1, n);
            return;
        }
        *p = 0;			/* strip trailing slash */
    }
}
@

<<constant SUID>>=
/*
 *	utilities for printing long form of 't' command
 */
#define	SUID	04000
@

<<constant SGID>>=
#define	SGID	02000
@

<<constant ROWN>>=
#define	ROWN	0400
@

<<constant WOWN>>=
#define	WOWN	0200
@

<<constant XOWN>>=
#define	XOWN	0100
@

<<constant RGRP>>=
#define	RGRP	040
@

<<constant WGRP>>=
#define	WGRP	020
@

<<constant XGRP>>=
#define	XGRP	010
@

<<constant ROTH>>=
#define	ROTH	04
@

<<constant WOTH>>=
#define	WOTH	02
@

<<constant XOTH>>=
#define	XOTH	01
@

<<constant STXT>>=
#define	STXT	01000
@

<<function longt>>=
void
longt(Armember *bp)
{
    char *cp;

    pmode(strtoul(bp->hdr.mode, 0, 8));
    Bprint(&bout, "%3ld/%1ld", strtol(bp->hdr.uid, 0, 0), strtol(bp->hdr.gid, 0, 0));
    Bprint(&bout, "%7ld", bp->size);
    cp = ctime(bp->date);
    Bprint(&bout, " %-12.12s %-4.4s ", cp+4, cp+24);
}
@

<<global m1>>=
int	m1[] = { 1, ROWN, 'r', '-' };
@

<<global m2>>=
int	m2[] = { 1, WOWN, 'w', '-' };
@

<<global m3>>=
int	m3[] = { 2, SUID, 's', XOWN, 'x', '-' };
@

<<global m4>>=
int	m4[] = { 1, RGRP, 'r', '-' };
@

<<global m5>>=
int	m5[] = { 1, WGRP, 'w', '-' };
@

<<global m6>>=
int	m6[] = { 2, SGID, 's', XGRP, 'x', '-' };
@

<<global m7>>=
int	m7[] = { 1, ROTH, 'r', '-' };
@

<<global m8>>=
int	m8[] = { 1, WOTH, 'w', '-' };
@

<<global m9>>=
int	m9[] = { 2, STXT, 't', XOTH, 'x', '-' };
@

<<global m>>=
int	*m[] = { m1, m2, m3, m4, m5, m6, m7, m8, m9};
@

<<function pmode>>=
void
pmode(long mode)
{
    int **mp;

    for(mp = &m[0]; mp < &m[9];)
        select(*mp++, mode);
}
@

<<function select>>=
void
select(int *ap, long mode)
{
    int n;

    n = *ap++;
    while(--n>=0 && (mode & (*ap++))==0)
        ap++;
    Bputc(&bout, *ap);
}
@

<<function newtempfile>>=
/*
 *	Temp file I/O subsystem.  We attempt to cache all three temp files in
 *	core.  When we run out of memory we spill to disk.
 *	The I/O model assumes that temp files:
 *		1) are only written on the end
 *		2) are only read from the beginning
 *		3) are only read after all writing is complete.
 *	The architecture uses one control block per temp file.  Each control
 *	block anchors a chain of buffers, each containing an archive member.
 */
Arfile *
newtempfile(char *name)		/* allocate a file control block */
{
    Arfile *ap;

    ap = (Arfile *) armalloc(sizeof(Arfile));
    ap->fname = name;
    return ap;
}
@

<<function newmember>>=
Armember *
newmember(void)			/* allocate a member buffer */
{
    return (Armember *)armalloc(sizeof(Armember));
}
@

<<function arread>>=
void
arread(Biobuf *b, Armember *bp, int n)	/* read an image into a member buffer */
{
    int i;

    bp->member = armalloc(n);
    i = Bread(b, bp->member, n);
    if (i < 0) {
        free(bp->member);
        bp->member = 0;
        rderr();
    }
}
@

<<function arinsert>>=
/*
 * insert a member buffer into the member chain
 */
void
arinsert(Arfile *ap, Armember *bp)
{
    bp->next = 0;
    if (!ap->tail)
        ap->head = bp;
    else
        ap->tail->next = bp;
    ap->tail = bp;
}
@

<<function arstream>>=
/*
 *	stream the members in a temp file to the file referenced by 'fd'.
 */
void
arstream(int fd, Arfile *ap)
{
    Armember *bp;
    int i;
    char buf[8192];

    if (ap->paged) {		/* copy from disk */
        seek(ap->fd, 0, 0);
        for (;;) {
            i = read(ap->fd, buf, sizeof(buf));
            if (i < 0)
                rderr();
            if (i == 0)
                break;
            if (write(fd, buf, i) != i)
                wrerr();
        }
        close(ap->fd);
        ap->paged = 0;
    }
        /* dump the in-core buffers */
    for (bp = ap->head; bp; bp = bp->next) {
        if (!arwrite(fd, bp))
            wrerr();
    }
}
@

<<function arwrite>>=
/*
 *	write a member to 'fd'.
 */
int
arwrite(int fd, Armember *bp)
{
    int len;

    if(HEADER_IO(write, fd, bp->hdr))
        return 0;
    len = bp->size;
    if (len & 01)
        len++;
    if (write(fd, bp->member, len) != len)
        return 0;
    return 1;
}
@

<<function page>>=
/*
 *	Spill a member to a disk copy of a temp file
 */
int
page(Arfile *ap)
{
    Armember *bp;

    bp = ap->head;
    if (!ap->paged) {		/* not yet paged - create file */
        ap->fname = mktemp(ap->fname);
        ap->fd = create(ap->fname, ORDWR|ORCLOSE, 0600);
        if (ap->fd < 0) {
            fprint(2,"ar: can't create temp file\n");
            return 0;
        }
        ap->paged = 1;
    }
    if (!arwrite(ap->fd, bp))	/* write member and free buffer block */
        return 0;
    ap->head = bp->next;
    if (ap->tail == bp)
        ap->tail = bp->next;
    free(bp->member);
    free(bp);
    return 1;
}
@

<<function getspace>>=
/*
 *	try to reclaim space by paging.  we try to spill the start, middle,
 *	and end files, in that order.  there is no particular reason for the
 *	ordering.
 */
int
getspace(void)
{
    if (astart && astart->head && page(astart))
            return 1;
    if (amiddle && amiddle->head && page(amiddle))
            return 1;
    if (aend && aend->head && page(aend))
            return 1;
    return 0;
}
@

<<function arfree>>=
void
arfree(Arfile *ap)		/* free a member buffer */
{
    Armember *bp, *next;

    for (bp = ap->head; bp; bp = next) {
        next = bp->next;
        if (bp->member)
            free(bp->member);
        free(bp);
    }
    free(ap);
}
@

<<function armalloc>>=
/*
 *	allocate space for a control block or member buffer.  if the malloc
 *	fails we try to reclaim space by spilling previously allocated
 *	member buffers.
 */
char *
armalloc(int n)
{
    char *cp;

    do {
        cp = malloc(n);
        if (cp) {
            memset(cp, 0, n);
            return cp;
        }
    } while (getspace());
    fprint(2, "ar: out of memory\n");
    exits("malloc");
    return 0;
}
@


%-------------------------------------------------------------

<<linkers/misc/ar.c>>=
/*
 * ar - portable (ascii) format version
 */
#include <u.h>
#include <libc.h>
#include <bio.h>
#include <mach.h>
#include <ar.h>

<<struct Arsymref>>

<<struct Armember>>

<<struct Arfile>>

<<struct Hashchain>>

<<constant NHASH>>

<<function HEADER_IO>>

        /* constants and flags */
<<global man>>
<<global opt>>
<<global artemp>>
<<global movtemp>>
<<global tailtemp>>
<<global symdef>>

<<global aflag>>
<<global bflag>>
<<global cflag>>
<<global oflag>>
<<global uflag>>
<<global vflag>>

Arfile *astart, *amiddle, *aend;	/* Temp file control block pointers */
<<global allobj>>
<<global symdefsize>>
<<global dupfound>>
<<global hash>>
    
<<constant ARNAMESIZE>>

<<global poname>>
<<global file>>
<<global bout>>
<<global bar>>

void	arcopy(Biobuf*, Arfile*, Armember*);
int	arcreate(char*);
void	arfree(Arfile*);
void	arinsert(Arfile*, Armember*);
char	*armalloc(int);
void	armove(Biobuf*, Arfile*, Armember*);
void	arread(Biobuf*, Armember*, int);
void	arstream(int, Arfile*);
int	arwrite(int, Armember*);
int	bamatch(char*, char*);
int	duplicate(char*);
Armember *getdir(Biobuf*);
int	getspace(void);
void	install(char*, Arfile*, Arfile*, Arfile*, int);
void	longt(Armember*);
int	match(int, char**);
void	mesg(int, char*);
Arfile	*newtempfile(char*);
Armember *newmember(void);
void	objsym(Sym*, void*);
int	openar(char*, int, int);
int	page(Arfile*);
void	pmode(long);
void	rl(int);
void	scanobj(Biobuf*, Arfile*, long);
void	select(int*, long);
void	setcom(void(*)(char*, int, char**));
void	skip(Biobuf*, vlong);
int	symcomp(void*, void*);
void	trim(char*, char*, int);
static void	usage(void);
void	wrerr(void);
void	wrsym(Biobuf*, long, Arsymref*);

void	rcmd(char*, int, char**);		/* command processing */
void	dcmd(char*, int, char**);
void	xcmd(char*, int, char**);
void	tcmd(char*, int, char**);
void	pcmd(char*, int, char**);
void	mcmd(char*, int, char**);
void	qcmd(char*, int, char**);
<<global comfun>>

<<function main>>
<<function setcom>>
<<function rcmd>>

<<function dcmd>>

<<function xcmd>>
<<function pcmd>>
<<function mcmd>>
<<function tcmd>>
<<function qcmd>>

<<function scanobj>>

<<function objsym>>

<<function duplicate>>

<<function openar>>

<<function arcreate>>

<<function wrerr>>

<<function rderr>>

<<function phaseerr>>

<<function usage>>

<<function getdir>>

<<function armove>>

<<function arcopy>>

<<function skip>>

<<function install>>

<<function rl>>

<<function wrsym>>

<<function match>>

<<function bamatch>>

<<function mesg>>

<<function trim>>

<<constant SUID>>
<<constant SGID>>
<<constant ROWN>>
<<constant WOWN>>
<<constant XOWN>>
<<constant RGRP>>
<<constant WGRP>>
<<constant XGRP>>
<<constant ROTH>>
<<constant WOTH>>
<<constant XOTH>>
<<constant STXT>>

<<function longt>>

<<global m1>>
<<global m2>>
<<global m3>>
<<global m4>>
<<global m5>>
<<global m6>>
<<global m7>>
<<global m8>>
<<global m9>>

<<global m>>

<<function pmode>>

<<function select>>

<<function newtempfile>>

<<function newmember>>

<<function arread>>

<<function arinsert>>

<<function arstream>>

<<function arwrite>>

<<function page>>

<<function getspace>>

<<function arfree>>

<<function armalloc>>
@


\subsection*{[[linkers/misc/nm.c]]}

<<enum _anon_ (linkers/misc/nm.c)>>=
enum{
    CHUNK	=	256	/* must be power of 2 */
};
@

<<global errs>>=
static char	*errs;			/* exit status */
@

<<global filename>>=
static char	*filename;		/* current file */
@

<<global symname>>=
static char	symname[]="__.SYMDEF";	/* table of contents file name */
@

<<global multifile>>=
static int	multifile;		/* processing multiple files */
@

<<global aflag (linkers/misc/nm.c)>>=
static int	aflag;
@

<<global gflag>>=
static int	gflag;
@

<<global hflag>>=
static int	hflag;
@

<<global nflag>>=
static int	nflag;
@

<<global sflag>>=
static int	sflag;
@

<<global uflag (linkers/misc/nm.c)>>=
static int	uflag;
@

<<global Tflag>>=
static int	Tflag;
@

<<global fnames>>=
static Sym	**fnames;		/* file path translation table */
@

<<global symptr>>=
static Sym	**symptr;
@

<<global nsym>>=
static int	nsym;
@

<<global bout (linkers/misc/nm.c)>>=
static Biobuf	bout;
@

<<function usage (linkers/misc/nm.c)>>=
static void
usage(void)
{
    fprint(2, "usage: nm [-aghnsTu] file ...\n");
    exits("usage");
}
@

<<function main (linkers/misc/nm.c)>>=
void
main(int argc, char *argv[])
{
    int i;
    Biobuf	*bin;

    Binit(&bout, 1, OWRITE);
    argv0 = argv[0];
    ARGBEGIN {
    default:	usage();
    case 'a':	aflag = 1; break;
    case 'g':	gflag = 1; break;
    case 'h':	hflag = 1; break;
    case 'n':	nflag = 1; break;
    case 's':	sflag = 1; break;
    case 'u':	uflag = 1; break;
    case 'T':	Tflag = 1; break;
    } ARGEND
    if (argc == 0)
        usage();
    if (argc > 1)
        multifile++;
    for(i=0; i<argc; i++){
        filename = argv[i];
        bin = Bopen(filename, OREAD);
        if(bin == 0){
            error("cannot open %s", filename);
            continue;
        }
        if (isar(bin))
            doar(bin);
        else{
            Bseek(bin, 0, 0);
            dofile(bin);
        }
        Bterm(bin);
    }
    exits(errs);
}
@

<<function doar>>=
/*
 * read an archive file,
 * processing the symbols for each intermediate file in it.
 */
void
doar(Biobuf *bp)
{
    int offset, size, obj;
    char membername[SARNAME];

    multifile = 1;
    for (offset = Boffset(bp);;offset += size) {
        size = nextar(bp, offset, membername);
        if (size < 0) {
            error("phase error on ar header %ld", offset);
            return;
        }
        if (size == 0)
            return;
        if (strcmp(membername, symname) == 0)
            continue;
        obj = objtype(bp, 0);
        if (obj < 0) {
            error("inconsistent file %s in %s",
                    membername, filename);
            return;
        }
        if (!readar(bp, obj, offset+size, 1)) {
            error("invalid symbol reference in file %s",
                    membername);
            return;
        }
        filename = membername;
        nsym=0;
        objtraverse(psym, 0);
        printsyms(symptr, nsym);
    }
}
@

<<function dofile>>=
/*
 * process symbols in a file
 */
void
dofile(Biobuf *bp)
{
    int obj;

    obj = objtype(bp, 0);
    if (obj < 0)
        execsyms(Bfildes(bp));
    else
    if (readobj(bp, obj)) {
        nsym = 0;
        objtraverse(psym, 0);
        printsyms(symptr, nsym);
    }
}
@

<<function cmp>>=
/*
 * comparison routine for sorting the symbol table
 *	this screws up on 'z' records when aflag == 1
 */
int
cmp(void *vs, void *vt)
{
    Sym **s, **t;

    s = vs;
    t = vt;
    if(nflag)
        if((*s)->value < (*t)->value)
            return -1;
        else
            return (*s)->value > (*t)->value;
    return strcmp((*s)->name, (*t)->name);
}
@

<<function zenter>>=
/*
 * enter a symbol in the table of filename elements
 */
void
zenter(Sym *s)
{
    static int maxf = 0;

    if (s->value > maxf) {
        maxf = (s->value+CHUNK-1) &~ (CHUNK-1);
        fnames = realloc(fnames, (maxf+1)*sizeof(*fnames));
        if(fnames == 0) {
            error("out of memory", argv0);
            exits("memory");
        }
    }
    fnames[s->value] = s;
}
@

<<function execsyms>>=
/*
 * get the symbol table from an executable file, if it has one
 */
void
execsyms(int fd)
{
    Fhdr f;
    Sym *s;
    long n;

    seek(fd, 0, 0);
    if (crackhdr(fd, &f) == 0) {
        error("Can't read header for %s", filename);
        return;
    }
    if (syminit(fd, &f) < 0)
        return;
    s = symbase(&n);
    nsym = 0;
    while(n--)
        psym(s++, 0);

    printsyms(symptr, nsym);
}
@

<<function psym>>=
void
psym(Sym *s, void* p)
{
    USED(p);
    switch(s->type) {
    case 'T':
    case 'L':
    case 'D':
    case 'B':
        if (uflag)
            return;
        if (!aflag && ((s->name[0] == '.' || s->name[0] == '$')))
            return;
        break;
    case 'b':
    case 'd':
    case 'l':
    case 't':
        if (uflag || gflag)
            return;
        if (!aflag && ((s->name[0] == '.' || s->name[0] == '$')))
            return;
        break;
    case 'U':
        if (gflag)
            return;
        break;
    case 'Z':
        if (!aflag)
            return;
        break;
    case 'm':
    case 'f':	/* we only see a 'z' when the following is true*/
        if(!aflag || uflag || gflag)
            return;
        if (strcmp(s->name, ".frame"))
            zenter(s);
        break;
    case 'a':
    case 'p':
    case 'z':
    default:
        if(!aflag || uflag || gflag)
            return;
        break;
    }
    symptr = realloc(symptr, (nsym+1)*sizeof(Sym*));
    if (symptr == 0) {
        error("out of memory");
        exits("memory");
    }
    symptr[nsym++] = s;
}
@

<<function printsyms>>=
void
printsyms(Sym **symptr, long nsym)
{
    int i, wid;
    Sym *s;
    char *cp;
    char path[512];

    if(!sflag)
        qsort(symptr, nsym, sizeof(*symptr), cmp);
    
    wid = 0;
    for (i=0; i<nsym; i++) {
        s = symptr[i];
        if (s->value && wid == 0)
            wid = 8;
        else if (s->value >= 0x100000000LL && wid == 8)
            wid = 16;
    }	
    for (i=0; i<nsym; i++) {
        s = symptr[i];
        if (multifile && !hflag)
            Bprint(&bout, "%s:", filename);
        if (s->type == 'z') {
            fileelem(fnames, (uchar *) s->name, path, 512);
            cp = path;
        } else
            cp = s->name;
        if (Tflag)
            Bprint(&bout, "%8ux ", s->sig);
        if (s->value || s->type == 'a' || s->type == 'p')
            Bprint(&bout, "%*llux ", wid, s->value);
        else
            Bprint(&bout, "%*s ", wid, "");
        Bprint(&bout, "%c %s\n", s->type, cp);
    }
}
@

<<function error>>=
static void
error(char *fmt, ...)
{
    Fmt f;
    char buf[128];
    va_list arg;

    fmtfdinit(&f, 2, buf, sizeof buf);
    fmtprint(&f, "%s: ", argv0);
    va_start(arg, fmt);
    fmtvprint(&f, fmt, arg);
    va_end(arg);
    fmtprint(&f, "\n");
    fmtfdflush(&f);
    errs = "errors";
}
@


%-------------------------------------------------------------

<<linkers/misc/nm.c>>=
/*
 * nm.c -- drive nm
 */
#include <u.h>
#include <libc.h>
#include <ar.h>
#include <bio.h>
#include <mach.h>

<<enum _anon_ (linkers/misc/nm.c)>>

<<global errs>>
<<global filename>>
<<global symname>>
<<global multifile>>
<<global aflag (linkers/misc/nm.c)>>
<<global gflag>>
<<global hflag>>
<<global nflag>>
<<global sflag>>
<<global uflag (linkers/misc/nm.c)>>
<<global Tflag>>

<<global fnames>>
<<global symptr>>
<<global nsym>>
<<global bout (linkers/misc/nm.c)>>

int	cmp(void*, void*);
static void	error(char*, ...);
void	execsyms(int);
void	psym(Sym*, void*);
void	printsyms(Sym**, long);
void	doar(Biobuf*);
void	dofile(Biobuf*);
void	zenter(Sym*);

<<function usage (linkers/misc/nm.c)>>

<<function main (linkers/misc/nm.c)>>

<<function doar>>

<<function dofile>>

<<function cmp>>
<<function zenter>>

<<function execsyms>>

<<function psym>>

<<function printsyms>>

<<function error>>
@


\subsection*{[[linkers/misc/size.c]]}

<<function size>>=
int
size(char *file)
{
    int fd;
    Fhdr f;

    if((fd = open(file, OREAD)) < 0){
        fprint(2, "size: ");
        perror(file);
        return 1;
    }
    if(crackhdr(fd, &f)) {
        print("%ldt + %ldd + %ldb = %ld\t%s\n", f.txtsz, f.datsz,
            f.bsssz, f.txtsz+f.datsz+f.bsssz, file);
        close(fd);
        return 0;
    }
    fprint(2, "size: %s not an a.out\n", file);
    close(fd);
    return 1;
}
@

<<function main (linkers/misc/size.c)>>=
void
main(int argc, char *argv[])
{
    char *err;
    int i;

    ARGBEGIN {
    default:
        fprint(2, "usage: size [a.out ...]\n");
        exits("usage");
    } ARGEND;

    err = 0;
    if(argc == 0)
        if(size("8.out"))
            err = "error";
    for(i=0; i<argc; i++)
        if(size(argv[i]))
            err = "error";
    exits(err);
}
@


%-------------------------------------------------------------

<<linkers/misc/size.c>>=
#include	<u.h>
#include	<libc.h>
#include	<bio.h>
#include	<mach.h>

<<function size>>

<<function main (linkers/misc/size.c)>>
@


\subsection*{[[linkers/misc/strip.c]]}

<<function error (linkers/misc/strip.c)>>=
void
error(char* fmt, ...)
{
    va_list arg;
    char *e, s[256];

    va_start(arg, fmt);
    e = seprint(s, s+sizeof(s), "%s: ", argv0);
    e = vseprint(e, s+sizeof(s), fmt, arg);
    e = seprint(e, s+sizeof(s), "\n");
    va_end(arg);

    write(2, s, e-s);
}
@

<<function usage (linkers/misc/strip.c)>>=
static void
usage(void)
{
    error("usage: %s -o ofile file\n\t%s file ...\n", argv0, argv0);
    exits("usage");
}
@

<<function strip>>=
static int
strip(char* file, char* out)
{
    Dir *dir;
    int fd, i;
    Fhdr fhdr;
    Exec *exec;
    ulong mode;
    void *data;
    vlong length;

    if((fd = open(file, OREAD)) < 0){
        error("%s: open: %r", file);
        return 1;
    }

    if(!crackhdr(fd, &fhdr)){
        error("%s: %r", file);
        close(fd);
        return 1;
    }
    for(i = MIN_MAGIC; i <= MAX_MAGIC; i++){
        if(fhdr.magic == _MAGIC(0, i) || fhdr.magic == _MAGIC(HDR_MAGIC, i))
            break;
    }
    if(i > MAX_MAGIC){
        error("%s: not a recognizeable binary", file);
        close(fd);
        return 1;
    }

    if((dir = dirfstat(fd)) == nil){
        error("%s: stat: %r", file);
        close(fd);
        return 1;
    }

    length = fhdr.datoff+fhdr.datsz;
    if(length == dir->length){
        if(out == nil){	/* nothing to do */
            error("%s: already stripped", file);
            free(dir);
            close(fd);
            return 0;
        }
    }
    if(length > dir->length){
        error("%s: strange length", file);
        close(fd);
        free(dir);
        return 1;
    }

    mode = dir->mode;
    free(dir);

    if((data = malloc(length)) == nil){
        error("%s: malloc failure", file);
        close(fd);
        return 1;
    }
    seek(fd, 0LL, 0);
    if(read(fd, data, length) != length){
        error("%s: read: %r", file);
        close(fd);
        free(data);
        return 1;
    }
    close(fd);

    exec = data;
    exec->syms = 0;
    exec->spsz = 0;
    exec->pcsz = 0;

    if(out == nil){
        if(remove(file) < 0) {
            error("%s: remove: %r", file);
            free(data);
            return 1;
        }
        out = file;
    }
    if((fd = create(out, OWRITE, mode)) < 0){
        error("%s: create: %r", out);
        free(data);
        return 1;
    }
    if(write(fd, data, length) != length){
        error("%s: write: %r", out);
        close(fd);
        free(data);
        return 1;
    }
    close(fd);
    free(data);

    return 0;
}
@

<<function main (linkers/misc/strip.c)>>=
void
main(int argc, char* argv[])
{
    int r;
    char *p;

    p = nil;

    ARGBEGIN{
    default:
        usage();
        break;
    case 'o':
        p = ARGF();
        if(p == nil)
            usage();
        break;
    }ARGEND;

    switch(argc){
    case 0:
        usage();
        return;
    case 1:
        if(p != nil){
            r = strip(*argv, p);
            break;
        }
        /*FALLTHROUGH*/
    default:
        r = 0;
        while(argc > 0){
            r |= strip(*argv, nil);
            argc--;
            argv++;
        }
        break;
    }

    if(r)
        exits("error");
    exits(0);
}
@


%-------------------------------------------------------------

<<linkers/misc/strip.c>>=
#include <u.h>
#include <libc.h>
#include <bio.h>
#include <mach.h>

<<function error (linkers/misc/strip.c)>>

<<function usage (linkers/misc/strip.c)>>

<<function strip>>

<<function main (linkers/misc/strip.c)>>
@


\section{[[linkers/8l/]]}

\subsection*{[[linkers/8l/elf.h]]}

%-------------------------------------------------------------

<<linkers/8l/elf.h>>=
#include <elf.h>

// vs include/elf.h? and libmach/elf.h?

<<enum _anon_ (linkers/8l/elf.h)>>


typedef void (*Putl)(long);

void	elf32(int mach, int bo, int addpsects, void (*putpsects)(Putl));
//void	elf32phdr(void (*putl)(long), ulong type, ulong off, ulong vaddr,
//    ulong paddr, ulong filesz, ulong memsz, ulong prots, ulong align);
//void	elf32shdr(void (*putl)(long), ulong name, ulong type, ulong flags,
//    ulong vaddr, ulong off, ulong sectsz, ulong link, ulong addnl,
//    ulong align, ulong entsz);

void	elf64(int mach, int bo, int addpsects, void (*putpsects)(Putl));
//void	elf64phdr(void (*putl)(long), void (*putll)(vlong), ulong type,
//    uvlong off, uvlong vaddr, uvlong paddr, uvlong filesz, uvlong memsz,
//    ulong prots, uvlong align);
//void	elf64shdr(void (*putl)(long), void (*putll)(vlong), ulong name,
//    ulong type, uvlong flags, uvlong vaddr, uvlong off, uvlong sectsz,
//    ulong link, ulong addnl, uvlong align, uvlong entsz);
@


\subsection*{[[linkers/8l/l.h]]}

<<global cbc>>=
int	cbc;
@

<<global cbp>>=
char*	cbp;
@

<<function cput>>=
#define	cput(c)\
    { *cbp++ = c;\
    if(--cbc <= 0)\
        cflush(); }
@

<<constant LIBNAMELEN>>=
#define	LIBNAMELEN	300
@



<<enum misc1>>=
enum misc1 {
    <<constant NHASH 8l.h>>
    <<constant NHUNK>>

    MINSIZ		= 4,
    STRINGSZ	= 200,
    MINLC		= 1,
    MAXIO		= 8192,
    MAXHIST		= 20, /* limit of path elements for history symbols */
};
@




<<enum rxxx>>=
enum rxxx {
    Roffset	= 22,		/* no. bits for offset in relocation address */
    Rindex	= 10,		/* no. bits for index in relocation address */
};
@


%-------------------------------------------------------------

<<linkers/8l/l.h>>=
#include	<u.h>
#include	<libc.h>
#include	<bio.h>

#include	<common.out.h>
#include	<386/8.out.h>
#include	"../8l/elf.h"

<<constant P>>
<<constant S>>
<<constant TNAME>>

<<function cput>>

<<constant LIBNAMELEN>>

typedef	struct	Adr	Adr;
typedef	struct	Prog	Prog;
typedef	struct	Sym	Sym;
typedef	struct	Auto	Auto;
typedef	struct	Optab	Optab;

<<struct Adr>>

<<constant offset>>
<<constant scon>>
<<constant cond>>
<<constant ieee>>

<<constant autom>>
<<constant sym>>

<<struct Prog>>
<<struct Auto>>
<<struct Sym>>
<<struct Optab>>

<<enum sxxx>>
<<enum yxxx>>
<<enum zxxx>>
<<enum pxxx>>
<<enum rxxx>>

<<enum misc1>>

<<struct Buf>>
extern union Buf buf;

<<constant cbuf>>
<<constant xbuf>>

#pragma	varargck	type	"A"	int
#pragma	varargck	type	"A"	uint
#pragma	varargck	type	"D"	Adr*
#pragma	varargck	type	"P"	Prog*
#pragma	varargck	type	"R"	int
#pragma	varargck	type	"R"	uint
#pragma	varargck	type	"S"	char*

#pragma	varargck	argpos	diag 1

extern	long	HEADR;
extern	long	HEADTYPE;
extern	long	INITDAT;
extern	long	INITRND;
extern	long	INITTEXT;
extern	long	INITTEXTP;
extern	char*	INITENTRY;		/* entry point */
extern	Biobuf	bso;
extern	long	bsssize;
extern	int	cbc;
extern	char*	cbp;
extern	char*	pcstr;
extern	int	cout;
extern	Auto*	curauto;
extern	Auto*	curhist;
extern	Prog*	curp;
extern	Prog*	curtext;
extern	Prog*	datap;
extern	Prog*	edatap;
extern	long	datsize;
extern	char	debug[128];
extern	char	literal[32];
extern	Prog*	etextp;
extern	Prog*	firstp;
extern	char	fnuxi8[8];
extern	char	fnuxi4[4];
extern	Sym*	hash[NHASH];
extern	Sym*	histfrog[MAXHIST];
extern	int	histfrogp;
extern	int	histgen;
extern	char*	library[50];
extern	char*	libraryobj[50];
extern	int	libraryp;
extern	int	xrefresolv;
extern	char*	hunk;
extern	char	inuxi1[1];
extern	char	inuxi2[2];
extern	char	inuxi4[4];
extern	char	ycover[Ymax*Ymax];
extern	uchar*	andptr;
extern	uchar	and[30];
extern	char	reg[D_NONE];
extern	Prog*	lastp;
extern	long	lcsize;
extern	int	nerrors;
extern	long	nhunk;
extern	long	nsymbol;
//@Scheck: used by TName, not useless
extern	char*	noname;
extern	char*	outfile;
extern	long	pc;
extern	long	spsize;
extern	long	symsize;
extern	Prog*	textp;
extern	long	textsize;
extern	long	thunk;
extern	int	version;
extern	Prog	zprg;
extern	int	dtype;

extern	Adr*	reloca;
extern	int	doexp, dlm;
extern	int	imports, nimports;
extern	int	exports, nexports, allexport;
extern	char*	EXPTAB;
extern	Prog	undefp;

<<constant UP>>

extern	Optab	optab[];
//@Scheck: defined in ../8c/enam.c
extern	char*	anames[];


Prog*	appendp(Prog*);
void	asmb(void);
void	asmdyn(void);
void	asmins(Prog*);
void	asmlc(void);

void	asmsym(void);
long	atolwhex(char*);

void	cflush(void);
void	ckoff(Sym*, long);
Prog*	copyp(Prog*);

double	cputime(void); //?


void	diag(char*, ...);
void	dodata(void);
void	doinit(void);
void	dostkoff(void);
void	dynreloc(Sym*, ulong, int);

void	errorexit(void);
void	export(void);
int	fileexists(char*);


void	follow(void);
void	gethunk(void);
long	ieeedtof(Ieee*);
void	import(void);

void	listinit(void);
Sym*	lookup(char*, int);
void	lput(long);
void	lputl(long);
void	llput(vlong v);
void	llputl(vlong v);
void	main(int, char*[]);

void	patch(void);
Prog*	prg(void);


long	rnd(long, long);
void	span(void);
void	strnput(char*, int);
void	undef(void);
void	undefsym(Sym*);

void	wput(long);
void	wputl(long);
void	xdefine(char*, int, long);



#pragma	varargck	type	"D"	Adr*
#pragma	varargck	type	"P"	Prog*
#pragma	varargck	type	"R"	int
#pragma	varargck	type	"A"	int
@


\subsection*{[[linkers/8l/globals.c]]}

<<global buf>>=
union Buf buf;
@

<<global HEADR>>=
long	HEADR;
@

<<global HEADTYPE>>=
long	HEADTYPE;
@

<<global INITDAT>>=
long	INITDAT;
@

<<global INITRND>>=
long	INITRND;
@

<<global INITTEXT>>=
long	INITTEXT;
@

<<global INITTEXTP>>=
long	INITTEXTP;
@

<<global INITENTRY>>=
char*	INITENTRY;		/* entry point */
@

<<global bso>>=
Biobuf	bso;
@

<<global bsssize>>=
long	bsssize;
@



<<global pcstr>>=
char*	pcstr;
@

<<global cout>>=
int	cout;
@

<<global curauto>>=
Auto*	curauto;
@

<<global curhist>>=
Auto*	curhist;
@

<<global curp>>=
Prog*	curp;
@


<<global datap>>=
Prog*	datap;
@

<<global edatap>>=
Prog*	edatap;
@

<<global datsize>>=
long	datsize;
@


<<global literal>>=
char	literal[32];
@

<<global etextp>>=
Prog*	etextp;
@

<<global firstp>>=
Prog*	firstp;
@

<<global fnuxi8>>=
char	fnuxi8[8];
@

<<global fnuxi4>>=
char	fnuxi4[4];
@


<<global histfrog>>=
Sym*	histfrog[MAXHIST];
@

<<global histfrogp>>=
int	histfrogp;
@

<<global histgen>>=
int	histgen;
@

<<global library>>=
char*	library[50];
@

<<global libraryobj>>=
char*	libraryobj[50];
@

<<global libraryp>>=
int	libraryp;
@

<<global xrefresolv>>=
int	xrefresolv;
@


<<global inuxi1>>=
char	inuxi1[1];
@

<<global inuxi2>>=
char	inuxi2[2];
@

<<global inuxi4>>=
char	inuxi4[4];
@

<<global ycover>>=
char	ycover[Ymax*Ymax];
@

<<global andptr>>=
uchar*	andptr;
@

<<global and>>=
uchar	and[30];
@

<<global reg>>=
char	reg[D_NONE];
@

<<global lastp>>=
Prog*	lastp;
@

<<global lcsize>>=
long	lcsize;
@



<<global nsymbol>>=
long	nsymbol;
@


<<global outfile>>=
char*	outfile;
@

<<global pc>>=
long	pc;
@

<<global spsize>>=
long	spsize;
@

<<global symsize>>=
long	symsize;
@

<<global textp>>=
Prog*	textp;
@

<<global textsize>>=
long	textsize;
@

<<global thunk>>=
long	thunk;
@

<<global version>>=
int	version;
@

<<global zprg>>=
Prog	zprg;
@

<<global dtype>>=
int	dtype;
@

<<global reloca>>=
Adr*	reloca;
@

<<global EXPTAB>>=
char*	EXPTAB;
@



%-------------------------------------------------------------

<<linkers/8l/globals.c>>=
#include	"l.h"

<<global buf>>

<<global HEADR>>
<<global HEADTYPE>>
<<global INITDAT>>
<<global INITRND>>
<<global INITTEXT>>
<<global INITTEXTP>>
<<global INITENTRY>>
<<global bso>>
<<global bsssize>>
<<global cbc>>
<<global cbp>>
<<global pcstr>>
<<global cout>>
<<global curp>>
<<global curtext>>
<<global datap>>
<<global edatap>>
<<global datsize>>
<<global debug>>
<<global firstp>>
<<global fnuxi8>>
<<global fnuxi4>>
<<global hash (linkers/8l/globals.c)>>
<<global hunk>>
<<global inuxi1>>
<<global inuxi2>>
<<global inuxi4>>
<<global ycover>>
<<global andptr>>
<<global and>>
<<global reg>>
<<global lastp>>
<<global lcsize>>
<<global nerrors>>
<<global nhunk>>
<<global nsymbol>>
<<global outfile>>
<<global pc>>
<<global symsize>>
<<global textp>>
<<global textsize>>
<<global thunk>>
<<global zprg>>
<<global dtype>>

<<global reloca>>
int dlm;
int	imports, nimports;
int	exports, nexports, allexport;
<<global EXPTAB>>
<<global undefp>>

@


\subsection*{[[linkers/8l/optab.c]]}

<<global ynone>>=
uchar	ynone[] =
{
    Ynone,	Ynone,	Zlit,	1,
    0
};
@

<<global ytext>>=
uchar	ytext[] =
{
    Ymb,	Yi32,	Zpseudo,1,
    0
};
@

<<global ynop>>=
uchar	ynop[] =
{
    Ynone,	Ynone,	Zpseudo,1,
    Ynone,	Yml,	Zpseudo,1,
    Ynone,	Yrf,	Zpseudo,1,
    Yml,	Ynone,	Zpseudo,1,
    Yrf,	Ynone,	Zpseudo,1,
    0
};
@

<<global yxorb>>=
uchar	yxorb[] =
{
    Yi32,	Yal,	Zib_,	1,
    Yi32,	Ymb,	Zibo_m,	2,
    Yrb,	Ymb,	Zr_m,	1,
    Ymb,	Yrb,	Zm_r,	1,
    0
};
@

<<global yxorl>>=
uchar	yxorl[] =
{
    Yi8,	Yml,	Zibo_m,	2,
    Yi32,	Yax,	Zil_,	1,
    Yi32,	Yml,	Zilo_m,	2,
    Yrl,	Yml,	Zr_m,	1,
    Yml,	Yrl,	Zm_r,	1,
    0
};
@

<<global yaddl>>=
uchar	yaddl[] =
{
    Yi8,	Yml,	Zibo_m,	2,
    Yi32,	Yax,	Zil_,	1,
    Yi32,	Yml,	Zilo_m,	2,
    Yrl,	Yml,	Zr_m,	1,
    Yml,	Yrl,	Zm_r,	1,
    0
};
@

<<global yincb>>=
uchar	yincb[] =
{
    Ynone,	Ymb,	Zo_m,	2,
    0
};
@

<<global yincl>>=
uchar	yincl[] =
{
    Ynone,	Yrl,	Z_rp,	1,
    Ynone,	Yml,	Zo_m,	2,
    0
};
@

<<global ycmpb>>=
uchar	ycmpb[] =
{
    Yal,	Yi32,	Z_ib,	1,
    Ymb,	Yi32,	Zm_ibo,	2,
    Ymb,	Yrb,	Zm_r,	1,
    Yrb,	Ymb,	Zr_m,	1,
    0
};
@

<<global ycmpl>>=
uchar	ycmpl[] =
{
    Yml,	Yi8,	Zm_ibo,	2,
    Yax,	Yi32,	Z_il,	1,
    Yml,	Yi32,	Zm_ilo,	2,
    Yml,	Yrl,	Zm_r,	1,
    Yrl,	Yml,	Zr_m,	1,
    0
};
@

<<global yshb>>=
uchar	yshb[] =
{
    Yi1,	Ymb,	Zo_m,	2,
    Yi32,	Ymb,	Zibo_m,	2,
    Ycx,	Ymb,	Zo_m,	2,
    0
};
@

<<global yshl>>=
uchar	yshl[] =
{
    Yi1,	Yml,	Zo_m,	2,
    Yi32,	Yml,	Zibo_m,	2,
    Ycl,	Yml,	Zo_m,	2,
    Ycx,	Yml,	Zo_m,	2,
    0
};
@

<<global ytestb>>=
uchar	ytestb[] =
{
    Yi32,	Yal,	Zib_,	1,
    Yi32,	Ymb,	Zibo_m,	2,
    Yrb,	Ymb,	Zr_m,	1,
    Ymb,	Yrb,	Zm_r,	1,
    0
};
@

<<global ytestl>>=
uchar	ytestl[] =
{
    Yi32,	Yax,	Zil_,	1,
    Yi32,	Yml,	Zilo_m,	2,
    Yrl,	Yml,	Zr_m,	1,
    Yml,	Yrl,	Zm_r,	1,
    0
};
@

<<global ymovb>>=
uchar	ymovb[] =
{
    Yrb,	Ymb,	Zr_m,	1,
    Ymb,	Yrb,	Zm_r,	1,
    Yi32,	Yrb,	Zib_rp,	1,
    Yi32,	Ymb,	Zibo_m,	2,
    0
};
@

<<global ymovl>>=
uchar	ymovl[] =
{
    Yrl,	Yml,	Zr_m,	1,
    Yml,	Yrl,	Zm_r,	1,
    Yi0,	Yrl,	Zclr,	1+2,
//	Yi0,	Yml,	Zibo_m,	2,	// shorter but slower AND $0,dst
    Yi32,	Yrl,	Zil_rp,	1,
    Yi32,	Yml,	Zilo_m,	2,
    Yiauto,	Yrl,	Zaut_r,	2,
    0
};
@
%$

<<global ym_rl>>=
uchar	ym_rl[] =
{
    Ym,	Yrl,	Zm_r,	1,
    0
};
@

<<global yrl_m>>=
uchar	yrl_m[] =
{
    Yrl,	Ym,	Zr_m,	1,
    0
};
@

<<global ymb_rl>>=
uchar	ymb_rl[] =
{
    Ymb,	Yrl,	Zm_r,	1,
    0
};
@

<<global yml_rl>>=
uchar	yml_rl[] =
{
    Yml,	Yrl,	Zm_r,	1,
    0
};
@

<<global yrl_ml>>=
uchar	yrl_ml[] =
{
    Yrl,	Yml,	Zr_m,	1,
    0
};
@

<<global yml_mb>>=
uchar	yml_mb[] =
{
    Yrb,	Ymb,	Zr_m,	1,
    Ymb,	Yrb,	Zm_r,	1,
    0
};
@

<<global yml_ml>>=
uchar	yml_ml[] =
{
    Yrl,	Yml,	Zr_m,	1,
    Yml,	Yrl,	Zm_r,	1,
    0
};
@

<<global ydivl>>=
uchar	ydivl[] =
{
    Yml,	Ynone,	Zm_o,	2,
    0
};
@

<<global ydivb>>=
uchar	ydivb[] =
{
    Ymb,	Ynone,	Zm_o,	2,
    0
};
@

<<global yimul>>=
uchar	yimul[] =
{
    Yml,	Ynone,	Zm_o,	2,
    Yi8,	Yrl,	Zib_rr,	1,
    Yi32,	Yrl,	Zil_rr,	1,
    0
};
@

<<global ybyte>>=
uchar	ybyte[] =
{
    Yi32,	Ynone,	Zbyte,	1,
    0
};
@

<<global yin>>=
uchar	yin[] =
{
    Yi32,	Ynone,	Zib_,	1,
    Ynone,	Ynone,	Zlit,	1,
    0
};
@

<<global yint>>=
uchar	yint[] =
{
    Yi32,	Ynone,	Zib_,	1,
    0
};
@

<<global ypushl>>=
uchar	ypushl[] =
{
    Yrl,	Ynone,	Zrp_,	1,
    Ym,	Ynone,	Zm_o,	2,
    Yi8,	Ynone,	Zib_,	1,
    Yi32,	Ynone,	Zil_,	1,
    0
};
@

<<global ypopl>>=
uchar	ypopl[] =
{
    Ynone,	Yrl,	Z_rp,	1,
    Ynone,	Ym,	Zo_m,	2,
    0
};
@

<<global yscond>>=
uchar	yscond[] =
{
    Ynone,	Ymb,	Zo_m,	2,
    0
};
@

<<global yjcond>>=
uchar	yjcond[] =
{
    Ynone,	Ybr,	Zbr,	1,
    0
};
@

<<global yloop>>=
uchar	yloop[] =
{
    Ynone,	Ybr,	Zloop,	1,
    0
};
@

<<global ycall>>=
uchar	ycall[] =
{
    Ynone,	Yml,	Zo_m,	2,
    Ynone,	Ybr,	Zcall,	1,
    0
};
@

<<global yjmp>>=
uchar	yjmp[] =
{
    Ynone,	Yml,	Zo_m,	2,
    Ynone,	Ybr,	Zjmp,	1,
    0
};
@

<<global yfmvd>>=
uchar	yfmvd[] =
{
    Ym,	Yf0,	Zm_o,	2,
    Yf0,	Ym,	Zo_m,	2,
    Yrf,	Yf0,	Zm_o,	2,
    Yf0,	Yrf,	Zo_m,	2,
    0
};
@

<<global yfmvdp>>=
uchar	yfmvdp[] =
{
    Yf0,	Ym,	Zo_m,	2,
    Yf0,	Yrf,	Zo_m,	2,
    0
};
@

<<global yfmvf>>=
uchar	yfmvf[] =
{
    Ym,	Yf0,	Zm_o,	2,
    Yf0,	Ym,	Zo_m,	2,
    0
};
@

<<global yfmvx>>=
uchar	yfmvx[] =
{
    Ym,	Yf0,	Zm_o,	2,
    0
};
@

<<global yfmvp>>=
uchar	yfmvp[] =
{
    Yf0,	Ym,	Zo_m,	2,
    0
};
@

<<global yfadd>>=
uchar	yfadd[] =
{
    Ym,	Yf0,	Zm_o,	2,
    Yrf,	Yf0,	Zm_o,	2,
    Yf0,	Yrf,	Zo_m,	2,
    0
};
@

<<global yfaddp>>=
uchar	yfaddp[] =
{
    Yf0,	Yrf,	Zo_m,	2,
    0
};
@

<<global yfxch>>=
uchar	yfxch[] =
{
    Yf0,	Yrf,	Zo_m,	2,
    Yrf,	Yf0,	Zm_o,	2,
    0
};
@

<<global ycompp>>=
uchar	ycompp[] =
{
    Yf0,	Yrf,	Zo_m,	2,	/* botch is really f0,f1 */
    0
};
@

<<global ystsw>>=
uchar	ystsw[] =
{
    Ynone,	Ym,	Zo_m,	2,
    Ynone,	Yax,	Zlit,	1,
    0
};
@

<<global ystcw>>=
uchar	ystcw[] =
{
    Ynone,	Ym,	Zo_m,	2,
    Ym,	Ynone,	Zm_o,	2,
    0
};
@

<<global ysvrs>>=
uchar	ysvrs[] =
{
    Ynone,	Ym,	Zo_m,	2,
    Ym,	Ynone,	Zm_o,	2,
    0
};
@

<<global optab>>=
Optab optab[] =
/*	as, ytab, andproto, opcode */
{
    { AXXX },
    { AAAA,		ynone,	Px, 0x37 },
    { AAAD,		ynone,	Px, 0xd5,0x0a },
    { AAAM,		ynone,	Px, 0xd4,0x0a },
    { AAAS,		ynone,	Px, 0x3f },
    { AADCB,	yxorb,	Pb, 0x14,0x80,(02),0x10,0x10 },
    { AADCL,	yxorl,	Px, 0x83,(02),0x15,0x81,(02),0x11,0x13 },
    { AADCW,	yxorl,	Pe, 0x83,(02),0x15,0x81,(02),0x11,0x13 },
    { AADDB,	yxorb,	Px, 0x04,0x80,(00),0x00,0x02 },
    { AADDL,	yaddl,	Px, 0x83,(00),0x05,0x81,(00),0x01,0x03 },
    { AADDW,	yaddl,	Pe, 0x83,(00),0x05,0x81,(00),0x01,0x03 },
    { AADJSP },
    { AANDB,	yxorb,	Pb, 0x24,0x80,(04),0x20,0x22 },
    { AANDL,	yxorl,	Px, 0x83,(04),0x25,0x81,(04),0x21,0x23 },
    { AANDW,	yxorl,	Pe, 0x83,(04),0x25,0x81,(04),0x21,0x23 },
    { AARPL,	yrl_ml,	Px, 0x63 },
    { ABOUNDL,	yrl_m,	Px, 0x62 },
    { ABOUNDW,	yrl_m,	Pe, 0x62 },
    { ABSFL,	yml_rl,	Pm, 0xbc },
    { ABSFW,	yml_rl,	Pq, 0xbc },
    { ABSRL,	yml_rl,	Pm, 0xbd },
    { ABSRW,	yml_rl,	Pq, 0xbd },
    { ABTL,		yml_rl,	Pm, 0xa3 },
    { ABTW,		yml_rl,	Pq, 0xa3 },
    { ABTCL,	yml_rl,	Pm, 0xbb },
    { ABTCW,	yml_rl,	Pq, 0xbb },
    { ABTRL,	yml_rl,	Pm, 0xb3 },
    { ABTRW,	yml_rl,	Pq, 0xb3 },
    { ABTSL,	yml_rl,	Pm, 0xab },
    { ABTSW,	yml_rl,	Pq, 0xab },
    { ABYTE,	ybyte,	Px, 1 },
    { ACALL,	ycall,	Px, 0xff,(02),0xe8 },
    { ACLC,		ynone,	Px, 0xf8 },
    { ACLD,		ynone,	Px, 0xfc },
    { ACLI,		ynone,	Px, 0xfa },
    { ACLTS,	ynone,	Pm, 0x06 },
    { ACMC,		ynone,	Px, 0xf5 },
    { ACMPB,	ycmpb,	Pb, 0x3c,0x80,(07),0x38,0x3a },
    { ACMPL,	ycmpl,	Px, 0x83,(07),0x3d,0x81,(07),0x39,0x3b },
    { ACMPW,	ycmpl,	Pe, 0x83,(07),0x3d,0x81,(07),0x39,0x3b },
    { ACMPSB,	ynone,	Pb, 0xa6 },
    { ACMPSL,	ynone,	Px, 0xa7 },
    { ACMPSW,	ynone,	Pe, 0xa7 },
    { ADAA,		ynone,	Px, 0x27 },
    { ADAS,		ynone,	Px, 0x2f },
    { ADATA },
    { ADECB,	yincb,	Pb, 0xfe,(01) },
    { ADECL,	yincl,	Px, 0x48,0xff,(01) },
    { ADECW,	yincl,	Pe, 0x48,0xff,(01) },
    { ADIVB,	ydivb,	Pb, 0xf6,(06) },
    { ADIVL,	ydivl,	Px, 0xf7,(06) },
    { ADIVW,	ydivl,	Pe, 0xf7,(06) },
    { AENTER },				/* botch */
    { AGLOBL },
    { AGOK },
    { AHISTORY },
    { AHLT,		ynone,	Px, 0xf4 },
    { AIDIVB,	ydivb,	Pb, 0xf6,(07) },
    { AIDIVL,	ydivl,	Px, 0xf7,(07) },
    { AIDIVW,	ydivl,	Pe, 0xf7,(07) },
    { AIMULB,	ydivb,	Pb, 0xf6,(05) },
    { AIMULL,	yimul,	Px, 0xf7,(05),0x6b,0x69 },
    { AIMULW,	yimul,	Pe, 0xf7,(05),0x6b,0x69 },
    { AINB,		yin,	Pb, 0xe4,0xec },
    { AINL,		yin,	Px, 0xe5,0xed },
    { AINW,		yin,	Pe, 0xe5,0xed },
    { AINCB,	yincb,	Pb, 0xfe,(00) },
    { AINCL,	yincl,	Px, 0x40,0xff,(00) },
    { AINCW,	yincl,	Pe, 0x40,0xff,(00) },
    { AINSB,	ynone,	Pb, 0x6c },
    { AINSL,	ynone,	Px, 0x6d },
    { AINSW,	ynone,	Pe, 0x6d },
    { AINT,		yint,	Px, 0xcd },
    { AINTO,	ynone,	Px, 0xce },
    { AIRETL,	ynone,	Px, 0xcf },
    { AIRETW,	ynone,	Pe, 0xcf },
    { AJCC,		yjcond,	Px, 0x73,0x83,(00) },
    { AJCS,		yjcond,	Px, 0x72,0x82 },
    { AJCXZ,	yloop,	Px, 0xe3 },
    { AJEQ,		yjcond,	Px, 0x74,0x84 },
    { AJGE,		yjcond,	Px, 0x7d,0x8d },
    { AJGT,		yjcond,	Px, 0x7f,0x8f },
    { AJHI,		yjcond,	Px, 0x77,0x87 },
    { AJLE,		yjcond,	Px, 0x7e,0x8e },
    { AJLS,		yjcond,	Px, 0x76,0x86 },
    { AJLT,		yjcond,	Px, 0x7c,0x8c },
    { AJMI,		yjcond,	Px, 0x78,0x88 },
    { AJMP,		yjmp,	Px, 0xff,(04),0xeb,0xe9 },
    { AJNE,		yjcond,	Px, 0x75,0x85 },
    { AJOC,		yjcond,	Px, 0x71,0x81,(00) },
    { AJOS,		yjcond,	Px, 0x70,0x80,(00) },
    { AJPC,		yjcond,	Px, 0x7b,0x8b },
    { AJPL,		yjcond,	Px, 0x79,0x89 },
    { AJPS,		yjcond,	Px, 0x7a,0x8a },
    { ALAHF,	ynone,	Px, 0x9f },
    { ALARL,	yml_rl,	Pm, 0x02 },
    { ALARW,	yml_rl,	Pq, 0x02 },
    { ALEAL,	ym_rl,	Px, 0x8d },
    { ALEAW,	ym_rl,	Pe, 0x8d },
    { ALEAVEL,	ynone,	Px, 0xc9 },
    { ALEAVEW,	ynone,	Pe, 0xc9 },
    { ALOCK,	ynone,	Px, 0xf0 },
    { ALODSB,	ynone,	Pb, 0xac },
    { ALODSL,	ynone,	Px, 0xad },
    { ALODSW,	ynone,	Pe, 0xad },
    { ALONG,	ybyte,	Px, 4 },
    { ALOOP,	yloop,	Px, 0xe2 },
    { ALOOPEQ,	yloop,	Px, 0xe1 },
    { ALOOPNE,	yloop,	Px, 0xe0 },
    { ALSLL,	yml_rl,	Pm, 0x03  },
    { ALSLW,	yml_rl,	Pq, 0x03  },
    { AMOVB,	ymovb,	Pb, 0x88,0x8a,0xb0,0xc6,(00) },
    { AMOVL,	ymovl,	Px, 0x89,0x8b,0x31,0x83,(04),0xb8,0xc7,(00) },
    { AMOVW,	ymovl,	Pe, 0x89,0x8b,0x31,0x83,(04),0xb8,0xc7,(00) },
    { AMOVBLSX,	ymb_rl,	Pm, 0xbe },
    { AMOVBLZX,	ymb_rl,	Pm, 0xb6 },
    { AMOVBWSX,	ymb_rl,	Pq, 0xbe },
    { AMOVBWZX,	ymb_rl,	Pq, 0xb6 },
    { AMOVWLSX,	yml_rl,	Pm, 0xbf },
    { AMOVWLZX,	yml_rl,	Pm, 0xb7 },
    { AMOVSB,	ynone,	Pb, 0xa4 },
    { AMOVSL,	ynone,	Px, 0xa5 },
    { AMOVSW,	ynone,	Pe, 0xa5 },
    { AMULB,	ydivb,	Pb, 0xf6,(04) },
    { AMULL,	ydivl,	Px, 0xf7,(04) },
    { AMULW,	ydivl,	Pe, 0xf7,(04) },
    { ANAME },
    { ANEGB,	yscond,	Px, 0xf6,(03) },
    { ANEGL,	yscond,	Px, 0xf7,(03) },
    { ANEGW,	yscond,	Pe, 0xf7,(03) },
    { ANOP,		ynop,	Px,0,0 },
    { ANOTB,	yscond,	Px, 0xf6,(02) },
    { ANOTL,	yscond,	Px, 0xf7,(02) },
    { ANOTW,	yscond,	Pe, 0xf7,(02) },
    { AORB,		yxorb,	Pb, 0x0c,0x80,(01),0x08,0x0a },
    { AORL,		yxorl,	Px, 0x83,(01),0x0d,0x81,(01),0x09,0x0b },
    { AORW,		yxorl,	Pe, 0x83,(01),0x0d,0x81,(01),0x09,0x0b },
    { AOUTB,	yin,	Pb, 0xe6,0xee },
    { AOUTL,	yin,	Px, 0xe7,0xef },
    { AOUTW,	yin,	Pe, 0xe7,0xef },
    { AOUTSB,	ynone,	Pb, 0x6e },
    { AOUTSL,	ynone,	Px, 0x6f },
    { AOUTSW,	ynone,	Pe, 0x6f },
    { APOPAL,	ynone,	Px, 0x61 },
    { APOPAW,	ynone,	Pe, 0x61 },
    { APOPFL,	ynone,	Px, 0x9d },
    { APOPFW,	ynone,	Pe, 0x9d },
    { APOPL,	ypopl,	Px, 0x58,0x8f,(00) },
    { APOPW,	ypopl,	Pe, 0x58,0x8f,(00) },
    { APUSHAL,	ynone,	Px, 0x60 },
    { APUSHAW,	ynone,	Pe, 0x60 },
    { APUSHFL,	ynone,	Px, 0x9c },
    { APUSHFW,	ynone,	Pe, 0x9c },
    { APUSHL,	ypushl,	Px, 0x50,0xff,(06),0x6a,0x68 },
    { APUSHW,	ypushl,	Pe, 0x50,0xff,(06),0x6a,0x68 },
    { ARCLB,	yshb,	Pb, 0xd0,(02),0xc0,(02),0xd2,(02) },
    { ARCLL,	yshl,	Px, 0xd1,(02),0xc1,(02),0xd3,(02),0xd3,(02) },
    { ARCLW,	yshl,	Pe, 0xd1,(02),0xc1,(02),0xd3,(02),0xd3,(02) },
    { ARCRB,	yshb,	Pb, 0xd0,(03),0xc0,(03),0xd2,(03) },
    { ARCRL,	yshl,	Px, 0xd1,(03),0xc1,(03),0xd3,(03),0xd3,(03) },
    { ARCRW,	yshl,	Pe, 0xd1,(03),0xc1,(03),0xd3,(03),0xd3,(03) },
    { AREP,		ynone,	Px, 0xf3 },
    { AREPN,	ynone,	Px, 0xf2 },
    { ARET,		ynone,	Px, 0xc3 },
    { AROLB,	yshb,	Pb, 0xd0,(00),0xc0,(00),0xd2,(00) },
    { AROLL,	yshl,	Px, 0xd1,(00),0xc1,(00),0xd3,(00),0xd3,(00) },
    { AROLW,	yshl,	Pe, 0xd1,(00),0xc1,(00),0xd3,(00),0xd3,(00) },
    { ARORB,	yshb,	Pb, 0xd0,(01),0xc0,(01),0xd2,(01) },
    { ARORL,	yshl,	Px, 0xd1,(01),0xc1,(01),0xd3,(01),0xd3,(01) },
    { ARORW,	yshl,	Pe, 0xd1,(01),0xc1,(01),0xd3,(01),0xd3,(01) },
    { ASAHF,	ynone,	Px, 0x9e },
    { ASALB,	yshb,	Pb, 0xd0,(04),0xc0,(04),0xd2,(04) },
    { ASALL,	yshl,	Px, 0xd1,(04),0xc1,(04),0xd3,(04),0xd3,(04) },
    { ASALW,	yshl,	Pe, 0xd1,(04),0xc1,(04),0xd3,(04),0xd3,(04) },
    { ASARB,	yshb,	Pb, 0xd0,(07),0xc0,(07),0xd2,(07) },
    { ASARL,	yshl,	Px, 0xd1,(07),0xc1,(07),0xd3,(07),0xd3,(07) },
    { ASARW,	yshl,	Pe, 0xd1,(07),0xc1,(07),0xd3,(07),0xd3,(07) },
    { ASBBB,	yxorb,	Pb, 0x1c,0x80,(03),0x18,0x1a },
    { ASBBL,	yxorl,	Px, 0x83,(03),0x1d,0x81,(03),0x19,0x1b },
    { ASBBW,	yxorl,	Pe, 0x83,(03),0x1d,0x81,(03),0x19,0x1b },
    { ASCASB,	ynone,	Pb, 0xae },
    { ASCASL,	ynone,	Px, 0xaf },
    { ASCASW,	ynone,	Pe, 0xaf },
    { ASETCC,	yscond,	Pm, 0x93,(00) },
    { ASETCS,	yscond,	Pm, 0x92,(00) },
    { ASETEQ,	yscond,	Pm, 0x94,(00) },
    { ASETGE,	yscond,	Pm, 0x9d,(00) },
    { ASETGT,	yscond,	Pm, 0x9f,(00) },
    { ASETHI,	yscond,	Pm, 0x97,(00) },
    { ASETLE,	yscond,	Pm, 0x9e,(00) },
    { ASETLS,	yscond,	Pm, 0x96,(00) },
    { ASETLT,	yscond,	Pm, 0x9c,(00) },
    { ASETMI,	yscond,	Pm, 0x98,(00) },
    { ASETNE,	yscond,	Pm, 0x95,(00) },
    { ASETOC,	yscond,	Pm, 0x91,(00) },
    { ASETOS,	yscond,	Pm, 0x90,(00) },
    { ASETPC,	yscond,	Pm, 0x96,(00) },
    { ASETPL,	yscond,	Pm, 0x99,(00) },
    { ASETPS,	yscond,	Pm, 0x9a,(00) },
    { ACDQ,		ynone,	Px, 0x99 },
    { ACWD,		ynone,	Pe, 0x99 },
    { ASHLB,	yshb,	Pb, 0xd0,(04),0xc0,(04),0xd2,(04) },
    { ASHLL,	yshl,	Px, 0xd1,(04),0xc1,(04),0xd3,(04),0xd3,(04) },
    { ASHLW,	yshl,	Pe, 0xd1,(04),0xc1,(04),0xd3,(04),0xd3,(04) },
    { ASHRB,	yshb,	Pb, 0xd0,(05),0xc0,(05),0xd2,(05) },
    { ASHRL,	yshl,	Px, 0xd1,(05),0xc1,(05),0xd3,(05),0xd3,(05) },
    { ASHRW,	yshl,	Pe, 0xd1,(05),0xc1,(05),0xd3,(05),0xd3,(05) },
    { ASTC,		ynone,	Px, 0xf9 },
    { ASTD,		ynone,	Px, 0xfd },
    { ASTI,		ynone,	Px, 0xfb },
    { ASTOSB,	ynone,	Pb, 0xaa },
    { ASTOSL,	ynone,	Px, 0xab },
    { ASTOSW,	ynone,	Pe, 0xab },
    { ASUBB,	yxorb,	Pb, 0x2c,0x80,(05),0x28,0x2a },
    { ASUBL,	yaddl,	Px, 0x83,(05),0x2d,0x81,(05),0x29,0x2b },
    { ASUBW,	yaddl,	Pe, 0x83,(05),0x2d,0x81,(05),0x29,0x2b },
    { ASYSCALL,	ynone,	Px, 0xcd,100 },
    { ATESTB,	ytestb,	Pb, 0xa8,0xf6,(00),0x84,0x84 },
    { ATESTL,	ytestl,	Px, 0xa9,0xf7,(00),0x85,0x85 },
    { ATESTW,	ytestl,	Pe, 0xa9,0xf7,(00),0x85,0x85 },
    { ATEXT,	ytext,	Px },
    { AVERR,	ydivl,	Pm, 0x00,(04) },
    { AVERW,	ydivl,	Pm, 0x00,(05) },
    { AWAIT,	ynone,	Px, 0x9b },
    { AWORD,	ybyte,	Px, 2 },
    { AXCHGB,	yml_mb,	Pb, 0x86,0x86 },
    { AXCHGL,	yml_ml,	Px, 0x87,0x87 },
    { AXCHGW,	yml_ml,	Pe, 0x87,0x87 },
    { AXLAT,	ynone,	Px, 0xd7 },
    { AXORB,	yxorb,	Pb, 0x34,0x80,(06),0x30,0x32 },
    { AXORL,	yxorl,	Px, 0x83,(06),0x35,0x81,(06),0x31,0x33 },
    { AXORW,	yxorl,	Pe, 0x83,(06),0x35,0x81,(06),0x31,0x33 },

    { AFMOVB,	yfmvx,	Px, 0xdf,(04) },
    { AFMOVBP,	yfmvp,	Px, 0xdf,(06) },
    { AFMOVD,	yfmvd,	Px, 0xdd,(00),0xdd,(02),0xd9,(00),0xdd,(02) },
    { AFMOVDP,	yfmvdp,	Px, 0xdd,(03),0xdd,(03) },
    { AFMOVF,	yfmvf,	Px, 0xd9,(00),0xd9,(02) },
    { AFMOVFP,	yfmvp,	Px, 0xd9,(03) },
    { AFMOVL,	yfmvf,	Px, 0xdb,(00),0xdb,(02) },
    { AFMOVLP,	yfmvp,	Px, 0xdb,(03) },
    { AFMOVV,	yfmvx,	Px, 0xdf,(05) },
    { AFMOVVP,	yfmvp,	Px, 0xdf,(07) },
    { AFMOVW,	yfmvf,	Px, 0xdf,(00),0xdf,(02) },
    { AFMOVWP,	yfmvp,	Px, 0xdf,(03) },
    { AFMOVX,	yfmvx,	Px, 0xdb,(05) },
    { AFMOVXP,	yfmvp,	Px, 0xdb,(07) },

    { AFCOMB },
    { AFCOMBP },
    { AFCOMD,	yfadd,	Px, 0xdc,(02),0xd8,(02),0xdc,(02) },	/* botch */
    { AFCOMDP,	yfadd,	Px, 0xdc,(03),0xd8,(03),0xdc,(03) },	/* botch */
    { AFCOMDPP,	ycompp,	Px, 0xde,(03) },
    { AFCOMF,	yfmvx,	Px, 0xd8,(02) },
    { AFCOMFP,	yfmvx,	Px, 0xd8,(03) },
    { AFCOML,	yfmvx,	Px, 0xda,(02) },
    { AFCOMLP,	yfmvx,	Px, 0xda,(03) },
    { AFCOMW,	yfmvx,	Px, 0xde,(02) },
    { AFCOMWP,	yfmvx,	Px, 0xde,(03) },

    { AFUCOM,	ycompp,	Px, 0xdd,(04) },
    { AFUCOMP,	ycompp, Px, 0xdd,(05) },
    { AFUCOMPP,	ycompp,	Px, 0xda,(13) },

    { AFADDDP,	yfaddp,	Px, 0xde,(00) },
    { AFADDW,	yfmvx,	Px, 0xde,(00) },
    { AFADDL,	yfmvx,	Px, 0xda,(00) },
    { AFADDF,	yfmvx,	Px, 0xd8,(00) },
    { AFADDD,	yfadd,	Px, 0xdc,(00),0xd8,(00),0xdc,(00) },

    { AFMULDP,	yfaddp,	Px, 0xde,(01) },
    { AFMULW,	yfmvx,	Px, 0xde,(01) },
    { AFMULL,	yfmvx,	Px, 0xda,(01) },
    { AFMULF,	yfmvx,	Px, 0xd8,(01) },
    { AFMULD,	yfadd,	Px, 0xdc,(01),0xd8,(01),0xdc,(01) },

    { AFSUBDP,	yfaddp,	Px, 0xde,(05) },
    { AFSUBW,	yfmvx,	Px, 0xde,(04) },
    { AFSUBL,	yfmvx,	Px, 0xda,(04) },
    { AFSUBF,	yfmvx,	Px, 0xd8,(04) },
    { AFSUBD,	yfadd,	Px, 0xdc,(04),0xd8,(04),0xdc,(05) },

    { AFSUBRDP,	yfaddp,	Px, 0xde,(04) },
    { AFSUBRW,	yfmvx,	Px, 0xde,(05) },
    { AFSUBRL,	yfmvx,	Px, 0xda,(05) },
    { AFSUBRF,	yfmvx,	Px, 0xd8,(05) },
    { AFSUBRD,	yfadd,	Px, 0xdc,(05),0xd8,(05),0xdc,(04) },

    { AFDIVDP,	yfaddp,	Px, 0xde,(07) },
    { AFDIVW,	yfmvx,	Px, 0xde,(06) },
    { AFDIVL,	yfmvx,	Px, 0xda,(06) },
    { AFDIVF,	yfmvx,	Px, 0xd8,(06) },
    { AFDIVD,	yfadd,	Px, 0xdc,(06),0xd8,(06),0xdc,(07) },

    { AFDIVRDP,	yfaddp,	Px, 0xde,(06) },
    { AFDIVRW,	yfmvx,	Px, 0xde,(07) },
    { AFDIVRL,	yfmvx,	Px, 0xda,(07) },
    { AFDIVRF,	yfmvx,	Px, 0xd8,(07) },
    { AFDIVRD,	yfadd,	Px, 0xdc,(07),0xd8,(07),0xdc,(06) },

    { AFXCHD,	yfxch,	Px, 0xd9,(01),0xd9,(01) },
    { AFFREE },
    { AFLDCW,	ystcw,	Px, 0xd9,(05),0xd9,(05) },
    { AFLDENV,	ystcw,	Px, 0xd9,(04),0xd9,(04) },
    { AFRSTOR,	ysvrs,	Px, 0xdd,(04),0xdd,(04) },
    { AFSAVE,	ysvrs,	Px, 0xdd,(06),0xdd,(06) },
    { AFSTCW,	ystcw,	Px, 0xd9,(07),0xd9,(07) },
    { AFSTENV,	ystcw,	Px, 0xd9,(06),0xd9,(06) },
    { AFSTSW,	ystsw,	Px, 0xdd,(07),0xdf,0xe0 },
    { AF2XM1,	ynone,	Px, 0xd9, 0xf0 },
    { AFABS,	ynone,	Px, 0xd9, 0xe1 },
    { AFCHS,	ynone,	Px, 0xd9, 0xe0 },
    { AFCLEX,	ynone,	Px, 0xdb, 0xe2 },
    { AFCOS,	ynone,	Px, 0xd9, 0xff },
    { AFDECSTP,	ynone,	Px, 0xd9, 0xf6 },
    { AFINCSTP,	ynone,	Px, 0xd9, 0xf7 },
    { AFINIT,	ynone,	Px, 0xdb, 0xe3 },
    { AFLD1,	ynone,	Px, 0xd9, 0xe8 },
    { AFLDL2E,	ynone,	Px, 0xd9, 0xea },
    { AFLDL2T,	ynone,	Px, 0xd9, 0xe9 },
    { AFLDLG2,	ynone,	Px, 0xd9, 0xec },
    { AFLDLN2,	ynone,	Px, 0xd9, 0xed },
    { AFLDPI,	ynone,	Px, 0xd9, 0xeb },
    { AFLDZ,	ynone,	Px, 0xd9, 0xee },
    { AFNOP,	ynone,	Px, 0xd9, 0xd0 },
    { AFPATAN,	ynone,	Px, 0xd9, 0xf3 },
    { AFPREM,	ynone,	Px, 0xd9, 0xf8 },
    { AFPREM1,	ynone,	Px, 0xd9, 0xf5 },
    { AFPTAN,	ynone,	Px, 0xd9, 0xf2 },
    { AFRNDINT,	ynone,	Px, 0xd9, 0xfc },
    { AFSCALE,	ynone,	Px, 0xd9, 0xfd },
    { AFSIN,	ynone,	Px, 0xd9, 0xfe },
    { AFSINCOS,	ynone,	Px, 0xd9, 0xfb },
    { AFSQRT,	ynone,	Px, 0xd9, 0xfa },
    { AFTST,	ynone,	Px, 0xd9, 0xe4 },
    { AFXAM,	ynone,	Px, 0xd9, 0xe5 },
    { AFXTRACT,	ynone,	Px, 0xd9, 0xf4 },
    { AFYL2X,	ynone,	Px, 0xd9, 0xf1 },
    { AFYL2XP1,	ynone,	Px, 0xd9, 0xf9 },
    { AEND },
    0
};
@


%-------------------------------------------------------------

<<linkers/8l/optab.c>>=
#include	"l.h"

<<global ynone>>
<<global ytext>>
<<global ynop>>
<<global yxorb>>
<<global yxorl>>
<<global yaddl>>
<<global yincb>>
<<global yincl>>
<<global ycmpb>>
<<global ycmpl>>
<<global yshb>>
<<global yshl>>
<<global ytestb>>
<<global ytestl>>
<<global ymovb>>
<<global ymovl>>
<<global ym_rl>>
<<global yrl_m>>
<<global ymb_rl>>
<<global yml_rl>>
<<global yrl_ml>>
<<global yml_mb>>
<<global yml_ml>>
<<global ydivl>>
<<global ydivb>>
<<global yimul>>
<<global ybyte>>
<<global yin>>
<<global yint>>
<<global ypushl>>
<<global ypopl>>
<<global yscond>>
<<global yjcond>>
<<global yloop>>
<<global ycall>>
<<global yjmp>>

<<global yfmvd>>
<<global yfmvdp>>
<<global yfmvf>>
<<global yfmvx>>
<<global yfmvp>>
<<global yfadd>>
<<global yfaddp>>
<<global yfxch>>
<<global ycompp>>
<<global ystsw>>
<<global ystcw>>
<<global ysvrs>>

<<global optab>>
@

\subsection*{[[linkers/8l/utils.c]]}

<<linkers/8l/utils.c>>=
#include "l.h"

<<function errorexit>>

<<function gethunk>>

<<function lookup>>

<<constructor prg>>

<<function copyp>>


@

\subsection*{[[linkers/8l/list.c]]}

<<function listinit>>=
void
listinit(void)
{

    fmtinstall('R', Rconv);
    fmtinstall('A', Aconv);
    fmtinstall('D', Dconv);
    fmtinstall('S', Sconv);
    fmtinstall('P', Pconv);
}
@

<<global bigP>>=
static	Prog	*bigP;
@

<<function Pconv>>=
int
Pconv(Fmt *fp)
{
    char str[STRINGSZ];
    Prog *p;

    p = va_arg(fp->args, Prog*);
    bigP = p;
    switch(p->as) {
    case ATEXT:
        if(p->from.scale) {
            snprint(str, sizeof(str), "(%ld)	%A	%D,%d,%D",
                p->line, p->as, &p->from, p->from.scale, &p->to);
            break;
        }
    default:
        snprint(str, sizeof(str), "(%ld)	%A	%D,%D",
            p->line, p->as, &p->from, &p->to);
        break;
    case ADATA:
    case AINIT:
    case ADYNT:
        snprint(str, sizeof(str), "(%ld)	%A	%D/%d,%D",
            p->line, p->as, &p->from, p->from.scale, &p->to);
        break;
    }
    bigP = P;
    return fmtstrcpy(fp, str);
}
@

<<function Aconv>>=
int
Aconv(Fmt *fp)
{
    int i;

    i = va_arg(fp->args, int);
    return fmtstrcpy(fp, anames[i]);
}
@

<<function Dconv>>=
int
Dconv(Fmt *fp)
{
    char str[STRINGSZ+40], s[20];
    Adr *a;
    int i;

    a = va_arg(fp->args, Adr*);
    i = a->type;
    if(i >= D_INDIR) {
        if(a->offset)
            snprint(str, sizeof(str), "%ld(%R)", a->offset, i-D_INDIR);
        else
            snprint(str, sizeof(str), "(%R)", i-D_INDIR);
        goto brk;
    }
    switch(i) {

    default:
        snprint(str, sizeof(str), "%R", i);
        break;

    case D_NONE:
        str[0] = 0;
        break;

    case D_BRANCH:
        if(bigP != P && bigP->pcond != P)
            if(a->sym != S)
                snprint(str, sizeof(str), "%lux+%s", bigP->pcond->pc,
                    a->sym->name);
            else
                snprint(str, sizeof(str), "%lux", bigP->pcond->pc);
        else
            snprint(str, sizeof(str), "%ld(PC)", a->offset);
        break;

    case D_EXTERN:
        snprint(str, sizeof(str), "%s+%ld(SB)", a->sym->name, a->offset);
        break;

    case D_STATIC:
        snprint(str, sizeof(str), "%s<%d>+%ld(SB)", a->sym->name,
            a->sym->version, a->offset);
        break;

    case D_AUTO:
        snprint(str, sizeof(str), "%s+%ld(SP)", a->sym->name, a->offset);
        break;

    case D_PARAM:
        if(a->sym)
            snprint(str, sizeof(str), "%s+%ld(FP)", a->sym->name, a->offset);
        else
            snprint(str, sizeof(str), "%ld(FP)", a->offset);
        break;

    case D_CONST:
        snprint(str, sizeof(str), "$%ld", a->offset);
        break;

    case D_FCONST:
        snprint(str, sizeof(str), "$(%.8lux,%.8lux)", a->ieee.h, a->ieee.l);
        break;

    case D_SCONST:
        snprint(str, sizeof(str), "$\"%S\"", a->scon);
        break;

    case D_ADDR:
        a->type = a->index;
        a->index = D_NONE;
        snprint(str, sizeof(str), "$%D", a);
        a->index = a->type;
        a->type = D_ADDR;
        goto conv;
    }
brk:
    if(a->index != D_NONE) {
        snprint(s, sizeof(s), "(%R*%d)", a->index, a->scale);
        strcat(str, s);
    }
conv:
    return fmtstrcpy(fp, str);
}
@

<<global regstr>>=
char*	regstr[] =
{
    "AL",		/* [D_AL] */
    "CL",
    "DL",
    "BL",
    "AH",
    "CH",
    "DH",
    "BH",

    "AX",		/* [D_AX] */
    "CX",
    "DX",
    "BX",
    "SP",
    "BP",
    "SI",
    "DI",

    "F0",		/* [D_F0] */
    "F1",
    "F2",
    "F3",
    "F4",
    "F5",
    "F6",
    "F7",

    "CS",		/* [D_CS] */
    "SS",
    "DS",
    "ES",
    "FS",
    "GS",

    "GDTR",		/* [D_GDTR] */
    "IDTR",		/* [D_IDTR] */
    "LDTR",		/* [D_LDTR] */
    "MSW",		/* [D_MSW] */
    "TASK",		/* [D_TASK] */

    "CR0",		/* [D_CR] */
    "CR1",
    "CR2",
    "CR3",
    "CR4",
    "CR5",
    "CR6",
    "CR7",

    "DR0",		/* [D_DR] */
    "DR1",
    "DR2",
    "DR3",
    "DR4",
    "DR5",
    "DR6",
    "DR7",

    "TR0",		/* [D_TR] */
    "TR1",
    "TR2",
    "TR3",
    "TR4",
    "TR5",
    "TR6",
    "TR7",

    "NONE",		/* [D_NONE] */
};
@

<<function Rconv>>=
int
Rconv(Fmt *fp)
{
    char str[20];
    int r;

    r = va_arg(fp->args, int);
    if(r >= D_AL && r <= D_NONE)
        snprint(str, sizeof(str), "%s", regstr[r-D_AL]);
    else
        snprint(str, sizeof(str), "gok(%d)", r);

    return fmtstrcpy(fp, str);
}
@

<<function Sconv>>=
int
Sconv(Fmt *fp)
{
    int i, c;
    char str[30], *p, *a;

    a = va_arg(fp->args, char*);
    p = str;
    for(i=0; i<sizeof(double); i++) {
        c = a[i] & 0xff;
        if(c >= 'a' && c <= 'z' ||
           c >= 'A' && c <= 'Z' ||
           c >= '0' && c <= '9') {
            *p++ = c;
            continue;
        }
        *p++ = '\\';
        switch(c) {
        default:
            if(c < 040 || c >= 0177)
                break;	/* not portable */
            p[-1] = c;
            continue;
        case 0:
            *p++ = 'z';
            continue;
        case '\\':
        case '"':
            *p++ = c;
            continue;
        case '\n':
            *p++ = 'n';
            continue;
        case '\t':
            *p++ = 't';
            continue;
        }
        *p++ = (c>>6) + '0';
        *p++ = ((c>>3) & 7) + '0';
        *p++ = (c & 7) + '0';
    }
    *p = 0;
    return fmtstrcpy(fp, str);
}
@

<<function diag>>=
void
diag(char *fmt, ...)
{
    char buf[STRINGSZ], *tn;
    va_list arg;

    tn = "??none??";
    if(curtext != P && curtext->from.sym != S)
        tn = curtext->from.sym->name;
    va_start(arg, fmt);
    vseprint(buf, buf+sizeof(buf), fmt, arg);
    va_end(arg);
    print("%s: %s\n", tn, buf);

    nerrors++;
    if(nerrors > 20 && !debug['A']) {
        print("too many errors\n");
        errorexit();
    }
}
@


%-------------------------------------------------------------

<<linkers/8l/list.c>>=
#include	"l.h"

int	Aconv(Fmt*);
int	Dconv(Fmt*);
int	Pconv(Fmt*);
int	Rconv(Fmt*);
int	Sconv(Fmt*);

<<function listinit>>

<<global bigP>>

<<function Pconv>>

<<function Aconv>>

<<function Dconv>>

<<global regstr>>

<<function Rconv>>

<<function Sconv>>

<<function diag>>
@


\subsection*{[[linkers/8l/compat.c]]}


<<function fileexists>>=
int
fileexists(char *s)
{
    uchar dirbuf[400];

    /* it's fine if stat result doesn't fit in dirbuf, since even then the file exists */
    return stat(s, dirbuf, sizeof(dirbuf)) >= 0;
}
@


%-------------------------------------------------------------

<<linkers/8l/compat.c>>=
#include	"l.h"

<<function malloc>>

<<function free>>

<<function setmalloctag>>

<<function fileexists>>
@


\subsection*{[[linkers/8l/pass.c]]}

<<function dodata>>=
void
dodata(void)
{
    int i;
    Sym *s;
    Prog *p;
    long t, u;

    if(debug['v'])
        Bprint(&bso, "%5.2f dodata\n", cputime());
    Bflush(&bso);
    for(p = datap; p != P; p = p->link) {
        s = p->from.sym;
        if(p->as == ADYNT || p->as == AINIT)
            s->value = dtype;
        if(s->type == SBSS)
            s->type = SDATA;
        if(s->type != SDATA)
            diag("initialize non-data (%d): %s\n%P",
                s->type, s->name, p);
        t = p->from.offset + p->width;
        if(t > s->value)
            diag("initialize bounds (%ld): %s\n%P",
                s->value, s->name, p);
    }
    /* allocate small guys */
    datsize = 0;
    for(i=0; i<NHASH; i++)
    for(s = hash[i]; s != S; s = s->link) {
        if(s->type != SDATA)
        if(s->type != SBSS)
            continue;
        t = s->value;
        if(t == 0) {
            diag("%s: no size", s->name);
            t = 1;
        }
        t = rnd(t, 4);;
        s->value = t;
        if(t > MINSIZ)
            continue;
        s->value = datsize;
        datsize += t;
        s->type = SDATA1;
    }

    /* allocate the rest of the data */
    for(i=0; i<NHASH; i++)
    for(s = hash[i]; s != S; s = s->link) {
        if(s->type != SDATA) {
            if(s->type == SDATA1)
                s->type = SDATA;
            continue;
        }
        t = s->value;
        s->value = datsize;
        datsize += t;
    }

    if(debug['j']) {
        /*
         * pad data with bss that fits up to next
         * 8k boundary, then push data to 8k
         */
        u = rnd(datsize, 8192);
        u -= datsize;
        for(i=0; i<NHASH; i++)
        for(s = hash[i]; s != S; s = s->link) {
            if(s->type != SBSS)
                continue;
            t = s->value;
            if(t > u)
                continue;
            u -= t;
            s->value = datsize;
            s->type = SDATA;
            datsize += t;
        }
        datsize += u;
    }

    /* now the bss */
    bsssize = 0;
    for(i=0; i<NHASH; i++)
    for(s = hash[i]; s != S; s = s->link) {
        if(s->type != SBSS)
            continue;
        t = s->value;
        s->value = bsssize + datsize;
        bsssize += t;
    }
    xdefine("bdata", SDATA, 0L);
    xdefine("edata", SBSS, datsize);
    xdefine("end", SBSS, bsssize + datsize);
    /* etext is defined in span.c */
}
@

<<function brchain>>=
Prog*
brchain(Prog *p)
{
    int i;

    for(i=0; i<20; i++) {
        if(p == P || p->as != AJMP)
            return p;
        p = p->pcond;
    }
    return P;
}
@

<<function follow>>=
void
follow(void)
{

    if(debug['v'])
        Bprint(&bso, "%5.2f follow\n", cputime());
    Bflush(&bso);
    firstp = prg();
    lastp = firstp;
    xfol(textp);
    lastp->link = P;
    firstp = firstp->link;
}
@

<<function xfol>>=
void
xfol(Prog *p)
{
    Prog *q;
    int i;
    enum as a;

loop:
    if(p == P)
        return;
    if(p->as == ATEXT)
        curtext = p;
    if(p->as == AJMP)
    if((q = p->pcond) != P) {
        p->mark = 1;
        p = q;
        if(p->mark == 0)
            goto loop;
    }
    if(p->mark) {
        /* copy up to 4 instructions to avoid branch */
        for(i=0,q=p; i<4; i++,q=q->link) {
            if(q == P)
                break;
            if(q == lastp)
                break;
            a = q->as;
            if(a == ANOP) {
                i--;
                continue;
            }
            switch(a) {
            case AJMP:
            case ARET:
            case AIRETL:

            case APUSHL:
            case APUSHFL:
            case APUSHW:
            case APUSHFW:
            case APOPL:
            case APOPFL:
            case APOPW:
            case APOPFW:
                goto brk;
            }
            if(q->pcond == P || q->pcond->mark)
                continue;
            if(a == ACALL || a == ALOOP)
                continue;
            for(;;) {
                if(p->as == ANOP) {
                    p = p->link;
                    continue;
                }
                q = copyp(p);
                p = p->link;
                q->mark = 1;
                lastp->link = q;
                lastp = q;
                if(q->as != a || q->pcond == P || q->pcond->mark)
                    continue;

                q->as = relinv(q->as);
                p = q->pcond;
                q->pcond = q->link;
                q->link = p;
                xfol(q->link);
                p = q->link;
                if(p->mark)
                    return;
                goto loop;
            }
        } /* */
    brk:;
        q = prg();
        q->as = AJMP;
        q->line = p->line;
        q->to.type = D_BRANCH;
        q->to.offset = p->pc;
        q->pcond = p;
        p = q;
    }
    p->mark = 1;
    lastp->link = p;
    lastp = p;
    a = p->as;
    if(a == AJMP || a == ARET || a == AIRETL)
        return;
    if(p->pcond != P)
    if(a != ACALL) {
        q = brchain(p->link);
        if(q != P && q->mark)
        if(a != ALOOP) {
            p->as = relinv(a);
            p->link = p->pcond;
            p->pcond = q;
        }
        xfol(p->link);
        q = brchain(p->pcond);
        if(q->mark) {
            p->pcond = q;
            return;
        }
        p = q;
        goto loop;
    }
    p = p->link;
    goto loop;
}
@

<<function relinv>>=
int
relinv(int a)
{

    switch(a) {
    case AJEQ:	return AJNE;
    case AJNE:	return AJEQ;
    case AJLE:	return AJGT;
    case AJLS:	return AJHI;
    case AJLT:	return AJGE;
    case AJMI:	return AJPL;
    case AJGE:	return AJLT;
    case AJPL:	return AJMI;
    case AJGT:	return AJLE;
    case AJHI:	return AJLS;
    case AJCS:	return AJCC;
    case AJCC:	return AJCS;
    case AJPS:	return AJPC;
    case AJPC:	return AJPS;
    case AJOS:	return AJOC;
    case AJOC:	return AJOS;
    }
    diag("unknown relation: %s in %s", anames[a], TNAME);
    return a;
}
@

<<function doinit>>=
void
doinit(void)
{
    Sym *s;
    Prog *p;
    int x;

    for(p = datap; p != P; p = p->link) {
        x = p->to.type;
        if(x != D_EXTERN && x != D_STATIC)
            continue;
        s = p->to.sym;
        if(s->type == 0 || s->type == SXREF)
            diag("undefined %s initializer of %s",
                s->name, p->from.sym->name);
        p->to.offset += s->value;
        p->to.type = D_CONST;
        if(s->type == SDATA || s->type == SBSS)
            p->to.offset += INITDAT;
    }
}
@

<<function patch>>=
void
patch(void)
{
    long c;
    Prog *p, *q;
    Sym *s;
    long vexit;

    if(debug['v'])
        Bprint(&bso, "%5.2f mkfwd\n", cputime());
    Bflush(&bso);
    mkfwd();
    if(debug['v'])
        Bprint(&bso, "%5.2f patch\n", cputime());
    Bflush(&bso);
    s = lookup("exit", 0);
    vexit = s->value;
    for(p = firstp; p != P; p = p->link) {
        if(p->as == ATEXT)
            curtext = p;
        if(p->as == ACALL || p->as == ARET) {
            s = p->to.sym;
            if(s) {
                if(debug['c'])
                    Bprint(&bso, "%s calls %s\n", TNAME, s->name);
                switch(s->type) {
                default:
                    /* diag prints TNAME first */
                    diag("undefined: %s", s->name);
                    s->type = STEXT;
                    s->value = vexit;
                    break;	/* or fall through to set offset? */
                case STEXT:
                    p->to.offset = s->value;
                    break;
                case SUNDEF:
                    p->pcond = UP;
                    p->to.offset = 0;
                    break;
                }
                p->to.type = D_BRANCH;
            }
        }
        if(p->to.type != D_BRANCH || p->pcond == UP)
            continue;
        c = p->to.offset;
        for(q = firstp; q != P;) {
            if(q->forwd != P)
            if(c >= q->forwd->pc) {
                q = q->forwd;
                continue;
            }
            if(c == q->pc)
                break;
            q = q->link;
        }
        if(q == P) {
            diag("branch out of range in %s\n%P", TNAME, p);
            p->to.type = D_NONE;
        }
        p->pcond = q;
    }

    for(p = firstp; p != P; p = p->link) {
        if(p->as == ATEXT)
            curtext = p;
        p->mark = 0;	/* initialization for follow */
        if(p->pcond != P && p->pcond != UP) {
            p->pcond = brloop(p->pcond);
            if(p->pcond != P)
            if(p->to.type == D_BRANCH)
                p->to.offset = p->pcond->pc;
        }
    }
}
@

<<constant LOG>>=
#define	LOG	5
@

<<function mkfwd>>=
void
mkfwd(void)
{
    Prog *p;
    int i;
    long dwn[LOG], cnt[LOG];
    Prog *lst[LOG];

    for(i=0; i<LOG; i++) {
        if(i == 0)
            cnt[i] = 1; else
            cnt[i] = LOG * cnt[i-1];
        dwn[i] = 1;
        lst[i] = P;
    }
    i = 0;
    for(p = firstp; p != P; p = p->link) {
        if(p->as == ATEXT)
            curtext = p;
        i--;
        if(i < 0)
            i = LOG-1;
        p->forwd = P;
        dwn[i]--;
        if(dwn[i] <= 0) {
            dwn[i] = cnt[i];
            if(lst[i] != P)
                lst[i]->forwd = p;
            lst[i] = p;
        }
    }
}
@

<<function brloop>>=
Prog*
brloop(Prog *p)
{
    int c;
    Prog *q;

    c = 0;
    for(q = p; q != P; q = q->pcond) {
        if(q->as != AJMP)
            break;
        c++;
        if(c >= 5000)
            return P;
    }
    return q;
}
@

<<function dostkoff>>=
void
dostkoff(void)
{
    Prog *p, *q;
    long autoffset, deltasp;
    int a, f, curframe, curbecome, maxbecome;

    curframe = 0;
    curbecome = 0;
    maxbecome = 0;
    curtext = 0;
    for(p = firstp; p != P; p = p->link) {

        /* find out how much arg space is used in this TEXT */
        if(p->to.type == (D_INDIR+D_SP))
            if(p->to.offset > curframe)
                curframe = p->to.offset;

        switch(p->as) {
        case ATEXT:
            if(curtext && curtext->from.sym) {
                curtext->from.sym->frame = curframe;
                curtext->from.sym->become = curbecome;
                if(curbecome > maxbecome)
                    maxbecome = curbecome;
            }
            curframe = 0;
            curbecome = 0;

            curtext = p;
            break;

        case ARET:
            /* special form of RET is BECOME */
            if(p->from.type == D_CONST)
                if(p->from.offset > curbecome)
                    curbecome = p->from.offset;
            break;
        }
    }
    if(curtext && curtext->from.sym) {
        curtext->from.sym->frame = curframe;
        curtext->from.sym->become = curbecome;
        if(curbecome > maxbecome)
            maxbecome = curbecome;
    }

    if(debug['b'])
        print("max become = %d\n", maxbecome);
    xdefine("ALEFbecome", STEXT, maxbecome);

    curtext = 0;
    for(p = firstp; p != P; p = p->link) {
        switch(p->as) {
        case ATEXT:
            curtext = p;
            break;
        case ACALL:
            if(curtext != P && curtext->from.sym != S && curtext->to.offset >= 0) {
                f = maxbecome - curtext->from.sym->frame;
                if(f <= 0)
                    break;
                /* calling a become or calling a variable */
                if(p->to.sym == S || p->to.sym->become) {
                    curtext->to.offset += f;
                    if(debug['b']) {
                        curp = p;
                        print("%D calling %D increase %d\n",
                            &curtext->from, &p->to, f);
                    }
                }
            }
            break;
        }
    }

    autoffset = 0;
    deltasp = 0;
    for(p = firstp; p != P; p = p->link) {
        if(p->as == ATEXT) {
            curtext = p;
            autoffset = p->to.offset;
            if(autoffset < 0)
                autoffset = 0;
            if(autoffset) {
                p = appendp(p);
                p->as = AADJSP;
                p->from.type = D_CONST;
                p->from.offset = autoffset;
            }
            deltasp = autoffset;
        }
        a = p->from.type;
        if(a == D_AUTO)
            p->from.offset += deltasp;
        if(a == D_PARAM)
            p->from.offset += deltasp + 4;
        a = p->to.type;
        if(a == D_AUTO)
            p->to.offset += deltasp;
        if(a == D_PARAM)
            p->to.offset += deltasp + 4;

        switch(p->as) {
        default:
            continue;
        case APUSHL:
        case APUSHFL:
            deltasp += 4;
            continue;
        case APUSHW:
        case APUSHFW:
            deltasp += 2;
            continue;
        case APOPL:
        case APOPFL:
            deltasp -= 4;
            continue;
        case APOPW:
        case APOPFW:
            deltasp -= 2;
            continue;
        case ARET:
            break;
        }

        if(autoffset != deltasp)
            diag("unbalanced PUSH/POP");
        if(p->from.type == D_CONST)
            goto become;

        if(autoffset) {
            q = p;
            p = appendp(p);
            p->as = ARET;

            q->as = AADJSP;
            q->from.type = D_CONST;
            q->from.offset = -autoffset;
        }
        continue;

    become:
        q = p;
        p = appendp(p);
        p->as = AJMP;
        p->to = q->to;
        p->pcond = q->pcond;

        q->as = AADJSP;
        q->from = zprg.from;
        q->from.type = D_CONST;
        q->from.offset = -autoffset;
        q->to = zprg.to;
        continue;
    }
}
@

<<function atolwhex>>=
long
atolwhex(char *s)
{
    long n;
    int f;

    n = 0;
    f = 0;
    while(*s == ' ' || *s == '\t')
        s++;
    if(*s == '-' || *s == '+') {
        if(*s++ == '-')
            f = 1;
        while(*s == ' ' || *s == '\t')
            s++;
    }
    if(s[0]=='0' && s[1]){
        if(s[1]=='x' || s[1]=='X'){
            s += 2;
            for(;;){
                if(*s >= '0' && *s <= '9')
                    n = n*16 + *s++ - '0';
                else if(*s >= 'a' && *s <= 'f')
                    n = n*16 + *s++ - 'a' + 10;
                else if(*s >= 'A' && *s <= 'F')
                    n = n*16 + *s++ - 'A' + 10;
                else
                    break;
            }
        } else
            while(*s >= '0' && *s <= '7')
                n = n*8 + *s++ - '0';
    } else
        while(*s >= '0' && *s <= '9')
            n = n*10 + *s++ - '0';
    if(f)
        n = -n;
    return n;
}
@

<<function undef>>=
void
undef(void)
{
    int i;
    Sym *s;

    for(i=0; i<NHASH; i++)
    for(s = hash[i]; s != S; s = s->link)
        if(s->type == SXREF)
            diag("%s: not defined", s->name);
}
@

<<function import>>=
void
import(void)
{
    int i;
    Sym *s;

    for(i = 0; i < NHASH; i++)
        for(s = hash[i]; s != S; s = s->link)
            if(s->sig != 0 && s->type == SXREF && (nimports == 0 || s->subtype == SIMPORT)){
                if(s->value != 0)
                    diag("value != 0 on SXREF");
                undefsym(s);
                if(debug['X'])
                    Bprint(&bso, "IMPORT: %s sig=%lux v=%ld\n", s->name, s->sig, s->value);
                if(debug['S'])
                    s->sig = 0;
            }
}
@

<<function ckoff>>=
void
ckoff(Sym *s, long v)
{
    if(v < 0 || v >= 1<<Roffset)
        diag("relocation offset %ld for %s out of range", v, s->name);
}
@

% >>

<<function newdata>>=
static Prog*
newdata(Sym *s, int o, int w, int t)
{
    Prog *p;

    p = prg();
    if(edatap == P)
        datap = p;
    else
        edatap->link = p;
    edatap = p;
    p->as = ADATA;
    p->width = w;
    p->from.scale = w;
    p->from.type = t;
    p->from.sym = s;
    p->from.offset = o;
    p->to.type = D_CONST;
    return p;
}
@

<<function export>>=
void
export(void)
{
    int i, j, n, off, nb, sv, ne;
    Sym *s, *et, *str, **esyms;
    Prog *p;
    char buf[NSNAME], *t;

    n = 0;
    for(i = 0; i < NHASH; i++)
        for(s = hash[i]; s != S; s = s->link)
            if(s->type != SXREF && s->type != SUNDEF && (nexports == 0 && s->sig != 0 || s->subtype == SEXPORT || allexport))
                n++;
    esyms = malloc(n*sizeof(Sym*));
    ne = n;
    n = 0;
    for(i = 0; i < NHASH; i++)
        for(s = hash[i]; s != S; s = s->link)
            if(s->type != SXREF && s->type != SUNDEF && (nexports == 0 && s->sig != 0 || s->subtype == SEXPORT || allexport))
                esyms[n++] = s;
    for(i = 0; i < ne-1; i++)
        for(j = i+1; j < ne; j++)
            if(strcmp(esyms[i]->name, esyms[j]->name) > 0){
                s = esyms[i];
                esyms[i] = esyms[j];
                esyms[j] = s;
            }

    nb = 0;
    off = 0;
    et = lookup(EXPTAB, 0);
    if(et->type != 0 && et->type != SXREF)
        diag("%s already defined", EXPTAB);
    et->type = SDATA;
    str = lookup(".string", 0);
    if(str->type == 0)
        str->type = SDATA;
    sv = str->value;
    for(i = 0; i < ne; i++){
        s = esyms[i];
        if(debug['S'])
            s->sig = 0;
        /* Bprint(&bso, "EXPORT: %s sig=%lux t=%d\n", s->name, s->sig, s->type); */

        /* signature */
        p = newdata(et, off, sizeof(long), D_EXTERN);
        off += sizeof(long);
        p->to.offset = s->sig;

        /* address */
        p = newdata(et, off, sizeof(long), D_EXTERN);
        off += sizeof(long);
        p->to.type = D_ADDR;
        p->to.index = D_EXTERN;
        p->to.sym = s;

        /* string */
        t = s->name;
        n = strlen(t)+1;
        for(;;){
            buf[nb++] = *t;
            sv++;
            if(nb >= NSNAME){
                p = newdata(str, sv-NSNAME, NSNAME, D_STATIC);
                p->to.type = D_SCONST;
                memmove(p->to.scon, buf, NSNAME);
                nb = 0;
            }
            if(*t++ == 0)
                break;
        }

        /* name */
        p = newdata(et, off, sizeof(long), D_EXTERN);
        off += sizeof(long);
        p->to.type = D_ADDR;
        p->to.index = D_STATIC;
        p->to.sym = str;
        p->to.offset = sv-n;
    }

    if(nb > 0){
        p = newdata(str, sv-nb, nb, D_STATIC);
        p->to.type = D_SCONST;
        memmove(p->to.scon, buf, nb);
    }

    for(i = 0; i < 3; i++){
        newdata(et, off, sizeof(long), D_EXTERN);
        off += sizeof(long);
    }
    et->value = off;
    if(sv == 0)
        sv = 1;
    str->value = sv;
    exports = ne;
    free(esyms);
}
@


%-------------------------------------------------------------

<<linkers/8l/pass.c>>=
#include	"l.h"

void	xfol(Prog*);
int	relinv(int);
void	mkfwd(void);
Prog*	brloop(Prog*);

<<function dodata>>

<<function brchain>>

<<function follow>>

<<function xfol>>

<<function relinv>>

<<function doinit>>

<<function patch>>

<<constant LOG>>
<<function mkfwd>>

<<function brloop>>

<<function dostkoff>>

<<function atolwhex>>

<<function undef>>

<<function import>>

<<function ckoff>>

<<function newdata>>

<<function export>>
@


\subsection*{[[linkers/8l/asm.c]]}

<<constant Dbufslop>>=
#define	Dbufslop	100
@

<<function entryvalue>>=
long
entryvalue(void)
{
    char *a;
    Sym *s;

    a = INITENTRY;
    if(*a >= '0' && *a <= '9')
        return atolwhex(a);
    s = lookup(a, 0);
    if(s->type == 0)
        return INITTEXT;
    switch(s->type) {
    case STEXT:
        break;
    case SDATA:
        if(dlm)
            return s->value+INITDAT;
    default:
        diag("entry not text: %s", s->name);
    }
    return s->value;
}
@

<<function wputl>>=
/* these need to take long arguments to be compatible with elf.c */
void
wputl(long w)
{
    cput(w);
    cput(w>>8);
}
@

<<function wput>>=
void
wput(long w)
{
    cput(w>>8);
    cput(w);
}
@

<<function lput>>=
void
lput(long l)
{
    cput(l>>24);
    cput(l>>16);
    cput(l>>8);
    cput(l);
}
@

<<function lputl>>=
void
lputl(long l)
{
    cput(l);
    cput(l>>8);
    cput(l>>16);
    cput(l>>24);
}
@

<<function llput>>=
void
llput(vlong v)
{
    lput(v>>32);
    lput(v);
}
@

<<function llputl>>=
void
llputl(vlong v)
{
    lputl(v);
    lputl(v>>32);
}
@

<<function strnput>>=
void
strnput(char *s, int n)
{
    for(; *s && n > 0; s++){
        cput(*s);
        n--;
    }
    while(n > 0){
        cput(0);
        n--;
    }
}
@

<<function asmb>>=
void
asmb(void)
{
    Prog *p;
    long v, magic;
    int a;
    uchar *op1;

    if(debug['v'])
        Bprint(&bso, "%5.2f asmb\n", cputime());
    Bflush(&bso);

    seek(cout, HEADR, 0);
    pc = INITTEXT;
    curp = firstp;
    for(p = firstp; p != P; p = p->link) {
        if(p->as == ATEXT)
            curtext = p;
        if(p->pc != pc) {
            if(!debug['a'])
                print("%P\n", curp);
            diag("phase error %lux sb %lux in %s", p->pc, pc, TNAME);
            pc = p->pc;
        }
        curp = p;
        asmins(p);
        if(cbc < sizeof(and))
            cflush();
        a = (andptr - and);
        if(debug['a']) {
            Bprint(&bso, pcstr, pc);
            for(op1 = and; op1 < andptr; op1++)
                Bprint(&bso, "%.2ux", *op1 & 0xff);
            Bprint(&bso, "\t%P\n", curp);
        }
        if(dlm) {
            if(p->as == ATEXT)
                reloca = nil;
            else if(reloca != nil)
                diag("reloc failure: %P", curp);
        }
        memmove(cbp, and, a);
        cbp += a;
        pc += a;
        cbc -= a;
    }
    cflush();
    switch(HEADTYPE) {
    default:
        diag("unknown header type %ld", HEADTYPE);
    case 0:
        seek(cout, rnd(HEADR+textsize, 8192), 0);
        break;
    case 1:
        textsize = rnd(HEADR+textsize, 4096)-HEADR;
        seek(cout, textsize+HEADR, 0);
        break;
    case 2:
    case 5:
        seek(cout, HEADR+textsize, 0);
        break;
    case 3:
    case 4:
        seek(cout, HEADR+rnd(textsize, INITRND), 0);
        break;
    }

    if(debug['v'])
        Bprint(&bso, "%5.2f datblk\n", cputime());
    Bflush(&bso);

    if(dlm){
        char buf[8];

        write(cout, buf, INITDAT-textsize);
        textsize = INITDAT;
    }

    for(v = 0; v < datsize; v += sizeof(buf)-Dbufslop) {
        if(datsize-v > sizeof(buf)-Dbufslop)
            datblk(v, sizeof(buf)-Dbufslop);
        else
            datblk(v, datsize-v);
    }

    symsize = 0;
    spsize = 0;
    lcsize = 0;
    if(!debug['s']) {
        if(debug['v'])
            Bprint(&bso, "%5.2f sym\n", cputime());
        Bflush(&bso);
        switch(HEADTYPE) {
        default:
        case 0:
            seek(cout, rnd(HEADR+textsize, 8192)+datsize, 0);
            break;
        case 1:
            seek(cout, rnd(HEADR+textsize, INITRND)+datsize, 0);
            break;
        case 2:
        case 5:
            seek(cout, HEADR+textsize+datsize, 0);
            break;
        case 3:
        case 4:
            debug['s'] = 1;
            break;
        }
        if(!debug['s'])
            asmsym();
        if(debug['v'])
            Bprint(&bso, "%5.2f sp\n", cputime());
        Bflush(&bso);
        if(debug['v'])
            Bprint(&bso, "%5.2f pc\n", cputime());
        Bflush(&bso);
        if(!debug['s'])
            asmlc();
        if(dlm)
            asmdyn();
        cflush();
    }
    else if(dlm){
        seek(cout, HEADR+textsize+datsize, 0);
        asmdyn();
        cflush();
    }
    if(debug['v'])
        Bprint(&bso, "%5.2f headr\n", cputime());
    Bflush(&bso);
    seek(cout, 0L, 0);
    switch(HEADTYPE) {
    default:
    case 0:	/* garbage */
        lput(0x160L<<16);		/* magic and sections */
        lput(0L);			/* time and date */
        lput(rnd(HEADR+textsize, 4096)+datsize);
        lput(symsize);			/* nsyms */
        lput((0x38L<<16)|7L);		/* size of optional hdr and flags */
        lput((0413<<16)|0437L);		/* magic and version */
        lput(rnd(HEADR+textsize, 4096));/* sizes */
        lput(datsize);
        lput(bsssize);
        lput(entryvalue());		/* va of entry */
        lput(INITTEXT-HEADR);		/* va of base of text */
        lput(INITDAT);			/* va of base of data */
        lput(INITDAT+datsize);		/* va of base of bss */
        lput(~0L);			/* gp reg mask */
        lput(0L);
        lput(0L);
        lput(0L);
        lput(0L);
        lput(~0L);			/* gp value ?? */
        break;
    case 1:	/* unix coff */
        /*
         * file header
         */
        lputl(0x0004014c);		/* 4 sections, magic */
        lputl(0);			/* unix time stamp */
        lputl(0);			/* symbol table */
        lputl(0);			/* nsyms */
        lputl(0x0003001c);		/* flags, sizeof a.out header */
        /*
         * a.out header
         */
        lputl(0x10b);			/* magic, version stamp */
        lputl(rnd(textsize, INITRND));	/* text sizes */
        lputl(datsize);			/* data sizes */
        lputl(bsssize);			/* bss sizes */
        lput(entryvalue());		/* va of entry */
        lputl(INITTEXT);		/* text start */
        lputl(INITDAT);			/* data start */
        /*
         * text section header
         */
        strnput(".text", 8);
        lputl(HEADR);			/* pa */
        lputl(HEADR);			/* va */
        lputl(textsize);		/* text size */
        lputl(HEADR);			/* file offset */
        lputl(0);			/* relocation */
        lputl(0);			/* line numbers */
        lputl(0);			/* relocation, line numbers */
        lputl(0x20);			/* flags text only */
        /*
         * data section header
         */
        strnput(".data", 8);
        lputl(INITDAT);			/* pa */
        lputl(INITDAT);			/* va */
        lputl(datsize);			/* data size */
        lputl(HEADR+textsize);		/* file offset */
        lputl(0);			/* relocation */
        lputl(0);			/* line numbers */
        lputl(0);			/* relocation, line numbers */
        lputl(0x40);			/* flags data only */
        /*
         * bss section header
         */
        strnput(".bss", 8);
        lputl(INITDAT+datsize);		/* pa */
        lputl(INITDAT+datsize);		/* va */
        lputl(bsssize);			/* bss size */
        lputl(0);			/* file offset */
        lputl(0);			/* relocation */
        lputl(0);			/* line numbers */
        lputl(0);			/* relocation, line numbers */
        lputl(0x80);			/* flags bss only */
        /*
         * comment section header
         */
        strnput(".comment", 8);
        lputl(0);			/* pa */
        lputl(0);			/* va */
        lputl(symsize+lcsize);		/* comment size */
        lputl(HEADR+textsize+datsize);	/* file offset */
        lputl(HEADR+textsize+datsize);	/* offset of syms */
        lputl(HEADR+textsize+datsize+symsize);/* offset of line numbers */
        lputl(0);			/* relocation, line numbers */
        lputl(0x200);			/* flags comment only */
        break;
    case 2:	/* plan9 */
        magic = 4*11*11+7;
        if(dlm)
            magic |= 0x80000000;
        lput(magic);			/* magic */
        lput(textsize);			/* sizes */
        lput(datsize);
        lput(bsssize);
        lput(symsize);			/* nsyms */
        lput(entryvalue());		/* va of entry */
        lput(spsize);			/* sp offsets */
        lput(lcsize);			/* line offsets */
        break;
    case 3:
        /* MS-DOS .COM */
        break;
    case 4:
        /* fake MS-DOS .EXE */
        v = rnd(HEADR+textsize, INITRND)+datsize;
        wputl(0x5A4D);			/* 'MZ' */
        wputl(v % 512);			/* bytes in last page */
        wputl(rnd(v, 512)/512);		/* total number of pages */
        wputl(0x0000);			/* number of reloc items */
        v = rnd(HEADR-(INITTEXT & 0xFFFF), 16);
        wputl(v/16);			/* size of header */
        wputl(0x0000);			/* minimum allocation */
        wputl(0xFFFF);			/* maximum allocation */
        wputl(0x0000);			/* initial ss value */
        wputl(0x0100);			/* initial sp value */
        wputl(0x0000);			/* complemented checksum */
        v = entryvalue();
        wputl(v);			/* initial ip value (!) */
        wputl(0x0000);			/* initial cs value */
        wputl(0x0000);
        wputl(0x0000);
        wputl(0x003E);			/* reloc table offset */
        wputl(0x0000);			/* overlay number */
        break;
    case 5:
        elf32(I386, ELFDATA2LSB, 0, nil);
        break;
    }
    cflush();
}
@

<<function cflush>>=
void
cflush(void)
{
    int n;

    n = sizeof(buf.cbuf) - cbc;
    if(n)
        write(cout, buf.cbuf, n);
    cbp = buf.cbuf;
    cbc = sizeof(buf.cbuf);
}
@

<<function datblk>>=
void
datblk(long s, long n)
{
    Prog *p;
    char *cast;
    long l, fl, j;
    int i, c;

    memset(buf.dbuf, 0, n+Dbufslop);
    for(p = datap; p != P; p = p->link) {
        curp = p;
        l = p->from.sym->value + p->from.offset - s;
        c = p->from.scale;
        i = 0;
        if(l < 0) {
            if(l+c <= 0)
                continue;
            while(l < 0) {
                l++;
                i++;
            }
        }
        if(l >= n)
            continue;
        if(p->as != AINIT && p->as != ADYNT) {
            for(j=l+(c-i)-1; j>=l; j--)
                if(buf.dbuf[j]) {
                    print("%P\n", p);
                    diag("multiple initialization");
                    break;
                }
        }
        switch(p->to.type) {
        case D_FCONST:
            switch(c) {
            default:
            case 4:
                fl = ieeedtof(&p->to.ieee);
                cast = (char*)&fl;
                if(debug['a'] && i == 0) {
                    Bprint(&bso, pcstr, l+s+INITDAT);
                    for(j=0; j<c; j++)
                        Bprint(&bso, "%.2ux", cast[fnuxi4[j]] & 0xff);
                    Bprint(&bso, "\t%P\n", curp);
                }
                for(; i<c; i++) {
                    buf.dbuf[l] = cast[fnuxi4[i]];
                    l++;
                }
                break;
            case 8:
                cast = (char*)&p->to.ieee;
                if(debug['a'] && i == 0) {
                    Bprint(&bso, pcstr, l+s+INITDAT);
                    for(j=0; j<c; j++)
                        Bprint(&bso, "%.2ux", cast[fnuxi8[j]] & 0xff);
                    Bprint(&bso, "\t%P\n", curp);
                }
                for(; i<c; i++) {
                    buf.dbuf[l] = cast[fnuxi8[i]];
                    l++;
                }
                break;
            }
            break;

        case D_SCONST:
            if(debug['a'] && i == 0) {
                Bprint(&bso, pcstr, l+s+INITDAT);
                for(j=0; j<c; j++)
                    Bprint(&bso, "%.2ux", p->to.scon[j] & 0xff);
                Bprint(&bso, "\t%P\n", curp);
            }
            for(; i<c; i++) {
                buf.dbuf[l] = p->to.scon[i];
                l++;
            }
            break;
        default:
            fl = p->to.offset;
            if(p->to.type == D_ADDR) {
                if(p->to.index != D_STATIC && p->to.index != D_EXTERN)
                    diag("DADDR type%P", p);
                if(p->to.sym) {
                    if(p->to.sym->type == SUNDEF)
                        ckoff(p->to.sym, fl);
                    fl += p->to.sym->value;
                    if(p->to.sym->type != STEXT && p->to.sym->type != SUNDEF)
                        fl += INITDAT;
                    if(dlm)
                        dynreloc(p->to.sym, l+s+INITDAT, 1);
                }
            }
            cast = (char*)&fl;
            switch(c) {
            default:
                diag("bad nuxi %d %d\n%P", c, i, curp);
                break;
            case 1:
                if(debug['a'] && i == 0) {
                    Bprint(&bso, pcstr, l+s+INITDAT);
                    for(j=0; j<c; j++)
                        Bprint(&bso, "%.2ux", cast[inuxi1[j]] & 0xff);
                    Bprint(&bso, "\t%P\n", curp);
                }
                for(; i<c; i++) {
                    buf.dbuf[l] = cast[inuxi1[i]];
                    l++;
                }
                break;
            case 2:
                if(debug['a'] && i == 0) {
                    Bprint(&bso, pcstr, l+s+INITDAT);
                    for(j=0; j<c; j++)
                        Bprint(&bso, "%.2ux", cast[inuxi2[j]] & 0xff);
                    Bprint(&bso, "\t%P\n", curp);
                }
                for(; i<c; i++) {
                    buf.dbuf[l] = cast[inuxi2[i]];
                    l++;
                }
                break;
            case 4:
                if(debug['a'] && i == 0) {
                    Bprint(&bso, pcstr, l+s+INITDAT);
                    for(j=0; j<c; j++)
                        Bprint(&bso, "%.2ux", cast[inuxi4[j]] & 0xff);
                    Bprint(&bso, "\t%P\n", curp);
                }
                for(; i<c; i++) {
                    buf.dbuf[l] = cast[inuxi4[i]];
                    l++;
                }
                break;
            }
            break;
        }
    }
    write(cout, buf.dbuf, n);
}
@

<<function rnd>>=
long
rnd(long v, long r)
{
    long c;

    if(r <= 0)
        return v;
    v += r - 1;
    c = v % r;
    if(c < 0)
        c += r;
    v -= c;
    return v;
}
@


%-------------------------------------------------------------

<<linkers/8l/asm.c>>=
#include	"l.h"

<<constant Dbufslop>>

<<global spsize>>

void	datblk(long, long);

<<function entryvalue>>

<<function wputl>>

<<function wput>>

<<function lput>>

<<function lputl>>

<<function llput>>

<<function llputl>>

<<function strnput>>

<<function asmb>>

<<function cflush>>

<<function datblk>>

<<function rnd>>
@


\subsection*{[[linkers/8l/span.c]]}

<<function span>>=
void
span(void)
{
    Prog *p, *q;
    long v, c, idat;
    int m, n, again;

    xdefine("etext", STEXT, 0L);
    idat = INITDAT;
    for(p = firstp; p != P; p = p->link) {
        if(p->as == ATEXT)
            curtext = p;
        n = 0;
        if(p->to.type == D_BRANCH)
            if(p->pcond == P)
                p->pcond = p;
        if((q = p->pcond) != P)
            if(q->back != 2)
                n = 1;
        p->back = n;
        if(p->as == AADJSP) {
            p->to.type = D_SP;
            v = -p->from.offset;
            p->from.offset = v;
            p->as = AADDL;
            if(v < 0) {
                p->as = ASUBL;
                v = -v;
                p->from.offset = v;
            }
            if(v == 0)
                p->as = ANOP;
        }
    }
    n = 0;

start:
    if(debug['v'])
        Bprint(&bso, "%5.2f span\n", cputime());
    Bflush(&bso);
    c = INITTEXT;
    for(p = firstp; p != P; p = p->link) {
        if(p->as == ATEXT)
            curtext = p;
        if(p->to.type == D_BRANCH)
            if(p->back)
                p->pc = c;
        asmins(p);
        p->pc = c;
        m = andptr-and;
        p->mark = m;
        c += m;
    }

loop:
    n++;
    if(debug['v'])
        Bprint(&bso, "%5.2f span %d\n", cputime(), n);
    Bflush(&bso);
    if(n > 50) {
        print("span must be looping\n");
        errorexit();
    }
    again = 0;
    c = INITTEXT;
    for(p = firstp; p != P; p = p->link) {
        if(p->as == ATEXT)
            curtext = p;
        if(p->to.type == D_BRANCH) {
            if(p->back)
                p->pc = c;
            asmins(p);
            m = andptr-and;
            if(m != p->mark) {
                p->mark = m;
                again++;
            }
        }
        p->pc = c;
        c += p->mark;
    }
    if(again) {
        textsize = c;
        goto loop;
    }
    if(INITRND) {
        INITDAT = rnd(c, INITRND);
        if(INITDAT != idat) {
            idat = INITDAT;
            goto start;
        }
    }
    xdefine("etext", STEXT, c);
    if(debug['v'])
        Bprint(&bso, "etext = %lux\n", c);
    Bflush(&bso);
    for(p = textp; p != P; p = p->pcond)
        p->from.sym->value = p->pc;
    textsize = c - INITTEXT;
}
@

<<function xdefine>>=
void
xdefine(char *p, int t, long v)
{
    Sym *s;

    s = lookup(p, 0);
    if(s->type == 0 || s->type == SXREF) {
        s->type = t;
        s->value = v;
    }
    if(s->type == STEXT && s->value == 0)
        s->value = v;
}
@

<<function putsymb>>=
void
putsymb(char *s, int t, long v, int ver)
{
    int i, f;

    if(t == 'f')
        s++;
    lput(v);
    if(ver)
        t += 'a' - 'A';
    cput(t+0x80);			/* 0x80 is variable length */

    if(t == 'Z' || t == 'z') {
        cput(s[0]);
        for(i=1; s[i] != 0 || s[i+1] != 0; i += 2) {
            cput(s[i]);
            cput(s[i+1]);
        }
        cput(0);
        cput(0);
        i++;
    }
    else {
        for(i=0; s[i]; i++)
            cput(s[i]);
        cput(0);
    }
    symsize += 4 + 1 + i + 1;

    if(debug['n']) {
        if(t == 'z' || t == 'Z') {
            Bprint(&bso, "%c %.8lux ", t, v);
            for(i=1; s[i] != 0 || s[i+1] != 0; i+=2) {
                f = ((s[i]&0xff) << 8) | (s[i+1]&0xff);
                Bprint(&bso, "/%x", f);
            }
            Bprint(&bso, "\n");
            return;
        }
        if(ver)
            Bprint(&bso, "%c %.8lux %s<%d>\n", t, v, s, ver);
        else
            Bprint(&bso, "%c %.8lux %s\n", t, v, s);
    }
}
@
%>>

<<function asmsym>>=
void
asmsym(void)
{
    Prog *p;
    Auto *a;
    Sym *s;
    int h;

    s = lookup("etext", 0);
    if(s->type == STEXT)
        putsymb(s->name, 'T', s->value, s->version);

    for(h=0; h<NHASH; h++)
        for(s=hash[h]; s!=S; s=s->link)
            switch(s->type) {
            case SCONST:
                putsymb(s->name, 'D', s->value, s->version);
                continue;

            case SDATA:
                putsymb(s->name, 'D', s->value+INITDAT, s->version);
                continue;

            case SBSS:
                putsymb(s->name, 'B', s->value+INITDAT, s->version);
                continue;

            case SFILE:
                putsymb(s->name, 'f', s->value, s->version);
                continue;
            }

    for(p=textp; p!=P; p=p->pcond) {
        s = p->from.sym;
        if(s->type != STEXT)
            continue;

        /* filenames first */
        for(a=p->to.autom; a; a=a->link)
            if(a->type == D_FILE)
                putsymb(a->asym->name, 'z', a->aoffset, 0);
            else
            if(a->type == D_FILE1)
                putsymb(a->asym->name, 'Z', a->aoffset, 0);

        putsymb(s->name, 'T', s->value, s->version);

        /* frame, auto and param after */
        putsymb(".frame", 'm', p->to.offset+4, 0);

        for(a=p->to.autom; a; a=a->link)
            if(a->type == D_AUTO)
                putsymb(a->asym->name, 'a', -a->aoffset, 0);
            else
            if(a->type == D_PARAM)
                putsymb(a->asym->name, 'p', a->aoffset, 0);
    }
    if(debug['v'] || debug['n'])
        Bprint(&bso, "symsize = %lud\n", symsize);
    Bflush(&bso);
}
@

<<function asmlc>>=
void
asmlc(void)
{
    long oldpc, oldlc;
    Prog *p;
    long v, s;

    oldpc = INITTEXT;
    oldlc = 0;
    for(p = firstp; p != P; p = p->link) {
        if(p->line == oldlc || p->as == ATEXT || p->as == ANOP) {
            if(p->as == ATEXT)
                curtext = p;
            if(debug['V'])
                Bprint(&bso, "%6lux %P\n",
                    p->pc, p);
            continue;
        }
        if(debug['V'])
            Bprint(&bso, "\t\t%6ld", lcsize);
        v = (p->pc - oldpc) / MINLC;
        while(v) {
            s = 127;
            if(v < 127)
                s = v;
            cput(s+128);	/* 129-255 +pc */
            if(debug['V'])
                Bprint(&bso, " pc+%ld*%d(%ld)", s, MINLC, s+128);
            v -= s;
            lcsize++;
        }
        s = p->line - oldlc;
        oldlc = p->line;
        oldpc = p->pc + MINLC;
        if(s > 64 || s < -64) {
            cput(0);	/* 0 vv +lc */
            cput(s>>24);
            cput(s>>16);
            cput(s>>8);
            cput(s);
            if(debug['V']) {
                if(s > 0)
                    Bprint(&bso, " lc+%ld(%d,%ld)\n",
                        s, 0, s);
                else
                    Bprint(&bso, " lc%ld(%d,%ld)\n",
                        s, 0, s);
                Bprint(&bso, "%6lux %P\n",
                    p->pc, p);
            }
            lcsize += 5;
            continue;
        }
        if(s > 0) {
            cput(0+s);	/* 1-64 +lc */
            if(debug['V']) {
                Bprint(&bso, " lc+%ld(%ld)\n", s, 0+s);
                Bprint(&bso, "%6lux %P\n",
                    p->pc, p);
            }
        } else {
            cput(64-s);	/* 65-128 -lc */
            if(debug['V']) {
                Bprint(&bso, " lc%ld(%ld)\n", s, 64-s);
                Bprint(&bso, "%6lux %P\n",
                    p->pc, p);
            }
        }
        lcsize++;
    }
    while(lcsize & 1) {
        s = 129;
        cput(s);
        lcsize++;
    }
    if(debug['v'] || debug['V'])
        Bprint(&bso, "lcsize = %ld\n", lcsize);
    Bflush(&bso);
}
@

<<function prefixof>>=
int
prefixof(Adr *a)
{
    switch(a->type) {
    case D_INDIR+D_CS:
        return 0x2e;
    case D_INDIR+D_DS:
        return 0x3e;
    case D_INDIR+D_ES:
        return 0x26;
    case D_INDIR+D_FS:
        return 0x64;
    case D_INDIR+D_GS:
        return 0x65;
    }
    return 0;
}
@

<<function oclass>>=
int
oclass(Adr *a)
{
    long v;

    if(a->type >= D_INDIR || a->index != D_NONE) {
        if(a->index != D_NONE && a->scale == 0) {
            if(a->type == D_ADDR) {
                switch(a->index) {
                case D_EXTERN:
                case D_STATIC:
                    return Yi32;
                case D_AUTO:
                case D_PARAM:
                    return Yiauto;
                }
                return Yxxx;
            }
            return Ycol;
        }
        return Ym;
    }
    switch(a->type)
    {
    case D_AL:
        return Yal;

    case D_AX:
        return Yax;

    case D_CL:
        return Ycl;

    case D_DL:
    case D_BL:
    case D_AH:
    case D_CH:
    case D_DH:
    case D_BH:
        return Yrb;

    case D_CX:
        return Ycx;

    case D_DX:
    case D_BX:
        return Yrx;

    case D_SP:
    case D_BP:
    case D_SI:
    case D_DI:
        return Yrl;

    case D_F0+0:
        return	Yf0;

    case D_F0+1:
    case D_F0+2:
    case D_F0+3:
    case D_F0+4:
    case D_F0+5:
    case D_F0+6:
    case D_F0+7:
        return	Yrf;

    case D_NONE:
        return Ynone;

    case D_CS:	return	Ycs;
    case D_SS:	return	Yss;
    case D_DS:	return	Yds;
    case D_ES:	return	Yes;
    case D_FS:	return	Yfs;
    case D_GS:	return	Ygs;

    case D_GDTR:	return	Ygdtr;
    case D_IDTR:	return	Yidtr;
    case D_LDTR:	return	Yldtr;
    case D_MSW:	return	Ymsw;
    case D_TASK:	return	Ytask;

    case D_CR+0:	return	Ycr0;
    case D_CR+1:	return	Ycr1;
    case D_CR+2:	return	Ycr2;
    case D_CR+3:	return	Ycr3;
    case D_CR+4:	return	Ycr4;
    case D_CR+5:	return	Ycr5;
    case D_CR+6:	return	Ycr6;
    case D_CR+7:	return	Ycr7;

    case D_DR+0:	return	Ydr0;
    case D_DR+1:	return	Ydr1;
    case D_DR+2:	return	Ydr2;
    case D_DR+3:	return	Ydr3;
    case D_DR+4:	return	Ydr4;
    case D_DR+5:	return	Ydr5;
    case D_DR+6:	return	Ydr6;
    case D_DR+7:	return	Ydr7;

    case D_TR+0:	return	Ytr0;
    case D_TR+1:	return	Ytr1;
    case D_TR+2:	return	Ytr2;
    case D_TR+3:	return	Ytr3;
    case D_TR+4:	return	Ytr4;
    case D_TR+5:	return	Ytr5;
    case D_TR+6:	return	Ytr6;
    case D_TR+7:	return	Ytr7;

    case D_EXTERN:
    case D_STATIC:
    case D_AUTO:
    case D_PARAM:
        return Ym;

    case D_CONST:
    case D_ADDR:
        if(a->sym == S) {
            v = a->offset;
            if(v == 0)
                return Yi0;
            if(v == 1)
                return Yi1;
            if(v >= -128 && v <= 127)
                return Yi8;
        }
        return Yi32;

    case D_BRANCH:
        return Ybr;
    }
    return Yxxx;
}
@

<<function asmidx>>=
void
asmidx(Adr *a, int base)
{
    int i;

    switch(a->index) {
    default:
        goto bad;

    case D_NONE:
        i = 4 << 3;
        goto bas;

    case D_AX:
    case D_CX:
    case D_DX:
    case D_BX:
    case D_BP:
    case D_SI:
    case D_DI:
        i = reg[a->index] << 3;
        break;
    }
    switch(a->scale) {
    default:
        goto bad;
    case 1:
        break;
    case 2:
        i |= (1<<6);
        break;
    case 4:
        i |= (2<<6);
        break;
    case 8:
        i |= (3<<6);
        break;
    }
bas:
    switch(base) {
    default:
        goto bad;
    case D_NONE:	/* must be mod=00 */
        i |= 5;
        break;
    case D_AX:
    case D_CX:
    case D_DX:
    case D_BX:
    case D_SP:
    case D_BP:
    case D_SI:
    case D_DI:
        i |= reg[base];
        break;
    }
    *andptr++ = i;
    return;
bad:
    diag("asmidx: bad address %D", a);
    *andptr++ = 0;
    return;
}
@
%>> >> >> >> >>

<<function put4>>=
static void
put4(long v)
{
    if(dlm && curp != P && reloca != nil){
        dynreloc(reloca->sym, curp->pc + andptr - &and[0], 1);
        reloca = nil;
    }
    andptr[0] = v;
    andptr[1] = v>>8;
    andptr[2] = v>>16;
    andptr[3] = v>>24;
    andptr += 4;
}
@

<<function vaddr>>=
long
vaddr(Adr *a)
{
    int t;
    long v;
    Sym *s;

    t = a->type;
    v = a->offset;
    if(t == D_ADDR)
        t = a->index;
    switch(t) {
    case D_STATIC:
    case D_EXTERN:
        s = a->sym;
        if(s != nil) {
            if(dlm && curp != P)
                reloca = a;
            switch(s->type) {
            case SUNDEF:
                ckoff(s, v);
            case STEXT:
            case SCONST:
                v += s->value;
                break;
            default:
                v += INITDAT + s->value;
            }
        }
    }
    return v;
}
@

<<function asmand>>=
void
asmand(Adr *a, int r)
{
    long v;
    int t;
    Adr aa;

    v = a->offset;
    t = a->type;
    if(a->index != D_NONE) {
        if(t >= D_INDIR) {
            t -= D_INDIR;
            if(t == D_NONE) {
                *andptr++ = (0 << 6) | (4 << 0) | (r << 3);
                asmidx(a, t);
                put4(v);
                return;
            }
            if(v == 0 && t != D_BP) {
                *andptr++ = (0 << 6) | (4 << 0) | (r << 3);
                asmidx(a, t);
                return;
            }
            if(v >= -128 && v < 128) {
                *andptr++ = (1 << 6) | (4 << 0) | (r << 3);
                asmidx(a, t);
                *andptr++ = v;
                return;
            }
            *andptr++ = (2 << 6) | (4 << 0) | (r << 3);
            asmidx(a, t);
            put4(v);
            return;
        }
        switch(t) {
        default:
            goto bad;
        case D_STATIC:
        case D_EXTERN:
            aa.type = D_NONE+D_INDIR;
            break;
        case D_AUTO:
        case D_PARAM:
            aa.type = D_SP+D_INDIR;
            break;
        }
        aa.offset = vaddr(a);
        aa.index = a->index;
        aa.scale = a->scale;
        asmand(&aa, r);
        return;
    }
    if(t >= D_AL && t <= D_F0+7) {
        if(v)
            goto bad;
        *andptr++ = (3 << 6) | (reg[t] << 0) | (r << 3);
        return;
    }
    if(t >= D_INDIR) {
        t -= D_INDIR;
        if(t == D_NONE || D_CS <= t && t <= D_GS) {
            *andptr++ = (0 << 6) | (5 << 0) | (r << 3);
            put4(v);
            return;
        }
        if(t == D_SP) {
            if(v == 0) {
                *andptr++ = (0 << 6) | (4 << 0) | (r << 3);
                asmidx(a, D_SP);
                return;
            }
            if(v >= -128 && v < 128) {
                *andptr++ = (1 << 6) | (4 << 0) | (r << 3);
                asmidx(a, D_SP);
                *andptr++ = v;
                return;
            }
            *andptr++ = (2 << 6) | (4 << 0) | (r << 3);
            asmidx(a, D_SP);
            put4(v);
            return;
        }
        if(t >= D_AX && t <= D_DI) {
            if(v == 0 && t != D_BP) {
                *andptr++ = (0 << 6) | (reg[t] << 0) | (r << 3);
                return;
            }
            if(v >= -128 && v < 128) {
                andptr[0] = (1 << 6) | (reg[t] << 0) | (r << 3);
                andptr[1] = v;
                andptr += 2;
                return;
            }
            *andptr++ = (2 << 6) | (reg[t] << 0) | (r << 3);
            put4(v);
            return;
        }
        goto bad;
    }
    switch(a->type) {
    default:
        goto bad;
    case D_STATIC:
    case D_EXTERN:
        aa.type = D_NONE+D_INDIR;
        break;
    case D_AUTO:
    case D_PARAM:
        aa.type = D_SP+D_INDIR;
        break;
    }
    aa.index = D_NONE;
    aa.scale = 1;
    aa.offset = vaddr(a);
    asmand(&aa, r);
    return;
bad:
    diag("asmand: bad address %D", a);
    return;
}
@

<<constant E>>=
#define	E	0xff
@

<<global ymovtab>>=
uchar	ymovtab[] =
{
/* push */
    APUSHL,	Ycs,	Ynone,	0,	0x0e,E,0,0,
    APUSHL,	Yss,	Ynone,	0,	0x16,E,0,0,
    APUSHL,	Yds,	Ynone,	0,	0x1e,E,0,0,
    APUSHL,	Yes,	Ynone,	0,	0x06,E,0,0,
    APUSHL,	Yfs,	Ynone,	0,	0x0f,0xa0,E,0,
    APUSHL,	Ygs,	Ynone,	0,	0x0f,0xa8,E,0,

    APUSHW,	Ycs,	Ynone,	0,	Pe,0x0e,E,0,
    APUSHW,	Yss,	Ynone,	0,	Pe,0x16,E,0,
    APUSHW,	Yds,	Ynone,	0,	Pe,0x1e,E,0,
    APUSHW,	Yes,	Ynone,	0,	Pe,0x06,E,0,
    APUSHW,	Yfs,	Ynone,	0,	Pe,0x0f,0xa0,E,
    APUSHW,	Ygs,	Ynone,	0,	Pe,0x0f,0xa8,E,

/* pop */
    APOPL,	Ynone,	Yds,	0,	0x1f,E,0,0,
    APOPL,	Ynone,	Yes,	0,	0x07,E,0,0,
    APOPL,	Ynone,	Yss,	0,	0x17,E,0,0,
    APOPL,	Ynone,	Yfs,	0,	0x0f,0xa1,E,0,
    APOPL,	Ynone,	Ygs,	0,	0x0f,0xa9,E,0,

    APOPW,	Ynone,	Yds,	0,	Pe,0x1f,E,0,
    APOPW,	Ynone,	Yes,	0,	Pe,0x07,E,0,
    APOPW,	Ynone,	Yss,	0,	Pe,0x17,E,0,
    APOPW,	Ynone,	Yfs,	0,	Pe,0x0f,0xa1,E,
    APOPW,	Ynone,	Ygs,	0,	Pe,0x0f,0xa9,E,

/* mov seg */
    AMOVW,	Yes,	Yml,	1,	0x8c,0,0,0,
    AMOVW,	Ycs,	Yml,	1,	0x8c,1,0,0,
    AMOVW,	Yss,	Yml,	1,	0x8c,2,0,0,
    AMOVW,	Yds,	Yml,	1,	0x8c,3,0,0,
    AMOVW,	Yfs,	Yml,	1,	0x8c,4,0,0,
    AMOVW,	Ygs,	Yml,	1,	0x8c,5,0,0,

    AMOVW,	Yml,	Yes,	2,	0x8e,0,0,0,
    AMOVW,	Yml,	Ycs,	2,	0x8e,1,0,0,
    AMOVW,	Yml,	Yss,	2,	0x8e,2,0,0,
    AMOVW,	Yml,	Yds,	2,	0x8e,3,0,0,
    AMOVW,	Yml,	Yfs,	2,	0x8e,4,0,0,
    AMOVW,	Yml,	Ygs,	2,	0x8e,5,0,0,

/* mov cr */
    AMOVL,	Ycr0,	Yml,	3,	0x0f,0x20,0,0,
    AMOVL,	Ycr2,	Yml,	3,	0x0f,0x20,2,0,
    AMOVL,	Ycr3,	Yml,	3,	0x0f,0x20,3,0,
    AMOVL,	Ycr4,	Yml,	3,	0x0f,0x20,4,0,

    AMOVL,	Yml,	Ycr0,	4,	0x0f,0x22,0,0,
    AMOVL,	Yml,	Ycr2,	4,	0x0f,0x22,2,0,
    AMOVL,	Yml,	Ycr3,	4,	0x0f,0x22,3,0,
    AMOVL,	Yml,	Ycr4,	4,	0x0f,0x22,4,0,

/* mov dr */
    AMOVL,	Ydr0,	Yml,	3,	0x0f,0x21,0,0,
    AMOVL,	Ydr6,	Yml,	3,	0x0f,0x21,6,0,
    AMOVL,	Ydr7,	Yml,	3,	0x0f,0x21,7,0,

    AMOVL,	Yml,	Ydr0,	4,	0x0f,0x23,0,0,
    AMOVL,	Yml,	Ydr6,	4,	0x0f,0x23,6,0,
    AMOVL,	Yml,	Ydr7,	4,	0x0f,0x23,7,0,

/* mov tr */
    AMOVL,	Ytr6,	Yml,	3,	0x0f,0x24,6,0,
    AMOVL,	Ytr7,	Yml,	3,	0x0f,0x24,7,0,

    AMOVL,	Yml,	Ytr6,	4,	0x0f,0x26,6,E,
    AMOVL,	Yml,	Ytr7,	4,	0x0f,0x26,7,E,

/* lgdt, sgdt, lidt, sidt */
    AMOVL,	Ym,	Ygdtr,	4,	0x0f,0x01,2,0,
    AMOVL,	Ygdtr,	Ym,	3,	0x0f,0x01,0,0,
    AMOVL,	Ym,	Yidtr,	4,	0x0f,0x01,3,0,
    AMOVL,	Yidtr,	Ym,	3,	0x0f,0x01,1,0,

/* lldt, sldt */
    AMOVW,	Yml,	Yldtr,	4,	0x0f,0x00,2,0,
    AMOVW,	Yldtr,	Yml,	3,	0x0f,0x00,0,0,

/* lmsw, smsw */
    AMOVW,	Yml,	Ymsw,	4,	0x0f,0x01,6,0,
    AMOVW,	Ymsw,	Yml,	3,	0x0f,0x01,4,0,

/* ltr, str */
    AMOVW,	Yml,	Ytask,	4,	0x0f,0x00,3,0,
    AMOVW,	Ytask,	Yml,	3,	0x0f,0x00,1,0,

/* load full pointer */
    AMOVL,	Yml,	Ycol,	5,	0,0,0,0,
    AMOVW,	Yml,	Ycol,	5,	Pe,0,0,0,

/* double shift */
    ASHLL,	Ycol,	Yml,	6,	0xa4,0xa5,0,0,
    ASHRL,	Ycol,	Yml,	6,	0xac,0xad,0,0,

/* extra imul */
    AIMULW,	Yml,	Yrl,	7,	Pq,0xaf,0,0,
    AIMULL,	Yml,	Yrl,	7,	Pm,0xaf,0,0,
    0
};
@

<<function isax>>=
int
isax(Adr *a)
{

    switch(a->type) {
    case D_AX:
    case D_AL:
    case D_AH:
    case D_INDIR+D_AX:
        return 1;
    }
    if(a->index == D_AX)
        return 1;
    return 0;
}
@

<<function subreg>>=
void
subreg(Prog *p, int from, int to)
{

    if(debug['Q'])
        print("\n%P	s/%R/%R/\n", p, from, to);

    if(p->from.type == from)
        p->from.type = to;
    if(p->to.type == from)
        p->to.type = to;

    if(p->from.index == from)
        p->from.index = to;
    if(p->to.index == from)
        p->to.index = to;

    from += D_INDIR;
    if(p->from.type == from)
        p->from.type = to+D_INDIR;
    if(p->to.type == from)
        p->to.type = to+D_INDIR;

    if(debug['Q'])
        print("%P\n", p);
}
@

<<function doasm>>=
void
doasm(Prog *p)
{
    Optab *o;
    Prog *q, pp;
    uchar *t;
    int z, op, ft, tt;
    long v, pre;

    pre = prefixof(&p->from);
    if(pre)
        *andptr++ = pre;
    pre = prefixof(&p->to);
    if(pre)
        *andptr++ = pre;

    o = &optab[p->as];
    ft = oclass(&p->from) * Ymax;
    tt = oclass(&p->to) * Ymax;
    t = o->ytab;
    if(t == 0) {
        diag("asmins: noproto %P", p);
        return;
    }
    for(z=0; *t; z+=t[3],t+=4)
        if(ycover[ft+t[0]])
        if(ycover[tt+t[1]])
            goto found;
    goto domov;

found:
    switch(o->prefix) {
    case Pq:	/* 16 bit escape and opcode escape */
        *andptr++ = Pe;
        *andptr++ = Pm;
        break;

    case Pm:	/* opcode escape */
        *andptr++ = Pm;
        break;

    case Pe:	/* 16 bit escape */
        *andptr++ = Pe;
        break;

    case Pb:	/* botch */
        break;
    }
    v = vaddr(&p->from);
    op = o->op[z];
    switch(t[2]) {
    default:
        diag("asmins: unknown z %d %P", t[2], p);
        return;

    case Zpseudo:
        break;

    case Zlit:
        for(; op = o->op[z]; z++)
            *andptr++ = op;
        break;

    case Zm_r:
        *andptr++ = op;
        asmand(&p->from, reg[p->to.type]);
        break;

    case Zaut_r:
        *andptr++ = 0x8d;	/* leal */
        if(p->from.type != D_ADDR)
            diag("asmins: Zaut sb type ADDR");
        p->from.type = p->from.index;
        p->from.index = D_NONE;
        asmand(&p->from, reg[p->to.type]);
        p->from.index = p->from.type;
        p->from.type = D_ADDR;
        break;

    case Zm_o:
        *andptr++ = op;
        asmand(&p->from, o->op[z+1]);
        break;

    case Zr_m:
        *andptr++ = op;
        asmand(&p->to, reg[p->from.type]);
        break;

    case Zo_m:
        *andptr++ = op;
        asmand(&p->to, o->op[z+1]);
        break;

    case Zm_ibo:
        v = vaddr(&p->to);
        *andptr++ = op;
        asmand(&p->from, o->op[z+1]);
        *andptr++ = v;
        break;

    case Zibo_m:
        *andptr++ = op;
        asmand(&p->to, o->op[z+1]);
        *andptr++ = v;
        break;

    case Z_ib:
        v = vaddr(&p->to);
    case Zib_:
        *andptr++ = op;
        *andptr++ = v;
        break;

    case Zib_rp:
        *andptr++ = op + reg[p->to.type];
        *andptr++ = v;
        break;

    case Zil_rp:
        *andptr++ = op + reg[p->to.type];
        if(o->prefix == Pe) {
            *andptr++ = v;
            *andptr++ = v>>8;
        }
        else
            put4(v);
        break;

    case Zib_rr:
        *andptr++ = op;
        asmand(&p->to, reg[p->to.type]);
        *andptr++ = v;
        break;

    case Z_il:
        v = vaddr(&p->to);
    case Zil_:
        *andptr++ = op;
        if(o->prefix == Pe) {
            *andptr++ = v;
            *andptr++ = v>>8;
        }
        else
            put4(v);
        break;

    case Zm_ilo:
        v = vaddr(&p->to);
        *andptr++ = op;
        asmand(&p->from, o->op[z+1]);
        if(o->prefix == Pe) {
            *andptr++ = v;
            *andptr++ = v>>8;
        }
        else
            put4(v);
        break;

    case Zilo_m:
        *andptr++ = op;
        asmand(&p->to, o->op[z+1]);
        if(o->prefix == Pe) {
            *andptr++ = v;
            *andptr++ = v>>8;
        }
        else
            put4(v);
        break;

    case Zil_rr:
        *andptr++ = op;
        asmand(&p->to, reg[p->to.type]);
        if(o->prefix == Pe) {
            *andptr++ = v;
            *andptr++ = v>>8;
        }
        else
            put4(v);
        break;

    case Z_rp:
        *andptr++ = op + reg[p->to.type];
        break;

    case Zrp_:
        *andptr++ = op + reg[p->from.type];
        break;

    case Zclr:
        *andptr++ = op;
        asmand(&p->to, reg[p->to.type]);
        break;

    case Zbr:
        q = p->pcond;
        if(q) {
            v = q->pc - p->pc - 2;
            if(v >= -128 && v <= 127) {
                *andptr++ = op;
                *andptr++ = v;
            } else {
                v -= 6-2;
                *andptr++ = 0x0f;
                *andptr++ = o->op[z+1];
                *andptr++ = v;
                *andptr++ = v>>8;
                *andptr++ = v>>16;
                *andptr++ = v>>24;
            }
        }
        break;

    case Zcall:
        q = p->pcond;
        if(q) {
            v = q->pc - p->pc - 5;
            if(dlm && curp != P && p->to.sym->type == SUNDEF){
                /* v = 0 - p->pc - 5; */
                v = 0;
                ckoff(p->to.sym, v);
                v += p->to.sym->value;
                dynreloc(p->to.sym, p->pc+1, 0);
            }
            *andptr++ = op;
            *andptr++ = v;
            *andptr++ = v>>8;
            *andptr++ = v>>16;
            *andptr++ = v>>24;
        }
        break;

    case Zjmp:
        q = p->pcond;
        if(q) {
            v = q->pc - p->pc - 2;
            if(v >= -128 && v <= 127) {
                *andptr++ = op;
                *andptr++ = v;
            } else {
                v -= 5-2;
                *andptr++ = o->op[z+1];
                *andptr++ = v;
                *andptr++ = v>>8;
                *andptr++ = v>>16;
                *andptr++ = v>>24;
            }
        }
        break;

    case Zloop:
        q = p->pcond;
        if(q) {
            v = q->pc - p->pc - 2;
            if(v < -128 || v > 127)
                diag("loop too far: %P", p);
            *andptr++ = op;
            *andptr++ = v;
        }
        break;

    case Zbyte:
        *andptr++ = v;
        if(op > 1) {
            *andptr++ = v>>8;
            if(op > 2) {
                *andptr++ = v>>16;
                *andptr++ = v>>24;
            }
        }
        break;

    case Zmov:
        goto domov;
    }
    return;

domov:
    for(t=ymovtab; *t; t+=8)
        if(p->as == t[0])
        if(ycover[ft+t[1]])
        if(ycover[tt+t[2]])
            goto mfound;
bad:
    /*
     * here, the assembly has failed.
     * if its a byte instruction that has
     * unaddressable registers, try to
     * exchange registers and reissue the
     * instruction with the operands renamed.
     */
    pp = *p;
    z = p->from.type;
    if(z >= D_BP && z <= D_DI) {
        if(isax(&p->to)) {
            *andptr++ = 0x87;			/* xchg lhs,bx */
            asmand(&p->from, reg[D_BX]);
            subreg(&pp, z, D_BX);
            doasm(&pp);
            *andptr++ = 0x87;			/* xchg lhs,bx */
            asmand(&p->from, reg[D_BX]);
        } else {
            *andptr++ = 0x90 + reg[z];		/* xchg lsh,ax */
            subreg(&pp, z, D_AX);
            doasm(&pp);
            *andptr++ = 0x90 + reg[z];		/* xchg lsh,ax */
        }
        return;
    }
    z = p->to.type;
    if(z >= D_BP && z <= D_DI) {
        if(isax(&p->from)) {
            *andptr++ = 0x87;			/* xchg rhs,bx */
            asmand(&p->to, reg[D_BX]);
            subreg(&pp, z, D_BX);
            doasm(&pp);
            *andptr++ = 0x87;			/* xchg rhs,bx */
            asmand(&p->to, reg[D_BX]);
        } else {
            *andptr++ = 0x90 + reg[z];		/* xchg rsh,ax */
            subreg(&pp, z, D_AX);
            doasm(&pp);
            *andptr++ = 0x90 + reg[z];		/* xchg rsh,ax */
        }
        return;
    }
    diag("doasm: notfound t2=%ux from=%ux to=%ux %P", t[2], p->from.type, p->to.type, p);
    return;

mfound:
    switch(t[3]) {
    default:
        diag("asmins: unknown mov %d %P", t[3], p);
        break;

    case 0:	/* lit */
        for(z=4; t[z]!=E; z++)
            *andptr++ = t[z];
        break;

    case 1:	/* r,m */
        *andptr++ = t[4];
        asmand(&p->to, t[5]);
        break;

    case 2:	/* m,r */
        *andptr++ = t[4];
        asmand(&p->from, t[5]);
        break;

    case 3:	/* r,m - 2op */
        *andptr++ = t[4];
        *andptr++ = t[5];
        asmand(&p->to, t[6]);
        break;

    case 4:	/* m,r - 2op */
        *andptr++ = t[4];
        *andptr++ = t[5];
        asmand(&p->from, t[6]);
        break;

    case 5:	/* load full pointer, trash heap */
        if(t[4])
            *andptr++ = t[4];
        switch(p->to.index) {
        default:
            goto bad;
        case D_DS:
            *andptr++ = 0xc5;
            break;
        case D_SS:
            *andptr++ = 0x0f;
            *andptr++ = 0xb2;
            break;
        case D_ES:
            *andptr++ = 0xc4;
            break;
        case D_FS:
            *andptr++ = 0x0f;
            *andptr++ = 0xb4;
            break;
        case D_GS:
            *andptr++ = 0x0f;
            *andptr++ = 0xb5;
            break;
        }
        asmand(&p->from, reg[p->to.type]);
        break;

    case 6:	/* double shift */
        z = p->from.type;
        switch(z) {
        default:
            goto bad;
        case D_CONST:
            *andptr++ = 0x0f;
            *andptr++ = t[4];
            asmand(&p->to, reg[p->from.index]);
            *andptr++ = p->from.offset;
            break;
        case D_CL:
        case D_CX:
            *andptr++ = 0x0f;
            *andptr++ = t[5];
            asmand(&p->to, reg[p->from.index]);
            break;
        }
        break;

    case 7: /* imul rm,r */
        *andptr++ = t[4];
        *andptr++ = t[5];
        asmand(&p->from, reg[p->to.type]);
        break;
    }
}
@

<<function asmins>>=
void
asmins(Prog *p)
{

    andptr = and;
    doasm(p);
}
@

<<enum _anon_ (linkers/8l/span.c)>>=
enum{
    ABSD = 0,
    ABSU = 1,
    RELD = 2,
    RELU = 3,
};
@

<<global modemap>>=
int modemap[4] = { 0, 1, -1, 2, };
@

<<struct Reloc>>=
struct Reloc
{
    int n;
    int t;
    uchar *m;
    ulong *a;
};
@

<<global rels>>=
Reloc rels;
@

<<function grow>>=
static void
grow(Reloc *r)
{
    int t;
    uchar *m, *nm;
    ulong *a, *na;

    t = r->t;
    r->t += 64;
    m = r->m;
    a = r->a;
    r->m = nm = malloc(r->t*sizeof(uchar));
    r->a = na = malloc(r->t*sizeof(ulong));
    memmove(nm, m, t*sizeof(uchar));
    memmove(na, a, t*sizeof(ulong));
    free(m);
    free(a);
}
@

<<function dynreloc>>=
void
dynreloc(Sym *s, ulong v, int abs)
{
    int i, k, n;
    uchar *m;
    ulong *a;
    Reloc *r;

    if(s->type == SUNDEF)
        k = abs ? ABSU : RELU;
    else
        k = abs ? ABSD : RELD;
    /* Bprint(&bso, "R %s a=%ld(%lx) %d\n", s->name, v, v, k); */
    k = modemap[k];
    r = &rels;
    n = r->n;
    if(n >= r->t)
        grow(r);
    m = r->m;
    a = r->a;
    for(i = n; i > 0; i--){
        if(v < a[i-1]){	/* happens occasionally for data */
            m[i] = m[i-1];
            a[i] = a[i-1];
        }
        else
            break;
    }
    m[i] = k;
    a[i] = v;
    r->n++;
}
@

<<function sput>>=
static int
sput(char *s)
{
    char *p;

    p = s;
    while(*s)
        cput(*s++);
    cput(0);
    return s-p+1;
}
@

<<function asmdyn>>=
void
asmdyn()
{
    int i, n, t, c;
    Sym *s;
    ulong la, ra, *a;
    vlong off;
    uchar *m;
    Reloc *r;

    cflush();
    off = seek(cout, 0, 1);
    lput(0);
    t = 0;
    lput(imports);
    t += 4;
    for(i = 0; i < NHASH; i++)
        for(s = hash[i]; s != S; s = s->link)
            if(s->type == SUNDEF){
                lput(s->sig);
                t += 4;
                t += sput(s->name);
            }

    la = 0;
    r = &rels;
    n = r->n;
    m = r->m;
    a = r->a;
    lput(n);
    t += 4;
    for(i = 0; i < n; i++){
        ra = *a-la;
        if(*a < la)
            diag("bad relocation order");
        if(ra < 256)
            c = 0;
        else if(ra < 65536)
            c = 1;
        else
            c = 2;
        cput((c<<6)|*m++);
        t++;
        if(c == 0){
            cput(ra);
            t++;
        }
        else if(c == 1){
            wput(ra);
            t += 2;
        }
        else{
            lput(ra);
            t += 4;
        }
        la = *a++;
    }

    cflush();
    seek(cout, off, 0);
    lput(t);

    if(debug['v']){
        Bprint(&bso, "import table entries = %d\n", imports);
        Bprint(&bso, "export table entries = %d\n", exports);
    }
}
@


%-------------------------------------------------------------

<<linkers/8l/span.c>>=
#include	"l.h"

<<function span>>

<<function xdefine>>

<<function putsymb>>

<<function asmsym>>

<<function asmlc>>

<<function prefixof>>

<<function oclass>>

<<function asmidx>>

<<function put4>>

<<function vaddr>>

<<function asmand>>

<<constant E>>
<<global ymovtab>>

<<function isax>>

<<function subreg>>

<<function doasm>>

<<function asmins>>

<<enum _anon_ (linkers/8l/span.c)>>

<<global modemap>>

typedef struct Reloc Reloc;

<<struct Reloc>>

<<global rels>>

<<function grow>>

<<function dynreloc>>

<<function sput>>

<<function asmdyn>>
@


\subsection*{[[linkers/8l/elf.c]]}

<<enum _anon_ (linkers/8l/elf.c)>>=
enum {
    /* offsets into string table */
    Stitext		= 1,
    Stidata		= 7,
    Stistrtab	= 13,
};
@

<<function elfident>>=
void
elfident(int bo, int class)
{
    strnput("\177ELF", 4);		/* e_ident */
    cput(class);
    cput(bo);			/* byte order */
    cput(1);			/* version = CURRENT */
    if(debug['k']){			/* boot/embedded/standalone */
        cput(255);
        cput(0);
    }
    else{
        cput(0);		/* osabi = SYSV */
        cput(0);		/* abiversion = 3 */
    }
    strnput("", 7);
}
@

<<function elfstrtab>>=
void
elfstrtab(void)
{
    /* string table */
    cput(0);
    strnput(".text", 5);		/* +1 */
    cput(0);
    strnput(".data", 5);		/* +7 */
    cput(0);
    strnput(".strtab", 7);		/* +13 */
    cput(0);
    cput(0);
}
@

<<function elf32phdr>>=
void
elf32phdr(void (*putl)(long), ulong type, ulong off, ulong vaddr, ulong paddr,
    ulong filesz, ulong memsz, ulong prots, ulong align)
{
    putl(type);
    putl(off);
    putl(vaddr);
    putl(paddr);
    putl(filesz);
    putl(memsz);
    putl(prots);
    putl(align);
}
@

<<function elf32shdr>>=
void
elf32shdr(void (*putl)(long), ulong name, ulong type, ulong flags, ulong vaddr,
    ulong off, ulong sectsz, ulong link, ulong addnl, ulong align,
    ulong entsz)
{
    putl(name);
    putl(type);
    putl(flags);
    putl(vaddr);
    putl(off);
    putl(sectsz);
    putl(link);
    putl(addnl);
    putl(align);
    putl(entsz);
}
@

<<function elf32sectab>>=
static void
elf32sectab(void (*putl)(long))
{
    seek(cout, HEADR+textsize+datsize+symsize, 0);
    elf32shdr(putl, Stitext, Progbits, Salloc|Sexec, INITTEXT,
        HEADR, textsize, 0, 0, 0x10000, 0);
    elf32shdr(putl, Stidata, Progbits, Salloc|SwriteElf, INITDAT,
        HEADR+textsize, datsize, 0, 0, 0x10000, 0);
    elf32shdr(putl, Stistrtab, Strtab, 1 << 5, 0,
        HEADR+textsize+datsize+symsize+3*Shdr32sz, 14, 0, 0, 1, 0);
    elfstrtab();
}
@

<<function elf32>>=
/* if addpsects > 0, putpsects must emit exactly that many psects. */
void
elf32(int mach, int bo, int addpsects, void (*putpsects)(Putl))
{
    ulong phydata;
    void (*putw)(long), (*putl)(long);

    if(bo == ELFDATA2MSB){
        putw = wput;
        putl = lput;
    }else if(bo == ELFDATA2LSB){
        putw = wputl;
        putl = lputl;
    }else{
        print("elf32 byte order is mixed-endian\n");
        errorexit();
        return;
    }

    elfident(bo, ELFCLASS32);
    putw(EXEC);
    putw(mach);
    putl(1L);			/* version = CURRENT */
    putl(entryvalue());		/* entry vaddr */
    putl(Ehdr32sz);			/* offset to first phdr */
    if(debug['S'])
        putl(HEADR+textsize+datsize+symsize); /* offset to first shdr */
    else
        putl(0);
    putl(0L);			/* flags */
    putw(Ehdr32sz);
    putw(Phdr32sz);
    putw(3 + addpsects);		/* # of Phdrs */
    putw(Shdr32sz);
    if(debug['S']){
        putw(3);		/* # of Shdrs */
        putw(2);		/* Shdr table index */
    }else{
        putw(0);
        putw(0);
    }

    /*
     * could include ELF headers in text -- 8l doesn't,
     * but in theory it aids demand loading.
     */
    elf32phdr(putl, PT_LOAD, HEADR, INITTEXT, INITTEXTP,
        textsize, textsize, R|X, INITRND);	/* text */
    /*
     * we need INITDATP, but it has to be computed.
     * assume distance between INITTEXT & INITTEXTP is also
     * correct for INITDAT and INITDATP.
     */
    phydata = INITDAT - (INITTEXT - INITTEXTP);
    elf32phdr(putl, PT_LOAD, HEADR+textsize, INITDAT, phydata,
        datsize, datsize+bsssize, R|W|X, INITRND); /* data */
    elf32phdr(putl, NOPTYPE, HEADR+textsize+datsize, 0, 0,
        symsize, lcsize, R, 4);			/* symbol table */
    if (addpsects > 0)
        putpsects(putl);
    cflush();

    if(debug['S'])
        elf32sectab(putl);
}
@

<<function elf64phdr>>=
/*
 * elf64
 */
void
elf64phdr(void (*putl)(long), void (*putll)(vlong), ulong type, uvlong off,
    uvlong vaddr, uvlong paddr, uvlong filesz, uvlong memsz, ulong prots,
    uvlong align)
{
    putl(type);		
    putl(prots);		
    putll(off);		
    putll(vaddr);	
    putll(paddr);	
    putll(filesz);	
    putll(memsz);	
    putll(align);		
}
@

<<function elf64shdr>>=
void
elf64shdr(void (*putl)(long), void (*putll)(vlong), ulong name, ulong type,
    uvlong flags, uvlong vaddr, uvlong off, uvlong sectsz, ulong link,
    ulong addnl, uvlong align, uvlong entsz)
{
    putl(name);
    putl(type);
    putll(flags);
    putll(vaddr);
    putll(off);
    putll(sectsz);
    putl(link);
    putl(addnl);
    putll(align);
    putll(entsz);
}
@

<<function elf64sectab>>=
static void
elf64sectab(void (*putl)(long), void (*putll)(vlong))
{
    seek(cout, HEADR+textsize+datsize+symsize, 0);
    elf64shdr(putl, putll, Stitext, Progbits, Salloc|Sexec, INITTEXT,
        HEADR, textsize, 0, 0, 0x10000, 0);
    elf64shdr(putl, putll, Stidata, Progbits, Salloc|SwriteElf, INITDAT,
        HEADR+textsize, datsize, 0, 0, 0x10000, 0);
    elf64shdr(putl, putll, Stistrtab, Strtab, 1 << 5, 0,
        HEADR+textsize+datsize+symsize+3*Shdr64sz, 14, 0, 0, 1, 0);
    elfstrtab();
}
@

<<function elf64>>=
/* if addpsects > 0, putpsects must emit exactly that many psects. */
//@Scheck: not dead, used by vl/
void elf64(int mach, int bo, int addpsects, void (*putpsects)(Putl))
{
    uvlong phydata;
    void (*putw)(long), (*putl)(long);
    void (*putll)(vlong);

    if(bo == ELFDATA2MSB){
        putw = wput;
        putl = lput;
        putll = llput;
    }else if(bo == ELFDATA2LSB){
        putw = wputl;
        putl = lputl;
        putll = llputl;
    }else{
        print("elf64 byte order is mixed-endian\n");
        errorexit();
        return;
    }

    elfident(bo, ELFCLASS64);
    putw(EXEC);
    putw(mach);
    putl(1L);			/* version = CURRENT */
    putll(entryvalue());		/* entry vaddr */
    putll(Ehdr64sz);		/* offset to first phdr */
    if(debug['S'])
        putll(HEADR+textsize+datsize+symsize); /* offset to 1st shdr */
    else
        putll(0);
    putl(0L);			/* flags */
    putw(Ehdr64sz);
    putw(Phdr64sz);
    putw(3 + addpsects);		/* # of Phdrs */
    putw(Shdr64sz);
    if(debug['S']){
        putw(3);		/* # of Shdrs */
        putw(2);		/* Shdr table index */
    }else{
        putw(0);
        putw(0);
    }

    elf64phdr(putl, putll, PT_LOAD, HEADR, INITTEXT, INITTEXTP,
        textsize, textsize, R|X, INITRND);	/* text */
    /*
     * see 32-bit ELF case for physical data address computation.
     */
    phydata = INITDAT - (INITTEXT - INITTEXTP);
    elf64phdr(putl, putll, PT_LOAD, HEADR+textsize, INITDAT, phydata,
        datsize, datsize+bsssize, R|W, INITRND); /* data */
    elf64phdr(putl, putll, NOPTYPE, HEADR+textsize+datsize, 0, 0,
        symsize, lcsize, R, 4);			/* symbol table */
    if (addpsects > 0)
        putpsects(putl);
    cflush();

    if(debug['S'])
        elf64sectab(putl, putll);
}
@


%-------------------------------------------------------------

<<linkers/8l/elf.c>>=
/*
 * emit 32- or 64-bit elf headers for any architecture.
 * this is a component of ?l.
 */
#include "l.h"

long	entryvalue(void);

<<enum _anon_ (linkers/8l/elf.c)>>

<<function elfident>>

<<function elfstrtab>>

<<function elf32phdr>>

<<function elf32shdr>>

<<function elf32sectab>>

<<function elf32>>

<<function elf64phdr>>

<<function elf64shdr>>

<<function elf64sectab>>

<<function elf64>>
@


\subsection*{[[linkers/8l/obj.c]]}

<<constant DEFAULT>>=
#define	DEFAULT	'9'
@

<<global noname (linkers/8l/obj.c)>>=
char	*noname		= "<none>";
@

<<global symname (linkers/8l/obj.c)>>=
char	symname[]	= SYMDEF;
@

<<global thechar>>=
char	thechar		= '8';
@

<<global thestring>>=
char	*thestring 	= "386";
@

<<global libdir>>=
char**	libdir;
@

<<global nlibdir>>=
int	nlibdir	= 0;
@

<<global maxlibdir>>=
static	int	maxlibdir = 0;
@

<<function usage (linkers/8l/obj.c)>>=
/*
 *	-H0 -T0x40004C -D0x10000000	is garbage unix
 *	-H1 -T0xd0 -R4			is unix coff
 *	-H2 -T4128 -R4096		is plan9 format
 *	-H3 -Tx -Rx			is MS-DOS .COM
 *	-H4 -Tx -Rx			is fake MS-DOS .EXE
 *	-H5 -T0x80100020 -R4096		is ELF
 */

void
usage(void)
{
    diag("usage: %s [-options] objects", argv0);
    errorexit();
}
@

<<function isobjfile>>=
static int
isobjfile(char *f)
{
    int n, v;
    Biobuf *b;
    char buf1[5], buf2[SARMAG];

    b = Bopen(f, OREAD);
    if(b == nil)
        return 0;
    n = Bread(b, buf1, 5);
    if(n == 5 && (buf1[2] == 1 && buf1[3] == '<' || buf1[3] == 1 && buf1[4] == '<'))
        v = 1;	/* good enough for our purposes */
    else{
        Bseek(b, 0, 0);
        n = Bread(b, buf2, SARMAG);
        v = n == SARMAG && strncmp(buf2, ARMAG, SARMAG) == 0;
    }
    Bterm(b);
    return v;
}
@

<<function main (linkers/8l/obj.c)>>=
void
main(int argc, char *argv[])
{
    int i, c;
    char *a;
    char name[LIBNAMELEN];

    Binit(&bso, 1, OWRITE);
    cout = -1;
    listinit();
    memset(debug, 0, sizeof(debug));
    nerrors = 0;
    outfile = "8.out";
    HEADTYPE = -1;
    INITTEXT = -1;
    INITTEXTP = -1;
    INITDAT = -1;
    INITRND = -1;
    INITENTRY = 0;
    ARGBEGIN {
    default:
        c = ARGC();
        if(c >= 0 && c < sizeof(debug))
            debug[c]++;
        break;
    case 'o': /* output to (next arg) */
        outfile = ARGF();
        break;
    case 'E':
        a = ARGF();
        if(a)
            INITENTRY = a;
        break;
    case 'H':
        a = ARGF();
        if(a)
            HEADTYPE = atolwhex(a);
        break;
    case 'L':
        addlibpath(EARGF(usage()));
        break;
    case 'T':
        a = ARGF();
        if(a)
            INITTEXT = atolwhex(a);
        break;
    case 'P':
        a = ARGF();
        if(a)
            INITTEXTP = atolwhex(a);
        break;
    case 'D':
        a = ARGF();
        if(a)
            INITDAT = atolwhex(a);
        break;
    case 'R':
        a = ARGF();
        if(a)
            INITRND = atolwhex(a);
        break;
    case 'x':	/* produce export table */
        doexp = 1;
        if(argv[1] != nil && argv[1][0] != '-' && !isobjfile(argv[1])){
            a = ARGF();
            if(strcmp(a, "*") == 0)
                allexport = 1;
            else
                readundefs(a, SEXPORT);
        }
        break;
    case 'u':	/* produce dynamically loadable module */
        dlm = 1;
        debug['l']++;
        if(argv[1] != nil && argv[1][0] != '-' && !isobjfile(argv[1]))
            readundefs(ARGF(), SIMPORT);
        break;
    } ARGEND
    USED(argc);
    if(*argv == 0)
        usage();
    if(!debug['9'] && !debug['U'] && !debug['B'])
        debug[DEFAULT] = 1;
    a = getenv("ccroot");
    if(a != nil && *a != '\0') {
        if(!fileexists(a)) {
            diag("nonexistent $ccroot: %s", a);
            errorexit();
        }
    }else
        a = "";
    snprint(name, sizeof(name), "%s/%s/lib", a, thestring);
    addlibpath(name);
    if(HEADTYPE == -1) {
        if(debug['U'])
            HEADTYPE = 1;
        if(debug['B'])
            HEADTYPE = 2;
        if(debug['9'])
            HEADTYPE = 2;
    }
    switch(HEADTYPE) {
    default:
        diag("unknown -H option");
        errorexit();

    case 0:	/* this is garbage */
        HEADR = 20L+56L;
        if(INITTEXT == -1)
            INITTEXT = 0x40004CL;
        if(INITDAT == -1)
            INITDAT = 0x10000000L;
        if(INITRND == -1)
            INITRND = 0;
        break;
    case 1:	/* is unix coff */
        HEADR = 0xd0L;
        if(INITTEXT == -1)
            INITTEXT = 0xd0;
        if(INITDAT == -1)
            INITDAT = 0x400000;
        if(INITRND == -1)
            INITRND = 0;
        break;
    case 2:	/* plan 9 */
        HEADR = 32L;
        if(INITTEXT == -1)
            INITTEXT = 4096+32;
        if(INITDAT == -1)
            INITDAT = 0;
        if(INITRND == -1)
            INITRND = 4096;
        break;
    case 3:	/* MS-DOS .COM */
        HEADR = 0;
        if(INITTEXT == -1)
            INITTEXT = 0x0100;
        if(INITDAT == -1)
            INITDAT = 0;
        if(INITRND == -1)
            INITRND = 4;
        break;
    case 4:	/* fake MS-DOS .EXE */
        HEADR = 0x200;
        if(INITTEXT == -1)
            INITTEXT = 0x0100;
        if(INITDAT == -1)
            INITDAT = 0;
        if(INITRND == -1)
            INITRND = 4;
        HEADR += (INITTEXT & 0xFFFF);
        if(debug['v'])
            Bprint(&bso, "HEADR = 0x%ld\n", HEADR);
        break;
    case 5:	/* elf executable */
        HEADR = rnd(Ehdr32sz+3*Phdr32sz, 16);
        if(INITTEXT == -1)
            INITTEXT = 0x80100020L;
        if(INITDAT == -1)
            INITDAT = 0;
        if(INITRND == -1)
            INITRND = 4096;
        break;
    }
    if (INITTEXTP == -1)
        INITTEXTP = INITTEXT;
    if(INITDAT != 0 && INITRND != 0)
        print("warning: -D0x%lux is ignored because of -R0x%lux\n",
            INITDAT, INITRND);
    if(debug['v'])
        Bprint(&bso, "HEADER = -H0x%ld -T0x%lux -D0x%lux -R0x%lux\n",
            HEADTYPE, INITTEXT, INITDAT, INITRND);
    Bflush(&bso);
    for(i=1; optab[i].as; i++)
        if(i != optab[i].as) {
            diag("phase error in optab: %d", i);
            errorexit();
        }

    for(i=0; i<Ymax; i++)
        ycover[i*Ymax + i] = 1;

    ycover[Yi0*Ymax + Yi8] = 1;
    ycover[Yi1*Ymax + Yi8] = 1;

    ycover[Yi0*Ymax + Yi32] = 1;
    ycover[Yi1*Ymax + Yi32] = 1;
    ycover[Yi8*Ymax + Yi32] = 1;

    ycover[Yal*Ymax + Yrb] = 1;
    ycover[Ycl*Ymax + Yrb] = 1;
    ycover[Yax*Ymax + Yrb] = 1;
    ycover[Ycx*Ymax + Yrb] = 1;
    ycover[Yrx*Ymax + Yrb] = 1;

    ycover[Yax*Ymax + Yrx] = 1;
    ycover[Ycx*Ymax + Yrx] = 1;

    ycover[Yax*Ymax + Yrl] = 1;
    ycover[Ycx*Ymax + Yrl] = 1;
    ycover[Yrx*Ymax + Yrl] = 1;

    ycover[Yf0*Ymax + Yrf] = 1;

    ycover[Yal*Ymax + Ymb] = 1;
    ycover[Ycl*Ymax + Ymb] = 1;
    ycover[Yax*Ymax + Ymb] = 1;
    ycover[Ycx*Ymax + Ymb] = 1;
    ycover[Yrx*Ymax + Ymb] = 1;
    ycover[Yrb*Ymax + Ymb] = 1;
    ycover[Ym*Ymax + Ymb] = 1;

    ycover[Yax*Ymax + Yml] = 1;
    ycover[Ycx*Ymax + Yml] = 1;
    ycover[Yrx*Ymax + Yml] = 1;
    ycover[Yrl*Ymax + Yml] = 1;
    ycover[Ym*Ymax + Yml] = 1;

    for(i=0; i<D_NONE; i++) {
        reg[i] = -1;
        if(i >= D_AL && i <= D_BH)
            reg[i] = (i-D_AL) & 7;
        if(i >= D_AX && i <= D_DI)
            reg[i] = (i-D_AX) & 7;
        if(i >= D_F0 && i <= D_F0+7)
            reg[i] = (i-D_F0) & 7;
    }

    zprg.link = P;
    zprg.pcond = P;
    zprg.back = 2;
    zprg.as = AGOK;
    zprg.from.type = D_NONE;
    zprg.from.index = D_NONE;
    zprg.from.scale = 1;
    zprg.to = zprg.from;

    pcstr = "%.6lux ";
    nuxiinit();
    histgen = 0;
    textp = P;
    datap = P;
    edatap = P;
    pc = 0;
    dtype = 4;
    cout = create(outfile, 1, 0775);
    if(cout < 0) {
        diag("cannot create %s: %r", outfile);
        errorexit();
    }
    version = 0;
    cbp = buf.cbuf;
    cbc = sizeof(buf.cbuf);
    firstp = prg();
    lastp = firstp;

    if(INITENTRY == 0) {
        INITENTRY = "_main";
        if(debug['p'])
            INITENTRY = "_mainp";
        if(!debug['l'])
            lookup(INITENTRY, 0)->type = SXREF;
    } else if(!(*INITENTRY >= '0' && *INITENTRY <= '9'))
        lookup(INITENTRY, 0)->type = SXREF;

    while(*argv)
        objfile(*argv++);
    if(!debug['l'])
        loadlib();
    firstp = firstp->link;
    if(firstp == P)
        errorexit();
    if(doexp || dlm){
        EXPTAB = "_exporttab";
        zerosig(EXPTAB);
        zerosig("etext");
        zerosig("edata");
        zerosig("end");
        if(dlm){
            import();
            HEADTYPE = 2;
            INITTEXT = INITDAT = 0;
            INITRND = 8;
            INITENTRY = EXPTAB;
        }
        export();
    }
    patch();
    follow();
    dodata();
    dostkoff();
    if(debug['p'])
        if(debug['1'])
            doprof1();
        else
            doprof2();
    span();
    doinit();
    asmb();
    undef();
    if(debug['v']) {
        Bprint(&bso, "%5.2f cpu time\n", cputime());
        Bprint(&bso, "%ld symbols\n", nsymbol);
        Bprint(&bso, "%ld memory used\n", thunk);
        Bprint(&bso, "%d sizeof adr\n", sizeof(Adr));
        Bprint(&bso, "%d sizeof prog\n", sizeof(Prog));
    }
    Bflush(&bso);

    errorexit();
}
@
%$ 

<<function addlibpath>>=
void
addlibpath(char *arg)
{
    char **p;

    if(nlibdir >= maxlibdir) {
        if(maxlibdir == 0)
            maxlibdir = 8;
        else
            maxlibdir *= 2;
        p = malloc(maxlibdir*sizeof(*p));
        if(p == nil) {
            diag("out of memory");
            errorexit();
        }
        memmove(p, libdir, nlibdir*sizeof(*p));
        free(libdir);
        libdir = p;
    }
    libdir[nlibdir++] = strdup(arg);
}
@

<<function findlib>>=
char*
findlib(char *file)
{
    int i;
    char name[LIBNAMELEN];

    for(i = 0; i < nlibdir; i++) {
        snprint(name, sizeof(name), "%s/%s", libdir[i], file);
        if(fileexists(name))
            return libdir[i];
    }
    return nil;
}
@

<<function loadlib>>=
void
loadlib(void)
{
    int i;
    long h;
    Sym *s;

loop:
    xrefresolv = 0;
    for(i=0; i<libraryp; i++) {
        if(debug['v'])
            Bprint(&bso, "%5.2f autolib: %s (from %s)\n", cputime(), library[i], libraryobj[i]);
        objfile(library[i]);
    }
    if(xrefresolv)
    for(h=0; h<nelem(hash); h++)
    for(s = hash[h]; s != S; s = s->link)
        if(s->type == SXREF)
            goto loop;
}
@


<<function objfile>>=
void
objfile(char *file)
{
    long off, esym, cnt, l;
    int f, work;
    Sym *s;
    char magbuf[SARMAG];
    char name[LIBNAMELEN], pname[LIBNAMELEN];
    struct ar_hdr arhdr;
    char *e, *start, *stop;

    if(debug['v'])
        Bprint(&bso, "%5.2f ldobj: %s\n", cputime(), file);
    Bflush(&bso);
    if(file[0] == '-' && file[1] == 'l') {
        snprint(pname, sizeof(pname), "lib%s.a", file+2);
        e = findlib(pname);
        if(e == nil) {
            diag("cannot find library: %s", file);
            errorexit();
        }
        snprint(name, sizeof(name), "%s/%s", e, pname);
        file = name;
    }
    f = open(file, 0);
    if(f < 0) {
        diag("cannot open %s: %r", file);
        errorexit();
    }
    l = read(f, magbuf, SARMAG);
    if(l != SARMAG || strncmp(magbuf, ARMAG, SARMAG)){
        /* load it as a regular file */
        l = seek(f, 0L, 2);
        seek(f, 0L, 0);
        ldobj(f, l, file);
        close(f);
        return;
    }

    l = read(f, &arhdr, SAR_HDR);
    if(l != SAR_HDR) {
        diag("%s: short read on archive file symbol header", file);
        goto out;
    }
    if(strncmp(arhdr.name, symname, strlen(symname))) {
        diag("%s: first entry not symbol header", file);
        goto out;
    }

    esym = SARMAG + SAR_HDR + atolwhex(arhdr.size);
    off = SARMAG + SAR_HDR;

    /*
     * just bang the whole symbol file into memory
     */
    seek(f, off, 0);
    cnt = esym - off;
    start = malloc(cnt + 10);
    cnt = read(f, start, cnt);
    if(cnt <= 0){
        close(f);
        return;
    }
    stop = &start[cnt];
    memset(stop, 0, 10);

    work = 1;
    while(work) {
        if(debug['v'])
            Bprint(&bso, "%5.2f library pass: %s\n", cputime(), file);
        Bflush(&bso);
        work = 0;
        for(e = start; e < stop; e = strchr(e+5, 0) + 1) {
            s = lookup(e+5, 0);
            if(s->type != SXREF)
                continue;
            sprint(pname, "%s(%s)", file, s->name);
            if(debug['v'])
                Bprint(&bso, "%5.2f library: %s\n", cputime(), pname);
            Bflush(&bso);
            l = e[1] & 0xff;
            l |= (e[2] & 0xff) << 8;
            l |= (e[3] & 0xff) << 16;
            l |= (e[4] & 0xff) << 24;
            seek(f, l, 0);
            /* need readn to read the dumps (at least) */
            l = readn(f, &arhdr, SAR_HDR);
            if(l != SAR_HDR)
                goto bad;
            if(strncmp(arhdr.fmag, ARFMAG, sizeof(arhdr.fmag)))
                goto bad;
            l = atolwhex(arhdr.size);
            ldobj(f, l, pname);
            if(s->type == SXREF) {
                diag("%s: failed to load: %s", file, s->name);
                errorexit();
            }
            work = 1;
            xrefresolv = 1;
        }
    }
    return;

bad:
    diag("%s: bad or out of date archive", file);
out:
    close(f);
}
@

<<function zaddr>>=
int
zaddr(uchar *p, Adr *a, Sym *h[])
{
    int c, t, i;
    int l;
    Sym *s;
    Auto *u;

    t = p[0];

    c = 1;
    if(t & T_INDEX) {
        a->index = p[c];
        a->scale = p[c+1];
        c += 2;
    } else {
        a->index = D_NONE;
        a->scale = 0;
    }
    a->offset = 0;
    if(t & T_OFFSET) {
        a->offset = p[c] | (p[c+1]<<8) | (p[c+2]<<16) | (p[c+3]<<24);
        c += 4;
    }
    a->sym = S;
    if(t & T_SYM) {
        a->sym = h[p[c]];
        c++;
    }
    a->type = D_NONE;
    if(t & T_FCONST) {
        a->ieee.l = p[c] | (p[c+1]<<8) | (p[c+2]<<16) | (p[c+3]<<24);
        a->ieee.h = p[c+4] | (p[c+5]<<8) | (p[c+6]<<16) | (p[c+7]<<24);
        c += 8;
        a->type = D_FCONST;
    } else
    if(t & T_SCONST) {
        for(i=0; i<NSNAME; i++)
            a->scon[i] = p[c+i];
        c += NSNAME;
        a->type = D_SCONST;
    }
    if(t & T_TYPE) {
        a->type = p[c];
        c++;
    }
    s = a->sym;
    if(s == S)
        return c;

    t = a->type;
    if(t != D_AUTO && t != D_PARAM)
        return c;
    l = a->offset;
    for(u=curauto; u; u=u->link) {
        if(u->asym == s)
        if(u->type == t) {
            if(u->aoffset > l)
                u->aoffset = l;
            return c;
        }
    }

    while(nhunk < sizeof(Auto))
        gethunk();
    u = (Auto*)hunk;
    nhunk -= sizeof(Auto);
    hunk += sizeof(Auto);

    u->link = curauto;
    curauto = u;
    u->asym = s;
    u->aoffset = l;
    u->type = t;
    return c;
}
@

% >> >> >> >> >> >> >> >> >> >> >> >>

<<function addlib>>=
void
addlib(char *obj)
{
    char fn1[LIBNAMELEN], fn2[LIBNAMELEN], comp[LIBNAMELEN], *p, *name;
    int i, search;

    if(histfrogp <= 0)
        return;

    name = fn1;
    search = 0;
    if(histfrog[0]->name[1] == '/') {
        sprint(name, "");
        i = 1;
    } else if(histfrog[0]->name[1] == '.') {
        sprint(name, ".");
        i = 0;
    } else {
        sprint(name, "");
        i = 0;
        search = 1;
    }

    for(; i<histfrogp; i++) {
        snprint(comp, sizeof comp, histfrog[i]->name+1);
        for(;;) {
            p = strstr(comp, "$O");
            if(p == 0)
                break;
            memmove(p+1, p+2, strlen(p+2)+1);
            p[0] = thechar;
        }
        for(;;) {
            p = strstr(comp, "$M");
            if(p == 0)
                break;
            if(strlen(comp)+strlen(thestring)-2+1 >= sizeof comp) {
                diag("library component too long");
                return;
            }
            memmove(p+strlen(thestring), p+2, strlen(p+2)+1);
            memmove(p, thestring, strlen(thestring));
        }
        if(strlen(fn1) + strlen(comp) + 3 >= sizeof(fn1)) {
            diag("library component too long");
            return;
        }
        if(i > 0 || !search)
            strcat(fn1, "/");
        strcat(fn1, comp);
    }

    cleanname(name);

    if(search){
        p = findlib(name);
        if(p != nil){
            snprint(fn2, sizeof(fn2), "%s/%s", p, name);
            name = fn2;
        }
    }

    for(i=0; i<libraryp; i++)
        if(strcmp(name, library[i]) == 0)
            return;
    if(libraryp == nelem(library)){
        diag("too many autolibs; skipping %s", name);
        return;
    }

    p = malloc(strlen(name) + 1);
    strcpy(p, name);
    library[libraryp] = p;
    p = malloc(strlen(obj) + 1);
    strcpy(p, obj);
    libraryobj[libraryp] = p;
    libraryp++;
}
@

<<function addhist>>=
void
addhist(long line, int type)
{
    Auto *u;
    Sym *s;
    int i, j, k;

    u = malloc(sizeof(Auto));
    s = malloc(sizeof(Sym));
    s->name = malloc(2*(histfrogp+1) + 1);

    u->asym = s;
    u->type = type;
    u->aoffset = line;
    u->link = curhist;
    curhist = u;

    j = 1;
    for(i=0; i<histfrogp; i++) {
        k = histfrog[i]->value;
        s->name[j+0] = k>>8;
        s->name[j+1] = k;
        j += 2;
    }
}
@

<<function histtoauto>>=
void
histtoauto(void)
{
    Auto *l;

    while(l = curhist) {
        curhist = l->link;
        l->link = curauto;
        curauto = l;
    }
}
@

<<function collapsefrog>>=
void
collapsefrog(Sym *s)
{
    int i;

    /*
     * bad encoding of path components only allows
     * MAXHIST components. if there is an overflow,
     * first try to collapse xxx/..
     */
    for(i=1; i<histfrogp; i++)
        if(strcmp(histfrog[i]->name+1, "..") == 0) {
            memmove(histfrog+i-1, histfrog+i+1,
                (histfrogp-i-1)*sizeof(histfrog[0]));
            histfrogp--;
            goto out;
        }

    /*
     * next try to collapse .
     */
    for(i=0; i<histfrogp; i++)
        if(strcmp(histfrog[i]->name+1, ".") == 0) {
            memmove(histfrog+i, histfrog+i+1,
                (histfrogp-i-1)*sizeof(histfrog[0]));
            goto out;
        }

    /*
     * last chance, just truncate from front
     */
    memmove(histfrog+0, histfrog+1,
        (histfrogp-1)*sizeof(histfrog[0]));

out:
    histfrog[histfrogp-1] = s;
}
@

<<function nopout>>=
void
nopout(Prog *p)
{
    p->as = ANOP;
    p->from.type = D_NONE;
    p->to.type = D_NONE;
}
@

<<function readsome>>=
uchar*
readsome(int f, uchar *buf, uchar *good, uchar *stop, int max)
{
    int n;

    n = stop - good;
    memmove(buf, good, stop - good);
    stop = buf + n;
    n = MAXIO - n;
    if(n > max)
        n = max;
    n = read(f, stop, n);
    if(n <= 0)
        return 0;
    return stop + n;
}
@

<<function ldobj>>=
void
ldobj(int f, long c, char *pn)
{
    long ipc;
    Prog *p, *t;
    uchar *bloc, *bsize, *stop;
    int v, o, r, skip;
    Sym *h[NSYM], *s, *di;
    ulong sig;
    static int files;
    static char **filen;
    char **nfilen;

    if((files&15) == 0){
        nfilen = malloc((files+16)*sizeof(char*));
        memmove(nfilen, filen, files*sizeof(char*));
        free(filen);
        filen = nfilen;
    }
    filen[files++] = strdup(pn);

    bsize = buf.xbuf;
    bloc = buf.xbuf;
    di = S;

newloop:
    memset(h, 0, sizeof(h));
    version++;
    histfrogp = 0;
    ipc = pc;
    skip = 0;

loop:
    if(c <= 0)
        goto eof;
    r = bsize - bloc;
    if(r < 100 && r < c) {		/* enough for largest prog */
        bsize = readsome(f, buf.xbuf, bloc, bsize, c);
        if(bsize == 0)
            goto eof;
        bloc = buf.xbuf;
        goto loop;
    }
    o = bloc[0] | (bloc[1] << 8);
    if(o <= AXXX || o >= ALAST) {
        if(o < 0)
            goto eof;
        diag("%s: opcode out of range %d", pn, o);
        print("	probably not a .8 file\n");
        errorexit();
    }

    if(o == ANAME || o == ASIGNAME) {
        sig = 0;
        if(o == ASIGNAME) {
            sig = bloc[2] | (bloc[3]<<8) | (bloc[4]<<16) | (bloc[5]<<24);
            bloc += 4;
            c -= 4;
        }
        stop = memchr(&bloc[4], 0, bsize-&bloc[4]);
        if(stop == 0){
            bsize = readsome(f, buf.xbuf, bloc, bsize, c);
            if(bsize == 0)
                goto eof;
            bloc = buf.xbuf;
            stop = memchr(&bloc[4], 0, bsize-&bloc[4]);
            if(stop == 0){
                fprint(2, "%s: name too long\n", pn);
                errorexit();
            }
        }
        v = bloc[2];	/* type */
        o = bloc[3];	/* sym */
        bloc += 4;
        c -= 4;

        r = 0;
        if(v == D_STATIC)
            r = version;
        s = lookup((char*)bloc, r);
        c -= &stop[1] - bloc;
        bloc = stop + 1;

        if(debug['S'] && r == 0)
            sig = 1729;
        if(sig != 0){
            if(s->sig != 0 && s->sig != sig)
                diag("incompatible type signatures %lux(%s) and %lux(%s) for %s", s->sig, filen[s->file], sig, pn, s->name);
            s->sig = sig;
            s->file = files-1;
        }

        if(debug['W'])
            print("	ANAME	%s\n", s->name);
        h[o] = s;
        if((v == D_EXTERN || v == D_STATIC) && s->type == 0)
            s->type = SXREF;
        if(v == D_FILE) {
            if(s->type != SFILE) {
                histgen++;
                s->type = SFILE;
                s->value = histgen;
            }
            if(histfrogp < MAXHIST) {
                histfrog[histfrogp] = s;
                histfrogp++;
            } else
                collapsefrog(s);
        }
        goto loop;
    }

    while(nhunk < sizeof(Prog))
        gethunk();
    p = (Prog*)hunk;
    nhunk -= sizeof(Prog);
    hunk += sizeof(Prog);

    p->as = o;
    p->line = bloc[2] | (bloc[3] << 8) | (bloc[4] << 16) | (bloc[5] << 24);
    p->back = 2;
    r = zaddr(bloc+6, &p->from, h) + 6;
    r += zaddr(bloc+r, &p->to, h);
    bloc += r;
    c -= r;

    if(debug['W'])
        print("%P\n", p);

    switch(p->as) {
    case AHISTORY:
        if(p->to.offset == -1) {
            addlib(pn);
            histfrogp = 0;
            goto loop;
        }
        addhist(p->line, D_FILE);		/* 'z' */
        if(p->to.offset)
            addhist(p->to.offset, D_FILE1);	/* 'Z' */
        histfrogp = 0;
        goto loop;

    case AEND:
        histtoauto();
        if(curtext != P)
            curtext->to.autom = curauto;
        curauto = 0;
        curtext = P;
        if(c)
            goto newloop;
        return;

    case AGLOBL:
        s = p->from.sym;
        if(s->type == 0 || s->type == SXREF) {
            s->type = SBSS;
            s->value = 0;
        }
        if(s->type != SBSS) {
            diag("%s: redefinition: %s in %s",
                pn, s->name, TNAME);
            s->type = SBSS;
            s->value = 0;
        }
        if(p->to.offset > s->value)
            s->value = p->to.offset;
        goto loop;

    case ADYNT:
        if(p->to.sym == S) {
            diag("DYNT without a sym\n%P", p);
            break;
        }
        di = p->to.sym;
        p->from.scale = 4;
        if(di->type == SXREF) {
            if(debug['z'])
                Bprint(&bso, "%P set to %d\n", p, dtype);
            di->type = SCONST;
            di->value = dtype;
            dtype += 4;
        }
        if(p->from.sym == S)
            break;

        p->from.offset = di->value;
        p->from.sym->type = SDATA;
        if(curtext == P) {
            diag("DYNT not in text: %P", p);
            break;
        }
        p->to.sym = curtext->from.sym;
        p->to.type = D_ADDR;
        p->to.index = D_EXTERN;
        goto data;

    case AINIT:
        if(p->from.sym == S) {
            diag("INIT without a sym\n%P", p);
            break;
        }
        if(di == S) {
            diag("INIT without previous DYNT\n%P", p);
            break;
        }
        p->from.offset = di->value;
        p->from.sym->type = SDATA;
        goto data;

    case ADATA:
    data:
        if(edatap == P)
            datap = p;
        else
            edatap->link = p;
        edatap = p;
        p->link = P;
        goto loop;

    case AGOK:
        diag("%s: GOK opcode in %s", pn, TNAME);
        pc++;
        goto loop;

    case ATEXT:
        if(curtext != P) {
            histtoauto();
            curtext->to.autom = curauto;
            curauto = 0;
        }
        skip = 0;
        curtext = p;
        s = p->from.sym;
        if(s == S) {
            diag("%s: no TEXT symbol: %P", pn, p);
            errorexit();
        }
        if(s->type != 0 && s->type != SXREF) {
            if(p->from.scale & DUPOK) {
                skip = 1;
                goto casdef;
            }
            diag("%s: redefinition: %s\n%P", pn, s->name, p);
        }
        s->type = STEXT;
        s->value = pc;
        lastp->link = p;
        lastp = p;
        p->pc = pc;
        pc++;
        if(textp == P) {
            textp = p;
            etextp = p;
            goto loop;
        }
        etextp->pcond = p;
        etextp = p;
        goto loop;

    case AFMOVF:
    case AFADDF:
    case AFSUBF:
    case AFSUBRF:
    case AFMULF:
    case AFDIVF:
    case AFDIVRF:
    case AFCOMF:
    case AFCOMFP:
        if(skip)
            goto casdef;
        if(p->from.type == D_FCONST) {
            /* size sb 9 max */
            sprint(literal, "$%lux", ieeedtof(&p->from.ieee));
            s = lookup(literal, 0);
            if(s->type == 0) {
                s->type = SBSS;
                s->value = 4;
                t = prg();
                t->as = ADATA;
                t->line = p->line;
                t->from.type = D_EXTERN;
                t->from.sym = s;
                t->from.scale = 4;
                t->to = p->from;
                if(edatap == P)
                    datap = t;
                else
                    edatap->link = t;
                edatap = t;
                t->link = P;
            }
            p->from.type = D_EXTERN;
            p->from.sym = s;
            p->from.offset = 0;
        }
        goto casdef;

    case AFMOVD:
    case AFADDD:
    case AFSUBD:
    case AFSUBRD:
    case AFMULD:
    case AFDIVD:
    case AFDIVRD:
    case AFCOMD:
    case AFCOMDP:
        if(skip)
            goto casdef;
        if(p->from.type == D_FCONST) {
            /* size sb 18 max */
            sprint(literal, "$%lux.%lux",
                p->from.ieee.l, p->from.ieee.h);
            s = lookup(literal, 0);
            if(s->type == 0) {
                s->type = SBSS;
                s->value = 8;
                t = prg();
                t->as = ADATA;
                t->line = p->line;
                t->from.type = D_EXTERN;
                t->from.sym = s;
                t->from.scale = 8;
                t->to = p->from;
                if(edatap == P)
                    datap = t;
                else
                    edatap->link = t;
                edatap = t;
                t->link = P;
            }
            p->from.type = D_EXTERN;
            p->from.sym = s;
            p->from.offset = 0;
        }
        goto casdef;

    default:
    casdef:
        if(skip)
            nopout(p);

        if(p->to.type == D_BRANCH)
            p->to.offset += ipc;
        lastp->link = p;
        lastp = p;
        p->pc = pc;
        pc++;
        goto loop;
    }
    goto loop;

eof:
    diag("truncated object file: %s", pn);
}
@


<<function appendp>>=
Prog*
appendp(Prog *q)
{
    Prog *p;

    p = prg();
    p->link = q->link;
    q->link = p;
    p->line = q->line;
    return p;
}
@


<<function doprof1>>=
void
doprof1(void)
{
    Sym *s;
    long n;
    Prog *p, *q;

    if(debug['v'])
        Bprint(&bso, "%5.2f profile 1\n", cputime());
    Bflush(&bso);
    s = lookup("__mcount", 0);
    n = 1;
    for(p = firstp->link; p != P; p = p->link) {
        if(p->as == ATEXT) {
            q = prg();
            q->line = p->line;
            q->link = datap;
            datap = q;
            q->as = ADATA;
            q->from.type = D_EXTERN;
            q->from.offset = n*4;
            q->from.sym = s;
            q->from.scale = 4;
            q->to = p->from;
            q->to.type = D_CONST;

            q = prg();
            q->line = p->line;
            q->pc = p->pc;
            q->link = p->link;
            p->link = q;
            p = q;
            p->as = AADDL;
            p->from.type = D_CONST;
            p->from.offset = 1;
            p->to.type = D_EXTERN;
            p->to.sym = s;
            p->to.offset = n*4 + 4;

            n += 2;
            continue;
        }
    }
    q = prg();
    q->line = 0;
    q->link = datap;
    datap = q;

    q->as = ADATA;
    q->from.type = D_EXTERN;
    q->from.sym = s;
    q->from.scale = 4;
    q->to.type = D_CONST;
    q->to.offset = n;

    s->type = SBSS;
    s->value = n*4;
}
@

<<function doprof2>>=
void
doprof2(void)
{
    Sym *s2, *s4;
    Prog *p, *q, *q2, *ps2, *ps4;

    if(debug['v'])
        Bprint(&bso, "%5.2f profile 2\n", cputime());
    Bflush(&bso);

    if(debug['e']){
        s2 = lookup("_tracein", 0);
        s4 = lookup("_traceout", 0);
    }else{
        s2 = lookup("_profin", 0);
        s4 = lookup("_profout", 0);
    }
    if(s2->type != STEXT || s4->type != STEXT) {
        if(debug['e'])
            diag("_tracein/_traceout not defined %d %d", s2->type, s4->type);
        else
            diag("_profin/_profout not defined");
        return;
    }

    ps2 = P;
    ps4 = P;
    for(p = firstp; p != P; p = p->link) {
        if(p->as == ATEXT) {
            if(p->from.sym == s2) {
                p->from.scale = 1;
                ps2 = p;
            }
            if(p->from.sym == s4) {
                p->from.scale = 1;
                ps4 = p;
            }
        }
    }
    for(p = firstp; p != P; p = p->link) {
        if(p->as == ATEXT) {
            curtext = p;

            if(p->from.scale & NOPROF) {	/* dont profile */
                for(;;) {
                    q = p->link;
                    if(q == P)
                        break;
                    if(q->as == ATEXT)
                        break;
                    p = q;
                }
                continue;
            }

            /*
             * JMPL	profin
             */
            q = prg();
            q->line = p->line;
            q->pc = p->pc;
            q->link = p->link;
            if(debug['e']){		/* embedded tracing */
                q2 = prg();
                p->link = q2;
                q2->link = q;

                q2->line = p->line;
                q2->pc = p->pc;

                q2->as = AJMP;
                q2->to.type = D_BRANCH;
                q2->to.sym = p->to.sym;
                q2->pcond = q->link;
            }else
                p->link = q;
            p = q;
            p->as = ACALL;
            p->to.type = D_BRANCH;
            p->pcond = ps2;
            p->to.sym = s2;

            continue;
        }
        if(p->as == ARET) {
            /*
             * RET (default)
             */
            if(debug['e']){		/* embedded tracing */
                q = prg();
                q->line = p->line;
                q->pc = p->pc;
                q->link = p->link;
                p->link = q;
                p = q;
            }
            /*
             * RET
             */
            q = prg();
            q->as = ARET;
            q->from = p->from;
            q->to = p->to;
            q->link = p->link;
            p->link = q;

            /*
             * JAL	profout
             */
            p->as = ACALL;
            p->from = zprg.from;
            p->to = zprg.to;
            p->to.type = D_BRANCH;
            p->pcond = ps4;
            p->to.sym = s4;

            p = q;

            continue;
        }
    }
}
@

<<function nuxiinit>>=
void
nuxiinit(void)
{
    int i, c;

    for(i=0; i<4; i++) {
        c = find1(0x04030201L, i+1);
        if(i < 2)
            inuxi2[i] = c;
        if(i < 1)
            inuxi1[i] = c;
        inuxi4[i] = c;
        fnuxi4[i] = c;
        fnuxi8[i] = c;
        fnuxi8[i+4] = c+4;
    }
    if(debug['v']) {
        Bprint(&bso, "inuxi = ");
        for(i=0; i<1; i++)
            Bprint(&bso, "%d", inuxi1[i]);
        Bprint(&bso, " ");
        for(i=0; i<2; i++)
            Bprint(&bso, "%d", inuxi2[i]);
        Bprint(&bso, " ");
        for(i=0; i<4; i++)
            Bprint(&bso, "%d", inuxi4[i]);
        Bprint(&bso, "\nfnuxi = ");
        for(i=0; i<4; i++)
            Bprint(&bso, "%d", fnuxi4[i]);
        Bprint(&bso, " ");
        for(i=0; i<8; i++)
            Bprint(&bso, "%d", fnuxi8[i]);
        Bprint(&bso, "\n");
    }
    Bflush(&bso);
}
@

<<function find1>>=
int
find1(long l, int c)
{
    char *p;
    int i;

    p = (char*)&l;
    for(i=0; i<4; i++)
        if(*p++ == c)
            return i;
    return 0;
}
@

<<function find2>>=
//int
//find2(long l, int c)
//{
//    short *p;
//    int i;
//
//    p = (short*)&l;
//    for(i=0; i<4; i+=2) {
//        if(((*p >> 8) & 0xff) == c)
//            return i;
//        if((*p++ & 0xff) == c)
//            return i+1;
//    }
//    return 0;
//}
@

<<function ieeedtof>>=
long
ieeedtof(Ieee *e)
{
    int exp;
    long v;

    if(e->h == 0)
        return 0;
    exp = (e->h>>20) & ((1L<<11)-1L);
    exp -= (1L<<10) - 2L;
    v = (e->h & 0xfffffL) << 3;
    v |= (e->l >> 29) & 0x7L;
    if((e->l >> 28) & 1) {
        v++;
        if(v & 0x800000L) {
            v = (v & 0x7fffffL) >> 1;
            exp++;
        }
    }
    if(exp <= -126 || exp >= 130)
        diag("double fp to single fp overflow");
    v |= ((exp + 126) & 0xffL) << 23;
    v |= e->h & 0x80000000L;
    return v;
}
@

<<function ieeedtod>>=
double
ieeedtod(Ieee *ieeep)
{
    Ieee e;
    double fr;
    int exp;

    if(ieeep->h & (1L<<31)) {
        e.h = ieeep->h & ~(1L<<31);
        e.l = ieeep->l;
        return -ieeedtod(&e);
    }
    if(ieeep->l == 0 && ieeep->h == 0)
        return 0;
    fr = ieeep->l & ((1L<<16)-1L);
    fr /= 1L<<16;
    fr += (ieeep->l>>16) & ((1L<<16)-1L);
    fr /= 1L<<16;
    fr += (ieeep->h & (1L<<20)-1L) | (1L<<20);
    fr /= 1L<<21;
    exp = (ieeep->h>>20) & ((1L<<11)-1L);
    exp -= (1L<<10) - 2L;
    return ldexp(fr, exp);
}
@

<<function undefsym>>=
void
undefsym(Sym *s)
{
    int n;

    n = imports;
    if(s->value != 0)
        diag("value != 0 on SXREF");
    if(n >= 1<<Rindex)
        diag("import index %d out of range", n);
    s->value = n<<Roffset;
    s->type = SUNDEF;
    imports++;
}
@

<<function zerosig>>=
void
zerosig(char *sp)
{
    Sym *s;

    s = lookup(sp, 0);
    s->sig = 0;
}
@

<<function readundefs>>=
void
readundefs(char *f, int t)
{
    int i, n;
    Sym *s;
    Biobuf *b;
    char *l, buf[256], *fields[64];

    if(f == nil)
        return;
    b = Bopen(f, OREAD);
    if(b == nil){
        diag("could not open %s: %r", f);
        errorexit();
    }
    while((l = Brdline(b, '\n')) != nil){
        n = Blinelen(b);
        if(n >= sizeof(buf)){
            diag("%s: line too long", f);
            errorexit();
        }
        memmove(buf, l, n);
        buf[n-1] = '\0';
        n = getfields(buf, fields, nelem(fields), 1, " \t\r\n");
        if(n == nelem(fields)){
            diag("%s: bad format", f);
            errorexit();
        }
        for(i = 0; i < n; i++){
            s = lookup(fields[i], 0);
            s->type = SXREF;
            s->subtype = t;
            if(t == SIMPORT)
                nimports++;
            else
                nexports++;
        }
    }
    Bterm(b);
}
@


%-------------------------------------------------------------

<<linkers/8l/obj.c>>=
#include	"l.h"
#include	<ar.h>

#ifndef	DEFAULT
<<constant DEFAULT>>
#endif

<<global histfrog>>
<<global curauto>>
<<global histfrogp>>
<<global curhist>>
<<global etextp>>
<<global histgen>>
<<global library>>
<<global libraryobj>>
<<global libraryp>>
<<global xrefresolv>>
<<global version>>
<<global literal>>
int	doexp;

void	addlibpath(char*);
char*	findlib(char*);
void	loadlib(void);
void	objfile(char*);

int	zaddr(uchar*, Adr*, Sym*[]);
long	vaddr(Adr*);

void	addhist(long, int);
void	histtoauto(void);
void	ldobj(int, long, char*);

void	doprof1(void);
void	doprof2(void);
void	nuxiinit(void);

int	find1(long, int);
//int	find2(long, int);

double	ieeedtod(Ieee*);

void	zerosig(char*);
void	readundefs(char*, int);
Prog*	brchain(Prog*);






<<global noname (linkers/8l/obj.c)>>
<<global symname (linkers/8l/obj.c)>>
<<global thechar>>
<<global thestring>>

<<global libdir>>
<<global nlibdir>>
<<global maxlibdir>>

<<function usage (linkers/8l/obj.c)>>

<<function isobjfile>>

<<function main (linkers/8l/obj.c)>>

<<function addlibpath>>

<<function findlib>>

<<function loadlib>>

<<function objfile>>

<<function zaddr>>

<<function addlib>>

<<function addhist>>

<<function histtoauto>>

<<function collapsefrog>>

<<function nopout>>

<<function readsome>>

<<function ldobj>>

<<function appendp>>

<<function doprof1>>

<<function doprof2>>

<<function nuxiinit>>

<<function find1>>

<<function find2>>

<<function ieeedtof>>

<<function ieeedtod>>

<<function undefsym>>

<<function zerosig>>

<<function readundefs>>
@


\section{[[linkers/libmach/]]}

\subsection*{[[linkers/libmach/8.c]]}

<<function REGOFF>>=
#define	REGOFF(x)	(ulong)(&((struct Ureg *) 0)->x)
@

<<constant PC>>=
#define PC		REGOFF(pc)
@

<<constant SP>>=
#define SP		REGOFF(sp)
@

<<constant AX>>=
#define	AX		REGOFF(ax)
@

<<constant REGSIZE>>=
#define	REGSIZE		sizeof(struct Ureg)
@

<<function FP_CTL>>=
#define FP_CTL(x)	(REGSIZE+4*(x))
@

<<function FP_REG>>=
#define FP_REG(x)	(FP_CTL(7)+10*(x))
@

<<constant FPREGSIZE>>=
#define	FPREGSIZE	(7*4+8*10)
@

<<global i386reglist>>=
Reglist i386reglist[] = {
    {"DI",		REGOFF(di),	RINT, 'X'},
    {"SI",		REGOFF(si),	RINT, 'X'},
    {"BP",		REGOFF(bp),	RINT, 'X'},
    {"BX",		REGOFF(bx),	RINT, 'X'},
    {"DX",		REGOFF(dx),	RINT, 'X'},
    {"CX",		REGOFF(cx),	RINT, 'X'},
    {"AX",		REGOFF(ax),	RINT, 'X'},
    {"GS",		REGOFF(gs),	RINT, 'X'},
    {"FS",		REGOFF(fs),	RINT, 'X'},
    {"ES",		REGOFF(es),	RINT, 'X'},
    {"DS",		REGOFF(ds),	RINT, 'X'},
    {"TRAP",	REGOFF(trap), 	RINT, 'X'},
    {"ECODE",	REGOFF(ecode),	RINT, 'X'},
    {"PC",		PC,		RINT, 'X'},
    {"CS",		REGOFF(cs),	RINT, 'X'},
    {"EFLAGS",	REGOFF(flags),	RINT, 'X'},
    {"SP",		SP,		RINT, 'X'},
    {"SS",		REGOFF(ss),	RINT, 'X'},

    {"E0",		FP_CTL(0),	RFLT, 'X'},
    {"E1",		FP_CTL(1),	RFLT, 'X'},
    {"E2",		FP_CTL(2),	RFLT, 'X'},
    {"E3",		FP_CTL(3),	RFLT, 'X'},
    {"E4",		FP_CTL(4),	RFLT, 'X'},
    {"E5",		FP_CTL(5),	RFLT, 'X'},
    {"E6",		FP_CTL(6),	RFLT, 'X'},
    {"F0",		FP_REG(0),	RFLT, '3'},
    {"F1",		FP_REG(1),	RFLT, '3'},
    {"F2",		FP_REG(2),	RFLT, '3'},
    {"F3",		FP_REG(3),	RFLT, '3'},
    {"F4",		FP_REG(4),	RFLT, '3'},
    {"F5",		FP_REG(5),	RFLT, '3'},
    {"F6",		FP_REG(6),	RFLT, '3'},
    {"F7",		FP_REG(7),	RFLT, '3'},
    {  0 }
};
@

<<global mi386>>=
Mach mi386 =
{
    "386",
    MI386,		/* machine type */
    i386reglist,	/* register list */
    REGSIZE,	/* size of registers in bytes */
    FPREGSIZE,	/* size of fp registers in bytes */
    "PC",		/* name of PC */
    "SP",		/* name of SP */
    0,		/* link register */
    "setSB",	/* static base register name (bogus anyways) */
    0,		/* static base register value */
    0x1000,		/* page size */
    0xF0100000ULL,	/* kernel base */
    0xF0000000ULL,	/* kernel text mask */
    0x7FFFFFFFULL,	/* user stack top */
    1,		/* quantization of pc */
    4,		/* szaddr */
    4,		/* szreg */
    4,		/* szfloat */
    8,		/* szdouble */
};
@


%-------------------------------------------------------------

<<linkers/libmach/8.c>>=
/*
 * 386 definition
 */
#include <u.h>
#include <libc.h>
#include <bio.h>
#include "/386/include/ureg.h"
#include <mach.h>

<<function REGOFF>>

<<constant PC>>
<<constant SP>>
<<constant AX>>

<<constant REGSIZE>>
<<function FP_CTL>>
<<function FP_REG>>
<<constant FPREGSIZE>>

<<global i386reglist>>

<<global mi386>>
@


\subsection*{[[linkers/libmach/elf.h]]}

<<constant LOAD>>=
//TODO: could remove this file?
#define LOAD PT_LOAD
@


%-------------------------------------------------------------

<<linkers/libmach/elf.h>>=
// see include/elf.h
#include <elf.h>

<<constant LOAD>>

@


\subsection*{[[linkers/libmach/obj.h]]}

<<struct Prog (linkers/libmach/obj.h)>>=
struct Prog		/* info from .$O files */
{
    Kind	kind;		/* what kind of symbol */
    char	type;		/* type of the symbol: ie, 'T', 'a', etc. */
    char	sym;		/* index of symbol's name */
    char	*id;		/* name for the symbol, if it introduces one */
    uint	sig;		/* type signature for symbol */
};
@
%$

<<constant UNKNOWN>>=
#define UNKNOWN	'?'
@


%-------------------------------------------------------------

<<linkers/libmach/obj.h>>=
/*
 * obj.h -- defs for dealing with object files
 */

typedef enum Kind		/* variable defs and references in obj */
{
    aNone,			/* we don't care about this prog */
    aName,			/* introduces a name */
    aText,			/* starts a function */
    aData,			/* references to a global object */
} Kind;

typedef struct	Prog	Prog;

<<struct Prog (linkers/libmach/obj.h)>>

<<constant UNKNOWN>>
void		_offset(int, vlong);
@


\subsection*{[[linkers/libmach/swap.c]]}

<<function beswab>>=
/*
 * big-endian short
 */
ushort
beswab(ushort s)
{
    uchar *p;

    p = (uchar*)&s;
    return (p[0]<<8) | p[1];
}
@

<<function beswal>>=
/*
 * big-endian long
 */
ulong
beswal(ulong l)
{
    uchar *p;

    p = (uchar*)&l;
    return (p[0]<<24) | (p[1]<<16) | (p[2]<<8) | p[3];
}
@

<<function beswav>>=
/*
 * big-endian vlong
 */
uvlong
beswav(uvlong v)
{
    uchar *p;

    p = (uchar*)&v;
    return ((uvlong)p[0]<<56) | ((uvlong)p[1]<<48) | ((uvlong)p[2]<<40)
                  | ((uvlong)p[3]<<32) | ((uvlong)p[4]<<24)
                  | ((uvlong)p[5]<<16) | ((uvlong)p[6]<<8)
                  | (uvlong)p[7];
}
@

<<function leswab>>=
/*
 * little-endian short
 */
ushort
leswab(ushort s)
{
    uchar *p;

    p = (uchar*)&s;
    return (p[1]<<8) | p[0];
}
@

<<function leswal>>=
/*
 * little-endian long
 */
ulong
leswal(ulong l)
{
    uchar *p;

    p = (uchar*)&l;
    return (p[3]<<24) | (p[2]<<16) | (p[1]<<8) | p[0];
}
@

<<function leswav>>=
/*
 * little-endian vlong
 */
uvlong
leswav(uvlong v)
{
    uchar *p;

    p = (uchar*)&v;
    return ((uvlong)p[7]<<56) | ((uvlong)p[6]<<48) | ((uvlong)p[5]<<40)
                  | ((uvlong)p[4]<<32) | ((uvlong)p[3]<<24)
                  | ((uvlong)p[2]<<16) | ((uvlong)p[1]<<8)
                  | (uvlong)p[0];
}
@


%-------------------------------------------------------------

<<linkers/libmach/swap.c>>=
#include <u.h>

<<function beswab>>

<<function beswal>>

<<function beswav>>

<<function leswab>>

<<function leswal>>

<<function leswav>>
@


\subsection*{[[linkers/libmach/executable.c]]}

<<struct Exectable>>=
/*
 *	definition of per-executable file type structures
 */

typedef struct Exectable{
    long	magic;			/* big-endian magic number of file */
    char	*name;			/* executable identifier */
    char	*dlmname;		/* dynamically loadable module identifier */
    uchar	type;			/* Internal code */
    uchar	_magic;			/* _MAGIC() magic */
    Mach	*mach;			/* Per-machine data */
    long	hsize;			/* header size */
    ulong	(*swal)(ulong);		/* beswal or leswal */
    int	(*hparse)(int, Fhdr*, ExecHdr*);
} ExecTable;
@

<<global exectab>>=
ExecTable exectab[] =
{
    { V_MAGIC,			/* Mips v.out */
        "mips plan 9 executable BE",
        "mips plan 9 dlm BE",
        FMIPS,
        1,
        &mmips,
        sizeof(Exec),
        beswal,
        adotout },
    { P_MAGIC,			/* Mips 0.out (r3k le) */
        "mips plan 9 executable LE",
        "mips plan 9 dlm LE",
        FMIPSLE,
        1,
        &mmips,
        sizeof(Exec),
        beswal,
        adotout },
    { 0x160<<16,			/* Mips boot image */
        "mips plan 9 boot image",
        nil,
        FMIPSB,
        0,
        &mmips,
        sizeof(struct mipsexec),
        beswal,
        mipsboot },
    { I_MAGIC,			/* I386 8.out & boot image */
        "386 plan 9 executable",
        "386 plan 9 dlm",
        FI386,
        1,
        &mi386,
        sizeof(Exec),
        beswal,
        common },
    { ELF_MAG,			/* any ELF */
        "elf executable",
        nil,
        FNONE,
        0,
        &mi386,
        sizeof(Ehdr),
        nil,
        elfdotout },
    { E_MAGIC,			/* Arm 5.out and boot image */
        "arm plan 9 executable",
        "arm plan 9 dlm",
        FARM,
        1,
        &marm,
        sizeof(Exec),
        beswal,
        common },

    { 0 },
};
@

<<global mach>>=
Mach	*mach = &mi386;			/* Global current machine table */
@

<<function couldbe4k>>=
static ExecTable*
couldbe4k(ExecTable *mp)
{
    Dir *d;
    ExecTable *f;

    if((d=dirstat("/proc/1/regs")) == nil)
        return mp;
    if(d->length < 32*8){		/* R3000 */
        free(d);
        return mp;
    }
    free(d);
    for (f = exectab; f->magic; f++)
        if(f->magic == M_MAGIC) {
            f->name = "mips plan 9 executable on mips2 kernel";
            return f;
        }
    return mp;
}
@

<<function crackhdr>>=
int
crackhdr(int fd, Fhdr *fp)
{
    ExecTable *mp;
    ExecHdr d;
    int nb, ret;
    ulong magic;

    fp->type = FNONE;
    nb = read(fd, (char *)&d.e, sizeof(d.e));
    if (nb <= 0)
        return 0;

    ret = 0;
    magic = beswal(d.e.magic);		/* big-endian */
    for (mp = exectab; mp->magic; mp++) {
        if (nb < mp->hsize)
            continue;

        /*
         * The magic number has morphed into something
         * with fields (the straw was DYN_MAGIC) so now
         * a flag is needed in Fhdr to distinguish _MAGIC()
         * magic numbers from foreign magic numbers.
         *
         * This code is creaking a bit and if it has to
         * be modified/extended much more it's probably
         * time to step back and redo it all.
         */
        if(mp->_magic){
            if(mp->magic != (magic & ~DYN_MAGIC))
                continue;

            if(mp->magic == V_MAGIC)
                mp = couldbe4k(mp);

            if ((magic & DYN_MAGIC) && mp->dlmname != nil)
                fp->name = mp->dlmname;
            else
                fp->name = mp->name;
        }
        else{
            if(mp->magic != magic)
                continue;
            fp->name = mp->name;
        }
        fp->type = mp->type;
        fp->hdrsz = mp->hsize;		/* will be zero on bootables */
        fp->_magic = mp->_magic;
        fp->magic = magic;

        mach = mp->mach;
        if(mp->swal != nil)
            hswal(&d, sizeof(d.e)/sizeof(ulong), mp->swal);
        ret = mp->hparse(fd, fp, &d);
        seek(fd, mp->hsize, 0);		/* seek to end of header */
        break;
    }
    if(mp->magic == 0)
        werrstr("unknown header type");
    return ret;
}
@

<<function hswal>>=
/*
 * Convert header to canonical form
 */
static void
hswal(void *v, int n, ulong (*swap)(ulong))
{
    ulong *ulp;

    for(ulp = v; n--; ulp++)
        *ulp = (*swap)(*ulp);
}
@

<<function adotout>>=
/*
 *	Crack a normal a.out-type header
 */
static int
adotout(int fd, Fhdr *fp, ExecHdr *hp)
{
    long pgsize;

    USED(fd);
    pgsize = mach->pgsize;
    settext(fp, hp->e.entry, pgsize+sizeof(Exec),
            hp->e.text, sizeof(Exec));
    setdata(fp, _round(pgsize+fp->txtsz+sizeof(Exec), pgsize),
        hp->e.data, fp->txtsz+sizeof(Exec), hp->e.bss);
    setsym(fp, hp->e.syms, hp->e.spsz, hp->e.pcsz, fp->datoff+fp->datsz);
    return 1;
}
@

<<function commonboot>>=
static void
commonboot(Fhdr *fp)
{
    if (!(fp->entry & mach->ktmask))
        return;

    switch(fp->type) {				/* boot image */
    case F68020:
        fp->type = F68020B;
        fp->name = "68020 plan 9 boot image";
        break;
    case FI386:
        fp->type = FI386B;
        fp->txtaddr = (u32int)fp->entry;
        fp->name = "386 plan 9 boot image";
        fp->dataddr = _round(fp->txtaddr+fp->txtsz, mach->pgsize);
        break;
    case FARM:
        fp->type = FARMB;
        fp->txtaddr = (u32int)fp->entry;
        fp->name = "ARM plan 9 boot image";
        fp->dataddr = _round(fp->txtaddr+fp->txtsz, mach->pgsize);
        return;
    case FALPHA:
        fp->type = FALPHAB;
        fp->txtaddr = (u32int)fp->entry;
        fp->name = "alpha plan 9 boot image";
        fp->dataddr = fp->txtaddr+fp->txtsz;
        break;
    case FPOWER:
        fp->type = FPOWERB;
        fp->txtaddr = (u32int)fp->entry;
        fp->name = "power plan 9 boot image";
        fp->dataddr = fp->txtaddr+fp->txtsz;
        break;
    case FAMD64:
        fp->type = FAMD64B;
        fp->txtaddr = fp->entry;
        fp->name = "amd64 plan 9 boot image";
        fp->dataddr = _round(fp->txtaddr+fp->txtsz, 4096);
        break;
    case FPOWER64:
        fp->type = FPOWER64B;
        fp->txtaddr = fp->entry;
        fp->name = "power64 plan 9 boot image";
        fp->dataddr = fp->txtaddr+fp->txtsz;
        break;
    default:
        return;
    }
    fp->hdrsz = 0;			/* header stripped */
}
@

<<function common>>=
/*
 *	_MAGIC() style headers and
 *	alpha plan9-style bootable images for axp "headerless" boot
 *
 */
static int
common(int fd, Fhdr *fp, ExecHdr *hp)
{
    adotout(fd, fp, hp);
    if(hp->e.magic & DYN_MAGIC) {
        fp->txtaddr = 0;
        fp->dataddr = fp->txtsz;
        return 1;
    }
    commonboot(fp);
    return 1;
}
@

<<function commonllp64>>=
static int
commonllp64(int, Fhdr *fp, ExecHdr *hp)
{
    long pgsize;
    uvlong entry;

    hswal(&hp->e, sizeof(Exec)/sizeof(long), beswal);
    if(!(hp->e.magic & HDR_MAGIC))
        return 0;

    /*
     * There can be more magic here if the
     * header ever needs more expansion.
     * For now just catch use of any of the
     * unused bits.
     */
    if((hp->e.magic & ~DYN_MAGIC)>>16)
        return 0;
    entry = beswav(hp->e.hdr[0]);

    pgsize = mach->pgsize;
    settext(fp, entry, pgsize+fp->hdrsz, hp->e.text, fp->hdrsz);
    setdata(fp, _round(pgsize+fp->txtsz+fp->hdrsz, pgsize),
        hp->e.data, fp->txtsz+fp->hdrsz, hp->e.bss);
    setsym(fp, hp->e.syms, hp->e.spsz, hp->e.pcsz, fp->datoff+fp->datsz);

    if(hp->e.magic & DYN_MAGIC) {
        fp->txtaddr = 0;
        fp->dataddr = fp->txtsz;
        return 1;
    }
    commonboot(fp);
    return 1;
}
@

<<function mipsboot>>=
/*
 *	mips bootable image.
 */
static int
mipsboot(int fd, Fhdr *fp, ExecHdr *hp)
{
    USED(fd);
    fp->type = FMIPSB;
    switch(hp->e.amagic) {
    default:
    case 0407:	/* some kind of mips */
        settext(fp, (u32int)hp->e.mentry, (u32int)hp->e.text_start,
            hp->e.tsize, sizeof(struct mipsexec)+4);
        setdata(fp, (u32int)hp->e.data_start, hp->e.dsize,
            fp->txtoff+hp->e.tsize, hp->e.bsize);
        break;
    case 0413:	/* some kind of mips */
        settext(fp, (u32int)hp->e.mentry, (u32int)hp->e.text_start,
            hp->e.tsize, 0);
        setdata(fp, (u32int)hp->e.data_start, hp->e.dsize,
            hp->e.tsize, hp->e.bsize);
        break;
    }
    setsym(fp, hp->e.nsyms, 0, hp->e.pcsize, hp->e.symptr);
    fp->hdrsz = 0;			/* header stripped */
    return 1;
}
@

<<function mips4kboot>>=
/*
 *	mips4k bootable image.
 */
static int
mips4kboot(int fd, Fhdr *fp, ExecHdr *hp)
{
    USED(fd);
    fp->type = FMIPSB;
    switch(hp->e.h.amagic) {
    default:
    case 0407:	/* some kind of mips */
        settext(fp, (u32int)hp->e.h.mentry, (u32int)hp->e.h.text_start,
            hp->e.h.tsize, sizeof(struct mips4kexec));
        setdata(fp, (u32int)hp->e.h.data_start, hp->e.h.dsize,
            fp->txtoff+hp->e.h.tsize, hp->e.h.bsize);
        break;
    case 0413:	/* some kind of mips */
        settext(fp, (u32int)hp->e.h.mentry, (u32int)hp->e.h.text_start,
            hp->e.h.tsize, 0);
        setdata(fp, (u32int)hp->e.h.data_start, hp->e.h.dsize,
            hp->e.h.tsize, hp->e.h.bsize);
        break;
    }
    setsym(fp, hp->e.h.nsyms, 0, hp->e.h.pcsize, hp->e.h.symptr);
    fp->hdrsz = 0;			/* header stripped */
    return 1;
}
@

<<function sparcboot>>=
/*
 *	sparc bootable image
 */
static int
sparcboot(int fd, Fhdr *fp, ExecHdr *hp)
{
    USED(fd);
    fp->type = FSPARCB;
    settext(fp, hp->e.sentry, hp->e.sentry, hp->e.stext,
        sizeof(struct sparcexec));
    setdata(fp, hp->e.sentry+hp->e.stext, hp->e.sdata,
        fp->txtoff+hp->e.stext, hp->e.sbss);
    setsym(fp, hp->e.ssyms, 0, hp->e.sdrsize, fp->datoff+hp->e.sdata);
    fp->hdrsz = 0;			/* header stripped */
    return 1;
}
@

<<function nextboot>>=
/*
 *	next bootable image
 */
static int
nextboot(int fd, Fhdr *fp, ExecHdr *hp)
{
    USED(fd);
    fp->type = FNEXTB;
    settext(fp, hp->e.textc.vmaddr, hp->e.textc.vmaddr,
        hp->e.texts.size, hp->e.texts.offset);
    setdata(fp, hp->e.datac.vmaddr, hp->e.datas.size,
        hp->e.datas.offset, hp->e.bsss.size);
    setsym(fp, hp->e.symc.nsyms, hp->e.symc.spoff, hp->e.symc.pcoff,
        hp->e.symc.symoff);
    fp->hdrsz = 0;			/* header stripped */
    return 1;
}
@

<<function elf64dotout>>=
/*
 * ELF64 binaries.
 */
static int
elf64dotout(int fd, Fhdr *fp, ExecHdr *hp)
{
    E64hdr *ep;
    P64hdr *ph;
    ushort (*swab)(ushort);
    ulong (*swal)(ulong);
    uvlong (*swav)(uvlong);
    int i, it, id, is, phsz;
    uvlong uvl;

    ep = &hp->e;
    if(ep->ident[DATA] == ELFDATA2LSB) {
        swab = leswab;
        swal = leswal;
        swav = leswav;
    } else if(ep->ident[DATA] == ELFDATA2MSB) {
        swab = beswab;
        swal = beswal;
        swav = beswav;
    } else {
        werrstr("bad ELF64 encoding - not big or little endian");
        return 0;
    }

    ep->type = swab(ep->type);
    ep->machine = swab(ep->machine);
    ep->version = swal(ep->version);
    if(ep->type != EXEC || ep->version != CURRENT)
        return 0;
    ep->elfentry = swav(ep->elfentry);
    ep->phoff = swav(ep->phoff);
    ep->shoff = swav(ep->shoff);
    ep->flags = swal(ep->flags);
    ep->ehsize = swab(ep->ehsize);
    ep->phentsize = swab(ep->phentsize);
    ep->phnum = swab(ep->phnum);
    ep->shentsize = swab(ep->shentsize);
    ep->shnum = swab(ep->shnum);
    ep->shstrndx = swab(ep->shstrndx);

    fp->magic = ELF_MAG;
    fp->hdrsz = (ep->ehsize+ep->phnum*ep->phentsize+16)&~15;
    switch(ep->machine) {
    default:
        return 0;
    }

    if(ep->phentsize != sizeof(P64hdr)) {
        werrstr("bad ELF64 header size");
        return 0;
    }
    phsz = sizeof(P64hdr)*ep->phnum;
    ph = malloc(phsz);
    if(!ph)
        return 0;
    seek(fd, ep->phoff, 0);
    if(read(fd, ph, phsz) < 0) {
        free(ph);
        return 0;
    }
    for(i = 0; i < ep->phnum; i++) {
        ph[i].type = swal(ph[i].type);
        ph[i].flags = swal(ph[i].flags);
        ph[i].offset = swav(ph[i].offset);
        ph[i].vaddr = swav(ph[i].vaddr);
        ph[i].paddr = swav(ph[i].paddr);
        ph[i].filesz = swav(ph[i].filesz);
        ph[i].memsz = swav(ph[i].memsz);
        ph[i].align = swav(ph[i].align);
    }

    /* find text, data and symbols and install them */
    it = id = is = -1;
    for(i = 0; i < ep->phnum; i++) {
        if(ph[i].type == LOAD
        && (ph[i].flags & (R|X)) == (R|X) && it == -1)
            it = i;
        else if(ph[i].type == LOAD
        && (ph[i].flags & (R|W)) == (R|W) && id == -1)
            id = i;
        else if(ph[i].type == NOPTYPE && is == -1)
            is = i;
    }
    if(it == -1 || id == -1) {
        werrstr("No ELF64 TEXT or DATA sections");
        free(ph);
        return 0;
    }

    settext(fp, ep->elfentry, ph[it].vaddr, ph[it].memsz, ph[it].offset);
    /* 8c: out of fixed registers */
    uvl = ph[id].memsz - ph[id].filesz;
    setdata(fp, ph[id].vaddr, ph[id].filesz, ph[id].offset, uvl);
    if(is != -1)
        setsym(fp, ph[is].filesz, 0, ph[is].memsz, ph[is].offset);
    free(ph);
    return 1;
}
@

<<function elf32dotout>>=
/*
 * ELF32 binaries.
 */
static int
elf32dotout(int fd, Fhdr *fp, ExecHdr *hp)
{
    ulong (*swal)(ulong);
    ushort (*swab)(ushort);
    Ehdr *ep;
    Phdr *ph;
    int i, it, id, is, phsz;

    /* bitswap the header according to the DATA format */
    ep = &hp->e;
    if(ep->ident[DATA] == ELFDATA2LSB) {
        swab = leswab;
        swal = leswal;
    } else if(ep->ident[DATA] == ELFDATA2MSB) {
        swab = beswab;
        swal = beswal;
    } else {
        werrstr("bad ELF32 encoding - not big or little endian");
        return 0;
    }

    ep->type = swab(ep->type);
    ep->machine = swab(ep->machine);
    ep->version = swal(ep->version);
    ep->elfentry = swal(ep->elfentry);
    ep->phoff = swal(ep->phoff);
    ep->shoff = swal(ep->shoff);
    ep->flags = swal(ep->flags);
    ep->ehsize = swab(ep->ehsize);
    ep->phentsize = swab(ep->phentsize);
    ep->phnum = swab(ep->phnum);
    ep->shentsize = swab(ep->shentsize);
    ep->shnum = swab(ep->shnum);
    ep->shstrndx = swab(ep->shstrndx);
    if(ep->type != EXEC || ep->version != CURRENT)
        return 0;

    /* we could definitely support a lot more machines here */
    fp->magic = ELF_MAG;
    fp->hdrsz = (ep->ehsize+ep->phnum*ep->phentsize+16)&~15;
    switch(ep->machine) {
    case I386:
        mach = &mi386;
        fp->type = FI386;
        fp->name = "386 ELF32 executable";
        break;
    case MIPS:
        mach = &mmips;
        fp->type = FMIPS;
        fp->name = "mips ELF32 executable";
        break;
    case ARM:
        mach = &marm;
        fp->type = FARM;
        fp->name = "arm ELF32 executable";
        break;
    default:
        return 0;
    }

    if(ep->phentsize != sizeof(Phdr)) {
        werrstr("bad ELF32 header size");
        return 0;
    }
    phsz = sizeof(Phdr)*ep->phnum;
    ph = malloc(phsz);
    if(!ph)
        return 0;
    seek(fd, ep->phoff, 0);
    if(read(fd, ph, phsz) < 0) {
        free(ph);
        return 0;
    }
    hswal(ph, phsz/sizeof(ulong), swal);

    /* find text, data and symbols and install them */
    it = id = is = -1;
    for(i = 0; i < ep->phnum; i++) {
        if(ph[i].type == LOAD
        && (ph[i].flags & (R|X)) == (R|X) && it == -1)
            it = i;
        else if(ph[i].type == LOAD
        && (ph[i].flags & (R|W)) == (R|W) && id == -1)
            id = i;
        else if(ph[i].type == NOPTYPE && is == -1)
            is = i;
    }
    if(it == -1 || id == -1) {
        /*
         * The SPARC64 boot image is something of an ELF hack.
         * Text+Data+BSS are represented by ph[0].  Symbols
         * are represented by ph[1]:
         *
         *		filesz, memsz, vaddr, paddr, off
         * ph[0] : txtsz+datsz, txtsz+datsz+bsssz, txtaddr-KZERO, datasize, txtoff
         * ph[1] : symsz, lcsz, 0, 0, symoff
         */
        if(ep->machine == SPARC64 && ep->phnum == 2) {
            ulong txtaddr, txtsz, dataddr, bsssz;

            txtaddr = ph[0].vaddr | 0x80000000;
            txtsz = ph[0].filesz - ph[0].paddr;
            dataddr = txtaddr + txtsz;
            bsssz = ph[0].memsz - ph[0].filesz;
            settext(fp, ep->elfentry | 0x80000000, txtaddr, txtsz, ph[0].offset);
            setdata(fp, dataddr, ph[0].paddr, ph[0].offset + txtsz, bsssz);
            setsym(fp, ph[1].filesz, 0, ph[1].memsz, ph[1].offset);
            free(ph);
            return 1;
        }

        werrstr("No ELF32 TEXT or DATA sections");
        free(ph);
        return 0;
    }

    settext(fp, ep->elfentry, ph[it].vaddr, ph[it].memsz, ph[it].offset);
    setdata(fp, ph[id].vaddr, ph[id].filesz, ph[id].offset, ph[id].memsz - ph[id].filesz);
    if(is != -1)
        setsym(fp, ph[is].filesz, 0, ph[is].memsz, ph[is].offset);
    free(ph);
    return 1;
}
@

<<function elfdotout>>=
/*
 * Elf binaries.
 */
static int
elfdotout(int fd, Fhdr *fp, ExecHdr *hp)
{
    Ehdr *ep;

    /* bitswap the header according to the DATA format */
    ep = &hp->e;
    if(ep->ident[CLASS] == ELFCLASS32)
        return elf32dotout(fd, fp, hp);
    else if(ep->ident[CLASS] == ELFCLASS64)
        return elf64dotout(fd, fp, hp);

    werrstr("bad ELF class - not 32- nor 64-bit");
    return 0;
}
@

<<function armdotout>>=
/*
 * (Free|Net)BSD ARM header.
 */
static int
armdotout(int fd, Fhdr *fp, ExecHdr *hp)
{
    uvlong kbase;

    USED(fd);
    settext(fp, hp->e.entry, sizeof(Exec), hp->e.text, sizeof(Exec));
    setdata(fp, fp->txtsz, hp->e.data, fp->txtsz, hp->e.bss);
    setsym(fp, hp->e.syms, hp->e.spsz, hp->e.pcsz, fp->datoff+fp->datsz);

    kbase = 0xF0000000;
    if ((fp->entry & kbase) == kbase) {		/* Boot image */
        fp->txtaddr = kbase+sizeof(Exec);
        fp->name = "ARM *BSD boot image";
        fp->hdrsz = 0;		/* header stripped */
        fp->dataddr = kbase+fp->txtsz;
    }
    return 1;
}
@

<<function settext>>=
static void
settext(Fhdr *fp, uvlong e, uvlong a, long s, vlong off)
{
    fp->txtaddr = a;
    fp->entry = e;
    fp->txtsz = s;
    fp->txtoff = off;
}
@

<<function setdata>>=
static void
setdata(Fhdr *fp, uvlong a, long s, vlong off, long bss)
{
    fp->dataddr = a;
    fp->datsz = s;
    fp->datoff = off;
    fp->bsssz = bss;
}
@

<<function setsym>>=
static void
setsym(Fhdr *fp, long symsz, long sppcsz, long lnpcsz, vlong symoff)
{
    fp->symsz = symsz;
    fp->symoff = symoff;
    fp->sppcsz = sppcsz;
    fp->sppcoff = fp->symoff+fp->symsz;
    fp->lnpcsz = lnpcsz;
    fp->lnpcoff = fp->sppcoff+fp->sppcsz;
}
@

<<function _round>>=
static uvlong
_round(uvlong a, ulong b)
{
    uvlong w;

    w = (a/b)*b;
    if (a!=w)
        w += b;
    return(w);
}
@


%-------------------------------------------------------------

<<linkers/libmach/executable.c>>=
#include	<u.h>
#include	<libc.h>
#include	<bio.h>
#include	<bootexec.h>
#include	<mach.h>
#include	"elf.h"

/*
 *	All a.out header types.  The dummy entry allows canonical
 *	processing of the union as a sequence of longs
 */

typedef struct {
    union{
        struct {
            Exec;		/* a.out.h */
            uvlong hdr[1];
        };
        Ehdr;			/* elf.h */
        E64hdr;
        struct mipsexec;	/* bootexec.h */
        struct mips4kexec;	/* bootexec.h */
        struct sparcexec;	/* bootexec.h */
        struct nextexec;	/* bootexec.h */
    } e;
    long dummy;			/* padding to ensure extra long */
} ExecHdr;

static	int	nextboot(int, Fhdr*, ExecHdr*);
static	int	sparcboot(int, Fhdr*, ExecHdr*);
static	int	mipsboot(int, Fhdr*, ExecHdr*);
static	int	mips4kboot(int, Fhdr*, ExecHdr*);
static	int	common(int, Fhdr*, ExecHdr*);
static	int	commonllp64(int, Fhdr*, ExecHdr*);
static	int	adotout(int, Fhdr*, ExecHdr*);
static	int	elfdotout(int, Fhdr*, ExecHdr*);
static	int	armdotout(int, Fhdr*, ExecHdr*);
static	void	setsym(Fhdr*, long, long, long, vlong);
static	void	setdata(Fhdr*, uvlong, long, vlong, long);
static	void	settext(Fhdr*, uvlong, uvlong, long, vlong);
static	void	hswal(void*, int, ulong(*)(ulong));
static	uvlong	_round(uvlong, ulong);

<<struct Exectable>>

//PAD: removed many archi
extern	Mach	mmips;
extern	Mach	mi386;
extern	Mach	marm;

<<global exectab>>

<<global mach>>

<<function couldbe4k>>

<<function crackhdr>>

<<function hswal>>

<<function adotout>>

<<function commonboot>>

<<function common>>

<<function commonllp64>>

<<function mipsboot>>

<<function mips4kboot>>

<<function sparcboot>>

<<function nextboot>>

<<function elf64dotout>>

<<function elf32dotout>>

<<function elfdotout>>

<<function armdotout>>

<<function settext>>

<<function setdata>>

<<function setsym>>


<<function _round>>
@


\subsection*{[[linkers/libmach/map.c]]}

<<function newmap>>=
Map *
newmap(Map *map, int n)
{
    int size;

    size = sizeof(Map)+(n-1)*sizeof(struct segment);
    if (map == 0)
        map = malloc(size);
    else
        map = realloc(map, size);
    if (map == 0) {
        werrstr("out of memory: %r");
        return 0;
    }
    memset(map, 0, size);
    map->nsegs = n;
    return map;
}
@

<<function setmap>>=
int
setmap(Map *map, int fd, uvlong b, uvlong e, vlong f, char *name)
{
    int i;

    if (map == 0)
        return 0;
    for (i = 0; i < map->nsegs; i++)
        if (!map->seg[i].inuse)
            break;
    if (i >= map->nsegs)
        return 0;
    map->seg[i].b = b;
    map->seg[i].e = e;
    map->seg[i].f = f;
    map->seg[i].inuse = 1;
    map->seg[i].name = name;
    map->seg[i].fd = fd;
    return 1;
}
@

<<function stacktop>>=
static uvlong
stacktop(int pid)
{
    char buf[64];
    int fd;
    int n;
    char *cp;

    snprint(buf, sizeof(buf), "/proc/%d/segment", pid);
    fd = open(buf, 0);
    if (fd < 0)
        return 0;
    n = read(fd, buf, sizeof(buf)-1);
    close(fd);
    buf[n] = 0;
    if (strncmp(buf, "Stack", 5))
        return 0;
    for (cp = buf+5; *cp && *cp == ' '; cp++)
        ;
    if (!*cp)
        return 0;
    cp = strchr(cp, ' ');
    if (!cp)
        return 0;
    while (*cp && *cp == ' ')
        cp++;
    if (!*cp)
        return 0;
    return strtoull(cp, 0, 16);
}
@

<<function attachproc>>=
Map*
attachproc(int pid, int kflag, int corefd, Fhdr *fp)
{
    char buf[64], *regs;
    int fd;
    Map *map;
    uvlong n;

    map = newmap(0, 4);
    if (!map)
        return 0;
    if(kflag)
        regs = "kregs";
    else
        regs = "regs";
    if (mach->regsize) {
        sprint(buf, "/proc/%d/%s", pid, regs);
        fd = open(buf, ORDWR);
        if(fd < 0)
            fd = open(buf, OREAD);
        if(fd < 0) {
            free(map);
            return 0;
        }
        setmap(map, fd, 0, mach->regsize, 0, "regs");
    }
    if (mach->fpregsize) {
        sprint(buf, "/proc/%d/fpregs", pid);
        fd = open(buf, ORDWR);
        if(fd < 0)
            fd = open(buf, OREAD);
        if(fd < 0) {
            close(map->seg[0].fd);
            free(map);
            return 0;
        }
        setmap(map, fd, mach->regsize, mach->regsize+mach->fpregsize, 0, "fpregs");
    }
    setmap(map, corefd, fp->txtaddr, fp->txtaddr+fp->txtsz, fp->txtaddr, "text");
    if(kflag || fp->dataddr >= mach->utop) {
        setmap(map, corefd, fp->dataddr, ~0, fp->dataddr, "data");
        return map;
    }
    n = stacktop(pid);
    if (n == 0) {
        setmap(map, corefd, fp->dataddr, mach->utop, fp->dataddr, "data");
        return map;
    }
    setmap(map, corefd, fp->dataddr, n, fp->dataddr, "data");
    return map;
}
@

<<function findseg>>=
int
findseg(Map *map, char *name)
{
    int i;

    if (!map)
        return -1;
    for (i = 0; i < map->nsegs; i++)
        if (map->seg[i].inuse && !strcmp(map->seg[i].name, name))
            return i;
    return -1;
}
@

<<function unusemap>>=
void
unusemap(Map *map, int i)
{
    if (map != 0 && 0 <= i && i < map->nsegs)
        map->seg[i].inuse = 0;
}
@

<<function loadmap>>=
Map*
loadmap(Map *map, int fd, Fhdr *fp)
{
    map = newmap(map, 2);
    if (map == 0)
        return 0;

    map->seg[0].b = fp->txtaddr;
    map->seg[0].e = fp->txtaddr+fp->txtsz;
    map->seg[0].f = fp->txtoff;
    map->seg[0].fd = fd;
    map->seg[0].inuse = 1;
    map->seg[0].name = "text";
    map->seg[1].b = fp->dataddr;
    map->seg[1].e = fp->dataddr+fp->datsz;
    map->seg[1].f = fp->datoff;
    map->seg[1].fd = fd;
    map->seg[1].inuse = 1;
    map->seg[1].name = "data";
    return map;
}
@


%-------------------------------------------------------------

<<linkers/libmach/map.c>>=
/*
 * file map routines
 */
#include <u.h>
#include <libc.h>
#include <bio.h>
#include <mach.h>

<<function newmap>>

<<function setmap>>

<<function stacktop>>

<<function attachproc>>
    
<<function findseg>>

<<function unusemap>>

<<function loadmap>>
@


\subsection*{[[linkers/libmach/sym.c]]}

<<constant HUGEINT>>=
#define	HUGEINT	0x7fffffff
@

<<constant NNAME>>=
#define	NNAME	20		/* a relic of the past */
@

<<struct txtsym>>=
struct txtsym {				/* Text Symbol table */
    int 	n;			/* number of local vars */
    Sym	**locals;		/* array of ptrs to autos */
    Sym	*sym;			/* function symbol entry */
};
@

<<struct hist>>=
struct hist {				/* Stack of include files & #line directives */
    char	*name;			/* Assumes names Null terminated in file */
    long	line;			/* line # where it was included */
    long	offset;			/* line # of #line directive */
};
@

<<struct file>>=
struct file {				/* Per input file header to history stack */
    uvlong	addr;			/* address of first text sym */
    union {
        Txtsym	*txt;		/* first text symbol */
        Sym	*sym;		/* only during initilization */
    };
    int	n;			/* size of history stack */
    Hist	*hist;			/* history stack */
};
@

<<global debug (linkers/libmach/sym.c)>>=
static	int	debug = 0;
@

<<global autos>>=
static	Sym	**autos;		/* Base of auto variables */
@

<<global files>>=
static	File	*files;			/* Base of file arena */
@

<<global fmax>>=
static	int	fmax;			/* largest file path index */
@

<<global fnames (linkers/libmach/sym.c)>>=
static	Sym	**fnames;		/* file names path component table */
@

<<global globals>>=
static	Sym	**globals;		/* globals by addr table */
@

<<global hist>>=
static	Hist	*hist;			/* base of history stack */
@

<<global isbuilt>>=
static	int	isbuilt;		/* internal table init flag */
@

<<global nauto>>=
static	long	nauto;			/* number of automatics */
@

<<global nfiles>>=
static	long	nfiles;			/* number of files */
@

<<global nglob>>=
static	long	nglob;			/* number of globals */
@

<<global nhist>>=
static	long	nhist;			/* number of history stack entries */
@

<<global nsym (linkers/libmach/sym.c)>>=
static	long	nsym;			/* number of symbols */
@

<<global ntxt>>=
static	int	ntxt;			/* number of text symbols */
@

<<global pcline>>=
static	uchar	*pcline;		/* start of pc-line state table */
@

<<global pclineend>>=
static	uchar 	*pclineend;		/* end of pc-line table */
@

<<global spoff>>=
static	uchar	*spoff;			/* start of pc-sp state table */
@

<<global spoffend>>=
static	uchar	*spoffend;		/* end of pc-sp offset table */
@

<<global symbols>>=
static	Sym	*symbols;		/* symbol table */
@

<<global txt>>=
static	Txtsym	*txt;			/* Base of text symbol table */
@

<<global txtstart>>=
static	uvlong	txtstart;		/* start of text segment */
@

<<global txtend>>=
static	uvlong	txtend;			/* end of text segment */
@

<<function syminit>>=
/*
 *	initialize the symbol tables
 */
int
syminit(int fd, Fhdr *fp)
{
    Sym *p;
    long i, l, size;
    vlong vl;
    Biobuf b;
    int svalsz;

    if(fp->symsz == 0)
        return 0;
    if(fp->type == FNONE)
        return 0;

    cleansyms();
    textseg(fp->txtaddr, fp);
        /* minimum symbol record size = 4+1+2 bytes */
    symbols = malloc((fp->symsz/(4+1+2)+1)*sizeof(Sym));
    if(symbols == 0) {
        werrstr("can't malloc %ld bytes", fp->symsz);
        return -1;
    }
    Binit(&b, fd, OREAD);
    Bseek(&b, fp->symoff, 0);
    nsym = 0;
    size = 0;
    if((fp->_magic && (fp->magic & HDR_MAGIC)) || mach->szaddr == 8)
        svalsz = 8;
    else
        svalsz = 4;
    for(p = symbols; size < fp->symsz; p++, nsym++) {
        if(svalsz == 8){
            if(Bread(&b, &vl, 8) != 8)
                return symerrmsg(8, "symbol");
            p->value = beswav(vl);
        }
        else{
            if(Bread(&b, &l, 4) != 4)
                return symerrmsg(4, "symbol");
            p->value = (u32int)beswal(l);
        }
        if(Bread(&b, &p->type, sizeof(p->type)) != sizeof(p->type))
            return symerrmsg(sizeof(p->value), "symbol");

        i = decodename(&b, p);
        if(i < 0)
            return -1;
        size += i+svalsz+sizeof(p->type);

        /* count global & auto vars, text symbols, and file names */
        switch (p->type) {
        case 'l':
        case 'L':
        case 't':
        case 'T':
            ntxt++;
            break;
        case 'd':
        case 'D':
        case 'b':
        case 'B':
            nglob++;
            break;
        case 'f':
            if(strcmp(p->name, ".frame") == 0) {
                p->type = 'm';
                nauto++;
            }
            else if(p->value > fmax)
                fmax = p->value;	/* highest path index */
            break;
        case 'a':
        case 'p':
        case 'm':
            nauto++;
            break;
        case 'z':
            if(p->value == 1) {		/* one extra per file */
                nhist++;
                nfiles++;
            }
            nhist++;
            break;
        default:
            break;
        }
    }
    if (debug)
        print("NG: %ld NT: %d NF: %d\n", nglob, ntxt, fmax);
    if (fp->sppcsz) {			/* pc-sp offset table */
        spoff = (uchar *)malloc(fp->sppcsz);
        if(spoff == 0) {
            werrstr("can't malloc %ld bytes", fp->sppcsz);
            return -1;
        }
        Bseek(&b, fp->sppcoff, 0);
        if(Bread(&b, spoff, fp->sppcsz) != fp->sppcsz){
            spoff = 0;
            return symerrmsg(fp->sppcsz, "sp-pc");
        }
        spoffend = spoff+fp->sppcsz;
    }
    if (fp->lnpcsz) {			/* pc-line number table */
        pcline = (uchar *)malloc(fp->lnpcsz);
        if(pcline == 0) {
            werrstr("can't malloc %ld bytes", fp->lnpcsz);
            return -1;
        }
        Bseek(&b, fp->lnpcoff, 0);
        if(Bread(&b, pcline, fp->lnpcsz) != fp->lnpcsz){
            pcline = 0;
            return symerrmsg(fp->lnpcsz, "pc-line");
        }
        pclineend = pcline+fp->lnpcsz;
    }
    return nsym;
}
@

<<function symerrmsg>>=
static int
symerrmsg(int n, char *table)
{
    werrstr("can't read %d bytes of %s table", n, table);
    return -1;
}
@

<<function decodename>>=
static long
decodename(Biobuf *bp, Sym *p)
{
    char *cp;
    int c1, c2;
    long n;
    vlong o;

    if((p->type & 0x80) == 0) {		/* old-style, fixed length names */
        p->name = malloc(NNAME);
        if(p->name == 0) {
            werrstr("can't malloc %d bytes", NNAME);
            return -1;
        }
        if(Bread(bp, p->name, NNAME) != NNAME)
            return symerrmsg(NNAME, "symbol");
        Bseek(bp, 3, 1);
        return NNAME+3;
    }

    p->type &= ~0x80;
    if(p->type == 'z' || p->type == 'Z') {
        o = Bseek(bp, 0, 1);
        if(Bgetc(bp) < 0) {
            werrstr("can't read symbol name");
            return -1;
        }
        for(;;) {
            c1 = Bgetc(bp);
            c2 = Bgetc(bp);
            if(c1 < 0 || c2 < 0) {
                werrstr("can't read symbol name");
                return -1;
            }
            if(c1 == 0 && c2 == 0)
                break;
        }
        n = Bseek(bp, 0, 1)-o;
        p->name = malloc(n);
        if(p->name == 0) {
            werrstr("can't malloc %ld bytes", n);
            return -1;
        }
        Bseek(bp, -n, 1);
        if(Bread(bp, p->name, n) != n) {
            werrstr("can't read %ld bytes of symbol name", n);
            return -1;
        }
    } else {
        cp = Brdline(bp, '\0');
        if(cp == 0) {
            werrstr("can't read symbol name");
            return -1;
        }
        n = Blinelen(bp);
        p->name = malloc(n);
        if(p->name == 0) {
            werrstr("can't malloc %ld bytes", n);
            return -1;
        }
        strcpy(p->name, cp);
    }
    return n;
}
@

<<function cleansyms>>=
/*
 *	free any previously loaded symbol tables
 */
static void
cleansyms(void)
{
    if(globals)
        free(globals);
    globals = 0;
    nglob = 0;
    if(txt)
        free(txt);
    txt = 0;
    ntxt = 0;
    if(fnames)
        free(fnames);
    fnames = 0;
    fmax = 0;

    if(files)
        free(files);
    files = 0;
    nfiles = 0;
    if(hist)
        free(hist);
    hist = 0;
    nhist = 0;
    if(autos)
        free(autos);
    autos = 0;
    nauto = 0;
    isbuilt = 0;
    if(symbols)
        free(symbols);
    symbols = 0;
    nsym = 0;
    if(spoff)
        free(spoff);
    spoff = 0;
    if(pcline)
        free(pcline);
    pcline = 0;
}
@

<<function textseg>>=
/*
 *	delimit the text segment
 */
void
textseg(uvlong base, Fhdr *fp)
{
    txtstart = base;
    txtend = base+fp->txtsz;
}
@

<<function symbase>>=
/*
 *	symbase: return base and size of raw symbol table
 *		(special hack for high access rate operations)
 */
Sym *
symbase(long *n)
{
    *n = nsym;
    return symbols;
}
@

<<function getsym>>=
/*
 *	Get the ith symbol table entry
 */
Sym *
getsym(int index)
{
    if(index >= 0 && index < nsym)
        return &symbols[index];
    return 0;
}
@

<<function buildtbls>>=
/*
 *	initialize internal symbol tables
 */
static int
buildtbls(void)
{
    long i;
    int j, nh, ng, nt;
    File *f;
    Txtsym *tp;
    Hist *hp;
    Sym *p, **ap;

    if(isbuilt)
        return 1;
    isbuilt = 1;
            /* allocate the tables */
    if(nglob) {
        globals = malloc(nglob*sizeof(*globals));
        if(!globals) {
            werrstr("can't malloc global symbol table");
            return 0;
        }
    }
    if(ntxt) {
        txt = malloc(ntxt*sizeof(*txt));
        if (!txt) {
            werrstr("can't malloc text symbol table");
            return 0;
        }
    }
    fnames = malloc((fmax+1)*sizeof(*fnames));
    if (!fnames) {
        werrstr("can't malloc file name table");
        return 0;
    }
    memset(fnames, 0, (fmax+1)*sizeof(*fnames));
    files = malloc(nfiles*sizeof(*files));
    if(!files) {
        werrstr("can't malloc file table");
        return 0;
    }
    hist = malloc(nhist*sizeof(Hist));
    if(hist == 0) {
        werrstr("can't malloc history stack");
        return 0;
    }
    autos = malloc(nauto*sizeof(Sym*));
    if(autos == 0) {
        werrstr("can't malloc auto symbol table");
        return 0;
    }
        /* load the tables */
    ng = nt = nh = 0;
    f = 0;
    tp = 0;
    i = nsym;
    hp = hist;
    ap = autos;
    for(p = symbols; i-- > 0; p++) {
        switch(p->type) {
        case 'D':
        case 'd':
        case 'B':
        case 'b':
            if(debug)
                print("Global: %s %llux\n", p->name, p->value);
            globals[ng++] = p;
            break;
        case 'z':
            if(p->value == 1) {		/* New file */
                if(f) {
                    f->n = nh;
                    f->hist[nh].name = 0;	/* one extra */
                    hp += nh+1;
                    f++;
                }
                else
                    f = files;
                f->hist = hp;
                f->sym = 0;
                f->addr = 0;
                nh = 0;
            }
                /* alloc one slot extra as terminator */
            f->hist[nh].name = p->name;
            f->hist[nh].line = p->value;
            f->hist[nh].offset = 0;
            if(debug)
                printhist("-> ", &f->hist[nh], 1);
            nh++;
            break;
        case 'Z':
            if(f && nh > 0)
                f->hist[nh-1].offset = p->value;
            break;
        case 'T':
        case 't':	/* Text: terminate history if first in file */
        case 'L':
        case 'l':
            tp = &txt[nt++];
            tp->n = 0;
            tp->sym = p;
            tp->locals = ap;
            if(debug)
                print("TEXT: %s at %llux\n", p->name, p->value);
            if(f && !f->sym) {			/* first  */
                f->sym = p;
                f->addr = p->value;
            }
            break;
        case 'a':
        case 'p':
        case 'm':		/* Local Vars */
            if(!tp)
                print("Warning: Free floating local var: %s\n",
                    p->name);
            else {
                if(debug)
                    print("Local: %s %llux\n", p->name, p->value);
                tp->locals[tp->n] = p;
                tp->n++;
                ap++;
            }
            break;
        case 'f':		/* File names */
            if(debug)
                print("Fname: %s\n", p->name);
            fnames[p->value] = p;
            break;
        default:
            break;
        }
    }
        /* sort global and text tables into ascending address order */
    qsort(globals, nglob, sizeof(Sym*), symcomp);
    qsort(txt, ntxt, sizeof(Txtsym), txtcomp);
    qsort(files, nfiles, sizeof(File), filecomp);
    tp = txt;
    for(i = 0, f = files; i < nfiles; i++, f++) {
        for(j = 0; j < ntxt; j++) {
            if(f->sym == tp->sym) {
                if(debug) {
                    print("LINK: %s to at %llux", f->sym->name, f->addr);
                    printhist("... ", f->hist, 1);
                }
                f->txt = tp++;
                break;
            }
            if(++tp >= txt+ntxt)	/* wrap around */
                tp = txt;
        }
    }
    return 1;
}
@

<<function lookup (linkers/libmach/sym.c)>>=
/*
 * find symbol function.var by name.
 *	fn != 0 && var != 0	=> look for fn in text, var in data
 *	fn != 0 && var == 0	=> look for fn in text
 *	fn == 0 && var != 0	=> look for var first in text then in data space.
 */
int
lookup(char *fn, char *var, Symbol *s)
{
    int found;

    if(buildtbls() == 0)
        return 0;
    if(fn) {
        found = findtext(fn, s);
        if(var == 0)		/* case 2: fn not in text */
            return found;
        else if(!found)		/* case 1: fn not found */
            return 0;
    } else if(var) {
        found = findtext(var, s);
        if(found)
            return 1;	/* case 3: var found in text */
    } else return 0;		/* case 4: fn & var == zero */

    if(found)
        return findlocal(s, var, s);	/* case 1: fn found */
    return findglobal(var, s);		/* case 3: var not found */

}
@

<<function findtext>>=
/*
 * find a function by name
 */
static int
findtext(char *name, Symbol *s)
{
    int i;

    for(i = 0; i < ntxt; i++) {
        if(strcmp(txt[i].sym->name, name) == 0) {
            fillsym(txt[i].sym, s);
            s->handle = (void *) &txt[i];
            s->index = i;
            return 1;
        }
    }
    return 0;
}
@

<<function findglobal>>=
/*
 * find global variable by name
 */
static int
findglobal(char *name, Symbol *s)
{
    long i;

    for(i = 0; i < nglob; i++) {
        if(strcmp(globals[i]->name, name) == 0) {
            fillsym(globals[i], s);
            s->index = i;
            return 1;
        }
    }
    return 0;
}
@

<<function findlocal>>=
/*
 *	find the local variable by name within a given function
 */
int
findlocal(Symbol *s1, char *name, Symbol *s2)
{
    if(s1 == 0)
        return 0;
    if(buildtbls() == 0)
        return 0;
    return findlocvar(s1, name, s2);
}
@

<<function findlocvar>>=
/*
 *	find the local variable by name within a given function
 *		(internal function - does no parameter validation)
 */
static int
findlocvar(Symbol *s1, char *name, Symbol *s2)
{
    Txtsym *tp;
    int i;

    tp = (Txtsym *)s1->handle;
    if(tp && tp->locals) {
        for(i = 0; i < tp->n; i++)
            if (strcmp(tp->locals[i]->name, name) == 0) {
                fillsym(tp->locals[i], s2);
                s2->handle = (void *)tp;
                s2->index = tp->n-1 - i;
                return 1;
            }
    }
    return 0;
}
@

<<function textsym>>=
/*
 *	Get ith text symbol
 */
int
textsym(Symbol *s, int index)
{

    if(buildtbls() == 0)
        return 0;
    if(index < 0 || index >= ntxt)
        return 0;
    fillsym(txt[index].sym, s);
    s->handle = (void *)&txt[index];
    s->index = index;
    return 1;
}
@

<<function filesym>>=
/*	
 *	Get ith file name
 */
int
filesym(int index, char *buf, int n)
{
    Hist *hp;

    if(buildtbls() == 0)
        return 0;
    if(index < 0 || index >= nfiles)
        return 0;
    hp = files[index].hist;
    if(!hp || !hp->name)
        return 0;
    return fileelem(fnames, (uchar*)hp->name, buf, n);
}
@

<<function getauto>>=
/*
 *	Lookup name of local variable located at an offset into the frame.
 *	The type selects either a parameter or automatic.
 */
int
getauto(Symbol *s1, int off, int type, Symbol *s2)
{
    Txtsym *tp;
    Sym *p;
    int i, t;

    if(s1 == 0)
        return 0;
    if(type == CPARAM)
        t = 'p';
    else if(type == CAUTO)
        t = 'a';
    else
        return 0;
    if(buildtbls() == 0)
        return 0;
    tp = (Txtsym *)s1->handle;
    if(tp == 0)
        return 0;
    for(i = 0; i < tp->n; i++) {
        p = tp->locals[i];
        if(p->type == t && p->value == off) {
            fillsym(p, s2);
            s2->handle = s1->handle;
            s2->index = tp->n-1 - i;
            return 1;
        }
    }
    return 0;
}
@

<<function srchtext>>=
/*
 * Find text symbol containing addr; binary search assumes text array is sorted by addr
 */
static int
srchtext(uvlong addr)
{
    uvlong val;
    int top, bot, mid;
    Sym *sp;

    val = addr;
    bot = 0;
    top = ntxt;
    for (mid = (bot+top)/2; mid < top; mid = (bot+top)/2) {
        sp = txt[mid].sym;
        if(sp == nil)
            return -1;
        if(val < sp->value)
            top = mid;
        else if(mid != ntxt-1 && val >= txt[mid+1].sym->value)
            bot = mid;
        else
            return mid;
    }
    return -1;
}
@

<<function srchdata>>=
/*
 * Find data symbol containing addr; binary search assumes data array is sorted by addr
 */
static int
srchdata(uvlong addr)
{
    uvlong val;
    int top, bot, mid;
    Sym *sp;

    bot = 0;
    top = nglob;
    val = addr;
    for(mid = (bot+top)/2; mid < top; mid = (bot+top)/2) {
        sp = globals[mid];
        if(sp == nil)
            return -1;
        if(val < sp->value)
            top = mid;
        else if(mid < nglob-1 && val >= globals[mid+1]->value)
            bot = mid;
        else
            return mid;
    }
    return -1;
}
@

<<function findsym>>=
/*
 * Find symbol containing val in specified search space
 * There is a special case when a value falls beyond the end
 * of the text segment; if the search space is CTEXT, that value
 * (usually etext) is returned.  If the search space is CANY, symbols in the
 * data space are searched for a match.
 */
int
findsym(uvlong val, int type, Symbol *s)
{
    int i;

    if(buildtbls() == 0)
        return 0;

    if(type == CTEXT || type == CANY) {
        i = srchtext(val);
        if(i >= 0) {
            if(type == CTEXT || i != ntxt-1) {
                fillsym(txt[i].sym, s);
                s->handle = (void *) &txt[i];
                s->index = i;
                return 1;
            }
        }
    }
    if(type == CDATA || type == CANY) {
        i = srchdata(val);
        if(i >= 0) {
            fillsym(globals[i], s);
            s->index = i;
            return 1;
        }
    }
    return 0;
}
@

<<function fnbound>>=
/*
 *	Find the start and end address of the function containing addr
 */
int
fnbound(uvlong addr, uvlong *bounds)
{
    int i;

    if(buildtbls() == 0)
        return 0;

    i = srchtext(addr);
    if(0 <= i && i < ntxt-1) {
        bounds[0] = txt[i].sym->value;
        bounds[1] = txt[i+1].sym->value;
        return 1;
    }
    return 0;
}
@

<<function localsym>>=
/*
 * get the ith local symbol for a function
 * the input symbol table is reverse ordered, so we reverse
 * accesses here to maintain approx. parameter ordering in a stack trace.
 */
int
localsym(Symbol *s, int index)
{
    Txtsym *tp;

    if(s == 0 || index < 0)
        return 0;
    if(buildtbls() == 0)
        return 0;

    tp = (Txtsym *)s->handle;
    if(tp && tp->locals && index < tp->n) {
        fillsym(tp->locals[tp->n-index-1], s);	/* reverse */
        s->handle = (void *)tp;
        s->index = index;
        return 1;
    }
    return 0;
}
@

<<function globalsym>>=
/*
 * get the ith global symbol
 */
int
globalsym(Symbol *s, int index)
{
    if(s == 0)
        return 0;
    if(buildtbls() == 0)
        return 0;

    if(index >=0 && index < nglob) {
        fillsym(globals[index], s);
        s->index = index;
        return 1;
    }
    return 0;
}
@

<<function file2pc>>=
/*
 *	find the pc given a file name and line offset into it.
 */
uvlong
file2pc(char *file, long line)
{
    File *fp;
    long i;
    uvlong pc, start, end;
    short *name;

    if(buildtbls() == 0 || files == 0)
        return ~0;
    name = encfname(file);
    if(name == 0) {			/* encode the file name */
        werrstr("file %s not found", file);
        return ~0;
    } 
        /* find this history stack */
    for(i = 0, fp = files; i < nfiles; i++, fp++)
        if (hline(fp, name, &line))
            break;
    free(name);
    if(i >= nfiles) {
        werrstr("line %ld in file %s not found", line, file);
        return ~0;
    }
    start = fp->addr;		/* first text addr this file */
    if(i < nfiles-1)
        end = (fp+1)->addr;	/* first text addr next file */
    else
        end = 0;		/* last file in load module */
    /*
     * At this point, line contains the offset into the file.
     * run the state machine to locate the pc closest to that value.
     */
    if(debug)
        print("find pc for %ld - between: %llux and %llux\n", line, start, end);
    pc = line2addr(line, start, end);
    if(pc == ~0) {
        werrstr("line %ld not in file %s", line, file);
        return ~0;
    }
    return pc;
}
@

<<function pathcomp>>=
/*
 *	search for a path component index
 */
static int
pathcomp(char *s, int n)
{
    int i;

    for(i = 0; i <= fmax; i++)
        if(fnames[i] && strncmp(s, fnames[i]->name, n) == 0)
            return i;
    return -1;
}
@

<<function encfname>>=
/*
 *	Encode a char file name as a sequence of short indices
 *	into the file name dictionary.
 */
static short*
encfname(char *file)
{
    int i, j;
    char *cp, *cp2;
    short *dest;

    if(*file == '/')	/* always check first '/' */
        cp2 = file+1;
    else {
        cp2 = strchr(file, '/');
        if(!cp2)
            cp2 = strchr(file, 0);
    }
    cp = file;
    dest = 0;
    for(i = 0; *cp; i++) {
        j = pathcomp(cp, cp2-cp);
        if(j < 0)
            return 0;	/* not found */
        dest = realloc(dest, (i+1)*sizeof(short));
        dest[i] = j;
        cp = cp2;
        while(*cp == '/')	/* skip embedded '/'s */
            cp++;
        cp2 = strchr(cp, '/');
        if(!cp2)
            cp2 = strchr(cp, 0);
    }
    dest = realloc(dest, (i+1)*sizeof(short));
    dest[i] = 0;
    return dest;
}
@

<<function hline>>=
/*
 *	Search a history stack for a matching file name accumulating
 *	the size of intervening files in the stack.
 */
static int
hline(File *fp, short *name, long *line)
{
    Hist *hp;
    int offset, depth;
    long ln;

    for(hp = fp->hist; hp->name; hp++)		/* find name in stack */
        if(hp->name[1] || hp->name[2]) {
            if(hcomp(hp, name))
                break;
        }
    if(!hp->name)		/* match not found */
        return 0;
    if(debug)
        printhist("hline found ... ", hp, 1);
    /*
     * unwind the stack until empty or we hit an entry beyond our line
     */
    ln = *line;
    offset = hp->line-1;
    depth = 1;
    for(hp++; depth && hp->name; hp++) {
        if(debug)
            printhist("hline inspect ... ", hp, 1);
        if(hp->name[1] || hp->name[2]) {
            if(hp->offset){			/* Z record */
                offset = 0;
                if(hcomp(hp, name)) {
                    if(*line <= hp->offset)
                        break;
                    ln = *line+hp->line-hp->offset;
                    depth = 1;	/* implicit pop */
                } else
                    depth = 2;	/* implicit push */
            } else if(depth == 1 && ln < hp->line-offset)
                    break;		/* Beyond our line */
            else if(depth++ == 1)		/* push	*/
                offset -= hp->line;
        } else if(--depth == 1)		/* pop */
            offset += hp->line;	
    }
    *line = ln+offset;
    return 1;
}
@

<<function hcomp>>=
/*
 *	compare two encoded file names
 */
static int
hcomp(Hist *hp, short *sp)
{
    uchar *cp;
    int i, j;
    short *s;

    cp = (uchar *)hp->name;
    s = sp;
    if (*s == 0)
        return 0;
    for (i = 1; j = (cp[i]<<8)|cp[i+1]; i += 2) {
        if(j == 0)
            break;
        if(*s == j)
            s++;
        else
            s = sp;
    }
    return *s == 0;
}
@

<<function fileline>>=
/*
 *	Convert a pc to a "file:line {file:line}" string.
 */
long
fileline(char *str, int n, uvlong dot)
{
    long line, top, bot, mid;
    File *f;

    *str = 0;
    if(buildtbls() == 0)
        return 0;
        /* binary search assumes file list is sorted by addr */
    bot = 0;
    top = nfiles;
    for (mid = (bot+top)/2; mid < top; mid = (bot+top)/2) {
        f = &files[mid];
        if(dot < f->addr)
            top = mid;
        else if(mid < nfiles-1 && dot >= (f+1)->addr)
            bot = mid;
        else {
            line = pc2line(dot);
            if(line > 0 && fline(str, n, line, f->hist, 0) >= 0)
                return 1;
            break;
        }
    }
    return 0;
}
@

<<function fline>>=
/*
 *	Convert a line number within a composite file to relative line
 *	number in a source file.  A composite file is the source
 *	file with included files inserted in line.
 */
static int
fline(char *str, int n, long line, Hist *base, Hist **ret)
{
    Hist *start;			/* start of current level */
    Hist *h;			/* current entry */
    long delta;			/* sum of size of files this level */
    int k;

    start = base;
    h = base;
    delta = h->line;
    while(h && h->name && line > h->line) {
        if(h->name[1] || h->name[2]) {
            if(h->offset != 0) {	/* #line Directive */
                delta = h->line-h->offset+1;
                start = h;
                base = h++;
            } else {		/* beginning of File */
                if(start == base)
                    start = h++;
                else {
                    k = fline(str, n, line, start, &h);
                    if(k <= 0)
                        return k;
                }
            }
        } else {
            if(start == base && ret) {	/* end of recursion level */
                *ret = h;
                return 1;
            } else {			/* end of included file */
                delta += h->line-start->line;
                h++;
                start = base;
            }
        }
    }
    if(!h)
        return -1;
    if(start != base)
        line = line-start->line+1;
    else
        line = line-delta+1;
    if(!h->name)
        strncpy(str, "<eof>", n);
    else {
        k = fileelem(fnames, (uchar*)start->name, str, n);
        if(k+8 < n)
            sprint(str+k, ":%ld", line);
    }
/**********Remove comments for complete back-trace of include sequence
 *	if(start != base) {
 *		k = strlen(str);
 *		if(k+2 < n) {
 *			str[k++] = ' ';
 *			str[k++] = '{';
 *		}
 *		k += fileelem(fnames, (uchar*) base->name, str+k, n-k);
 *		if(k+10 < n)
 *			sprint(str+k, ":%ld}", start->line-delta);
 *	}
 ********************/
    return 0;
}
@

<<function fileelem>>=
/*
 *	convert an encoded file name to a string.
 */
int
fileelem(Sym **fp, uchar *cp, char *buf, int n)
{
    int i, j;
    char *c, *bp, *end;
    Sym *sym;

    bp = buf;
    end = buf+n-1;
    for(i = 1; j = (cp[i]<<8)|cp[i+1]; i+=2){
        sym = fp[j];
        if (sym == nil)
            break;
        c = sym->name;
        if(bp != buf && bp[-1] != '/' && bp < end)
            *bp++ = '/';
        while(bp < end && *c)
            *bp++ = *c++;
    }
    *bp = 0;
    i =  bp-buf;
    if(i > 1) {
        cleanname(buf);
        i = strlen(buf);
    }
    return i;
}
@

<<function symcomp>>=
/*
 *	compare the values of two symbol table entries.
 */
static int
symcomp(void *a, void *b)
{
    int i;

    i = (*(Sym**)a)->value - (*(Sym**)b)->value;
    if (i)
        return i;
    return strcmp((*(Sym**)a)->name, (*(Sym**)b)->name);
}
@

<<function txtcomp>>=
/*
 *	compare the values of the symbols referenced by two text table entries
 */
static int
txtcomp(void *a, void *b)
{
    return ((Txtsym*)a)->sym->value - ((Txtsym*)b)->sym->value;
}
@

<<function filecomp>>=
/*
 *	compare the values of the symbols referenced by two file table entries
 */
static int
filecomp(void *a, void *b)
{
    return ((File*)a)->addr - ((File*)b)->addr;
}
@

<<function fillsym>>=
/*
 *	fill an interface Symbol structure from a symbol table entry
 */
static void
fillsym(Sym *sp, Symbol *s)
{
    s->type = sp->type;
    s->value = sp->value;
    s->name = sp->name;
    s->index = 0;
    switch(sp->type) {
    case 'b':
    case 'B':
    case 'D':
    case 'd':
        s->class = CDATA;
        break;
    case 't':
    case 'T':
    case 'l':
    case 'L':
        s->class = CTEXT;
        break;
    case 'a':
        s->class = CAUTO;
        break;
    case 'p':
        s->class = CPARAM;
        break;
    case 'm':
        s->class = CSTAB;
        break;
    default:
        s->class = CNONE;
        break;
    }
    s->handle = 0;
}
@

<<function pc2sp>>=
/*
 *	find the stack frame, given the pc
 */
uvlong
pc2sp(uvlong pc)
{
    uchar *c, u;
    uvlong currpc, currsp;

    if(spoff == 0)
        return ~0;
    currsp = 0;
    currpc = txtstart - mach->pcquant;

    if(pc<currpc || pc>txtend)
        return ~0;
    for(c = spoff; c < spoffend; c++) {
        if (currpc >= pc)
            return currsp;
        u = *c;
        if (u == 0) {
            currsp += (c[1]<<24)|(c[2]<<16)|(c[3]<<8)|c[4];
            c += 4;
        }
        else if (u < 65)
            currsp += 4*u;
        else if (u < 129)
            currsp -= 4*(u-64);
        else 
            currpc += mach->pcquant*(u-129);
        currpc += mach->pcquant;
    }
    return ~0;
}
@

<<function pc2line>>=
/*
 *	find the source file line number for a given value of the pc
 */
long
pc2line(uvlong pc)
{
    uchar *c, u;
    uvlong currpc;
    long currline;

    if(pcline == 0)
        return -1;
    currline = 0;
    currpc = txtstart-mach->pcquant;
    if(pc<currpc || pc>txtend)
        return ~0;

    for(c = pcline; c < pclineend; c++) {
        if(currpc >= pc)
            return currline;
        u = *c;
        if(u == 0) {
            currline += (c[1]<<24)|(c[2]<<16)|(c[3]<<8)|c[4];
            c += 4;
        }
        else if(u < 65)
            currline += u;
        else if(u < 129)
            currline -= (u-64);
        else 
            currpc += mach->pcquant*(u-129);
        currpc += mach->pcquant;
    }
    return ~0;
}
@

<<function line2addr>>=
/*
 *	find the pc associated with a line number
 *	basepc and endpc are text addresses bounding the search.
 *	if endpc == 0, the end of the table is used (i.e., no upper bound).
 *	usually, basepc and endpc contain the first text address in
 *	a file and the first text address in the following file, respectively.
 */
uvlong
line2addr(long line, uvlong basepc, uvlong endpc)
{
    uchar *c,  u;
    uvlong currpc, pc;
    long currline;
    long delta, d;
    int found;

    if(pcline == 0 || line == 0)
        return ~0;

    currline = 0;
    currpc = txtstart-mach->pcquant;
    pc = ~0;
    found = 0;
    delta = HUGEINT;

    for(c = pcline; c < pclineend; c++) {
        if(endpc && currpc >= endpc)	/* end of file of interest */
            break;
        if(currpc >= basepc) {		/* proper file */
            if(currline >= line) {
                d = currline-line;
                found = 1;
            } else
                d = line-currline;
            if(d < delta) {
                delta = d;
                pc = currpc;
            }
        }
        u = *c;
        if(u == 0) {
            currline += (c[1]<<24)|(c[2]<<16)|(c[3]<<8)|c[4];
            c += 4;
        }
        else if(u < 65)
            currline += u;
        else if(u < 129)
            currline -= (u-64);
        else 
            currpc += mach->pcquant*(u-129);
        currpc += mach->pcquant;
    }
    if(found)
        return pc;
    return ~0;
}
@

<<function printhist>>=
/*
 *	Print a history stack (debug). if count is 0, prints the whole stack
 */
static void
printhist(char *msg, Hist *hp, int count)
{
    int i;
    uchar *cp;
    char buf[128];

    i = 0;
    while(hp->name) {
        if(count && ++i > count)
            break;
        print("%s Line: %lx (%ld)  Offset: %lx (%ld)  Name: ", msg,
            hp->line, hp->line, hp->offset, hp->offset);
        for(cp = (uchar *)hp->name+1; (*cp<<8)|cp[1]; cp += 2) {
            if (cp != (uchar *)hp->name+1)
                print("/");
            print("%x", (*cp<<8)|cp[1]);
        }
        fileelem(fnames, (uchar *) hp->name, buf, sizeof(buf));
        print(" (%s)\n", buf);
        hp++;
    }
}
@

<<function dumphist>>=
/*
 *	print the history stack for a file. (debug only)
 *	if (name == 0) => print all history stacks.
 */
void
dumphist(char *name)
{
    int i;
    File *f;
    short *fname;

    if(buildtbls() == 0)
        return;
    if(name)
        fname = encfname(name);
    for(i = 0, f = files; i < nfiles; i++, f++)
        if(fname == 0 || hcomp(f->hist, fname))
            printhist("> ", f->hist, f->n);

    if(fname)
        free(fname);
}
@


%-------------------------------------------------------------

<<linkers/libmach/sym.c>>=
#include <u.h>
#include <libc.h>
#include <bio.h>
#include <mach.h>

<<constant HUGEINT>>
<<constant NNAME>>

typedef	struct txtsym Txtsym;
typedef	struct file File;
typedef	struct hist Hist;

<<struct txtsym>>

<<struct hist>>

<<struct file>>

<<global debug (linkers/libmach/sym.c)>>

<<global autos>>
<<global files>>
<<global fmax>>
<<global fnames (linkers/libmach/sym.c)>>
<<global globals>>
<<global hist>>
<<global isbuilt>>
<<global nauto>>
<<global nfiles>>
<<global nglob>>
<<global nhist>>
<<global nsym (linkers/libmach/sym.c)>>
<<global ntxt>>
<<global pcline>>
<<global pclineend>>
<<global spoff>>
<<global spoffend>>
<<global symbols>>
<<global txt>>
<<global txtstart>>
<<global txtend>>

static void	cleansyms(void);
static long	decodename(Biobuf*, Sym*);
static short	*encfname(char*);
static int 	fline(char*, int, long, Hist*, Hist**);
static void	fillsym(Sym*, Symbol*);
static int	findglobal(char*, Symbol*);
static int	findlocvar(Symbol*, char *, Symbol*);
static int	findtext(char*, Symbol*);
static int	hcomp(Hist*, short*);
static int	hline(File*, short*, long*);
static void	printhist(char*, Hist*, int);
static int	buildtbls(void);
static int	symcomp(void*, void*);
static int	symerrmsg(int, char*);
static int	txtcomp(void*, void*);
static int	filecomp(void*, void*);

<<function syminit>>

<<function symerrmsg>>

<<function decodename>>

<<function cleansyms>>

<<function textseg>>

<<function symbase>>

<<function getsym>>

<<function buildtbls>>

<<function lookup (linkers/libmach/sym.c)>>

<<function findtext>>
<<function findglobal>>

<<function findlocal>>

<<function findlocvar>>

<<function textsym>>

<<function filesym>>

<<function getauto>>

<<function srchtext>>

<<function srchdata>>

<<function findsym>>

<<function fnbound>>

<<function localsym>>

<<function globalsym>>

<<function file2pc>>

<<function pathcomp>>

<<function encfname>>

<<function hline>>

<<function hcomp>>

<<function fileline>>

<<function fline>>

<<function fileelem>>

<<function symcomp>>

<<function txtcomp>>

<<function filecomp>>

<<function fillsym>>

<<function pc2sp>>

<<function pc2line>>

<<function line2addr>>

<<function printhist>>

#ifdef DEBUG
<<function dumphist>>
#endif
@


\subsection*{[[linkers/libmach/8obj.c]]}

<<struct Addr>>=
struct Addr
{
    char	sym;
    char	flags;
};
@

<<function _is8>>=
int
_is8(char *t)
{
    uchar *s = (uchar*)t;

    return  s[0] == (ANAME&0xff)			/* aslo = ANAME */
        && s[1] == ((ANAME>>8)&0xff)
        && s[2] == D_FILE			/* type */
        && s[3] == 1				/* sym */
        && s[4] == '<';				/* name of file */
}
@

<<function _read8>>=
int
_read8(Biobuf *bp, Prog* p)
{
    int as, n, c;
    Addr a;

    as = Bgetc(bp);		/* as(low) */
    if(as < 0)
        return 0;
    c = Bgetc(bp);		/* as(high) */
    if(c < 0)
        return 0;
    as |= ((c & 0xff) << 8);
    p->kind = aNone;
    p->sig = 0;
    if(as == ANAME || as == ASIGNAME){
        if(as == ASIGNAME){
            Bread(bp, &p->sig, 4);
            p->sig = leswal(p->sig);
        }
        p->kind = aName;
        p->type = type2char(Bgetc(bp));		/* type */
        p->sym = Bgetc(bp);			/* sym */
        n = 0;
        for(;;) {
            as = Bgetc(bp);
            if(as < 0)
                return 0;
            n++;
            if(as == 0)
                break;
        }
        p->id = malloc(n);
        if(p->id == 0)
            return 0;
        Bseek(bp, -n, 1);
        if(Bread(bp, p->id, n) != n)
            return 0;
        return 1;
    }
    if(as == ATEXT)
        p->kind = aText;
    if(as == AGLOBL)
        p->kind = aData;
    skip(bp, 4);		/* lineno(4) */
    a = addr(bp);
    addr(bp);
    if(!(a.flags & T_SYM))
        p->kind = aNone;
    p->sym = a.sym;
    return 1;
}
@

<<function addr>>=
static Addr
addr(Biobuf *bp)
{
    Addr a;
    int t;
    long off;

    off = 0;
    a.sym = -1;
    a.flags = Bgetc(bp);			/* flags */
    if(a.flags & T_INDEX)
        skip(bp, 2);
    if(a.flags & T_OFFSET){
        off = Bgetc(bp);
        off |= Bgetc(bp) << 8;
        off |= Bgetc(bp) << 16;
        off |= Bgetc(bp) << 24;
        if(off < 0)
            off = -off;
    }
    if(a.flags & T_SYM)
        a.sym = Bgetc(bp);
    if(a.flags & T_FCONST)
        skip(bp, 8);
    else
    if(a.flags & T_SCONST)
        skip(bp, NSNAME);
    if(a.flags & T_TYPE) {
        t = Bgetc(bp);
        if(a.sym > 0 && (t==D_PARAM || t==D_AUTO))
            _offset(a.sym, off);
    }
    return a;
}
@

<<function type2char>>=
static char
type2char(int t)
{
    switch(t){
    case D_EXTERN:		return 'U';
    case D_STATIC:		return 'b';
    case D_AUTO:		return 'a';
    case D_PARAM:		return 'p';
    default:		return UNKNOWN;
    }
}
@

<<function skip (linkers/libmach/8obj.c)>>=
static void
skip(Biobuf *bp, int n)
{
    while (n-- > 0)
        Bgetc(bp);
}
@


%-------------------------------------------------------------

<<linkers/libmach/8obj.c>>=
/*
 * 8obj.c - identify and parse a 386 object file
 */
#include <u.h>
#include <libc.h>
#include <bio.h>
#include <mach.h>
#include "386/8.out.h"
#include "obj.h"

typedef struct Addr	Addr;
<<struct Addr>>
static	Addr	addr(Biobuf*);
static	char	type2char(int);
static	void	skip(Biobuf*, int);

<<function _is8>>

<<function _read8>>

<<function addr>>

<<function type2char>>

<<function skip (linkers/libmach/8obj.c)>>
@


\subsection*{[[linkers/libmach/access.c]]}

<<function geta>>=
/*
 * routines to get/put various types
 */
int
geta(Map *map, uvlong addr, uvlong *x)
{
    ulong l;
    uvlong vl;

    if (mach->szaddr == 8){
        if (get8(map, addr, &vl) < 0)
            return -1;
        *x = vl;
        return 1;
    }

    if (get4(map, addr, &l) < 0)
        return -1;
    *x = l;

    return 1;
}
@

<<function get8>>=
int
get8(Map *map, uvlong addr, uvlong *x)
{
    if (!map) {
        werrstr("get8: invalid map");
        return -1;
    }

    if (map->nsegs == 1 && map->seg[0].fd < 0) {
        *x = addr;
        return 1;
    }
    if (mget(map, addr, x, 8) < 0)
        return -1;
    *x = machdata->swav(*x);
    return 1;
}
@

<<function get4>>=
int
get4(Map *map, uvlong addr, ulong *x)
{
    if (!map) {
        werrstr("get4: invalid map");
        return -1;
    }

    if (map->nsegs == 1 && map->seg[0].fd < 0) {
        *x = addr;
        return 1;
    }
    if (mget(map, addr, x, 4) < 0)
        return -1;
    *x = machdata->swal(*x);
    return 1;
}
@

<<function get2>>=
int
get2(Map *map, uvlong addr, ushort *x)
{
    if (!map) {
        werrstr("get2: invalid map");
        return -1;
    }

    if (map->nsegs == 1 && map->seg[0].fd < 0) {
        *x = addr;
        return 1;
    }
    if (mget(map, addr, x, 2) < 0)
        return -1;
    *x = machdata->swab(*x);
    return 1;
}
@

<<function get1>>=
int
get1(Map *map, uvlong addr, uchar *x, int size)
{
    uchar *cp;

    if (!map) {
        werrstr("get1: invalid map");
        return -1;
    }

    if (map->nsegs == 1 && map->seg[0].fd < 0) {
        cp = (uchar*)&addr;
        while (cp < (uchar*)(&addr+1) && size-- > 0)
            *x++ = *cp++;
        while (size-- > 0)
            *x++ = 0;
    } else
        return mget(map, addr, x, size);
    return 1;
}
@

<<function puta>>=
int
puta(Map *map, uvlong addr, uvlong v)
{
    if (mach->szaddr == 8)
        return put8(map, addr, v);

    return put4(map, addr, v);
}
@

<<function put8>>=
int
put8(Map *map, uvlong addr, uvlong v)
{
    if (!map) {
        werrstr("put8: invalid map");
        return -1;
    }
    v = machdata->swav(v);
    return mput(map, addr, &v, 8);
}
@

<<function put4 (linkers/libmach/access.c)>>=
int
put4(Map *map, uvlong addr, ulong v)
{
    if (!map) {
        werrstr("put4: invalid map");
        return -1;
    }
    v = machdata->swal(v);
    return mput(map, addr, &v, 4);
}
@

<<function put2>>=
int
put2(Map *map, uvlong addr, ushort v)
{
    if (!map) {
        werrstr("put2: invalid map");
        return -1;
    }
    v = machdata->swab(v);
    return mput(map, addr, &v, 2);
}
@

<<function put1>>=
int
put1(Map *map, uvlong addr, uchar *v, int size)
{
    if (!map) {
        werrstr("put1: invalid map");
        return -1;
    }
    return mput(map, addr, v, size);
}
@

<<function spread>>=
static int
spread(struct segment *s, void *buf, int n, uvlong off)
{
    uvlong base;

    static struct {
        struct segment *s;
        char a[8192];
        uvlong off;
    } cache;

    if(s->cache){
        base = off&~(sizeof cache.a-1);
        if(cache.s != s || cache.off != base){
            cache.off = ~0;
            if(seek(s->fd, base, 0) >= 0
            && readn(s->fd, cache.a, sizeof cache.a) == sizeof cache.a){
                cache.s = s;
                cache.off = base;
            }
        }
        if(cache.s == s && cache.off == base){
            off &= sizeof cache.a-1;
            if(off+n > sizeof cache.a)
                n = sizeof cache.a - off;
            memmove(buf, cache.a+off, n);
            return n;
        }
    }

    return pread(s->fd, buf, n, off);
}
@

<<function mget>>=
static int
mget(Map *map, uvlong addr, void *buf, int size)
{
    uvlong off;
    int i, j, k;
    struct segment *s;

    s = reloc(map, addr, (vlong*)&off);
    if (!s)
        return -1;
    if (s->fd < 0) {
        werrstr("unreadable map");
        return -1;
    }
    for (i = j = 0; i < 2; i++) {	/* in case read crosses page */
        k = spread(s, (void*)((uchar *)buf+j), size-j, off+j);
        if (k < 0) {
            werrstr("can't read address %llux: %r", addr);
            return -1;
        }
        j += k;
        if (j == size)
            return j;
    }
    werrstr("partial read at address %llux (size %d j %d)", addr, size, j);
    return -1;
}
@

<<function mput>>=
static int
mput(Map *map, uvlong addr, void *buf, int size)
{
    vlong off;
    int i, j, k;
    struct segment *s;

    s = reloc(map, addr, &off);
    if (!s)
        return -1;
    if (s->fd < 0) {
        werrstr("unwritable map");
        return -1;
    }

    seek(s->fd, off, 0);
    for (i = j = 0; i < 2; i++) {	/* in case read crosses page */
        k = write(s->fd, buf, size-j);
        if (k < 0) {
            werrstr("can't write address %llux: %r", addr);
            return -1;
        }
        j += k;
        if (j == size)
            return j;
    }
    werrstr("partial write at address %llux", addr);
    return -1;
}
@

<<function reloc>>=
/*
 *	convert address to file offset; returns nonzero if ok
 */
static struct segment*
reloc(Map *map, uvlong addr, vlong *offp)
{
    int i;

    for (i = 0; i < map->nsegs; i++) {
        if (map->seg[i].inuse)
        if (map->seg[i].b <= addr && addr < map->seg[i].e) {
            *offp = addr + map->seg[i].f - map->seg[i].b;
            return &map->seg[i];
        }
    }
    werrstr("can't translate address %llux", addr);
    return 0;
}
@


%-------------------------------------------------------------

<<linkers/libmach/access.c>>=
/*
 * functions to read and write an executable or file image
 */

#include <u.h>
#include <libc.h>
#include <bio.h>
#include <mach.h>

static	int	mget(Map*, uvlong, void*, int);
static	int	mput(Map*, uvlong, void*, int);
static	struct	segment*	reloc(Map*, uvlong, vlong*);

<<function geta>>

<<function get8>>

<<function get4>>

<<function get2>>

<<function get1>>

<<function puta>>

<<function put8>>

<<function put4 (linkers/libmach/access.c)>>

<<function put2>>

<<function put1>>

<<function spread>>

<<function mget>>

<<function mput>>

<<function reloc>>
@


\subsection*{[[linkers/libmach/machdata.c]]}

<<constant STARTSYM>>=
#define STARTSYM	"_main"
@

<<constant PROFSYM>>=
#define PROFSYM		"_mainp"
@

<<constant FRAMENAME>>=
#define	FRAMENAME	".frame"
@

<<global asstype>>=
int	asstype = AMIPS;		/* disassembler type */
@

<<global machdata>>=
Machdata *machdata;		/* machine-dependent functions */
@

<<function localaddr>>=
int
localaddr(Map *map, char *fn, char *var, uvlong *r, Rgetter rget)
{
    Symbol s;
    uvlong fp, pc, sp, link;

    if (!lookup(fn, 0, &s)) {
        werrstr("function not found");
        return -1;
    }
    pc = rget(map, mach->pc);
    sp = rget(map, mach->sp);
    if(mach->link)
        link = rget(map, mach->link);
    else
        link = 0;
    fp = machdata->findframe(map, s.value, pc, sp, link);
    if (fp == 0) {
        werrstr("stack frame not found");
        return -1;
    }

    if (!var || !var[0]) {
        *r = fp;
        return 1;
    }

    if (findlocal(&s, var, &s) == 0) {
        werrstr("local variable not found");
        return -1;
    }

    switch (s.class) {
    case CAUTO:
        *r = fp - s.value;
        break;
    case CPARAM:		/* assume address size is stack width */
        *r = fp + s.value + mach->szaddr;
        break;
    default:
        werrstr("local variable not found: %d", s.class);
        return -1;
    }
    return 1;
}
@

<<function symoff>>=
/*
 * Print value v as s.name[+offset] if possible, or just v.
 */
int
symoff(char *buf, int n, uvlong v, int space)
{
    Symbol s;
    int r;
    long delta;

    r = delta = 0;		/* to shut compiler up */
    if (v) {
        r = findsym(v, space, &s);
        if (r)
            delta = v-s.value;
        if (delta < 0)
            delta = -delta;
    }
    if (v == 0 || r == 0)
        return snprint(buf, n, "%llux", v);
    if (s.type != 't' && s.type != 'T' && delta >= 4096)
        return snprint(buf, n, "%llux", v);
    else if (delta)
        return snprint(buf, n, "%s+%lux", s.name, delta);
    else
        return snprint(buf, n, "%s", s.name);
}
@

<<function fpformat>>=
/*
 *	Format floating point registers
 *
 *	Register codes in format field:
 *	'X' - print as 32-bit hexadecimal value
 *	'F' - 64-bit double register when modif == 'F'; else 32-bit single reg
 *	'f' - 32-bit ieee float
 *	'8' - big endian 80-bit ieee extended float
 *	'3' - little endian 80-bit ieee extended float with hole in bytes 8&9
 */
int
fpformat(Map *map, Reglist *rp, char *buf, int n, int modif)
{
    char reg[12];
    ulong r;

    switch(rp->rformat)
    {
    case 'X':
        if (get4(map, rp->roffs, &r) < 0)
            return -1;
        snprint(buf, n, "%lux", r);
        break;
    case 'F':	/* first reg of double reg pair */
        if (modif == 'F')
        if ((rp->rformat=='F') || (((rp+1)->rflags&RFLT) && (rp+1)->rformat == 'f')) {
            if (get1(map, rp->roffs, (uchar *)reg, 8) < 0)
                return -1;
            machdata->dftos(buf, n, reg);
            if (rp->rformat == 'F')
                return 1;
            return 2;
        }	
            /* treat it like 'f' */
        if (get1(map, rp->roffs, (uchar *)reg, 4) < 0)
            return -1;
        machdata->sftos(buf, n, reg);
        break;
    case 'f':	/* 32 bit float */
        if (get1(map, rp->roffs, (uchar *)reg, 4) < 0)
            return -1;
        machdata->sftos(buf, n, reg);
        break;
    case '3':	/* little endian ieee 80 with hole in bytes 8&9 */
        if (get1(map, rp->roffs, (uchar *)reg, 10) < 0)
            return -1;
        memmove(reg+10, reg+8, 2);	/* open hole */
        memset(reg+8, 0, 2);		/* fill it */
        leieee80ftos(buf, n, reg);
        break;
    case '8':	/* big-endian ieee 80 */
        if (get1(map, rp->roffs, (uchar *)reg, 10) < 0)
            return -1;
        beieee80ftos(buf, n, reg);
        break;
    default:	/* unknown */
        break;
    }
    return 1;
}
@

<<function _hexify>>=
char *
_hexify(char *buf, ulong p, int zeros)
{
    ulong d;

    d = p/16;
    if(d)
        buf = _hexify(buf, d, zeros-1);
    else
        while(zeros--)
            *buf++ = '0';
    *buf++ = "0123456789abcdef"[p&0x0f];
    return buf;
}
@

<<function ieeedftos>>=
/*
 * These routines assume that if the number is representable
 * in IEEE floating point, it will be representable in the native
 * double format.  Naive but workable, probably.
 */
int
ieeedftos(char *buf, int n, ulong h, ulong l)
{
    double fr;
    int exp;

    if (n <= 0)
        return 0;


    if(h & (1L<<31)){
        *buf++ = '-';
        h &= ~(1L<<31);
    }else
        *buf++ = ' ';
    n--;
    if(l == 0 && h == 0)
        return snprint(buf, n, "0.");
    exp = (h>>20) & ((1L<<11)-1L);
    if(exp == 0)
        return snprint(buf, n, "DeN(%.8lux%.8lux)", h, l);
    if(exp == ((1L<<11)-1L)){
        if(l==0 && (h&((1L<<20)-1L)) == 0)
            return snprint(buf, n, "Inf");
        else
            return snprint(buf, n, "NaN(%.8lux%.8lux)", h&((1L<<20)-1L), l);
    }
    exp -= (1L<<10) - 2L;
    fr = l & ((1L<<16)-1L);
    fr /= 1L<<16;
    fr += (l>>16) & ((1L<<16)-1L);
    fr /= 1L<<16;
    fr += (h & (1L<<20)-1L) | (1L<<20);
    fr /= 1L<<21;
    fr = ldexp(fr, exp);
    return snprint(buf, n, "%.18g", fr);
}
@

<<function ieeesftos>>=
int
ieeesftos(char *buf, int n, ulong h)
{
    double fr;
    int exp;

    if (n <= 0)
        return 0;

    if(h & (1L<<31)){
        *buf++ = '-';
        h &= ~(1L<<31);
    }else
        *buf++ = ' ';
    n--;
    if(h == 0)
        return snprint(buf, n, "0.");
    exp = (h>>23) & ((1L<<8)-1L);
    if(exp == 0)
        return snprint(buf, n, "DeN(%.8lux)", h);
    if(exp == ((1L<<8)-1L)){
        if((h&((1L<<23)-1L)) == 0)
            return snprint(buf, n, "Inf");
        else
            return snprint(buf, n, "NaN(%.8lux)", h&((1L<<23)-1L));
    }
    exp -= (1L<<7) - 2L;
    fr = (h & ((1L<<23)-1L)) | (1L<<23);
    fr /= 1L<<24;
    fr = ldexp(fr, exp);
    return snprint(buf, n, "%.9g", fr);
}
@

<<function beieeesftos>>=
int
beieeesftos(char *buf, int n, void *s)
{
    return ieeesftos(buf, n, beswal(*(ulong*)s));
}
@

<<function beieeedftos>>=
int
beieeedftos(char *buf, int n, void *s)
{
    return ieeedftos(buf, n, beswal(*(ulong*)s), beswal(((ulong*)(s))[1]));
}
@

<<function leieeesftos>>=
int
leieeesftos(char *buf, int n, void *s)
{
    return ieeesftos(buf, n, leswal(*(ulong*)s));
}
@

<<function leieeedftos>>=
int
leieeedftos(char *buf, int n, void *s)
{
    return ieeedftos(buf, n, leswal(((ulong*)(s))[1]), leswal(*(ulong*)s));
}
@

<<function beieee80ftos>>=
/* packed in 12 bytes, with s[2]==s[3]==0; mantissa starts at s[4]*/
int
beieee80ftos(char *buf, int n, void *s)
{
    uchar *reg = (uchar*)s;
    int i;
    ulong x;
    uchar ieee[8+8];	/* room for slop */
    uchar *p, *q;

    memset(ieee, 0, sizeof(ieee));
    /* sign */
    if(reg[0] & 0x80)
        ieee[0] |= 0x80;

    /* exponent */
    x = ((reg[0]&0x7F)<<8) | reg[1];
    if(x == 0)		/* number is ±0 */
        goto done;
    if(x == 0x7FFF){
        if(memcmp(reg+4, ieee+1, 8) == 0){ /* infinity */
            x = 2047;
        }else{				/* NaN */
            x = 2047;
            ieee[7] = 0x1;		/* make sure */
        }
        ieee[0] |= x>>4;
        ieee[1] |= (x&0xF)<<4;
        goto done;
    }
    x -= 0x3FFF;		/* exponent bias */
    x += 1023;
    if(x >= (1<<11) || ((reg[4]&0x80)==0 && x!=0))
        return snprint(buf, n, "not in range");
    ieee[0] |= x>>4;
    ieee[1] |= (x&0xF)<<4;

    /* mantissa */
    p = reg+4;
    q = ieee+1;
    for(i=0; i<56; i+=8, p++, q++){	/* move one byte */
        x = (p[0]&0x7F) << 1;
        if(p[1] & 0x80)
            x |= 1;
        q[0] |= x>>4;
        q[1] |= (x&0xF)<<4;
    }
    done:
    return beieeedftos(buf, n, (void*)ieee);
}
@

<<function leieee80ftos>>=
int
leieee80ftos(char *buf, int n, void *s)
{
    int i;
    char *cp;
    char b[12];

    cp = (char*) s;
    for(i=0; i<12; i++)
        b[11-i] = *cp++;
    return beieee80ftos(buf, n, b);
}
@

<<function cisctrace>>=
int
cisctrace(Map *map, uvlong pc, uvlong sp, uvlong link, Tracer trace)
{
    Symbol s;
    int found, i;
    uvlong opc, moved;

    USED(link);
    i = 0;
    opc = 0;
    while(pc && opc != pc) {
        moved = pc2sp(pc);
        if (moved == ~0)
            break;
        found = findsym(pc, CTEXT, &s);
        if (!found)
            break;
        if(strcmp(STARTSYM, s.name) == 0 || strcmp(PROFSYM, s.name) == 0)
            break;

        sp += moved;
        opc = pc;
        if (geta(map, sp, &pc) < 0)
            break;
        (*trace)(map, pc, sp, &s);
        sp += mach->szaddr;	/*assumes address size = stack width*/
        if(++i > 40)
            break;
    }
    return i;
}
@

<<function risctrace>>=
int
risctrace(Map *map, uvlong pc, uvlong sp, uvlong link, Tracer trace)
{
    int i;
    Symbol s, f;
    uvlong oldpc;

    i = 0;
    while(findsym(pc, CTEXT, &s)) {
        if(strcmp(STARTSYM, s.name) == 0 || strcmp(PROFSYM, s.name) == 0)
            break;

        if(pc == s.value)	/* at first instruction */
            f.value = 0;
        else if(findlocal(&s, FRAMENAME, &f) == 0)
            break;

        oldpc = pc;
        if(s.type == 'L' || s.type == 'l' || pc <= s.value+mach->pcquant)
            pc = link;
        else
            if (geta(map, sp, &pc) < 0)
                break;

        if(pc == 0 || (pc == oldpc && f.value == 0))
            break;

        sp += f.value;
        (*trace)(map, pc-8, sp, &s);

        if(++i > 40)
            break;
    }
    return i;
}
@

<<function ciscframe>>=
uvlong
ciscframe(Map *map, uvlong addr, uvlong pc, uvlong sp, uvlong link)
{
    Symbol s;
    uvlong moved;

    USED(link);
    for(;;) {
        moved = pc2sp(pc);
        if (moved  == ~0)
            break;
        sp += moved;
        findsym(pc, CTEXT, &s);
        if (addr == s.value)
            return sp;
        if (geta(map, sp, &pc) < 0)
            break;
        sp += mach->szaddr;	/*assumes sizeof(addr) = stack width*/
    }
    return 0;
}
@

<<function riscframe>>=
uvlong
riscframe(Map *map, uvlong addr, uvlong pc, uvlong sp, uvlong link)
{
    Symbol s, f;

    while (findsym(pc, CTEXT, &s)) {
        if(strcmp(STARTSYM, s.name) == 0 || strcmp(PROFSYM, s.name) == 0)
            break;

        if(pc == s.value)	/* at first instruction */
            f.value = 0;
        else
        if(findlocal(&s, FRAMENAME, &f) == 0)
            break;

        sp += f.value;
        if (s.value == addr)
            return sp;

        if (s.type == 'L' || s.type == 'l' || pc-s.value <= mach->szaddr*2)
            pc = link;
        else
        if (geta(map, sp-f.value, &pc) < 0)
            break;
    }
    return 0;
}
@


%-------------------------------------------------------------

<<linkers/libmach/machdata.c>>=
/*
 * Debugger utilities shared by at least two architectures
 */

#include <u.h>
#include <libc.h>
#include <bio.h>
#include <mach.h>

<<constant STARTSYM>>
<<constant PROFSYM>>
<<constant FRAMENAME>>

extern	Machdata	mipsmach;

<<global asstype>>
<<global machdata>>

<<function localaddr>>

<<function symoff>>

<<function fpformat>>

<<function _hexify>>

<<function ieeedftos>>

<<function ieeesftos>>

<<function beieeesftos>>

<<function beieeedftos>>

<<function leieeesftos>>

<<function leieeedftos>>

<<function beieee80ftos>>

<<function leieee80ftos>>

<<function cisctrace>>

<<function risctrace>>

<<function ciscframe>>

<<function riscframe>>
@


\subsection*{[[linkers/libmach/obj.c]]}

<<function islocal>>=
#define islocal(t)	((t)=='a' || (t)=='p')
@

<<enum _anon_ (linkers/libmach/obj.c)>>=
enum
{
    NNAMES	= 50,
    MAXIS	= 8,		/* max length to determine if a file is a .? file */
    MAXOFF	= 0x7fffffff,	/* larger than any possible local offset */
    NHASH	= 1024,		/* must be power of two */
    HASHMUL	= 79L,
};
@

<<struct Obj>>=
struct	Obj		/* functions to handle each intermediate (.$O) file */
{
    char	*name;				/* name of each $O file */
    int	(*is)(char*);			/* test for each type of $O file */
    int	(*read)(Biobuf*, Prog*);	/* read for each type of $O file*/
};
@

<<global obj>>=
static Obj	obj[] =
{			/* functions to identify and parse each type of obj */
    [ObjArm]	"arm .5",	_is5, _read5,
    [Obj386]	"386 .8",	_is8, _read8,
    [ObjMips]	"mips .v",	_isv, _readv,
    [Maxobjtype]	0, 0
};
@

<<struct Symtab>>=
struct	Symtab
{
    struct	Sym 	s;
    struct	Symtab	*next;
};
@

<<global hash (linkers/libmach/obj.c)>>=
static	Symtab *hash[NHASH];
@

<<global names>>=
static	Sym	*names[NNAMES];	/* working set of active names */
@

<<function objtype>>=
int
objtype(Biobuf *bp, char **name)
{
    int i;
    char buf[MAXIS];

    if(Bread(bp, buf, MAXIS) < MAXIS)
        return -1;
    Bseek(bp, -MAXIS, 1);
    for (i = 0; i < Maxobjtype; i++) {
        if (obj[i].is && (*obj[i].is)(buf)) {
            if (name)
                *name = obj[i].name;
            return i;
        }
    }
    return -1;
}
@

<<function isar>>=
int
isar(Biobuf *bp)
{
    int n;
    char magbuf[SARMAG];

    n = Bread(bp, magbuf, SARMAG);
    if(n == SARMAG && strncmp(magbuf, ARMAG, SARMAG) == 0)
        return 1;
    return 0;
}
@

<<function readobj>>=
/*
 * determine what kind of object file this is and process it.
 * return whether or not this was a recognized intermediate file.
 */
int
readobj(Biobuf *bp, int objtype)
{
    Prog p;

    if (objtype < 0 || objtype >= Maxobjtype || obj[objtype].is == 0)
        return 1;
    objreset();
    while ((*obj[objtype].read)(bp, &p))
        if (!processprog(&p, 1))
            return 0;
    return 1;
}
@

<<function readar>>=
int
readar(Biobuf *bp, int objtype, vlong end, int doautos)
{
    Prog p;

    if (objtype < 0 || objtype >= Maxobjtype || obj[objtype].is == 0)
        return 1;
    objreset();
    while ((*obj[objtype].read)(bp, &p) && Boffset(bp) < end)
        if (!processprog(&p, doautos))
            return 0;
    return 1;
}
@

<<function processprog>>=
/*
 *	decode a symbol reference or definition
 */
static	int
processprog(Prog *p, int doautos)
{
    if(p->kind == aNone)
        return 1;
    if(p->sym < 0 || p->sym >= NNAMES)
        return 0;
    switch(p->kind)
    {
    case aName:
        if (!doautos)
        if(p->type != 'U' && p->type != 'b')
            break;
        objlookup(p->sym, p->id, p->type, p->sig);
        break;
    case aText:
        objupdate(p->sym, 'T');
        break;
    case aData:
        objupdate(p->sym, 'D');
        break;
    default:
        break;
    }
    return 1;
}
@

<<function objlookup>>=
/*
 * find the entry for s in the symbol array.
 * make a new entry if it is not already there.
 */
static void
objlookup(int id, char *name, int type, uint sig)
{
    long h;
    char *cp;
    Sym *s;
    Symtab *sp;

    s = names[id];
    if(s && strcmp(s->name, name) == 0) {
        s->type = type;
        s->sig = sig;
        return;
    }

    h = *name;
    for(cp = name+1; *cp; h += *cp++)
        h *= HASHMUL;
    if(h < 0)
        h = ~h;
    h &= (NHASH-1);
    if (type == 'U' || type == 'b' || islocal(type)) {
        for(sp = hash[h]; sp; sp = sp->next)
            if(strcmp(sp->s.name, name) == 0) {
                switch(sp->s.type) {
                case 'T':
                case 'D':
                case 'U':
                    if (type == 'U') {
                        names[id] = &sp->s;
                        return;
                    }
                    break;
                case 't':
                case 'd':
                case 'b':
                    if (type == 'b') {
                        names[id] = &sp->s;
                        return;
                    }
                    break;
                case 'a':
                case 'p':
                    if (islocal(type)) {
                        names[id] = &sp->s;
                        return;
                    }
                    break;
                default:
                    break;
                }
            }
    }
    sp = malloc(sizeof(Symtab));
    sp->s.name = name;
    sp->s.type = type;
    sp->s.sig = sig;
    sp->s.value = islocal(type) ? MAXOFF : 0;
    names[id] = &sp->s;
    sp->next = hash[h];
    hash[h] = sp;
    return;
}
@

<<function objtraverse>>=
/*
 *	traverse the symbol lists
 */
void
objtraverse(void (*fn)(Sym*, void*), void *pointer)
{
    int i;
    Symtab *s;

    for(i = 0; i < NHASH; i++)
        for(s = hash[i]; s; s = s->next)
            (*fn)(&s->s, pointer);
}
@

<<function _offset>>=
/*
 * update the offset information for a 'a' or 'p' symbol in an intermediate file
 */
void
_offset(int id, vlong off)
{
    Sym *s;

    s = names[id];
    if (s && s->name[0] && islocal(s->type) && s->value > off)
        s->value = off;
}
@

<<function objupdate>>=
/*
 * update the type of a global text or data symbol
 */
static void 
objupdate(int id, int type)
{
    Sym *s;

    s = names[id];
    if (s && s->name[0])
        if (s->type == 'U')
            s->type = type;
        else if (s->type == 'b')
            s->type = tolower(type);
}
@

<<function nextar>>=
/*
 * look for the next file in an archive
 */
int
nextar(Biobuf *bp, int offset, char *buf)
{
    struct ar_hdr a;
    int i, r;
    long arsize;

    if (offset&01)
        offset++;
    Bseek(bp, offset, 0);
    r = Bread(bp, &a, SAR_HDR);
    if(r != SAR_HDR)
        return 0;
    if(strncmp(a.fmag, ARFMAG, sizeof(a.fmag)))
        return -1;
    for(i=0; i<sizeof(a.name) && i<SARNAME && a.name[i] != ' '; i++)
        buf[i] = a.name[i];
    buf[i] = 0;
    arsize = strtol(a.size, 0, 0);
    if (arsize&1)
        arsize++;
    return arsize + SAR_HDR;
}
@

<<function objreset>>=
static void
objreset(void)
{
    int i;
    Symtab *s, *n;

    for(i = 0; i < NHASH; i++) {
        for(s = hash[i]; s; s = n) {
            n = s->next;
            free(s->s.name);
            free(s);
        }
        hash[i] = 0;
    }
    memset(names, 0, sizeof names);
}
@


%-------------------------------------------------------------

<<linkers/libmach/obj.c>>=
/*
 * obj.c
 * routines universal to all object files
 */
#include <u.h>
#include <libc.h>
#include <bio.h>
#include <ar.h>
#include <mach.h>
#include "obj.h"

<<function islocal>>

<<enum _anon_ (linkers/libmach/obj.c)>>

int			/* in [$OS].c */
  _is5(char*),
  _is8(char*),
  _isv(char*),
  _read5(Biobuf*, Prog*),
  _read8(Biobuf*, Prog*),
  _readv(Biobuf*, Prog*);


typedef struct Obj	Obj;
typedef struct Symtab	Symtab;

<<struct Obj>>

<<global obj>>

<<struct Symtab>>

<<global hash (linkers/libmach/obj.c)>>
<<global names>>

static	int	processprog(Prog*,int);	/* decode each symbol reference */
static	void	objreset(void);
static	void	objlookup(int, char *, int, uint);
static	void 	objupdate(int, int);

<<function objtype>>

<<function isar>>

<<function readobj>>

<<function readar>>

<<function processprog>>

<<function objlookup>>
<<function objtraverse>>

<<function _offset>>

<<function objupdate>>

<<function nextar>>

<<function objreset>>
@

%$ 

\subsection*{[[linkers/libmach/8db.c]]}

<<global STARTSYM>>=
static	char	STARTSYM[] =	"_main";
@

<<global PROFSYM>>=
static	char	PROFSYM[] =	"_mainp";
@

<<global FRAMENAME>>=
static	char	FRAMENAME[] =	".frame";
@

<<global excname>>=
static char *excname[] =
{
[0]	"divide error",
[1]	"debug exception",
[4]	"overflow",
[5]	"bounds check",
[6]	"invalid opcode",
[7]	"math coprocessor emulation",
[8]	"double fault",
[9]	"math coprocessor overrun",
[10]	"invalid TSS",
[11]	"segment not present",
[12]	"stack exception",
[13]	"general protection violation",
[14]	"page fault",
[16]	"math coprocessor error",
[17]	"alignment check",
[18]	"machine check",
[19]	"floating-point exception",
[24]	"clock",
[25]	"keyboard",
[27]	"modem status",
[28]	"serial line status",
[30]	"floppy disk",
[36]	"mouse",
[37]	"math coprocessor",
[38]	"hard disk",
[64]	"system call",
};
@

<<global i386mach>>=
Machdata i386mach =
{
    {0xCC, 0, 0, 0},	/* break point: INT 3 */
    1,			/* break point size */

    leswab,			/* convert short to local byte order */
    leswal,			/* convert long to local byte order */
    leswav,			/* convert vlong to local byte order */
    i386trace,		/* C traceback */
    i386frame,		/* frame finder */
    i386excep,		/* print exception */
    0,			/* breakpoint fixup */
    leieeesftos,		/* single precision float printer */
    leieeedftos,		/* double precision float printer */
    i386foll,		/* following addresses */
    i386inst,		/* print instruction */
    i386das,		/* dissembler */
    i386instlen,		/* instruction size calculation */
};
@

<<function i386excep>>=
static char*
i386excep(Map *map, Rgetter rget)
{
    ulong c;
    uvlong pc;
    static char buf[16];

    c = (*rget)(map, "TRAP");
    if(c > 64 || excname[c] == 0) {
        if (c == 3) {
            pc = (*rget)(map, "PC");
            if (get1(map, pc, (uchar*)buf, machdata->bpsize) > 0)
            if (memcmp(buf, machdata->bpinst, machdata->bpsize) == 0)
                return "breakpoint";
        }
        snprint(buf, sizeof(buf), "exception %ld", c);
        return buf;
    } else
        return excname[c];
}
@

<<function i386trace>>=
static int
i386trace(Map *map, uvlong pc, uvlong sp, uvlong link, Tracer trace)
{
    int i;
    uvlong osp;
    Symbol s, f;

    USED(link);
    i = 0;
    osp = 0;
    while(findsym(pc, CTEXT, &s)) {
        if (osp == sp)
            break;
        osp = sp;

        if(strcmp(STARTSYM, s.name) == 0 || strcmp(PROFSYM, s.name) == 0)
            break;

        if(pc != s.value) {	/* not at first instruction */
            if(findlocal(&s, FRAMENAME, &f) == 0)
                break;
            sp += f.value-mach->szaddr;
        }

        if (geta(map, sp, &pc) < 0)
            break;

        if(pc == 0)
            break;

        (*trace)(map, pc, sp, &s);
        sp += mach->szaddr;

        if(++i > 1000)
            break;
    }
    return i;
}
@

<<function i386frame>>=
static uvlong
i386frame(Map *map, uvlong addr, uvlong pc, uvlong sp, uvlong link)
{
    Symbol s, f;

    USED(link);
    while (findsym(pc, CTEXT, &s)) {
        if(strcmp(STARTSYM, s.name) == 0 || strcmp(PROFSYM, s.name) == 0)
            break;

        if(pc != s.value) {	/* not first instruction */
            if(findlocal(&s, FRAMENAME, &f) == 0)
                break;
            sp += f.value-mach->szaddr;
        }

        if (s.value == addr)
            return sp;

        if (geta(map, sp, &pc) < 0)
            break;
        sp += mach->szaddr;
    }
    return 0;
}
@

<<struct Instr>>=
struct	Instr
{
    uchar	mem[1+1+1+1+2+1+1+4+4];		/* raw instruction */
    uvlong	addr;		/* address of start of instruction */
    int	n;		/* number of bytes in instruction */
    char	*prefix;	/* instr prefix */
    char	*segment;	/* segment override */
    uchar	jumptype;	/* set to the operand type for jump/ret/call */
    uchar	amd64;
    uchar	rex;		/* REX prefix (or zero) */
    char	osize;		/* 'W' or 'L' (or 'Q' on amd64) */
    char	asize;		/* address size 'W' or 'L' (or 'Q' or amd64) */
    uchar	mod;		/* bits 6-7 of mod r/m field */
    uchar	reg;		/* bits 3-5 of mod r/m field */
    char	ss;		/* bits 6-7 of SIB */
    char	index;		/* bits 3-5 of SIB */
    char	base;		/* bits 0-2 of SIB */
    char	rip;		/* RIP-relative in amd64 mode */
    uchar	opre;		/* f2/f3 could introduce media */
    short	seg;		/* segment of far address */
    ulong	disp;		/* displacement */
    ulong 	imm;		/* immediate */
    ulong 	imm2;		/* second immediate operand */
    uvlong	imm64;		/* big immediate */
    char	*curr;		/* fill level in output buffer */
    char	*end;		/* end of output buffer */
    char	*err;		/* error message */
};
@

<<enum _anon_ (linkers/libmach/8db.c)>>=
enum{
    AX=0,
    CX,
    DX,
    BX,
    SP,
    BP,
    SI,
    DI,

    /* amd64 */
    R8,
    R9,
    R10,
    R11,
    R12,
    R13,
    R14,
    R15
};
@

<<enum _anon_ (linkers/libmach/8db.c)2>>=
enum{
    REXW		= 1<<3,	/* =1, 64-bit operand size */
    REXR		= 1<<2,	/* extend modrm reg */
    REXX		= 1<<1,	/* extend sib index */
    REXB		= 1<<0	/* extend modrm r/m, sib base, or opcode reg */
};
@

<<struct Optable>>=
struct Optable
{
    char	operand[2];
    void	*proto;		/* actually either (char*) or (Optable*) */
};
@

<<enum _anon_ (linkers/libmach/8db.c)3>>=
enum {
    Ib = 1,			/* 8-bit immediate - (no sign extension)*/
    Ibs,			/* 8-bit immediate (sign extended) */
    Jbs,			/* 8-bit sign-extended immediate in jump or call */
    Iw,			/* 16-bit immediate -> imm */
    Iw2,			/* 16-bit immediate -> imm2 */
    Iwd,			/* Operand-sized immediate (no sign extension)*/
    Iwdq,			/* Operand-sized immediate, possibly 64 bits */
    Awd,			/* Address offset */
    Iwds,			/* Operand-sized immediate (sign extended) */
    RM,			/* Word or long R/M field with register (/r) */
    RMB,			/* Byte R/M field with register (/r) */
    RMOP,			/* Word or long R/M field with op code (/digit) */
    RMOPB,			/* Byte R/M field with op code (/digit) */
    RMR,			/* R/M register only (mod = 11) */
    RMM,			/* R/M memory only (mod = 0/1/2) */
    R0,			/* Base reg of Mod R/M is literal 0x00 */
    R1,			/* Base reg of Mod R/M is literal 0x01 */
    FRMOP,			/* Floating point R/M field with opcode */
    FRMEX,			/* Extended floating point R/M field with opcode */
    JUMP,			/* Jump or Call flag - no operand */
    RET,			/* Return flag - no operand */
    OA,			/* literal 0x0a byte */
    PTR,			/* Seg:Displacement addr (ptr16:16 or ptr16:32) */
    AUX,			/* Multi-byte op code - Auxiliary table */
    AUXMM,			/* multi-byte op code - auxiliary table chosen by prefix */
    PRE,			/* Instr Prefix */
    OPRE,			/* Instr Prefix or media op extension */
    SEG,			/* Segment Prefix */
    OPOVER,			/* Operand size override */
    ADDOVER,		/* Address size override */
};
@

<<global optab0F00>>=
static Optable optab0F00[8]=
{
[0x00]	0,0,		"MOVW	LDT,%e",
[0x01]	0,0,		"MOVW	TR,%e",
[0x02]	0,0,		"MOVW	%e,LDT",
[0x03]	0,0,		"MOVW	%e,TR",
[0x04]	0,0,		"VERR	%e",
[0x05]	0,0,		"VERW	%e",
};
@

<<global optab0F01>>=
static Optable optab0F01[8]=
{
[0x00]	0,0,		"MOVL	GDTR,%e",
[0x01]	0,0,		"MOVL	IDTR,%e",
[0x02]	0,0,		"MOVL	%e,GDTR",
[0x03]	0,0,		"MOVL	%e,IDTR",
[0x04]	0,0,		"MOVW	MSW,%e",	/* word */
[0x06]	0,0,		"MOVW	%e,MSW",	/* word */
[0x07]	0,0,		"INVLPG	%e",		/* or SWAPGS */
};
@

<<global optab0F01F8>>=
static Optable optab0F01F8[1]=
{
[0x00]	0,0,		"SWAPGS",
};
@

<<global optab0FAE>>=
/* 0F73 */

static Optable optab0FAE[8]=
{
[0x00]	0,0,		"FXSAVE	%e",
[0x01]	0,0,		"FXRSTOR	%e",
[0x02]	0,0,		"LDMXCSR	%e",
[0x03]	0,0,		"STMXCSR	%e",
[0x05]	0,0,		"LFENCE",
[0x06]	0,0,		"MFENCE",
[0x07]	0,0,		"SFENCE",
};
@

<<global optab0FBA>>=
/* 0F0D */

static Optable optab0FBA[8]=
{
[0x04]	Ib,0,		"BT%S	%i,%e",
[0x05]	Ib,0,		"BTS%S	%i,%e",
[0x06]	Ib,0,		"BTR%S	%i,%e",
[0x07]	Ib,0,		"BTC%S	%i,%e",
};
@

<<global optab0F0F>>=
static Optable optab0F0F[256]=
{
[0x0c]	0,0,		"PI2FW	%m,%M",
[0x0d]	0,0,		"PI2L	%m,%M",
[0x1c]	0,0,		"PF2IW	%m,%M",
[0x1d]	0,0,		"PF2IL	%m,%M",
[0x8a]	0,0,		"PFNACC	%m,%M",
[0x8e]	0,0,		"PFPNACC	%m,%M",
[0x90]	0,0,		"PFCMPGE	%m,%M",
[0x94]	0,0,		"PFMIN	%m,%M",
[0x96]	0,0,		"PFRCP	%m,%M",
[0x97]	0,0,		"PFRSQRT	%m,%M",
[0x9a]	0,0,		"PFSUB	%m,%M",
[0x9e]	0,0,		"PFADD	%m,%M",
[0xa0]	0,0,		"PFCMPGT	%m,%M",
[0xa4]	0,0,		"PFMAX	%m,%M",
[0xa6]	0,0,		"PFRCPIT1	%m,%M",
[0xa7]	0,0,		"PFRSQIT1	%m,%M",
[0xaa]	0,0,		"PFSUBR	%m,%M",
[0xae]	0,0,		"PFACC	%m,%M",
[0xb0]	0,0,		"PFCMPEQ	%m,%M",
[0xb4]	0,0,		"PFMUL	%m,%M",
[0xb6]	0,0,		"PFRCPI2T	%m,%M",
[0xb7]	0,0,		"PMULHRW	%m,%M",
[0xbb]	0,0,		"PSWAPL	%m,%M",
};
@

<<global optab0FC7>>=
static Optable optab0FC7[8]=
{
[0x01]	0,0,		"CMPXCHG8B	%e",
};
@

<<global optab660F71>>=
static Optable optab660F71[8]=
{
[0x02]	Ib,0,		"PSRLW	%i,%X",
[0x04]	Ib,0,		"PSRAW	%i,%X",
[0x06]	Ib,0,		"PSLLW	%i,%X",
};
@

<<global optab660F72>>=
static Optable optab660F72[8]=
{
[0x02]	Ib,0,		"PSRLL	%i,%X",
[0x04]	Ib,0,		"PSRAL	%i,%X",
[0x06]	Ib,0,		"PSLLL	%i,%X",
};
@

<<global optab660F73>>=
static Optable optab660F73[8]=
{
[0x02]	Ib,0,		"PSRLQ	%i,%X",
[0x03]	Ib,0,		"PSRLO	%i,%X",
[0x06]	Ib,0,		"PSLLQ	%i,%X",
[0x07]	Ib,0,		"PSLLO	%i,%X",
};
@

<<global optab660F>>=
static Optable optab660F[256]=
{
[0x2B]	RM,0,		"MOVNTPD	%x,%e",
[0x2E]	RM,0,		"UCOMISD	%x,%X",
[0x2F]	RM,0,		"COMISD	%x,%X",
[0x5A]	RM,0,		"CVTPD2PS	%x,%X",
[0x5B]	RM,0,		"CVTPS2PL	%x,%X",
[0x6A]	RM,0,		"PUNPCKHLQ %x,%X",
[0x6B]	RM,0,		"PACKSSLW %x,%X",
[0x6C]	RM,0,		"PUNPCKLQDQ %x,%X",
[0x6D]	RM,0,		"PUNPCKHQDQ %x,%X",
[0x6E]	RM,0,		"MOV%S	%e,%X",
[0x6F]	RM,0,		"MOVO	%x,%X",		/* MOVDQA */
[0x70]	RM,Ib,		"PSHUFL	%i,%x,%X",
[0x71]	RMOP,0,		optab660F71,
[0x72]	RMOP,0,		optab660F72,
[0x73]	RMOP,0,		optab660F73,
[0x7E]	RM,0,		"MOV%S	%X,%e",
[0x7F]	RM,0,		"MOVO	%X,%x",
[0xC4]	RM,Ib,		"PINSRW	%i,%e,%X",
[0xC5]	RMR,Ib,		"PEXTRW	%i,%X,%e",
[0xD4]	RM,0,		"PADDQ	%x,%X",
[0xD5]	RM,0,		"PMULLW	%x,%X",
[0xD6]	RM,0,		"MOVQ	%X,%x",
[0xE6]	RM,0,		"CVTTPD2PL	%x,%X",
[0xE7]	RM,0,		"MOVNTO	%X,%e",
[0xF7]	RM,0,		"MASKMOVOU	%x,%X",
};
@

<<global optabF20F>>=
static Optable optabF20F[256]=
{
[0x10]	RM,0,		"MOVSD	%x,%X",
[0x11]	RM,0,		"MOVSD	%X,%x",
[0x2A]	RM,0,		"CVTS%S2SD	%e,%X",
[0x2C]	RM,0,		"CVTTSD2S%S	%x,%r",
[0x2D]	RM,0,		"CVTSD2S%S	%x,%r",
[0x5A]	RM,0,		"CVTSD2SS	%x,%X",
[0x6F]	RM,0,		"MOVOU	%x,%X",
[0x70]	RM,Ib,		"PSHUFLW	%i,%x,%X",
[0x7F]	RM,0,		"MOVOU	%X,%x",
[0xD6]	RM,0,		"MOVQOZX	%M,%X",
[0xE6]	RM,0,		"CVTPD2PL	%x,%X",
};
@

<<global optabF30F>>=
static Optable optabF30F[256]=
{
[0x10]	RM,0,		"MOVSS	%x,%X",
[0x11]	RM,0,		"MOVSS	%X,%x",
[0x2A]	RM,0,		"CVTS%S2SS	%e,%X",
[0x2C]	RM,0,		"CVTTSS2S%S	%x,%r",
[0x2D]	RM,0,		"CVTSS2S%S	%x,%r",
[0x5A]	RM,0,		"CVTSS2SD	%x,%X",
[0x5B]	RM,0,		"CVTTPS2PL	%x,%X",
[0x6F]	RM,0,		"MOVOU	%x,%X",
[0x70]	RM,Ib,		"PSHUFHW	%i,%x,%X",
[0x7E]	RM,0,		"MOVQOZX	%x,%X",
[0x7F]	RM,0,		"MOVOU	%X,%x",
[0xD6]	RM,0,		"MOVQOZX	%m*,%X",
[0xE6]	RM,0,		"CVTPL2PD	%x,%X",
};
@

<<global optab0F>>=
static Optable optab0F[256]=
{
[0x00]	RMOP,0,		optab0F00,
[0x01]	RMOP,0,		optab0F01,
[0x02]	RM,0,		"LAR	%e,%r",
[0x03]	RM,0,		"LSL	%e,%r",
[0x05]	0,0,		"SYSCALL",
[0x06]	0,0,		"CLTS",
[0x07]	0,0,		"SYSRET",
[0x08]	0,0,		"INVD",
[0x09]	0,0,		"WBINVD",
[0x0B]	0,0,		"UD2",
[0x0F]	RM,AUX,		optab0F0F,		/* 3DNow! */
[0x10]	RM,0,		"MOVU%s	%x,%X",
[0x11]	RM,0,		"MOVU%s	%X,%x",
[0x12]	RM,0,		"MOV[H]L%s	%x,%X",	/* TO DO: H if source is XMM */
[0x13]	RM,0,		"MOVL%s	%X,%e",
[0x14]	RM,0,		"UNPCKL%s	%x,%X",
[0x15]	RM,0,		"UNPCKH%s	%x,%X",
[0x16]	RM,0,		"MOV[L]H%s	%x,%X",	/* TO DO: L if source is XMM */
[0x17]	RM,0,		"MOVH%s	%X,%x",
[0x20]	RMR,0,		"MOVL	%C,%e",
[0x21]	RMR,0,		"MOVL	%D,%e",
[0x22]	RMR,0,		"MOVL	%e,%C",
[0x23]	RMR,0,		"MOVL	%e,%D",
[0x24]	RMR,0,		"MOVL	%T,%e",
[0x26]	RMR,0,		"MOVL	%e,%T",
[0x28]	RM,0,		"MOVA%s	%x,%X",
[0x29]	RM,0,		"MOVA%s	%X,%x",
[0x2A]	RM,0,		"CVTPL2%s	%m*,%X",
[0x2B]	RM,0,		"MOVNT%s	%X,%e",
[0x2C]	RM,0,		"CVTT%s2PL	%x,%M",
[0x2D]	RM,0,		"CVT%s2PL	%x,%M",
[0x2E]	RM,0,		"UCOMISS	%x,%X",
[0x2F]	RM,0,		"COMISS	%x,%X",
[0x30]	0,0,		"WRMSR",
[0x31]	0,0,		"RDTSC",
[0x32]	0,0,		"RDMSR",
[0x33]	0,0,		"RDPMC",
[0x42]	RM,0,		"CMOVC	%e,%r",		/* CF */
[0x43]	RM,0,		"CMOVNC	%e,%r",		/* ¬ CF */
[0x44]	RM,0,		"CMOVZ	%e,%r",		/* ZF */
[0x45]	RM,0,		"CMOVNZ	%e,%r",		/* ¬ ZF */
[0x46]	RM,0,		"CMOVBE	%e,%r",		/* CF ∨ ZF */
[0x47]	RM,0,		"CMOVA	%e,%r",		/* ¬CF ∧ ¬ZF */
[0x48]	RM,0,		"CMOVS	%e,%r",		/* SF */
[0x49]	RM,0,		"CMOVNS	%e,%r",		/* ¬ SF */
[0x4A]	RM,0,		"CMOVP	%e,%r",		/* PF */
[0x4B]	RM,0,		"CMOVNP	%e,%r",		/* ¬ PF */
[0x4C]	RM,0,		"CMOVLT	%e,%r",		/* LT ≡ OF ≠ SF */
[0x4D]	RM,0,		"CMOVGE	%e,%r",		/* GE ≡ ZF ∨ SF */
[0x4E]	RM,0,		"CMOVLE	%e,%r",		/* LE ≡ ZF ∨ LT */
[0x4F]	RM,0,		"CMOVGT	%e,%r",		/* GT ≡ ¬ZF ∧ GE */
[0x50]	RM,0,		"MOVMSK%s	%X,%r",	/* TO DO: check */
[0x51]	RM,0,		"SQRT%s	%x,%X",
[0x52]	RM,0,		"RSQRT%s	%x,%X",
[0x53]	RM,0,		"RCP%s	%x,%X",
[0x54]	RM,0,		"AND%s	%x,%X",
[0x55]	RM,0,		"ANDN%s	%x,%X",
[0x56]	RM,0,		"OR%s	%x,%X",		/* TO DO: S/D */
[0x57]	RM,0,		"XOR%s	%x,%X",		/* S/D */
[0x58]	RM,0,		"ADD%s	%x,%X",		/* S/P S/D */
[0x59]	RM,0,		"MUL%s	%x,%X",
[0x5A]	RM,0,		"CVTPS2PD	%x,%X",
[0x5B]	RM,0,		"CVTPL2PS	%x,%X",
[0x5C]	RM,0,		"SUB%s	%x,%X",
[0x5D]	RM,0,		"MIN%s	%x,%X",
[0x5E]	RM,0,		"DIV%s	%x,%X",		/* TO DO: S/P S/D */
[0x5F]	RM,0,		"MAX%s	%x,%X",
[0x60]	RM,0,		"PUNPCKLBW %m,%M",
[0x61]	RM,0,		"PUNPCKLWL %m,%M",
[0x62]	RM,0,		"PUNPCKLLQ %m,%M",
[0x63]	RM,0,		"PACKSSWB %m,%M",
[0x64]	RM,0,		"PCMPGTB %m,%M",
[0x65]	RM,0,		"PCMPGTW %m,%M",
[0x66]	RM,0,		"PCMPGTL %m,%M",
[0x67]	RM,0,		"PACKUSWB %m,%M",
[0x68]	RM,0,		"PUNPCKHBW %m,%M",
[0x69]	RM,0,		"PUNPCKHWL %m,%M",
[0x6A]	RM,0,		"PUNPCKHLQ %m,%M",
[0x6B]	RM,0,		"PACKSSLW %m,%M",
[0x6E]	RM,0,		"MOV%S %e,%M",
[0x6F]	RM,0,		"MOVQ %m,%M",
[0x70]	RM,Ib,		"PSHUFW	%i,%m,%M",
[0x74]	RM,0,		"PCMPEQB %m,%M",
[0x75]	RM,0,		"PCMPEQW %m,%M",
[0x76]	RM,0,		"PCMPEQL %m,%M",
[0x7E]	RM,0,		"MOV%S %M,%e",
[0x7F]	RM,0,		"MOVQ %M,%m",
[0xAE]	RMOP,0,		optab0FAE,
[0xAA]	0,0,		"RSM",
[0xB0]	RM,0,		"CMPXCHGB	%r,%e",
[0xB1]	RM,0,		"CMPXCHG%S	%r,%e",
[0xC0]	RMB,0,		"XADDB	%r,%e",
[0xC1]	RM,0,		"XADD%S	%r,%e",
[0xC2]	RM,Ib,		"CMP%s	%i,%x,%X",
[0xC3]	RM,0,		"MOVNTI%S	%r,%e",
[0xC6]	RM,Ib,		"SHUF%s	%i,%x,%X",
[0xC8]	0,0,		"BSWAP	AX",
[0xC9]	0,0,		"BSWAP	CX",
[0xCA]	0,0,		"BSWAP	DX",
[0xCB]	0,0,		"BSWAP	BX",
[0xCC]	0,0,		"BSWAP	SP",
[0xCD]	0,0,		"BSWAP	BP",
[0xCE]	0,0,		"BSWAP	SI",
[0xCF]	0,0,		"BSWAP	DI",
[0xD1]	RM,0,		"PSRLW %m,%M",
[0xD2]	RM,0,		"PSRLL %m,%M",
[0xD3]	RM,0,		"PSRLQ %m,%M",
[0xD5]	RM,0,		"PMULLW %m,%M",
[0xD6]	RM,0,		"MOVQOZX	%m*,%X",
[0xD7]	RM,0,		"PMOVMSKB %m,%r",
[0xD8]	RM,0,		"PSUBUSB %m,%M",
[0xD9]	RM,0,		"PSUBUSW %m,%M",
[0xDA]	RM,0,		"PMINUB %m,%M",
[0xDB]	RM,0,		"PAND %m,%M",
[0xDC]	RM,0,		"PADDUSB %m,%M",
[0xDD]	RM,0,		"PADDUSW %m,%M",
[0xDE]	RM,0,		"PMAXUB %m,%M",
[0xDF]	RM,0,		"PANDN %m,%M",
[0xE0]	RM,0,		"PAVGB %m,%M",
[0xE1]	RM,0,		"PSRAW %m,%M",
[0xE2]	RM,0,		"PSRAL %m,%M",
[0xE3]	RM,0,		"PAVGW %m,%M",
[0xE4]	RM,0,		"PMULHUW %m,%M",
[0xE5]	RM,0,		"PMULHW %m,%M",
[0xE7]	RM,0,		"MOVNTQ	%M,%e",
[0xE8]	RM,0,		"PSUBSB %m,%M",
[0xE9]	RM,0,		"PSUBSW %m,%M",
[0xEA]	RM,0,		"PMINSW %m,%M",
[0xEB]	RM,0,		"POR %m,%M",
[0xEC]	RM,0,		"PADDSB %m,%M",
[0xED]	RM,0,		"PADDSW %m,%M",
[0xEE]	RM,0,		"PMAXSW %m,%M",
[0xEF]	RM,0,		"PXOR %m,%M",
[0xF1]	RM,0,		"PSLLW %m,%M",
[0xF2]	RM,0,		"PSLLL %m,%M",
[0xF3]	RM,0,		"PSLLQ %m,%M",
[0xF4]	RM,0,		"PMULULQ	%m,%M",
[0xF5]	RM,0,		"PMADDWL %m,%M",
[0xF6]	RM,0,		"PSADBW %m,%M",
[0xF7]	RMR,0,		"MASKMOVQ	%m,%M",
[0xF8]	RM,0,		"PSUBB %m,%M",
[0xF9]	RM,0,		"PSUBW %m,%M",
[0xFA]	RM,0,		"PSUBL %m,%M",
[0xFC]	RM,0,		"PADDB %m,%M",
[0xFD]	RM,0,		"PADDW %m,%M",
[0xFE]	RM,0,		"PADDL %m,%M",

[0x80]	Iwds,0,		"JOS	%p",
[0x81]	Iwds,0,		"JOC	%p",
[0x82]	Iwds,0,		"JCS	%p",
[0x83]	Iwds,0,		"JCC	%p",
[0x84]	Iwds,0,		"JEQ	%p",
[0x85]	Iwds,0,		"JNE	%p",
[0x86]	Iwds,0,		"JLS	%p",
[0x87]	Iwds,0,		"JHI	%p",
[0x88]	Iwds,0,		"JMI	%p",
[0x89]	Iwds,0,		"JPL	%p",
[0x8a]	Iwds,0,		"JPS	%p",
[0x8b]	Iwds,0,		"JPC	%p",
[0x8c]	Iwds,0,		"JLT	%p",
[0x8d]	Iwds,0,		"JGE	%p",
[0x8e]	Iwds,0,		"JLE	%p",
[0x8f]	Iwds,0,		"JGT	%p",
[0x90]	RMB,0,		"SETOS	%e",
[0x91]	RMB,0,		"SETOC	%e",
[0x92]	RMB,0,		"SETCS	%e",
[0x93]	RMB,0,		"SETCC	%e",
[0x94]	RMB,0,		"SETEQ	%e",
[0x95]	RMB,0,		"SETNE	%e",
[0x96]	RMB,0,		"SETLS	%e",
[0x97]	RMB,0,		"SETHI	%e",
[0x98]	RMB,0,		"SETMI	%e",
[0x99]	RMB,0,		"SETPL	%e",
[0x9a]	RMB,0,		"SETPS	%e",
[0x9b]	RMB,0,		"SETPC	%e",
[0x9c]	RMB,0,		"SETLT	%e",
[0x9d]	RMB,0,		"SETGE	%e",
[0x9e]	RMB,0,		"SETLE	%e",
[0x9f]	RMB,0,		"SETGT	%e",
[0xa0]	0,0,		"PUSHL	FS",
[0xa1]	0,0,		"POPL	FS",
[0xa2]	0,0,		"CPUID",
[0xa3]	RM,0,		"BT%S	%r,%e",
[0xa4]	RM,Ib,		"SHLD%S	%r,%i,%e",
[0xa5]	RM,0,		"SHLD%S	%r,CL,%e",
[0xa8]	0,0,		"PUSHL	GS",
[0xa9]	0,0,		"POPL	GS",
[0xab]	RM,0,		"BTS%S	%r,%e",
[0xac]	RM,Ib,		"SHRD%S	%r,%i,%e",
[0xad]	RM,0,		"SHRD%S	%r,CL,%e",
[0xaf]	RM,0,		"IMUL%S	%e,%r",
[0xb2]	RMM,0,		"LSS	%e,%r",
[0xb3]	RM,0,		"BTR%S	%r,%e",
[0xb4]	RMM,0,		"LFS	%e,%r",
[0xb5]	RMM,0,		"LGS	%e,%r",
[0xb6]	RMB,0,		"MOVBZX	%e,%R",
[0xb7]	RM,0,		"MOVWZX	%e,%R",
[0xba]	RMOP,0,		optab0FBA,
[0xbb]	RM,0,		"BTC%S	%e,%r",
[0xbc]	RM,0,		"BSF%S	%e,%r",
[0xbd]	RM,0,		"BSR%S	%e,%r",
[0xbe]	RMB,0,		"MOVBSX	%e,%R",
[0xbf]	RM,0,		"MOVWSX	%e,%R",
[0xc7]	RMOP,0,		optab0FC7,
};
@

<<global optab80>>=
static Optable optab80[8]=
{
[0x00]	Ib,0,		"ADDB	%i,%e",
[0x01]	Ib,0,		"ORB	%i,%e",
[0x02]	Ib,0,		"ADCB	%i,%e",
[0x03]	Ib,0,		"SBBB	%i,%e",
[0x04]	Ib,0,		"ANDB	%i,%e",
[0x05]	Ib,0,		"SUBB	%i,%e",
[0x06]	Ib,0,		"XORB	%i,%e",
[0x07]	Ib,0,		"CMPB	%e,%i",
};
@

<<global optab81>>=
static Optable optab81[8]=
{
[0x00]	Iwd,0,		"ADD%S	%i,%e",
[0x01]	Iwd,0,		"OR%S	%i,%e",
[0x02]	Iwd,0,		"ADC%S	%i,%e",
[0x03]	Iwd,0,		"SBB%S	%i,%e",
[0x04]	Iwd,0,		"AND%S	%i,%e",
[0x05]	Iwd,0,		"SUB%S	%i,%e",
[0x06]	Iwd,0,		"XOR%S	%i,%e",
[0x07]	Iwd,0,		"CMP%S	%e,%i",
};
@

<<global optab83>>=
static Optable optab83[8]=
{
[0x00]	Ibs,0,		"ADD%S	%i,%e",
[0x01]	Ibs,0,		"OR%S	%i,%e",
[0x02]	Ibs,0,		"ADC%S	%i,%e",
[0x03]	Ibs,0,		"SBB%S	%i,%e",
[0x04]	Ibs,0,		"AND%S	%i,%e",
[0x05]	Ibs,0,		"SUB%S	%i,%e",
[0x06]	Ibs,0,		"XOR%S	%i,%e",
[0x07]	Ibs,0,		"CMP%S	%e,%i",
};
@

<<global optabC0>>=
static Optable optabC0[8] =
{
[0x00]	Ib,0,		"ROLB	%i,%e",
[0x01]	Ib,0,		"RORB	%i,%e",
[0x02]	Ib,0,		"RCLB	%i,%e",
[0x03]	Ib,0,		"RCRB	%i,%e",
[0x04]	Ib,0,		"SHLB	%i,%e",
[0x05]	Ib,0,		"SHRB	%i,%e",
[0x07]	Ib,0,		"SARB	%i,%e",
};
@

<<global optabC1>>=
static Optable optabC1[8] =
{
[0x00]	Ib,0,		"ROL%S	%i,%e",
[0x01]	Ib,0,		"ROR%S	%i,%e",
[0x02]	Ib,0,		"RCL%S	%i,%e",
[0x03]	Ib,0,		"RCR%S	%i,%e",
[0x04]	Ib,0,		"SHL%S	%i,%e",
[0x05]	Ib,0,		"SHR%S	%i,%e",
[0x07]	Ib,0,		"SAR%S	%i,%e",
};
@

<<global optabD0>>=
static Optable optabD0[8] =
{
[0x00]	0,0,		"ROLB	%e",
[0x01]	0,0,		"RORB	%e",
[0x02]	0,0,		"RCLB	%e",
[0x03]	0,0,		"RCRB	%e",
[0x04]	0,0,		"SHLB	%e",
[0x05]	0,0,		"SHRB	%e",
[0x07]	0,0,		"SARB	%e",
};
@

<<global optabD1>>=
static Optable optabD1[8] =
{
[0x00]	0,0,		"ROL%S	%e",
[0x01]	0,0,		"ROR%S	%e",
[0x02]	0,0,		"RCL%S	%e",
[0x03]	0,0,		"RCR%S	%e",
[0x04]	0,0,		"SHL%S	%e",
[0x05]	0,0,		"SHR%S	%e",
[0x07]	0,0,		"SAR%S	%e",
};
@

<<global optabD2>>=
static Optable optabD2[8] =
{
[0x00]	0,0,		"ROLB	CL,%e",
[0x01]	0,0,		"RORB	CL,%e",
[0x02]	0,0,		"RCLB	CL,%e",
[0x03]	0,0,		"RCRB	CL,%e",
[0x04]	0,0,		"SHLB	CL,%e",
[0x05]	0,0,		"SHRB	CL,%e",
[0x07]	0,0,		"SARB	CL,%e",
};
@

<<global optabD3>>=
static Optable optabD3[8] =
{
[0x00]	0,0,		"ROL%S	CL,%e",
[0x01]	0,0,		"ROR%S	CL,%e",
[0x02]	0,0,		"RCL%S	CL,%e",
[0x03]	0,0,		"RCR%S	CL,%e",
[0x04]	0,0,		"SHL%S	CL,%e",
[0x05]	0,0,		"SHR%S	CL,%e",
[0x07]	0,0,		"SAR%S	CL,%e",
};
@

<<global optabD8>>=
static Optable optabD8[8+8] =
{
[0x00]	0,0,		"FADDF	%e,F0",
[0x01]	0,0,		"FMULF	%e,F0",
[0x02]	0,0,		"FCOMF	%e,F0",
[0x03]	0,0,		"FCOMFP	%e,F0",
[0x04]	0,0,		"FSUBF	%e,F0",
[0x05]	0,0,		"FSUBRF	%e,F0",
[0x06]	0,0,		"FDIVF	%e,F0",
[0x07]	0,0,		"FDIVRF	%e,F0",
[0x08]	0,0,		"FADDD	%f,F0",
[0x09]	0,0,		"FMULD	%f,F0",
[0x0a]	0,0,		"FCOMD	%f,F0",
[0x0b]	0,0,		"FCOMPD	%f,F0",
[0x0c]	0,0,		"FSUBD	%f,F0",
[0x0d]	0,0,		"FSUBRD	%f,F0",
[0x0e]	0,0,		"FDIVD	%f,F0",
[0x0f]	0,0,		"FDIVRD	%f,F0",
};
@

<<global optabD9>>=
/*
 *	optabD9 and optabDB use the following encoding: 
 *	if (0 <= modrm <= 2) instruction = optabDx[modrm&0x07];
 *	else instruction = optabDx[(modrm&0x3f)+8];
 *
 *	the instructions for MOD == 3, follow the 8 instructions
 *	for the other MOD values stored at the front of the table.
 */
static Optable optabD9[64+8] =
{
[0x00]	0,0,		"FMOVF	%e,F0",
[0x02]	0,0,		"FMOVF	F0,%e",
[0x03]	0,0,		"FMOVFP	F0,%e",
[0x04]	0,0,		"FLDENV%S %e",
[0x05]	0,0,		"FLDCW	%e",
[0x06]	0,0,		"FSTENV%S %e",
[0x07]	0,0,		"FSTCW	%e",
[0x08]	0,0,		"FMOVD	F0,F0",		/* Mod R/M = 11xx xxxx*/
[0x09]	0,0,		"FMOVD	F1,F0",
[0x0a]	0,0,		"FMOVD	F2,F0",
[0x0b]	0,0,		"FMOVD	F3,F0",
[0x0c]	0,0,		"FMOVD	F4,F0",
[0x0d]	0,0,		"FMOVD	F5,F0",
[0x0e]	0,0,		"FMOVD	F6,F0",
[0x0f]	0,0,		"FMOVD	F7,F0",
[0x10]	0,0,		"FXCHD	F0,F0",
[0x11]	0,0,		"FXCHD	F1,F0",
[0x12]	0,0,		"FXCHD	F2,F0",
[0x13]	0,0,		"FXCHD	F3,F0",
[0x14]	0,0,		"FXCHD	F4,F0",
[0x15]	0,0,		"FXCHD	F5,F0",
[0x16]	0,0,		"FXCHD	F6,F0",
[0x17]	0,0,		"FXCHD	F7,F0",
[0x18]	0,0,		"FNOP",
[0x28]	0,0,		"FCHS",
[0x29]	0,0,		"FABS",
[0x2c]	0,0,		"FTST",
[0x2d]	0,0,		"FXAM",
[0x30]	0,0,		"FLD1",
[0x31]	0,0,		"FLDL2T",
[0x32]	0,0,		"FLDL2E",
[0x33]	0,0,		"FLDPI",
[0x34]	0,0,		"FLDLG2",
[0x35]	0,0,		"FLDLN2",
[0x36]	0,0,		"FLDZ",
[0x38]	0,0,		"F2XM1",
[0x39]	0,0,		"FYL2X",
[0x3a]	0,0,		"FPTAN",
[0x3b]	0,0,		"FPATAN",
[0x3c]	0,0,		"FXTRACT",
[0x3d]	0,0,		"FPREM1",
[0x3e]	0,0,		"FDECSTP",
[0x3f]	0,0,		"FNCSTP",
[0x40]	0,0,		"FPREM",
[0x41]	0,0,		"FYL2XP1",
[0x42]	0,0,		"FSQRT",
[0x43]	0,0,		"FSINCOS",
[0x44]	0,0,		"FRNDINT",
[0x45]	0,0,		"FSCALE",
[0x46]	0,0,		"FSIN",
[0x47]	0,0,		"FCOS",
};
@

<<global optabDA>>=
static Optable optabDA[8+8] =
{
[0x00]	0,0,		"FADDL	%e,F0",
[0x01]	0,0,		"FMULL	%e,F0",
[0x02]	0,0,		"FCOML	%e,F0",
[0x03]	0,0,		"FCOMLP	%e,F0",
[0x04]	0,0,		"FSUBL	%e,F0",
[0x05]	0,0,		"FSUBRL	%e,F0",
[0x06]	0,0,		"FDIVL	%e,F0",
[0x07]	0,0,		"FDIVRL	%e,F0",
[0x0d]	R1,0,		"FUCOMPP",
};
@

<<global optabDB>>=
static Optable optabDB[8+64] =
{
[0x00]	0,0,		"FMOVL	%e,F0",
[0x02]	0,0,		"FMOVL	F0,%e",
[0x03]	0,0,		"FMOVLP	F0,%e",
[0x05]	0,0,		"FMOVX	%e,F0",
[0x07]	0,0,		"FMOVXP	F0,%e",
[0x2a]	0,0,		"FCLEX",
[0x2b]	0,0,		"FINIT",
};
@

<<global optabDC>>=
static Optable optabDC[8+8] =
{
[0x00]	0,0,		"FADDD	%e,F0",
[0x01]	0,0,		"FMULD	%e,F0",
[0x02]	0,0,		"FCOMD	%e,F0",
[0x03]	0,0,		"FCOMDP	%e,F0",
[0x04]	0,0,		"FSUBD	%e,F0",
[0x05]	0,0,		"FSUBRD	%e,F0",
[0x06]	0,0,		"FDIVD	%e,F0",
[0x07]	0,0,		"FDIVRD	%e,F0",
[0x08]	0,0,		"FADDD	F0,%f",
[0x09]	0,0,		"FMULD	F0,%f",
[0x0c]	0,0,		"FSUBRD	F0,%f",
[0x0d]	0,0,		"FSUBD	F0,%f",
[0x0e]	0,0,		"FDIVRD	F0,%f",
[0x0f]	0,0,		"FDIVD	F0,%f",
};
@

<<global optabDD>>=
static Optable optabDD[8+8] =
{
[0x00]	0,0,		"FMOVD	%e,F0",
[0x02]	0,0,		"FMOVD	F0,%e",
[0x03]	0,0,		"FMOVDP	F0,%e",
[0x04]	0,0,		"FRSTOR%S %e",
[0x06]	0,0,		"FSAVE%S %e",
[0x07]	0,0,		"FSTSW	%e",
[0x08]	0,0,		"FFREED	%f",
[0x0a]	0,0,		"FMOVD	%f,F0",
[0x0b]	0,0,		"FMOVDP	%f,F0",
[0x0c]	0,0,		"FUCOMD	%f,F0",
[0x0d]	0,0,		"FUCOMDP %f,F0",
};
@

<<global optabDE>>=
static Optable optabDE[8+8] =
{
[0x00]	0,0,		"FADDW	%e,F0",
[0x01]	0,0,		"FMULW	%e,F0",
[0x02]	0,0,		"FCOMW	%e,F0",
[0x03]	0,0,		"FCOMWP	%e,F0",
[0x04]	0,0,		"FSUBW	%e,F0",
[0x05]	0,0,		"FSUBRW	%e,F0",
[0x06]	0,0,		"FDIVW	%e,F0",
[0x07]	0,0,		"FDIVRW	%e,F0",
[0x08]	0,0,		"FADDDP	F0,%f",
[0x09]	0,0,		"FMULDP	F0,%f",
[0x0b]	R1,0,		"FCOMPDP",
[0x0c]	0,0,		"FSUBRDP F0,%f",
[0x0d]	0,0,		"FSUBDP	F0,%f",
[0x0e]	0,0,		"FDIVRDP F0,%f",
[0x0f]	0,0,		"FDIVDP	F0,%f",
};
@

<<global optabDF>>=
static Optable optabDF[8+8] =
{
[0x00]	0,0,		"FMOVW	%e,F0",
[0x02]	0,0,		"FMOVW	F0,%e",
[0x03]	0,0,		"FMOVWP	F0,%e",
[0x04]	0,0,		"FBLD	%e",
[0x05]	0,0,		"FMOVL	%e,F0",
[0x06]	0,0,		"FBSTP	%e",
[0x07]	0,0,		"FMOVLP	F0,%e",
[0x0c]	R0,0,		"FSTSW	%OAX",
};
@

<<global optabF6>>=
static Optable optabF6[8] =
{
[0x00]	Ib,0,		"TESTB	%i,%e",
[0x02]	0,0,		"NOTB	%e",
[0x03]	0,0,		"NEGB	%e",
[0x04]	0,0,		"MULB	AL,%e",
[0x05]	0,0,		"IMULB	AL,%e",
[0x06]	0,0,		"DIVB	AL,%e",
[0x07]	0,0,		"IDIVB	AL,%e",
};
@

<<global optabF7>>=
static Optable optabF7[8] =
{
[0x00]	Iwd,0,		"TEST%S	%i,%e",
[0x02]	0,0,		"NOT%S	%e",
[0x03]	0,0,		"NEG%S	%e",
[0x04]	0,0,		"MUL%S	%OAX,%e",
[0x05]	0,0,		"IMUL%S	%OAX,%e",
[0x06]	0,0,		"DIV%S	%OAX,%e",
[0x07]	0,0,		"IDIV%S	%OAX,%e",
};
@

<<global optabFE>>=
static Optable optabFE[8] =
{
[0x00]	0,0,		"INCB	%e",
[0x01]	0,0,		"DECB	%e",
};
@

<<global optabFF>>=
static Optable optabFF[8] =
{
[0x00]	0,0,		"INC%S	%e",
[0x01]	0,0,		"DEC%S	%e",
[0x02]	JUMP,0,		"CALL*	%e",
[0x03]	JUMP,0,		"CALLF*	%e",
[0x04]	JUMP,0,		"JMP*	%e",
[0x05]	JUMP,0,		"JMPF*	%e",
[0x06]	0,0,		"PUSHL	%e",
};
@

<<global optable>>=
static Optable optable[256+1] =
{
[0x00]	RMB,0,		"ADDB	%r,%e",
[0x01]	RM,0,		"ADD%S	%r,%e",
[0x02]	RMB,0,		"ADDB	%e,%r",
[0x03]	RM,0,		"ADD%S	%e,%r",
[0x04]	Ib,0,		"ADDB	%i,AL",
[0x05]	Iwd,0,		"ADD%S	%i,%OAX",
[0x06]	0,0,		"PUSHL	ES",
[0x07]	0,0,		"POPL	ES",
[0x08]	RMB,0,		"ORB	%r,%e",
[0x09]	RM,0,		"OR%S	%r,%e",
[0x0a]	RMB,0,		"ORB	%e,%r",
[0x0b]	RM,0,		"OR%S	%e,%r",
[0x0c]	Ib,0,		"ORB	%i,AL",
[0x0d]	Iwd,0,		"OR%S	%i,%OAX",
[0x0e]	0,0,		"PUSHL	CS",
[0x0f]	AUXMM,0,	optab0F,
[0x10]	RMB,0,		"ADCB	%r,%e",
[0x11]	RM,0,		"ADC%S	%r,%e",
[0x12]	RMB,0,		"ADCB	%e,%r",
[0x13]	RM,0,		"ADC%S	%e,%r",
[0x14]	Ib,0,		"ADCB	%i,AL",
[0x15]	Iwd,0,		"ADC%S	%i,%OAX",
[0x16]	0,0,		"PUSHL	SS",
[0x17]	0,0,		"POPL	SS",
[0x18]	RMB,0,		"SBBB	%r,%e",
[0x19]	RM,0,		"SBB%S	%r,%e",
[0x1a]	RMB,0,		"SBBB	%e,%r",
[0x1b]	RM,0,		"SBB%S	%e,%r",
[0x1c]	Ib,0,		"SBBB	%i,AL",
[0x1d]	Iwd,0,		"SBB%S	%i,%OAX",
[0x1e]	0,0,		"PUSHL	DS",
[0x1f]	0,0,		"POPL	DS",
[0x20]	RMB,0,		"ANDB	%r,%e",
[0x21]	RM,0,		"AND%S	%r,%e",
[0x22]	RMB,0,		"ANDB	%e,%r",
[0x23]	RM,0,		"AND%S	%e,%r",
[0x24]	Ib,0,		"ANDB	%i,AL",
[0x25]	Iwd,0,		"AND%S	%i,%OAX",
[0x26]	SEG,0,		"ES:",
[0x27]	0,0,		"DAA",
[0x28]	RMB,0,		"SUBB	%r,%e",
[0x29]	RM,0,		"SUB%S	%r,%e",
[0x2a]	RMB,0,		"SUBB	%e,%r",
[0x2b]	RM,0,		"SUB%S	%e,%r",
[0x2c]	Ib,0,		"SUBB	%i,AL",
[0x2d]	Iwd,0,		"SUB%S	%i,%OAX",
[0x2e]	SEG,0,		"CS:",
[0x2f]	0,0,		"DAS",
[0x30]	RMB,0,		"XORB	%r,%e",
[0x31]	RM,0,		"XOR%S	%r,%e",
[0x32]	RMB,0,		"XORB	%e,%r",
[0x33]	RM,0,		"XOR%S	%e,%r",
[0x34]	Ib,0,		"XORB	%i,AL",
[0x35]	Iwd,0,		"XOR%S	%i,%OAX",
[0x36]	SEG,0,		"SS:",
[0x37]	0,0,		"AAA",
[0x38]	RMB,0,		"CMPB	%r,%e",
[0x39]	RM,0,		"CMP%S	%r,%e",
[0x3a]	RMB,0,		"CMPB	%e,%r",
[0x3b]	RM,0,		"CMP%S	%e,%r",
[0x3c]	Ib,0,		"CMPB	%i,AL",
[0x3d]	Iwd,0,		"CMP%S	%i,%OAX",
[0x3e]	SEG,0,		"DS:",
[0x3f]	0,0,		"AAS",
[0x40]	0,0,		"INC%S	%OAX",
[0x41]	0,0,		"INC%S	%OCX",
[0x42]	0,0,		"INC%S	%ODX",
[0x43]	0,0,		"INC%S	%OBX",
[0x44]	0,0,		"INC%S	%OSP",
[0x45]	0,0,		"INC%S	%OBP",
[0x46]	0,0,		"INC%S	%OSI",
[0x47]	0,0,		"INC%S	%ODI",
[0x48]	0,0,		"DEC%S	%OAX",
[0x49]	0,0,		"DEC%S	%OCX",
[0x4a]	0,0,		"DEC%S	%ODX",
[0x4b]	0,0,		"DEC%S	%OBX",
[0x4c]	0,0,		"DEC%S	%OSP",
[0x4d]	0,0,		"DEC%S	%OBP",
[0x4e]	0,0,		"DEC%S	%OSI",
[0x4f]	0,0,		"DEC%S	%ODI",
[0x50]	0,0,		"PUSH%S	%OAX",
[0x51]	0,0,		"PUSH%S	%OCX",
[0x52]	0,0,		"PUSH%S	%ODX",
[0x53]	0,0,		"PUSH%S	%OBX",
[0x54]	0,0,		"PUSH%S	%OSP",
[0x55]	0,0,		"PUSH%S	%OBP",
[0x56]	0,0,		"PUSH%S	%OSI",
[0x57]	0,0,		"PUSH%S	%ODI",
[0x58]	0,0,		"POP%S	%OAX",
[0x59]	0,0,		"POP%S	%OCX",
[0x5a]	0,0,		"POP%S	%ODX",
[0x5b]	0,0,		"POP%S	%OBX",
[0x5c]	0,0,		"POP%S	%OSP",
[0x5d]	0,0,		"POP%S	%OBP",
[0x5e]	0,0,		"POP%S	%OSI",
[0x5f]	0,0,		"POP%S	%ODI",
[0x60]	0,0,		"PUSHA%S",
[0x61]	0,0,		"POPA%S",
[0x62]	RMM,0,		"BOUND	%e,%r",
[0x63]	RM,0,		"ARPL	%r,%e",
[0x64]	SEG,0,		"FS:",
[0x65]	SEG,0,		"GS:",
[0x66]	OPOVER,0,	"",
[0x67]	ADDOVER,0,	"",
[0x68]	Iwd,0,		"PUSH%S	%i",
[0x69]	RM,Iwd,		"IMUL%S	%e,%i,%r",
[0x6a]	Ib,0,		"PUSH%S	%i",
[0x6b]	RM,Ibs,		"IMUL%S	%e,%i,%r",
[0x6c]	0,0,		"INSB	DX,(%ODI)",
[0x6d]	0,0,		"INS%S	DX,(%ODI)",
[0x6e]	0,0,		"OUTSB	(%ASI),DX",
[0x6f]	0,0,		"OUTS%S	(%ASI),DX",
[0x70]	Jbs,0,		"JOS	%p",
[0x71]	Jbs,0,		"JOC	%p",
[0x72]	Jbs,0,		"JCS	%p",
[0x73]	Jbs,0,		"JCC	%p",
[0x74]	Jbs,0,		"JEQ	%p",
[0x75]	Jbs,0,		"JNE	%p",
[0x76]	Jbs,0,		"JLS	%p",
[0x77]	Jbs,0,		"JHI	%p",
[0x78]	Jbs,0,		"JMI	%p",
[0x79]	Jbs,0,		"JPL	%p",
[0x7a]	Jbs,0,		"JPS	%p",
[0x7b]	Jbs,0,		"JPC	%p",
[0x7c]	Jbs,0,		"JLT	%p",
[0x7d]	Jbs,0,		"JGE	%p",
[0x7e]	Jbs,0,		"JLE	%p",
[0x7f]	Jbs,0,		"JGT	%p",
[0x80]	RMOPB,0,	optab80,
[0x81]	RMOP,0,		optab81,
[0x83]	RMOP,0,		optab83,
[0x84]	RMB,0,		"TESTB	%r,%e",
[0x85]	RM,0,		"TEST%S	%r,%e",
[0x86]	RMB,0,		"XCHGB	%r,%e",
[0x87]	RM,0,		"XCHG%S	%r,%e",
[0x88]	RMB,0,		"MOVB	%r,%e",
[0x89]	RM,0,		"MOV%S	%r,%e",
[0x8a]	RMB,0,		"MOVB	%e,%r",
[0x8b]	RM,0,		"MOV%S	%e,%r",
[0x8c]	RM,0,		"MOVW	%g,%e",
[0x8d]	RM,0,		"LEA%S	%e,%r",
[0x8e]	RM,0,		"MOVW	%e,%g",
[0x8f]	RM,0,		"POP%S	%e",
[0x90]	0,0,		"NOP",
[0x91]	0,0,		"XCHG	%OCX,%OAX",
[0x92]	0,0,		"XCHG	%ODX,%OAX",
[0x93]	0,0,		"XCHG	%OBX,%OAX",
[0x94]	0,0,		"XCHG	%OSP,%OAX",
[0x95]	0,0,		"XCHG	%OBP,%OAX",
[0x96]	0,0,		"XCHG	%OSI,%OAX",
[0x97]	0,0,		"XCHG	%ODI,%OAX",
[0x98]	0,0,		"%W",			/* miserable CBW or CWDE */
[0x99]	0,0,		"%w",			/* idiotic CWD or CDQ */
[0x9a]	PTR,0,		"CALL%S	%d",
[0x9b]	0,0,		"WAIT",
[0x9c]	0,0,		"PUSHF",
[0x9d]	0,0,		"POPF",
[0x9e]	0,0,		"SAHF",
[0x9f]	0,0,		"LAHF",
[0xa0]	Awd,0,		"MOVB	%i,AL",
[0xa1]	Awd,0,		"MOV%S	%i,%OAX",
[0xa2]	Awd,0,		"MOVB	AL,%i",
[0xa3]	Awd,0,		"MOV%S	%OAX,%i",
[0xa4]	0,0,		"MOVSB	(%ASI),(%ADI)",
[0xa5]	0,0,		"MOVS%S	(%ASI),(%ADI)",
[0xa6]	0,0,		"CMPSB	(%ASI),(%ADI)",
[0xa7]	0,0,		"CMPS%S	(%ASI),(%ADI)",
[0xa8]	Ib,0,		"TESTB	%i,AL",
[0xa9]	Iwd,0,		"TEST%S	%i,%OAX",
[0xaa]	0,0,		"STOSB	AL,(%ADI)",
[0xab]	0,0,		"STOS%S	%OAX,(%ADI)",
[0xac]	0,0,		"LODSB	(%ASI),AL",
[0xad]	0,0,		"LODS%S	(%ASI),%OAX",
[0xae]	0,0,		"SCASB	(%ADI),AL",
[0xaf]	0,0,		"SCAS%S	(%ADI),%OAX",
[0xb0]	Ib,0,		"MOVB	%i,AL",
[0xb1]	Ib,0,		"MOVB	%i,CL",
[0xb2]	Ib,0,		"MOVB	%i,DL",
[0xb3]	Ib,0,		"MOVB	%i,BL",
[0xb4]	Ib,0,		"MOVB	%i,AH",
[0xb5]	Ib,0,		"MOVB	%i,CH",
[0xb6]	Ib,0,		"MOVB	%i,DH",
[0xb7]	Ib,0,		"MOVB	%i,BH",
[0xb8]	Iwdq,0,		"MOV%S	%i,%OAX",
[0xb9]	Iwdq,0,		"MOV%S	%i,%OCX",
[0xba]	Iwdq,0,		"MOV%S	%i,%ODX",
[0xbb]	Iwdq,0,		"MOV%S	%i,%OBX",
[0xbc]	Iwdq,0,		"MOV%S	%i,%OSP",
[0xbd]	Iwdq,0,		"MOV%S	%i,%OBP",
[0xbe]	Iwdq,0,		"MOV%S	%i,%OSI",
[0xbf]	Iwdq,0,		"MOV%S	%i,%ODI",
[0xc0]	RMOPB,0,	optabC0,
[0xc1]	RMOP,0,		optabC1,
[0xc2]	Iw,0,		"RET	%i",
[0xc3]	RET,0,		"RET",
[0xc4]	RM,0,		"LES	%e,%r",
[0xc5]	RM,0,		"LDS	%e,%r",
[0xc6]	RMB,Ib,		"MOVB	%i,%e",
[0xc7]	RM,Iwd,		"MOV%S	%i,%e",
[0xc8]	Iw2,Ib,		"ENTER	%i,%I",		/* loony ENTER */
[0xc9]	RET,0,		"LEAVE",		/* bizarre LEAVE */
[0xca]	Iw,0,		"RETF	%i",
[0xcb]	RET,0,		"RETF",
[0xcc]	0,0,		"INT	3",
[0xcd]	Ib,0,		"INTB	%i",
[0xce]	0,0,		"INTO",
[0xcf]	0,0,		"IRET",
[0xd0]	RMOPB,0,	optabD0,
[0xd1]	RMOP,0,		optabD1,
[0xd2]	RMOPB,0,	optabD2,
[0xd3]	RMOP,0,		optabD3,
[0xd4]	OA,0,		"AAM",
[0xd5]	OA,0,		"AAD",
[0xd7]	0,0,		"XLAT",
[0xd8]	FRMOP,0,	optabD8,
[0xd9]	FRMEX,0,	optabD9,
[0xda]	FRMOP,0,	optabDA,
[0xdb]	FRMEX,0,	optabDB,
[0xdc]	FRMOP,0,	optabDC,
[0xdd]	FRMOP,0,	optabDD,
[0xde]	FRMOP,0,	optabDE,
[0xdf]	FRMOP,0,	optabDF,
[0xe0]	Jbs,0,		"LOOPNE	%p",
[0xe1]	Jbs,0,		"LOOPE	%p",
[0xe2]	Jbs,0,		"LOOP	%p",
[0xe3]	Jbs,0,		"JCXZ	%p",
[0xe4]	Ib,0,		"INB	%i,AL",
[0xe5]	Ib,0,		"IN%S	%i,%OAX",
[0xe6]	Ib,0,		"OUTB	AL,%i",
[0xe7]	Ib,0,		"OUT%S	%OAX,%i",
[0xe8]	Iwds,0,		"CALL	%p",
[0xe9]	Iwds,0,		"JMP	%p",
[0xea]	PTR,0,		"JMP	%d",
[0xeb]	Jbs,0,		"JMP	%p",
[0xec]	0,0,		"INB	DX,AL",
[0xed]	0,0,		"IN%S	DX,%OAX",
[0xee]	0,0,		"OUTB	AL,DX",
[0xef]	0,0,		"OUT%S	%OAX,DX",
[0xf0]	PRE,0,		"LOCK",
[0xf2]	OPRE,0,		"REPNE",
[0xf3]	OPRE,0,		"REP",
[0xf4]	0,0,		"HLT",
[0xf5]	0,0,		"CMC",
[0xf6]	RMOPB,0,	optabF6,
[0xf7]	RMOP,0,		optabF7,
[0xf8]	0,0,		"CLC",
[0xf9]	0,0,		"STC",
[0xfa]	0,0,		"CLI",
[0xfb]	0,0,		"STI",
[0xfc]	0,0,		"CLD",
[0xfd]	0,0,		"STD",
[0xfe]	RMOPB,0,	optabFE,
[0xff]	RMOP,0,		optabFF,
[0x100]	RM,0,		"MOVLQSX	%r,%e",
};
@

<<function igetc>>=
/*
 *  get a byte of the instruction
 */
static int
igetc(Map *map, Instr *ip, uchar *c)
{
    if(ip->n+1 > sizeof(ip->mem)){
        werrstr("instruction too long");
        return -1;
    }
    if (get1(map, ip->addr+ip->n, c, 1) < 0) {
        werrstr("can't read instruction: %r");
        return -1;
    }
    ip->mem[ip->n++] = *c;
    return 1;
}
@

<<function igets>>=
/*
 *  get two bytes of the instruction
 */
static int
igets(Map *map, Instr *ip, ushort *sp)
{
    uchar c;
    ushort s;

    if (igetc(map, ip, &c) < 0)
        return -1;
    s = c;
    if (igetc(map, ip, &c) < 0)
        return -1;
    s |= (c<<8);
    *sp = s;
    return 1;
}
@
% >>

<<function igetl>>=
/*
 *  get 4 bytes of the instruction
 */
static int
igetl(Map *map, Instr *ip, ulong *lp)
{
    ushort s;
    long	l;

    if (igets(map, ip, &s) < 0)
        return -1;
    l = s;
    if (igets(map, ip, &s) < 0)
        return -1;
    l |= (s<<16);
    *lp = l;
    return 1;
}
@

% >>

<<function igetq>>=
/*
 *  get 8 bytes of the instruction
 */
static int
igetq(Map *map, Instr *ip, vlong *qp)
{
    ulong	l;
    uvlong q;

    if (igetl(map, ip, &l) < 0)
        return -1;
    q = l;
    if (igetl(map, ip, &l) < 0)
        return -1;
    q |= ((uvlong)l<<32);
    *qp = q;
    return 1;
}
@

% >>

<<function getdisp>>=
static int
getdisp(Map *map, Instr *ip, int mod, int rm, int code, int pcrel)
{
    uchar c;
    ushort s;

    if (mod > 2)
        return 1;
    if (mod == 1) {
        if (igetc(map, ip, &c) < 0)
            return -1;
        if (c&0x80)
            ip->disp = c|0xffffff00;
        else
            ip->disp = c&0xff;
    } else if (mod == 2 || rm == code) {
        if (ip->asize == 'E') {
            if (igetl(map, ip, &ip->disp) < 0)
                return -1;
            if (mod == 0)
                ip->rip = pcrel;
        } else {
            if (igets(map, ip, &s) < 0)
                return -1;
            if (s&0x8000)
                ip->disp = s|0xffff0000;
            else
                ip->disp = s;
        }
        if (mod == 0)
            ip->base = -1;
    }
    return 1;
}
@

<<function modrm>>=
static int
modrm(Map *map, Instr *ip, uchar c)
{
    uchar rm, mod;

    mod = (c>>6)&3;
    rm = c&7;
    ip->mod = mod;
    ip->base = rm;
    ip->reg = (c>>3)&7;
    ip->rip = 0;
    if (mod == 3)			/* register */
        return 1;
    if (ip->asize == 0) {		/* 16-bit mode */
        switch(rm) {
        case 0:
            ip->base = BX; ip->index = SI;
            break;
        case 1:
            ip->base = BX; ip->index = DI;
            break;
        case 2:
            ip->base = BP; ip->index = SI;
            break;
        case 3:
            ip->base = BP; ip->index = DI;
            break;
        case 4:
            ip->base = SI;
            break;
        case 5:
            ip->base = DI;
            break;
        case 6:
            ip->base = BP;
            break;
        case 7:
            ip->base = BX;
            break;
        default:
            break;
        }
        return getdisp(map, ip, mod, rm, 6, 0);
    }
    if (rm == 4) {	/* scummy sib byte */
        if (igetc(map, ip, &c) < 0)
            return -1;
        ip->ss = (c>>6)&0x03;
        ip->index = (c>>3)&0x07;
        if (ip->index == 4)
            ip->index = -1;
        ip->base = c&0x07;
        return getdisp(map, ip, mod, ip->base, 5, 0);
    }
    return getdisp(map, ip, mod, rm, 5, ip->amd64);
}
@

<<function mkinstr>>=
static Optable *
mkinstr(Map *map, Instr *ip, uvlong pc)
{
    int i, n, norex;
    uchar c;
    ushort s;
    Optable *op, *obase;
    char buf[128];

    memset(ip, 0, sizeof(*ip));
    norex = 1;
    ip->base = -1;
    ip->index = -1;
    if(asstype == AI8086)
        ip->osize = 'W';
    else {
        ip->osize = 'L';
        ip->asize = 'E';
        ip->amd64 = asstype != AI386;
        norex = 0;
    }
    ip->addr = pc;
    if (igetc(map, ip, &c) < 0)
        return 0;
    obase = optable;
newop:
    if(ip->amd64 && !norex){
        if(c >= 0x40 && c <= 0x4f) {
            ip->rex = c;
            if(igetc(map, ip, &c) < 0)
                return 0;
        }
        if(c == 0x63){
            op = &obase[0x100];	/* MOVLQSX */
            goto hack;
        }
    }
    op = &obase[c];
hack:
    if (op->proto == 0) {
badop:
        n = snprint(buf, sizeof(buf), "opcode: ??");
        for (i = 0; i < ip->n && n < sizeof(buf)-3; i++, n+=2)
            _hexify(buf+n, ip->mem[i], 1);
        strcpy(buf+n, "??");
        werrstr(buf);
        return 0;
    }
    for(i = 0; i < 2 && op->operand[i]; i++) {
        switch(op->operand[i]) {
        case Ib:	/* 8-bit immediate - (no sign extension)*/
            if (igetc(map, ip, &c) < 0)
                return 0;
            ip->imm = c&0xff;
            ip->imm64 = ip->imm;
            break;
        case Jbs:	/* 8-bit jump immediate (sign extended) */
            if (igetc(map, ip, &c) < 0)
                return 0;
            if (c&0x80)
                ip->imm = c|0xffffff00;
            else
                ip->imm = c&0xff;
            ip->imm64 = (long)ip->imm;
            ip->jumptype = Jbs;
            break;
        case Ibs:	/* 8-bit immediate (sign extended) */
            if (igetc(map, ip, &c) < 0)
                return 0;
            if (c&0x80)
                if (ip->osize == 'L')
                    ip->imm = c|0xffffff00;
                else
                    ip->imm = c|0xff00;
            else
                ip->imm = c&0xff;
            ip->imm64 = (long)ip->imm;
            break;
        case Iw:	/* 16-bit immediate -> imm */
            if (igets(map, ip, &s) < 0)
                return 0;
            ip->imm = s&0xffff;
            ip->imm64 = ip->imm;
            ip->jumptype = Iw;
            break;
        case Iw2:	/* 16-bit immediate -> in imm2*/
            if (igets(map, ip, &s) < 0)
                return 0;
            ip->imm2 = s&0xffff;
            break;
        case Iwd:	/* Operand-sized immediate (no sign extension unless 64 bits)*/
            if (ip->osize == 'L') {
                if (igetl(map, ip, &ip->imm) < 0)
                    return 0;
                ip->imm64 = ip->imm;
                if(ip->rex&REXW && (ip->imm & (1<<31)) != 0)
                    ip->imm64 |= (vlong)~0 << 32;
            } else {
                if (igets(map, ip, &s)< 0)
                    return 0;
                ip->imm = s&0xffff;
                ip->imm64 = ip->imm;
            }
            break;
        case Iwdq:	/* Operand-sized immediate, possibly big */
            if (ip->osize == 'L') {
                if (igetl(map, ip, &ip->imm) < 0)
                    return 0;
                ip->imm64 = ip->imm;
                if (ip->rex & REXW) {
                    ulong l;
                    if (igetl(map, ip, &l) < 0)
                        return 0;
                    ip->imm64 |= (uvlong)l << 32;
                }
            } else {
                if (igets(map, ip, &s)< 0)
                    return 0;
                ip->imm = s&0xffff;
            }
            break;
        case Awd:	/* Address-sized immediate (no sign extension)*/
            if (ip->asize == 'E') {
                if (igetl(map, ip, &ip->imm) < 0)
                    return 0;
                /* TO DO: REX */
            } else {
                if (igets(map, ip, &s)< 0)
                    return 0;
                ip->imm = s&0xffff;
            }
            break;
        case Iwds:	/* Operand-sized immediate (sign extended) */
            if (ip->osize == 'L') {
                if (igetl(map, ip, &ip->imm) < 0)
                    return 0;
            } else {
                if (igets(map, ip, &s)< 0)
                    return 0;
                if (s&0x8000)
                    ip->imm = s|0xffff0000;
                else
                    ip->imm = s&0xffff;
            }
            ip->jumptype = Iwds;
            break;
        case OA:	/* literal 0x0a byte */
            if (igetc(map, ip, &c) < 0)
                return 0;
            if (c != 0x0a)
                goto badop;
            break;
        case R0:	/* base register must be R0 */
            if (ip->base != 0)
                goto badop;
            break;
        case R1:	/* base register must be R1 */
            if (ip->base != 1)
                goto badop;
            break;
        case RMB:	/* R/M field with byte register (/r)*/
            if (igetc(map, ip, &c) < 0)
                return 0;
            if (modrm(map, ip, c) < 0)
                return 0;
            ip->osize = 'B';
            break;
        case RM:	/* R/M field with register (/r) */
            if (igetc(map, ip, &c) < 0)
                return 0;
            if (modrm(map, ip, c) < 0)
                return 0;
            break;
        case RMOPB:	/* R/M field with op code (/digit) */
            if (igetc(map, ip, &c) < 0)
                return 0;
            if (modrm(map, ip, c) < 0)
                return 0;
            c = ip->reg;		/* secondary op code */
            obase = (Optable*)op->proto;
            ip->osize = 'B';
            goto newop;
        case RMOP:	/* R/M field with op code (/digit) */
            if (igetc(map, ip, &c) < 0)
                return 0;
            if (modrm(map, ip, c) < 0)
                return 0;
            obase = (Optable*)op->proto;
            if(ip->amd64 && obase == optab0F01 && c == 0xF8)
                return optab0F01F8;
            c = ip->reg;
            goto newop;
        case FRMOP:	/* FP R/M field with op code (/digit) */
            if (igetc(map, ip, &c) < 0)
                return 0;
            if (modrm(map, ip, c) < 0)
                return 0;
            if ((c&0xc0) == 0xc0)
                c = ip->reg+8;		/* 16 entry table */
            else
                c = ip->reg;
            obase = (Optable*)op->proto;
            goto newop;
        case FRMEX:	/* Extended FP R/M field with op code (/digit) */
            if (igetc(map, ip, &c) < 0)
                return 0;
            if (modrm(map, ip, c) < 0)
                return 0;
            if ((c&0xc0) == 0xc0)
                c = (c&0x3f)+8;		/* 64-entry table */
            else
                c = ip->reg;
            obase = (Optable*)op->proto;
            goto newop;
        case RMR:	/* R/M register only (mod = 11) */
            if (igetc(map, ip, &c) < 0)
                return 0;
            if ((c&0xc0) != 0xc0) {
                werrstr("invalid R/M register: %x", c);
                return 0;
            }
            if (modrm(map, ip, c) < 0)
                return 0;
            break;
        case RMM:	/* R/M register only (mod = 11) */
            if (igetc(map, ip, &c) < 0)
                return 0;
            if ((c&0xc0) == 0xc0) {
                werrstr("invalid R/M memory mode: %x", c);
                return 0;
            }
            if (modrm(map, ip, c) < 0)
                return 0;
            break;
        case PTR:	/* Seg:Displacement addr (ptr16:16 or ptr16:32) */
            if (ip->osize == 'L') {
                if (igetl(map, ip, &ip->disp) < 0)
                    return 0;
            } else {
                if (igets(map, ip, &s)< 0)
                    return 0;
                ip->disp = s&0xffff;
            }
            if (igets(map, ip, (ushort*)&ip->seg) < 0)
                return 0;
            ip->jumptype = PTR;
            break;
        case AUXMM:	/* Multi-byte op code; prefix determines table selection */
            if (igetc(map, ip, &c) < 0)
                return 0;
            obase = (Optable*)op->proto;
            switch (ip->opre) {
            case 0x66:	op = optab660F; break;
            case 0xF2:	op = optabF20F; break;
            case 0xF3:	op = optabF30F; break;
            default:	op = nil; break;
            }
            if(op != nil && op[c].proto != nil)
                obase = op;
            norex = 1;	/* no more rex prefixes */
            /* otherwise the optab entry captures it */
            goto newop;
        case AUX:	/* Multi-byte op code - Auxiliary table */
            obase = (Optable*)op->proto;
            if (igetc(map, ip, &c) < 0)
                return 0;
            goto newop;
        case OPRE:	/* Instr Prefix or media op */
            ip->opre = c;
            /* fall through */
        case PRE:	/* Instr Prefix */
            ip->prefix = (char*)op->proto;
            if (igetc(map, ip, &c) < 0)
                return 0;
            if (ip->opre && c == 0x0F)
                ip->prefix = 0;
            goto newop;
        case SEG:	/* Segment Prefix */
            ip->segment = (char*)op->proto;
            if (igetc(map, ip, &c) < 0)
                return 0;
            goto newop;
        case OPOVER:	/* Operand size override */
            ip->opre = c;
            ip->osize = 'W';
            if (igetc(map, ip, &c) < 0)
                return 0;
            if (c == 0x0F)
                ip->osize = 'L';
            else if (ip->amd64 && (c&0xF0) == 0x40)
                ip->osize = 'Q';
            goto newop;
        case ADDOVER:	/* Address size override */
            ip->asize = 0;
            if (igetc(map, ip, &c) < 0)
                return 0;
            goto newop;
        case JUMP:	/* mark instruction as JUMP or RET */
        case RET:
            ip->jumptype = op->operand[i];
            break;
        default:
            werrstr("bad operand type %d", op->operand[i]);
            return 0;
        }
    }
    return op;
}
@

<<function bprint>>=
static void
bprint(Instr *ip, char *fmt, ...)
{
    va_list arg;

    va_start(arg, fmt);
    ip->curr = vseprint(ip->curr, ip->end, fmt, arg);
    va_end(arg);
}
@

<<function ANAME>>=
/*
 *  if we want to call 16 bit regs AX,BX,CX,...
 *  and 32 bit regs EAX,EBX,ECX,... then
 *  change the defs of ANAME and ONAME to:
 *  #define	ANAME(ip)	((ip->asize == 'E' ? "E" : "")
 *  #define	ONAME(ip)	((ip)->osize == 'L' ? "E" : "")
 */
#define	ANAME(ip)	""
@

<<function ONAME>>=
#define	ONAME(ip)	""
@

<<global reg (linkers/libmach/8db.c)>>=
static char *reg[] =  {
[AX]	"AX",
[CX]	"CX",
[DX]	"DX",
[BX]	"BX",
[SP]	"SP",
[BP]	"BP",
[SI]	"SI",
[DI]	"DI",

    /* amd64 */
[R8]	"R8",
[R9]	"R9",
[R10]	"R10",
[R11]	"R11",
[R12]	"R12",
[R13]	"R13",
[R14]	"R14",
[R15]	"R15",
};
@

<<global breg>>=
static char *breg[] = { "AL", "CL", "DL", "BL", "AH", "CH", "DH", "BH" };
@

<<global breg64>>=
static char *breg64[] = { "AL", "CL", "DL", "BL", "SPB", "BPB", "SIB", "DIB",
    "R8B", "R9B", "R10B", "R11B", "R12B", "R13B", "R14B", "R15B" };
@

<<global sreg>>=
static char *sreg[] = { "ES", "CS", "SS", "DS", "FS", "GS" };
@

<<function plocal>>=
static void
plocal(Instr *ip)
{
    int ret;
    long offset;
    Symbol s;
    char *reg;

    offset = ip->disp;
    if (!findsym(ip->addr, CTEXT, &s) || !findlocal(&s, FRAMENAME, &s)) {
        bprint(ip, "%lux(SP)", offset);
        return;
    }

    if (s.value > ip->disp) {
        ret = getauto(&s, s.value-ip->disp-mach->szaddr, CAUTO, &s);
        reg = "(SP)";
    } else {
        offset -= s.value;
        ret = getauto(&s, offset, CPARAM, &s);
        reg = "(FP)";
    }
    if (ret)
        bprint(ip, "%s+", s.name);
    else
        offset = ip->disp;
    bprint(ip, "%lux%s", offset, reg);
}
@

<<function isjmp>>=
static int
isjmp(Instr *ip)
{
    switch(ip->jumptype){
    case Iwds:
    case Jbs:
    case JUMP:
        return 1;
    default:
        return 0;
    }
}
@

<<function issymref>>=
/*
 * This is too smart for its own good, but it really is nice
 * to have accurate translations when debugging, and it
 * helps us identify which code is different in binaries that
 * are changed on sources.
 */
static int
issymref(Instr *ip, Symbol *s, long w, long val)
{
    Symbol next, tmp;
    long isstring, size;

    if (isjmp(ip))
        return 1;
    if (s->class==CTEXT && w==0)
        return 1;
    if (s->class==CDATA) {
        /* use first bss symbol (or "end") rather than edata */
        if (s->name[0]=='e' && strcmp(s->name, "edata") == 0){
            if((s ->index >= 0 && globalsym(&tmp, s->index+1) && tmp.value==s->value)
            || (s->index > 0 && globalsym(&tmp, s->index-1) && tmp.value==s->value))
                *s = tmp;
        }
        if (w == 0)
            return 1;
        for (next=*s; next.value==s->value; next=tmp)
            if (!globalsym(&tmp, next.index+1))
                break;
        size = next.value - s->value;
        if (w >= size)
            return 0;
        if (w > size-w)
            w = size-w;
        /* huge distances are usually wrong except in .string */
        isstring = (s->name[0]=='.' && strcmp(s->name, ".string") == 0);
        if (w > 8192 && !isstring)
            return 0;
        /* medium distances are tricky - look for constants */
        /* near powers of two */
        if ((val&(val-1)) == 0 || (val&(val+1)) == 0)
            return 0;
        return 1;
    }
    return 0;
}
@

<<function immediate>>=
static void
immediate(Instr *ip, vlong val)
{
    Symbol s;
    long w;

    if (findsym(val, CANY, &s)) {		/* TO DO */
        w = val - s.value;
        if (w < 0)
            w = -w;
        if (issymref(ip, &s, w, val)) {
            if (w)
                bprint(ip, "%s+%lux(SB)", s.name, w);
            else
                bprint(ip, "%s(SB)", s.name);
            return;
        }
/*
        if (s.class==CDATA && globalsym(&s, s.index+1)) {
            w = s.value - val;
            if (w < 0)
                w = -w;
            if (w < 4096) {
                bprint(ip, "%s-%lux(SB)", s.name, w);
                return;
            }
        }
*/
    }
    if((ip->rex & REXW) == 0)
        bprint(ip, "%lux", (long)val);
    else
        bprint(ip, "%llux", val);
}
@

<<function pea>>=
static void
pea(Instr *ip)
{
    if (ip->mod == 3) {
        if (ip->osize == 'B')
            bprint(ip, (ip->rex & REXB? breg64: breg)[ip->base]);
        else if(ip->rex & REXB)
            bprint(ip, "%s%s", ANAME(ip), reg[ip->base+8]);
        else
            bprint(ip, "%s%s", ANAME(ip), reg[ip->base]);
        return;
    }
    if (ip->segment)
        bprint(ip, ip->segment);
    if (ip->asize == 'E' && ip->base == SP)
        plocal(ip);
    else {
        if (ip->base < 0)
            immediate(ip, ip->disp);
        else {
            bprint(ip, "%lux", ip->disp);
            if(ip->rip)
                bprint(ip, "(RIP)");
            bprint(ip,"(%s%s)", ANAME(ip), reg[ip->rex&REXB? ip->base+8: ip->base]);
        }
    }
    if (ip->index >= 0)
        bprint(ip,"(%s%s*%d)", ANAME(ip), reg[ip->rex&REXX? ip->index+8: ip->index], 1<<ip->ss);
}
@

<<function prinstr>>=
static void
prinstr(Instr *ip, char *fmt)
{
    vlong v;

    if (ip->prefix)
        bprint(ip, "%s ", ip->prefix);
    for (; *fmt && ip->curr < ip->end; fmt++) {
        if (*fmt != '%'){
            *ip->curr++ = *fmt;
            continue;
        }
        switch(*++fmt){
        case '%':
            *ip->curr++ = '%';
            break;
        case 'A':
            bprint(ip, "%s", ANAME(ip));
            break;
        case 'C':
            bprint(ip, "CR%d", ip->reg);
            break;
        case 'D':
            if (ip->reg < 4 || ip->reg == 6 || ip->reg == 7)
                bprint(ip, "DR%d",ip->reg);
            else
                bprint(ip, "???");
            break;
        case 'I':
            bprint(ip, "$");
            immediate(ip, ip->imm2);
            break;
        case 'O':
            bprint(ip,"%s", ONAME(ip));
            break;
        case 'i':
            bprint(ip, "$");
            v = ip->imm;
            if(ip->rex & REXW)
                v = ip->imm64;
            immediate(ip, v);
            break;
        case 'R':
            bprint(ip, "%s%s", ONAME(ip), reg[ip->rex&REXR? ip->reg+8: ip->reg]);
            break;
        case 'S':
            if(ip->osize == 'Q' || ip->osize == 'L' && ip->rex & REXW)
                bprint(ip, "Q");
            else
                bprint(ip, "%c", ip->osize);
            break;
        case 's':
            if(ip->opre == 0 || ip->opre == 0x66)
                bprint(ip, "P");
            else
                bprint(ip, "S");
            if(ip->opre == 0xf2 || ip->opre == 0x66)
                bprint(ip, "D");
            else
                bprint(ip, "S");
            break;
        case 'T':
            if (ip->reg == 6 || ip->reg == 7)
                bprint(ip, "TR%d",ip->reg);
            else
                bprint(ip, "???");
            break;
        case 'W':
            if (ip->osize == 'Q' || ip->osize == 'L' && ip->rex & REXW)
                bprint(ip, "CDQE");
            else if (ip->osize == 'L')
                bprint(ip,"CWDE");
            else
                bprint(ip, "CBW");
            break;
        case 'd':
            bprint(ip,"%ux:%lux",ip->seg,ip->disp);
            break;
        case 'm':
            if (ip->mod == 3 && ip->osize != 'B') {
                if(fmt[1] != '*'){
                    if(ip->opre != 0) {
                        bprint(ip, "X%d", ip->rex&REXB? ip->base+8: ip->base);
                        break;
                    }
                } else
                    fmt++;
                bprint(ip, "M%d", ip->base);
                break;
            }
            pea(ip);
            break;
        case 'e':
            pea(ip);
            break;
        case 'f':
            bprint(ip, "F%d", ip->base);
            break;
        case 'g':
            if (ip->reg < 6)
                bprint(ip,"%s",sreg[ip->reg]);
            else
                bprint(ip,"???");
            break;
        case 'p':
            /*
             * signed immediate in the ulong ip->imm.
             */
            v = (long)ip->imm;
            immediate(ip, v+ip->addr+ip->n);
            break;
        case 'r':
            if (ip->osize == 'B')
                bprint(ip,"%s", (ip->rex? breg64: breg)[ip->rex&REXR? ip->reg+8: ip->reg]);
            else
                bprint(ip, reg[ip->rex&REXR? ip->reg+8: ip->reg]);
            break;
        case 'w':
            if (ip->osize == 'Q' || ip->rex & REXW)
                bprint(ip, "CQO");
            else if (ip->osize == 'L')
                bprint(ip,"CDQ");
            else
                bprint(ip, "CWD");
            break;
        case 'M':
            if(ip->opre != 0)
                bprint(ip, "X%d", ip->rex&REXR? ip->reg+8: ip->reg);
            else
                bprint(ip, "M%d", ip->reg);
            break;
        case 'x':
            if (ip->mod == 3 && ip->osize != 'B') {
                bprint(ip, "X%d", ip->rex&REXB? ip->base+8: ip->base);
                break;
            }
            pea(ip);
            break;
        case 'X':
            bprint(ip, "X%d", ip->rex&REXR? ip->reg+8: ip->reg);
            break;
        default:
            bprint(ip, "%%%c", *fmt);
            break;
        }
    }
    *ip->curr = 0;		/* there's always room for 1 byte */
}
@

<<function i386inst>>=
static int
i386inst(Map *map, uvlong pc, char modifier, char *buf, int n)
{
    Instr instr;
    Optable *op;

    USED(modifier);
    op = mkinstr(map, &instr, pc);
    if (op == 0) {
        errstr(buf, n);
        return -1;
    }
    instr.curr = buf;
    instr.end = buf+n-1;
    prinstr(&instr, op->proto);
    return instr.n;
}
@

<<function i386das>>=
static int
i386das(Map *map, uvlong pc, char *buf, int n)
{
    Instr instr;
    int i;

    if (mkinstr(map, &instr, pc) == 0) {
        errstr(buf, n);
        return -1;
    }
    for(i = 0; i < instr.n && n > 2; i++) {
        _hexify(buf, instr.mem[i], 1);
        buf += 2;
        n -= 2;
    }
    *buf = 0;
    return instr.n;
}
@

<<function i386instlen>>=
static int
i386instlen(Map *map, uvlong pc)
{
    Instr i;

    if (mkinstr(map, &i, pc))
        return i.n;
    return -1;
}
@

<<function i386foll>>=
static int
i386foll(Map *map, uvlong pc, Rgetter rget, uvlong *foll)
{
    Instr i;
    Optable *op;
    ushort s;
    uvlong l, addr;
    vlong v;
    int n;

    op = mkinstr(map, &i, pc);
    if (!op)
        return -1;

    n = 0;

    switch(i.jumptype) {
    case RET:		/* RETURN or LEAVE */
    case Iw:		/* RETURN */
        if (strcmp(op->proto, "LEAVE") == 0) {
            if (geta(map, (*rget)(map, "BP"), &l) < 0)
                return -1;
        } else if (geta(map, (*rget)(map, mach->sp), &l) < 0)
            return -1;
        foll[0] = l;
        return 1;
    case Iwds:		/* pc relative JUMP or CALL*/
    case Jbs:		/* pc relative JUMP or CALL */
        v = (long)i.imm;
        foll[0] = pc+v+i.n;
        n = 1;
        break;
    case PTR:		/* seg:displacement JUMP or CALL */
        foll[0] = (i.seg<<4)+i.disp;
        return 1;
    case JUMP:		/* JUMP or CALL EA */

        if(i.mod == 3) {
            foll[0] = (*rget)(map, reg[i.rex&REXB? i.base+8: i.base]);
            return 1;
        }
            /* calculate the effective address */
        addr = i.disp;
        if (i.base >= 0) {
            if (geta(map, (*rget)(map, reg[i.rex&REXB? i.base+8: i.base]), &l) < 0)
                return -1;
            addr += l;
        }
        if (i.index >= 0) {
            if (geta(map, (*rget)(map, reg[i.rex&REXX? i.index+8: i.index]), &l) < 0)
                return -1;
            addr += l*(1<<i.ss);
        }
            /* now retrieve a seg:disp value at that address */
        if (get2(map, addr, &s) < 0)			/* seg */
            return -1;
        foll[0] = s<<4;
        addr += 2;
        if (i.asize == 'L') {
            if (geta(map, addr, &l) < 0)		/* disp32 */
                return -1;
            foll[0] += l;
        } else {					/* disp16 */
            if (get2(map, addr, &s) < 0)
                return -1;
            foll[0] += s;
        }
        return 1;
    default:
        break;
    }		
    if (strncmp(op->proto,"JMP", 3) == 0 || strncmp(op->proto,"CALL", 4) == 0)
        return 1;
    foll[n++] = pc+i.n;
    return n;
}
@


%-------------------------------------------------------------

<<linkers/libmach/8db.c>>=
#include <u.h>
#include <libc.h>
#include <bio.h>
#include <mach.h>

/*
 * i386-specific debugger interface
 * also amd64 extensions
 */

static	char	*i386excep(Map*, Rgetter);

static	int	i386trace(Map*, uvlong, uvlong, uvlong, Tracer);
static	uvlong	i386frame(Map*, uvlong, uvlong, uvlong, uvlong);
static	int	i386foll(Map*, uvlong, Rgetter, uvlong*);
static	int	i386inst(Map*, uvlong, char, char*, int);
static	int	i386das(Map*, uvlong, char*, int);
static	int	i386instlen(Map*, uvlong);

<<global STARTSYM>>
<<global PROFSYM>>
<<global FRAMENAME>>
<<global excname>>

<<global i386mach>>

<<function i386excep>>

<<function i386trace>>

<<function i386frame>>

    /* I386/486 - Disassembler and related functions */

/*
 *  an instruction
 */
typedef struct Instr Instr;
<<struct Instr>>

    /* 386 register (ha!) set */
<<enum _anon_ (linkers/libmach/8db.c)>>

    /* amd64 rex extension byte */
<<enum _anon_ (linkers/libmach/8db.c)2>>
    
    /* Operand Format codes */
/*
%A	-	address size register modifier (!asize -> 'E')
%C	-	Control register CR0/CR1/CR2
%D	-	Debug register DR0/DR1/DR2/DR3/DR6/DR7
%I	-	second immediate operand
%O	-	Operand size register modifier (!osize -> 'E')
%T	-	Test register TR6/TR7
%S	-	size code ('W' or 'L')
%W	-	Weird opcode: OSIZE == 'W' => "CBW"; else => "CWDE"
%d	-	displacement 16-32 bits
%e	-	effective address - Mod R/M value
%f	-	floating point register F0-F7 - from Mod R/M register
%g	-	segment register
%i	-	immediate operand 8-32 bits
%p	-	PC-relative - signed displacement in immediate field
%r	-	Reg from Mod R/M
%w	-	Weird opcode: OSIZE == 'W' => "CWD"; else => "CDQ"
*/

typedef struct Optable Optable;
<<struct Optable>>
    /* Operand decoding codes */
<<enum _anon_ (linkers/libmach/8db.c)3>>
    
<<global optab0F00>>

<<global optab0F01>>

<<global optab0F01F8>>

/* 0F71 */
/* 0F72 */
<<global optab0FAE>>

/* 0F18 */
<<global optab0FBA>>

<<global optab0F0F>>

<<global optab0FC7>>

<<global optab660F71>>

<<global optab660F72>>

<<global optab660F73>>

<<global optab660F>>

<<global optabF20F>>

<<global optabF30F>>

<<global optab0F>>

<<global optab80>>

<<global optab81>>

<<global optab83>>

<<global optabC0>>

<<global optabC1>>

<<global optabD0>>

<<global optabD1>>

<<global optabD2>>

<<global optabD3>>

<<global optabD8>>
<<global optabD9>>

<<global optabDA>>

<<global optabDB>>

<<global optabDC>>

<<global optabDD>>

<<global optabDE>>

<<global optabDF>>

<<global optabF6>>

<<global optabF7>>

<<global optabFE>>

<<global optabFF>>

<<global optable>>

<<function igetc>>

<<function igets>>

<<function igetl>>

<<function igetq>>

<<function getdisp>>

<<function modrm>>

<<function mkinstr>>

#pragma	varargck	argpos	bprint		2

<<function bprint>>

<<function ANAME>>
<<function ONAME>>

<<global reg (linkers/libmach/8db.c)>>

<<global breg>>
<<global breg64>>
<<global sreg>>

<<function plocal>>

<<function isjmp>>

<<function issymref>>

<<function immediate>>

<<function pea>>

<<function prinstr>>

<<function i386inst>>

<<function i386das>>

<<function i386instlen>>

<<function i386foll>>
@


\subsection*{[[linkers/libmach/vcodas.c]]}

<<global mipscoload>>=
static char mipscoload[] = "r%t,%l";
@

<<global mipscoalui>>=
static char mipscoalui[] = "r%t,r%s,%i";
@

<<global mipscoalu3op>>=
static char mipscoalu3op[] = "r%d,r%s,r%t";
@

<<global mipscoboc>>=
static char mipscoboc[] = "r%s,r%t,%b";
@

<<global mipscoboc0>>=
static char mipscoboc0[] = "r%s,%b";
@

<<global mipscorsrt>>=
static char mipscorsrt[] = "r%s,r%t";
@

<<global mipscorsi>>=
static char mipscorsi[] = "r%s,%i";
@

<<global mipscoxxx>>=
static char mipscoxxx[] = "%w";
@

<<global mipscofp3>>=
static char mipscofp3[] = "f%a,f%d,f%t";	/* fd,fs,ft */
@

<<global mipscofp2>>=
static char mipscofp2[] = "f%a,f%d";		/* fd,fs */
@

<<global mipscofpc>>=
static char mipscofpc[] = "f%d,f%t";		/* fs,ft */
@

<<global opcodes>>=
static Opcode opcodes[64] = {
    0,		0,
    0,		0,
    "j",		"%j",
    "jal",		"%j",
    "beq",		mipscoboc,
    "bne",		mipscoboc,
    "blez",		mipscoboc0,
    "bgtz",		mipscoboc0,
    "addi",		mipscoalui,
    "addiu",	mipscoalui,
    "slti",		mipscoalui,
    "sltiu",	mipscoalui,
    "andi",		mipscoalui,
    "ori",		mipscoalui,
    "xori",		mipscoalui,
    "lui",		"r%t,%u",
    "cop0",		0,
    "cop1",		0,
    "cop2",		0,
    "cop3",		0,
    "beql",		mipscoboc,
    "bnel",		mipscoboc,
    "blezl",	mipscoboc0,
    "bgtzl",	mipscoboc0,
    "instr18",	mipscoxxx,
    "instr19",	mipscoxxx,
    "instr1A",	mipscoxxx,
    "instr1B",	mipscoxxx,
    "instr1C",	mipscoxxx,
    "instr1D",	mipscoxxx,
    "instr1E",	mipscoxxx,
    "instr1F",	mipscoxxx,
    "lb",		mipscoload,
    "lh",		mipscoload,
    "lwl",		mipscoload,
    "lw",		mipscoload,
    "lbu",		mipscoload,
    "lhu",		mipscoload,
    "lwr",		mipscoload,
    "instr27",	mipscoxxx,
    "sb",		mipscoload,
    "sh",		mipscoload,
    "swl",		mipscoload,
    "sw",		mipscoload,
    "instr2C",	mipscoxxx,
    "instr2D",	mipscoxxx,
    "swr",		mipscoload,
    "cache",	"",
    "ll",		mipscoload,
    "lwc1",		mipscoload,
    "lwc2",		mipscoload,
    "lwc3",		mipscoload,
    "instr34",	mipscoxxx,
    "ld",		mipscoload,
    "ld",		mipscoload,
    "ld",		mipscoload,
    "sc",		mipscoload,
    "swc1",		mipscoload,
    "swc2",		mipscoload,
    "swc3",		mipscoload,
    "instr3C",	mipscoxxx,
    "sd",		mipscoload,
    "sd",		mipscoload,
    "sd",		mipscoload,
};
@

<<global sopcodes>>=
static Opcode sopcodes[64] = {
    "sll",		"r%d,r%t,$%a",
    "special01",	mipscoxxx,
    "srl",		"r%d,r%t,$%a",
    "sra",		"r%d,r%t,$%a",
    "sllv",		"r%d,r%t,R%s",
    "special05",	mipscoxxx,
    "srlv",		"r%d,r%t,r%s",
    "srav",		"r%d,r%t,r%s",
    "jr",		"r%s",
    "jalr",		"r%d,r%s",
    "special0A",	mipscoxxx,
    "special0B",	mipscoxxx,
    "syscall",	"",
    "break",	"",
    "special0E",	mipscoxxx,
    "sync",		"",
    "mfhi",		"r%d",
    "mthi",		"r%s",
    "mflo",		"r%d",
    "mtlo",		"r%s",
    "special14",	mipscoxxx,
    "special15",	mipscoxxx,
    "special16",	mipscoxxx,
    "special17",	mipscoxxx,
    "mult",		mipscorsrt,
    "multu",	mipscorsrt,
    "div",		mipscorsrt,
    "divu",		mipscorsrt,
    "special1C",	mipscoxxx,
    "special1D",	mipscoxxx,
    "special1E",	mipscoxxx,
    "special1F",	mipscoxxx,
    "add",		mipscoalu3op,
    "addu",		mipscoalu3op,
    "sub",		mipscoalu3op,
    "subu",		mipscoalu3op,
    "and",		mipscoalu3op,
    "or",		mipscoalu3op,
    "xor",		mipscoalu3op,
    "nor",		mipscoalu3op,
    "special28",	mipscoxxx,
    "special29",	mipscoxxx,
    "slt",		mipscoalu3op,
    "sltu",		mipscoalu3op,
    "special2C",	mipscoxxx,
    "special2D",	mipscoxxx,
    "special2E",	mipscoxxx,
    "special2F",	mipscoxxx,
    "tge",		mipscorsrt,
    "tgeu",		mipscorsrt,
    "tlt",		mipscorsrt,
    "tltu",		mipscorsrt,
    "teq",		mipscorsrt,
    "special35",	mipscoxxx,
    "tne",		mipscorsrt,
    "special37",	mipscoxxx,
    "special38",	mipscoxxx,
    "special39",	mipscoxxx,
    "special3A",	mipscoxxx,
    "special3B",	mipscoxxx,
    "special3C",	mipscoxxx,
    "special3D",	mipscoxxx,
    "special3E",	mipscoxxx,
    "special3F",	mipscoxxx,
};
@

<<global ropcodes>>=
static Opcode ropcodes[32] = {
    "bltz",		mipscoboc0,
    "bgez",		mipscoboc0,
    "bltzl",	mipscoboc0,
    "bgezl",	mipscoboc0,
    "regimm04",	mipscoxxx,
    "regimm05",	mipscoxxx,
    "regimm06",	mipscoxxx,
    "regimm07",	mipscoxxx,
    "tgei",		mipscorsi,
    "tgeiu",	mipscorsi,
    "tlti",		mipscorsi,
    "tltiu",	mipscorsi,
    "teqi",		mipscorsi,
    "regimm0D",	mipscoxxx,
    "tnei",		mipscorsi,
    "regimm0F",	mipscoxxx,
    "bltzal",	mipscoboc0,
    "bgezal",	mipscoboc0,
    "bltzall",	mipscoboc0,
    "bgezall",	mipscoboc0,
    "regimm14",	mipscoxxx,
    "regimm15",	mipscoxxx,
    "regimm16",	mipscoxxx,
    "regimm17",	mipscoxxx,
    "regimm18",	mipscoxxx,
    "regimm19",	mipscoxxx,
    "regimm1A",	mipscoxxx,
    "regimm1B",	mipscoxxx,
    "regimm1C",	mipscoxxx,
    "regimm1D",	mipscoxxx,
    "regimm1E",	mipscoxxx,
    "regimm1F",	mipscoxxx,
};
@

<<global fopcodes>>=
static Opcode fopcodes[64] = {
    "add.%f",	mipscofp3,
    "sub.%f",	mipscofp3,
    "mul.%f",	mipscofp3,
    "div.%f",	mipscofp3,
    "sqrt.%f",	mipscofp2,
    "abs.%f",	mipscofp2,
    "mov.%f",	mipscofp2,
    "neg.%f",	mipscofp2,
    "finstr08",	mipscoxxx,
    "finstr09",	mipscoxxx,
    "finstr0A",	mipscoxxx,
    "finstr0B",	mipscoxxx,
    "round.w.%f",	mipscofp2,
    "trunc.w%f",	mipscofp2,
    "ceil.w%f",	mipscofp2,
    "floor.w%f",	mipscofp2,
    "finstr10",	mipscoxxx,
    "finstr11",	mipscoxxx,
    "finstr12",	mipscoxxx,
    "finstr13",	mipscoxxx,
    "finstr14",	mipscoxxx,
    "finstr15",	mipscoxxx,
    "finstr16",	mipscoxxx,
    "finstr17",	mipscoxxx,
    "finstr18",	mipscoxxx,
    "finstr19",	mipscoxxx,
    "finstr1A",	mipscoxxx,
    "finstr1B",	mipscoxxx,
    "finstr1C",	mipscoxxx,
    "finstr1D",	mipscoxxx,
    "finstr1E",	mipscoxxx,
    "finstr1F",	mipscoxxx,
    "cvt.s.%f",	mipscofp2,
    "cvt.d.%f",	mipscofp2,
    "cvt.e.%f",	mipscofp2,
    "cvt.q.%f",	mipscofp2,
    "cvt.w.%f",	mipscofp2,
    "finstr25",	mipscoxxx,
    "finstr26",	mipscoxxx,
    "finstr27",	mipscoxxx,
    "finstr28",	mipscoxxx,
    "finstr29",	mipscoxxx,
    "finstr2A",	mipscoxxx,
    "finstr2B",	mipscoxxx,
    "finstr2C",	mipscoxxx,
    "finstr2D",	mipscoxxx,
    "finstr2E",	mipscoxxx,
    "finstr2F",	mipscoxxx,
    "c.f.%f",	mipscofpc,
    "c.un.%f",	mipscofpc,
    "c.eq.%f",	mipscofpc,
    "c.ueq.%f",	mipscofpc,
    "c.olt.%f",	mipscofpc,
    "c.ult.%f",	mipscofpc,
    "c.ole.%f",	mipscofpc,
    "c.ule.%f",	mipscofpc,
    "c.sf.%f",	mipscofpc,
    "c.ngle.%f",	mipscofpc,
    "c.seq.%f",	mipscofpc,
    "c.ngl.%f",	mipscofpc,
    "c.lt.%f",	mipscofpc,
    "c.nge.%f",	mipscofpc,
    "c.le.%f",	mipscofpc,
    "c.ngt.%f",	mipscofpc,
};
@

<<global fsub>>=
static char fsub[16] = {
    's', 'd', 'e', 'q', 'w', '?', '?', '?',
    '?', '?', '?', '?', '?', '?', '?', '?'
};
@

<<function mkinstr (linkers/libmach/vcodas.c)>>=
static int
mkinstr(Instr *i, Map *map, uvlong pc)
{
    ulong w;

    if (get4(map, pc, &w) < 0) {
        werrstr("can't read instruction: %r");
        return -1;
    }
    i->addr = pc;
    i->op = (w >> 26) & 0x3F;
    i->rs = (w >> 21) & 0x1F;
    i->rt = (w >> 16) & 0x1F;
    i->rd = (w >> 11) & 0x1F;
    i->sa = (w >> 6) & 0x1F;
    i->function = w & 0x3F;
    i->immediate = w & 0x0000FFFF;
    if (i->immediate & 0x8000)
        i->immediate |= ~0x0000FFFF;
    i->cofun = w & 0x01FFFFFF;
    i->target = w & 0x03FFFFFF;
    i->w0 = w;
    return 1;
}
@

<<function bprint (linkers/libmach/vcodas.c)>>=
static void
bprint(Instr *i, char *fmt, ...)
{
    va_list arg;

    va_start(arg, fmt);
    i->curr = vseprint(i->curr, i->end, fmt, arg);
    va_end(arg);
}
@

<<function format>>=
static void
format(char *mnemonic, Instr *i, char *f)
{
    if (mnemonic)
        format(0, i, mnemonic);
    if (f == 0)
        return;
    if (i->curr < i->end)
        *i->curr++ = '\t';
    for ( ; *f && i->curr < i->end; f++) {
        if (*f != '%') {
            *i->curr++ = *f;
            continue;
        }
        switch (*++f) {

        case 's':
            bprint(i, "%d", i->rs);
            break;

        case 't':
            bprint(i, "%d", i->rt);
            break;

        case 'd':
            bprint(i, "%d", i->rd);
            break;

        case 'a':
            bprint(i, "%d", i->sa);
            break;

        case 'l':
            if (i->rs == 30) {
                i->curr += symoff(i->curr, i->end-i->curr, i->immediate+mach->sb, CANY);
                bprint(i, "(SB)");
            } else 
                bprint(i, "%lx(r%d)", i->immediate, i->rs);
            break;

        case 'i':
            bprint(i, "$%lx", i->immediate);
            break;

        case 'u':
            *i->curr++ = '$';
            i->curr += symoff(i->curr, i->end-i->curr, i->immediate, CANY);
            bprint(i, "(SB)");
            break;

        case 'j':
            i->curr += symoff(i->curr, i->end-i->curr,
                (i->target<<2)|(i->addr & 0xF0000000), CANY);
            bprint(i, "(SB)");
            break;

        case 'b':
            i->curr += symoff(i->curr, i->end-i->curr,
                (i->immediate<<2)+i->addr+4, CANY);
            break;

        case 'c':
            bprint(i, "%lux", i->cofun);
            break;

        case 'w':
            bprint(i, "[%lux]", i->w0);
            break;

        case 'f':
            *i->curr++ = fsub[i->rs & 0x0F];
            break;

        case '\0':
            *i->curr++ = '%';
            return;

        default:
            bprint(i, "%%%c", *f);
            break;
        }
    }
}
@

<<function copz>>=
static void
copz(int cop, Instr *i)
{
    char *f, *m, buf[16];

    m = buf;
    f = "%t,%d";
    switch (i->rs) {

    case 0:
        sprint(buf, "mfc%d", cop);
        break;

    case 2:
        sprint(buf, "cfc%d", cop);
        break;

    case 4:
        sprint(buf, "mtc%d", cop);
        break;

    case 6:
        sprint(buf, "ctc%d", cop);
        break;

    case 8:
        f = "%b";
        switch (i->rt) {

        case 0:
            sprint(buf, "bc%df", cop);
            break;

        case 1:
            sprint(buf, "bc%dt", cop);
            break;

        case 2:
            sprint(buf, "bc%dfl", cop);
            break;

        case 3:
            sprint(buf, "bc%dtl", cop);
            break;

        default:
            sprint(buf, "cop%d", cop);
            f = mipscoxxx;
            break;
        }
        break;

    default:
        sprint(buf, "cop%d", cop);
        if (i->rs & 0x10)
            f = "function %c";
        else
            f = mipscoxxx;
        break;
    }
    format(m, i, f);
}
@

<<function cop0>>=
static void
cop0(Instr *i)
{
    char *m = 0;

    if (i->rs >= 0x10) {
        switch (i->cofun) {
    
        case 1:
            m = "tlbr";
            break;
    
        case 2:
            m = "tlbwi";
            break;
    
        case 6:
            m = "tlbwr";
            break;
    
        case 8:
            m = "tlbp";
            break;
    
        case 16:
            m = "rfe";
            break;
    
        case 24:
            m = "eret";
            break;
    
        case 32:
            m = "wait";
            break;
        }
        if (m) {
            format(m, i, 0);
            if (i->curr < i->end)
                *i->curr++ = 0;
            return;
        }
    }
    copz(0, i);
}
@

<<function _mipscoinst>>=
int
_mipscoinst(Map *map, uvlong pc, char *buf, int n)
{
    Instr i;
    Opcode *o;
    uchar op;

    i.curr = buf;
    i.end = buf+n-1;
    if (mkinstr(&i, map, pc) < 0)
        return -1;
    switch (i.op) {

    case 0x00:					/* SPECIAL */
        o = sopcodes;
        op = i.function;
        break;

    case 0x01:					/* REGIMM */
        o = ropcodes;
        op = i.rt;
        break;

    case 0x10:					/* COP0 */
        cop0(&i);
        return 4;

    case 0x11:					/* COP1 */
        if (i.rs & 0x10) {
            o = fopcodes;
            op = i.function;
            break;
        }
        /*FALLTHROUGH*/
    case 0x12:					/* COP2 */
    case 0x13:					/* COP3 */
        copz(i.op-0x10, &i);
        return 4;

    default:
        o = opcodes;
        op = i.op;
        break;
    }
    format(o[op].mnemonic, &i, o[op].mipsco);
    return 4;
}
@


%-------------------------------------------------------------

<<linkers/libmach/vcodas.c>>=
#include <u.h>
#include <libc.h>
#include <bio.h>
#include <mach.h>

    /* mips native disassembler */

typedef struct {
    uvlong addr;			/* pc of instr */
    uchar op;			/* bits 31-26 */
    uchar rs;			/* bits 25-21 */
    uchar rt;			/* bits 20-16 */
    uchar rd;			/* bits 15-11 */
    uchar sa;			/* bits 10-6 */
    uchar function;			/* bits 5-0 */
    long immediate;			/* bits 15-0 */
    ulong cofun;			/* bits 24-0 */
    ulong target;			/* bits 25-0 */
    long w0;
    char *curr;			/* current fill point */
    char *end;			/* end of buffer */
    char *err;
} Instr;

typedef struct {
    char *mnemonic;
    char *mipsco;
} Opcode;

<<global mipscoload>>
<<global mipscoalui>>
<<global mipscoalu3op>>
<<global mipscoboc>>
<<global mipscoboc0>>
<<global mipscorsrt>>
<<global mipscorsi>>
<<global mipscoxxx>>
<<global mipscofp3>>
<<global mipscofp2>>
<<global mipscofpc>>

<<global opcodes>>

<<global sopcodes>>

<<global ropcodes>>

<<global fopcodes>>

<<global fsub>>


<<function mkinstr (linkers/libmach/vcodas.c)>>

#pragma	varargck	argpos	bprint		2

<<function bprint (linkers/libmach/vcodas.c)>>

<<function format>>

<<function copz>>

<<function cop0>>

<<function _mipscoinst>>
@


\subsection*{[[linkers/libmach/setmach.c]]}

<<struct machtab>>=
struct machtab
{
    char		*name;			/* machine name */
    short		type;			/* executable type */
    short		boottype;		/* bootable type */
    int		asstype;		/* disassembler code */
    Mach		*mach;			/* machine description */
    Machdata	*machdata;		/* machine functions */
};
@

<<global machines>>=
/*
 *	machine selection table.  machines with native disassemblers should
 *	follow the plan 9 variant in the table; native modes are selectable
 *	only by name.
 */
Machtab	machines[] =
{
    {	"mips",				/*plan 9 mips*/
        FMIPS,
        FMIPSB,
        AMIPS,
        &mmips,
        &mipsmach, 	},
    {	"mipsco",			/*native mips - must follow plan 9*/
        FMIPS,
        FMIPSB,
        AMIPSCO,
        &mmips,
        &mipsmach,	},
    {	"386",				/*plan 9 386*/
        FI386,
        FI386B,
        AI386,
        &mi386,
        &i386mach,	},
    {	"86",				/*8086 - a peach of a machine*/
        FI386,
        FI386B,
        AI8086,
        &mi386,
        &i386mach,	},
    {	"arm",				/*ARM*/
        FARM,
        FARMB,
        AARM,
        &marm,
        &armmach,	},
    {	0		},		/*the terminator*/
};
@

<<function machbytype>>=
/*
 *	select a machine by executable file type
 */
void
machbytype(int type)
{
    Machtab *mp;

    for (mp = machines; mp->name; mp++){
        if (mp->type == type || mp->boottype == type) {
            asstype = mp->asstype;
            machdata = mp->machdata;
            break;
        }
    }
}
@

<<function machbyname>>=
/*
 *	select a machine by name
 */
int
machbyname(char *name)
{
    Machtab *mp;

    if (!name) {
        asstype = AMIPS;
        machdata = &mipsmach;
        mach = &mmips;
        return 1;
    }
    for (mp = machines; mp->name; mp++){
        if (strcmp(mp->name, name) == 0) {
            asstype = mp->asstype;
            machdata = mp->machdata;
            mach = mp->mach;
            return 1;
        }
    }
    return 0;
}
@


%-------------------------------------------------------------

<<linkers/libmach/setmach.c>>=
#include	<u.h>
#include	<libc.h>
#include	<bio.h>
#include	<mach.h>
        /* table for selecting machine-dependent parameters */

typedef	struct machtab Machtab;

<<struct machtab>>

extern	Mach		mmips, mi386, marm;
extern	Machdata	mipsmach, i386mach, armmach;

<<global machines>>

<<function machbytype>>
<<function machbyname>>
@
