\documentclass[twocolumn]{report}

%******************************************************************************
% Prelude
%******************************************************************************
\newif\iffinal
\newif\ifverbose
\finaltrue\verbosefalse
% see also other newif in Macros.tex

%------------------------------------------------------------------------------
%history: 
%------------------------------------------------------------------------------

%thx to LP, changed for the better a few things:

%thx to codemap/codegraph:
% - see subtle dependency to 8c/enam.c through anames

%thx to this manual, better understand X11?:

%history LP-ization:
% - skeleton, mostly copy paste of Kernel.tex.nw skeleton
% - put all content of files in the Extra section, via 'pfff -lpize'
%   which also now split in chunks!
%    * function, global, struct, enum, constant, macro(actually function)
% - TODO read Extra section, identify concepts, first TOC
% - TODO distribute parts of the file before
% - TODO nullify, boolify, typeify,    scheckify
% - TODO aspecify advanced features!
% - TODO add figures
% - TODO add explanations

%------------------------------------------------------------------------------
% Packages
%------------------------------------------------------------------------------

\usepackage{../docs/latex/noweb}
 \noweboptions{footnotesizecode,nomargintag}
 %note: allow chunk on different pages, less white space at bottom of pages
 \def\nwendcode{\endtrivlist \endgroup}
 \let\nwdocspar=\par
\usepackage{xspace}
\usepackage{verbatim}
%note: required by noweblatexpad for the \t \l \n in this file
\usepackage{fancyvrb}
\usepackage{url}
\iffinal
\usepackage{hyperref}
 \hypersetup{colorlinks=true}
\fi
\usepackage[pageref]{backref}
 \def\backref{{\footnotesize cited page(s)}~}
\usepackage{cleveref} %\cref
\usepackage{multirow}
\usepackage{booktabs} 
 \newcommand{\otoprule}{\midrule[\heavyrulewidth]}
\usepackage{graphicx}
 %\usepackage[margin=0.5in]{geometry}
 %  but eat the bottom when very low
 %\usepackage{fullpage} is deprecated 
 % => do the more manual below:
 \addtolength{\oddsidemargin}{-.850in}
 \addtolength{\evensidemargin}{-.850in}
 \addtolength{\textwidth}{1.70in}
 \addtolength{\topmargin}{-.850in}
 \addtolength{\textheight}{1.70in}
%\usepackage{minitoc}

%------------------------------------------------------------------------------
% Macros
%------------------------------------------------------------------------------
\input{../docs/latex/Macros}

%------------------------------------------------------------------------------
% Config
%------------------------------------------------------------------------------
\allcodefalse
% used for forward decl, pragmas, func decl, extern decl, stats, #ifdef,
% debugging macros

%\setcounter{tocdepth}{1}

%******************************************************************************
% Title
%******************************************************************************

\begin{document}

\title{
{\Huge 
Plan9 Linker
% and Loader?
}\\
{version 0.1}
}

\author{
Yoann Padioleau\\
\texttt{yoann.padioleau@gmail.com}
}

\maketitle 
\onecolumn
\hrule
\begin{quote}
    Copyright \copyright{} 2014 Yoann Padioleau \\
    Permission is granted to copy, distribute and/or modify this document,
    except all the source code it contains, under the terms of the GNU Free
    Documentation License, Version 1.3.
\end{quote}
\hrule

%CONFIG: \dominitoc

\iffinal
\begingroup
\hypersetup{linkcolor=blue}
% need to s/onecolumn/twocolumn in report.cls :) for \tableofcontents
\twocolumn
\tableofcontents
\endgroup
\else
\tableofcontents
\fi

%******************************************************************************
% Body
%******************************************************************************

\chapter{Introduction}

%http://jvns.ca/blog/2014/09/06/how-to-read-an-executable/

\section{Motivations}

The goal of this book is to present in full details the source code of
a linker.
Why? Because I think it makes you a better programmer if
you fully understand how things work under the hood.

Here are other candidates that were considered but ultimately discarded:
\begin{itemize}
\item GNU ld and the bfd library
\item Gold
\end{itemize}

\section{Getting started}

\section{Requirements}

\section{About this document}
#include "../docs/latex/About.tex.nw"

\section{Copyright}

Most of this document is actually source code from Plan9, so
those parts are copyright by Lucent Technologies Inc.
The prose is mine and is licensed under the GNU Free Documentation
License.

\section{Acknowledgments}


\chapter{Overview}

\section{Linker principles}
% and loader? why the use the term loader instead of linker?

% link together object files. Resolve external symbols.
% (actually for plan9 the linker is also generating the
% ISA binary code (what was usually done by the assembler))


\section{[[8l]] services}

% command line interface? -o

% important -TText, see Kernel.tex.nw

<<function usage (linkers/8l/obj.c)>>=
/*
 *	-H0 -T0x40004C -D0x10000000	is garbage unix
 *	-H1 -T0xd0 -R4			is unix coff
 *	-H2 -T4128 -R4096		is plan9 format
 *	-H3 -Tx -Rx			is MS-DOS .COM
 *	-H4 -Tx -Rx			is fake MS-DOS .EXE
 *	-H5 -T0x80100020 -R4096		is ELF
 */

void
usage(void)
{
    diag("usage: %s [-options] objects", argv0);
    errorexit();
}
@


\section{Example}
% show binary format? hexdump?

\section{Object format}
% the input this time (as opposed to 8a where it's the output)

% nm foo.8 => ? U? D? T?

% nm is using libmach, crachhdr, etc, generic API for object manip

\section{Code organization}

\section{Architecture overview}

% depends on 8.out.h all assembly instructions, registers, etc

% depends on 8c/ for some files
%8c -FTVw -I/home/pad/plan9/include/386 -I/home/pad/plan9/include -. -I. ../8c/enam.c
%8c -FTVw -I/home/pad/plan9/include/386 -I/home/pad/plan9/include -. -I. compat.c
%8c -FTVw -I/home/pad/plan9/include/386 -I/home/pad/plan9/include -. -I. ../8l/elf.c

%###############################################################################

\chapter{Core Data Structures}

\section{[[Instruction]] and [[Register]]}
% in 8.out.h: Instruction (enum as), Register (enum reg)
% see Aconv

\section{[[Sym]]}

% conflict with include/a.out.h
<<struct Sym>>=
struct	Sym
{
    char	*name;
    short	type;

    short	version;
    short	become;
    short	frame;
    uchar	subtype;
    ushort	file;
    long	value;
    long	sig;

    // Extra
    Sym*	link;
};
@

<<constant S>>=
#define	S		((Sym*)0)
@


<<constant NHASH 8l.h>>=
    NHASH		= 10007,
@

<<global hash (linkers/8l/globals.c)>>=
Sym*	hash[NHASH];
@

<<function lookup>>=
Sym*
lookup(char *symb, int v)
{
    Sym *s;
    char *p;
    long h;
    int l, c;

    h = v;
    for(p=symb; c = *p; p++)
        h = h+h+h + c;
    l = (p - symb) + 1;
    h &= 0xffffff;
    h %= NHASH;
    for(s = hash[h]; s != S; s = s->link)
        if(s->version == v)
        if(memcmp(s->name, symb, l) == 0)
            return s;

    while(nhunk < sizeof(Sym))
        gethunk();
    s = (Sym*)hunk;
    nhunk -= sizeof(Sym);
    hunk += sizeof(Sym);

    s->name = malloc(l + 1);
    memmove(s->name, symb, l);

    s->link = hash[h];
    s->type = 0;
    s->version = v;
    s->value = 0;
    s->sig = 0;
    hash[h] = s;
    nsymbol++;
    return s;
}
@


\section{[[Adr]]}

<<struct Adr>>=
struct	Adr
{
    union
    {
        long	u0offset;
        char	u0scon[8];
        Prog	*u0cond;	/* not used, but should be D_BRANCH */
        Ieee	u0ieee;
    } u0;
    union
    {
        Auto*	u1autom;
        Sym*	u1sym;
    } u1;

    short	type;
    uchar	index;
    char	scale;
};
@

<<constant offset>>=
#define	offset	u0.u0offset
@

<<constant scon>>=
#define	scon	u0.u0scon
@

<<constant cond>>=
#define	cond	u0.u0cond
@

<<constant ieee>>=
#define	ieee	u0.u0ieee
@

<<constant autom>>=
#define	autom	u1.u1autom
@

<<constant sym>>=
#define	sym	u1.u1sym
@

\section{[[Prog]] and [[curtext]]}

<<struct Prog>>=
struct	Prog
{
    Adr	from;
    Adr	to;

    //enum<section>>
    short	as;

    Prog	*forwd;
    Prog*	link;
    Prog*	pcond;	/* work on this */
    long	pc;
    long	line;
    char	width;		/* fake for DATA */
    char	ft;		/* oclass cache */
    char	tt;
    uchar	mark;	/* work on these */
    uchar	back;
};
@

<<enum sxxx>>=
enum sxxx
{
    STEXT		= 1,
    SDATA,
    SBSS,
    SDATA1,
    SXREF,
    SFILE,
    SCONST,
    SUNDEF,

    SIMPORT,
    SEXPORT,
};
@

<<constant P>>=
#define	P		((Prog*)0)
@

<<global curtext>>=
Prog*	curtext;
@

<<constant TNAME>>=
#define	TNAME		(curtext?curtext->from.sym->name:noname)
@



<<global undefp>>=
//@Scheck: not dead, used by UP
Prog	undefp;
@

<<constant UP>>=
#define	UP	(&undefp)
@

\section{[[Auto]]}

<<struct Auto>>=
struct	Auto
{
    Sym*	asym;

    Auto*	link;
    long	aoffset;
    short	type;
};
@

\section{[[Optab]] and [[optab]]}

<<struct Optab>>=
struct	Optab
{
    // enum<as> from 8.out.h
    short	as;

    uchar*	ytab;

    // enum<Pxxx>
    byte	prefix;
    // the actual x86 machine code for instruction optab.as
    byte	op[10];
};
@

\chapter{[[main()]]}

<<function main (linkers/8l/obj.c)>>=
void
main(int argc, char *argv[])
{
    int i, c;
    char *a;
    char name[LIBNAMELEN];

    Binit(&bso, 1, OWRITE);
    cout = -1;
    listinit();
    memset(debug, 0, sizeof(debug));
    nerrors = 0;
    outfile = "8.out";
    HEADTYPE = -1;
    INITTEXT = -1;
    INITTEXTP = -1;
    INITDAT = -1;
    INITRND = -1;
    INITENTRY = 0;
    ARGBEGIN {
    default:
        c = ARGC();
        if(c >= 0 && c < sizeof(debug))
            debug[c]++;
        break;
    case 'o': /* output to (next arg) */
        outfile = ARGF();
        break;
    case 'E':
        a = ARGF();
        if(a)
            INITENTRY = a;
        break;
    case 'H':
        a = ARGF();
        if(a)
            HEADTYPE = atolwhex(a);
        break;
    case 'L':
        addlibpath(EARGF(usage()));
        break;
    case 'T':
        a = ARGF();
        if(a)
            INITTEXT = atolwhex(a);
        break;
    case 'P':
        a = ARGF();
        if(a)
            INITTEXTP = atolwhex(a);
        break;
    case 'D':
        a = ARGF();
        if(a)
            INITDAT = atolwhex(a);
        break;
    case 'R':
        a = ARGF();
        if(a)
            INITRND = atolwhex(a);
        break;
    case 'x':	/* produce export table */
        doexp = 1;
        if(argv[1] != nil && argv[1][0] != '-' && !isobjfile(argv[1])){
            a = ARGF();
            if(strcmp(a, "*") == 0)
                allexport = 1;
            else
                readundefs(a, SEXPORT);
        }
        break;
    case 'u':	/* produce dynamically loadable module */
        dlm = 1;
        debug['l']++;
        if(argv[1] != nil && argv[1][0] != '-' && !isobjfile(argv[1]))
            readundefs(ARGF(), SIMPORT);
        break;
    } ARGEND
    USED(argc);
    if(*argv == 0)
        usage();
    if(!debug['9'] && !debug['U'] && !debug['B'])
        debug[DEFAULT] = 1;
    a = getenv("ccroot");
    if(a != nil && *a != '\0') {
        if(!fileexists(a)) {
            diag("nonexistent $ccroot: %s", a);
            errorexit();
        }
    }else
        a = "";
    snprint(name, sizeof(name), "%s/%s/lib", a, thestring);
    addlibpath(name);
    if(HEADTYPE == -1) {
        if(debug['U'])
            HEADTYPE = 1;
        if(debug['B'])
            HEADTYPE = 2;
        if(debug['9'])
            HEADTYPE = 2;
    }
    switch(HEADTYPE) {
    default:
        diag("unknown -H option");
        errorexit();

    case 0:	/* this is garbage */
        HEADR = 20L+56L;
        if(INITTEXT == -1)
            INITTEXT = 0x40004CL;
        if(INITDAT == -1)
            INITDAT = 0x10000000L;
        if(INITRND == -1)
            INITRND = 0;
        break;
    case 1:	/* is unix coff */
        HEADR = 0xd0L;
        if(INITTEXT == -1)
            INITTEXT = 0xd0;
        if(INITDAT == -1)
            INITDAT = 0x400000;
        if(INITRND == -1)
            INITRND = 0;
        break;
    case 2:	/* plan 9 */
        HEADR = 32L;
        if(INITTEXT == -1)
            INITTEXT = 4096+32;
        if(INITDAT == -1)
            INITDAT = 0;
        if(INITRND == -1)
            INITRND = 4096;
        break;
    case 3:	/* MS-DOS .COM */
        HEADR = 0;
        if(INITTEXT == -1)
            INITTEXT = 0x0100;
        if(INITDAT == -1)
            INITDAT = 0;
        if(INITRND == -1)
            INITRND = 4;
        break;
    case 4:	/* fake MS-DOS .EXE */
        HEADR = 0x200;
        if(INITTEXT == -1)
            INITTEXT = 0x0100;
        if(INITDAT == -1)
            INITDAT = 0;
        if(INITRND == -1)
            INITRND = 4;
        HEADR += (INITTEXT & 0xFFFF);
        if(debug['v'])
            Bprint(&bso, "HEADR = 0x%ld\n", HEADR);
        break;
    case 5:	/* elf executable */
        HEADR = rnd(Ehdr32sz+3*Phdr32sz, 16);
        if(INITTEXT == -1)
            INITTEXT = 0x80100020L;
        if(INITDAT == -1)
            INITDAT = 0;
        if(INITRND == -1)
            INITRND = 4096;
        break;
    }
    if (INITTEXTP == -1)
        INITTEXTP = INITTEXT;
    if(INITDAT != 0 && INITRND != 0)
        print("warning: -D0x%lux is ignored because of -R0x%lux\n",
            INITDAT, INITRND);
    if(debug['v'])
        Bprint(&bso, "HEADER = -H0x%ld -T0x%lux -D0x%lux -R0x%lux\n",
            HEADTYPE, INITTEXT, INITDAT, INITRND);
    Bflush(&bso);
    for(i=1; optab[i].as; i++)
        if(i != optab[i].as) {
            diag("phase error in optab: %d", i);
            errorexit();
        }

    for(i=0; i<Ymax; i++)
        ycover[i*Ymax + i] = 1;

    ycover[Yi0*Ymax + Yi8] = 1;
    ycover[Yi1*Ymax + Yi8] = 1;

    ycover[Yi0*Ymax + Yi32] = 1;
    ycover[Yi1*Ymax + Yi32] = 1;
    ycover[Yi8*Ymax + Yi32] = 1;

    ycover[Yal*Ymax + Yrb] = 1;
    ycover[Ycl*Ymax + Yrb] = 1;
    ycover[Yax*Ymax + Yrb] = 1;
    ycover[Ycx*Ymax + Yrb] = 1;
    ycover[Yrx*Ymax + Yrb] = 1;

    ycover[Yax*Ymax + Yrx] = 1;
    ycover[Ycx*Ymax + Yrx] = 1;

    ycover[Yax*Ymax + Yrl] = 1;
    ycover[Ycx*Ymax + Yrl] = 1;
    ycover[Yrx*Ymax + Yrl] = 1;

    ycover[Yf0*Ymax + Yrf] = 1;

    ycover[Yal*Ymax + Ymb] = 1;
    ycover[Ycl*Ymax + Ymb] = 1;
    ycover[Yax*Ymax + Ymb] = 1;
    ycover[Ycx*Ymax + Ymb] = 1;
    ycover[Yrx*Ymax + Ymb] = 1;
    ycover[Yrb*Ymax + Ymb] = 1;
    ycover[Ym*Ymax + Ymb] = 1;

    ycover[Yax*Ymax + Yml] = 1;
    ycover[Ycx*Ymax + Yml] = 1;
    ycover[Yrx*Ymax + Yml] = 1;
    ycover[Yrl*Ymax + Yml] = 1;
    ycover[Ym*Ymax + Yml] = 1;

    for(i=0; i<D_NONE; i++) {
        reg[i] = -1;
        if(i >= D_AL && i <= D_BH)
            reg[i] = (i-D_AL) & 7;
        if(i >= D_AX && i <= D_DI)
            reg[i] = (i-D_AX) & 7;
        if(i >= D_F0 && i <= D_F0+7)
            reg[i] = (i-D_F0) & 7;
    }

    zprg.link = P;
    zprg.pcond = P;
    zprg.back = 2;
    zprg.as = AGOK;
    zprg.from.type = D_NONE;
    zprg.from.index = D_NONE;
    zprg.from.scale = 1;
    zprg.to = zprg.from;

    pcstr = "%.6lux ";
    nuxiinit();
    histgen = 0;
    textp = P;
    datap = P;
    edatap = P;
    pc = 0;
    dtype = 4;
    cout = create(outfile, 1, 0775);
    if(cout < 0) {
        diag("cannot create %s: %r", outfile);
        errorexit();
    }
    version = 0;
    cbp = buf.cbuf;
    cbc = sizeof(buf.cbuf);
    firstp = prg();
    lastp = firstp;

    if(INITENTRY == 0) {
        INITENTRY = "_main";
        if(debug['p'])
            INITENTRY = "_mainp";
        if(!debug['l'])
            lookup(INITENTRY, 0)->type = SXREF;
    } else if(!(*INITENTRY >= '0' && *INITENTRY <= '9'))
        lookup(INITENTRY, 0)->type = SXREF;

    while(*argv)
        objfile(*argv++);
    if(!debug['l'])
        loadlib();
    firstp = firstp->link;
    if(firstp == P)
        errorexit();
    if(doexp || dlm){
        EXPTAB = "_exporttab";
        zerosig(EXPTAB);
        zerosig("etext");
        zerosig("edata");
        zerosig("end");
        if(dlm){
            import();
            HEADTYPE = 2;
            INITTEXT = INITDAT = 0;
            INITRND = 8;
            INITENTRY = EXPTAB;
        }
        export();
    }
    patch();
    follow();
    dodata();
    dostkoff();
    if(debug['p'])
        if(debug['1'])
            doprof1();
        else
            doprof2();
    span();
    doinit();
    asmb();
    undef();
    if(debug['v']) {
        Bprint(&bso, "%5.2f cpu time\n", cputime());
        Bprint(&bso, "%ld symbols\n", nsymbol);
        Bprint(&bso, "%ld memory used\n", thunk);
        Bprint(&bso, "%d sizeof adr\n", sizeof(Adr));
        Bprint(&bso, "%d sizeof prog\n", sizeof(Prog));
    }
    Bflush(&bso);

    errorexit();
}
@
%$ 

\chapter{Sections}


\chapter{Libraries}

% ar.h

<<constant ARMAG>>=
#define	ARMAG	"!<arch>\n"
@

<<constant SARMAG>>=
#define	SARMAG	8
@

<<constant ARFMAG>>=
#define	ARFMAG	"`\n"
@

<<constant SARNAME>>=
#define SARNAME	16
@

<<struct ar_hdr>>=
struct	ar_hdr
{
    char	name[SARNAME];
    char	date[12];
    char	uid[6];
    char	gid[6];
    char	mode[8];
    char	size[10];
    char	fmag[2];
};
@

<<constant SAR_HDR>>=
#define	SAR_HDR	(SARNAME+44)
@


% ar.c

\chapter{Machine Code Generation}

% done by 8l, not 8a, surprisingly
% why? because allows more optimisations? cross libs? as in llvm?

<<enum pxxx>>=
enum pxxx {
    Px		= 0,
    Pe		= 0x66,	/* operand escape */
    Pm		= 0x0f,	/* 2byte opcode escape */
    Pq		= 0xff,	/* both escape */
    Pb		= 0xfe,	/* byte operands */
};
@

<<global optab>>=
Optab optab[] =
/*	as, ytab, andproto, opcode */
{
    { AXXX },
    { AAAA,		ynone,	Px, 0x37 },
    { AAAD,		ynone,	Px, 0xd5,0x0a },
    { AAAM,		ynone,	Px, 0xd4,0x0a },
    { AAAS,		ynone,	Px, 0x3f },
    { AADCB,	yxorb,	Pb, 0x14,0x80,(02),0x10,0x10 },
    { AADCL,	yxorl,	Px, 0x83,(02),0x15,0x81,(02),0x11,0x13 },
    { AADCW,	yxorl,	Pe, 0x83,(02),0x15,0x81,(02),0x11,0x13 },
    { AADDB,	yxorb,	Px, 0x04,0x80,(00),0x00,0x02 },
    { AADDL,	yaddl,	Px, 0x83,(00),0x05,0x81,(00),0x01,0x03 },
    { AADDW,	yaddl,	Pe, 0x83,(00),0x05,0x81,(00),0x01,0x03 },
    { AADJSP },
    { AANDB,	yxorb,	Pb, 0x24,0x80,(04),0x20,0x22 },
    { AANDL,	yxorl,	Px, 0x83,(04),0x25,0x81,(04),0x21,0x23 },
    { AANDW,	yxorl,	Pe, 0x83,(04),0x25,0x81,(04),0x21,0x23 },
    { AARPL,	yrl_ml,	Px, 0x63 },
    { ABOUNDL,	yrl_m,	Px, 0x62 },
    { ABOUNDW,	yrl_m,	Pe, 0x62 },
    { ABSFL,	yml_rl,	Pm, 0xbc },
    { ABSFW,	yml_rl,	Pq, 0xbc },
    { ABSRL,	yml_rl,	Pm, 0xbd },
    { ABSRW,	yml_rl,	Pq, 0xbd },
    { ABTL,		yml_rl,	Pm, 0xa3 },
    { ABTW,		yml_rl,	Pq, 0xa3 },
    { ABTCL,	yml_rl,	Pm, 0xbb },
    { ABTCW,	yml_rl,	Pq, 0xbb },
    { ABTRL,	yml_rl,	Pm, 0xb3 },
    { ABTRW,	yml_rl,	Pq, 0xb3 },
    { ABTSL,	yml_rl,	Pm, 0xab },
    { ABTSW,	yml_rl,	Pq, 0xab },
    { ABYTE,	ybyte,	Px, 1 },
    { ACALL,	ycall,	Px, 0xff,(02),0xe8 },
    { ACLC,		ynone,	Px, 0xf8 },
    { ACLD,		ynone,	Px, 0xfc },
    { ACLI,		ynone,	Px, 0xfa },
    { ACLTS,	ynone,	Pm, 0x06 },
    { ACMC,		ynone,	Px, 0xf5 },
    { ACMPB,	ycmpb,	Pb, 0x3c,0x80,(07),0x38,0x3a },
    { ACMPL,	ycmpl,	Px, 0x83,(07),0x3d,0x81,(07),0x39,0x3b },
    { ACMPW,	ycmpl,	Pe, 0x83,(07),0x3d,0x81,(07),0x39,0x3b },
    { ACMPSB,	ynone,	Pb, 0xa6 },
    { ACMPSL,	ynone,	Px, 0xa7 },
    { ACMPSW,	ynone,	Pe, 0xa7 },
    { ADAA,		ynone,	Px, 0x27 },
    { ADAS,		ynone,	Px, 0x2f },
    { ADATA },
    { ADECB,	yincb,	Pb, 0xfe,(01) },
    { ADECL,	yincl,	Px, 0x48,0xff,(01) },
    { ADECW,	yincl,	Pe, 0x48,0xff,(01) },
    { ADIVB,	ydivb,	Pb, 0xf6,(06) },
    { ADIVL,	ydivl,	Px, 0xf7,(06) },
    { ADIVW,	ydivl,	Pe, 0xf7,(06) },
    { AENTER },				/* botch */
    { AGLOBL },
    { AGOK },
    { AHISTORY },
    { AHLT,		ynone,	Px, 0xf4 },
    { AIDIVB,	ydivb,	Pb, 0xf6,(07) },
    { AIDIVL,	ydivl,	Px, 0xf7,(07) },
    { AIDIVW,	ydivl,	Pe, 0xf7,(07) },
    { AIMULB,	ydivb,	Pb, 0xf6,(05) },
    { AIMULL,	yimul,	Px, 0xf7,(05),0x6b,0x69 },
    { AIMULW,	yimul,	Pe, 0xf7,(05),0x6b,0x69 },
    { AINB,		yin,	Pb, 0xe4,0xec },
    { AINL,		yin,	Px, 0xe5,0xed },
    { AINW,		yin,	Pe, 0xe5,0xed },
    { AINCB,	yincb,	Pb, 0xfe,(00) },
    { AINCL,	yincl,	Px, 0x40,0xff,(00) },
    { AINCW,	yincl,	Pe, 0x40,0xff,(00) },
    { AINSB,	ynone,	Pb, 0x6c },
    { AINSL,	ynone,	Px, 0x6d },
    { AINSW,	ynone,	Pe, 0x6d },
    { AINT,		yint,	Px, 0xcd },
    { AINTO,	ynone,	Px, 0xce },
    { AIRETL,	ynone,	Px, 0xcf },
    { AIRETW,	ynone,	Pe, 0xcf },
    { AJCC,		yjcond,	Px, 0x73,0x83,(00) },
    { AJCS,		yjcond,	Px, 0x72,0x82 },
    { AJCXZ,	yloop,	Px, 0xe3 },
    { AJEQ,		yjcond,	Px, 0x74,0x84 },
    { AJGE,		yjcond,	Px, 0x7d,0x8d },
    { AJGT,		yjcond,	Px, 0x7f,0x8f },
    { AJHI,		yjcond,	Px, 0x77,0x87 },
    { AJLE,		yjcond,	Px, 0x7e,0x8e },
    { AJLS,		yjcond,	Px, 0x76,0x86 },
    { AJLT,		yjcond,	Px, 0x7c,0x8c },
    { AJMI,		yjcond,	Px, 0x78,0x88 },
    { AJMP,		yjmp,	Px, 0xff,(04),0xeb,0xe9 },
    { AJNE,		yjcond,	Px, 0x75,0x85 },
    { AJOC,		yjcond,	Px, 0x71,0x81,(00) },
    { AJOS,		yjcond,	Px, 0x70,0x80,(00) },
    { AJPC,		yjcond,	Px, 0x7b,0x8b },
    { AJPL,		yjcond,	Px, 0x79,0x89 },
    { AJPS,		yjcond,	Px, 0x7a,0x8a },
    { ALAHF,	ynone,	Px, 0x9f },
    { ALARL,	yml_rl,	Pm, 0x02 },
    { ALARW,	yml_rl,	Pq, 0x02 },
    { ALEAL,	ym_rl,	Px, 0x8d },
    { ALEAW,	ym_rl,	Pe, 0x8d },
    { ALEAVEL,	ynone,	Px, 0xc9 },
    { ALEAVEW,	ynone,	Pe, 0xc9 },
    { ALOCK,	ynone,	Px, 0xf0 },
    { ALODSB,	ynone,	Pb, 0xac },
    { ALODSL,	ynone,	Px, 0xad },
    { ALODSW,	ynone,	Pe, 0xad },
    { ALONG,	ybyte,	Px, 4 },
    { ALOOP,	yloop,	Px, 0xe2 },
    { ALOOPEQ,	yloop,	Px, 0xe1 },
    { ALOOPNE,	yloop,	Px, 0xe0 },
    { ALSLL,	yml_rl,	Pm, 0x03  },
    { ALSLW,	yml_rl,	Pq, 0x03  },
    { AMOVB,	ymovb,	Pb, 0x88,0x8a,0xb0,0xc6,(00) },
    { AMOVL,	ymovl,	Px, 0x89,0x8b,0x31,0x83,(04),0xb8,0xc7,(00) },
    { AMOVW,	ymovl,	Pe, 0x89,0x8b,0x31,0x83,(04),0xb8,0xc7,(00) },
    { AMOVBLSX,	ymb_rl,	Pm, 0xbe },
    { AMOVBLZX,	ymb_rl,	Pm, 0xb6 },
    { AMOVBWSX,	ymb_rl,	Pq, 0xbe },
    { AMOVBWZX,	ymb_rl,	Pq, 0xb6 },
    { AMOVWLSX,	yml_rl,	Pm, 0xbf },
    { AMOVWLZX,	yml_rl,	Pm, 0xb7 },
    { AMOVSB,	ynone,	Pb, 0xa4 },
    { AMOVSL,	ynone,	Px, 0xa5 },
    { AMOVSW,	ynone,	Pe, 0xa5 },
    { AMULB,	ydivb,	Pb, 0xf6,(04) },
    { AMULL,	ydivl,	Px, 0xf7,(04) },
    { AMULW,	ydivl,	Pe, 0xf7,(04) },
    { ANAME },
    { ANEGB,	yscond,	Px, 0xf6,(03) },
    { ANEGL,	yscond,	Px, 0xf7,(03) },
    { ANEGW,	yscond,	Pe, 0xf7,(03) },
    { ANOP,		ynop,	Px,0,0 },
    { ANOTB,	yscond,	Px, 0xf6,(02) },
    { ANOTL,	yscond,	Px, 0xf7,(02) },
    { ANOTW,	yscond,	Pe, 0xf7,(02) },
    { AORB,		yxorb,	Pb, 0x0c,0x80,(01),0x08,0x0a },
    { AORL,		yxorl,	Px, 0x83,(01),0x0d,0x81,(01),0x09,0x0b },
    { AORW,		yxorl,	Pe, 0x83,(01),0x0d,0x81,(01),0x09,0x0b },
    { AOUTB,	yin,	Pb, 0xe6,0xee },
    { AOUTL,	yin,	Px, 0xe7,0xef },
    { AOUTW,	yin,	Pe, 0xe7,0xef },
    { AOUTSB,	ynone,	Pb, 0x6e },
    { AOUTSL,	ynone,	Px, 0x6f },
    { AOUTSW,	ynone,	Pe, 0x6f },
    { APOPAL,	ynone,	Px, 0x61 },
    { APOPAW,	ynone,	Pe, 0x61 },
    { APOPFL,	ynone,	Px, 0x9d },
    { APOPFW,	ynone,	Pe, 0x9d },
    { APOPL,	ypopl,	Px, 0x58,0x8f,(00) },
    { APOPW,	ypopl,	Pe, 0x58,0x8f,(00) },
    { APUSHAL,	ynone,	Px, 0x60 },
    { APUSHAW,	ynone,	Pe, 0x60 },
    { APUSHFL,	ynone,	Px, 0x9c },
    { APUSHFW,	ynone,	Pe, 0x9c },
    { APUSHL,	ypushl,	Px, 0x50,0xff,(06),0x6a,0x68 },
    { APUSHW,	ypushl,	Pe, 0x50,0xff,(06),0x6a,0x68 },
    { ARCLB,	yshb,	Pb, 0xd0,(02),0xc0,(02),0xd2,(02) },
    { ARCLL,	yshl,	Px, 0xd1,(02),0xc1,(02),0xd3,(02),0xd3,(02) },
    { ARCLW,	yshl,	Pe, 0xd1,(02),0xc1,(02),0xd3,(02),0xd3,(02) },
    { ARCRB,	yshb,	Pb, 0xd0,(03),0xc0,(03),0xd2,(03) },
    { ARCRL,	yshl,	Px, 0xd1,(03),0xc1,(03),0xd3,(03),0xd3,(03) },
    { ARCRW,	yshl,	Pe, 0xd1,(03),0xc1,(03),0xd3,(03),0xd3,(03) },
    { AREP,		ynone,	Px, 0xf3 },
    { AREPN,	ynone,	Px, 0xf2 },
    { ARET,		ynone,	Px, 0xc3 },
    { AROLB,	yshb,	Pb, 0xd0,(00),0xc0,(00),0xd2,(00) },
    { AROLL,	yshl,	Px, 0xd1,(00),0xc1,(00),0xd3,(00),0xd3,(00) },
    { AROLW,	yshl,	Pe, 0xd1,(00),0xc1,(00),0xd3,(00),0xd3,(00) },
    { ARORB,	yshb,	Pb, 0xd0,(01),0xc0,(01),0xd2,(01) },
    { ARORL,	yshl,	Px, 0xd1,(01),0xc1,(01),0xd3,(01),0xd3,(01) },
    { ARORW,	yshl,	Pe, 0xd1,(01),0xc1,(01),0xd3,(01),0xd3,(01) },
    { ASAHF,	ynone,	Px, 0x9e },
    { ASALB,	yshb,	Pb, 0xd0,(04),0xc0,(04),0xd2,(04) },
    { ASALL,	yshl,	Px, 0xd1,(04),0xc1,(04),0xd3,(04),0xd3,(04) },
    { ASALW,	yshl,	Pe, 0xd1,(04),0xc1,(04),0xd3,(04),0xd3,(04) },
    { ASARB,	yshb,	Pb, 0xd0,(07),0xc0,(07),0xd2,(07) },
    { ASARL,	yshl,	Px, 0xd1,(07),0xc1,(07),0xd3,(07),0xd3,(07) },
    { ASARW,	yshl,	Pe, 0xd1,(07),0xc1,(07),0xd3,(07),0xd3,(07) },
    { ASBBB,	yxorb,	Pb, 0x1c,0x80,(03),0x18,0x1a },
    { ASBBL,	yxorl,	Px, 0x83,(03),0x1d,0x81,(03),0x19,0x1b },
    { ASBBW,	yxorl,	Pe, 0x83,(03),0x1d,0x81,(03),0x19,0x1b },
    { ASCASB,	ynone,	Pb, 0xae },
    { ASCASL,	ynone,	Px, 0xaf },
    { ASCASW,	ynone,	Pe, 0xaf },
    { ASETCC,	yscond,	Pm, 0x93,(00) },
    { ASETCS,	yscond,	Pm, 0x92,(00) },
    { ASETEQ,	yscond,	Pm, 0x94,(00) },
    { ASETGE,	yscond,	Pm, 0x9d,(00) },
    { ASETGT,	yscond,	Pm, 0x9f,(00) },
    { ASETHI,	yscond,	Pm, 0x97,(00) },
    { ASETLE,	yscond,	Pm, 0x9e,(00) },
    { ASETLS,	yscond,	Pm, 0x96,(00) },
    { ASETLT,	yscond,	Pm, 0x9c,(00) },
    { ASETMI,	yscond,	Pm, 0x98,(00) },
    { ASETNE,	yscond,	Pm, 0x95,(00) },
    { ASETOC,	yscond,	Pm, 0x91,(00) },
    { ASETOS,	yscond,	Pm, 0x90,(00) },
    { ASETPC,	yscond,	Pm, 0x96,(00) },
    { ASETPL,	yscond,	Pm, 0x99,(00) },
    { ASETPS,	yscond,	Pm, 0x9a,(00) },
    { ACDQ,		ynone,	Px, 0x99 },
    { ACWD,		ynone,	Pe, 0x99 },
    { ASHLB,	yshb,	Pb, 0xd0,(04),0xc0,(04),0xd2,(04) },
    { ASHLL,	yshl,	Px, 0xd1,(04),0xc1,(04),0xd3,(04),0xd3,(04) },
    { ASHLW,	yshl,	Pe, 0xd1,(04),0xc1,(04),0xd3,(04),0xd3,(04) },
    { ASHRB,	yshb,	Pb, 0xd0,(05),0xc0,(05),0xd2,(05) },
    { ASHRL,	yshl,	Px, 0xd1,(05),0xc1,(05),0xd3,(05),0xd3,(05) },
    { ASHRW,	yshl,	Pe, 0xd1,(05),0xc1,(05),0xd3,(05),0xd3,(05) },
    { ASTC,		ynone,	Px, 0xf9 },
    { ASTD,		ynone,	Px, 0xfd },
    { ASTI,		ynone,	Px, 0xfb },
    { ASTOSB,	ynone,	Pb, 0xaa },
    { ASTOSL,	ynone,	Px, 0xab },
    { ASTOSW,	ynone,	Pe, 0xab },
    { ASUBB,	yxorb,	Pb, 0x2c,0x80,(05),0x28,0x2a },
    { ASUBL,	yaddl,	Px, 0x83,(05),0x2d,0x81,(05),0x29,0x2b },
    { ASUBW,	yaddl,	Pe, 0x83,(05),0x2d,0x81,(05),0x29,0x2b },
    { ASYSCALL,	ynone,	Px, 0xcd,100 },
    { ATESTB,	ytestb,	Pb, 0xa8,0xf6,(00),0x84,0x84 },
    { ATESTL,	ytestl,	Px, 0xa9,0xf7,(00),0x85,0x85 },
    { ATESTW,	ytestl,	Pe, 0xa9,0xf7,(00),0x85,0x85 },
    { ATEXT,	ytext,	Px },
    { AVERR,	ydivl,	Pm, 0x00,(04) },
    { AVERW,	ydivl,	Pm, 0x00,(05) },
    { AWAIT,	ynone,	Px, 0x9b },
    { AWORD,	ybyte,	Px, 2 },
    { AXCHGB,	yml_mb,	Pb, 0x86,0x86 },
    { AXCHGL,	yml_ml,	Px, 0x87,0x87 },
    { AXCHGW,	yml_ml,	Pe, 0x87,0x87 },
    { AXLAT,	ynone,	Px, 0xd7 },
    { AXORB,	yxorb,	Pb, 0x34,0x80,(06),0x30,0x32 },
    { AXORL,	yxorl,	Px, 0x83,(06),0x35,0x81,(06),0x31,0x33 },
    { AXORW,	yxorl,	Pe, 0x83,(06),0x35,0x81,(06),0x31,0x33 },

    { AFMOVB,	yfmvx,	Px, 0xdf,(04) },
    { AFMOVBP,	yfmvp,	Px, 0xdf,(06) },
    { AFMOVD,	yfmvd,	Px, 0xdd,(00),0xdd,(02),0xd9,(00),0xdd,(02) },
    { AFMOVDP,	yfmvdp,	Px, 0xdd,(03),0xdd,(03) },
    { AFMOVF,	yfmvf,	Px, 0xd9,(00),0xd9,(02) },
    { AFMOVFP,	yfmvp,	Px, 0xd9,(03) },
    { AFMOVL,	yfmvf,	Px, 0xdb,(00),0xdb,(02) },
    { AFMOVLP,	yfmvp,	Px, 0xdb,(03) },
    { AFMOVV,	yfmvx,	Px, 0xdf,(05) },
    { AFMOVVP,	yfmvp,	Px, 0xdf,(07) },
    { AFMOVW,	yfmvf,	Px, 0xdf,(00),0xdf,(02) },
    { AFMOVWP,	yfmvp,	Px, 0xdf,(03) },
    { AFMOVX,	yfmvx,	Px, 0xdb,(05) },
    { AFMOVXP,	yfmvp,	Px, 0xdb,(07) },

    { AFCOMB },
    { AFCOMBP },
    { AFCOMD,	yfadd,	Px, 0xdc,(02),0xd8,(02),0xdc,(02) },	/* botch */
    { AFCOMDP,	yfadd,	Px, 0xdc,(03),0xd8,(03),0xdc,(03) },	/* botch */
    { AFCOMDPP,	ycompp,	Px, 0xde,(03) },
    { AFCOMF,	yfmvx,	Px, 0xd8,(02) },
    { AFCOMFP,	yfmvx,	Px, 0xd8,(03) },
    { AFCOML,	yfmvx,	Px, 0xda,(02) },
    { AFCOMLP,	yfmvx,	Px, 0xda,(03) },
    { AFCOMW,	yfmvx,	Px, 0xde,(02) },
    { AFCOMWP,	yfmvx,	Px, 0xde,(03) },

    { AFUCOM,	ycompp,	Px, 0xdd,(04) },
    { AFUCOMP,	ycompp, Px, 0xdd,(05) },
    { AFUCOMPP,	ycompp,	Px, 0xda,(13) },

    { AFADDDP,	yfaddp,	Px, 0xde,(00) },
    { AFADDW,	yfmvx,	Px, 0xde,(00) },
    { AFADDL,	yfmvx,	Px, 0xda,(00) },
    { AFADDF,	yfmvx,	Px, 0xd8,(00) },
    { AFADDD,	yfadd,	Px, 0xdc,(00),0xd8,(00),0xdc,(00) },

    { AFMULDP,	yfaddp,	Px, 0xde,(01) },
    { AFMULW,	yfmvx,	Px, 0xde,(01) },
    { AFMULL,	yfmvx,	Px, 0xda,(01) },
    { AFMULF,	yfmvx,	Px, 0xd8,(01) },
    { AFMULD,	yfadd,	Px, 0xdc,(01),0xd8,(01),0xdc,(01) },

    { AFSUBDP,	yfaddp,	Px, 0xde,(05) },
    { AFSUBW,	yfmvx,	Px, 0xde,(04) },
    { AFSUBL,	yfmvx,	Px, 0xda,(04) },
    { AFSUBF,	yfmvx,	Px, 0xd8,(04) },
    { AFSUBD,	yfadd,	Px, 0xdc,(04),0xd8,(04),0xdc,(05) },

    { AFSUBRDP,	yfaddp,	Px, 0xde,(04) },
    { AFSUBRW,	yfmvx,	Px, 0xde,(05) },
    { AFSUBRL,	yfmvx,	Px, 0xda,(05) },
    { AFSUBRF,	yfmvx,	Px, 0xd8,(05) },
    { AFSUBRD,	yfadd,	Px, 0xdc,(05),0xd8,(05),0xdc,(04) },

    { AFDIVDP,	yfaddp,	Px, 0xde,(07) },
    { AFDIVW,	yfmvx,	Px, 0xde,(06) },
    { AFDIVL,	yfmvx,	Px, 0xda,(06) },
    { AFDIVF,	yfmvx,	Px, 0xd8,(06) },
    { AFDIVD,	yfadd,	Px, 0xdc,(06),0xd8,(06),0xdc,(07) },

    { AFDIVRDP,	yfaddp,	Px, 0xde,(06) },
    { AFDIVRW,	yfmvx,	Px, 0xde,(07) },
    { AFDIVRL,	yfmvx,	Px, 0xda,(07) },
    { AFDIVRF,	yfmvx,	Px, 0xd8,(07) },
    { AFDIVRD,	yfadd,	Px, 0xdc,(07),0xd8,(07),0xdc,(06) },

    { AFXCHD,	yfxch,	Px, 0xd9,(01),0xd9,(01) },
    { AFFREE },
    { AFLDCW,	ystcw,	Px, 0xd9,(05),0xd9,(05) },
    { AFLDENV,	ystcw,	Px, 0xd9,(04),0xd9,(04) },
    { AFRSTOR,	ysvrs,	Px, 0xdd,(04),0xdd,(04) },
    { AFSAVE,	ysvrs,	Px, 0xdd,(06),0xdd,(06) },
    { AFSTCW,	ystcw,	Px, 0xd9,(07),0xd9,(07) },
    { AFSTENV,	ystcw,	Px, 0xd9,(06),0xd9,(06) },
    { AFSTSW,	ystsw,	Px, 0xdd,(07),0xdf,0xe0 },
    { AF2XM1,	ynone,	Px, 0xd9, 0xf0 },
    { AFABS,	ynone,	Px, 0xd9, 0xe1 },
    { AFCHS,	ynone,	Px, 0xd9, 0xe0 },
    { AFCLEX,	ynone,	Px, 0xdb, 0xe2 },
    { AFCOS,	ynone,	Px, 0xd9, 0xff },
    { AFDECSTP,	ynone,	Px, 0xd9, 0xf6 },
    { AFINCSTP,	ynone,	Px, 0xd9, 0xf7 },
    { AFINIT,	ynone,	Px, 0xdb, 0xe3 },
    { AFLD1,	ynone,	Px, 0xd9, 0xe8 },
    { AFLDL2E,	ynone,	Px, 0xd9, 0xea },
    { AFLDL2T,	ynone,	Px, 0xd9, 0xe9 },
    { AFLDLG2,	ynone,	Px, 0xd9, 0xec },
    { AFLDLN2,	ynone,	Px, 0xd9, 0xed },
    { AFLDPI,	ynone,	Px, 0xd9, 0xeb },
    { AFLDZ,	ynone,	Px, 0xd9, 0xee },
    { AFNOP,	ynone,	Px, 0xd9, 0xd0 },
    { AFPATAN,	ynone,	Px, 0xd9, 0xf3 },
    { AFPREM,	ynone,	Px, 0xd9, 0xf8 },
    { AFPREM1,	ynone,	Px, 0xd9, 0xf5 },
    { AFPTAN,	ynone,	Px, 0xd9, 0xf2 },
    { AFRNDINT,	ynone,	Px, 0xd9, 0xfc },
    { AFSCALE,	ynone,	Px, 0xd9, 0xfd },
    { AFSIN,	ynone,	Px, 0xd9, 0xfe },
    { AFSINCOS,	ynone,	Px, 0xd9, 0xfb },
    { AFSQRT,	ynone,	Px, 0xd9, 0xfa },
    { AFTST,	ynone,	Px, 0xd9, 0xe4 },
    { AFXAM,	ynone,	Px, 0xd9, 0xe5 },
    { AFXTRACT,	ynone,	Px, 0xd9, 0xf4 },
    { AFYL2X,	ynone,	Px, 0xd9, 0xf1 },
    { AFYL2XP1,	ynone,	Px, 0xd9, 0xf9 },
    { AEND },
    0
};
@



<<enum yxxx>>=
enum yxxx {
    Yxxx		= 0,
    Ynone,
    Yi0,
    Yi1,
    Yi8,
    Yi32,

    Yiauto,

    Yal,
    Ycl,
    Yax,
    Ycx,
    Yrb,
    Yrl,
    Yrf,
    Yf0,
    Yrx,
    Ymb,
    Yml,
    Ym,
    Ybr,
    Ycol,

    Ycs,	Yss,	Yds,	Yes,	Yfs,	Ygs,
    Ygdtr,	Yidtr,	Yldtr,	Ymsw,	Ytask,
    Ycr0,	Ycr1,	Ycr2,	Ycr3,	Ycr4,	Ycr5,	Ycr6,	Ycr7,
    Ydr0,	Ydr1,	Ydr2,	Ydr3,	Ydr4,	Ydr5,	Ydr6,	Ydr7,
    Ytr0,	Ytr1,	Ytr2,	Ytr3,	Ytr4,	Ytr5,	Ytr6,	Ytr7,

    Ymax,
};
@


<<enum zxxx>>=
enum zxxx {
    Zxxx		= 0,

    Zlit,
    Z_rp,
    Zbr,
    Zcall,
    Zib_,
    Zib_rp,
    Zibo_m,
    Zil_,
    Zil_rp,
    Zilo_m,
    Zjmp,
    Zloop,
    Zm_o,
    Zm_r,
    Zaut_r,
    Zo_m,
    Zpseudo,
    Zr_m,
    Zrp_,
    Z_ib,
    Z_il,
    Zm_ibo,
    Zm_ilo,
    Zib_rr,
    Zil_rr,
    Zclr,
    Zbyte,
    Zmov,
    Zmax,
};
@


<<global ynone>>=
byte	ynone[] =
{
    Ynone,	Ynone,	Zlit,	1,
    0
};
@

<<global ytext>>=
byte	ytext[] =
{
    Ymb,	Yi32,	Zpseudo,1,
    0
};
@

<<global ynop>>=
byte	ynop[] =
{
    Ynone,	Ynone,	Zpseudo,1,
    Ynone,	Yml,	Zpseudo,1,
    Ynone,	Yrf,	Zpseudo,1,
    Yml,	Ynone,	Zpseudo,1,
    Yrf,	Ynone,	Zpseudo,1,
    0
};
@

<<global yxorb>>=
byte	yxorb[] =
{
    Yi32,	Yal,	Zib_,	1,
    Yi32,	Ymb,	Zibo_m,	2,
    Yrb,	Ymb,	Zr_m,	1,
    Ymb,	Yrb,	Zm_r,	1,
    0
};
@

<<global yxorl>>=
byte	yxorl[] =
{
    Yi8,	Yml,	Zibo_m,	2,
    Yi32,	Yax,	Zil_,	1,
    Yi32,	Yml,	Zilo_m,	2,
    Yrl,	Yml,	Zr_m,	1,
    Yml,	Yrl,	Zm_r,	1,
    0
};
@

<<global yaddl>>=
byte	yaddl[] =
{
    Yi8,	Yml,	Zibo_m,	2,
    Yi32,	Yax,	Zil_,	1,
    Yi32,	Yml,	Zilo_m,	2,
    Yrl,	Yml,	Zr_m,	1,
    Yml,	Yrl,	Zm_r,	1,
    0
};
@

<<global yincb>>=
byte	yincb[] =
{
    Ynone,	Ymb,	Zo_m,	2,
    0
};
@

<<global yincl>>=
byte	yincl[] =
{
    Ynone,	Yrl,	Z_rp,	1,
    Ynone,	Yml,	Zo_m,	2,
    0
};
@

<<global ycmpb>>=
byte	ycmpb[] =
{
    Yal,	Yi32,	Z_ib,	1,
    Ymb,	Yi32,	Zm_ibo,	2,
    Ymb,	Yrb,	Zm_r,	1,
    Yrb,	Ymb,	Zr_m,	1,
    0
};
@

<<global ycmpl>>=
byte	ycmpl[] =
{
    Yml,	Yi8,	Zm_ibo,	2,
    Yax,	Yi32,	Z_il,	1,
    Yml,	Yi32,	Zm_ilo,	2,
    Yml,	Yrl,	Zm_r,	1,
    Yrl,	Yml,	Zr_m,	1,
    0
};
@

<<global yshb>>=
byte	yshb[] =
{
    Yi1,	Ymb,	Zo_m,	2,
    Yi32,	Ymb,	Zibo_m,	2,
    Ycx,	Ymb,	Zo_m,	2,
    0
};
@

<<global yshl>>=
byte	yshl[] =
{
    Yi1,	Yml,	Zo_m,	2,
    Yi32,	Yml,	Zibo_m,	2,
    Ycl,	Yml,	Zo_m,	2,
    Ycx,	Yml,	Zo_m,	2,
    0
};
@

<<global ytestb>>=
byte	ytestb[] =
{
    Yi32,	Yal,	Zib_,	1,
    Yi32,	Ymb,	Zibo_m,	2,
    Yrb,	Ymb,	Zr_m,	1,
    Ymb,	Yrb,	Zm_r,	1,
    0
};
@

<<global ytestl>>=
byte	ytestl[] =
{
    Yi32,	Yax,	Zil_,	1,
    Yi32,	Yml,	Zilo_m,	2,
    Yrl,	Yml,	Zr_m,	1,
    Yml,	Yrl,	Zm_r,	1,
    0
};
@

<<global ymovb>>=
byte	ymovb[] =
{
    Yrb,	Ymb,	Zr_m,	1,
    Ymb,	Yrb,	Zm_r,	1,
    Yi32,	Yrb,	Zib_rp,	1,
    Yi32,	Ymb,	Zibo_m,	2,
    0
};
@

<<global ymovl>>=
byte	ymovl[] =
{
    Yrl,	Yml,	Zr_m,	1,
    Yml,	Yrl,	Zm_r,	1,
    Yi0,	Yrl,	Zclr,	1+2,
//	Yi0,	Yml,	Zibo_m,	2,	// shorter but slower AND $0,dst
    Yi32,	Yrl,	Zil_rp,	1,
    Yi32,	Yml,	Zilo_m,	2,
    Yiauto,	Yrl,	Zaut_r,	2,
    0
};
@
%$

<<global ym_rl>>=
byte	ym_rl[] =
{
    Ym,	Yrl,	Zm_r,	1,
    0
};
@

<<global yrl_m>>=
byte	yrl_m[] =
{
    Yrl,	Ym,	Zr_m,	1,
    0
};
@

<<global ymb_rl>>=
byte	ymb_rl[] =
{
    Ymb,	Yrl,	Zm_r,	1,
    0
};
@

<<global yml_rl>>=
byte	yml_rl[] =
{
    Yml,	Yrl,	Zm_r,	1,
    0
};
@

<<global yrl_ml>>=
byte	yrl_ml[] =
{
    Yrl,	Yml,	Zr_m,	1,
    0
};
@

<<global yml_mb>>=
byte	yml_mb[] =
{
    Yrb,	Ymb,	Zr_m,	1,
    Ymb,	Yrb,	Zm_r,	1,
    0
};
@

<<global yml_ml>>=
byte	yml_ml[] =
{
    Yrl,	Yml,	Zr_m,	1,
    Yml,	Yrl,	Zm_r,	1,
    0
};
@

<<global ydivl>>=
byte	ydivl[] =
{
    Yml,	Ynone,	Zm_o,	2,
    0
};
@

<<global ydivb>>=
byte	ydivb[] =
{
    Ymb,	Ynone,	Zm_o,	2,
    0
};
@

<<global yimul>>=
byte	yimul[] =
{
    Yml,	Ynone,	Zm_o,	2,
    Yi8,	Yrl,	Zib_rr,	1,
    Yi32,	Yrl,	Zil_rr,	1,
    0
};
@

<<global ybyte>>=
byte	ybyte[] =
{
    Yi32,	Ynone,	Zbyte,	1,
    0
};
@

<<global yin>>=
byte	yin[] =
{
    Yi32,	Ynone,	Zib_,	1,
    Ynone,	Ynone,	Zlit,	1,
    0
};
@

<<global yint>>=
byte	yint[] =
{
    Yi32,	Ynone,	Zib_,	1,
    0
};
@

<<global ypushl>>=
byte	ypushl[] =
{
    Yrl,	Ynone,	Zrp_,	1,
    Ym,	Ynone,	Zm_o,	2,
    Yi8,	Ynone,	Zib_,	1,
    Yi32,	Ynone,	Zil_,	1,
    0
};
@

<<global ypopl>>=
byte	ypopl[] =
{
    Ynone,	Yrl,	Z_rp,	1,
    Ynone,	Ym,	Zo_m,	2,
    0
};
@

<<global yscond>>=
byte	yscond[] =
{
    Ynone,	Ymb,	Zo_m,	2,
    0
};
@

<<global yjcond>>=
byte	yjcond[] =
{
    Ynone,	Ybr,	Zbr,	1,
    0
};
@

<<global yloop>>=
byte	yloop[] =
{
    Ynone,	Ybr,	Zloop,	1,
    0
};
@

<<global ycall>>=
byte	ycall[] =
{
    Ynone,	Yml,	Zo_m,	2,
    Ynone,	Ybr,	Zcall,	1,
    0
};
@

<<global yjmp>>=
byte	yjmp[] =
{
    Ynone,	Yml,	Zo_m,	2,
    Ynone,	Ybr,	Zjmp,	1,
    0
};
@

<<global yfmvd>>=
byte	yfmvd[] =
{
    Ym,	Yf0,	Zm_o,	2,
    Yf0,	Ym,	Zo_m,	2,
    Yrf,	Yf0,	Zm_o,	2,
    Yf0,	Yrf,	Zo_m,	2,
    0
};
@

<<global yfmvdp>>=
byte	yfmvdp[] =
{
    Yf0,	Ym,	Zo_m,	2,
    Yf0,	Yrf,	Zo_m,	2,
    0
};
@

<<global yfmvf>>=
byte	yfmvf[] =
{
    Ym,	Yf0,	Zm_o,	2,
    Yf0,	Ym,	Zo_m,	2,
    0
};
@

<<global yfmvx>>=
byte	yfmvx[] =
{
    Ym,	Yf0,	Zm_o,	2,
    0
};
@

<<global yfmvp>>=
byte	yfmvp[] =
{
    Yf0,	Ym,	Zo_m,	2,
    0
};
@

<<global yfadd>>=
byte	yfadd[] =
{
    Ym,	Yf0,	Zm_o,	2,
    Yrf,	Yf0,	Zm_o,	2,
    Yf0,	Yrf,	Zo_m,	2,
    0
};
@

<<global yfaddp>>=
byte	yfaddp[] =
{
    Yf0,	Yrf,	Zo_m,	2,
    0
};
@

<<global yfxch>>=
byte	yfxch[] =
{
    Yf0,	Yrf,	Zo_m,	2,
    Yrf,	Yf0,	Zm_o,	2,
    0
};
@

<<global ycompp>>=
byte	ycompp[] =
{
    Yf0,	Yrf,	Zo_m,	2,	/* botch is really f0,f1 */
    0
};
@

<<global ystsw>>=
byte	ystsw[] =
{
    Ynone,	Ym,	Zo_m,	2,
    Ynone,	Yax,	Zlit,	1,
    0
};
@

<<global ystcw>>=
byte	ystcw[] =
{
    Ynone,	Ym,	Zo_m,	2,
    Ym,	Ynone,	Zm_o,	2,
    0
};
@

<<global ysvrs>>=
byte	ysvrs[] =
{
    Ynone,	Ym,	Zo_m,	2,
    Ym,	Ynone,	Zm_o,	2,
    0
};
@



\chapter{Elf}

<<enum _anon_ (linkers/8l/elf.h)>>=
enum {
    Ehdr32sz	= 52,
    Phdr32sz	= 32,
    Shdr32sz	= 40,

    Ehdr64sz	= 64,
    Phdr64sz	= 56,
    Shdr64sz	= 64,
};
@

\chapter{Profiling}
% surprising that part of ld job, but it is

% NOPROF of 8.out.h

\chapter{Advanced Topics}

\section{Float}

% 8.out.h

\chapter{Conclusion}

\appendix

\chapter{Debugging}

% -A, see diag()

<<global debug>>=
char	debug[128];
@


<<function listinit>>=
void
listinit(void)
{

    fmtinstall('A', Aconv);
    fmtinstall('R', Rconv);
    fmtinstall('D', Dconv);

    fmtinstall('S', Sconv);
    fmtinstall('P', Pconv);
}
@

% defined in ../8c/enam.c, coupling with enum as in 8.out.h
% extern	char*	anames[];

<<function Aconv>>=
// enum<as> -> string
int
Aconv(Fmt *fp)
{
    int i;

    i = va_arg(fp->args, int);
    return fmtstrcpy(fp, anames[i]);
}
@

<<global regstr>>=
// coupling with enum regs in 8.out.h
char*	regstr[] =
{
    "AL",		/* [D_AL] */
    "CL",
    "DL",
    "BL",
    "AH",
    "CH",
    "DH",
    "BH",

    "AX",		/* [D_AX] */
    "CX",
    "DX",
    "BX",
    "SP",
    "BP",
    "SI",
    "DI",

    "F0",		/* [D_F0] */
    "F1",
    "F2",
    "F3",
    "F4",
    "F5",
    "F6",
    "F7",

    "CS",		/* [D_CS] */
    "SS",
    "DS",
    "ES",
    "FS",
    "GS",

    "GDTR",		/* [D_GDTR] */
    "IDTR",		/* [D_IDTR] */
    "LDTR",		/* [D_LDTR] */
    "MSW",		/* [D_MSW] */
    "TASK",		/* [D_TASK] */

    "CR0",		/* [D_CR] */
    "CR1",
    "CR2",
    "CR3",
    "CR4",
    "CR5",
    "CR6",
    "CR7",

    "DR0",		/* [D_DR] */
    "DR1",
    "DR2",
    "DR3",
    "DR4",
    "DR5",
    "DR6",
    "DR7",

    "TR0",		/* [D_TR] */
    "TR1",
    "TR2",
    "TR3",
    "TR4",
    "TR5",
    "TR6",
    "TR7",

    "NONE",		/* [D_NONE] */
};
@

<<function Rconv>>=
// enum<register> -> string
int
Rconv(Fmt *fp)
{
    char str[20];
    int r;

    r = va_arg(fp->args, int);
    if(r >= D_AL && r <= D_NONE)
        snprint(str, sizeof(str), "%s", regstr[r-D_AL]);
    else
        snprint(str, sizeof(str), "gok(%d)", r);

    return fmtstrcpy(fp, str);
}
@


% used by PConv and Dconv as Dconv need access to enclosing Prog for branch
<<global bigP>>=
static	Prog	*bigP;
@

<<function Pconv>>=
// Proc -> string
int
Pconv(Fmt *fp)
{
    char str[STRINGSZ];
    Prog *p;

    p = va_arg(fp->args, Prog*);
    bigP = p;
    switch(p->as) {
    case ATEXT:
        if(p->from.scale) {
            snprint(str, sizeof(str), "(%ld)	%A	%D,%d,%D",
                p->line, p->as, &p->from, p->from.scale, &p->to);
            break;
        }
    default:
        snprint(str, sizeof(str), "(%ld)	%A	%D,%D",
            p->line, p->as, &p->from, &p->to);
        break;
    case ADATA:
    case AINIT:
    case ADYNT:
        snprint(str, sizeof(str), "(%ld)	%A	%D/%d,%D",
            p->line, p->as, &p->from, p->from.scale, &p->to);
        break;
    }
    bigP = P;
    return fmtstrcpy(fp, str);
}
@


<<function Dconv>>=
// enum<dxxx> -> string
int
Dconv(Fmt *fp)
{
    char str[STRINGSZ+40], s[20];
    Adr *a;
    int i;

    a = va_arg(fp->args, Adr*);
    i = a->type;
    if(i >= D_INDIR) {
        if(a->offset)
            snprint(str, sizeof(str), "%ld(%R)", a->offset, i-D_INDIR);
        else
            snprint(str, sizeof(str), "(%R)", i-D_INDIR);
        goto brk;
    }
    switch(i) {

    default:
        snprint(str, sizeof(str), "%R", i);
        break;

    case D_NONE:
        str[0] = 0;
        break;

    case D_BRANCH:
        if(bigP != P && bigP->pcond != P)
            if(a->sym != S)
                snprint(str, sizeof(str), "%lux+%s", bigP->pcond->pc,
                    a->sym->name);
            else
                snprint(str, sizeof(str), "%lux", bigP->pcond->pc);
        else
            snprint(str, sizeof(str), "%ld(PC)", a->offset);
        break;

    case D_EXTERN:
        snprint(str, sizeof(str), "%s+%ld(SB)", a->sym->name, a->offset);
        break;

    case D_STATIC:
        snprint(str, sizeof(str), "%s<%d>+%ld(SB)", a->sym->name,
            a->sym->version, a->offset);
        break;

    case D_AUTO:
        snprint(str, sizeof(str), "%s+%ld(SP)", a->sym->name, a->offset);
        break;

    case D_PARAM:
        if(a->sym)
            snprint(str, sizeof(str), "%s+%ld(FP)", a->sym->name, a->offset);
        else
            snprint(str, sizeof(str), "%ld(FP)", a->offset);
        break;

    case D_CONST:
        snprint(str, sizeof(str), "$%ld", a->offset);
        break;

    case D_FCONST:
        snprint(str, sizeof(str), "$(%.8lux,%.8lux)", a->ieee.h, a->ieee.l);
        break;

    case D_SCONST:
        snprint(str, sizeof(str), "$\"%S\"", a->scon);
        break;

    case D_ADDR:
        a->type = a->index;
        a->index = D_NONE;
        snprint(str, sizeof(str), "$%D", a);
        a->index = a->type;
        a->type = D_ADDR;
        goto conv;
    }
brk:
    if(a->index != D_NONE) {
        snprint(s, sizeof(s), "(%R*%d)", a->index, a->scale);
        strcat(str, s);
    }
conv:
    return fmtstrcpy(fp, str);
}
@



<<function Sconv>>=
// ??symbol? -> string
int
Sconv(Fmt *fp)
{
    int i, c;
    char str[30], *p, *a;

    a = va_arg(fp->args, char*);
    p = str;
    for(i=0; i<sizeof(double); i++) {
        c = a[i] & 0xff;
        if(c >= 'a' && c <= 'z' ||
           c >= 'A' && c <= 'Z' ||
           c >= '0' && c <= '9') {
            *p++ = c;
            continue;
        }
        *p++ = '\\';
        switch(c) {
        default:
            if(c < 040 || c >= 0177)
                break;	/* not portable */
            p[-1] = c;
            continue;
        case 0:
            *p++ = 'z';
            continue;
        case '\\':
        case '"':
            *p++ = c;
            continue;
        case '\n':
            *p++ = 'n';
            continue;
        case '\t':
            *p++ = 't';
            continue;
        }
        *p++ = (c>>6) + '0';
        *p++ = ((c>>3) & 7) + '0';
        *p++ = (c & 7) + '0';
    }
    *p = 0;
    return fmtstrcpy(fp, str);
}
@




\chapter{Error Managment}

<<global nerrors>>=
int	nerrors;
@

<<function errorexit>>=
void
errorexit(void)
{

    if(nerrors) {
        if(cout >= 0)
            remove(outfile);
        exits("error");
    }
    exits(0);
}
@



<<function diag>>=
void
diag(char *fmt, ...)
{
    char buf[STRINGSZ];
    char *tn;
    va_list arg;

    tn = "??none??";
    if(curtext != P && curtext->from.sym != S)
        tn = curtext->from.sym->name;
    va_start(arg, fmt);
    vseprint(buf, buf+sizeof(buf), fmt, arg);
    va_end(arg);
    print("%s: %s\n", tn, buf);

    nerrors++;
    if(nerrors > 20 && !debug['A']) {
        print("too many errors\n");
        errorexit();
    }
}
@

\chapter{Libc}

\section{Memory managmnent}

<<global nhunk>>=
long	nhunk;
@

<<global hunk>>=
char*	hunk;
@

<<function malloc>>=
/*
 * fake malloc
 */
void*
malloc(ulong n)
{
    void *p;

    while(n & 7)
        n++;
    while(nhunk < n)
        gethunk();
    p = hunk;
    nhunk -= n;
    hunk += n;
    return p;
}
@

<<function free>>=
void
free(void *p)
{
    USED(p);
}
@

% not sure why but if redefine malloc and free then have to
% redefine this func too, otherwise get a link error
<<function setmalloctag>>=
//@Scheck: looks dead, but because we redefine malloc/free we must also redefine that
void setmalloctag(void *v, ulong pc)
{
    USED(v, pc);
}
@


<<constant NHUNK>>=
NHUNK		= 100000,
@

<<function gethunk>>=
void
gethunk(void)
{
    char *h;
    long nh;

    nh = NHUNK;
    if(thunk >= 5L*NHUNK) {
        nh = 5L*NHUNK;
        if(thunk >= 25L*NHUNK)
            nh = 25L*NHUNK;
    }
    h = sbrk(nh);
    if(h == (char*)-1) {
        diag("out of memory");
        errorexit();
    }
    hunk = h;
    nhunk = nh;
    thunk += nh;
}
@


<<constructor prg>>=
Prog*
prg(void)
{
    Prog *p;

    while(nhunk < sizeof(Prog))
        gethunk();
    p = (Prog*)hunk;
    nhunk -= sizeof(Prog);
    hunk += sizeof(Prog);

    *p = zprg;
    return p;
}
@

<<function copyp>>=
Prog*
copyp(Prog *q)
{
    Prog *p;

    p = prg();
    *p = *q;
    return p;
}
@


\section{Buffer managmnent}

<<struct Buf>>=
union Buf
{
    struct
    {
        char	obuf[MAXIO];			/* output buffer */
        uchar	ibuf[MAXIO];			/* input buffer */
    } u;
    char	dbuf[1];
};
@

<<constant cbuf>>=
#define	cbuf	u.obuf
@

<<constant xbuf>>=
#define	xbuf	u.ibuf
@

\section{File managment}

<<function fileexists>>=
int
fileexists(char *s)
{
    uchar dirbuf[400];

    /* it's fine if stat result doesn't fit in dirbuf, since even then the file exists */
    return stat(s, dirbuf, sizeof(dirbuf)) >= 0;
}
@


\chapter{Extra Code}

\ifallcode
#include "Linker_extra.tex.nw"
\fi

\chapter{Changelog}
\label{sec:changelog}

\chapter{Glossary}
\label{sec:glossary}

\begin{verbatim}
\end{verbatim}

\chapter*{Indexes}
\addcontentsline{toc}{section}{Index}

%\chapter{References} 
\addcontentsline{toc}{section}{References}

\begin{thebibliography}{99}

\bibitem[1]{wp-literate-programming} Donald Knuth,,
{\em Literate Programming}, 
\url{http://en.wikipedia.org/wiki/Literate\_Program}

\bibitem[2]{noweb} Norman Ramsey,
{\em Noweb}, 
\url{http://www.cs.tufts.edu/~nr/noweb/}

\bibitem[3]{syncweb} Yoann Padioleau,
{\em Syncweb, literate programming meets unison}, 
\url{http://padator.org/software/project-syncweb/readme.txt}

\end{thebibliography}

%******************************************************************************
% Postlude
%******************************************************************************

\end{document}
