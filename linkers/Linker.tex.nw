\documentclass[twocolumn]{report}

%******************************************************************************
% Prelude
%******************************************************************************
\newif\iffinal
\newif\ifverbose
\finaltrue\verbosefalse
% see also other newif in Macros.tex

%------------------------------------------------------------------------------
%history: 
%------------------------------------------------------------------------------

%thx to LP, changed for the better a few things:

%thx to codemap/codegraph:
% - see subtle dependency to 8c/enam.c through anames

%thx to this manual, better understand ld?:
% - fpic? dynamic linking?

%history LP-ization:
% - skeleton, mostly copy paste of Kernel.tex.nw skeleton
% - put all content of files in the Extra section, via 'pfff -lpize'
%   which also now split in chunks!
%    * function, global, struct, enum, constant, macro(actually function)
% - read Extra section, identify concepts, first TOC
% - distribute parts of the file before
% - understand main(), LP split main, improve TOC
% - understand main functions, LP split, cluster, improve TOC
% - TODO LP split the structures, use datalog for flow to field info
% - TODO nullify, boolify, typeify,    scheckify
% - TODO aspecify advanced features!
% - TODO add figures
% - TODO add explanations

%------------------------------------------------------------------------------
% Packages
%------------------------------------------------------------------------------

\usepackage{../docs/latex/noweb}
 \noweboptions{footnotesizecode,nomargintag}
 %note: allow chunk on different pages, less white space at bottom of pages
 \def\nwendcode{\endtrivlist \endgroup}
 \let\nwdocspar=\par
\usepackage{xspace}
\usepackage{verbatim}
%note: required by noweblatexpad for the \t \l \n in this file
\usepackage{fancyvrb}
\usepackage{url}
\iffinal
\usepackage{hyperref}
 \hypersetup{colorlinks=true}
\fi
\usepackage[pageref]{backref}
 \def\backref{{\footnotesize cited page(s)}~}
% not in basicTex
%\usepackage{cleveref} %\cref
% not in basicTex, for multirow TOC!
%\usepackage{multirow}
\usepackage{booktabs} 
 \newcommand{\otoprule}{\midrule[\heavyrulewidth]}
\usepackage{graphicx}
 %\usepackage[margin=0.5in]{geometry}
 %  but eat the bottom when very low
 %\usepackage{fullpage} is deprecated 
 % => do the more manual below:
 \addtolength{\oddsidemargin}{-.850in}
 \addtolength{\evensidemargin}{-.850in}
 \addtolength{\textwidth}{1.70in}
 \addtolength{\topmargin}{-.850in}
 \addtolength{\textheight}{1.70in}
%\usepackage{minitoc}

%------------------------------------------------------------------------------
% Macros
%------------------------------------------------------------------------------
\input{../docs/latex/Macros}

%------------------------------------------------------------------------------
% Config
%------------------------------------------------------------------------------
\allcodefalse
% used for forward decl, pragmas, func decl, extern decl, stats, #ifdef,
% debugging macros

%\setcounter{tocdepth}{1}

%******************************************************************************
% Title
%******************************************************************************

\begin{document}

\title{
{\Huge 
Plan9 Linker
% and Loader?
}\\
x86 (32 bits) edition\\
{version 0.1}
}

\author{
Yoann Padioleau\\
\texttt{yoann.padioleau@gmail.com}
}

\maketitle 
\onecolumn
\hrule
\begin{quote}
    Copyright \copyright{} 2014 Yoann Padioleau \\
    Permission is granted to copy, distribute and/or modify this document,
    except all the source code it contains, under the terms of the GNU Free
    Documentation License, Version 1.3.
\end{quote}
\hrule

%CONFIG: \dominitoc

\iffinal
\begingroup
\hypersetup{linkcolor=blue}
% need to s/onecolumn/twocolumn in report.cls :) for \tableofcontents
\twocolumn
\tableofcontents
\endgroup
\else
\tableofcontents
\fi

%******************************************************************************
% Body
%******************************************************************************

\chapter{Introduction}

\section{Motivations}

The goal of this book is to present in full details the source code of
a linker.
Why? Because I think it makes you a better programmer if
you fully understand how things work under the hood.

Here are other candidates that were considered but ultimately discarded:
\begin{itemize}
\item GNU ld and the BFD library
\item Gold
\end{itemize}
% Linker and Loader book, introduce his own ld?

%http://eli.thegreenplace.net/2012/08/13/how-statically-linked-programs-run-on-linux/

\section{Getting started}

\section{Requirements}

\section{About this document}
#include "../docs/latex/About.tex.nw"

\section{Copyright}

Most of this document is actually source code from Plan9, so
those parts are copyright by Lucent Technologies Inc.
The prose is mine and is licensed under the GNU Free Documentation
License.

\section{Acknowledgments}


\chapter{Overview}

\section{Linker principles}
% and loader? why the use the term loader instead of linker?
% maybe because load the objects and libs and then link them
% (but first it "loads" them)

% principle: link together object files. Resolve external symbols.
% compute textsize, datasize, etc and adjust addresses.
% (actually for plan9 the linker is also generating the
% ISA binary code (what was usually done by the assembler)).

% what about dynamic linking? see Advanced topics chapter.

\section{[[8l]] services}

% command line interface? -o

% important -TText, see Kernel.tex.nw

<<function usage (linkers/8l/obj.c)>>=
void
usage(void)
{
    diag("usage: %s [-options] objects", argv0);
    errorexit();
}
@

% env: $ccroot

\section{Example}
% show binary format? hexdump?

% see tests/ with two .c calling each other

\section{Input object format}
% the input this time (as opposed to 8a where it's the output)

% nm foo.8 => ? U? D? T?

% nm is actually using libmach, crachhdr, etc, generic API for object manip

% put libmach/8obj.c?

\section{Output executable format}
% the output,

%http://jvns.ca/blog/2014/09/06/how-to-read-an-executable/

% plan9 is essential a.out.h? 
% but can actually generate different executable (well different headers)

<<enum headtype>>=
/*
 *	-H0 -T0x40004C -D0x10000000	is garbage unix
 *	-H1 -T0xd0 -R4			is unix coff
 *	-H2 -T4128 -R4096		is plan9 format
 *	-H3 -Tx -Rx			is MS-DOS .COM
 *	-H4 -Tx -Rx			is fake MS-DOS .EXE
 *	-H5 -T0x80100020 -R4096		is ELF
 */
enum headtype {
    H_GARBAGE = 0,
    H_COFF = 1,
    H_PLAN9 = 2, // default
    H_COM = 3,
    H_EXE = 4,
    H_ELF = 5,
};
@
% was not in the original code, but so much better than having
% some switch() { case 3: ... }

% see libmach to read back this executable!

% so   .s -8a-> .o -8l-> .exe -libmach-> readable
% (hmm libmach is also reading .o (.8)


% include/a.out.h
% used by strip, libmach, but not 8l, should be 32 bytes (0x20)
% see asmb() that generate this far below
<<struct Exec>>=
// a.out header format
struct	Exec
{
    long	magic;		/* magic number */

    long	text;	 	/* size of text segment */
    long	data;	 	/* size of initialized data */
    long	bss;	  	/* size of uninitialized data */

    long	syms;	 	/* size of symbol table */

    // virtual address in [UTZERO+sizeof(Exec)..UTZERO+sizeof(Exec)+text]
    long	entry;	 	/* entry point */ 

    // used only by 68020, spsize set to 0 for 8l TODO remove at some point!
    long	spsz;		/* size of pc/sp offset table */
    // see a.out.h man page explaining how to compute the line of a PC
    long	pcsz;		/* size of pc/line number table */
};
@


% entry: it's actually usually not main but _main (or _mainp) that does
% some core initialization and then call main

\section{Code organization}

\section{Architecture overview}

% depends on 8.out.h all assembly instructions, registers, etc
% depends on 8c/ for one file:
%8c -FTVw -I/home/pad/plan9/include/386 -I/home/pad/plan9/include -. -I. ../8c/enam.c

% linker vs libmach, 
% actually linker does not depend on libmach/! because it's writing specific stuff
% and libmach is mostly about generic reading interface to many specifics
% (and not just 8l)


%###############################################################################

\chapter{Core Data Structures}

\section{[[Sym]] and [[hash]]}

% linker is all about resolving undefined symbols, and link to the right place
% so symbols are pretty central!

% conflict with include/a.out.h
<<struct Sym>>=
struct	Sym
{
    char	*name;
    short	version; // for static names, each sym has a different version

    //enum<section> ?
    short	type;

    // enum<section> too?
    byte	subtype;

    long	sig;
    long	value; // e.g. pc for a TEXT procedure

    // [[Sym]] other fields
    short	become;
    short	frame;
    ushort	file;

    // Extra

    // hash<Sym.name * Sym.version, ref<Sym>> of hash
    Sym*	link;
};
@


<<constant S>>=
#define	S		((Sym*)nil)
@


% SSTACK? not in exec :) not sure it's section, it's more about
%  type of symbol/entity, a const, file, data, procedure, etc
% see asmsym()
<<enum sxxx>>=
enum section
{
    STEXT		= 1,
    SDATA,
    SBSS,

    SDATA1,
    SXREF, // means not defined (yet)
    SFILE,
    SCONST,
    SUNDEF,

    SIMPORT,
    SEXPORT,
};
@


<<constant NHASH 8l.h>>=
NHASH		= 10007,
@

<<global hash (linkers/8l/globals.c)>>=
// hash<Sym.name * Sym.version, ref<Sym>> (next = Sym.link)
Sym*	hash[NHASH];
@

<<global nsymbol>>=
long	nsymbol;
@

% v is for version, but really it's about handling static names
% (we could have a typedef int version;? and VERSION0 = 0 so clearer to read?)
<<function lookup>>=
Sym*
lookup(char *symb, int v)
{
    Sym *s;
    char *p;
    long h;
    int l, c;

    // h = hash(symb, v)
    h = v;
    for(p=symb; c = *p; p++)
        h = h+h+h + c;
    l = (p - symb) + 1;
    h &= 0xffffff;
    h %= NHASH;
    
    // s = lookup(h, hash)
    for(s = hash[h]; s != S; s = s->link)
        if(s->version == v)
            if(memcmp(s->name, symb, l) == 0)
                return s;


    // s =~ malloc(sizeof(Sym)), TODO factorize this code
    while(nhunk < sizeof(Sym))
        gethunk();
    s = (Sym*)hunk;
    nhunk -= sizeof(Sym);
    hunk += sizeof(Sym);

    s->name = malloc(l + 1); // +1 again?
    memmove(s->name, symb, l);

    s->link = hash[h];
    s->type = 0;
    s->version = v;
    s->value = 0;
    s->sig = 0;
    hash[h] = s;
    nsymbol++;
    return s;
}
@


\section{[[Opcode]] and [[Operand_kind]]}
% in 8.out.h: Opcode (enum opcode), Operand_kind (enum operand_kind)
% see Aconv, Rconv, Dconv

% put major opcode here, AXXX, ALAST, etc
% and also D_CS, ... and also D_EXTERN,

\section{[[Prog]] and [[firstp]], [[textp]], [[datap]], [[curtext]], etc}

% bad name .... I think Prog is really a Instruction ... From and To
% are when do MOV AX, BX,    then AX is the from, BX the to

<<struct Prog>>=
struct	Prog
{
    //enum<opcode>
    short	as;

    // operands
    Adr	from;
    Adr	to;

    // [[Prog]] other fields
    // 2 by default in zprg, why?
    byte	back;

    Prog*	forwd;
    long	pc;
    long	line;
    char	width;		/* fake for DATA */
    char	ft;		/* oclass cache */
    char	tt;
    byte	mark;	/* work on these */

    // [[Prog]] Extra fields

    // list<ref<Prog>> from firstp/lastp, or datap/edatap
    Prog*	link;

    // list<ref<Prog>> from textp/etextp, to follow CALL xxx
    Prog*	pcond;	/* work on this */

};
@
% see Pconv, %P


% list of instructions (ATEXT and its instrs, but not ADATA, AGLOBL, ...)
% good name? first_instr better? also again there is strong
% coupling between firstp and lastp that should be encapsulated
% in a specific structure (like for datap, edatap)
<<global firstp>>=
// list<ref_own?<Prog>>, next = Prog.link
Prog*	firstp;
@

<<global lastp>>=
// ref<Prog>, last elt of firstp list
Prog*	lastp;
@

<<constant P>>=
#define	P		((Prog*)nil)
@



% list of procedures (ATEXT opcode), subset of firstp/lastp
<<global textp>>=
// list<ref<Prog>>, next = Prog.cond
Prog*	textp = P;
@

<<global etextp>>=
// ref<Prog>, end of textp list
Prog*	etextp = P;
@


% list of data (ADATA opcode)
<<global datap>>=
// list<ref<Prog>>, next = Prog.next
Prog*	datap = P;
@

% todo could use a queue data structure, so have fast access to end of list?
<<global edatap>>=
// ref<Prog>>, end of datap list
Prog*	edatap = P;
@




% When iterate over all instrs, if the instr is a ATEXT then store it here.
% It's probably for error message, to say in which procedure we currently are
% most of the code related to curtext is if(p->as == ATEXT) curtext = p;
<<global curtext>>=
Prog*	curtext;
@

<<constant TNAME>>=
#define	TNAME		(curtext ? curtext->from.sym->name : noname)
@

<<global noname (linkers/8l/obj.c)>>=
char	*noname		= "<none>";
@



<<global undefp>>=
//@Scheck: not dead, used by UP
Prog	undefp;
@

<<constant UP>>=
#define	UP	(&undefp)
@

\section{[[Adr]]}

% operand of instruction, e.g. in MOV AX, BX,  then AX is a form of Adr
% (would be better if had ADT so can have better Instruction type instead
% of those opcode, operand, Adr, and unions and all comments)

% give a few examples? show man page where have all the addressing modes

<<struct Adr>>=
struct	Adr
{
    //enum<operand_kind> (D_NONE by default)
    short	type;

    union
    {
        long	u0offset;
        char	u0scon[8];
        Prog	*u0cond;	/* not used, but should be D_BRANCH */
        Ieee	u0ieee;
    } u0;

    union
    {
        Auto*	u1autom;
        Sym*	u1sym;
    } u1;

    //enum<operand_kind(register-only|D_NONE)>
    byte	index;

    // TODO: abused for NOPROF function attributes
    char	scale; // offset * scale give size of entity?
};
@

% the main thing the linker does, to relocate at the right place
% offset can be based on PC (for D_BRANCH), SB(for D_STATIC, D_EXTERN),
% on FP(for D_PARAM), and on SP(for D_AUTO), 
% or can be direct value (for D_CONST)
see DConv
<<constant offset>>=
#define	offset	u0.u0offset
@

% TODO I thought could have unamed union that then alleviate the need
% for those macros! (just need to adapt graph_code_c to find those fields)

% ??
<<constant scon>>=
#define	scon	u0.u0scon
@

<<constant cond>>=
#define	cond	u0.u0cond
@

<<constant ieee>>=
#define	ieee	u0.u0ieee
@

<<constant autom>>=
#define	autom	u1.u1autom
@

<<constant sym>>=
#define	sym	u1.u1sym
@


% ???
<<struct Auto>>=
struct	Auto
{
    Sym*	asym;

    long	aoffset;
    short	type;

    // Extra
    Auto*	link;
};
@

\section{[[Optab]] and [[optab]]}

<<struct Optab>>=
struct	Optab
{
    // enum<as> from 8.out.h
    short	as;

    byte*	ytab;

    // enum<Pxxx>
    byte	prefix;
    // the actual x86 machine code for instruction optab.as
    byte	op[10];
};
@

\chapter{[[main()]]}

% default object suffix, to generate 8.out
<<global thechar>>=
char	thechar		= '8';
@

% to find library files? /386/lib/...
<<global thestring>>=
char	*thestring 	= "386";
@

% -o, 
<<global outfile>>=
char*	outfile = "8.out";
@

<<[[main()]] command line processing>>=
    case 'o': /* output to (next arg) */
        outfile = ARGF();
        break;
@

% cout =~ create(outfile)
<<global cout>>=
fdt	cout = -1;
@






<<function main (linkers/8l/obj.c)>>=
void
main(int argc, char *argv[])
{
    <<[[main()]] locals>>

    <<[[main()]] debug initialization>>

    ARGBEGIN {
    <<[[main()]] command line processing>>
    } ARGEND
    USED(argc);
    if(*argv == nil)
        usage();

    <<[[main()]] addlibpath("/386/lib") or ccroot>>

    <<[[main()]] adjust HEADTYPE if debug flags>>
    switch(HEADTYPE) {
    <<[[main()]] switch HEADTYPE cases>>
    default:
        diag("unknown -H option");
        errorexit();

    }
    <<[[main()]] last INITXXX adjustments>>

    DBG("HEADER = -H0x%ld -T0x%lux -D0x%lux -R0x%lux\n",
            HEADTYPE, INITTEXT, INITDAT, INITRND);

    <<[[main()]] sanity check optab>>
    <<[[main()]] initialize globals>>

    nuxiinit();

    cout = create(outfile, 1, 0775);
    if(cout < 0) {
        diag("cannot create %s: %r", outfile);
        errorexit();
    }

    // ------ main functions  ------
    <<[[main()]] cout is ready, LET'S GO>>

    <<[[main()]] profile report>>
    errorexit();
}
@
%$ 



% -H executable format (header type)
<<global HEADTYPE>>=
long	HEADTYPE = -1;
@

% -T text segment start virtual address (important! e.g. for kernel 0x7c00)
<<global INITTEXT>>=
long	INITTEXT = -1;
@

% -D data segment start
<<global INITDAT>>=
long	INITDAT = -1;
@

% -E default _main (or _mainp when -p)
<<global INITENTRY>>=
char*	INITENTRY = nil;		/* entry point */
@

% -R text segment rounder at r multiple
<<global INITRND>>=
long	INITRND = -1;
@


<<[[main()]] command line processing>>=
case 'H':
    a = ARGF();
    if(a)
        HEADTYPE = atolwhex(a);
    break;
case 'T':
    a = ARGF();
    if(a)
        INITTEXT = atolwhex(a);
    break;
case 'D':
    a = ARGF();
    if(a)
        INITDAT = atolwhex(a);
    break;
case 'E':
    a = ARGF();
    if(a)
        INITENTRY = a;
    break;
case 'R':
    a = ARGF();
    if(a)
        INITRND = atolwhex(a);
    break;
@




% size of Header, 32 for a.out (0x20)
<<global HEADR>>=
long	HEADR;
@

%32 = 0x20, hence this note in kernel mkfile:
%# see mem.h, the additional 20 are the size of the a.out header added by LD
%KTZERO_AND_HEADER=0xE0100020

<<[[main()]] switch HEADTYPE cases>>=
case H_PLAN9:	/* plan 9 */
    HEADR = 32L;
    if(INITTEXT == -1)
        INITTEXT = 4096+32;
    if(INITDAT == -1)
        INITDAT = 0;
    if(INITRND == -1)
        INITRND = 4096;
    break;
@

% less important I think
<<[[main()]] last INITXXX adjustments>>=
if (INITTEXTP == -1)
    INITTEXTP = INITTEXT;

if(INITDAT != 0 && INITRND != 0)
    print("warning: -D0x%lux is ignored because of -R0x%lux\n",
        INITDAT, INITRND);
@



\section{XXX}

% used locals? move closer the the code that use it then
<<[[main()]] locals>>=
    int i, c;
    char name[LIBNAMELEN];
    char *a;
@



<<[[main()]] initialize globals>>=
<<[[main()]] set ycover>>
<<[[main()]] set reg>>
<<[[main()]] set zprg>>
dtype = 4;

cbp = buf.cbuf;
cbc = sizeof(buf.cbuf);
@



\chapter{Main functions}


% essentially a malloc(sizeof(Prog), 
% see section on Buffer managment to better understand
<<constructor prg>>=
Prog*
prg(void)
{
    Prog *p;

    //todo: factorize with similar code in lookup but for Sym, 
    // =~ malloc(sizeof(Procg))
    while(nhunk < sizeof(Prog))
        gethunk();
    p = (Prog*)hunk;
    nhunk -= sizeof(Prog);
    hunk += sizeof(Prog);

    *p = zprg;
    return p;
}
@

% empty prg, to initialize new Prog
<<global zprg>>=
Prog	zprg;
@

%GOK? God Only Knows? to be used as a special mark, there is diag()
% in ldobj() about AGOK
<<[[main()]] set zprg>>=
zprg.link = P;
zprg.pcond = P;
zprg.back = 2;
zprg.as = AGOK;
zprg.from.type = D_NONE;
zprg.from.index = D_NONE;
zprg.from.scale = 1;
zprg.to = zprg.from;
@


<<function copyp>>=
Prog*
copyp(Prog *q)
{
    Prog *p;

    p = prg();
    *p = *q;
    return p;
}
@

<<[[main()]] locals>>=
bool load_libs = true;
@

% -l means no automagic stdlibs
<<[[main()]] initialize globals>>=
load_libs = !debug['l'];
@

% TODO: all those functions that take no args are ugly, they use too much
% globals, e.g. firstp, lastp, I should really rewrite the code
% to be more functional.

<<[[main()]] cout is ready, LET'S GO>>=
firstp = prg();
lastp = firstp;

<<[[main()]] set INITENTRY>>

while(*argv)
    objfile(*argv++);

if(load_libs)
    loadlib();

firstp = firstp->link;
if(firstp == P)
    errorexit();

<<[[main()]] if export table or dynamic module>>

patch();
follow();
dodata();
dostkoff();
<<[[main()]] call doprofxxx() if profiling>>
span();
doinit();

// write to cout, finally
asmb();

// sanity check
undef();
@

% when -l alone it means no startup lib
% why firstp = firstp->link? the first prog is a fake?
% and why ->link and not ->cond?


<<[[main()]] set INITENTRY>>=
if(INITENTRY == nil) {
    INITENTRY = "_main";
    <<[[main()]] adjust INITENTRY if profiling>>
    if(load_libs)
        lookup(INITENTRY, 0)->type = SXREF;
} else {
    <<[[main()]] if digit INITENTRY>>
}
@
% _main! not main, because _main is defined in libc and then call your main?
% SXREF means?

\section{Loading the objects, [[objfile()]]}

% essentially modify which globals?
%  - will modify libraryp probably, the cool pragma "autolib"
%    which is why objfile() must be called before loadlib()
%  - ??

<<function objfile>>=
void
objfile(char *file)
{
    fdt f;
    long l;
    char magbuf[SARMAG];
    <<[[objfile()]] other locals>>

    DBG("%5.2f ldobj: %s\n", cputime(), file);

    <<[[objfile()]] adjust file if -lxxx filename>>

    f = open(file, 0);
    if(f < 0) {
        diag("cannot open %s: %r", file);
        errorexit();
    }

    l = read(f, magbuf, SARMAG);

    // not a library
    if(l != SARMAG || strncmp(magbuf, ARMAG, SARMAG)){
        /* load it as a regular file */
        l = seek(f, 0L, SEEK__END);
        seek(f, 0L, SEEK__START);

        // the important call!
        ldobj(f, l, file);

        close(f);
        return;
    }

    <<[[objfile()]] when file is a library>>
}
@


%ldobj(), see later chapter

\section{Loading the libraries, [[loadlib()]]}
% it loads the libraries mentioned in the .obj via the .h and #pragma magic!
% see later section

<<global library>>=
char*	library[50];
@

<<global libraryp>>=
int	libraryp;
@


<<global libraryobj>>=
char*	libraryobj[50];
@


% ???
<<global xrefresolv>>=
bool	xrefresolv;
@

<<function loadlib>>=
void
loadlib(void)
{
    int i;
    long h;
    Sym *s;

loop:
    xrefresolv = false;
    for(i=0; i<libraryp; i++) {
        DBG("%5.2f autolib: %s (from %s)\n", cputime(), library[i], libraryobj[i]);
        objfile(library[i]);
    }
    if(xrefresolv)
        for(h=0; h<nelem(hash); h++)
             for(s = hash[h]; s != S; s = s->link)
                 if(s->type == SXREF)
                     goto loop;
}
@


\section{[[patch()]]}

<<function patch>>=
void
patch(void)
{
    long c;
    Prog *p, *q;
    Sym *s;
    long vexit;

    // could be moved out of patch() in main()?
    DBG("%5.2f mkfwd\n", cputime());
    mkfwd();

    DBG("%5.2f patch\n", cputime());
    s = lookup("exit", 0);
    vexit = s->value;
    for(p = firstp; p != P; p = p->link) {
        if(p->as == ATEXT)
            curtext = p;
        if(p->as == ACALL || p->as == ARET) {
            s = p->to.sym;
            if(s) {
                if(debug['c'])
                    Bprint(&bso, "%s calls %s\n", TNAME, s->name);

                switch(s->type) {
                case STEXT:
                    p->to.offset = s->value;
                    break;
                case SUNDEF:
                    p->pcond = UP;
                    p->to.offset = 0;
                    break;
                default:
                    /* diag prints TNAME first */
                    diag("undefined: %s", s->name);
                    s->type = STEXT;
                    s->value = vexit;
                    break;	/* or fall through to set offset? */
                }
                p->to.type = D_BRANCH;
            }
        }
        if(p->to.type != D_BRANCH || p->pcond == UP)
            continue;

        c = p->to.offset;
        for(q = firstp; q != P;) {
            if(q->forwd != P)
            if(c >= q->forwd->pc) {
                q = q->forwd;
                continue;
            }
            if(c == q->pc)
                break;
            q = q->link;
        }
        if(q == P) {
            diag("branch out of range in %s\n%P", TNAME, p);
            p->to.type = D_NONE;
        }
        p->pcond = q;
    }

    for(p = firstp; p != P; p = p->link) {
        if(p->as == ATEXT)
            curtext = p;
        p->mark = 0;	/* initialization for follow */
        if(p->pcond != P && p->pcond != UP) {
            p->pcond = brloop(p->pcond);
            if(p->pcond != P)
            if(p->to.type == D_BRANCH)
                p->to.offset = p->pcond->pc;
        }
    }
}
@

<<function brloop>>=
Prog*
brloop(Prog *p)
{
    int c;
    Prog *q;

    c = 0;
    for(q = p; q != P; q = q->pcond) {
        if(q->as != AJMP)
            break;
        c++;
        if(c >= 5000)
            return P;
    }
    return q;
}
@


<<constant LOG>>=
#define	LOG	5
@

<<function mkfwd>>=
void
mkfwd(void)
{
    Prog *p;
    int i;
    long dwn[LOG], cnt[LOG];
    Prog *lst[LOG];

    for(i=0; i<LOG; i++) {
        if(i == 0)
            cnt[i] = 1; else
            cnt[i] = LOG * cnt[i-1];
        dwn[i] = 1;
        lst[i] = P;
    }
    i = 0;
    for(p = firstp; p != P; p = p->link) {
        if(p->as == ATEXT)
            curtext = p;
        i--;
        if(i < 0)
            i = LOG-1;
        p->forwd = P;
        dwn[i]--;
        if(dwn[i] <= 0) {
            dwn[i] = cnt[i];
            if(lst[i] != P)
                lst[i]->forwd = p;
            lst[i] = p;
        }
    }
}
@


\section{[[follow()]]}

<<function follow>>=
void
follow(void)
{

    DBG("%5.2f follow\n", cputime());

    firstp = prg();
    lastp = firstp;

    xfol(textp);

    lastp->link = P;
    firstp = firstp->link;
}
@

<<function xfol>>=
void
xfol(Prog *p)
{
    Prog *q;
    int i;
    enum as a;

loop:
    if(p == P)
        return;
    if(p->as == ATEXT)
        curtext = p;
    if(p->as == AJMP)
    if((q = p->pcond) != P) {
        p->mark = 1;
        p = q;
        if(p->mark == 0)
            goto loop;
    }
    if(p->mark) {
        /* copy up to 4 instructions to avoid branch */
        for(i=0,q=p; i<4; i++,q=q->link) {
            if(q == P)
                break;
            if(q == lastp)
                break;
            a = q->as;
            if(a == ANOP) {
                i--;
                continue;
            }
            switch(a) {
            case AJMP:
            case ARET:
            case AIRETL:

            case APUSHL:
            case APUSHFL:
            case APUSHW:
            case APUSHFW:
            case APOPL:
            case APOPFL:
            case APOPW:
            case APOPFW:
                goto brk;
            }
            if(q->pcond == P || q->pcond->mark)
                continue;
            if(a == ACALL || a == ALOOP)
                continue;
            for(;;) {
                if(p->as == ANOP) {
                    p = p->link;
                    continue;
                }
                q = copyp(p);
                p = p->link;
                q->mark = 1;
                lastp->link = q;
                lastp = q;
                if(q->as != a || q->pcond == P || q->pcond->mark)
                    continue;

                q->as = relinv(q->as);
                p = q->pcond;
                q->pcond = q->link;
                q->link = p;
                xfol(q->link);
                p = q->link;
                if(p->mark)
                    return;
                goto loop;
            }
        } /* */
    brk:;
        q = prg();
        q->as = AJMP;
        q->line = p->line;
        q->to.type = D_BRANCH;
        q->to.offset = p->pc;
        q->pcond = p;
        p = q;
    }
    p->mark = 1;
    lastp->link = p;
    lastp = p;
    a = p->as;
    if(a == AJMP || a == ARET || a == AIRETL)
        return;
    if(p->pcond != P)
    if(a != ACALL) {
        q = brchain(p->link);
        if(q != P && q->mark)
        if(a != ALOOP) {
            p->as = relinv(a);
            p->link = p->pcond;
            p->pcond = q;
        }
        xfol(p->link);
        q = brchain(p->pcond);
        if(q->mark) {
            p->pcond = q;
            return;
        }
        p = q;
        goto loop;
    }

    p = p->link;
    goto loop;
}
@

<<function relinv>>=
int
relinv(int a)
{

    switch(a) {
    case AJEQ:	return AJNE;
    case AJNE:	return AJEQ;
    case AJLE:	return AJGT;
    case AJLS:	return AJHI;
    case AJLT:	return AJGE;
    case AJMI:	return AJPL;
    case AJGE:	return AJLT;
    case AJPL:	return AJMI;
    case AJGT:	return AJLE;
    case AJHI:	return AJLS;
    case AJCS:	return AJCC;
    case AJCC:	return AJCS;
    case AJPS:	return AJPC;
    case AJPC:	return AJPS;
    case AJOS:	return AJOC;
    case AJOC:	return AJOS;
    }
    diag("unknown relation: %s in %s", anames[a], TNAME);
    return a;
}
@


<<function brchain>>=
Prog*
brchain(Prog *p)
{
    int i;

    for(i=0; i<20; i++) {
        if(p == P || p->as != AJMP)
            return p;
        p = p->pcond;
    }
    return P;
}
@

\section{Computing datsize, [[dodata()]]}

<<global datsize>>=
long	datsize;
@

<<global bsssize>>=
long	bsssize;
@


<<function dodata>>=
void
dodata(void)
{
    int i;
    Sym *s;
    Prog *p;
    long t, u;

    DBG("%5.2f dodata\n", cputime());

    for(p = datap; p != P; p = p->link) {
        s = p->from.sym;
        if(p->as == ADYNT || p->as == AINIT)
            s->value = dtype;
        if(s->type == SBSS)
            s->type = SDATA;
        if(s->type != SDATA)
            diag("initialize non-data (%d): %s\n%P",
                s->type, s->name, p);
        t = p->from.offset + p->width;
        if(t > s->value)
            diag("initialize bounds (%ld): %s\n%P",
                s->value, s->name, p);
    }
    /* allocate small guys */
    datsize = 0;
    for(i=0; i<NHASH; i++)
    for(s = hash[i]; s != S; s = s->link) {
        if(s->type != SDATA)
        if(s->type != SBSS)
            continue;
        t = s->value;
        if(t == 0) {
            diag("%s: no size", s->name);
            t = 1;
        }
        t = rnd(t, 4);;
        s->value = t;
        if(t > MINSIZ)
            continue;
        s->value = datsize;
        datsize += t;
        s->type = SDATA1;
    }

    /* allocate the rest of the data */
    for(i=0; i<NHASH; i++)
    for(s = hash[i]; s != S; s = s->link) {
        if(s->type != SDATA) {
            if(s->type == SDATA1)
                s->type = SDATA;
            continue;
        }
        t = s->value;
        s->value = datsize;
        datsize += t;
    }

    if(debug['j']) {
        /*
         * pad data with bss that fits up to next
         * 8k boundary, then push data to 8k
         */
        u = rnd(datsize, 8192);
        u -= datsize;
        for(i=0; i<NHASH; i++)
        for(s = hash[i]; s != S; s = s->link) {
            if(s->type != SBSS)
                continue;
            t = s->value;
            if(t > u)
                continue;
            u -= t;
            s->value = datsize;
            s->type = SDATA;
            datsize += t;
        }
        datsize += u;
    }

    /* now the bss */
    bsssize = 0;
    for(i=0; i<NHASH; i++)
    for(s = hash[i]; s != S; s = s->link) {
        if(s->type != SBSS)
            continue;
        t = s->value;
        s->value = bsssize + datsize;
        bsssize += t;
    }
    xdefine("bdata", SDATA, 0L);
    xdefine("edata", SBSS, datsize);
    xdefine("end", SBSS, bsssize + datsize);
    /* etext is defined in span.c */
}
@

<<function xdefine>>=
void
xdefine(char *p, int t, long v)
{
    Sym *s;

    s = lookup(p, 0);
    if(s->type == 0 || s->type == SXREF) {
        s->type = t;
        s->value = v;
    }
    if(s->type == STEXT && s->value == 0)
        s->value = v;
}
@


\section{[[dostkoff()]]}

<<function dostkoff>>=
void
dostkoff(void)
{
    Prog *p, *q;
    long autoffset, deltasp;
    int a, f, curframe, curbecome, maxbecome;

    curframe = 0;
    curbecome = 0;
    maxbecome = 0;
    curtext = nil;

    for(p = firstp; p != P; p = p->link) {

        /* find out how much arg space is used in this TEXT */
        if(p->to.type == (D_INDIR+D_SP))
            if(p->to.offset > curframe)
                curframe = p->to.offset;

        switch(p->as) {
        case ATEXT:
            if(curtext && curtext->from.sym) {
                curtext->from.sym->frame = curframe;
                curtext->from.sym->become = curbecome;
                if(curbecome > maxbecome)
                    maxbecome = curbecome;
            }
            curframe = 0;
            curbecome = 0;

            curtext = p;
            break;

        case ARET:
            /* special form of RET is BECOME */
            if(p->from.type == D_CONST)
                if(p->from.offset > curbecome)
                    curbecome = p->from.offset;
            break;
        }
    }
    if(curtext && curtext->from.sym) {
        curtext->from.sym->frame = curframe;
        curtext->from.sym->become = curbecome;
        if(curbecome > maxbecome)
            maxbecome = curbecome;
    }

    if(debug['b'])
        print("max become = %d\n", maxbecome);

    xdefine("ALEFbecome", STEXT, maxbecome);

    curtext = nil;

    for(p = firstp; p != P; p = p->link) {
        switch(p->as) {
        case ATEXT:
            curtext = p;
            break;
        case ACALL:
            if(curtext != P && curtext->from.sym != S && curtext->to.offset >= 0) {
                f = maxbecome - curtext->from.sym->frame;
                if(f <= 0)
                    break;
                /* calling a become or calling a variable */
                if(p->to.sym == S || p->to.sym->become) {
                    curtext->to.offset += f;

                    if(debug['b']) {
                        curp = p;
                        print("%D calling %D increase %d\n",
                            &curtext->from, &p->to, f);
                    }
                }
            }
            break;
        }
    }

    autoffset = 0;
    deltasp = 0;
    for(p = firstp; p != P; p = p->link) {
        if(p->as == ATEXT) {
            curtext = p;

            autoffset = p->to.offset;
            if(autoffset < 0)
                autoffset = 0;
            if(autoffset) {
                p = appendp(p);
                p->as = AADJSP;
                p->from.type = D_CONST;
                p->from.offset = autoffset;
            }
            deltasp = autoffset;
        }
        a = p->from.type;
        if(a == D_AUTO)
            p->from.offset += deltasp;
        if(a == D_PARAM)
            p->from.offset += deltasp + 4;
        a = p->to.type;
        if(a == D_AUTO)
            p->to.offset += deltasp;
        if(a == D_PARAM)
            p->to.offset += deltasp + 4;

        switch(p->as) {
        default:
            continue;
        case APUSHL:
        case APUSHFL:
            deltasp += 4;
            continue;
        case APUSHW:
        case APUSHFW:
            deltasp += 2;
            continue;
        case APOPL:
        case APOPFL:
            deltasp -= 4;
            continue;
        case APOPW:
        case APOPFW:
            deltasp -= 2;
            continue;
        case ARET:
            break;
        }

        if(autoffset != deltasp)
            diag("unbalanced PUSH/POP");
        if(p->from.type == D_CONST)
            goto become;

        if(autoffset) {
            q = p;
            p = appendp(p);
            p->as = ARET;

            q->as = AADJSP;
            q->from.type = D_CONST;
            q->from.offset = -autoffset;
        }
        continue;

    become:
        q = p;
        p = appendp(p);
        p->as = AJMP;
        p->to = q->to;
        p->pcond = q->pcond;

        q->as = AADJSP;
        q->from = zprg.from;
        q->from.type = D_CONST;
        q->from.offset = -autoffset;
        q->to = zprg.to;
        continue;
    }
}
@

<<function appendp>>=
Prog*
appendp(Prog *q)
{
    Prog *p;

    p = prg();
    p->link = q->link;
    q->link = p;
    p->line = q->line;
    return p;
}
@

\section{Computing textsize, [[span()]]}

<<global textsize>>=
long	textsize;
@


<<function span>>=
void
span(void)
{
    Prog *p, *q;
    long v, c, idat;
    int m, n, again;

    xdefine("etext", STEXT, 0L);
    idat = INITDAT;
    for(p = firstp; p != P; p = p->link) {
        if(p->as == ATEXT)
            curtext = p;
        n = 0;
        if(p->to.type == D_BRANCH)
            if(p->pcond == P)
                p->pcond = p;
        if((q = p->pcond) != P)
            if(q->back != 2)
                n = 1;
        p->back = n;
        if(p->as == AADJSP) {
            p->to.type = D_SP;
            v = -p->from.offset;
            p->from.offset = v;
            p->as = AADDL;
            if(v < 0) {
                p->as = ASUBL;
                v = -v;
                p->from.offset = v;
            }
            if(v == 0)
                p->as = ANOP;
        }
    }
    n = 0;

start:

    DBG("%5.2f span\n", cputime());

    c = INITTEXT;
    for(p = firstp; p != P; p = p->link) {
        if(p->as == ATEXT)
            curtext = p;
        if(p->to.type == D_BRANCH)
            if(p->back)
                p->pc = c;
        asmins(p);
        p->pc = c;
        m = andptr-and;
        p->mark = m;
        c += m;
    }

loop:
    n++;

    DBG("%5.2f span %d\n", cputime(), n);

    if(n > 50) {
        print("span must be looping\n");
        errorexit();
    }
    again = 0;
    c = INITTEXT;
    for(p = firstp; p != P; p = p->link) {
        if(p->as == ATEXT)
            curtext = p;
        if(p->to.type == D_BRANCH) {
            if(p->back)
                p->pc = c;
            asmins(p);
            m = andptr-and;
            if(m != p->mark) {
                p->mark = m;
                again++;
            }
        }
        p->pc = c;
        c += p->mark;
    }
    if(again) {
        textsize = c;
        goto loop;
    }
    if(INITRND) {
        INITDAT = rnd(c, INITRND);
        if(INITDAT != idat) {
            idat = INITDAT;
            goto start;
        }
    }
    xdefine("etext", STEXT, c);

    DBG("etext = %lux\n", c);

    for(p = textp; p != P; p = p->pcond)
        p->from.sym->value = p->pc;
    textsize = c - INITTEXT;
}
@

\section{[[doinit()]]}

% use INITDAT and relocate from there
<<function doinit>>=
void
doinit(void)
{
    Sym *s;
    Prog *p;
    int x;

    for(p = datap; p != P; p = p->link) {
        x = p->to.type;
        if(x != D_EXTERN && x != D_STATIC)
            continue;
        s = p->to.sym;
        if(s->type == 0 || s->type == SXREF)
            diag("undefined %s initializer of %s",
                s->name, p->from.sym->name);
        p->to.offset += s->value;
        p->to.type = D_CONST;
        if(s->type == SDATA || s->type == SBSS)
            p->to.offset += INITDAT;
    }
}
@

\section{Generating the executable, [[asmb()]]}
% asmb? asm binary?

% first function to actually use cout!

<<function asmb>>=
void
asmb(void)
{
    Prog *p;
    long v, magic;
    int a;
    byte *op1;

    DBG("%5.2f asmb\n", cputime());

    // TEXT SECTION

    seek(cout, HEADR, SEEK__START);
    pc = INITTEXT;
    curp = firstp;

    for(p = firstp; p != P; p = p->link) {
        if(p->as == ATEXT)
            curtext = p;
        if(p->pc != pc) {
            if(!debug['a'])
                print("%P\n", curp);
            diag("phase error %lux sb %lux in %s", p->pc, pc, TNAME);
            pc = p->pc;
        }
        curp = p;

        // generate instruction!
        asmins(p);

        if(cbc < sizeof(and))
            cflush();
        a = (andptr - and);

        if(debug['a']) {
            Bprint(&bso, pcstr, pc);
            for(op1 = and; op1 < andptr; op1++)
                Bprint(&bso, "%.2ux", *op1 & 0xff);
            Bprint(&bso, "\t%P\n", curp);
        }

        <<[[asmb()]] if dynamic module, when iterate from firstp>>

        memmove(cbp, and, a);
        cbp += a;
        pc += a;
        cbc -= a;
    }
    cflush();

    // DATA SECTION

    switch(HEADTYPE) {
    case H_PLAN9:
        seek(cout, HEADR+textsize, SEEK__START);
        break;
    <<[[asmb()]] switch HEADTYPE (to position after text) cases>>
    default:
        diag("unknown header type %ld", HEADTYPE);
    }

    DBG("%5.2f datblk\n", cputime());

    <<[[asmb()]] if dynamic module, before datblk()>>

    for(v = 0; v < datsize; v += sizeof(buf)-Dbufslop) {
        if(datsize-v > sizeof(buf)-Dbufslop)
            datblk(v, sizeof(buf)-Dbufslop);
        else
            datblk(v, datsize-v);
    }

    // SYMBOL TABLE

    // modified by asmsym()
    symsize = 0;
    // modified by asmlc()
    lcsize = 0;

    if(!debug['s']) {
        DBG("%5.2f sym\n", cputime());

        switch(HEADTYPE) {
        case H_PLAN9:
            seek(cout, HEADR+textsize+datsize, 0);
            break;
        <<[[asmb()]] switch HEADTYPE (for symbol table generation) cases>>
        default:
            seek(cout, rnd(HEADR+textsize, 8192)+datsize, 0);
            break;
        }

        asmsym();

        DBG("%5.2f sp\n", cputime());
        DBG("%5.2f pc\n", cputime());

        asmlc();

        <<[[asmb()]] if dynamic module, call asmdyn()>>
        cflush();
    } else {
        <<[[asmb()]] if dynamic module and no symbol table generation>>
    }

    // HEADER

    DBG("%5.2f headr\n", cputime());

    seek(cout, 0L, SEEK__START);

    switch(HEADTYPE) {
    // see Exec in a.out.h
    case H_PLAN9:	/* plan9 */
        magic = 4*11*11+7;
        <<[[asmb()]] if dynamic module magic header adjustment>>
        lput(magic);			/* magic */
        lput(textsize);			/* sizes */
        lput(datsize);
        lput(bsssize);
        lput(symsize);			/* nsyms */

        lput(entryvalue());		/* va of entry */

        lput(spsize);			/* sp offsets */
        lput(lcsize);			/* line offsets */
        break;
    <<[[asmb()]] switch HEADTYPE (for header generation) cases>>
    }

    cflush();
}
@

\ifallcode
% dead on 8l, so does not really have to be a global
<<global spsize>>=
long	spsize = 0;
@
\fi

\ifallcode
<<global pcstr>>=
char*	pcstr = "%.6lux ";
@
\fi



<<function entryvalue>>=
long
entryvalue(void)
{
    char *a;
    Sym *s;

    a = INITENTRY;

    <<[[entryvalue()]] if digit INITENTRY>>

    s = lookup(a, 0);
    // no _main found, maybe pure asm, start at beginning of TEXT section (va)
    if(s->type == 0)
        return INITTEXT;

    switch(s->type) {
    case STEXT:
        return s->value;
    <<[[entryvalue()]] if dynamic module case>>
    default:
        diag("entry not text: %s", s->name);
    }
}
@


<<constant Dbufslop>>=
#define	Dbufslop	100
@

<<function datblk>>=
void
datblk(long s, long n)
{
    Prog *p;
    char *cast;
    long l, fl, j;
    int i, c;

    memset(buf.dbuf, 0, n+Dbufslop);
    for(p = datap; p != P; p = p->link) {
        curp = p;
        l = p->from.sym->value + p->from.offset - s;
        c = p->from.scale;
        i = 0;
        if(l < 0) {
            if(l+c <= 0)
                continue;
            while(l < 0) {
                l++;
                i++;
            }
        }
        if(l >= n)
            continue;
        if(p->as != AINIT && p->as != ADYNT) {
            for(j=l+(c-i)-1; j>=l; j--)
                if(buf.dbuf[j]) {
                    print("%P\n", p);
                    diag("multiple initialization");
                    break;
                }
        }
        switch(p->to.type) {
        case D_FCONST:
            switch(c) {
            default:
            case 4:
                fl = ieeedtof(&p->to.ieee);
                cast = (char*)&fl;
                if(debug['a'] && i == 0) {
                    Bprint(&bso, pcstr, l+s+INITDAT);
                    for(j=0; j<c; j++)
                        Bprint(&bso, "%.2ux", cast[fnuxi4[j]] & 0xff);
                    Bprint(&bso, "\t%P\n", curp);
                }
                for(; i<c; i++) {
                    buf.dbuf[l] = cast[fnuxi4[i]];
                    l++;
                }
                break;
            case 8:
                cast = (char*)&p->to.ieee;
                if(debug['a'] && i == 0) {
                    Bprint(&bso, pcstr, l+s+INITDAT);
                    for(j=0; j<c; j++)
                        Bprint(&bso, "%.2ux", cast[fnuxi8[j]] & 0xff);
                    Bprint(&bso, "\t%P\n", curp);
                }
                for(; i<c; i++) {
                    buf.dbuf[l] = cast[fnuxi8[i]];
                    l++;
                }
                break;
            }
            break;

        case D_SCONST:
            if(debug['a'] && i == 0) {
                Bprint(&bso, pcstr, l+s+INITDAT);
                for(j=0; j<c; j++)
                    Bprint(&bso, "%.2ux", p->to.scon[j] & 0xff);
                Bprint(&bso, "\t%P\n", curp);
            }
            for(; i<c; i++) {
                buf.dbuf[l] = p->to.scon[i];
                l++;
            }
            break;

        default:
            fl = p->to.offset;
            if(p->to.type == D_ADDR) {
                if(p->to.index != D_STATIC && p->to.index != D_EXTERN)
                    diag("DADDR type%P", p);
                if(p->to.sym) {
                    if(p->to.sym->type == SUNDEF)
                        ckoff(p->to.sym, fl);
                    fl += p->to.sym->value;
                    if(p->to.sym->type != STEXT && p->to.sym->type != SUNDEF)
                        fl += INITDAT;
                    <<[[datblk()]] if dynamic module>>
                }
            }
            cast = (char*)&fl;
            switch(c) {
            default:
                diag("bad nuxi %d %d\n%P", c, i, curp);
                break;
            case 1:
                if(debug['a'] && i == 0) {
                    Bprint(&bso, pcstr, l+s+INITDAT);
                    for(j=0; j<c; j++)
                        Bprint(&bso, "%.2ux", cast[inuxi1[j]] & 0xff);
                    Bprint(&bso, "\t%P\n", curp);
                }
                for(; i<c; i++) {
                    buf.dbuf[l] = cast[inuxi1[i]];
                    l++;
                }
                break;
            case 2:
                if(debug['a'] && i == 0) {
                    Bprint(&bso, pcstr, l+s+INITDAT);
                    for(j=0; j<c; j++)
                        Bprint(&bso, "%.2ux", cast[inuxi2[j]] & 0xff);
                    Bprint(&bso, "\t%P\n", curp);
                }
                for(; i<c; i++) {
                    buf.dbuf[l] = cast[inuxi2[i]];
                    l++;
                }
                break;
            case 4:
                if(debug['a'] && i == 0) {
                    Bprint(&bso, pcstr, l+s+INITDAT);
                    for(j=0; j<c; j++)
                        Bprint(&bso, "%.2ux", cast[inuxi4[j]] & 0xff);
                    Bprint(&bso, "\t%P\n", curp);
                }
                for(; i<c; i++) {
                    buf.dbuf[l] = cast[inuxi4[i]];
                    l++;
                }
                break;
            }
            break;
        }
    }
    write(cout, buf.dbuf, n);
}
@


<<function ckoff>>=
void
ckoff(Sym *s, long v)
{
    if(v < 0 || v >= 1<<Roffset)
        diag("relocation offset %ld for %s out of range", v, s->name);
}
@

% >>





\section{Checking for unresolved symbols, [[undef()]]}

% rename check_if_still_undefined_symbols()?
<<function undef>>=
void
undef(void)
{
    int i;
    Sym *s;

    for(i=0; i<NHASH; i++)
        for(s = hash[i]; s != S; s = s->link)
            if(s->type == SXREF)
                diag("%s: not defined", s->name);
}
@


\chapter{Loading Objects}
% was called parsing, but binary format so loading is more appropriate I think

% essentially reverse operation than object generation in Assembler.tex.nw?
% hmmm if C had proper ADT and Marshall module that would be easier ...
% (but maybe less other-languages friendly)
% could factorize code with libmach?

% why not using 8obj.c from libmach/? because 8obj.c is incomplete?
% car just about symbol table?

% each ldobj will add to this pc
<<global pc>>=
long	pc = 0;
@


% This is for the D_STATIC; to handle conflicts with different files
% defining the same static entity. This is bumped each time
% a new object file is parsed, so it's safe.
<<global version>>=
int	version = 0;
@


<<[[ldobj()]] locals>>=
// enum<as>, the opcode
int o;
Prog *p;
@

% ???
<<[[ldobj()]] locals>>=
Sym *h[NSYM];
Sym *di;
Sym *s;
long ipc;
bool skip;
@

%???
<<[[ldobj()]] locals>>=
Prog *t;
byte *stop;
int v;
ulong sig;
@




<<[[ldobj()]] locals>>=
byte *bloc;
byte *bsize;
int r;
@
% and parameter 'int c'

<<[[ldobj()]] bloc and bsize init>>=
bsize = buf.xbuf;
bloc = buf.xbuf;
@

<<[[ldobj()]] read if needed in loop:, adjust block and bsize>>=
r = bsize - bloc;
if(r < 100 && r < c) {		/* enough for largest prog */
    bsize = readsome(f, buf.xbuf, bloc, bsize, c);
    if(bsize == 0)
        goto eof;
    bloc = buf.xbuf;
    goto loop;
}
@

\section{[[ldobj()]]}

% main() -> objfile() -> ldbobj()
% c = size of .8, pn = filename, f = fd of opened object file
<<function ldobj>>=
void
ldobj(fdt f, long c, char *pn)
{
    <<[[ldobj()]] locals>>

    <<[[ldobj()]] grow filen if not enough space>>
    filen[files++] = strdup(pn);

    <<[[ldobj()]] bloc and bsize init>>

    di = S;

// can come from AEND
newloop:
    version++;
    memset(h, 0, sizeof(h));
    histfrogp = 0;
    ipc = pc;
    skip = false;

loop:
    if(c <= 0)
        goto eof;

    <<[[ldobj()]] read if needed in loop:, adjust block and bsize>>

    // get the opcode
    o = bloc[0] | (bloc[1] << 8); // >>

    <<[[ldobj()]] sanity check opcode in range>>

    <<[[ldobj()]] if ANAME or ASIGNAME>>

    //TODO: factorize
    while(nhunk < sizeof(Prog))
        gethunk();
    p = (Prog*)hunk;
    nhunk -= sizeof(Prog);
    hunk += sizeof(Prog);

    p->as = o;
    p->line = bloc[2] | (bloc[3] << 8) | (bloc[4] << 16) | (bloc[5] << 24);
    p->back = 2;
    // >> >> >>

    r = zaddr(bloc+6, &p->from, h) + 6;
    r += zaddr(bloc+r, &p->to, h);

    bloc += r;
    c -= r;

    if(debug['W'])
        print("%P\n", p);

    switch(p->as) {
    <<[[ldobj()]] switch as cases>>

    default:
    casdef:
        if(skip)
            nopout(p);

        if(p->to.type == D_BRANCH)
            p->to.offset += ipc;

        lastp->link = p;
        lastp = p;

        p->pc = pc;
        pc++;
    }
    goto loop;

eof:
    diag("truncated object file: %s", pn);
}
@

% >> >> >> >>

<<[[ldobj()]] sanity check opcode in range>>=
if(o <= AXXX || o >= ALAST) {
    if(o < 0)
        goto eof;
    diag("%s: opcode out of range %d", pn, o);
    print("	probably not a .8 file\n");
    errorexit();
}
@
 
<<function nopout>>=
void
nopout(Prog *p)
{
    p->as = ANOP;
    p->from.type = D_NONE;
    p->to.type = D_NONE;
}
@


<<function zaddr>>=
int
zaddr(byte *p, Adr *a, Sym *h[])
{
    int c, t, i;
    int l;
    Sym *s;
    Auto *u;

    t = p[0];

    c = 1;
    if(t & T_INDEX) {
        a->index = p[c];
        a->scale = p[c+1];
        c += 2;
    } else {
        a->index = D_NONE;
        a->scale = 0;
    }
    a->offset = 0;
    if(t & T_OFFSET) {
        a->offset = p[c] | (p[c+1]<<8) | (p[c+2]<<16) | (p[c+3]<<24);
        c += 4;
        // >> >> >>
    }
    a->sym = S;
    if(t & T_SYM) {
        a->sym = h[p[c]];
        c++;
    }
    a->type = D_NONE;
    if(t & T_FCONST) {
        a->ieee.l = p[c] | (p[c+1]<<8) | (p[c+2]<<16) | (p[c+3]<<24);
        a->ieee.h = p[c+4] | (p[c+5]<<8) | (p[c+6]<<16) | (p[c+7]<<24);
        // >> >> >> >> >> >>
        c += 8;
        a->type = D_FCONST;
    } else
    if(t & T_SCONST) {
        for(i=0; i<NSNAME; i++)
            a->scon[i] = p[c+i];
        c += NSNAME;
        a->type = D_SCONST;
    }
    if(t & T_TYPE) {
        a->type = p[c];
        c++;
    }
    s = a->sym;
    if(s == S)
        return c;

    t = a->type;
    if(t != D_AUTO && t != D_PARAM)
        return c;
    l = a->offset;
    for(u=curauto; u; u=u->link) {
        if(u->asym == s)
        if(u->type == t) {
            if(u->aoffset > l)
                u->aoffset = l;
            return c;
        }
    }

    // factorize!
    while(nhunk < sizeof(Auto))
        gethunk();
    u = (Auto*)hunk;
    nhunk -= sizeof(Auto);
    hunk += sizeof(Auto);

    u->link = curauto;
    curauto = u;
    u->asym = s;
    u->aoffset = l;
    u->type = t;
    return c;
}
@


\section{[[ATEXT]]}

<<global curauto>>=
Auto*	curauto;
@

<<[[ldobj()]] switch as cases>>=
case ATEXT:
    if(curtext != P) {
        histtoauto();
        curtext->to.autom = curauto;
        curauto = 0;
    }
    skip = false;
    curtext = p;
    s = p->from.sym;
    if(s == S) {
        diag("%s: no TEXT symbol: %P", pn, p);
        errorexit();
    }
    if(s->type != 0 && s->type != SXREF) {
        if(p->from.scale & DUPOK) {
            skip = true;
            goto casdef;
        }
        diag("%s: redefinition: %s\n%P", pn, s->name, p);
    }
    s->type = STEXT;
    s->value = pc;

    //add_list(firstp, lastp, p)
    lastp->link = p;
    lastp = p;

    p->pc = pc;
    pc++;

    //add_list(textp, etextp, p)
    if(textp == P) {
        textp = p;
        etextp = p;
    } else {
        etextp->pcond = p;
        etextp = p;
    }

    break;
@


\section{[[ADATA]]}

<<[[ldobj()]] switch as cases>>=
case ADATA:
data:
    //add_list(datap, edatap, p)
    if(edatap == P)
        datap = p;
    else
        edatap->link = p;
    edatap = p;
    p->link = P;
    break;
@

\section{[[ADYNT]]}
% ???
% mv with dlm?

<<[[ldobj()]] switch as cases>>=
case ADYNT:
    if(p->to.sym == S) {
        diag("DYNT without a sym\n%P", p);
        break;
    }
    di = p->to.sym;
    p->from.scale = 4; // NOSPLIT?
    if(di->type == SXREF) {
        if(debug['z'])
            Bprint(&bso, "%P set to %d\n", p, dtype);
        di->type = SCONST;
        di->value = dtype;
        dtype += 4;
    }
    if(p->from.sym == S)
        break;

    p->from.offset = di->value;
    p->from.sym->type = SDATA;
    if(curtext == P) {
        diag("DYNT not in text: %P", p);
        break;
    }
    p->to.sym = curtext->from.sym;
    p->to.type = D_ADDR;
    p->to.index = D_EXTERN;
    goto data;
@

\section{[[AINIT]]}

<<[[ldobj()]] switch as cases>>=
case AINIT:
    if(p->from.sym == S) {
        diag("INIT without a sym\n%P", p);
        break;
    }
    if(di == S) {
        diag("INIT without previous DYNT\n%P", p);
        break;
    }
    p->from.offset = di->value;
    p->from.sym->type = SDATA;
    goto data;
@

\section{[[AGLOBL]]}

% not added in any list? because bss?
<<[[ldobj()]] switch as cases>>=
case AGLOBL:
    s = p->from.sym;
    if(s->type == 0 || s->type == SXREF) {
        s->type = SBSS;
        s->value = 0;
    }
    if(s->type != SBSS) {
        diag("%s: redefinition: %s in %s",
            pn, s->name, TNAME);
        s->type = SBSS;
        s->value = 0;
    }
    if(p->to.offset > s->value)
        s->value = p->to.offset;
    break;
@

\section{[[ANAME]], [[ASIGNAME]]}

<<global histfrogp>>=
int	histfrogp;
@

<<global histfrog>>=
Sym*	histfrog[MAXHIST];
@

<<global histgen>>=
int	histgen = 0;
@



% used by what? for debugging? when signature conflict! to print
% current filenames in conflict
<<[[ldobj()]] locals>>=
// array<string>, length used = files, extended every 16
static char **filen;
static int files = 0;
char **nfilen;
@

<<[[ldobj()]] grow filen if not enough space>>=
if((files&15) == 0){
    nfilen = malloc((files+16)*sizeof(char*));
    memmove(nfilen, filen, files*sizeof(char*));
    free(filen);
    filen = nfilen;
}
@


<<[[ldobj()]] if ANAME or ASIGNAME>>=
if(o == ANAME || o == ASIGNAME) {
    sig = 0;
    if(o == ASIGNAME) {
        sig = bloc[2] | (bloc[3]<<8) | (bloc[4]<<16) | (bloc[5]<<24);
        // >> >> >>
        bloc += 4;
        c -= 4;
    }
    stop = memchr(&bloc[4], 0, bsize-&bloc[4]);
    if(stop == nil){
        bsize = readsome(f, buf.xbuf, bloc, bsize, c);
        if(bsize == 0)
            goto eof;
        bloc = buf.xbuf;
        stop = memchr(&bloc[4], 0, bsize-&bloc[4]);
        if(stop == nil){
            fprint(2, "%s: name too long\n", pn);
            errorexit();
        }
    }

    v = bloc[2];	/* type */
    o = bloc[3];	/* sym */
    bloc += 4;
    c -= 4;

    r = 0;
    if(v == D_STATIC)
        r = version;
    s = lookup((char*)bloc, r);

    c -= &stop[1] - bloc;
    bloc = stop + 1;

    if(debug['S'] && r == 0)
        sig = 1729;
    if(sig != 0){
        if(s->sig != 0 && s->sig != sig)
            diag("incompatible type signatures %lux(%s) and %lux(%s) for %s", s->sig, filen[s->file], sig, pn, s->name);
        s->sig = sig;
        s->file = files-1;
    }

    if(debug['W'])
        print("	ANAME	%s\n", s->name);

    h[o] = s;
    if((v == D_EXTERN || v == D_STATIC) && s->type == 0)
        s->type = SXREF;
    if(v == D_FILE) {
        if(s->type != SFILE) {
            histgen++;
            s->type = SFILE;
            s->value = histgen;
        }
        if(histfrogp < MAXHIST) {
            histfrog[histfrogp] = s;
            histfrogp++;
        } else
            collapsefrog(s);
    }
    goto loop;
}
@
% >> >> >>

<<function collapsefrog>>=
void
collapsefrog(Sym *s)
{
    int i;

    /*
     * bad encoding of path components only allows
     * MAXHIST components. if there is an overflow,
     * first try to collapse xxx/..
     */
    for(i=1; i<histfrogp; i++)
        if(strcmp(histfrog[i]->name+1, "..") == 0) {
            memmove(histfrog+i-1, histfrog+i+1,
                (histfrogp-i-1)*sizeof(histfrog[0]));
            histfrogp--;
            goto out;
        }

    /*
     * next try to collapse .
     */
    for(i=0; i<histfrogp; i++)
        if(strcmp(histfrog[i]->name+1, ".") == 0) {
            memmove(histfrog+i, histfrog+i+1,
                (histfrogp-i-1)*sizeof(histfrog[0]));
            goto out;
        }

    /*
     * last chance, just truncate from front
     */
    memmove(histfrog+0, histfrog+1,
        (histfrogp-1)*sizeof(histfrog[0]));

out:
    histfrog[histfrogp-1] = s;
}
@



\section{[[AHISTORY]]}

<<[[ldobj()]] switch as cases>>=
case AHISTORY:
    if(p->to.offset == -1) {
        addlib(pn);
        histfrogp = 0;
        goto loop;
    }
    addhist(p->line, D_FILE);		/* 'z' */
    if(p->to.offset)
        addhist(p->to.offset, D_FILE1);	/* 'Z' */
    histfrogp = 0;
    break;
@

\section{[[AEND]]}

<<[[ldobj()]] switch as cases>>=
case AEND:
    histtoauto();
    if(curtext != P)
        curtext->to.autom = curauto;
    curauto = 0;
    curtext = P;
    if(c)
        goto newloop;
    return;
@

% also called by ATEXT
<<function histtoauto>>=
void
histtoauto(void)
{
    Auto *l;

    while(l = curhist) {
        curhist = l->link;
        l->link = curauto;
        curauto = l;
    }
}
@

\section{[[AGOK]]}

<<[[ldobj()]] switch as cases>>=
case AGOK:
    diag("%s: GOK opcode in %s", pn, TNAME);
    pc++;
    break;
@

\chapter{Loading Libraries}

\section{Library search path}

<<[[main()]] command line processing>>=
case 'L':
    addlibpath(EARGF(usage()));
    break;
@

% was called a
<<[[main()]] locals>>=
char *root;
@

<<[[main()]] addlibpath("/386/lib") or ccroot>>=
<<[[main()]] change root if ccroot>>

// usually /386/lib/ as root = ""
snprint(name, sizeof(name), "%s/%s/lib", root, thestring);
addlibpath(name);
@

% possible to change default / search path
<<[[main()]] change root if ccroot>>=
root = getenv("ccroot");

if(root != nil && *root != '\0') {
    if(!fileexists(root)) {
        diag("nonexistent $ccroot: %s", root);
        errorexit();
    }
}else
    root = "";
@
%$




<<global libdir>>=
char**	libdir;
@

<<global nlibdir>>=
int	nlibdir	= 0;
@

<<global maxlibdir>>=
static	int	maxlibdir = 0;
@

<<function addlibpath>>=
void
addlibpath(char *arg)
{
    char **p;

    // growing array libdir
    if(nlibdir >= maxlibdir) {
        if(maxlibdir == 0)
            maxlibdir = 8;
        else
            maxlibdir *= 2;
        p = malloc(maxlibdir*sizeof(*p));
        if(p == nil) {
            diag("out of memory");
            errorexit();
        }
        memmove(p, libdir, nlibdir*sizeof(*p));
        free(libdir);
        libdir = p;
    }

    libdir[nlibdir++] = strdup(arg);
}
@


\section{[[ar]] format}

% from ar.h
<<constant ARMAG>>=
#define	ARMAG	"!<arch>\n"
@

<<constant SARMAG>>=
#define	SARMAG	8
@

<<constant ARFMAG>>=
#define	ARFMAG	"`\n"
@

<<constant SARNAME>>=
#define SARNAME	16
@

<<struct ar_hdr>>=
struct	ar_hdr
{
    char	name[SARNAME];
    char	date[12];
    char	uid[6];
    char	gid[6];
    char	mode[8];
    char	size[10];
    char	fmag[2];
};
@

<<constant SAR_HDR>>=
#define	SAR_HDR	(SARNAME+44)
@

\section{Loading libraries}

\subsection{Loading libraries manually [[8l -lxxx]]}

% when done manually by -l in command line of ld
<<[[objfile()]] adjust file if -lxxx filename>>=
if(file[0] == '-' && file[1] == 'l') {
    snprint(pname, sizeof(pname), "lib%s.a", file+2);
    e = findlib(pname);
    if(e == nil) {
        diag("cannot find library: %s", file);
        errorexit();
    }
    snprint(name, sizeof(name), "%s/%s", e, pname);
    file = name;
}
@

<<function findlib>>=
char*
findlib(char *file)
{
    int i;
    char name[LIBNAMELEN];

    for(i = 0; i < nlibdir; i++) {
        snprint(name, sizeof(name), "%s/%s", libdir[i], file);
        if(fileexists(name))
            return libdir[i];
    }
    return nil;
}
@


<<[[objfile()]] other locals>>=
long off, esym, cnt;
bool work;
Sym *s;
char pname[LIBNAMELEN];
char name[LIBNAMELEN];
struct ar_hdr arhdr;
char *e, *start, *stop;
@

<<global symname (linkers/8l/obj.c)>>=
char	symname[]	= SYMDEF;
@

<<[[objfile()]] when file is a library>>=
    l = read(f, &arhdr, SAR_HDR);
    if(l != SAR_HDR) {
        diag("%s: short read on archive file symbol header", file);
        goto out;
    }
    if(strncmp(arhdr.name, symname, strlen(symname))) {
        diag("%s: first entry not symbol header", file);
        goto out;
    }

    esym = SARMAG + SAR_HDR + atolwhex(arhdr.size);
    off = SARMAG + SAR_HDR;

    /*
     * just bang the whole symbol file into memory
     */
    seek(f, off, 0);
    cnt = esym - off;
    start = malloc(cnt + 10);
    cnt = read(f, start, cnt);
    if(cnt <= 0){
        close(f);
        return;
    }
    stop = &start[cnt];
    memset(stop, 0, 10);

    work = true;

    while(work) {

        DBG("%5.2f library pass: %s\n", cputime(), file);

        work = false;
        for(e = start; e < stop; e = strchr(e+5, 0) + 1) {
            s = lookup(e+5, 0);
            if(s->type != SXREF)
                continue;
            sprint(pname, "%s(%s)", file, s->name);

            DBG("%5.2f library: %s\n", cputime(), pname);

            l = e[1] & 0xff;
            l |= (e[2] & 0xff) << 8;
            l |= (e[3] & 0xff) << 16;
            l |= (e[4] & 0xff) << 24;
            seek(f, l, 0);
            /* need readn to read the dumps (at least) */
            l = readn(f, &arhdr, SAR_HDR);
            if(l != SAR_HDR)
                goto bad;
            if(strncmp(arhdr.fmag, ARFMAG, sizeof(arhdr.fmag)))
                goto bad;
            l = atolwhex(arhdr.size);
            ldobj(f, l, pname);
            if(s->type == SXREF) {
                diag("%s: failed to load: %s", file, s->name);
                errorexit();
            }
            work = true;
            xrefresolv = true;
        }
    }
    return;

bad:
    diag("%s: bad or out of date archive", file);
out:
    close(f);
@

% >> >> >>

\subsection{Loading libraries automagically [[#pragma lib]]}

% when done automatically

% TODO LP split AHISTORY here


<<function addhist>>=
void
addhist(long line, int type)
{
    Auto *u;
    Sym *s;
    int i, j, k;

    u = malloc(sizeof(Auto));
    s = malloc(sizeof(Sym));
    s->name = malloc(2*(histfrogp+1) + 1);

    u->asym = s;
    u->type = type;
    u->aoffset = line;
    u->link = curhist;
    curhist = u;

    j = 1;
    for(i=0; i<histfrogp; i++) {
        k = histfrog[i]->value;
        s->name[j+0] = k>>8;
        s->name[j+1] = k;
        j += 2;
    }
}
@



<<function addlib>>=
void
addlib(char *obj)
{
    char fn1[LIBNAMELEN], fn2[LIBNAMELEN], comp[LIBNAMELEN], *p, *name;
    int i, search;

    if(histfrogp <= 0)
        return;

    name = fn1;
    search = 0;
    if(histfrog[0]->name[1] == '/') {
        sprint(name, "");
        i = 1;
    } else if(histfrog[0]->name[1] == '.') {
        sprint(name, ".");
        i = 0;
    } else {
        sprint(name, "");
        i = 0;
        search = 1;
    }

    for(; i<histfrogp; i++) {
        snprint(comp, sizeof comp, histfrog[i]->name+1);
        for(;;) {
            p = strstr(comp, "$O");
            if(p == 0)
                break;
            memmove(p+1, p+2, strlen(p+2)+1);
            p[0] = thechar;
        }
        for(;;) {
            p = strstr(comp, "$M");
            if(p == 0)
                break;
            if(strlen(comp)+strlen(thestring)-2+1 >= sizeof comp) {
                diag("library component too long");
                return;
            }
            memmove(p+strlen(thestring), p+2, strlen(p+2)+1);
            memmove(p, thestring, strlen(thestring));
        }
        if(strlen(fn1) + strlen(comp) + 3 >= sizeof(fn1)) {
            diag("library component too long");
            return;
        }
        if(i > 0 || !search)
            strcat(fn1, "/");
        strcat(fn1, comp);
    }

    cleanname(name);

    if(search){
        p = findlib(name);
        if(p != nil){
            snprint(fn2, sizeof(fn2), "%s/%s", p, name);
            name = fn2;
        }
    }


    for(i=0; i<libraryp; i++)
        if(strcmp(name, library[i]) == 0)
            return;
    if(libraryp == nelem(library)){
        diag("too many autolibs; skipping %s", name);
        return;
    }

    p = malloc(strlen(name) + 1);
    strcpy(p, name);
    library[libraryp] = p;
    p = malloc(strlen(obj) + 1);
    strcpy(p, obj);
    libraryobj[libraryp] = p;
    libraryp++;
}
@


\chapter{Checking Signatures}

\chapter{Machine Code Generation (x86)}
% for x86

% done by 8l, not 8a, surprisingly!

% why? because allows more optimisations? cross libs? as in llvm?
% also more compact and simple object format? and more cross platform?

\section{[[optab]]}
<<enum pxxx>>=
enum pxxx {
    Px		= 0,
    Pe		= 0x66,	/* operand escape */
    Pm		= 0x0f,	/* 2byte opcode escape */
    Pq		= 0xff,	/* both escape */
    Pb		= 0xfe,	/* byte operands */
};
@

<<global optab>>=
Optab optab[] =
/*	as, ytab, andproto, opcode */
{
    { AXXX },
    { AAAA,		ynone,	Px, 0x37 },
    { AAAD,		ynone,	Px, 0xd5,0x0a },
    { AAAM,		ynone,	Px, 0xd4,0x0a },
    { AAAS,		ynone,	Px, 0x3f },
    { AADCB,	yxorb,	Pb, 0x14,0x80,(02),0x10,0x10 },
    { AADCL,	yxorl,	Px, 0x83,(02),0x15,0x81,(02),0x11,0x13 },
    { AADCW,	yxorl,	Pe, 0x83,(02),0x15,0x81,(02),0x11,0x13 },
    { AADDB,	yxorb,	Px, 0x04,0x80,(00),0x00,0x02 },
    { AADDL,	yaddl,	Px, 0x83,(00),0x05,0x81,(00),0x01,0x03 },
    { AADDW,	yaddl,	Pe, 0x83,(00),0x05,0x81,(00),0x01,0x03 },
    { AADJSP },
    { AANDB,	yxorb,	Pb, 0x24,0x80,(04),0x20,0x22 },
    { AANDL,	yxorl,	Px, 0x83,(04),0x25,0x81,(04),0x21,0x23 },
    { AANDW,	yxorl,	Pe, 0x83,(04),0x25,0x81,(04),0x21,0x23 },
    { AARPL,	yrl_ml,	Px, 0x63 },
    { ABOUNDL,	yrl_m,	Px, 0x62 },
    { ABOUNDW,	yrl_m,	Pe, 0x62 },
    { ABSFL,	yml_rl,	Pm, 0xbc },
    { ABSFW,	yml_rl,	Pq, 0xbc },
    { ABSRL,	yml_rl,	Pm, 0xbd },
    { ABSRW,	yml_rl,	Pq, 0xbd },
    { ABTL,		yml_rl,	Pm, 0xa3 },
    { ABTW,		yml_rl,	Pq, 0xa3 },
    { ABTCL,	yml_rl,	Pm, 0xbb },
    { ABTCW,	yml_rl,	Pq, 0xbb },
    { ABTRL,	yml_rl,	Pm, 0xb3 },
    { ABTRW,	yml_rl,	Pq, 0xb3 },
    { ABTSL,	yml_rl,	Pm, 0xab },
    { ABTSW,	yml_rl,	Pq, 0xab },
    { ABYTE,	ybyte,	Px, 1 },
    { ACALL,	ycall,	Px, 0xff,(02),0xe8 },
    { ACLC,		ynone,	Px, 0xf8 },
    { ACLD,		ynone,	Px, 0xfc },
    { ACLI,		ynone,	Px, 0xfa },
    { ACLTS,	ynone,	Pm, 0x06 },
    { ACMC,		ynone,	Px, 0xf5 },
    { ACMPB,	ycmpb,	Pb, 0x3c,0x80,(07),0x38,0x3a },
    { ACMPL,	ycmpl,	Px, 0x83,(07),0x3d,0x81,(07),0x39,0x3b },
    { ACMPW,	ycmpl,	Pe, 0x83,(07),0x3d,0x81,(07),0x39,0x3b },
    { ACMPSB,	ynone,	Pb, 0xa6 },
    { ACMPSL,	ynone,	Px, 0xa7 },
    { ACMPSW,	ynone,	Pe, 0xa7 },
    { ADAA,		ynone,	Px, 0x27 },
    { ADAS,		ynone,	Px, 0x2f },
    { ADATA },
    { ADECB,	yincb,	Pb, 0xfe,(01) },
    { ADECL,	yincl,	Px, 0x48,0xff,(01) },
    { ADECW,	yincl,	Pe, 0x48,0xff,(01) },
    { ADIVB,	ydivb,	Pb, 0xf6,(06) },
    { ADIVL,	ydivl,	Px, 0xf7,(06) },
    { ADIVW,	ydivl,	Pe, 0xf7,(06) },
    { AENTER },				/* botch */
    { AGLOBL },
    { AGOK },
    { AHISTORY },
    { AHLT,		ynone,	Px, 0xf4 },
    { AIDIVB,	ydivb,	Pb, 0xf6,(07) },
    { AIDIVL,	ydivl,	Px, 0xf7,(07) },
    { AIDIVW,	ydivl,	Pe, 0xf7,(07) },
    { AIMULB,	ydivb,	Pb, 0xf6,(05) },
    { AIMULL,	yimul,	Px, 0xf7,(05),0x6b,0x69 },
    { AIMULW,	yimul,	Pe, 0xf7,(05),0x6b,0x69 },
    { AINB,		yin,	Pb, 0xe4,0xec },
    { AINL,		yin,	Px, 0xe5,0xed },
    { AINW,		yin,	Pe, 0xe5,0xed },
    { AINCB,	yincb,	Pb, 0xfe,(00) },
    { AINCL,	yincl,	Px, 0x40,0xff,(00) },
    { AINCW,	yincl,	Pe, 0x40,0xff,(00) },
    { AINSB,	ynone,	Pb, 0x6c },
    { AINSL,	ynone,	Px, 0x6d },
    { AINSW,	ynone,	Pe, 0x6d },
    { AINT,		yint,	Px, 0xcd },
    { AINTO,	ynone,	Px, 0xce },
    { AIRETL,	ynone,	Px, 0xcf },
    { AIRETW,	ynone,	Pe, 0xcf },
    { AJCC,		yjcond,	Px, 0x73,0x83,(00) },
    { AJCS,		yjcond,	Px, 0x72,0x82 },
    { AJCXZ,	yloop,	Px, 0xe3 },
    { AJEQ,		yjcond,	Px, 0x74,0x84 },
    { AJGE,		yjcond,	Px, 0x7d,0x8d },
    { AJGT,		yjcond,	Px, 0x7f,0x8f },
    { AJHI,		yjcond,	Px, 0x77,0x87 },
    { AJLE,		yjcond,	Px, 0x7e,0x8e },
    { AJLS,		yjcond,	Px, 0x76,0x86 },
    { AJLT,		yjcond,	Px, 0x7c,0x8c },
    { AJMI,		yjcond,	Px, 0x78,0x88 },
    { AJMP,		yjmp,	Px, 0xff,(04),0xeb,0xe9 },
    { AJNE,		yjcond,	Px, 0x75,0x85 },
    { AJOC,		yjcond,	Px, 0x71,0x81,(00) },
    { AJOS,		yjcond,	Px, 0x70,0x80,(00) },
    { AJPC,		yjcond,	Px, 0x7b,0x8b },
    { AJPL,		yjcond,	Px, 0x79,0x89 },
    { AJPS,		yjcond,	Px, 0x7a,0x8a },
    { ALAHF,	ynone,	Px, 0x9f },
    { ALARL,	yml_rl,	Pm, 0x02 },
    { ALARW,	yml_rl,	Pq, 0x02 },
    { ALEAL,	ym_rl,	Px, 0x8d },
    { ALEAW,	ym_rl,	Pe, 0x8d },
    { ALEAVEL,	ynone,	Px, 0xc9 },
    { ALEAVEW,	ynone,	Pe, 0xc9 },
    { ALOCK,	ynone,	Px, 0xf0 },
    { ALODSB,	ynone,	Pb, 0xac },
    { ALODSL,	ynone,	Px, 0xad },
    { ALODSW,	ynone,	Pe, 0xad },
    { ALONG,	ybyte,	Px, 4 },
    { ALOOP,	yloop,	Px, 0xe2 },
    { ALOOPEQ,	yloop,	Px, 0xe1 },
    { ALOOPNE,	yloop,	Px, 0xe0 },
    { ALSLL,	yml_rl,	Pm, 0x03  },
    { ALSLW,	yml_rl,	Pq, 0x03  },
    { AMOVB,	ymovb,	Pb, 0x88,0x8a,0xb0,0xc6,(00) },
    { AMOVL,	ymovl,	Px, 0x89,0x8b,0x31,0x83,(04),0xb8,0xc7,(00) },
    { AMOVW,	ymovl,	Pe, 0x89,0x8b,0x31,0x83,(04),0xb8,0xc7,(00) },
    { AMOVBLSX,	ymb_rl,	Pm, 0xbe },
    { AMOVBLZX,	ymb_rl,	Pm, 0xb6 },
    { AMOVBWSX,	ymb_rl,	Pq, 0xbe },
    { AMOVBWZX,	ymb_rl,	Pq, 0xb6 },
    { AMOVWLSX,	yml_rl,	Pm, 0xbf },
    { AMOVWLZX,	yml_rl,	Pm, 0xb7 },
    { AMOVSB,	ynone,	Pb, 0xa4 },
    { AMOVSL,	ynone,	Px, 0xa5 },
    { AMOVSW,	ynone,	Pe, 0xa5 },
    { AMULB,	ydivb,	Pb, 0xf6,(04) },
    { AMULL,	ydivl,	Px, 0xf7,(04) },
    { AMULW,	ydivl,	Pe, 0xf7,(04) },
    { ANAME },
    { ANEGB,	yscond,	Px, 0xf6,(03) },
    { ANEGL,	yscond,	Px, 0xf7,(03) },
    { ANEGW,	yscond,	Pe, 0xf7,(03) },
    { ANOP,		ynop,	Px,0,0 },
    { ANOTB,	yscond,	Px, 0xf6,(02) },
    { ANOTL,	yscond,	Px, 0xf7,(02) },
    { ANOTW,	yscond,	Pe, 0xf7,(02) },
    { AORB,		yxorb,	Pb, 0x0c,0x80,(01),0x08,0x0a },
    { AORL,		yxorl,	Px, 0x83,(01),0x0d,0x81,(01),0x09,0x0b },
    { AORW,		yxorl,	Pe, 0x83,(01),0x0d,0x81,(01),0x09,0x0b },
    { AOUTB,	yin,	Pb, 0xe6,0xee },
    { AOUTL,	yin,	Px, 0xe7,0xef },
    { AOUTW,	yin,	Pe, 0xe7,0xef },
    { AOUTSB,	ynone,	Pb, 0x6e },
    { AOUTSL,	ynone,	Px, 0x6f },
    { AOUTSW,	ynone,	Pe, 0x6f },
    { APOPAL,	ynone,	Px, 0x61 },
    { APOPAW,	ynone,	Pe, 0x61 },
    { APOPFL,	ynone,	Px, 0x9d },
    { APOPFW,	ynone,	Pe, 0x9d },
    { APOPL,	ypopl,	Px, 0x58,0x8f,(00) },
    { APOPW,	ypopl,	Pe, 0x58,0x8f,(00) },
    { APUSHAL,	ynone,	Px, 0x60 },
    { APUSHAW,	ynone,	Pe, 0x60 },
    { APUSHFL,	ynone,	Px, 0x9c },
    { APUSHFW,	ynone,	Pe, 0x9c },
    { APUSHL,	ypushl,	Px, 0x50,0xff,(06),0x6a,0x68 },
    { APUSHW,	ypushl,	Pe, 0x50,0xff,(06),0x6a,0x68 },
    { ARCLB,	yshb,	Pb, 0xd0,(02),0xc0,(02),0xd2,(02) },
    { ARCLL,	yshl,	Px, 0xd1,(02),0xc1,(02),0xd3,(02),0xd3,(02) },
    { ARCLW,	yshl,	Pe, 0xd1,(02),0xc1,(02),0xd3,(02),0xd3,(02) },
    { ARCRB,	yshb,	Pb, 0xd0,(03),0xc0,(03),0xd2,(03) },
    { ARCRL,	yshl,	Px, 0xd1,(03),0xc1,(03),0xd3,(03),0xd3,(03) },
    { ARCRW,	yshl,	Pe, 0xd1,(03),0xc1,(03),0xd3,(03),0xd3,(03) },
    { AREP,		ynone,	Px, 0xf3 },
    { AREPN,	ynone,	Px, 0xf2 },
    { ARET,		ynone,	Px, 0xc3 },
    { AROLB,	yshb,	Pb, 0xd0,(00),0xc0,(00),0xd2,(00) },
    { AROLL,	yshl,	Px, 0xd1,(00),0xc1,(00),0xd3,(00),0xd3,(00) },
    { AROLW,	yshl,	Pe, 0xd1,(00),0xc1,(00),0xd3,(00),0xd3,(00) },
    { ARORB,	yshb,	Pb, 0xd0,(01),0xc0,(01),0xd2,(01) },
    { ARORL,	yshl,	Px, 0xd1,(01),0xc1,(01),0xd3,(01),0xd3,(01) },
    { ARORW,	yshl,	Pe, 0xd1,(01),0xc1,(01),0xd3,(01),0xd3,(01) },
    { ASAHF,	ynone,	Px, 0x9e },
    { ASALB,	yshb,	Pb, 0xd0,(04),0xc0,(04),0xd2,(04) },
    { ASALL,	yshl,	Px, 0xd1,(04),0xc1,(04),0xd3,(04),0xd3,(04) },
    { ASALW,	yshl,	Pe, 0xd1,(04),0xc1,(04),0xd3,(04),0xd3,(04) },
    { ASARB,	yshb,	Pb, 0xd0,(07),0xc0,(07),0xd2,(07) },
    { ASARL,	yshl,	Px, 0xd1,(07),0xc1,(07),0xd3,(07),0xd3,(07) },
    { ASARW,	yshl,	Pe, 0xd1,(07),0xc1,(07),0xd3,(07),0xd3,(07) },
    { ASBBB,	yxorb,	Pb, 0x1c,0x80,(03),0x18,0x1a },
    { ASBBL,	yxorl,	Px, 0x83,(03),0x1d,0x81,(03),0x19,0x1b },
    { ASBBW,	yxorl,	Pe, 0x83,(03),0x1d,0x81,(03),0x19,0x1b },
    { ASCASB,	ynone,	Pb, 0xae },
    { ASCASL,	ynone,	Px, 0xaf },
    { ASCASW,	ynone,	Pe, 0xaf },
    { ASETCC,	yscond,	Pm, 0x93,(00) },
    { ASETCS,	yscond,	Pm, 0x92,(00) },
    { ASETEQ,	yscond,	Pm, 0x94,(00) },
    { ASETGE,	yscond,	Pm, 0x9d,(00) },
    { ASETGT,	yscond,	Pm, 0x9f,(00) },
    { ASETHI,	yscond,	Pm, 0x97,(00) },
    { ASETLE,	yscond,	Pm, 0x9e,(00) },
    { ASETLS,	yscond,	Pm, 0x96,(00) },
    { ASETLT,	yscond,	Pm, 0x9c,(00) },
    { ASETMI,	yscond,	Pm, 0x98,(00) },
    { ASETNE,	yscond,	Pm, 0x95,(00) },
    { ASETOC,	yscond,	Pm, 0x91,(00) },
    { ASETOS,	yscond,	Pm, 0x90,(00) },
    { ASETPC,	yscond,	Pm, 0x96,(00) },
    { ASETPL,	yscond,	Pm, 0x99,(00) },
    { ASETPS,	yscond,	Pm, 0x9a,(00) },
    { ACDQ,		ynone,	Px, 0x99 },
    { ACWD,		ynone,	Pe, 0x99 },
    { ASHLB,	yshb,	Pb, 0xd0,(04),0xc0,(04),0xd2,(04) },
    { ASHLL,	yshl,	Px, 0xd1,(04),0xc1,(04),0xd3,(04),0xd3,(04) },
    { ASHLW,	yshl,	Pe, 0xd1,(04),0xc1,(04),0xd3,(04),0xd3,(04) },
    { ASHRB,	yshb,	Pb, 0xd0,(05),0xc0,(05),0xd2,(05) },
    { ASHRL,	yshl,	Px, 0xd1,(05),0xc1,(05),0xd3,(05),0xd3,(05) },
    { ASHRW,	yshl,	Pe, 0xd1,(05),0xc1,(05),0xd3,(05),0xd3,(05) },
    { ASTC,		ynone,	Px, 0xf9 },
    { ASTD,		ynone,	Px, 0xfd },
    { ASTI,		ynone,	Px, 0xfb },
    { ASTOSB,	ynone,	Pb, 0xaa },
    { ASTOSL,	ynone,	Px, 0xab },
    { ASTOSW,	ynone,	Pe, 0xab },
    { ASUBB,	yxorb,	Pb, 0x2c,0x80,(05),0x28,0x2a },
    { ASUBL,	yaddl,	Px, 0x83,(05),0x2d,0x81,(05),0x29,0x2b },
    { ASUBW,	yaddl,	Pe, 0x83,(05),0x2d,0x81,(05),0x29,0x2b },
    { ASYSCALL,	ynone,	Px, 0xcd,100 },
    { ATESTB,	ytestb,	Pb, 0xa8,0xf6,(00),0x84,0x84 },
    { ATESTL,	ytestl,	Px, 0xa9,0xf7,(00),0x85,0x85 },
    { ATESTW,	ytestl,	Pe, 0xa9,0xf7,(00),0x85,0x85 },
    { ATEXT,	ytext,	Px },
    { AVERR,	ydivl,	Pm, 0x00,(04) },
    { AVERW,	ydivl,	Pm, 0x00,(05) },
    { AWAIT,	ynone,	Px, 0x9b },
    { AWORD,	ybyte,	Px, 2 },
    { AXCHGB,	yml_mb,	Pb, 0x86,0x86 },
    { AXCHGL,	yml_ml,	Px, 0x87,0x87 },
    { AXCHGW,	yml_ml,	Pe, 0x87,0x87 },
    { AXLAT,	ynone,	Px, 0xd7 },
    { AXORB,	yxorb,	Pb, 0x34,0x80,(06),0x30,0x32 },
    { AXORL,	yxorl,	Px, 0x83,(06),0x35,0x81,(06),0x31,0x33 },
    { AXORW,	yxorl,	Pe, 0x83,(06),0x35,0x81,(06),0x31,0x33 },

    { AFMOVB,	yfmvx,	Px, 0xdf,(04) },
    { AFMOVBP,	yfmvp,	Px, 0xdf,(06) },
    { AFMOVD,	yfmvd,	Px, 0xdd,(00),0xdd,(02),0xd9,(00),0xdd,(02) },
    { AFMOVDP,	yfmvdp,	Px, 0xdd,(03),0xdd,(03) },
    { AFMOVF,	yfmvf,	Px, 0xd9,(00),0xd9,(02) },
    { AFMOVFP,	yfmvp,	Px, 0xd9,(03) },
    { AFMOVL,	yfmvf,	Px, 0xdb,(00),0xdb,(02) },
    { AFMOVLP,	yfmvp,	Px, 0xdb,(03) },
    { AFMOVV,	yfmvx,	Px, 0xdf,(05) },
    { AFMOVVP,	yfmvp,	Px, 0xdf,(07) },
    { AFMOVW,	yfmvf,	Px, 0xdf,(00),0xdf,(02) },
    { AFMOVWP,	yfmvp,	Px, 0xdf,(03) },
    { AFMOVX,	yfmvx,	Px, 0xdb,(05) },
    { AFMOVXP,	yfmvp,	Px, 0xdb,(07) },

    { AFCOMB },
    { AFCOMBP },
    { AFCOMD,	yfadd,	Px, 0xdc,(02),0xd8,(02),0xdc,(02) },	/* botch */
    { AFCOMDP,	yfadd,	Px, 0xdc,(03),0xd8,(03),0xdc,(03) },	/* botch */
    { AFCOMDPP,	ycompp,	Px, 0xde,(03) },
    { AFCOMF,	yfmvx,	Px, 0xd8,(02) },
    { AFCOMFP,	yfmvx,	Px, 0xd8,(03) },
    { AFCOML,	yfmvx,	Px, 0xda,(02) },
    { AFCOMLP,	yfmvx,	Px, 0xda,(03) },
    { AFCOMW,	yfmvx,	Px, 0xde,(02) },
    { AFCOMWP,	yfmvx,	Px, 0xde,(03) },

    { AFUCOM,	ycompp,	Px, 0xdd,(04) },
    { AFUCOMP,	ycompp, Px, 0xdd,(05) },
    { AFUCOMPP,	ycompp,	Px, 0xda,(13) },

    { AFADDDP,	yfaddp,	Px, 0xde,(00) },
    { AFADDW,	yfmvx,	Px, 0xde,(00) },
    { AFADDL,	yfmvx,	Px, 0xda,(00) },
    { AFADDF,	yfmvx,	Px, 0xd8,(00) },
    { AFADDD,	yfadd,	Px, 0xdc,(00),0xd8,(00),0xdc,(00) },

    { AFMULDP,	yfaddp,	Px, 0xde,(01) },
    { AFMULW,	yfmvx,	Px, 0xde,(01) },
    { AFMULL,	yfmvx,	Px, 0xda,(01) },
    { AFMULF,	yfmvx,	Px, 0xd8,(01) },
    { AFMULD,	yfadd,	Px, 0xdc,(01),0xd8,(01),0xdc,(01) },

    { AFSUBDP,	yfaddp,	Px, 0xde,(05) },
    { AFSUBW,	yfmvx,	Px, 0xde,(04) },
    { AFSUBL,	yfmvx,	Px, 0xda,(04) },
    { AFSUBF,	yfmvx,	Px, 0xd8,(04) },
    { AFSUBD,	yfadd,	Px, 0xdc,(04),0xd8,(04),0xdc,(05) },

    { AFSUBRDP,	yfaddp,	Px, 0xde,(04) },
    { AFSUBRW,	yfmvx,	Px, 0xde,(05) },
    { AFSUBRL,	yfmvx,	Px, 0xda,(05) },
    { AFSUBRF,	yfmvx,	Px, 0xd8,(05) },
    { AFSUBRD,	yfadd,	Px, 0xdc,(05),0xd8,(05),0xdc,(04) },

    { AFDIVDP,	yfaddp,	Px, 0xde,(07) },
    { AFDIVW,	yfmvx,	Px, 0xde,(06) },
    { AFDIVL,	yfmvx,	Px, 0xda,(06) },
    { AFDIVF,	yfmvx,	Px, 0xd8,(06) },
    { AFDIVD,	yfadd,	Px, 0xdc,(06),0xd8,(06),0xdc,(07) },

    { AFDIVRDP,	yfaddp,	Px, 0xde,(06) },
    { AFDIVRW,	yfmvx,	Px, 0xde,(07) },
    { AFDIVRL,	yfmvx,	Px, 0xda,(07) },
    { AFDIVRF,	yfmvx,	Px, 0xd8,(07) },
    { AFDIVRD,	yfadd,	Px, 0xdc,(07),0xd8,(07),0xdc,(06) },

    { AFXCHD,	yfxch,	Px, 0xd9,(01),0xd9,(01) },
    { AFFREE },
    { AFLDCW,	ystcw,	Px, 0xd9,(05),0xd9,(05) },
    { AFLDENV,	ystcw,	Px, 0xd9,(04),0xd9,(04) },
    { AFRSTOR,	ysvrs,	Px, 0xdd,(04),0xdd,(04) },
    { AFSAVE,	ysvrs,	Px, 0xdd,(06),0xdd,(06) },
    { AFSTCW,	ystcw,	Px, 0xd9,(07),0xd9,(07) },
    { AFSTENV,	ystcw,	Px, 0xd9,(06),0xd9,(06) },
    { AFSTSW,	ystsw,	Px, 0xdd,(07),0xdf,0xe0 },
    { AF2XM1,	ynone,	Px, 0xd9, 0xf0 },
    { AFABS,	ynone,	Px, 0xd9, 0xe1 },
    { AFCHS,	ynone,	Px, 0xd9, 0xe0 },
    { AFCLEX,	ynone,	Px, 0xdb, 0xe2 },
    { AFCOS,	ynone,	Px, 0xd9, 0xff },
    { AFDECSTP,	ynone,	Px, 0xd9, 0xf6 },
    { AFINCSTP,	ynone,	Px, 0xd9, 0xf7 },
    { AFINIT,	ynone,	Px, 0xdb, 0xe3 },
    { AFLD1,	ynone,	Px, 0xd9, 0xe8 },
    { AFLDL2E,	ynone,	Px, 0xd9, 0xea },
    { AFLDL2T,	ynone,	Px, 0xd9, 0xe9 },
    { AFLDLG2,	ynone,	Px, 0xd9, 0xec },
    { AFLDLN2,	ynone,	Px, 0xd9, 0xed },
    { AFLDPI,	ynone,	Px, 0xd9, 0xeb },
    { AFLDZ,	ynone,	Px, 0xd9, 0xee },
    { AFNOP,	ynone,	Px, 0xd9, 0xd0 },
    { AFPATAN,	ynone,	Px, 0xd9, 0xf3 },
    { AFPREM,	ynone,	Px, 0xd9, 0xf8 },
    { AFPREM1,	ynone,	Px, 0xd9, 0xf5 },
    { AFPTAN,	ynone,	Px, 0xd9, 0xf2 },
    { AFRNDINT,	ynone,	Px, 0xd9, 0xfc },
    { AFSCALE,	ynone,	Px, 0xd9, 0xfd },
    { AFSIN,	ynone,	Px, 0xd9, 0xfe },
    { AFSINCOS,	ynone,	Px, 0xd9, 0xfb },
    { AFSQRT,	ynone,	Px, 0xd9, 0xfa },
    { AFTST,	ynone,	Px, 0xd9, 0xe4 },
    { AFXAM,	ynone,	Px, 0xd9, 0xe5 },
    { AFXTRACT,	ynone,	Px, 0xd9, 0xf4 },
    { AFYL2X,	ynone,	Px, 0xd9, 0xf1 },
    { AFYL2XP1,	ynone,	Px, 0xd9, 0xf9 },
    { AEND },
    0
};
@

% starts at 1 because of AXXX (but why need AXXX?)
<<[[main()]] sanity check optab>>=
for(i=1; optab[i].as; i++)
    if(i != optab[i].as) {
        diag("phase error in optab: %d", i);
        errorexit();
    }
@


\section{[[Yxxx]]}

<<enum yxxx>>=
enum yxxx {
    Yxxx		= 0,
    Ynone,
    Yi0,
    Yi1,
    Yi8,
    Yi32,

    Yiauto,

    Yal,
    Ycl,
    Yax,
    Ycx,
    Yrb,
    Yrl,
    Yrf,
    Yf0,
    Yrx,
    Ymb,
    Yml,
    Ym,
    Ybr,
    Ycol,

    Ycs,	Yss,	Yds,	Yes,	Yfs,	Ygs,
    Ygdtr,	Yidtr,	Yldtr,	Ymsw,	Ytask,
    Ycr0,	Ycr1,	Ycr2,	Ycr3,	Ycr4,	Ycr5,	Ycr6,	Ycr7,
    Ydr0,	Ydr1,	Ydr2,	Ydr3,	Ydr4,	Ydr5,	Ydr6,	Ydr7,
    Ytr0,	Ytr1,	Ytr2,	Ytr3,	Ytr4,	Ytr5,	Ytr6,	Ytr7,

    Ymax,
};
@

\section{[[Zxxx]]}

<<enum zxxx>>=
enum zxxx {
    Zxxx		= 0,

    Zlit,
    Z_rp,
    Zbr,
    Zcall,
    Zib_,
    Zib_rp,
    Zibo_m,
    Zil_,
    Zil_rp,
    Zilo_m,
    Zjmp,
    Zloop,
    Zm_o,
    Zm_r,
    Zaut_r,
    Zo_m,
    Zpseudo,
    Zr_m,
    Zrp_,
    Z_ib,
    Z_il,
    Zm_ibo,
    Zm_ilo,
    Zib_rr,
    Zil_rr,
    Zclr,
    Zbyte,
    Zmov,
    Zmax,
};
@

\section{[[yxxx]]}

<<global ynone>>=
byte	ynone[] =
{
    Ynone,	Ynone,	Zlit,	1,
    0
};
@

<<global ytext>>=
byte	ytext[] =
{
    Ymb,	Yi32,	Zpseudo,1,
    0
};
@

<<global ynop>>=
byte	ynop[] =
{
    Ynone,	Ynone,	Zpseudo,1,
    Ynone,	Yml,	Zpseudo,1,
    Ynone,	Yrf,	Zpseudo,1,
    Yml,	Ynone,	Zpseudo,1,
    Yrf,	Ynone,	Zpseudo,1,
    0
};
@

<<global yxorb>>=
byte	yxorb[] =
{
    Yi32,	Yal,	Zib_,	1,
    Yi32,	Ymb,	Zibo_m,	2,
    Yrb,	Ymb,	Zr_m,	1,
    Ymb,	Yrb,	Zm_r,	1,
    0
};
@

<<global yxorl>>=
byte	yxorl[] =
{
    Yi8,	Yml,	Zibo_m,	2,
    Yi32,	Yax,	Zil_,	1,
    Yi32,	Yml,	Zilo_m,	2,
    Yrl,	Yml,	Zr_m,	1,
    Yml,	Yrl,	Zm_r,	1,
    0
};
@

<<global yaddl>>=
byte	yaddl[] =
{
    Yi8,	Yml,	Zibo_m,	2,
    Yi32,	Yax,	Zil_,	1,
    Yi32,	Yml,	Zilo_m,	2,
    Yrl,	Yml,	Zr_m,	1,
    Yml,	Yrl,	Zm_r,	1,
    0
};
@

<<global yincb>>=
byte	yincb[] =
{
    Ynone,	Ymb,	Zo_m,	2,
    0
};
@

<<global yincl>>=
byte	yincl[] =
{
    Ynone,	Yrl,	Z_rp,	1,
    Ynone,	Yml,	Zo_m,	2,
    0
};
@

<<global ycmpb>>=
byte	ycmpb[] =
{
    Yal,	Yi32,	Z_ib,	1,
    Ymb,	Yi32,	Zm_ibo,	2,
    Ymb,	Yrb,	Zm_r,	1,
    Yrb,	Ymb,	Zr_m,	1,
    0
};
@

<<global ycmpl>>=
byte	ycmpl[] =
{
    Yml,	Yi8,	Zm_ibo,	2,
    Yax,	Yi32,	Z_il,	1,
    Yml,	Yi32,	Zm_ilo,	2,
    Yml,	Yrl,	Zm_r,	1,
    Yrl,	Yml,	Zr_m,	1,
    0
};
@

<<global yshb>>=
byte	yshb[] =
{
    Yi1,	Ymb,	Zo_m,	2,
    Yi32,	Ymb,	Zibo_m,	2,
    Ycx,	Ymb,	Zo_m,	2,
    0
};
@

<<global yshl>>=
byte	yshl[] =
{
    Yi1,	Yml,	Zo_m,	2,
    Yi32,	Yml,	Zibo_m,	2,
    Ycl,	Yml,	Zo_m,	2,
    Ycx,	Yml,	Zo_m,	2,
    0
};
@

<<global ytestb>>=
byte	ytestb[] =
{
    Yi32,	Yal,	Zib_,	1,
    Yi32,	Ymb,	Zibo_m,	2,
    Yrb,	Ymb,	Zr_m,	1,
    Ymb,	Yrb,	Zm_r,	1,
    0
};
@

<<global ytestl>>=
byte	ytestl[] =
{
    Yi32,	Yax,	Zil_,	1,
    Yi32,	Yml,	Zilo_m,	2,
    Yrl,	Yml,	Zr_m,	1,
    Yml,	Yrl,	Zm_r,	1,
    0
};
@

<<global ymovb>>=
byte	ymovb[] =
{
    Yrb,	Ymb,	Zr_m,	1,
    Ymb,	Yrb,	Zm_r,	1,
    Yi32,	Yrb,	Zib_rp,	1,
    Yi32,	Ymb,	Zibo_m,	2,
    0
};
@

<<global ymovl>>=
byte	ymovl[] =
{
    Yrl,	Yml,	Zr_m,	1,
    Yml,	Yrl,	Zm_r,	1,
    Yi0,	Yrl,	Zclr,	1+2,
//	Yi0,	Yml,	Zibo_m,	2,	// shorter but slower AND $0,dst
    Yi32,	Yrl,	Zil_rp,	1,
    Yi32,	Yml,	Zilo_m,	2,
    Yiauto,	Yrl,	Zaut_r,	2,
    0
};
@
%$

<<global ym_rl>>=
byte	ym_rl[] =
{
    Ym,	Yrl,	Zm_r,	1,
    0
};
@

<<global yrl_m>>=
byte	yrl_m[] =
{
    Yrl,	Ym,	Zr_m,	1,
    0
};
@

<<global ymb_rl>>=
byte	ymb_rl[] =
{
    Ymb,	Yrl,	Zm_r,	1,
    0
};
@

<<global yml_rl>>=
byte	yml_rl[] =
{
    Yml,	Yrl,	Zm_r,	1,
    0
};
@

<<global yrl_ml>>=
byte	yrl_ml[] =
{
    Yrl,	Yml,	Zr_m,	1,
    0
};
@

<<global yml_mb>>=
byte	yml_mb[] =
{
    Yrb,	Ymb,	Zr_m,	1,
    Ymb,	Yrb,	Zm_r,	1,
    0
};
@

<<global yml_ml>>=
byte	yml_ml[] =
{
    Yrl,	Yml,	Zr_m,	1,
    Yml,	Yrl,	Zm_r,	1,
    0
};
@

<<global ydivl>>=
byte	ydivl[] =
{
    Yml,	Ynone,	Zm_o,	2,
    0
};
@

<<global ydivb>>=
byte	ydivb[] =
{
    Ymb,	Ynone,	Zm_o,	2,
    0
};
@

<<global yimul>>=
byte	yimul[] =
{
    Yml,	Ynone,	Zm_o,	2,
    Yi8,	Yrl,	Zib_rr,	1,
    Yi32,	Yrl,	Zil_rr,	1,
    0
};
@

<<global ybyte>>=
byte	ybyte[] =
{
    Yi32,	Ynone,	Zbyte,	1,
    0
};
@

<<global yin>>=
byte	yin[] =
{
    Yi32,	Ynone,	Zib_,	1,
    Ynone,	Ynone,	Zlit,	1,
    0
};
@

<<global yint>>=
byte	yint[] =
{
    Yi32,	Ynone,	Zib_,	1,
    0
};
@

<<global ypushl>>=
byte	ypushl[] =
{
    Yrl,	Ynone,	Zrp_,	1,
    Ym,	Ynone,	Zm_o,	2,
    Yi8,	Ynone,	Zib_,	1,
    Yi32,	Ynone,	Zil_,	1,
    0
};
@

<<global ypopl>>=
byte	ypopl[] =
{
    Ynone,	Yrl,	Z_rp,	1,
    Ynone,	Ym,	Zo_m,	2,
    0
};
@

<<global yscond>>=
byte	yscond[] =
{
    Ynone,	Ymb,	Zo_m,	2,
    0
};
@

<<global yjcond>>=
byte	yjcond[] =
{
    Ynone,	Ybr,	Zbr,	1,
    0
};
@

<<global yloop>>=
byte	yloop[] =
{
    Ynone,	Ybr,	Zloop,	1,
    0
};
@

<<global ycall>>=
byte	ycall[] =
{
    Ynone,	Yml,	Zo_m,	2,
    Ynone,	Ybr,	Zcall,	1,
    0
};
@

<<global yjmp>>=
byte	yjmp[] =
{
    Ynone,	Yml,	Zo_m,	2,
    Ynone,	Ybr,	Zjmp,	1,
    0
};
@

<<global yfmvd>>=
byte	yfmvd[] =
{
    Ym,	Yf0,	Zm_o,	2,
    Yf0,	Ym,	Zo_m,	2,
    Yrf,	Yf0,	Zm_o,	2,
    Yf0,	Yrf,	Zo_m,	2,
    0
};
@

<<global yfmvdp>>=
byte	yfmvdp[] =
{
    Yf0,	Ym,	Zo_m,	2,
    Yf0,	Yrf,	Zo_m,	2,
    0
};
@

<<global yfmvf>>=
byte	yfmvf[] =
{
    Ym,	Yf0,	Zm_o,	2,
    Yf0,	Ym,	Zo_m,	2,
    0
};
@

<<global yfmvx>>=
byte	yfmvx[] =
{
    Ym,	Yf0,	Zm_o,	2,
    0
};
@

<<global yfmvp>>=
byte	yfmvp[] =
{
    Yf0,	Ym,	Zo_m,	2,
    0
};
@

<<global yfadd>>=
byte	yfadd[] =
{
    Ym,	Yf0,	Zm_o,	2,
    Yrf,	Yf0,	Zm_o,	2,
    Yf0,	Yrf,	Zo_m,	2,
    0
};
@

<<global yfaddp>>=
byte	yfaddp[] =
{
    Yf0,	Yrf,	Zo_m,	2,
    0
};
@

<<global yfxch>>=
byte	yfxch[] =
{
    Yf0,	Yrf,	Zo_m,	2,
    Yrf,	Yf0,	Zm_o,	2,
    0
};
@

<<global ycompp>>=
byte	ycompp[] =
{
    Yf0,	Yrf,	Zo_m,	2,	/* botch is really f0,f1 */
    0
};
@

<<global ystsw>>=
byte	ystsw[] =
{
    Ynone,	Ym,	Zo_m,	2,
    Ynone,	Yax,	Zlit,	1,
    0
};
@

<<global ystcw>>=
byte	ystcw[] =
{
    Ynone,	Ym,	Zo_m,	2,
    Ym,	Ynone,	Zm_o,	2,
    0
};
@

<<global ysvrs>>=
byte	ysvrs[] =
{
    Ynone,	Ym,	Zo_m,	2,
    Ym,	Ynone,	Zm_o,	2,
    0
};
@

\section{[[ycover]]}

<<global ycover>>=
char	ycover[Ymax*Ymax];
@

<<[[main()]] set ycover>>=
for(i=0; i<Ymax; i++)
    ycover[i*Ymax + i] = 1;

ycover[Yi0*Ymax + Yi8] = 1;
ycover[Yi1*Ymax + Yi8] = 1;

ycover[Yi0*Ymax + Yi32] = 1;
ycover[Yi1*Ymax + Yi32] = 1;
ycover[Yi8*Ymax + Yi32] = 1;

ycover[Yal*Ymax + Yrb] = 1;
ycover[Ycl*Ymax + Yrb] = 1;
ycover[Yax*Ymax + Yrb] = 1;
ycover[Ycx*Ymax + Yrb] = 1;
ycover[Yrx*Ymax + Yrb] = 1;

ycover[Yax*Ymax + Yrx] = 1;
ycover[Ycx*Ymax + Yrx] = 1;

ycover[Yax*Ymax + Yrl] = 1;
ycover[Ycx*Ymax + Yrl] = 1;
ycover[Yrx*Ymax + Yrl] = 1;

ycover[Yf0*Ymax + Yrf] = 1;

ycover[Yal*Ymax + Ymb] = 1;
ycover[Ycl*Ymax + Ymb] = 1;
ycover[Yax*Ymax + Ymb] = 1;
ycover[Ycx*Ymax + Ymb] = 1;
ycover[Yrx*Ymax + Ymb] = 1;
ycover[Yrb*Ymax + Ymb] = 1;
ycover[Ym*Ymax + Ymb] = 1;

ycover[Yax*Ymax + Yml] = 1;
ycover[Ycx*Ymax + Yml] = 1;
ycover[Yrx*Ymax + Yml] = 1;
ycover[Yrl*Ymax + Yml] = 1;
ycover[Ym*Ymax + Yml] = 1;
@

\section{[[reg]]}
<<global reg>>=
char	reg[D_NONE];
@

<<[[main()]] set reg>>=
for(i=0; i<D_NONE; i++) {
    reg[i] = -1;
    if(i >= D_AL && i <= D_BH)
        reg[i] = (i-D_AL) & 7;
    if(i >= D_AX && i <= D_DI)
        reg[i] = (i-D_AX) & 7;
    if(i >= D_F0 && i <= D_F0+7)
        reg[i] = (i-D_F0) & 7;
}
@

\chapter{Debugging Support}
% Symbol Tables.
% related to import/export table? I don't think so

\section{Symbol table}

<<global symsize>>=
long	symsize;
@


% asmb() -> asmsym()
<<function asmsym>>=
void
asmsym(void)
{
    Prog *p;
    Auto *a;
    Sym *s;
    int h;

    s = lookup("etext", 0);
    if(s->type == STEXT)
        putsymb(s->name, 'T', s->value, s->version);

    for(h=0; h<NHASH; h++)
        for(s=hash[h]; s!=S; s=s->link)
            switch(s->type) {
            case SCONST:
                putsymb(s->name, 'D', s->value, s->version);
                continue;

            case SDATA:
                putsymb(s->name, 'D', s->value+INITDAT, s->version);
                continue;

            case SBSS:
                putsymb(s->name, 'B', s->value+INITDAT, s->version);
                continue;

            case SFILE:
                putsymb(s->name, 'f', s->value, s->version);
                continue;
            }

    for(p=textp; p!=P; p=p->pcond) {
        s = p->from.sym;
        if(s->type != STEXT)
            continue;

        /* filenames first */
        for(a=p->to.autom; a; a=a->link)
            if(a->type == D_FILE)
                putsymb(a->asym->name, 'z', a->aoffset, 0);
            else
            if(a->type == D_FILE1)
                putsymb(a->asym->name, 'Z', a->aoffset, 0);

        putsymb(s->name, 'T', s->value, s->version);

        /* frame, auto and param after */
        putsymb(".frame", 'm', p->to.offset+4, 0);

        for(a=p->to.autom; a; a=a->link)
            if(a->type == D_AUTO)
                putsymb(a->asym->name, 'a', -a->aoffset, 0);
            else
            if(a->type == D_PARAM)
                putsymb(a->asym->name, 'p', a->aoffset, 0);
    }

    if(debug['v'] || debug['n'])
        DBG("symsize = %lud\n", symsize);
}
@




<<function putsymb>>=
void
putsymb(char *s, int t, long v, int ver)
{
    int i, f;

    if(t == 'f')
        s++;
    lput(v);
    if(ver)
        t += 'a' - 'A';
    cput(t+0x80);			/* 0x80 is variable length */

    if(t == 'Z' || t == 'z') {
        cput(s[0]);
        for(i=1; s[i] != 0 || s[i+1] != 0; i += 2) {
            cput(s[i]);
            cput(s[i+1]);
        }
        cput(0);
        cput(0);
        i++;
    }
    else {
        for(i=0; s[i]; i++)
            cput(s[i]);
        cput(0);
    }
    symsize += 4 + 1 + i + 1;

    if(debug['n']) {
        if(t == 'z' || t == 'Z') {
            Bprint(&bso, "%c %.8lux ", t, v);
            for(i=1; s[i] != 0 || s[i+1] != 0; i+=2) {
                f = ((s[i]&0xff) << 8) | (s[i+1]&0xff);
                Bprint(&bso, "/%x", f);
            }
            Bprint(&bso, "\n");
            return;
        }
        if(ver)
            Bprint(&bso, "%c %.8lux %s<%d>\n", t, v, s, ver);
        else
            Bprint(&bso, "%c %.8lux %s\n", t, v, s);
    }
}
@
%>>


\section{Line table}

% lc? line count?
<<global lcsize>>=
long	lcsize;
@

<<function asmlc>>=
void
asmlc(void)
{
    long oldpc, oldlc;
    Prog *p;
    long v, s;

    oldpc = INITTEXT;
    oldlc = 0;
    for(p = firstp; p != P; p = p->link) {
        if(p->line == oldlc || p->as == ATEXT || p->as == ANOP) {
            if(p->as == ATEXT)
                curtext = p;
            if(debug['V'])
                Bprint(&bso, "%6lux %P\n",
                    p->pc, p);
            continue;
        }
        if(debug['V'])
            Bprint(&bso, "\t\t%6ld", lcsize);
        v = (p->pc - oldpc) / MINLC;
        while(v) {
            s = 127;
            if(v < 127)
                s = v;
            cput(s+128);	/* 129-255 +pc */
            if(debug['V'])
                Bprint(&bso, " pc+%ld*%d(%ld)", s, MINLC, s+128);
            v -= s;
            lcsize++;
        }
        s = p->line - oldlc;
        oldlc = p->line;
        oldpc = p->pc + MINLC;
        if(s > 64 || s < -64) {
            cput(0);	/* 0 vv +lc */
            cput(s>>24);
            cput(s>>16);
            cput(s>>8);
            cput(s);
            if(debug['V']) {
                if(s > 0)
                    Bprint(&bso, " lc+%ld(%d,%ld)\n",
                        s, 0, s);
                else
                    Bprint(&bso, " lc%ld(%d,%ld)\n",
                        s, 0, s);
                Bprint(&bso, "%6lux %P\n",
                    p->pc, p);
            }
            lcsize += 5;
            continue;
        }
        if(s > 0) {
            cput(0+s);	/* 1-64 +lc */
            if(debug['V']) {
                Bprint(&bso, " lc+%ld(%ld)\n", s, 0+s);
                Bprint(&bso, "%6lux %P\n",
                    p->pc, p);
            }
        } else {
            cput(64-s);	/* 65-128 -lc */
            if(debug['V']) {
                Bprint(&bso, " lc%ld(%ld)\n", s, 64-s);
                Bprint(&bso, "%6lux %P\n",
                    p->pc, p);
            }
        }
        lcsize++;
    }
    while(lcsize & 1) {
        s = 129;
        cput(s);
        lcsize++;
    }
    if(debug['v'] || debug['V'])
        Bprint(&bso, "lcsize = %ld\n", lcsize);
    Bflush(&bso);
}
@


\chapter{Profiling Support}
% surprising again that it's ld's job to add profiling in plan9

% The code below is interesting because it inserts extra object code using
% directly "AST" constructs, so it helps to understand the data structure!!

% see NOPROF of 8.out.h in Assembler_extra.tex.nw


% where is defined _mainp? lib_core/libc/386/main9p.s
<<[[main()]] adjust INITENTRY if profiling>>=
if(debug['p'])
    INITENTRY = "_mainp";
@

% 8l -p -1
% after dostkoff(), before span() (matters?)
<<[[main()]] call doprofxxx() if profiling>>=
if(debug['p'])
    if(debug['1'])
        doprof1();
    else
        doprof2();
@

\section{[[__mcount[]]]}

% the idea o the code below is to add __mcount array, one index per function,
% and when call it increments the array at the right place.

% todo: who is using this information then? profreport of what?
% git grep __mcount does not seem to return stuff, maybe obsolete code?

<<function doprof1>>=
void
doprof1(void)
{
    Sym *s;
    long n;
    Prog *p, *q;

    DBG("%5.2f profile 1\n", cputime());

    s = lookup("__mcount", 0);
    n = 1;
    for(p = firstp->link; p != P; p = p->link) {
        if(p->as == ATEXT) {
            q = prg();
            q->line = p->line;

            q->link = datap;
            datap = q;

            //asm: DATA __mcount ??? array? why need to declare it here too?
            q->as = ADATA;
            q->from.type = D_EXTERN;
            q->from.offset = n*4;
            q->from.sym = s; // __mcount
            q->from.scale = 4;  // NOSPLIT?
            q->to = p->from;
            q->to.type = D_CONST;

            q = prg();
            q->line = p->line;
            q->pc = p->pc;

            q->link = p->link;
            p->link = q;
            p = q;

            //asm: ADDL 1, __mcount[n]?
            p->as = AADDL;
            p->from.type = D_CONST;
            p->from.offset = 1;
            p->to.type = D_EXTERN;
            p->to.sym = s;
            p->to.offset = n*4 + 4;

            n += 2;
            continue;
        }
    }

    q = prg();
    q->line = 0;

    q->link = datap;
    datap = q;

    //asm: DATA __mcount ???
    q->as = ADATA;
    q->from.type = D_EXTERN;
    q->from.sym = s;
    q->from.scale = 4;  // NOSPLIT?
    q->to.type = D_CONST;
    q->to.offset = n;

    s->type = SBSS;
    // 4 bytes counter for each functions
    s->value = n*4;
}
@

\section{[[_profin()]]}

% _profin() is defined by lib_core/libc/port/profile.c
% (_tracin() is defined by you)

% todo: why s2 and s4? why not sin, sout? and pin, pout?
<<function doprof2>>=
void
doprof2(void)
{
    Sym *s2, *s4;
    Prog *p, *q, *q2;
    Prog *ps2, *ps4;

    DBG("%5.2f profile 2\n", cputime());

    <<[[doprof2()]] if embedded tracing>>
    else{
        s2 = lookup("_profin", 0);
        s4 = lookup("_profout", 0);
    }
    if(s2->type != STEXT || s4->type != STEXT) {
       <<[[doprof2()]] if embedded tracing diag()>>
        else
            diag("_profin/_profout not defined");
        return;
    }

    // finding ps2, ps4 = instruction (Prog) of s2 and s4
    ps2 = P;
    ps4 = P;
    for(p = firstp; p != P; p = p->link) {
        if(p->as == ATEXT) {
            if(p->from.sym == s2) {
                // do not profile the profling function itself ...
                p->from.scale = NOPROF;
                ps2 = p;
            }
            if(p->from.sym == s4) {
                p->from.scale = NOPROF;
                ps4 = p;
            }
        }
    }

    for(p = firstp; p != P; p = p->link) {
        if(p->as == ATEXT) {
            curtext = p;

            <<[[doprof2()]] if NOPROF p>>

            /*
             * JMPL	profin
             */
            q = prg();
            q->line = p->line;
            q->pc = p->pc;
            q->link = p->link;

            <<[[doprof2()]] if embedded tracing ATEXT instrumentation>>
             else
                p->link = q;
            p = q;
            //asm: CALL _profin
            p->as = ACALL;
            p->to.type = D_BRANCH;
            p->pcond = ps2;
            p->to.sym = s2;

        }else if(p->as == ARET) {
            <<[[doprof2()]] if embedded tracing ARET instrumentation>>
            /*
             * RET
             */
            q = prg();
            q->as = ARET;
            q->from = p->from;
            q->to = p->to;
            q->link = p->link;

            p->link = q;

            /*
             * JAL	profout
             */
            //asm: CALL _profout
            p->as = ACALL;
            p->from = zprg.from;
            p->to = zprg.to;
            p->to.type = D_BRANCH;
            p->pcond = ps4;
            p->to.sym = s4;

            p = q;
        }
    }
}
@

<<[[doprof2()]] if NOPROF p>>=
if(p->from.scale & NOPROF) {	/* dont profile */
    for(;;) {
        q = p->link;
        if(q == P)
            break;
        if(q->as == ATEXT)
            break;
        p = q;
    }
    continue;
}
@

\section{[[_tracin()]]}

% -p -e, -e for embedded tracing

<<[[doprof2()]] if embedded tracing>>=
if(debug['e']){
    s2 = lookup("_tracein", 0);
    s4 = lookup("_traceout", 0);
}
@

<<[[doprof2()]] if embedded tracing diag()>>=
if(debug['e'])
    diag("_tracein/_traceout not defined %d %d", s2->type, s4->type);
@

<<[[doprof2()]] if embedded tracing ATEXT instrumentation>>=
if(debug['e']){		/* embedded tracing */
    q2 = prg();
    p->link = q2;
    q2->link = q;

    q2->line = p->line;
    q2->pc = p->pc;

    q2->as = AJMP;
    q2->to.type = D_BRANCH;
    q2->to.sym = p->to.sym;
    q2->pcond = q->link;
}
@

<<[[doprof2()]] if embedded tracing ARET instrumentation>>=
/*
 * RET (default)
 */
if(debug['e']){		/* embedded tracing */
    q = prg();
    q->line = p->line;
    q->pc = p->pc;
    q->link = p->link;
    p->link = q;
    p = q;
}
@

\section{[[NOPROF]] attribute}

% from Assembler_extra.tex.nw

\chapter{Nuxiinit ???}

%???

<<global inuxi1>>=
char	inuxi1[1];
@

<<global inuxi2>>=
char	inuxi2[2];
@

<<global inuxi4>>=
char	inuxi4[4];
@


<<global fnuxi8>>=
char	fnuxi8[8];
@

<<global fnuxi4>>=
char	fnuxi4[4];
@

<<function nuxiinit>>=
void
nuxiinit(void)
{
    int i, c;

    for(i=0; i<4; i++) {
        c = find1(0x04030201L, i+1);
        if(i < 2)
            inuxi2[i] = c;
        if(i < 1)
            inuxi1[i] = c;
        inuxi4[i] = c;
        fnuxi4[i] = c;
        fnuxi8[i] = c;
        fnuxi8[i+4] = c+4;
    }
    if(debug['v']) {
        Bprint(&bso, "inuxi = ");
        for(i=0; i<1; i++)
            Bprint(&bso, "%d", inuxi1[i]);
        Bprint(&bso, " ");
        for(i=0; i<2; i++)
            Bprint(&bso, "%d", inuxi2[i]);
        Bprint(&bso, " ");
        for(i=0; i<4; i++)
            Bprint(&bso, "%d", inuxi4[i]);
        Bprint(&bso, "\nfnuxi = ");
        for(i=0; i<4; i++)
            Bprint(&bso, "%d", fnuxi4[i]);
        Bprint(&bso, " ");
        for(i=0; i<8; i++)
            Bprint(&bso, "%d", fnuxi8[i]);
        Bprint(&bso, "\n");
    }
    Bflush(&bso);
}
@


<<function find1>>=
int
find1(long l, int c)
{
    char *p;
    int i;

    p = (char*)&l;
    for(i=0; i<4; i++)
        if(*p++ == c)
            return i;
    return 0;
}
@

<<function find2>>=
//int
//find2(long l, int c)
//{
//    short *p;
//    int i;
//
//    p = (short*)&l;
//    for(i=0; i<4; i+=2) {
//        if(((*p >> 8) & 0xff) == c)
//            return i;
//        if((*p++ & 0xff) == c)
//            return i+1;
//    }
//    return 0;
//}
@




\chapter{[[libmach/]]}

% a bit reverse of linker. linker actually does not use libmach/,
% but the debugger/profiler/emulator do.

% read .o (objects), read .out (binaries)


<<struct Fhdr>>=
/*
 *	Common a.out header describing all architectures
 */
typedef struct Fhdr
{
    char	*name;		/* identifier of executable */
    byte	type;		/* file type - see codes above */
    byte	hdrsz;		/* header size */
    byte	_magic;		/* _MAGIC() magic */
    byte	spare;

    long	magic;		/* magic number */

    uvlong	txtaddr;	/* text address */
    vlong	txtoff;		/* start of text in file */
    uvlong	dataddr;	/* start of data segment */
    vlong	datoff;		/* offset to data seg in file */
    vlong	symoff;		/* offset of symbol table in file */

    uvlong	entry;		/* entry point */

    vlong	sppcoff;	/* offset of sp-pc table in file */
    vlong	lnpcoff;	/* offset of line number-pc table in file */

    long	txtsz;		/* text size */
    long	datsz;		/* size of data seg */
    long	bsssz;		/* size of bss */

    long	symsz;		/* size of symbol table */
    long	sppcsz;		/* size of sp-pc table */
    long	lnpcsz;		/* size of line number-pc table */

} Fhdr;
@

\chapter{Utilities}

\section{[[size]]}

% errort (0 is ok)
<<function size>>=
int
size(char *file)
{
    fdt fd;
    Fhdr f;

    if((fd = open(file, OREAD)) < 0){
        fprint(2, "size: ");
        perror(file);
        return 1;
    }
    if(crackhdr(fd, &f)) {
        print("%ldt + %ldd + %ldb = %ld\t%s\n", f.txtsz, f.datsz,
            f.bsssz, f.txtsz+f.datsz+f.bsssz, file);
        close(fd);
        return 0;
    }
    fprint(2, "size: %s not an a.out\n", file);
    close(fd);
    return 1;
}
@

<<function main (linkers/misc/size.c)>>=
void
main(int argc, char *argv[])
{
    char *err;
    int i;

    ARGBEGIN {
    default:
        fprint(2, "usage: size [a.out ...]\n");
        exits("usage");
    } ARGEND;

    err = nil;
    if(argc == 0)
        if(size("8.out"))
            err = "error";
    for(i=0; i<argc; i++)
        if(size(argv[i]))
            err = "error";
    exits(err);
}
@

\section{[[nm]]}

\section{[[ar]]}

\section{[[strip]]}

\chapter{Advanced Topics}

\section{Overriding symbols, [[DUPOK]]}
% case in kernel where override a previous symbol,
% e.g. sysfatal, werrstr

% DUPOK, x.scale & DUPOK

\section{Export table}

% what this is for?

<<global doexp>>=
// do export table, -x
bool	doexp;
@

<<[[main()]] command line processing>>=
    case 'x':	/* produce export table */
        doexp = true;
        if(argv[1] != nil && argv[1][0] != '-' && !isobjfile(argv[1])){
            a = ARGF();
            if(strcmp(a, "*") == 0)
                allexport = true;
            else
                readundefs(a, SEXPORT);
        }
        break;
@

<<function isobjfile>>=
static int
isobjfile(char *f)
{
    int n, v;
    Biobuf *b;
    char buf1[5], buf2[SARMAG];

    b = Bopen(f, OREAD);
    if(b == nil)
        return 0;
    n = Bread(b, buf1, 5);
    if(n == 5 && (buf1[2] == 1 && buf1[3] == '<' || buf1[3] == 1 && buf1[4] == '<'))
        v = 1;	/* good enough for our purposes */
    else{
        Bseek(b, 0, 0);
        n = Bread(b, buf2, SARMAG);
        v = n == SARMAG && strncmp(buf2, ARMAG, SARMAG) == 0;
    }
    Bterm(b);
    return v;
}
@


<<global EXPTAB>>=
char*	EXPTAB;
@

<<[[main()]] if export table or dynamic module>>=
if(doexp || dlm){
    EXPTAB = "_exporttab";
    zerosig(EXPTAB);
    zerosig("etext");
    zerosig("edata");
    zerosig("end");

   <<[[main()]] if dynamic module>>

    export();
}
@

<<function zerosig>>=
void
zerosig(char *sp)
{
    Sym *s;

    s = lookup(sp, 0);
    s->sig = 0;
}
@


<<global nimports>>=
int nimports;
@

<<global nexports>>=
int nexports;
@

<<function readundefs>>=
void
readundefs(char *f, int t)
{
    int i, n;
    Sym *s;
    Biobuf *b;
    char *l, buf[256], *fields[64];

    if(f == nil)
        return;
    b = Bopen(f, OREAD);
    if(b == nil){
        diag("could not open %s: %r", f);
        errorexit();
    }
    while((l = Brdline(b, '\n')) != nil){
        n = Blinelen(b);
        if(n >= sizeof(buf)){
            diag("%s: line too long", f);
            errorexit();
        }
        memmove(buf, l, n);
        buf[n-1] = '\0';
        n = getfields(buf, fields, nelem(fields), 1, " \t\r\n");
        if(n == nelem(fields)){
            diag("%s: bad format", f);
            errorexit();
        }
        for(i = 0; i < n; i++){
            s = lookup(fields[i], 0);
            s->type = SXREF;
            s->subtype = t;
            if(t == SIMPORT)
                nimports++;
            else
                nexports++;
        }
    }
    Bterm(b);
}
@


<<function export>>=
void
export(void)
{
    int i, j, n, off, nb, sv, ne;
    Sym *s, *et, *str, **esyms;
    Prog *p;
    char buf[NSNAME], *t;

    n = 0;
    for(i = 0; i < NHASH; i++)
        for(s = hash[i]; s != S; s = s->link)
            if(s->type != SXREF && s->type != SUNDEF && (nexports == 0 && s->sig != 0 || s->subtype == SEXPORT || allexport))
                n++;
    esyms = malloc(n*sizeof(Sym*));
    ne = n;
    n = 0;
    for(i = 0; i < NHASH; i++)
        for(s = hash[i]; s != S; s = s->link)
            if(s->type != SXREF && s->type != SUNDEF && (nexports == 0 && s->sig != 0 || s->subtype == SEXPORT || allexport))
                esyms[n++] = s;
    for(i = 0; i < ne-1; i++)
        for(j = i+1; j < ne; j++)
            if(strcmp(esyms[i]->name, esyms[j]->name) > 0){
                s = esyms[i];
                esyms[i] = esyms[j];
                esyms[j] = s;
            }

    nb = 0;
    off = 0;
    et = lookup(EXPTAB, 0);
    if(et->type != 0 && et->type != SXREF)
        diag("%s already defined", EXPTAB);
    et->type = SDATA;
    str = lookup(".string", 0);
    if(str->type == 0)
        str->type = SDATA;
    sv = str->value;
    for(i = 0; i < ne; i++){
        s = esyms[i];
        if(debug['S'])
            s->sig = 0;
        /* Bprint(&bso, "EXPORT: %s sig=%lux t=%d\n", s->name, s->sig, s->type); */

        /* signature */
        p = newdata(et, off, sizeof(long), D_EXTERN);
        off += sizeof(long);
        p->to.offset = s->sig;

        /* address */
        p = newdata(et, off, sizeof(long), D_EXTERN);
        off += sizeof(long);
        p->to.type = D_ADDR;
        p->to.index = D_EXTERN;
        p->to.sym = s;

        /* string */
        t = s->name;
        n = strlen(t)+1;
        for(;;){
            buf[nb++] = *t;
            sv++;
            if(nb >= NSNAME){
                p = newdata(str, sv-NSNAME, NSNAME, D_STATIC);
                p->to.type = D_SCONST;
                memmove(p->to.scon, buf, NSNAME);
                nb = 0;
            }
            if(*t++ == 0)
                break;
        }

        /* name */
        p = newdata(et, off, sizeof(long), D_EXTERN);
        off += sizeof(long);
        p->to.type = D_ADDR;
        p->to.index = D_STATIC;
        p->to.sym = str;
        p->to.offset = sv-n;
    }

    if(nb > 0){
        p = newdata(str, sv-nb, nb, D_STATIC);
        p->to.type = D_SCONST;
        memmove(p->to.scon, buf, nb);
    }

    for(i = 0; i < 3; i++){
        newdata(et, off, sizeof(long), D_EXTERN);
        off += sizeof(long);
    }
    et->value = off;
    if(sv == 0)
        sv = 1;
    str->value = sv;
    exports = ne;
    free(esyms);
}
@

<<function newdata>>=
static Prog*
newdata(Sym *s, int o, int w, int t)
{
    Prog *p;

    p = prg();
    if(edatap == P)
        datap = p;
    else
        edatap->link = p;
    edatap = p;
    p->as = ADATA;
    p->width = w;
    p->from.scale = w;
    p->from.type = t;
    p->from.sym = s;
    p->from.offset = o;
    p->to.type = D_CONST;
    return p;
}
@


\section{Dynamic loading}
% been disabled? can not find man page for dynld anymore, nor dynld.h

<<global dlm>>=
bool dlm;
@

<<[[main()]] command line processing>>=
case 'u':	/* produce dynamically loadable module */
    dlm = true;
    // do not load standard libraries
    debug['l'] = true;

    if(argv[1] != nil && argv[1][0] != '-' && !isobjfile(argv[1]))
        readundefs(ARGF(), SIMPORT);
    break;
@

<<[[asmb()]] if dynamic module magic header adjustment>>=
if(dlm)
    magic |= 0x80000000;
@


<<[[main()]] if dynamic module>>=
if(dlm){
    import();
    HEADTYPE = H_PLAN9;
    INITTEXT = INITDAT = 0;
    INITRND = 8;
    INITENTRY = EXPTAB;
}
@

% import(), pending of export() ?



<<function import>>=
void
import(void)
{
    int i;
    Sym *s;

    for(i = 0; i < NHASH; i++)
        for(s = hash[i]; s != S; s = s->link)
            if(s->sig != 0 && s->type == SXREF && (nimports == 0 || s->subtype == SIMPORT)){
                if(s->value != 0)
                    diag("value != 0 on SXREF");
                undefsym(s);
                if(debug['X'])
                    Bprint(&bso, "IMPORT: %s sig=%lux v=%ld\n", s->name, s->sig, s->value);
                if(debug['S'])
                    s->sig = 0;
            }
}
@

<<enum rxxx>>=
enum rxxx {
    Roffset	= 22,		/* no. bits for offset in relocation address */
    Rindex	= 10,		/* no. bits for index in relocation address */
};
@

% import -> undefsym
<<function undefsym>>=
void
undefsym(Sym *s)
{
    int n;

    n = imports;
    if(s->value != 0)
        diag("value != 0 on SXREF");
    if(n >= 1<<Rindex)
        diag("import index %d out of range", n);
    s->value = n<<Roffset;
    s->type = SUNDEF;
    imports++;
}
@
%>> >>


<<global reloca>>=
Adr*	reloca;
@

<<[[asmb()]] if dynamic module, when iterate from firstp>>=
if(dlm) {
    if(p->as == ATEXT)
        reloca = nil;
    else if(reloca != nil)
        diag("reloc failure: %P", curp);
}
@


% ???
<<[[asmb()]] if dynamic module, before datblk()>>=
if(dlm){
    char buf[8];

    write(cout, buf, INITDAT-textsize);
    textsize = INITDAT;
}
@

<<[[asmb()]] if dynamic module and no symbol table generation>>=
if(dlm){
    seek(cout, HEADR+textsize+datsize, 0);
    asmdyn();
    cflush();
}
@


<<[[entryvalue()]] if dynamic module case>>=
case SDATA:
    if(dlm)
        return s->value+INITDAT;
@














<<struct Reloc>>=
struct Reloc
{
    int n;
    int t;
    byte *m;
    ulong *a;
};
@

<<global rels>>=
Reloc rels;
@


<<[[asmb()]] if dynamic module, call asmdyn()>>=
if(dlm)
    asmdyn();
@

% asmb() -> asmdyn()

<<function asmdyn>>=
void
asmdyn()
{
    int i, n, t, c;
    Sym *s;
    ulong la, ra, *a;
    vlong off;
    byte *m;
    Reloc *r;

    cflush();
    off = seek(cout, 0, 1);
    lput(0);
    t = 0;
    lput(imports);
    t += 4;
    for(i = 0; i < NHASH; i++)
        for(s = hash[i]; s != S; s = s->link)
            if(s->type == SUNDEF){
                lput(s->sig);
                t += 4;
                t += sput(s->name);
            }

    la = 0;
    r = &rels;
    n = r->n;
    m = r->m;
    a = r->a;
    lput(n);
    t += 4;
    for(i = 0; i < n; i++){
        ra = *a-la;
        if(*a < la)
            diag("bad relocation order");
        if(ra < 256)
            c = 0;
        else if(ra < 65536)
            c = 1;
        else
            c = 2;
        cput((c<<6)|*m++);
        t++;
        if(c == 0){
            cput(ra);
            t++;
        }
        else if(c == 1){
            wput(ra);
            t += 2;
        }
        else{
            lput(ra);
            t += 4;
        }
        la = *a++;
    }

    cflush();
    seek(cout, off, 0);
    lput(t);

    DBG("import table entries = %d\n", imports);
    DBG("export table entries = %d\n", exports);
}
@
% >> >>



<<global modemap>>=
int modemap[4] = { 0, 1, -1, 2, };
@



<<[[datblk()]] if dynamic module>>=
if(dlm)
    dynreloc(p->to.sym, l+s+INITDAT, 1);
@

<<function dynreloc>>=
void
dynreloc(Sym *s, ulong v, int abs)
{
    int i, k, n;
    byte *m;
    ulong *a;
    Reloc *r;

    if(s->type == SUNDEF)
        k = abs ? ABSU : RELU;
    else
        k = abs ? ABSD : RELD;
    /* Bprint(&bso, "R %s a=%ld(%lx) %d\n", s->name, v, v, k); */
    k = modemap[k];
    r = &rels;
    n = r->n;
    if(n >= r->t)
        grow(r);
    m = r->m;
    a = r->a;
    for(i = n; i > 0; i--){
        if(v < a[i-1]){	/* happens occasionally for data */
            m[i] = m[i-1];
            a[i] = a[i-1];
        }
        else
            break;
    }
    m[i] = k;
    a[i] = v;
    r->n++;
}
@

<<function grow>>=
static void
grow(Reloc *r)
{
    int t;
    byte *m, *nm;
    ulong *a, *na;

    t = r->t;
    r->t += 64;
    m = r->m;
    a = r->a;
    r->m = nm = malloc(r->t*sizeof(byte));
    r->a = na = malloc(r->t*sizeof(ulong));
    memmove(nm, m, t*sizeof(byte));
    memmove(na, a, t*sizeof(ulong));
    free(m);
    free(a);
}
@

\section{Float}

% 8.out.h

<<function ieeedtof>>=
long
ieeedtof(Ieee *e)
{
    int exp;
    long v;

    if(e->h == 0)
        return 0;
    exp = (e->h>>20) & ((1L<<11)-1L);
    exp -= (1L<<10) - 2L;
    v = (e->h & 0xfffffL) << 3;
    v |= (e->l >> 29) & 0x7L;
    if((e->l >> 28) & 1) {
        v++;
        if(v & 0x800000L) {
            v = (v & 0x7fffffL) >> 1;
            exp++;
        }
    }
    if(exp <= -126 || exp >= 130)
        diag("double fp to single fp overflow");
    v |= ((exp + 126) & 0xffL) << 23;
    v |= e->h & 0x80000000L;
    return v;
}
@

<<function ieeedtod>>=
double
ieeedtod(Ieee *ieeep)
{
    Ieee e;
    double fr;
    int exp;

    if(ieeep->h & (1L<<31)) {
        e.h = ieeep->h & ~(1L<<31);
        e.l = ieeep->l;
        return -ieeedtod(&e);
    }
    if(ieeep->l == 0 && ieeep->h == 0)
        return 0;
    fr = ieeep->l & ((1L<<16)-1L);
    fr /= 1L<<16;
    fr += (ieeep->l>>16) & ((1L<<16)-1L);
    fr /= 1L<<16;
    fr += (ieeep->h & (1L<<20)-1L) | (1L<<20);
    fr /= 1L<<21;
    exp = (ieeep->h>>20) & ((1L<<11)-1L);
    exp -= (1L<<10) - 2L;
    return ldexp(fr, exp);
}
@



<<[[ldobj()]] switch as cases>>=
case AFMOVF:
case AFADDF:
case AFSUBF:
case AFSUBRF:
case AFMULF:
case AFDIVF:
case AFDIVRF:
case AFCOMF:
case AFCOMFP:
    if(skip)
        goto casdef;
    if(p->from.type == D_FCONST) {
        /* size sb 9 max */
        sprint(literal, "$%lux", ieeedtof(&p->from.ieee));
        s = lookup(literal, 0);
        if(s->type == 0) {
            s->type = SBSS;
            s->value = 4;
            t = prg();
            t->as = ADATA;
            t->line = p->line;
            t->from.type = D_EXTERN;
            t->from.sym = s;
            t->from.scale = 4;  // NOSPLIT?
            t->to = p->from;
            if(edatap == P)
                datap = t;
            else
                edatap->link = t;
            edatap = t;
            t->link = P;
        }
        p->from.type = D_EXTERN;
        p->from.sym = s;
        p->from.offset = 0;
    }
    goto casdef;
@

<<[[ldobj()]] switch as cases>>=
case AFMOVD:
case AFADDD:
case AFSUBD:
case AFSUBRD:
case AFMULD:
case AFDIVD:
case AFDIVRD:
case AFCOMD:
case AFCOMDP:
    if(skip)
        goto casdef;
    if(p->from.type == D_FCONST) {
        /* size sb 18 max */
        sprint(literal, "$%lux.%lux",
            p->from.ieee.l, p->from.ieee.h);
        s = lookup(literal, 0);
        if(s->type == 0) {
            s->type = SBSS;
            s->value = 8;
            t = prg();
            t->as = ADATA;
            t->line = p->line;
            t->from.type = D_EXTERN;
            t->from.sym = s;
            t->from.scale = 8;
            t->to = p->from;
            if(edatap == P)
                datap = t;
            else
                edatap->link = t;
            edatap = t;
            t->link = P;
        }
        p->from.type = D_EXTERN;
        p->from.sym = s;
        p->from.offset = 0;
    }
    goto casdef;
@


\section{Extra executable formats}

<<[[main()]] switch HEADTYPE cases>>=
case H_GARBAGE:	/* this is garbage */
    HEADR = 20L+56L;
    if(INITTEXT == -1)
        INITTEXT = 0x40004CL;
    if(INITDAT == -1)
        INITDAT = 0x10000000L;
    if(INITRND == -1)
        INITRND = 0;
    break;
case H_COFF:	/* is unix coff */
    HEADR = 0xd0L;
    if(INITTEXT == -1)
        INITTEXT = 0xd0;
    if(INITDAT == -1)
        INITDAT = 0x400000;
    if(INITRND == -1)
        INITRND = 0;
    break;
case H_COM:	/* MS-DOS .COM */
    HEADR = 0;
    if(INITTEXT == -1)
        INITTEXT = 0x0100;
    if(INITDAT == -1)
        INITDAT = 0;
    if(INITRND == -1)
        INITRND = 4;
    break;
case H_EXE:	/* fake MS-DOS .EXE */
    HEADR = 0x200;
    if(INITTEXT == -1)
        INITTEXT = 0x0100;
    if(INITDAT == -1)
        INITDAT = 0;
    if(INITRND == -1)
        INITRND = 4;
    HEADR += (INITTEXT & 0xFFFF);
    DBG("HEADR = 0x%ld\n", HEADR);
    break;
case H_ELF:	/* elf executable */
    HEADR = rnd(Ehdr32sz+3*Phdr32sz, 16);
    if(INITTEXT == -1)
        INITTEXT = 0x80100020L;
    if(INITDAT == -1)
        INITDAT = 0;
    if(INITRND == -1)
        INITRND = 4096;
    break;
@


<<[[asmb()]] switch HEADTYPE (to position after text) cases>>=
case H_GARBAGE:
    seek(cout, rnd(HEADR+textsize, 8192), 0);
    break;
case H_COFF:
    textsize = rnd(HEADR+textsize, 4096)-HEADR;
    seek(cout, textsize+HEADR, 0);
    break;
case H_ELF: // like H_PLAN9
    seek(cout, HEADR+textsize, 0);
    break;
case H_COM:
case H_EXE:
    seek(cout, HEADR+rnd(textsize, INITRND), 0);
    break;
@

<<[[asmb()]] switch HEADTYPE (for symbol table generation) cases>>=
case H_GARBAGE:
case H_COFF:
    seek(cout, rnd(HEADR+textsize, INITRND)+datsize, 0);
    break;
//case H_PLAN9:
case H_ELF:
    seek(cout, HEADR+textsize+datsize, 0);
    break;
case H_COM:
case H_EXE:
    debug['s'] = 1;
    break;
@

<<[[asmb()]] switch HEADTYPE (for header generation) cases>>=
default:
case H_GARBAGE:	/* garbage */
    lput(0x160L<<16);		/* magic and sections */
    lput(0L);			/* time and date */
    lput(rnd(HEADR+textsize, 4096)+datsize);
    lput(symsize);			/* nsyms */
    lput((0x38L<<16)|7L);		/* size of optional hdr and flags */
    lput((0413<<16)|0437L);		/* magic and version */
    lput(rnd(HEADR+textsize, 4096));/* sizes */
    lput(datsize);
    lput(bsssize);
    lput(entryvalue());		/* va of entry */
    lput(INITTEXT-HEADR);		/* va of base of text */
    lput(INITDAT);			/* va of base of data */
    lput(INITDAT+datsize);		/* va of base of bss */
    lput(~0L);			/* gp reg mask */
    lput(0L);
    lput(0L);
    lput(0L);
    lput(0L);
    lput(~0L);			/* gp value ?? */
    break;
case H_COFF:	/* unix coff */
    /*
     * file header
     */
    lputl(0x0004014c);		/* 4 sections, magic */
    lputl(0);			/* unix time stamp */
    lputl(0);			/* symbol table */
    lputl(0);			/* nsyms */
    lputl(0x0003001c);		/* flags, sizeof a.out header */
    /*
     * a.out header
     */
    lputl(0x10b);			/* magic, version stamp */
    lputl(rnd(textsize, INITRND));	/* text sizes */
    lputl(datsize);			/* data sizes */
    lputl(bsssize);			/* bss sizes */
    lput(entryvalue());		/* va of entry */
    lputl(INITTEXT);		/* text start */
    lputl(INITDAT);			/* data start */
    /*
     * text section header
     */
    strnput(".text", 8);
    lputl(HEADR);			/* pa */
    lputl(HEADR);			/* va */
    lputl(textsize);		/* text size */
    lputl(HEADR);			/* file offset */
    lputl(0);			/* relocation */
    lputl(0);			/* line numbers */
    lputl(0);			/* relocation, line numbers */
    lputl(0x20);			/* flags text only */
    /*
     * data section header
     */
    strnput(".data", 8);
    lputl(INITDAT);			/* pa */
    lputl(INITDAT);			/* va */
    lputl(datsize);			/* data size */
    lputl(HEADR+textsize);		/* file offset */
    lputl(0);			/* relocation */
    lputl(0);			/* line numbers */
    lputl(0);			/* relocation, line numbers */
    lputl(0x40);			/* flags data only */
    /*
     * bss section header
     */
    strnput(".bss", 8);
    lputl(INITDAT+datsize);		/* pa */
    lputl(INITDAT+datsize);		/* va */
    lputl(bsssize);			/* bss size */
    lputl(0);			/* file offset */
    lputl(0);			/* relocation */
    lputl(0);			/* line numbers */
    lputl(0);			/* relocation, line numbers */
    lputl(0x80);			/* flags bss only */
    /*
     * comment section header
     */
    strnput(".comment", 8);
    lputl(0);			/* pa */
    lputl(0);			/* va */
    lputl(symsize+lcsize);		/* comment size */
    lputl(HEADR+textsize+datsize);	/* file offset */
    lputl(HEADR+textsize+datsize);	/* offset of syms */
    lputl(HEADR+textsize+datsize+symsize);/* offset of line numbers */
    lputl(0);			/* relocation, line numbers */
    lputl(0x200);			/* flags comment only */
    break;
case H_COM:
    /* MS-DOS .COM */
    break;
case H_EXE:
    /* fake MS-DOS .EXE */
    v = rnd(HEADR+textsize, INITRND)+datsize;
    wputl(0x5A4D);			/* 'MZ' */
    wputl(v % 512);			/* bytes in last page */
    wputl(rnd(v, 512)/512);		/* total number of pages */
    wputl(0x0000);			/* number of reloc items */
    v = rnd(HEADR-(INITTEXT & 0xFFFF), 16);
    wputl(v/16);			/* size of header */
    wputl(0x0000);			/* minimum allocation */
    wputl(0xFFFF);			/* maximum allocation */
    wputl(0x0000);			/* initial ss value */
    wputl(0x0100);			/* initial sp value */
    wputl(0x0000);			/* complemented checksum */
    v = entryvalue();
    wputl(v);			/* initial ip value (!) */
    wputl(0x0000);			/* initial cs value */
    wputl(0x0000);
    wputl(0x0000);
    wputl(0x003E);			/* reloc table offset */
    wputl(0x0000);			/* overlay number */
    break;
case H_ELF:
    elf32(I386, ELFDATA2LSB, 0, nil);
    break;
@


\subsection{Elf}

% start text physical address (elf only)
<<global INITTEXTP>>=
long	INITTEXTP = -1;
@

<<[[main()]] command line processing>>=
case 'P':
    a = ARGF();
    if(a)
        INITTEXTP = atolwhex(a);
    break;
@

<<enum _anon_ (linkers/8l/elf.h)>>=
enum {
    Ehdr32sz	= 52,
    Phdr32sz	= 32,
    Shdr32sz	= 40,

    Ehdr64sz	= 64,
    Phdr64sz	= 56,
    Shdr64sz	= 64,
};
@

\subsection{OMach}

%\subsection{PE}
% windows format, see pe.h in golang/src/libmach/

\section{[[8l -E digits]]}

<<[[main()]] if digit INITENTRY>>=
if(!(*INITENTRY >= '0' && *INITENTRY <= '9'))
   lookup(INITENTRY, 0)->type = SXREF;
@
% 0_9 initentry means something special?

<<[[entryvalue()]] if digit INITENTRY>>=
if(*a >= '0' && *a <= '9')
    return atolwhex(a);
@


\chapter{Conclusion}












\appendix

\chapter{Debugging}

\section{[[debug]]}

% hmm actually it's used not just for debugging but also for generic
% options, e.g. for -l, -p, etc in addition to the main use which is -v
<<global debug>>=
bool	debug[128];
@
% why not 256 like in Assembler.tex.nw?

% -A, see diag()

%bso? 
<<global bso>>=
Biobuf	bso;
@

<<[[main()]] debug initialization>>=
Binit(&bso, 1, OWRITE);
listinit(); // fmtinstall()
memset(debug, false, sizeof(debug));
@

<<[[main()]] command line processing>>=
default:
    c = ARGC();
    if(c >= 0 && c < sizeof(debug))
        debug[c] = true;
    break;
@

\section{Fmt}
% dupe with Compiler.tex.nw

% why called listinit??
<<function listinit>>=
void
listinit(void)
{

    fmtinstall('A', Aconv);
    fmtinstall('R', Rconv);
    fmtinstall('D', Dconv);
    fmtinstall('P', Pconv);
    fmtinstall('S', Sconv);
}
@

% defined in ../8c/enam.c, coupling with enum as in 8.out.h
% extern	char*	anames[];

<<function Aconv>>=
// enum<opcode> -> string
int
Aconv(Fmt *fp)
{
    int i;

    i = va_arg(fp->args, int);
    return fmtstrcpy(fp, anames[i]);
}
@

<<global regstr>>=
// coupling with enum regs in 8.out.h
char*	regstr[] =
{
    "AL",		/* [D_AL] */
    "CL",
    "DL",
    "BL",
    "AH",
    "CH",
    "DH",
    "BH",

    "AX",		/* [D_AX] */
    "CX",
    "DX",
    "BX",
    "SP",
    "BP",
    "SI",
    "DI",

    "F0",		/* [D_F0] */
    "F1",
    "F2",
    "F3",
    "F4",
    "F5",
    "F6",
    "F7",

    "CS",		/* [D_CS] */
    "SS",
    "DS",
    "ES",
    "FS",
    "GS",

    "GDTR",		/* [D_GDTR] */
    "IDTR",		/* [D_IDTR] */
    "LDTR",		/* [D_LDTR] */
    "MSW",		/* [D_MSW] */
    "TASK",		/* [D_TASK] */

    "CR0",		/* [D_CR] */
    "CR1",
    "CR2",
    "CR3",
    "CR4",
    "CR5",
    "CR6",
    "CR7",

    "DR0",		/* [D_DR] */
    "DR1",
    "DR2",
    "DR3",
    "DR4",
    "DR5",
    "DR6",
    "DR7",

    "TR0",		/* [D_TR] */
    "TR1",
    "TR2",
    "TR3",
    "TR4",
    "TR5",
    "TR6",
    "TR7",

    "NONE",		/* [D_NONE] */
};
@
% NONE part of it? this can happen? not more part of enum<operand>?

<<function Rconv>>=
// enum<operand_kind(register-only)> -> string
int
Rconv(Fmt *fp)
{
    char str[20];
    int r;

    r = va_arg(fp->args, int);
    if(r >= D_AL && r <= D_NONE)
        snprint(str, sizeof(str), "%s", regstr[r-D_AL]);
    else
        snprint(str, sizeof(str), "gok(%d)", r);

    return fmtstrcpy(fp, str);
}
@
%gok??


% used by PConv and Dconv as Dconv need access to enclosing Prog for branch
<<global bigP>>=
static	Prog	*bigP;
@

<<constant STRINGSZ>>=
STRINGSZ	= 200,
@

<<function Pconv>>=
// Prog -> string
int
Pconv(Fmt *fp)
{
    char str[STRINGSZ];
    Prog *p;

    p = va_arg(fp->args, Prog*);
    bigP = p;
    switch(p->as) {
    case ATEXT:
        // when this happens?
        if(p->from.scale) {
            snprint(str, sizeof(str), "(%ld)	%A	%D,%d,%D",
                p->line, p->as, &p->from, p->from.scale, &p->to);
        } else {
            snprint(str, sizeof(str), "(%ld)	%A	%D,%D",
                p->line, p->as, &p->from, &p->to);
        }
        break;
    case ADATA:
    case AINIT:
    case ADYNT:
        snprint(str, sizeof(str), "(%ld)	%A	%D/%d,%D",
            p->line, p->as, &p->from, p->from.scale, &p->to);
        break;
    default:
        snprint(str, sizeof(str), "(%ld)	%A	%D,%D",
            p->line, p->as, &p->from, &p->to);
        break;
    }
    bigP = P;
    return fmtstrcpy(fp, str);
}
@


<<function Dconv>>=
// Adr -> string
int
Dconv(Fmt *fp)
{
    char str[STRINGSZ+40], s[20];
    Adr *a;
    //enum<operand_kind>
    int i;

    a = va_arg(fp->args, Adr*);
    i = a->type;

    <<[[Dconv()]] if i >= D_INDIR>>

    switch(i) {
    case D_NONE:
        str[0] = '\0';
        break;


    case D_BRANCH:
        if(bigP != P && bigP->pcond != P)
            if(a->sym != S)
                snprint(str, sizeof(str), "%lux+%s", bigP->pcond->pc,
                    a->sym->name);
            else
                snprint(str, sizeof(str), "%lux", bigP->pcond->pc);
        else
            snprint(str, sizeof(str), "%ld(PC)", a->offset);
        break;

    case D_EXTERN:
        snprint(str, sizeof(str), "%s+%ld(SB)", a->sym->name, a->offset);
        break;
    case D_STATIC:
        snprint(str, sizeof(str), "%s<%d>+%ld(SB)", a->sym->name,
            a->sym->version, a->offset);
        break;
    case D_AUTO:
        snprint(str, sizeof(str), "%s+%ld(SP)", a->sym->name, a->offset);
        break;
    case D_PARAM:
        if(a->sym)
            snprint(str, sizeof(str), "%s+%ld(FP)", a->sym->name, a->offset);
        else
            snprint(str, sizeof(str), "%ld(FP)", a->offset);
        break;

    case D_CONST:
        snprint(str, sizeof(str), "$%ld", a->offset);
        break;
    case D_FCONST:
        snprint(str, sizeof(str), "$(%.8lux,%.8lux)", a->ieee.h, a->ieee.l);
        break;
    case D_SCONST:
        snprint(str, sizeof(str), "$\"%S\"", a->scon);
        break;

    case D_ADDR:
        a->type = a->index;
        a->index = D_NONE;
        snprint(str, sizeof(str), "$%D", a);
        a->index = a->type;
        a->type = D_ADDR;
        goto conv;

    default:
        snprint(str, sizeof(str), "%R", i);
        break;

    }
brk:
    if(a->index != D_NONE) {
        snprint(s, sizeof(s), "(%R*%d)", a->index, a->scale);
        strcat(str, s);
    }
conv:
    return fmtstrcpy(fp, str);
}
@
% todo: could simplify flow, those brk: conv: and goto are ugly,
% copy paste a bit and avoid complex flow instead

%???
<<[[Dconv()]] if i >= D_INDIR>>=
if(i >= D_INDIR) {
    if(a->offset)
        snprint(str, sizeof(str), "%ld(%R)", a->offset, i-D_INDIR);
    else
        snprint(str, sizeof(str), "(%R)", i-D_INDIR);
    goto brk;
}
@


%????  %S not used that much here, but used a lot in optable, for things
% like MOV%S, means MOVL, MOVB, MOVW?
% for D_SCONST ?? but what is D_SCONST?
<<function Sconv>>=
// ?? -> string
int
Sconv(Fmt *fp)
{
    int i, c;
    char str[30], *p, *a;

    a = va_arg(fp->args, char*);
    p = str;
    for(i=0; i<sizeof(double); i++) {
        c = a[i] & 0xff;
        if(c >= 'a' && c <= 'z' ||
           c >= 'A' && c <= 'Z' ||
           c >= '0' && c <= '9') {
            *p++ = c;
            continue;
        }
        *p++ = '\\';

        switch(c) {
        default:
            if(c < 040 || c >= 0177)
                break;	/* not portable */
            p[-1] = c;
            continue;
        case 0:
            *p++ = 'z';
            continue;
        case '\\':
        case '"':
            *p++ = c;
            continue;
        case '\n':
            *p++ = 'n';
            continue;
        case '\t':
            *p++ = 't';
            continue;
        }
        *p++ = (c>>6) + '0';
        *p++ = ((c>>3) & 7) + '0';
        *p++ = (c & 7) + '0';
    }
    *p = 0;
    return fmtstrcpy(fp, str);
}
@
% what the fuck is this?

\section{[[8l -v]] and [[DBG()]]}

%used to have lots of code like:
%if(debug['v']) {
%    Bprint(&bso, "HEADER = -H0x%ld -T0x%lux -D0x%lux -R0x%lux\n",
%        HEADTYPE, INITTEXT, INITDAT, INITRND);
%    Bflush(&bso);
%}
% (The Bflush was outside the if, but makes more sense like this I think)
%but better to have a DBG macro for this

<<macro DBG>>=
#define DBG if(debug['v']) mylog
@

<<function log>>=
void mylog(char *fmt, ...) {

    va_list arg;

    va_start(arg, fmt);
    Bvprint(&bso, fmt, arg);
    va_end(arg);
    Bflush(&bso);
}
@

\section{[[8l -a]]}
% print object code in assembly language with addresses?

\section{[[8l -9 -B -9]]}
% dead?

<<constant DEFAULT>>=
#define	DEFAULT	'9'
@

% obsolete?
<<[[main()]] adjust HEADTYPE if debug flags>>=
if(!debug['9'] && !debug['U'] && !debug['B'])
    debug[DEFAULT] = true;

if(HEADTYPE == -1) {
    if(debug['U'])
        HEADTYPE = 1;
    if(debug['B'])
        HEADTYPE = 2;
    if(debug['9'])
        HEADTYPE = 2;
}
@


\chapter{Profiling}

% had lots of cputime() too in calls to DBG, so a form of profiling

<<[[main()]] profile report>>=
if(debug['v']) {
    Bprint(&bso, "%5.2f cpu time\n", cputime());
    Bprint(&bso, "%ld symbols\n", nsymbol);
    Bprint(&bso, "%ld memory used\n", thunk);
    Bprint(&bso, "%d sizeof adr\n", sizeof(Adr));
    Bprint(&bso, "%d sizeof prog\n", sizeof(Prog));
    Bflush(&bso);
}
@

\chapter{Error Managment}

<<global nerrors>>=
int	nerrors = 0;
@

<<function errorexit>>=
void
errorexit(void)
{

    if(nerrors) {
        if(cout >= 0)
            remove(outfile);
        exits("error");
    }
    exits(0);
}
@


% could use TNAME here too?
<<function diag>>=
void
diag(char *fmt, ...)
{
    char buf[STRINGSZ];
    char *tn;
    va_list arg;

    tn = "??none??";
    if(curtext != P && curtext->from.sym != S)
        tn = curtext->from.sym->name;
    va_start(arg, fmt);
    vseprint(buf, buf+sizeof(buf), fmt, arg);
    va_end(arg);
    print("%s: %s\n", tn, buf);

    nerrors++;
    if(nerrors > 20 && !debug['A']) {
        print("too many errors\n");
        errorexit();
    }
}
@

\chapter{Libc}

\section{Memory managmnent}
% same in Assembler

<<global hunk>>=
char*	hunk;
@

<<global nhunk>>=
long	nhunk;
@
% = 0??

<<global thunk>>=
long	thunk;
@

<<constant NHUNK>>=
NHUNK		= 100000,
@


% not sure why don't use libc malloc and do low-level sbrk ...
% to optimize things? as they do no free?
<<function gethunk>>=
void
gethunk(void)
{
    char *h;
    long nh;

    nh = NHUNK;
    if(thunk >= 5L*NHUNK) {
        nh = 5L*NHUNK;
        if(thunk >= 25L*NHUNK)
            nh = 25L*NHUNK;
    }
    h = sbrk(nh);
    if(h == (char*)-1) {
        diag("out of memory");
        errorexit();
    }
    hunk = h;
    nhunk = nh;
    thunk += nh;
}
@



<<function malloc>>=
/*
 * fake malloc
 */
void*
malloc(ulong n)
{
    void *p;

    // upper_round(n, 8)
    while(n & 7)
        n++;

    while(nhunk < n)
        gethunk();
    p = hunk;
    nhunk -= n;
    hunk += n;
    return p;
}
@

% no free ...  hmmm
<<function free>>=
void
free(void *p)
{
    USED(p);
}
@

% not sure why but if redefine malloc and free then have to
% redefine this func too, otherwise get a link error
<<function setmalloctag>>=
//@Scheck: looks dead, but because we redefine malloc/free we must also redefine that
void setmalloctag(void *v, ulong pc)
{
    USED(v, pc);
}
@





\section{Buffer managmnent}

<<function readsome>>=
byte*
readsome(int f, byte *buf, byte *good, byte *stop, int max)
{
    int n;

    n = stop - good;
    memmove(buf, good, stop - good);
    stop = buf + n;
    n = MAXIO - n;
    if(n > max)
        n = max;
    n = read(f, stop, n);
    if(n <= 0)
        return 0;
    return stop + n;
}
@





<<struct Buf>>=
union Buf
{
    struct
    {
        char	obuf[MAXIO];			/* output buffer */
        byte	ibuf[MAXIO];			/* input buffer */
    } u;
    char	dbuf[1];
};
@

<<global buf>>=
union Buf buf;
@


<<constant MAXIO>>=
MAXIO		= 8192,
@




<<constant cbuf>>=
#define	cbuf	u.obuf
@

<<constant xbuf>>=
#define	xbuf	u.ibuf
@

<<global cbc>>=
int	cbc;
@

<<global cbp>>=
char*	cbp;
@

<<function cput>>=
#define	cput(c)\
    { *cbp++ = c;\
    if(--cbc <= 0)\
        cflush(); }
@

% in the end print in cout
<<function cflush>>=
void
cflush(void)
{
    int n;

    n = sizeof(buf.cbuf) - cbc;
    if(n)
        write(cout, buf.cbuf, n);
    cbp = buf.cbuf;
    cbc = sizeof(buf.cbuf);
}
@


% xxxl means left? little endian?


<<function wputl>>=
/* these need to take long arguments to be compatible with elf.c */
void
wputl(long w)
{
    cput(w);
    cput(w>>8);
}
@

<<function wput>>=
void
wput(long w)
{
    cput(w>>8);
    cput(w);
}
@

<<function lput>>=
void
lput(long l)
{
    cput(l>>24);
    cput(l>>16);
    cput(l>>8);
    cput(l);
}
@

<<function lputl>>=
void
lputl(long l)
{
    cput(l);
    cput(l>>8);
    cput(l>>16);
    cput(l>>24);
}
@

<<function llput>>=
void
llput(vlong v)
{
    lput(v>>32);
    lput(v);
}
@

<<function llputl>>=
void
llputl(vlong v)
{
    lputl(v);
    lputl(v>>32);
}
@

<<function strnput>>=
void
strnput(char *s, int n)
{
    for(; *s && n > 0; s++){
        cput(*s);
        n--;
    }
    while(n > 0){
        cput(0);
        n--;
    }
}
@

\section{File managment}

<<function fileexists>>=
int
fileexists(char *s)
{
    byte dirbuf[400];

    /* it's fine if stat result doesn't fit in dirbuf, since even then the file exists */
    return stat(s, dirbuf, sizeof(dirbuf)) >= 0;
}
@

\section{String processing}

% could be put in libc, with the other atoxxx
% atoxx? why a?
<<function atolwhex>>=
long
atolwhex(char *s)
{
    long n;
    int f;

    n = 0;
    f = 0;
    while(*s == ' ' || *s == '\t')
        s++;
    if(*s == '-' || *s == '+') {
        if(*s++ == '-')
            f = 1;
        while(*s == ' ' || *s == '\t')
            s++;
    }
    if(s[0]=='0' && s[1]){
        if(s[1]=='x' || s[1]=='X'){
            s += 2;
            for(;;){
                if(*s >= '0' && *s <= '9')
                    n = n*16 + *s++ - '0';
                else if(*s >= 'a' && *s <= 'f')
                    n = n*16 + *s++ - 'a' + 10;
                else if(*s >= 'A' && *s <= 'F')
                    n = n*16 + *s++ - 'A' + 10;
                else
                    break;
            }
        } else
            while(*s >= '0' && *s <= '7')
                n = n*8 + *s++ - '0';
    } else
        while(*s >= '0' && *s <= '9')
            n = n*10 + *s++ - '0';
    if(f)
        n = -n;
    return n;
}
@

\section{Mathematic functions}

<<function rnd>>=
long
rnd(long v, long r)
{
    long c;

    if(r <= 0)
        return v;
    v += r - 1;
    c = v % r;
    if(c < 0)
        c += r;
    v -= c;
    return v;
}
@

\chapter{Extra Code}

\ifallcode
#include "Linker_extra.tex.nw"
\fi

\chapter{Changelog}
\label{sec:changelog}

\chapter{Glossary}
\label{sec:glossary}

\begin{verbatim}
\end{verbatim}

\chapter*{Indexes}
\addcontentsline{toc}{section}{Index}

%\chapter{References} 
\addcontentsline{toc}{section}{References}

\begin{thebibliography}{99}

\bibitem[1]{wp-literate-programming} Donald Knuth,,
{\em Literate Programming}, 
\url{http://en.wikipedia.org/wiki/Literate\_Program}

\bibitem[2]{noweb} Norman Ramsey,
{\em Noweb}, 
\url{http://www.cs.tufts.edu/~nr/noweb/}

\bibitem[3]{syncweb} Yoann Padioleau,
{\em Syncweb, literate programming meets unison}, 
\url{http://padator.org/software/project-syncweb/readme.txt}

\end{thebibliography}

%******************************************************************************
% Postlude
%******************************************************************************

\end{document}
